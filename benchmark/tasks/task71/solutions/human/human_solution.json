[
  {
    "language": "C++",
    "code": "//AOJ0117\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000000\nint n,m,r[21][21],cost[21][21];\nint x1,x2,y1,y2;\nint d[21];\nint BF(int a,int b){\n  for(int i=0;i<21;i++)d[i]=INF;\n  d[a]=0;\n  for(int i=0;i<n-1;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n        if(r[j][k])\n          d[k]=min(d[k],d[j]+cost[j][k]);\n      }\n    }\n  }\n  return d[b];\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    r[a][b]=1;r[b][a]=1;\n    cost[a][b]=c;cost[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  // cout<<BF(x1,x2)<<endl;\n  //cout<<BF(x2,x1)<<endl;\n  cout<<y1-y2-BF(x1,x2)-BF(x2,x1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint n;\nint dst[100][100];\n\nvoid wf(){\n\tfor(int k=0; k<n; k++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(dst[i][k]+dst[k][j] < dst[i][j]){\n\t\t\t\t\tdst[i][j] = dst[i][k]+dst[k][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdst[i][j] = 1001001001;\n\t\t}\n\t}\n\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdst[a-1][b-1] = c;\n\t\tdst[b-1][a-1] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n\twf();\n\tcout << y1 - y2 - (dst[x1-1][x2-1]+dst[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define MAX_V  21;\n\nstruct edge{ int to, cost; };\ntypedef pair<int , int> P;\n\n\nint V;\n\nint INF = 10000000;\nvector<edge> G[22];\nint d[22];\nint m;\nint a1,b1,c1,d1;\n\nbool operator < (P a,P b){\n\treturn a.first == b.first;\n}\nbool comp(P a,P b){\n\treturn a.first < b.first;\n}\n\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+V, INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\t\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\t//cout<<\" que top \"<<v<<endl;\n\t\tif (d[v] < p.first) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t//cout<<e.to<< \" \"<<d[e.to]<<endl;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tchar t;\n\tint go,come;\n\tcin>>V>>m;\n\trep(i,m){\n\t\tedge tmp;\n\t\tcin>>a1>>t>>b1>>t>>c1>>t>>d1;\n\t\t//cout<<a1<<endl;\n\t\ttmp.to = b1-1; tmp.cost = c1;\n\t\tG[a1-1].push_back(tmp);\n\t\ttmp.to = a1-1; tmp.cost = d1;\n\t\tG[b1-1].push_back(tmp);\n\t}\n\t/*\n\trep(i,V+1){\n\t\trep(j,G[i].size()){\n\t\t\tcout<<i<< \" \"<<G[i][j].to<< \" \"<<G[i][j].cost<<endl;\n\t\t}\n\t}\n\t*/\n\tcin>>a1>>t>>b1>>t>>c1>>t>>d1;\n\tdijkstra(a1-1);\n\tgo = d[b1-1];\n\t\n\t//cout<<\"go  d[i]\\n\";\n\trep(i,V+1){\n\t\t//cout<<i<<\" \"<<d[i]<<endl;\n\t}\n\t\n\t//cout<<\"go = \"<< go<< endl;\n\tdijkstra(b1-1);\n\tcome = d[a1-1];\n\t//cout << \"come = \" << come<< endl;\n\tcout<<c1-d1-go-come<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 25\n#define INF 1<<21\n\nint d[MAX_V][MAX_V];\t//d[u][v]テ」ツ?ッティツセツコe=(u,v)テ」ツ?ョテ」ツつウテ」ツつケテ」ツδ?テ・ツュツ佚・ツ慊ィテ」ツ?療」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッINFテ」ツ??」ツ?淌」ツ??」ツ?妖[i][i]=0テ」ツ?ィテ」ツ?凖」ツつ?\nint n, m;\t//テゥツ?づァツつケテヲツ閉ー\n\nvoid warshall_floyd(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nint main(){\n\tfor(int i = 0; i < MAX_V; i++){\n\t\tfor(int j = 0; j < MAX_V; j++){\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\n\tcin >> n >> m;\n\tchar c;\n\tfor(int i = 0; i < m; i++){\n\t\tint a1, b1, c1, d1;\n\t\tcin >> a1 >> c >> b1 >> c >> c1 >> c >> d1;\n\t\td[a1-1][b1-1] = c1;\n\t\td[b1-1][a1-1]\t= d1;\t\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\t\n\twarshall_floyd();\n\tcout << y1 - y2 - d[x1-1][x2-1] - d[x2-1][x1-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint main(){\n    int cost[22][22]={0};\n    int n;\n    int m;\n    int i;\n    int j;\n    int k;\n    int a;\n    int b;\n    int c;\n    int d;\n    char cc;\n    cin >> n >> m;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = 1<<28;\n    for(i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint dist[21][21];\n\nint main() {\n    int n, m;\n    char cm;\n    cin >> n >> m;\n    for (int i=0; i<21; ++i) {\n        for (int j=0; j<21; ++j) {\n            dist[i][j] = 1e6;\n        }\n    }\n    int a, b, c, d;\n    for (int i=0; i<m; ++i) {\n        cin >> a >> cm >> b >> cm >> c >> cm >> d;\n        dist[a][b] = c;\n        dist[b][a] = d;\n    }\n    int x1, x2, y1, y2;\n    cin >> x1 >> cm >> x2 >> cm >> y1 >> cm >> y2;\n    for (int k=0; k<21; ++k) {\n        for (int i=0; i<21; ++i) {\n            for (int j=0; j<21; ++j) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    cout << y1 - y2 - dist[x1][x2] - dist[x2][x1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_in(int c){int n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in(gcu());}\n_sc(int &n){int c=gcu();return c==EOF?false:(n=in(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\ntemplate <typename H,typename... T> _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\ntemplate <typename T>\n_vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\ntemplate <typename H,typename... T> _vo(H&& h, T&&... t){out(h);out(move(t)...);}\n_vl(){out('\\n');}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\n#define B(n) n = in()\ntypedef unordered_map<int, unordered_map<int, int>> R;\n\nstruct N {\n\tint n, c;\n\tbool operator < (const N &a) const {return a.c < c;}\n};\n\nint min_cost(int s, int g, int n, R &r) {\n\tpriority_queue<N> q;\n\tvector<N> v(n + 1, {0, INT_MAX});\n\tfor (q.push({s,0}) ;!q.empty();) {\n\t\tauto p = q.top(); q.pop();\n\t\tif (p.n == g) return p.c;\n\t\tif (v[p.n].n) continue;\n\t\tv[p.n].n = 1;\n\t\tfor (auto n: r[p.n]) {\n\t\t\tint c = p.c + n.second;\n\t\t\tif (v[n.first].c > c)\n\t\t\t\tq.push({n.first, v[n.first].c = c});\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tint B(n), B(m);\n\tR r;\n\twhile (m--) {\n\t\tint B(a), B(b), B(c), B(d);\n\t\tr[a][b] = c;\n\t\tr[b][a] = d;\n\t}\n\tint B(s), B(g), B(v), B(p);\n\toutl(v - p - min_cost(s, g, n, r) - min_cost(g, s, n, r));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 1001001001;\n\nint main(){\n for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n+1,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\n\tprintf(\"%d\\n\",v-p-kou);\n\treturn 0;\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\n\nusing namespace std;\nint dd[100][100];\nint v[100];\nint n,m;\n\nvoid init(){\n  for(int i = 0 ; i < n ; i++ ){\n  for(int j = 0 ; j < n ; j++ ){\n    dd[i][j] = INF;\n  }\n  }\n}\n\nvoid dijkstra(int s){\n  bool visited[100];\n  fill(visited,visited+100,false);\n  fill(v,v+100,INF);\n  v[s] = 0;\n\n  while(1){\n    int vv = -1;\n\n    for(int i = 0 ; i < n ; i++ ){\n      if(!visited[i] && (vv == -1 || v[i] < v[vv]))vv = i;\n    }\n\n    if(vv == -1)break;\n\n    visited[vv] = true;\n    for(int i = 0 ; i < n ; i++ ){\n      v[i] = min(v[i],v[vv] + dd[vv][i]);\n    }\n  }\n}\n\nint main(){\n\n  cin >> n >> m;\n  n++;\n\n  int a,b,c,d;\n  char ch;\n  init();\n  for(int i = 0 ; i < m ; i++ ){\n       cin >> a >> ch >> b >> ch >> c >> ch >> d;\n    dd[a][b] = c;\n    dd[b][a] = d;\n  }\n  int spos,gpos,mone,hasira;\n  cin >> spos >> ch >> gpos >> ch >> mone >> ch >> hasira;\n  dijkstra(spos);\n  int go,back; \n  go = v[gpos];\n\n  dijkstra(gpos);\n\n  back = v[spos];\n  cout << mone-(go+back+hasira) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define MAX_E 1000\n#define MAX_V 100\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n};\n\nedge es[MAX_E];\nint d[MAX_V];\nint V, E;// V???????????°???E????????°\n\n// O(VE)??§????????????????????????????????§??????\n\nvoid shortest_path(int s){\n\tfor(int i = 1; i <= V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\twhile(true){\n\t\tbool update = false;\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tedge e = es[i];\n\t\t\tif(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif(!update){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint a1, b1, c1, d1, p, q, r, s;\n\t\n\tint ans1, ans2;\n\t\n\tcin >> V >> E;\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n\t\tes[2 * i].from = a1;\n\t\tes[2 * i].to = b1;\n\t\tes[2 * i].cost = c1;\n\t\tes[2 * i + 1].from = b1;\n\t\tes[2 * i + 1].to = a1;\n\t\tes[2 * i + 1].cost = d1;\n\t}\n\t\n\tE *= 2;\n\t\n\tscanf(\"%d,%d,%d,%d\", &p, &q, &r, &s);\n\t\n\tshortest_path(p);\n\tans1 = d[q];\n\tshortest_path(q);\n\tans2 = d[p];\n\tprintf(\"%d\\n\", r - s - ans1 - ans2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint g[20][20];\nint main(){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    for(int i=0;i<a;i++)\n        for(int j=0;j<a;j++)\n            g[i][j]=99999999;\n    for(int i=0;i<b;i++){\n        int c,d,e,f;\n        scanf(\"%d,%d,%d,%d\",&c,&d,&e,&f);\n        g[c-1][d-1]=e;\n        g[d-1][c-1]=f;\n    }\n    int c,d,e,f;\n    scanf(\"%d,%d,%d,%d\",&c,&d,&e,&f);\n    for(int k=0;k<a;k++)\n        for(int i=0;i<a;i++)\n            for(int j=0;j<a;j++)\n                if(g[i][j]>g[i][k]+g[k][j])g[i][j]=g[i][k]+g[k][j];\n    printf(\"%d\\n\",e-f-g[c-1][d-1]-g[d-1][c-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\nint n;\nint dst[100][100];\n\nvoid wf(){\n\tfor(int k=0; k<n; k++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(dst[i][k]+dst[k][j] < dst[i][j]){\n\t\t\t\t\tdst[i][j] = dst[i][k]+dst[k][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdst[i][j] = 1001001001;\n\t\t}\n\t}\n\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdst[a-1][b-1] = c;\n\t\tdst[b-1][a-1] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n\twf();\n\tcout << y1 - y2 - (dst[x1-1][x2-1]+dst[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntypedef std::pair<int, int> pii;\ntypedef std::vector<int> vi;\ntypedef std::vector<double> vd;\ntypedef std::vector<std::string> vs;\ntypedef std::vector<pii> vpii;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { rep(i,v.size()) is >> v[i]; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Array;\ntypedef std::vector<Array> Matrix;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int &src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph t(n);\n  char gomi;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> gomi >> b >> gomi >> c >> gomi >> d;\n    --a, --b;\n    t.addArc(a, b, c);\n    t.addArc(b, a, d);\n  }\n  int s, g, v, p;\n  cin >> s >> gomi >> g >> gomi >> v >> gomi >> p;\n  --s, --g;\n  vector<Weight> dist1 = dijkstra(t, s).first;\n  vector<Weight> dist2 = dijkstra(t, g).first;\n  cout << v - p - dist1[g] - dist2[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n\tint n, m;\n\tint a[1000], b[1000], c[1000], d[1000];\n\tint x1, x2, y1, y2;\n\tint ed[21];\n\tchar gav;\n\tqueue<int> q;\n\n\tcin >> n;\n\tcin >> m;\n\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> a[i] >> gav >> b[i] >> gav >> c[i] >> gav >> d[i];\n\t}\n\n\tcin >> x1 >> gav >> x2 >> gav >> y1 >> gav >> y2;\n\n\tfor (int i = 0; i < 21; i++){\n\t\ted[i] = -1;\n\t}\n\n\ted[x1] = y1;\n\tq.push(x1);\n\twhile (!q.empty()){\n\t\tint no = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tif (a[i] == no){\n\t\t\t\tif (ed[b[i]] < ed[a[i]] - c[i]){\n\t\t\t\t\ted[b[i]] = ed[a[i]] - c[i];\n\t\t\t\t\tq.push(b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[i] == no){\n\t\t\t\tif (ed[a[i]] < ed[b[i]] - d[i]){\n\t\t\t\t\ted[a[i]] = ed[b[i]] - d[i];\n\t\t\t\t\tq.push(a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\ted[x2] -= y2;\n\n\tfor (int i = 0; i < 21; i++){\n\t\tif (i != x2) ed[i] = -1;\n\t}\n\n\tq.push(x2);\n\twhile (!q.empty()){\n\t\tint no = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tif (a[i] == no){\n\t\t\t\tif (ed[b[i]] < ed[a[i]] - c[i]){\n\t\t\t\t\ted[b[i]] = ed[a[i]] - c[i];\n\t\t\t\t\tq.push(b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[i] == no){\n\t\t\t\tif (ed[a[i]] < ed[b[i]] - d[i]){\n\t\t\t\t\ted[a[i]] = ed[b[i]] - d[i];\n\t\t\t\t\tq.push(a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcout << ed[x1] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    if(minPos == -1) break;\n    come[minPos] = 1;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i] != INF) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,INF);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    int start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\nusing namespace std;\n\nint n;\nint con[21][21];\nint cost[21];\nbool used[21];\n\nint dijkstra(int stt, int end) {\n  int a, b, c, d;\n\n  for (int i=1; i<=n; i++) cost[i] = INT_MAX;\n  for (int i=1; i<=n; i++) used[i] = false;\n\n  cost[stt] = 0;\n  used[stt] = true;\n  a = stt;\n  while (1) {\n    for (int i=1; i<=n; i++) {\n      if (con[a][i]) {\n        b = cost[a] + con[a][i];\n        if (b < cost[i]) {\n          cost[i] = b;\n        }\n      }\n    }\n    c = INT_MAX;\n    d = 0;\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && cost[i] < c) {\n        c = cost[i];\n        d = i;\n      }\n    }\n    if (!d) break;\n    used[d] = true;\n    a = d;\n  }\n\n  return cost[end];\n}\n\nint main() {\n  int m, a, b, c, d;\n  int stt, end, budget, pole, ans;\n\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n\n  for (int i=1; i<=n; i++) {\n    for (int j=1; j<=n; j++) {\n      con[i][j] = 0;\n    }\n  }\n\n  for (int i=0; i<m; i++) {\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    con[a][b] = c;\n    con[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &stt, &end, &budget, &pole);\n\n  ans = budget - dijkstra(stt, end) - dijkstra(end, stt) - pole;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint search(int n, int m, int passed[], int path[][3], int start, int end) {\n    int cost = -1, s, c;\n    if (start == end) {\n        return 0;\n    }\n    passed[start - 1] = 1;\n    for (int i = 0; i < m * 2; i++) {\n        if (path[i][0] == start && passed[path[i][1] - 1] == 0) {\n            s = search(n, m, passed, path, path[i][1], end);\n            c = path[i][2] + s;\n            if (s == -1) continue;\n            if (cost == -1) cost = c;\n            else cost = min(cost, c);\n        }\n    }\n    passed[start - 1] = 0;\n    return cost;\n}\n\nint main(void) {\n    int n, m;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    int path[m * 2][3];\n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        path[i * 2][0] = a;\n        path[i * 2][1] = b;\n        path[i * 2][2] = c;\n        path[i * 2 + 1][0] = b;\n        path[i * 2 + 1][1] = a;\n        path[i * 2 + 1][2] = d;\n    }\n    int start, end, y1, y2;\n    scanf(\"%d,%d,%d,%d\", &start, &end, &y1, &y2);\n    int passed[n];\n    for (int i = 0; i < n; i++) passed[i] = 0;\n    int p1 = search(n, m, passed, path, start, end);\n    for (int i = 0; i < n; i++) passed[i] = 0;\n    int p2 = search(n, m, passed, path, end, start);\n    int cost = y1 - y2 - p1 - p2;\n    printf(\"%d\\n\", cost);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define INF 100000010\n\nusing namespace std;\n\nint main(void){\n  int n,m;\n  int a,b,c,d;\n  int s,g,V,P;\n  cin>>n;\n  cin>>m;\n  map<int,int> mp[n];\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;\n    b--;\n    mp[a][b]=c;\n    mp[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n  s--;\n  g--;\n  int iki[n];\n  int kaeri[n];\n  for(int i=0;i<n;i++){\n    iki[i]=INF;\n    kaeri[i]=INF;\n  }\n  iki[s]=0;\n  kaeri[g]=0;\n\n  vector<int> next;\n  vector<int> _next;\n  next.push_back(s);\n  for(int i=0;i<20;i++){\n    _next.clear();\n    for(int j=0;j<next.size();j++){\n      int city=next[j];\n      for(auto iter=mp[city].begin();iter!=mp[city].end();iter++){\n        int city_next_to = iter->first;\n        int cost = iter->second;\n        if(iki[city_next_to]>iki[city]+cost){\n          iki[city_next_to]=iki[city]+cost;\n          _next.push_back(city_next_to);\n        }\n      }\n    }\n    next.clear();\n    copy(_next.begin(),_next.end(),back_inserter(next));\n  }\n\n  next.clear();\n  next.push_back(g);\n  for(int i=0;i<20;i++){\n    _next.clear();\n    for(int j=0;j<next.size();j++){\n      int city=next[j];\n      for(auto iter=mp[city].begin();iter!=mp[city].end();iter++){\n        int city_next_to = iter->first;\n        int cost = iter->second;\n        if(kaeri[city_next_to]>kaeri[city]+cost){\n          kaeri[city_next_to]=kaeri[city]+cost;\n          _next.push_back(city_next_to);\n        }\n      }\n    }\n    next.clear();\n    copy(_next.begin(),_next.end(),back_inserter(next));\n  }\n  cout<<V-P-iki[g]-kaeri[s]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y, y2;\nint w[25][25];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i < 25; i++) {\n\t\tfor (int j = 1; j<25; j++) {\n\t\t\tw[i][j] = 1000000000;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 1; h <= N; h++) {\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y, &y2);\n\tint t = y - w[x1][x2] - y2 - w[x2][x1];\n\tprintf(\"%d\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\t\n\tprintf(\"%d\\n\",v-p-kou);\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nconst int INF = 1e9;\nint main(){\n\tint n,m;\n\tint data[100][100];\n\tREP(i,100) REP(j,100) data[i][j] = INF;\t\n\tREP(i,100) data[i][i] = 0;\n\tcin >> n >> m;\n\tREP(i,m){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--; b--;\n\t\tdata[a][b] = c;\n\t\tdata[b][a] = d;\n\t}\n\tREP(k,n){\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tdata[i][j] = min(data[i][j],data[i][k]+data[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint s,g,v,p;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--;\n\tg--;\n\tcout << v-p-data[s][g]-data[g][s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nclass BellmanFord {\npublic:\n    static const int inf = 1<<29;\n    int m_num;\n    vector<pair<pair<int,int>,int> > m;\n    void init(int n){\n        m_num = n;\n        m.clear();\n    }\n    void add(int u, int v, int e){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num || u == v);\n        m.pb(mp(mp(u,v),e));\n    }\n    int solve(int u, int v, vector<int> *result = NULL){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num);\n        int n = m_num;\n        int nv = m.size();\n        vector<int> c(n, inf);\n        vector<int> r(n, -1);\n        c[u] = 0;\n        REP(i,n){\n            bool flag = true;\n            FOREACH(it,m){\n                int u = it->first.first, v = it->first.second, e = it->second;\n                if(c[u] + e < c[v]){\n                    if(i == n-1){\n                        // negative-weight cycle\n                        return -inf;\n                    }\n                    r[v] = u; c[v] = c[u] + e;\n                    flag = false;\n                }\n            }\n            if(flag) break;\n        }\n        if(result) result[0] = c, result[1] = r;\n        return c[v];\n    }\n};\n\nint main(){\n    int n, m;\n    string s;\n    cin >> n >> m;\n    BellmanFord bf;\n    bf.init(n);\n    REP(i,m){\n        cin >> s;\n        int a,b,c,d;\n        sscanf(s.c_str(), \"%d,%d,%d,%d\", &a, &b, &c, &d);\n        bf.add(a-1,b-1,c);\n        bf.add(b-1,a-1,d);\n    }\n    cin >> s;\n    int fr,to,m1,m2;\n    sscanf(s.c_str(), \"%d,%d,%d,%d\", &fr, &to, &m1, &m2);\n    cout << m1 - (bf.solve(fr-1,to-1) + bf.solve(to-1,fr-1) + m2) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\tif((*i).depart==s){\n\t\t\tq.push((*i).arrival);\n\t\t\tcost.at((*i).arrival)=(*i).cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\t\tif((*i).depart==pos){\n\t\t\t\tif(cost.at((*i).arrival)==INF){\n\t\t\t\t\tq.push((*i).arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at((*i).arrival)>(*i).cost+cost.at(pos)){\n\t\t\t\t\tcost.at((*i).arrival)=(*i).cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\tfor(int i=0;i<cost.size();i++){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tfor(int i=0;i<n+1;i++){\n\t\tcost.push_back(INF);\n\t}\n\t/*\n\tint ret=0;\n\trep(i,n+1){\n\t\tcost.clear();\n\t\tFOR(k,0,n+1){\n\t\t\tcost.push_back(INF);\n\t\t}\n\t\tdijkstra(i);\n\t\tFOR(j,1,n+1){\n\t\t\tif(cost.at(j)!=INF)\n\t\t\tcout<<setw(3)<<i<<\"-(\"<<setw(3)<<cost.at(j)<<\")->\"<<setw(3)<<j<<\", \";\n\t\t\tret++;\n\t\t\tif(ret==3){\n\t\t\t\tcout<<endl;\n\t\t\t\tret=0;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\tfor(int i=0;i<n+1;i++){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-(y2+Cost+cost.at(x1))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(auto i :dat){\n\t\tif(i.depart==s){\n\t\t\tq.push(i.arrival);\n\t\t\tcost.at(i.arrival)=i.cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(auto i:dat){\n\t\t\tif(i.depart==pos){\n\t\t\t\tif(cost.at(i.arrival)==INF){\n\t\t\t\t\tq.push(i.arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at(i.arrival)>i.cost+cost.at(pos)){\n\t\t\t\t\tcost.at(i.arrival)=i.cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(I,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nclass Town\n{\npublic:\n\tTown() : totalCost( 0 ), isGoal( false ), isThrough( false ){}\n\t~Town(){}\n\n\tvoid clear(){\n\t\ttotalCost = 0;\n\t\tisGoal = false;\n\t\tisThrough = false;\n\t}\n\n\tvector< pair< int, int > > routes;\n\tint totalCost;\n\tbool isGoal;\n\tbool isThrough;\n};\n\nint startToGoal( Town* towns, int start, int goal )\n{\n\tint move = start;\n\ttowns[ goal ].isGoal = true;\n\tvector< pair< int, pair< int, int > > > gotoList;\n\n\twhile( !towns[ move ].isGoal ){\n\t\ttowns[ move ].isThrough = true;\n\t\tint count = towns[ move ].routes.size();\n\t\tfor( int i = 0; i < count; ++i ){\n\t\t\tgotoList.push_back( make_pair( move, towns[ move ].routes[ i ] ) );\n\t\t}\n\t\tint minCost = INT_MAX;\n\t\tint here, go, c;\n\t\tvector< pair< int, pair< int, int > > >::iterator itr = gotoList.begin();\n\t\twhile( itr != gotoList.end() ){\n\t\t\there = itr->first;\n\t\t\tgo = itr->second.first;\n\n\t\t\tif( towns[ go ].isThrough ){\n\t\t\t\titr = gotoList.erase( itr );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc = towns[ here ].totalCost + itr->second.second;\n\t\t\tif( c < minCost ){\n\t\t\t\tminCost = c;\n\t\t\t\tmove = go;\n\t\t\t}\n\t\t\t++itr;\n\t\t}\n\t\ttowns[ move ].totalCost = minCost;\n\t}\n\treturn towns[ move ].totalCost;\n}\n\nint main()\n{\n\tint n, m;\n\tint a, b, c, d;\n\tint bugget, cost;\n\tint home, turn;\n\n\tcin >> n;\n\tcin >> m;\n\n\tTown* towns = new Town[ n + 1 ];\n\n\tchar dummy;\n\tfor( int i = 0; i < m; ++i ){\n\t\tcin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n\t\ttowns[ a ].routes.push_back( make_pair( b, c ) );\n\t\ttowns[ b ].routes.push_back( make_pair( a, d ) );\n\t}\n\n\tcin >> home >> dummy >> turn >> dummy >> bugget >> dummy >> cost;\n\n\tcost += startToGoal( towns, home, turn );\n\n\tfor( int i = 0; i < n + 1; ++i ){\n\t\ttowns[ i ].clear();\n\t}\n\n\tcost += startToGoal( towns, turn, home );\n\n\tcout << bugget - cost << endl;\n\n\tdelete[] towns;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][21],int b[],int c,int e,int m){\n  int i;\n  if(c==e){\n    if(b[c]==-1||b[c]>m)\n      b[c]=m;\n  }else if(b[c]==-1||b[c]>m){\n    b[c]=m;\n    for(i=1;i<21;i++){\n      if(a[c][i])\n\tf(a,b,i,e,m+a[c][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  int a[21][21],b[21],m,n,v,w,x,y;\n  memset(a,0,sizeof(a));\n  cin>>n>>m;\n  for(i=0;i<m;i++){\n    int p,q,r,s;\n    scanf(\"%d,%d,%d,%d\",&p,&q,&r,&s);\n    a[p][q]=r;\n    a[q][p]=s;\n  }\n  scanf(\"%d,%d,%d,%d\",&v,&w,&x,&y);\n  memset(b,-1,sizeof(b));\n  f(a,b,v,w,0);\n  x-=b[w];\n  memset(b,-1,sizeof(b));\n  f(a,b,w,v,0);\n  x-=b[v];\n  cout<<x-y<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n\nint main(void){\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int> > town(n,vector<int>(n+1,1000));\n  \n  int a,b,c,d;\n  for(int i = 0 ; i < m ; i ++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    town[--a][--b] = c;\n    town[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  int start = --a;\n  int end = --b;\n  int get = c;\n  int lose = d;\n  \n  int max = 0;\n  /*\n  rep(i,town.size()){\n    cout<<i<< \" : \";\n    rep(j,town[i].size()){\n      printf(\"%4d \",town[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int k = 0 ; k < n ; k ++){\n    for(int i = 0 ; i < n ; i ++){\n      for(int j = 0 ; j < n ; j ++){\n        town[i][j]=min(town[i][j],town[i][k]+town[k][j]);\n      }\n    }\n  }\n  //cout<<town[start][end]<<\" \"<<town[end][start]<<endl;\n  cout<<get-lose-town[start][end]-town[end][start]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> dist(n,vector<int>(n,INF));\n    rep(i,n) dist[i][i] = 0;\n    rep(i,m){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        --a;--b;\n        dist[a][b] = c;\n        dist[b][a] = d;\n    }\n    \n    rep(k,n)rep(i,n)rep(j,n) dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n    \n    int s,g,v,p;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n    --s;--g;\n    cout << (v - dist[s][g] - dist[g][s] - p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include \"stdio.h\"\n\nusing namespace std;\n\nint s, g, V, P;\n\nstruct Road{\n    Road(int t, int c)\n        : to(t), cost(c) {};\n\n    int to;\n    int cost;\n};\n\nint d[20];\nvector<Road> roads[100];\ntypedef pair<int, int> PII;\n\n\nint dijkstra(int start, int goal);\n\nint main(int argc, char const *argv[]){\n    int n, m, a, b, c, d;\n    cin>>n;\n    cin>>m;\n\n    for (int i = 0; i < m; i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);  \n            roads[a].push_back(Road(b, c));\n            roads[b].push_back(Road(a, d));\n    }\n\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);  \n\n    V -= dijkstra(s, g);\n    V -= dijkstra(g, s);\n\n    cout<<V-P<<endl;\n    \n    return 0;\n}\n\n\nint dijkstra(int start, int goal){\n    fill(d, d+20, 1000000);\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n    d[start] = 0;\n    que.push(PII(0, start));\n\n    while (!que.empty()){\n        PII p = que.top();\n        que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < roads[v].size(); i++)\n        {\n            Road r = roads[v][i];\n            if (d[r.to] > d[v] + r.cost)\n            {\n                d[r.to] = d[v] + r.cost;\n                que.push(PII(d[r.to], r.to));\n            }\n        }\n    }\n\n    return d[goal];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1 << 12;\nint main()\n{\n\tint map[21][21];\n\tint n, m,a,b,c,d;\n\tint x, y, xx, yy;\n\tchar s;\n\tcin >> n;\n\tcin >> m;\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int i2 = 0; i2 <= n; i2++){\n\t\t\tmap[i][i2] = INF;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> a >> s >> b >> s >> c >> s >> d;\n\t\tmap[a][b] = c;\n\t\tmap[b][a] = d;\n\t}\n\tfor (int k = 0; k <= n; k++){\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int i2 = 0; i2 <= n; i2++){\n\t\t\t\tmap[i][i2] = min(map[i][i2],map[i][k] + map[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x >> s >> y >> s >> xx >> s >> yy;\n\tint ans = xx - (yy + map[x][y] + map[y][x]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint start,fin,mon,cos;\n\nint solve_go(){\n  queue <int> Q;\n  cost[start] = 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  }\n  return cost[fin];\n}\n\nint solve_ret(){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[fin]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[start];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n){\n    init();\n    for(int i = n+1; i < MAX_C; i++) come[i] = 1;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve_go() - solve_ret() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tll n,m,s,g,v,p;\n\tll pp,kou,min;\n\tll i,j,k;\n\tll ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\t\n\tprintf(\"%lld\\n\",v-p-kou);\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define MG 210000000\n\n main(){\n\t\n\tint n,m;\n\tint i,j;\n\tint a[40],b[40],c[40],d[40];\n\tint e,f,g=MG,h,l;\n\tint k[21][21],flg[21],dk[21],dkn;\n\tint flg2[21],dk2[21];\n\t\n\tscanf(\"%d\",&n);\n\t\n\tscanf(\"%d\",&m);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tdk[i]=MG;\n\t\tflg[i]=0;\n\t\tdk2[i]=MG;\n\t\tflg2[i]=0;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tk[i][j]=MG;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&e,&f,&dkn,&h);\n\t\n\t\n\n\t\n\tfor(i=1;i<=m;i++){\n\t\tk[a[i]][b[i]]=c[i];\n\t\tk[b[i]][a[i]]=d[i];\n\t}\n\t\n\n\tdk[e]=0;\n\t\n\tfor(i=0;i<=n;i++){\n\t\tg=MG;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0 && dk[j]<g){\n\t\t\t\tg=dk[j];\n\t\t\t\tl=j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg[l]=1;\n\t\t\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(dk[l]+k[l][j]<dk[j]){\n\t\t\t\tdk[j]=dk[l]+k[l][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdk2[f]=0;\n\t\n\tfor(i=0;i<=n;i++){\n\t\tg=MG;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg2[j]==0 && dk2[j]<g){\n\t\t\t\tg=dk2[j];\n\t\t\t\tl=j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg2[l]=1;\n\t\t\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(dk2[l]+k[l][j]<dk2[j]){\n\t\t\t\tdk2[j]=dk2[l]+k[l][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdkn=dkn-(h+dk[f]+dk2[e]);\n\t\n\tprintf(\"%d\\n\",dkn);\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nmain(){int n,a,b,c,d,M[22][22],i,j,k;std::cin>>n>>k;for(i=0;i++<n;)for(j=0;j++<n;)M[i][j]=1<<29;for(;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d),k+1;)if(k--){M[a][b]=c;M[b][a]=d;}for(k=0;k++<n;)for(i=0;i++<n;)for(j=0;j++<n;)M[i][j]=std::min(M[i][j],M[i][k]+M[k][j]);printf(\"%d\\n\",c-d-M[a][b]-M[b][a]);}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint i,j,n,m,s,g,v,p,flg[101],ky[101],a,min,ri[21][21],sum;\n\tPP ga[101];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++) scanf(\"%d,%d,%d,%d\",&ga[i].ff,&ga[i].fs,&ga[i].sf,&ga[i].ss);\n\tsort(ga,ga+m);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) ri[i][j]=M;\n\t}\n\tfor(i=1;i<=m;i++) {\n\t\tri[ga[i].ff][ga[i].fs]=ga[i].sf;\n\t\tri[ga[i].fs][ga[i].ff]=ga[i].ss;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t/*printf(\"\\n\");\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) printf(\"%d \",ri[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[s]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum=ky[g];\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[g]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum+=ky[s];\n\tprintf(\"%d\",v-sum-p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nconst ll INF=1e10;\n#define PI 3.141592\n#define pb push_back\n\nvoid show(vector<vll> a){\n    range(i,1,a.size()){\n        range(j,1,a[i].size()){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    int n,m; cin >> n >> m;\n    char ch;\n    vint a(m),b(m),c(m),d(m);\n    vector<vll> K(n+1,vll(n+1,INF));\n    rep(i,m){\n        int a,b; cin >> a >> ch >> b >> ch;\n        cin >> K[a][b] >> ch >> K[b][a];\n    }\n    int s,g,v,p; cin >> s >> ch >> g >> ch >>  v >> ch >> p;\n\n    range(k,1,n+1) range(i,1,n+1) range(j,1,n+1){\n        if(K[i][j]>K[i][k]+K[k][j]){\n            K[i][j]=K[i][k]+K[k][j];\n        }\n    }\n    cout << v-p-K[s][g]-K[g][s] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 10000000\nusing namespace std;\nint glid[21][21];\nint kakutei[21],leng[21];\nint main(void)\n{\n\t//ios::sync_with_stdio(false);\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++) {\n\t\tfor(j=0;j<n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++) glid[i][i]=0;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t}\n\t\t}\n\t}\n\tokane-=leng[finish];\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tswap(start,finish);\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t}\n\t\t}\n\t}\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nstruct Node{\n  //ノードの情報\n  int num;//ノードの番号(あっても意味ない気はするが、一応)\n  vector<pair<int,int>> edge;//各エッジの接続先のノード番号とコスト\n\n  //ダイクストラ法用のデータ\n  bool confirmed=false;\n  int mincost=1000000000;//そのノードへの最小コスト\n};\n\nstruct Node_comparision{\n  bool operator()(const Node node1,const Node node2) const{\n    return node1.mincost > node2.mincost;\n  }\n};\n\n//添字は0にする\n//vectorは参照渡しで基本はする(遅いので)\nvoid dijkstra(vector<Node>& nodes,int r){\n  //優先度の低いものを取りだす(popで)\n  //取り出したものが接続するノードのmincostを取り出す\n  //new演算子で新たに確保しないと、参照先を書き換えしてしまう\n  Node* x= new Node;*x=nodes[r];\n  priority_queue<Node,vector<Node>,Node_comparision> nodes_sub;nodes_sub.push(*x);\n  while(nodes_sub.size()!=0){\n    Node* y= new Node;*y=nodes_sub.top();\n    while(nodes[y->num].confirmed==true){\n      nodes_sub.pop();\n      if(nodes_sub.size()==0) break;\n      *y=nodes_sub.top();\n    }\n    if(nodes_sub.size()==0) break;\n    nodes_sub.pop();\n    nodes[y->num].confirmed=true;\n    int l=y->edge.size();\n    for(int i=0;i<l;i++){\n      nodes[y->edge[i].first].mincost=min(nodes[y->edge[i].first].mincost,y->mincost+y->edge[i].second);\n      Node* z= new Node;*z=nodes[y->edge[i].first];\n      if(nodes[z->num].confirmed==false) nodes_sub.push(*z);\n      delete z;\n    }\n    delete y;\n  }\n  delete x;\n}\n\nint main(){\n  int n,m;cin >> n >> m;\n  vector<Node> Nodes1(n);\n  vector<Node> Nodes2(n);\n  for(int i=0;i<n;i++){Nodes1[i].num=i;}\n  for(int i=0;i<n;i++){Nodes2[i].num=i;}\n\n  for(int i=0;i<m;i++){\n    int a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    Nodes1[a-1].edge.push_back(make_pair(b-1,c));\n    Nodes1[b-1].edge.push_back(make_pair(a-1,d));\n    Nodes2[a-1].edge.push_back(make_pair(b-1,c));\n    Nodes2[b-1].edge.push_back(make_pair(a-1,d));\n  }\n\n  int s,g,v,p;scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n  Nodes1[s-1].mincost=0;Nodes2[g-1].mincost=0;\n\n  dijkstra(Nodes1,s-1);\n  dijkstra(Nodes2,g-1);\n\n  cout << v-p-(Nodes1[g-1].mincost+Nodes2[s-1].mincost) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#define INF 1<<27\nusing namespace std;\nint V,E;\nint cost[301][301];\nbool used[301];\nint d[301];\n\nvoid init(){\n  fill(d,d + 101,INF);\n  fill(used,used + 101,false);\n}\n\nvoid dijkstra(int s){\n  init(); \n  d[s] = 0;\n  while(1){\n    int v = -1;\n    for(int i = 1 ; i < V ; i++ ){\n      if(!used[i] && (v == -1 || d[v] > d[i]))v = i;\n    }\n    if(v == -1)break;\n    used[v] = true;\n\n    for(int i = 1 ; i < V ; i++ ){\n      d[i] = min(d[i],d[v] + cost[v][i]);\n    }\n  }\n}\n\nint main(){\n  cin >> V >> E;\n  V++;\n  fill(cost[0],cost[101],INF);\n  for(int i = 0 ; i < E ; i++ ){\n    int a,b,c,d;\n    char ch;\n    cin >> a >>ch>> b >>ch>> c >>ch>> d;\n\tcost[a][b] = c;\n\tcost[b][a] = d;\n  }\n \n  int s,g,c1,c2;\n  char ch;\n  cin >> s >>ch>> g >>ch>> c1 >>ch>> c2;\n\n  dijkstra(s);\n  int st = d[g];\n\n\n  dijkstra(g);\n  int go = d[s];\n  cout << c1-(st + go + c2) << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 10000000\nusing namespace std;\nint glid[21][21];\nint kakutei[21],leng[21];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++) {\n\t\tfor(j=0;j<n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++) glid[i][i]=0;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t}\n\t\t}\n\t}\n\tokane-=leng[finish];\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tswap(start,finish);\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t}\n\t\t}\n\t}\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n/** Problem0117 : A reward for a Carpenter **/\nconst int INF = 100000;\nint d[20][20];\nint path[20][20];\nint V, E;\n\n\nint main()\n{\n\tint s, g, plus, minus;\n\tchar c;\n\tcin >> V >> E;\n\t\n\tfor (int i=0; i<20; i++)\n\t\tfor (int j=0; j<20; j++) d[i][j] = INF;\n\t\n\tfor (int i=0; i<E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> c >> b >> c >> d[a-1][b-1] >> c >> d[b-1][a-1];\n\t}\n\t\n\tcin >> s >> c >> g >> c >> plus >> c >> minus;\n\ts--; g--;\n\t\n\tfor (int k=0; k<V; k++)\n\t\tfor (int i=0; i<V; i++)\n\t\t\tfor (int j=0; j<V; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\n\tcout << plus - (minus + d[s][g] + d[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\nint n,m;\nint d[30];\nvector<pii> G[500];\n\n#define TO first\n#define COST second\nvoid dijkstra(int s){\n    rep(i,30)d[i]=INF;\n    priority_queue<pii,vector<pii>,greater<pii>> que;\n    que.push(pii(0,s));\n    d[s]=0;\n    \n    while(que.size()){\n        pii q=que.top();\n        que.pop();\n        \n        int v=q.second;\n        if(d[v]<q.first)continue;\n        \n        rep(i,G[v].size()){\n            pii e=G[v][i];\n            if(d[e.TO]>d[v]+e.COST){\n                d[e.TO]=d[v]+e.COST;\n                que.push(pii(d[e.TO],e.TO));\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m;\n    char ch;\n    cin>>n>>m;\n    rep(i,m){\n        int a,b,c,f;\n        cin>>a>>ch>>b>>ch>>c>>ch>>f;\n        G[a].pb(pii(b,c));\n        G[b].pb(pii(a,f));\n    }\n    int a,b,c,f;\n    cin>>a>>ch>>b>>ch>>c>>ch>>f;\n    int s=0;\n    dijkstra(a);\n    s+=d[b];\n    dijkstra(b);\n    s+=d[a];\n    cout<<c-f-s<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\tcin >> N;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &s, &t, &p, &q);\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[s] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - q - D[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n\n#define mp make_pair\n#define pb push_back\n#define REP(i,a,n) for(int i = a;i < (n);i++)\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define all(s) s.begin(), s.end()\n#define rall(s) s.rbegin(), s.rend()\n#define range(x,min,max) ((min) <= (x) && (x) <= (max)) \n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VII;\ntypedef pair<int,int> PII;\n\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\tint n,m,ans;\n\tchar ch;\n\tcin >> n >> m;\n\tVI A(m),B(m),C(m),D(m),cost(n + 1,INT_MAX);\n\trep(i,m)\n\t\tcin >> A[i] >> ch >> B[i] >> ch >> C[i] >> ch >> D[i];\n\tint x1,x2,y1,y2;\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\tpriority_queue< PII, vector< PII >,greater< PII > > que;\n\tque.push(mp(0,x1));\n\tcost[x1] = 0;\n\twhile(!que.empty()){\n\t\tint d = que.top().first,u = que.top().second;\n\t\tque.pop();\n\t\tif(cost[u] < d) continue;\n\t\trep(i,m){\n\t\t\tif(u == A[i] && cost[u] + C[i] < cost[B[i]]){\n\t\t\t\tcost[B[i]] = cost[u] + C[i];\n\t\t\t\tque.push(mp(cost[B[i]],B[i]));\n\t\t\t}\n\t\t\tif(u == B[i] && cost[u] + D[i] < cost[A[i]]){\n\t\t\t\tcost[A[i]] = cost[u] + D[i];\n\t\t\t\tque.push(mp(cost[A[i]],A[i]));\n\t\t\t}\n\t\t}\n\t}\n\tans = cost[x2];\n\trep(i,n + 1){\n\t\tcost[i] = INT_MAX;\n\t}\n\tque.push(mp(0,x2));\n\tcost[x2] = 0;\n\twhile(!que.empty()){\n\t\tint d = que.top().first,u = que.top().second;\n\t\tque.pop();\n\t\tif(cost[u] < d) continue;\n\t\trep(i,m){\n\t\t\tif(u == A[i] && cost[u] + C[i] < cost[B[i]]){\n\t\t\t\tcost[B[i]] = cost[u] + C[i];\n\t\t\t\tque.push(mp(cost[B[i]],B[i]));\n\t\t\t}\n\t\t\tif(u == B[i] && cost[u] + D[i] < cost[A[i]]){\n\t\t\t\tcost[A[i]] = cost[u] + D[i];\n\t\t\t\tque.push(mp(cost[A[i]],A[i]));\n\t\t\t}\n\t\t}\n\t}\n\tans += cost[x1];\n\tans = y1 - y2 - ans;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\naccept?????????\n30?????????????????£???\n\n??????????????????????????????????§£???????????£?????????\n??????????????????????????????????§£???????????£????????§\n??????????????????????§£????????????????????¨????????????\n\nFloyd-Warshall????????¨??????\n#endif\n\n\n#include <iostream>\nusing namespace std;\n\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf=1001001001;\n\nint main() {\n  long long pay,ans;\n  for(int i=0;i<32;i++)\n    for(int j=0;j<32;j++)\n      K[i][j]=inf;\n\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    //cerr << \"read \" << A <<\" \"<< B <<\" \" << C <<\" \" << D<< endl;\n    //?????????\n    K[A][B]=C; // A ??? B ????????????C\n    K[B][A]=D;// B ??? A ????????????D    \n  }\n  /*\n  for(int i=1;i<N+1;i++){//?????§?????????\n    for(int j=1;j<N+1;j++){\n      if(K[i][j]==inf){\n\tcout<<\"i\"<<\" \";\n      }else{\n\tcout<<K[i][j]<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n  */\n  for(int k=1;k<N+1;k++){\n    for(int i=1;i<N+1;i++){\n      for(int j=1;j<N+1;j++){\n\tif(K[i][j]>K[i][k]+K[k][j]){\n\t  K[i][j]=K[i][k]+K[k][j];\n\t}\n      }\n    }/*\n    for(int l=1;l<N+1;l++){//?????§??????2???\n    for(int m=1;m<N+1;m++){\n      if(K[l][m]==inf){\n\tcout<<\"i\"<<\" \";\n      }else{\n\tcout<<K[l][m]<<\" \";\n      }\n    }\n    cout<<endl;\n    } \n    cout<<endl;*/\n  }\n  scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n  pay=K[A][B]+K[B][A];\n  ans=C-D-pay;\n  cout<<ans<<endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nclass Edge\n{\npublic:\n    int to;\n    T cost;\n    Edge(){};\n    Edge(int to0, T cost0){to = to0; cost = cost0;}\n};\n\ntemplate<class T>\nvoid shortestPath(const vector<vector<Edge<T> > >& edges, int start, vector<T>& dist)\n{\n    const T INF = numeric_limits<T>::max();\n    const T EPS = static_cast<T>(1.0e-10);\n\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<T,int>, vector<pair<T,int> >, greater<pair<T,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<T, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first - EPS)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge<T> e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to] - EPS){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<Edge<int> > > edges(n);\n    for(int i=0; i<m; ++i){\n        int a, b, c, d;\n        char z;\n        cin >> a >> z >> b >> z >> c >> z >> d;\n        edges[a-1].push_back(Edge<int>(b-1, c));\n        edges[b-1].push_back(Edge<int>(a-1, d));\n    }\n\n    int x1, x2, y1, y2;\n    char z;\n    cin >> x1 >> z >> x2 >> z >> y1 >> z >> y2;\n\n    vector<int> dist1, dist2;\n    shortestPath(edges, x1-1, dist1);\n    shortestPath(edges, x2-1, dist2);\n\n    int ret = y1 - y2 - dist1[x2-1] - dist2[x1-1];\n    cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n\nint main(void){\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int> > town(n,vector<int>(n+1,1000));\n  \n  int a,b,c,d;\n  for(int i = 0 ; i < m ; i ++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    town[--a][--b] = c;\n    town[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  int start = --a;\n  int end = --b;\n  int get = c;\n  int lose = d;\n  \n  int max = 0;\n  /*\n  rep(i,town.size()){\n    cout<<i<< \" : \";\n    rep(j,town[i].size()){\n      printf(\"%4d \",town[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int k = 0 ; k < n ; k ++){\n    for(int i = 0 ; i < n ; i ++){\n      for(int j = 0 ; j < n ; j ++){\n        town[i][j]=min(town[i][j],town[i][k]+town[k][j]);\n      }\n    }\n  }\n  //cout<<town[start][end]<<\" \"<<town[end][start]<<endl;\n  cout<<get-lose-town[start][end]-town[end][start]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define INF (1<<29)\n\nint dist[30][30];\nint main(){\n    int n, m;\n    char dummy;\n\tcin >> n >> m;\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse      dist[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tint a, b, c, d;\n\t\tcin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n\t\tdist[a-1][b-1] = c;\n\t\tdist[b-1][a-1] = d;\n\t}\t\n\n\n\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> dummy >> x2 >> dummy >> y1 >> dummy >> y2;\n\tcout << (y1 - y2 - dist[x1-1][x2-1] - dist[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nvoid warshallFloyd(int alt[100][100], int n){\n    range(k,0,n + 1){\n        range(i,0,n + 1){\n            range(j,0,n + 1){\n                alt[i][j] = min(alt[i][j], alt[i][k] + alt[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    int a, b, c, d;\n    int n, m;\n    int atl[100][100];\n    rep(i,100) rep(j,100) atl[i][j] = INF;\n    cin >> n >> m;\n    rep(i,m){\n        scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n        atl[a][b] = c;\n        atl[b][a] = d;\n    }\n    warshallFloyd(atl, n);\n    scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n    cout << c - atl[a][b] - atl[b][a] - d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0117 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117)\n#include<cstdio>\n#include<algorithm>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_N = 20, INF = std::numeric_limits<int>::max()>>4;\n\nint n, m;\nint d[MAX_N][MAX_N], rd[MAX_N][MAX_N];\nint x1, x2, Y1, y2;\n\nint main()\n{\n\tscanf( \"%d%d\", &n, &m );\n\n\trep( i, n ) rep( j, n )\n\t\td[i][j] = rd[i][j] = i==j?0:INF;\n\n\trep( i, m )\n\t{\n\t\tint a, b, c, di;\n\t\tscanf( \"%d,%d,%d,%d\", &a, &b, &c, &di );\n\t\t--a; --b;\n\t\td[a][b] = d[b][a] = c;\n\t\trd[a][b] = rd[b][a] = di;\n\t}\n\n\trep( k, n ) rep( i, n ) rep( j, n )\n\t{\n\t\td[i][j] = std::min( d[i][j], d[i][k]+d[k][j] );\n\t\trd[i][j] = std::min( rd[i][j], rd[i][k]+rd[k][j] );\n\t}\n\n\tscanf( \"%d,%d,%d,%d\", &x1, &x2, &Y1, &y2 );\n\t--x1; --x2;\n\n\tprintf( \"%d\\n\", Y1-d[x1][x2]-rd[x2][x1]-y2 );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n//\nint main(void){\n\n\tchar str;\n\tint n, m, a, b, c, d, s, g, s_cost, g_cost;\n\tint cost[21][21];\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i < n+1; i++){\n\t\tfor (int j = 1; j < n+1; j++) cost[i][j] = 1001;\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\n\t\tcin >> a >> str >> b  >> str >> c >> str >> d;\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\tcin >> s >> str >> g >> str >> s_cost >> str >> g_cost;\n\n\tfor (int i = 1; i < n + 1; i++){\n\t\tfor (int j = 1; j < n + 1; j++) printf(\"%5d\",cost[i][j]);\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\tfor (int i = 1; i < n + 1; i++){\n\t\tfor (int j = 1; j < n + 1; j++){\n\t\t\tfor (int k = 1; k < n + 1; k++){\n\t\t\t\tcost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\t\t\t\tprintf(\"%5d\", cost[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tcout << s_cost - g_cost - cost[s][g] - cost[g][s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main( void )\n{\n    int n, m;\n    string input;\n    int G[31][31];\n    int C[31][31];\n    for ( int i = 0; i < 31; i++ )\n    {\n        for ( int j = 0; j < 31; j++ )\n        {\n            C[i][j] = 1 << 24;\n        }\n    }\n\n    cin >> n >> m;\n    for ( int i = 0; i < m; i++ )\n    {\n        cin >> input;\n        replace( input.begin(), input.end(), ',', ' ' );\n        istringstream is( input );\n        int a, b, c, d;\n        is >> a >> b >> c >> d;\n        C[a][b] = c;\n        C[b][a] = d;\n    }\n\n    for ( int k = 1; k <= n; k++ ) for ( int i = 1; i <= n; i++ ) for ( int j = 1; j <= n; j++ )\n    {\n        C[i][j] = min( C[i][j], C[i][k] + C[k][j] );\n    }\n\n    int x1, x2, y1, y2;\n    cin >> input;\n    replace( input.begin(), input.end(), ',', ' ' );\n    istringstream is( input );\n    is >> x1 >> x2 >> y1 >> y2;\n    cout << y1 - y2 - C[x1][x2] - C[x2][x1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>10)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int i,j;\n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int ans;\n  int rout[21][21];\n  int dis1[21],dis2[21];\n  int flag;\n\n  while(scanf(\"%d\",&n)!=EOF){\n    cin >> m;\n\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\trout[i][j] = -1;\n      }\n    }\n\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d,%d \",&a,&b,&c,&d);\n      rout[a][b] = c;\n      rout[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d \",&x1,&x2,&y1,&y2);\n\n    for(i=1;i<=n;i++)dis1[i] = -1;\n    for(i=1;i<=n;i++)dis2[i] = -1;\n    dis1[x1] = 0;\n    dis2[x2] = 0;\n\n    while(1){\n      flag = 0;\n\n      for(i=1;i<=n;i++){\n\tif(dis1[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>=0){\n\t      if(dis1[j]<0){\n\t\tdis1[j] = dis1[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis1[i]+rout[i][j] < dis1[j]){\n\t\tdis1[j] = dis1[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n\tif(dis2[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>=0){\n\t      if(dis2[j]<0){\n\t\tdis2[j] = dis2[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis2[i]+rout[i][j] < dis2[j]){\n\t\tdis2[j] = dis2[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(!flag)break;\n    }\n  \n    ans = y1 - y2 -dis1[x2] - dis2[x1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < 25; i++){\n\t\tfor (int  j = 0; j<25; j++){\n\t\t\tw[i][j] = 10000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 0; h < N; h++){\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << w[x1][x2] - y1 - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1001\nusing namespace std;\n\nint main()\n{\n    int m,n,a,b,c,d,x[2],y1,y2;\n    int w[20][20],di[20],f[20];\n    for (int i=0; i<20; i++)\n    {\n\tfor (int j=0; j<20; j++)\n\t{\n\t    w[i][j]=INF;\n\t}\n    }\n    scanf(\"%d\\n%d\",&n,&m);\n    for (int i=0; i<m; i++)\n    {\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tw[a][b] = c;\n\tw[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\",&x[0],&x[1],&y1,&y2);\n    for (int i=0; i<2; i++)\n    {\n\tfor (int j=0; j<20; j++)\n\t{\n\t    di[j] = INF;\n\t    f[j] = 0;\n\t}\n\tdi[x[i]] = 0;\n\tfor (int j=0; j<20; j++)\n\t{\n\t    int min = INF;\n\t    int p;\n\t    for (int k=0; k<20; k++)\n\t    {\n\t\tif (f[k] == 0 && min > di[k])\n\t\t{\n\t\t    min = di[k];\n\t\t    p = k;\n\t\t}\n\t    }\n\t    f[p]=1;\n\t    for (int k=0; k<20; k++)\n\t    {\n\t\tdi[k] = std::min(di[k],di[p]+w[p][k]);\n\t    }\n\t}\n\ty1-=di[x[1-i]];\n    }\n    cout << y1-y2 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nint road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=n;i++)if(place[now][i]!=0)ans=max(ans,serch(start,finish,money-place[now][i],go,i));\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint K[20][20];\nint n,m,a,b,c,d;\nint Floyd(int K[20][20],int n) {\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]) {\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\\n\",&n);\n\tscanf(\"%d\\n\",&m);\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<n; ++j) {\n\t\t\tK[i][j] = 100000;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\tK[a-1][b-1] = c;\n\t\tK[b-1][a-1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tFloyd(K,n);\n\tcout << c-d-K[a-1][b-1]-K[b-1][a-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<climits>\nconst int MAXN = 22;\nconst int INF = INT_MAX/3;\nint graph[MAXN][MAXN];\n\nusing namespace std;\n\nvoid dijkstra(int s,int* d,int n){\n  bool visited[MAXN];\n  fill(visited, visited+n+1,false);\n  fill(d, d+n+1, INF);\n  d[s] = 0;\n  while(true){\n    int minv  = -1;\n    for(int i = 1;i <= n;i++){\n      if((not visited[i]) and (d[i] < d[minv] or minv == -1)) minv = i;\n    }\n    if(minv == -1)break;\n    visited[minv] = true;\n    for(int i = 1;i <= n;i++){\n      d[i] = min(d[i],graph[minv][i] + d[minv]);\n    }\n  }\n}\n\nint main(){\n  int n ,m;\n  scanf(\"%d\",&n);\n  scanf(\"%d\",&m);\n  //cin >> n;\n  //cin >> m;\n  fill(*graph,*(graph+MAXN),INF);\n  for(int i = 0;i < m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    //cin >> a >> b >> c >> d;\n    graph[a][b] = c;\n    graph[b][a] = d;\n  }\n  int x1,x2,y1,y2;\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  int d[MAXN];\n  dijkstra(x1,d,n);\n  int min1 = d[x2];\n  dijkstra(x2,d,n);\n  int min2 = d[x1];\n  cout << y1 - y2 - min1 - min2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 1; i < 25; i++){\n\t\tfor (int  j = 1; j<25; j++){\n\t\t\tw[i][j] = 10000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 1; h <= N; h++){\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << y1- w[x1][x2]  - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n#define REP1(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint n, m;\nint dis[21][21];\nint s, g, v, p;\n\nint main(){\n    cin >> n >> m;\n\n    REP(i, n+1){\n        REP(j, n+1){\n            if(i!=0 && i==j){\n                dis[i][j] = 0;\n            } else {\n                dis[i][j] = INF; dis[j][i] = INF;\n            }\n        }\n    }\n\n    REP(i, m){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        dis[a][b] = c;\n        dis[b][a] = d;\n    }\n\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    REP1(k, n+1){\n        REP1(i, n+1){\n            REP1(j, n+1){\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    int output = v - (p + dis[s][g] + dis[g][s]);\n    cout << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++i)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=1;k<N;k++){\n    for (int i = 1; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j])){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1][x2]-y2 << endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,m,a,b,c,d,COST[21][21];\n  \n  for(int i=0;i<21;i++){\n    for(int j=0;j<21;j++){\n      COST[i][j] = 1000000;\n    }\n  }\n\n  cin >> n >> m;\n  for(int i=0;;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    if(i==m) break;\n    COST[a][b] = c;\n    COST[b][a] = d;\n  }\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n\tif(COST[j][k]>COST[j][i]+COST[i][k]){\n\t  COST[j][k]=COST[j][i]+COST[i][k];\n\t}\n      }\n    }\n  }\n  cout << c - COST[a][b] - COST[b][a] - d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    rep(i, 20) rep(j, 20) G[i][j] = INF;\n    rep(i, m) {\n        int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = G[i][j];\n    \"rep(i, n) dp[i][i] = 0;\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\nint main()\n{\n\tchar c;\n\tint x1,x2,y1,y2;\n\tint n,m,a,b,ab,ba;\n\tint tb[32][32];\n\n\tcin >> n >> m;\n\tREP(i,n)REP(j,n)\n\t{\n\t\ttb[i][j] = (i==j ? 0 : 1<<20);\n\t}\n\n\twhile(m--)\n\t{\n\t\tcin >> a >> c >> b >> c >> ab >> c >> ba;\n\t\ta--; b--;\n\t\ttb[a][b] = ab;\n\t\ttb[b][a] = ba;\n\t}\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\n\tREP(k,n)REP(i,n)REP(j,n)\n\t{\n\t\tif(tb[i][j]>tb[i][k]+tb[k][j]) tb[i][j]=tb[i][k]+tb[k][j];\n\t}\n\n\tx1--; x2--;\n\tcout << y1-y2-tb[x1][x2]-tb[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define MG 210000000\n\n\n\n\n main(){\n\t\n\tint n,m;\n\tint i,j;\n\tint a[40],b[40],c[40],d[40];\n\tint e,f,g=MG,h,l;\n\tint k[21][21],flg[21],dk[21],dkn;\n\t\n\t\n\tscanf(\"%d\",&n);\n\t\n\tscanf(\"%d\",&m);\n\t\n\tfor(i=1;i<=n;i++){\n\t\tdk[i]=MG;\n\t\tflg[i]=0;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tk[i][j]=MG;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&e,&f,&dkn,&h);\n\t\n\t\n\n\t\n\tfor(i=1;i<=m;i++){\n\t\tk[a[i]][b[i]]=c[i];\n\t\tk[b[i]][a[i]]=d[i];\n\t}\n\t\n\n\tdk[e]=0;\n\t\n\tfor(i=0;i<=n;i++){\n\t\tg=MG;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0 && dk[j]<g){\n\t\t\t\tg=dk[j];\n\t\t\t\tl=j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg[l]=1;\n\t\t\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(dk[l]+k[l][j]<dk[j]){\n\t\t\t\tdk[j]=dk[l]+k[l][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdkn=dkn-(h+dk[f]+dk[n]);\n\t\n\tprintf(\"%d\\n\",dkn);\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nstruct Edge {\n    int to, cost;\n};\n\nstruct P {\n    int town, cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint G[21];\n\nint main() {\n    int town_n, road_n;\n    cin >> town_n >> road_n;\n\n    vector<vector<Edge>> E(town_n+1);\n    REP(i, road_n) {\n        int a, b, c, d;\n        char delim;\n        cin >> a >> delim >> b >> delim >> c >> delim >> d;\n        E[a].push_back({b, c});\n        E[b].push_back({a, d});\n    }\n    int start, goal, money, hashira;\n    char delim;\n    cin >> start >> delim >> goal >> delim >> money >> delim >> hashira;\n\n    int cost1 = 0, cost2 = 0;\n\n    fill_n((int *)G, 21, INF);\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({start, 0});\n    G[start] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.town == goal) {\n            cost1 = p.cost;\n            break;\n        }\n        for (Edge& e : E[p.town]) {\n            int next_cost = p.cost + e.cost;\n            if (G[e.to] > next_cost) {\n                G[e.to] = next_cost;\n                que.push({e.to, next_cost});\n            }\n        }\n    }\n    fill_n((int *)G, 21, INF);\n    while (!que.empty()) que.pop();\n    que.push({goal, 0});\n    G[goal] = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        if (p.town == start) {\n            cost2 = p.cost;\n            break;\n        }\n        for (Edge& e : E[p.town]) {\n            int next_cost = p.cost + e.cost;\n            if (G[e.to] > next_cost) {\n                G[e.to] = next_cost;\n                que.push({e.to, next_cost});\n            }\n        }\n    }\n    cout << (money - hashira - cost1 - cost2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n/** Problem0117 : A reward for a Carpenter **/\nconst int INF = 100000;\n\nint main()\n{\n\tint d[21][21];\n\tint V, E;\n\t\n\tint s, g, plus, minus;\n\tchar c;\n\tcin >> V >> E;\n\t\n\tfor (int i=0; i<21; i++)\n\t\tfor (int j=0; j<21; j++) d[i][j] = INF;\n\t\n\tfor (int i=0; i<E; i++) {\n\t\tint a, b, dd, ddd;\n\t\tcin >> a >> c >> b >> c >> dd >> c >> ddd;\n\t\td[a][b] = dd;\n\t\td[b][a] = ddd;\n\t}\n\t\n\tcin >> s >> c >> g >> c >> plus >> c >> minus;\n\t\n\tfor (int k=1; k<=V; k++)\n\t\tfor (int i=1; i<=V; i++)\n\t\t\tfor (int j=1; j<=V; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\n\tcout << plus - (minus + d[s][g] + d[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <string>\nclass City;\nstruct Path {\n\tint cost;\n\tCity *to;\n};\nclass City {\npublic:\n\tCity() {};\n\tvoid add_path(const Path &path) {\n\t\troute[idx++] = path;\n\t}\n\tint cost{ INT_MAX };\n\tvoid go_next() {\n\t\treach_flag = true;\n\t\tfor (auto i = 0; i < idx; ++i) {\n\t\t\troute[i].to->arrive_at(cost + route[i].cost);\n\t\t}\n\t}\n\tbool is_reached() const { return reach_flag; };\n\tvoid reset() { reach_flag = false; cost = INT_MAX; }\nprivate:\n\tint idx{ 0 };\n\tPath route[20];\n\tbool reach_flag{ false };\n\tvoid arrive_at(const int &c) {\n\t\tif (c < cost) cost = c;\n\t}\n};\nvoid read_sub(std::string &str, int &a) {\n\tauto idx = str.find(',');\n\ta = std::stoi(str.substr(0, idx));\n\tstr = str.substr(idx + 1);\n}\nvoid read(std::string str, int &a, int &b, int &c, int &d) {\n\tread_sub(str, a); read_sub(str, b); read_sub(str, c); d = std::stoi(str);\n}\nint cul_cost(City city[], int n, int start, int goal) {\n\tfor (auto i = 1; i <= n; ++i) {\n\t\tcity[i].reset();\n\t}\n\tcity[start].cost = 0;\n\tauto min = start;\n\twhile (min != goal){\n\t\tcity[min].go_next();\n\t\tauto min_cost = INT_MAX;\n\t\tfor (auto i = 1; i <= n; ++i) {\n\t\t\tif (!city[i].is_reached() && city[i].cost < min_cost) {\n\t\t\t\tmin_cost = city[i].cost;\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn city[goal].cost;\n}\nint main() {\n\tCity city[21];\n\tint n;\n\tstd::cin >> n;\n\tfor (auto i = 1; i <= n; ++i) {\n\t\tcity[i] = City();\n\t}\n\tint m;\n\tstd::cin >> m;\n\tfor (auto i = 0; i < m; ++i) {\n\t\tint a, b, c, d;\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\tread(str, a, b, c, d);\n\t\tcity[a].add_path({ c, &city[b] });\n\t\tcity[b].add_path({ d, &city[a] });\n\t}\n\tint start, goal, reward, pillar_cost;\n\tstd::string str;\n\tstd::cin >> str;\n\tread(str, start, goal, reward, pillar_cost);\n\tauto all_cost = cul_cost(city, n, start, goal) + cul_cost(city, n, goal, start);\n\tstd::cout << reward - pillar_cost - all_cost << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MAX 20\n#define TEST 0\nint dist[MAX][MAX];\n\nvoid fw(int n)\n{\n    for(int k=0;k<n;k++)\n    {\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if((dist[i][k]!=-1 && dist[k][j]!=-1)&& (dist[i][j]==-1|| (dist[i][k]!=-1 && dist[i][j]>dist[i][k]+dist[k][j])))\n                {\n                    dist[i][j]=dist[i][k]+dist[k][j];\n                }\n            }\n        }\n    }\n    return;\n}\n\n\nint main(void)\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            dist[i][j]=-1;\n        }\n    }\n    for(int i=0;i<m;i++)\n    {\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        dist[a-1][b-1]=c;\n        dist[b-1][a-1]=d;\n    }\n    int x1,x2,y1,y2;\n    scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n    fw(n);\n    if(TEST)\n    {\n        printf(\"(x1,x2,y1,y2)=(%d,%d,%d,%d)\\n\",x1,x2,y1,y2);\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                printf(\"%d \",dist[i][j]);\n            }\n            puts(\"\");\n        }\n    }\n    printf(\"%d\\n\",y1-y2-dist[x1-1][x2-1]-dist[x2-1][x1-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\tpq.emplace(d[t] + E[t][i].second, E[t][i].first);\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n/** Problem0117 : A reward for a Carpenter **/\nconst int INF = 100000;\nint d[21][21];\nint path[21][21];\nint V, E;\n\n\nint main()\n{\n\tint s, g, plus, minus;\n\tchar c;\n\tcin >> V >> E;\n\t\n\tfor (int i=0; i<21; i++)\n\t\tfor (int j=0; j<21; j++) d[i][j] = INF;\n\t\n\tfor (int i=0; i<E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> c >> b >> c >> d[a][b] >> c >> d[b][a];\n\t}\n\t\n\tcin >> s >> c >> g >> c >> plus >> c >> minus;\n\t\n\tfor (int k=0; k<=V; k++)\n\t\tfor (int i=0; i<=V; i++)\n\t\t\tfor (int j=0; j<=V; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\n\tcout << plus - (minus + d[s][g] + d[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nconst int inf = 1001000100;\nint K[32][32]={};\n\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n\n  for (int i=1; i<N+1; i++)\n    for (int j=1; j<N+1; j++)\n      K[i][j] = inf;\n  \n  for (int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    //   cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  \n  for (int k=1; k<N+1; k++){\n    for (int i=1; i<N+1; i++){\n      for (int j=1; j<N+1; j++){\n\tif (K[i][j] > K[i][k] + K[k][j])\n\t  K[i][j] = K[i][k] + K[k][j];\n\t//cout << K[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n  }\n  cout << y1 - y2 - K[x1][x2] -K[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint g[20][20];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tg[i][j]=99999999;\n\tfor(int i=0;i<b;i++){\n\t\tint c,d,e,f;\n\t\tscanf(\"%d,%d,%d,%d\",&c,&d,&e,&f);\n\t\tg[c-1][d-1]=e;\n\t\tg[d-1][c-1]=f;\n\t}\n\tint c,d,e,f;\n\tscanf(\"%d,%d,%d,%d\",&c,&d,&e,&f);\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tif(g[i][j]>g[i][k]+g[k][j])g[i][j]=g[i][k]+g[k][j];\n\tprintf(\"%d\\n\",e-f-g[c-1][d-1]-g[d-1][c-1]);\n}"
  },
  {
    "language": "C++",
    "code": "// 0117\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#define  N    10000000\nusing namespace std;\n\nstruct road{\n\tint v;\n\tint cost;\n};\n\nint com_min(int x, int y, vector<vector<road> > town){\n\tvector<int> c;\n\n\tfor(int i=0;i<=town.size();i++)\n\t\tif(i == x)\n\t\t\tc.push_back(0);\n\t\telse\n\t\t\tc.push_back(N);\n\n\tqueue<int> ver;\n\tver.push(x);\n\n\twhile(!ver.empty()){\n\t\tint f = ver.front();\n\t\tfor(int i=0;i<town[f].size();i++)\n\t\t\tif(c[town[f][i].v] > c[f] + town[f][i].cost){\n\t\t\t\tc[town[f][i].v] = c[f] + town[f][i].cost;\n\t\t\t\tver.push(town[f][i].v);\n\t\t\t}\n\t\tver.pop();\n\t}\n\n\treturn c[y];\n}\n\nint main(){\n\tint n, m, a, b, c, d;\n\tvector<vector<road> > town;\n\troad r;\n\n\tcin>>n;\n\ttown.resize(n+1);\n\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\n\t\tr.v = b;\n\t\tr.cost = c;\n\t\ttown[a].push_back(r);\n\t\tr.v = a;\n\t\tr.cost = d;\n\t\ttown[b].push_back(r);\n\t}\n\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n\tcout<<y1-y2-com_min(x1, x2, town)-com_min(x2, x1, town)<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tconst int nmax = 21;\n\tint route[nmax][nmax];\n\tint n;\n\tint m;\n\tint a, b, c, d;\n\tint x1, x2, y1, y2;\n\tchar ch;\n\tint cost1, cost2;\n\tcin >> n >> m;\n\tfor(int i = 0; i < nmax; i++){\n\t\tfor(int j = 0; j < nmax; j++){\n\t\t\troute[i][j] = 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\troute[a][b] = c;\n\t\troute[b][a] = d;\n\t}\n\tfor(int i = 1; i < nmax; i++){\n\t\tfor(int j = 1; j < nmax; j++){\n\t\t\tif(route[j][i])\n\t\t\t\tfor(int k = 1; k < nmax; k++)\n\t\t\t\t\tif(route[i][k])\n\t\t\t\t\t\tif(!route[j][k] || (route[j][i] + route[i][k] < route[j][k]))\n\t\t\t\t\t\t\troute[j][k] = route[j][i] + route[i][k];\n\t\t}\n\t}\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\tcost1 = route[x1][x2];\n\tcost2 = route[x2][x1];\n\tcout << y1 - y2 - cost1 - cost2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n*/\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n\nusing std::cout;\nusing std::cin;\nusing std::setw;\nusing std::setfill;\nusing std::string;\nusing std::pair;\nusing std::make_pair;\nusing std::vector;\nusing std::queue;\nusing std::deque;\nusing std::priority_queue;\nusing std::next_permutation;\n//using std::iota;\nusing std::sort;\nusing std::greater;\nusing std::max;\nusing std::min;\n\n#define INF 99999;\n#define MOD 1000000007\n\n#define EVEL 1\n\n#ifndef EVEL\n#define dbug(X) std::cout << #X << \":\" <<X<<\" \" ;\n#define dbugf(s) std::cout << s << \" \";\n#define dbugln std::cout<<\"\\n\";\n#else\n#define dbug(X) {}\n#define dbugf(s) {}\n#define dbugln {}\n#endif\n\nint n, m;\nchar com;\n//vector< vector< pair<int, int> > > graph;\nint Cost[25][25];\nint s, g, V, P;\n\nint main(){\n\tcin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\n    cin >> n >> m;\n    //graph.resize(n);\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            Cost[i][j] = INF;\n        }\n    }\n    int a, b, c, d;\n    for(int i = 0; i < m; i++){\n        cin >> a >>com>> b >>com>> c >>com>> d;\n        Cost[a][b] = c;\n        Cost[b][a] = d;\n    }\n    cin >> s >>com>> g >>com>> V >>com>> P;\n\n    for(int k = 1; k <= n; k++){\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                dbugf(k)dbugf(i)dbugf(j)dbug(Cost[i][j])dbugln\n                Cost[i][j] = min(Cost[i][j], Cost[i][k] + Cost[k][j]);\n                dbug(Cost[i][j])dbug(Cost[i][k])dbug(Cost[k][j])dbugln\n            }\n        }\n        dbugln;\n    }\n\n    cout << V - Cost[s][g] - Cost[g][s] - P << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#define INF (2000000000)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\n\n\nint head[20];\nint to[400];\nint next[400];\nint cost[400];\n\nint d[20];\n\nint n, m;\n\nvoid Search(int now)\n{\n\tfill(d, d + 20, INF);\n\td[now] = 0;\n\t\n\twhile (true){\n\t\tbool update = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int e = head[i]; e != -1; e = next[e]){\n\t\t\t\tif (d[i] != INF && d[to[e]] > d[i] + cost[e]){\n\t\t\t\t\td[to[e]] = d[i] + cost[e];\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!update){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tmemset(head, -1, sizeof(head));\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\t\n\t\tnext[i * 2] = head[a];\n\t\thead[a] = i * 2;\n\t\tto[i * 2] = b;\n\t\tcost[i * 2] = c;\n\t\t\n\t\tnext[i * 2 + 1] = head[b];\n\t\thead[b] = i * 2 + 1;\n\t\tto[i * 2 + 1] = a;\n\t\tcost[i * 2 + 1] = d;\n\t}\n\t\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tx1--; x2--;\n\t\n\t\n\tint go, back;\n\tSearch(x1);\n\tgo = d[x2];\n\tSearch(x2);\n\tback = d[x1];\n\t\n\tprintf(\"%d\\n\", y1 - y2 - go - back);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\nusing namespace std;\n\nint n;\nint con[21][21];\nint cost[21];\nbool used[21];\n\nint dijkstra(int stt, int end) {\n  int a, b, c, d;\n\n  for (int i=1; i<=n; i++) cost[i] = INT_MAX;\n  for (int i=1; i<=n; i++) used[i] = false;\n\n  cost[stt] = 0;\n  used[stt] = true;\n  a = stt;\n  while (!used[end]) {\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && con[a][i]!=INT_MAX) {\n        b = cost[a] + con[a][i];\n        if (b < cost[i]) {\n          cost[i] = b;\n        }\n      }\n    }\n    c = INT_MAX;\n    d = 0;\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && cost[i] < c) {\n        c = cost[i];\n        d = i;\n      }\n    }\n    used[d] = true;\n    a = d;\n  }\n\n  return cost[end];\n}\n\nint main() {\n  int m, a, b, c, d;\n  int stt, end, budget, pole, ans;\n\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n\n  for (int i=1; i<=n; i++) {\n    for (int j=1; j<=n; j++) {\n      con[i][j] = INT_MAX;\n    }\n  }\n\n  for (int i=0; i<m; i++) {\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    con[a][b] = c;\n    con[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &stt, &end, &budget, &pole);\n\n  ans = budget - dijkstra(stt, end) - dijkstra(end, stt) - pole;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\t\n\tprintf(\"%d\\n\",v-p-kou);\n\treturn 0;\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint N , M;\n\tchar C;\n\tcin >> N >> M;\n\tvector<vector<pair<int , int>>>data(N);\n\tfor(size_t i = 0; i < M; i++)\n\t{\n\t\tint a , b , c , d;\n\t\tcin >> a >> C >> b >> C >> c >> C >> d;\n\t\ta--; b--;\n\t\tdata[a].push_back(make_pair(b , c));\n\t\tdata[b].push_back(make_pair(a , d));\n\t}\n\tint x1 , x2 , y1 , y2;\n\tcin >> x1 >> C >> x2 >> C >> y1 >> C >> y2;\n\tx1--; x2--;\n\tvector<int>cost1(N , INT_MAX / 6);\n\tauto cost2 = cost1;\n\tpriority_queue<pair<int , int> , vector<pair<int , int>>>que1 , que2;\n\tque1.push(make_pair(0 , x1));\n\tcost1[x1] = 0;\n\twhile(que1.size())\n\t{\n\t\tauto now = que1.top(); que1.pop();\n\t\tif(now.second == x2)break;\n\t\tfor(auto x : data[now.second])\n\t\t{\n\t\t\tif(cost1[x.first] > now.first + x.second)\n\t\t\t{\n\t\t\t\tcost1[x.first] = now.first + x.second;\n\t\t\t\tque1.push(make_pair(cost1[x.first] , x.first));\n\t\t\t}\n\t\t}\n\t}\n\ty1 -= cost1[x2];\n\tque2.push(make_pair(0 , x2));\n\tcost2[x2] = 0;\n\twhile(que2.size())\n\t{\n\t\tauto now = que2.top(); que2.pop();\n\t\tif(now.second == x1)break;\n\t\tfor(auto x : data[now.second])\n\t\t{\n\t\t\tif(cost2[x.first] > now.first + x.second)\n\t\t\t{\n\t\t\t\tcost2[x.first] = now.first + x.second;\n\t\t\t\tque2.push(make_pair(cost2[x.first] , x.first));\n\t\t\t}\n\t\t}\n\t}\n\ty1 -= cost2[x1];\n\ty1 -= y2;\n\tcout << y1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#define F first\n#define S second\nusing namespace std;\n\nstruct edge{\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\ntypedef pair<int,int> P;\n\nint n,m;\nvector<edge> g[22];\nint d[22];\n\nvoid djk(int s){\n\n  fill(d,d+n+1,1<<20);\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0,s));\n  d[s] = 0;\n  while(!que.empty()){\n    P p = que.top();que.pop();\n    if(d[p.S] < p.F) continue;\n    for(int i = 0; i < (int)g[p.S].size(); i++){\n      if(d[g[p.S][i].t] > d[p.S] + g[p.S][i].c){\n\td[g[p.S][i].t] = d[p.S] + g[p.S][i].c;\n\tque.push(P(d[p.S] + g[p.S][i].c,g[p.S][i].t));\n      }\n    }\n  }\n}\n\nint main(void)\n{\n  scanf(\"%d %d\",&n,&m);\n  for(int i = 0; i < m; i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    g[a].push_back(edge(b,c));\n    g[b].push_back(edge(a,d));\n  }\n\n  int s,g,y,b;\n  scanf(\"%d,%d,%d,%d\",&s,&g,&y,&b);\n  int k = 0;\n  djk(s);\n  k += d[g];\n  djk(g);\n  k += d[s];\n  printf(\"%d\\n\",y - b - k);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t\tpq.emplace(d[E[t][i].first], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF (1<<21)\nint main(){\n\tint n,m,a,b,c,d;\n\tcin >> n,m;\n\tint wf[20][20];\n\trep(i,20)rep(j,20)wf[i][j] = (i==j?0:INF);\n\tcin >> m;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--,b--;\n\t\twf[a][b] = c , wf[b][a] = d;\n\t}\n\trep(k,n)rep(i,n)rep(j,n)wf[i][j] = min(wf[i][j],wf[i][k]+wf[k][j]);\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\ta--,b--;\n\tcout << c-d-wf[a][b]-wf[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstruct edge { int to, cost; };\nvector<edge> G[21];\nint search(int start, int goal)\n{\n    //first := cost, second := now vertex\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> dist(21, INF);\n    que.push(P(0, start));\n    dist[start] = 0;\n    while(not que.empty())\n    {\n        P now = que.top(); que.pop();\n        if(now.second == goal) break;\n        for(int u = 0; u < G[now.second].size(); u++)\n        {\n            edge e = G[now.second][u];\n            if(now.first + e.cost < dist[e.to])\n            {\n                dist[e.to] = now.first + e.cost;\n                que.push(P(dist[e.to], e.to));\n            }\n        }\n    }\n    return dist[goal];\n}\nint main()\n{\n    int n, m; cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a].push_back({b, c});\n        G[b].push_back({a, d});\n    }\n    int start, goal, v, p;\n    scanf(\"%d,%d,%d,%d\", &start, &goal, &v, &p);\n    int ans = v - p;\n    int a = search(start, goal);\n    int b = search(goal, start);\n    cout << ans - a - b << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint mp[20][20];\nint bfs(int n,int s,int g){\n  vector<int> dis(n);\n  queue<int> q;\n  rep(i,n)dis[i]=INF;\n  dis[s]=0;\n  q.push(s);\n\n  int u;\n\n  while(!q.empty()){\n    u=q.front(),q.pop();\n    rep(i,n){\n      if(dis[i]>dis[u]+mp[u][i]){\n        dis[i]=dis[u]+mp[u][i];\n        q.push(i);\n      }\n    }\n  }\n    return dis[g];\n}\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  char x;\n  rep(i,n)rep(j,n)mp[i][j]=INF;\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>x>>b>>x>>c>>x>>d;\n    a--;b--;\n    mp[a][b]=c;\n    mp[b][a]=d;\n  }\n  int s,g,v,p;\n  cin>>s>>x>>g>>x>>v>>x>>p;\n  s--;g--;\n\n  int sum1=bfs(n,s,g);\n  int sum2=bfs(n,g,s);\n\n  \n  cout<<v-p-sum1-sum2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nconst int INFINITY = INT_MAX;\n\nstruct Node{\n  vector<int> edgeTo;\n  vector<int> edgeCost;\n  bool done;\n  int cost;\n};\n\nclass compf: public binary_function<struct Node, struct Node, bool>{\npublic:\n  result_type operator()(first_argument_type first, second_argument_type second){\n    return (first.cost - second.cost) > 0;\n  }\n};\n\nint Dijkstra(int start, int goal, struct Node *town){\n  priority_queue<struct Node, vector<struct Node> , compf> priQueue;\n\n  town[start].cost = 0;\n  priQueue.push(town[start]);\n\n\n  while(priQueue.empty() == false){\n    struct Node doneNode = priQueue.top(); priQueue.pop();\n    if(doneNode.done == true) continue;\n    doneNode.done = true;\n    for(int i = 0; i < doneNode.edgeTo.size(); i++){\n      int to = doneNode.edgeTo[i];\n      unsigned int cost = (unsigned int)doneNode.cost + doneNode.edgeCost[i];\n      if(cost < town[to].cost){\n\ttown[to].cost = cost;\n\tpriQueue.push(town[to]);\n#if DEBUG\n\tprintf(\"town No.%d is pushed.\\n\", i);\n#endif\n      }\n    }\n  }\n#if DEBUG\n  for(int i = 0; i < 7; i++){\n    printf(\"i = %d, cost = %d\\n\", i, town[i].cost);\n  }\n#endif\n  return town[goal].cost;\n}\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  struct Node town[n + 1];\n\n  for(int i = 0; i < n + 1; i++){\n    town[i].done = false;\n    town[i].cost = INFINITY;\n  }\n\n  for(int i = 0; i < m; i++){\n    int a, b, c, d;\n    char t;\n    cin >> a >> t >> b >> t >> c >> t >> d;\n    town[a].edgeTo.push_back(b);\n    town[a].edgeCost.push_back(c);\n    town[b].edgeTo.push_back(a);\n    town[b].edgeCost.push_back(d);    \n  }\n\n  int start, yamazato, reward, polePrice;\n  char t;\n  cin >> start >> t >> yamazato >> t >> reward >> t >> polePrice;\n\n  int gotoCost = Dijkstra(start, yamazato, town);\n\n  for(int i = 0; i < n + 1; i++){\n    town[i].done = false;\n    town[i].cost = INFINITY;\n  }\n\n  int gobackCost = Dijkstra(yamazato, start, town);\n\n  cout << reward - gotoCost - gobackCost - polePrice << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<list>\n#include<stack>\n#include<queue>\n#include<cctype>\n#include<iomanip>\n#include<functional>\n#include<numeric>\n#include<map>\n#include<set>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long llong;\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\nstatic const int INF = (1 << 21);\nint n, m;\nvector<vector<int> >v;\nvector<int>color, dis, p;\nint s, g, V, P;\n\nvoid dijkstra(int s) {\n\tint minv;\n\tfor (int i = 0; i < n; i++) {\n\t\tdis[i] = INF;\n\t\tcolor[i] = WHITE;\n\t}\n\tdis[s] = 0;\n\tcolor[s] = GRAY;\n\twhile (1) {\n\t\tminv = INF;\n\t\tint u = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (minv > dis[i] && color[i] != BLACK) {\n\t\t\t\tminv = dis[i];\n\t\t\t\tu = i;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)break;\n\t\tcolor[u] = BLACK;\n\t\tfor (int r = 0; r < n; r++) {\n\t\t\tif (color[r] != BLACK&&v[u][r] != INF) {\n\t\t\t\tif (dis[r] > dis[u] + v[u][r]) {\n\t\t\t\t\tdis[r] = dis[u] + v[u][r];\n\t\t\t\t\tcolor[r] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nint main() {\n\tcin >> n >> m;\n\tcolor = p = dis = vector<int>(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int>x;\n\t\tv.push_back(x);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tv[i].push_back(INF);\n\t\t}\n\t}\n\tint a, b, c, d;\n\tchar e;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> e >> b >> e >> c >> e >> d;\n\t\ta--; b--;\n\t\tv[a][b] = c;\n\t\tv[b][a] = d;\n\t}\n\tcin >> s >> e >> g >> e >> V >> e >> P;\n\ts--; g--;\n\tV -= P;\n\tdijkstra(s);\n\tV -= dis[g];\n\tdijkstra(g);\n\tV -= dis[s];\n\tcout << V << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  char dummy;\n  vector<vector<int>> d(n, vector<int> (n,INF));\n  for(int i=0;i<m;++i){\n    int a,b,c,e;\n    cin>>a>>dummy>>b>>dummy>>c>>dummy>>e;\n\n    d[a-1][b-1] = c;\n    d[b-1][a-1] = e;\n  }\n\n  int x1,x2,y1,y2;\n  cin>>x1>>dummy>>x2>>dummy>>y1>>dummy>>y2;\n\n  // wa-sharufuroidohou\n  for(int k = 0; k < n; ++k)\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n  int ans = y1 - y2 - (d[x1-1][x2-1] + d[x2-1][x1-1]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tvvi cost(n, vi(n, INF));\n\tint a, b, d, e;\n\tchar c;\n\tREP(i, m) {\n\t\tcin >> a >> c >> b >> c >> d >> c >> e;\n\t\tcost[a-1][b-1] = d;\n\t\tcost[b-1][a-1] = e;\n\t}\n\tcin >> a >> c >> b >> c >> d >> c >> e;\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << d-e-cost[a-1][b-1]-cost[b-1][a-1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  const int INF = 1 << 28;\n\n  int n;\n  while (~scanf(\"%d\", &n)) {\n    int m;\n    scanf(\"%d\", &m);\n\n    vector<vector<int> > cost(n, vector<int>(n, INF));\n    for (int i = 0; i < m; ++i) {\n      int a1, b1, c1, d1;\n      scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n      --a1;\n      --b1;\n      cost[a1][b1] = c1;\n      cost[b1][a1] = d1;\n    }\n\n    for (int k = 0; k < n; ++k) {\n      for (int i = 0; i < n; ++i) {\n\tfor (int j = 0; j < n; ++j)\n\t  cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n      }\n    }\n\n    int x1, x2, y1, y2;\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    printf(\"%d\\n\", y1-y2-cost[x1-1][x2-1]-cost[x2-1][x1-1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint d[30][30];\nint main(){\n    int n,m;\n    while(cin>>n>>m && n){\n        rep(i,30)rep(j,30)d[i][j]=1<<29;\n        rep(i,30)d[i][i]=0;\n        rep(i,m){\n            string s;\n            cin>>s;\n            for(char &c:s)if(c==',')c=' ';\n            stringstream ss(s);\n            int a,b,d1,d2;\n            ss>>a>>b>>d1>>d2;\n            d[a][b]=d1; d[b][a]=d2;\n        }\n        int x1,x2,y1,y2;\n        string s;cin>>s;\n        for(char &c:s)if(c==',')c=' ';\n        stringstream ss(s);\n        ss>>x1>>x2>>y1>>y2;\n        //printf(\"aa %d %d %d %d\\n\",x1,x2,y1,y2);\n        rep(k,30)rep(i,30)rep(j,30)d[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n        cout << y1 - d[x1][x2] - d[x2][x1] - y2 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n  /*  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[y].cost;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    }\n    ans_cost+=vil[x].cost;*/\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<queue>\n#include<utility>\nusing namespace std;\n\nconst int N = 20+1;\nint costMap[N][N];\n\nint MinCost(int startP, int endP, int n)\n{\n\tint distance[N];\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tint i;\n\tfill(distance, distance+N, INT_MAX);\n\tdistance[startP] = 0;\n\tq.push( make_pair(0, startP) );\n\twhile(!q.empty())\n\t{\n\t\tp = q.front(); q.pop();\n\t\tfor(i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(costMap[p.second][i] != INT_MAX)\n\t\t\t{\n\t\t\t\tif(distance[i] > p.first+costMap[p.second][i])\n\t\t\t\t{\n\t\t\t\t\tdistance[i] = p.first + costMap[p.second][i];\n\t\t\t\t\tq.push( make_pair(distance[i], i) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn distance[endP];\n}\n\n\nint main()\n{\n\tint n,m;\n\tint startP, pillarP, income, pillarCost;\n\twhile(scanf(\"%d%d\",&n,&m) > 0)\n\t{\n\t\tint i,j,a,b,c,d;\n\t\tfor(i = 0; i < N; ++i)\n\t\t\tfor(j = 0; j < N; ++j)\n\t\t\t\tcostMap[i][j] = INT_MAX;\n\t\tfor(i = 0; i < m; ++i)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\t\tcostMap[a][b] = c;\n\t\t\tcostMap[b][a] = d;\n\t\t}\n\t\tscanf(\"%d,%d,%d,%d\",&startP,&pillarP, &income, &pillarCost);\n\n\t\tint goCost = MinCost(startP, pillarP, n),\n\t\t\tfromCost = MinCost(pillarP, startP, n);\n\t\tprintf(\"%d\\n\", income - pillarCost - goCost - fromCost);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#define INF 147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\n//warshall_floyd\nconst int MAX_V=100;\nint d[MAX_V][MAX_V];\nint V;\nvoid WF(){\n  for(int k=1;k<=V;k++)\n    for(int i=1;i<=V;i++)\n      for(int j=1;j<=V;j++)\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}\n//end of warshall_floyd\nint main(){\n  int m;\n  cin>>V>>m;\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n  for(int i=0;i<m;i++){\n    int a,b,c,dd;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&dd);\n    d[a][b]=c;\n    d[b][a]=dd;\n  }\n  WF();\n  int s,g,v,p;\n  scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n  cout<<v-p-d[s][g]-d[g][s]<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint N , M;\n\tchar C;\n\tcin >> N >> M;\n\tvector<vector<pair<int , int>>>data(N);\n\tfor(size_t i = 0; i < M; i++)\n\t{\n\t\tint a , b , c , d;\n\t\tcin >> a >> C >> b >> C >> c >> C >> d;\n\t\ta--; b--;\n\t\tdata[a].push_back(make_pair(b , c));\n\t\tdata[b].push_back(make_pair(a , d));\n\t}\n\tint x1 , x2 , y1 , y2;\n\tcin >> x1 >> C >> x2 >> C >> y1 >> C >> y2;\n\tx1--; x2--;\n\tvector<int>cost1(N , INT_MAX / 6);\n\tauto cost2 = cost1;\n\tpriority_queue<pair<int , int> , vector<pair<int , int>> , greater<pair<int , int>>>que1 , que2;\n\tque1.push(make_pair(0 , x1));\n\tcost1[x1] = 0;\n\twhile(que1.size())\n\t{\n\t\tauto now = que1.top(); que1.pop();\n\t\tif(now.second == x2)break;\n\t\tfor(auto x : data[now.second])\n\t\t{\n\t\t\tif(cost1[x.first] > now.first + x.second)\n\t\t\t{\n\t\t\t\tcost1[x.first] = now.first + x.second;\n\t\t\t\tque1.push(make_pair(cost1[x.first] , x.first));\n\t\t\t}\n\t\t}\n\t}\n\ty1 -= cost1[x2];\n\tque2.push(make_pair(0 , x2));\n\tcost2[x2] = 0;\n\twhile(que2.size())\n\t{\n\t\tauto now = que2.top(); que2.pop();\n\t\tif(now.second == x1)break;\n\t\tfor(auto x : data[now.second])\n\t\t{\n\t\t\tif(cost2[x.first] > now.first + x.second)\n\t\t\t{\n\t\t\t\tcost2[x.first] = now.first + x.second;\n\t\t\t\tque2.push(make_pair(cost2[x.first] , x.first));\n\t\t\t}\n\t\t}\n\t}\n\ty1 -= cost2[x1];\n\ty1 -= y2;\n\tcout << y1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n# define M_PI 3.141592\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m; cin.ignore();\n\tint a[21][21];\n\tmemset(a, -1, sizeof a);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x, y, z, w;\n\t\tscanf(\"%d,%d,%d,%d\", &x, &y, &z, &w);\n\t\ta[x][y] = z;\n\t\ta[y][x] = w;\n\t}\n\tint s, g, p, v;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &p, &v);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t{\n\t\t\t\tif (a[i][k] == -1 || a[k][j] == -1)continue;\n\t\t\t\tif (a[i][j] == -1)a[i][j] = a[i][k] + a[k][j];\n\t\t\t\telse a[i][j] = min(a[i][k] + a[k][j], a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t{\n\t\t\t\tif (a[i][k] == -1 || a[k][j] == -1)continue;\n\t\t\t\tif (a[i][j] == -1)a[i][j] = a[i][k] + a[k][j];\n\t\t\t\telse a[i][j] = min(a[i][k] + a[k][j], a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - v - a[s][g] - a[g][s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nstruct Edge\n{\n\tint from, to, cost;\n\n\tEdge( const int f, const int t, const int c ) : from( f ), to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n};\n\nint bellmanford1( const int V, const vector< Edge > E, const int s, const int t )\n{\n\tvector<int> dist( V, INF );\n\tdist[s] = 0;\n\n\twhile ( true )\n\t{\n\t\tbool update = false;\n\n\t\tfor ( int i = 0; i < E.size(); i++ )\n\t\t{\n\t\t\tif ( dist[ E[i].from ] != INF && dist[ E[i].from ] + E[i].cost < dist[ E[i].to ] )\n\t\t\t{\n\t\t\t\tdist[ E[i].to ] = dist[ E[i].from ] + E[i].cost;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( !update )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint bellmanford2( const int V, const vector< Edge > E, const int s, const int t )\n{\n\tvector<int> dist( V, INF );\n\tdist[s] = 0;\n\n\tfor ( int t = 1; t < V; t++ )\n\t{\n\t\tfor ( int i = 0; i < E.size(); i++ )\n\t\t{\n\t\t\tdist[ E[i].to ] = min( dist[ E[i].to ], dist[ E[i].from ] + E[i].cost );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< Edge > E;\n\n\tfor ( int i = 0; i < m; i++ )\n\t{\n\t\tint a, b, ab, ba;\n\t\tchar d;\n\n\t\tcin >> a >> d >> b >> d >> ab >> d >> ba;\n\n\t\ta--;\n\t\tb--;\n\n\t\tE.push_back( Edge( a, b, ab ) );\n\t\tE.push_back( Edge( b, a, ba ) );\n\t}\n\n\tint s, t, money, price;\n\tchar d;\n\n\tcin >> s >> d >> t >> d >> money >> d >> price;\n\n\ts--;\n\tt--;\n\n\tcout << money - price - bellmanford1( n, E, s, t ) - bellmanford2( n, E, t, s ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint n,m,t[21][21],u[21],v[21],a,b,c,d;\nint cost(int start,int goal){\n\tint mini,miniNo;\n\tfor(int i=0;i<21;i++){\n\t\tu[i]=INF;\n\t\tv[i]=0;\n\t}\n\tu[start]=0;\n\twhile(1){\n\t\tmini=INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(v[i]==0&&u[i]<mini){\n\t\t\t\tminiNo=i;\n\t\t\t\tmini=u[i];\n\t\t\t}\n\t\t}\n\t\tif(mini==INF)break;\n\t\tv[miniNo]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(u[i]>u[miniNo]+t[miniNo][i]){\n\t\t\t\tu[i]=u[miniNo]+t[miniNo][i];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn u[goal];\n}\nint main(){\n\tfor(int i=0;i<21;i++)for(int j=0;j<21;j++)t[i][j]=INF;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\tt[a][b]=c;t[b][a]=d;\n\t}\n\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\tcout<<c-d-cost(a,b)-cost(b,a)<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n int i,j,k,m,n,a1,b1,x1,x2,y1,y2,c1,d1,d[21][21];\n cin >> n;\n for (i=1;i<=n;i++) for (j=1;j<n;j++) if (i==j) d[i][j]=0; else d[i][j]=1000000000;\n cin >> m;\n for (i=0;i<m;i++) {\n\t scanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n     d[a1][b1]=c1; d[b1][a1]=d1;\n }\n scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n cout << y1-y2-d[x1][x2]-d[x2][x1] << endl;\n return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint P[32][32];\nconst int inf = 1001001001;\nint main() {\n\tfor(int e=0;e<32;++e){\n\t\tfor(int f=0;f<32;++f){\n\t\t\tP[e][f]=inf;\n\t\t}\n\t}\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int g=0;g<M;++g){\n\t\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\t\tP[A][B]=C;\n\t\tP[B][A]=D;\n\t}\n\tfor(int k=1;k<=N;++k){\n\t\tfor(int i=1;i<=N;++i){\n\t\t\tfor(int j=1;j<=N;++j){\n\t\t\t\tif(P[i][j]>P[i][k]+P[k][j]){\n\t\t\t\t\tP[i][j] = P[i][k] + P[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\t\n\tint X;\n\tX=y1-P[x1][x2]-P[x2][x1]-y2;\n\tprintf(\"%d\\n\", X);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<P> way[32];\nint def, poal;\nint n;\n\nint mini(int s, int g, int money, int spend = 0);\n\nint main()\n{\n\tint m;\n\t\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\t\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tway[a].push_back(P(c, b));\n\t\tway[b].push_back(P(d, a));\n\t}\n\tint s, g;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &def, &poal);\n\t\n\tprintf(\"%d\\n\", mini(g, s, mini(s, g, def, poal)));\n}\n\nint mini(int s, int g, int money, int spend)\n{\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tint dijkstra[32];\n\t\n\tfor (int i = 0; i <= n; i++) dijkstra[i] = 1000000000;\n\tq.push(P(0, s));\n\tdijkstra[s] = 0;\n\twhile (!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\t\n\t\tif (dijkstra[p.second] < p.first) continue;\n\t\tfor (int i = 0; i < way[p.second].size(); i++){\n\t\t\tP edge = way[p.second][i];\n\t\t\t\n\t\t\tif (dijkstra[edge.second] > dijkstra[p.second] + edge.first){\n\t\t\t\tdijkstra[edge.second] = dijkstra[p.second] + edge.first;\n\t\t\t\tq.push(P(dijkstra[edge.second], edge.second));\n\t\t\t}\n\t\t}\n\t}\n\treturn money - dijkstra[g] - spend;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n\nint cost[21][21],mindist[21],cur,cur_spot;\nbool used[21];\n\nint cost_sum(int n,int x1,int x2){\n  \n  for(int _=1 ; _ <= 20 ; _++){\n    mindist[_]=1e9;\n    used[_]=false;\n  }\n  \n  mindist[x1]=0;\n  \n  for(int _=0 ; _ < n ; _++){\n    cur=INT_MAX;\n    for(int i=1 ; i <= n ; i++){\n      if( cur >= mindist[i] && used[i] == false){\n\tcur=mindist[i];\n\tcur_spot=i;\n      }\n    }\n    used[cur_spot]=true;\n    \n    for(int i=1 ; i <= n ; i++){\n      if(cost[cur_spot][i] != -1){\n\tif(mindist[i] > mindist[cur_spot] + cost[cur_spot][i]){\n\t  mindist[i]=mindist[cur_spot] + cost[cur_spot][i];\n\t}\n      }\n    }\n    \n  }\n  \n  return mindist[x2];\n}    \nint main(){\n  \n  int n,m,a,b,c,d,x1,x2,y1,y2;\n  int cost_go,cost_back;\n  char dam;\n  \n  cin >>n;\n  cin >>m;\n  \n  for(int _=0 ; _ < 20 ; _++){\n    for(int __=0 ; __<20 ; __++){\n      cost[_][__]=-1;\n    }\n  }\n  \n  for(int _=0 ; _ < m ; _++){\n    cin >>a>>dam>>b>>dam>>c>>dam>>d;\n    \n    cost[a][b]=c;\n    cost[b][a]=d;\n  }\n  \n  cin >>x1>>dam>>x2>>dam>>y1>>dam>>y2;\n  \n  cost_go=cost_sum(n,x1,x2);\n  cost_back=cost_sum(n,x2,x1);\n  \n  cout <<y1-y2-cost_go-cost_back<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n#define MAX_N 20\n\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > open;\nmap<int, int> closed;\n\nint search(int start, int goal);\nvoid resetDx();\n\nint n, maxCost, dx[MAX_N][MAX_N][2];\nvoid set(int now, int next, int nowCost, int plusCost);\n\nint main(){\n    resetDx();\n    int m, x1, x2, y1, y2;\n    cin >>n >>m;\n    for(int i = 0; i < m; i++){\n        int a1, b1, c1, d1;\n        scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n        dx[a1][b1][0] = c1;\n        dx[a1][b1][1] = d1;\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    int cost = 0;\n    maxCost = y1 - y2;\n    open.push( make_pair(x1, 0) );\n    cost += search(x1, x2);\n    closed.clear();\n    cout <<\"turn\" <<endl;\n    open.push( make_pair(x2, 0) );\n    cost += search(x2, x1);\n    cout <<maxCost - cost <<endl;\n}\n\nvoid resetDx(){\n    for(int i = 0; i < MAX_N; i++){\n        for(int j = 0; j < MAX_N; j++){\n            dx[i][j][0] = -1;\n            dx[i][j][1] = -1;\n        }\n    }\n}\n\nint search(int start, int goal){\n    while(!open.empty()){\n        int now = open.top().first;\n        int cost = open.top().second;\n        open.pop();\n        for(int i = 1; i <= n; i++){\n            if(dx[now][i][0] != -1) set(now, i, cost, dx[now][i][0]);\n            if(dx[i][now][1] != -1) set(now, i, cost, dx[i][now][1]);\n        }\n    }\n    return closed[goal];\n}\n\n\nvoid set(int now, int next, int nowCost, int plusCost){\n    int sum = nowCost + plusCost;\n    \n    if((closed.find(next) == closed.end() || closed[next] > sum) && sum <= maxCost){\n        open.push( make_pair(next, sum));\n        closed[next] = sum;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 25;\nconst int MAX_V = 30 * 30;\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid dijkstra(int s) {\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[s] = 0;\n\n\twhile(true) {\n\t\tint v = -1;\n\t\tfor(int u = 0; u < V; u++) {\n\t\t\tif(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t}\n\t\tif(v == -1) break;\n\n\t\tused[v] = true;\n\t\tfor(int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n}\nint main() {\n\tint n, m, s, g, money, pillar;\n\tscanf(\"%d %d\", &n, &m);\n\tV = n;\n\n\tfor(int i = 0; i < V; i++) {\n\t\tfor(int j = 0; j < V; j++) {\n\t\t\tcost[i][j] = (i == j) ? 0 : INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &money, &pillar);\n\ts--, g--;\n\tint sum = pillar;\n\tdijkstra(s);\n\tsum += d[g];\n\tdijkstra(g);\n\tsum += d[s];\n\tprintf(\"%d\\n\", money - sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Node\n{\n\tvector<int> to,cost;\n};\n\nstruct Tri\n{\n\tint p,ct;\n\tTri(int pp, int cc) {p=pp;ct=cc;}\n\n\tbool operator<(const Tri &t) const\n\t{\n\t\treturn ct > t.ct;\n\t}\n};\n\nNode node[32];\nbool visited[32];\n\nint main()\n{\n\tchar c1,c2,c3;\n\tint x1,x2,y1,y2;\n\tint n,m,a,b,ab,ba;\n\tcin >> n >> m;\n\twhile(m--)\n\t{\n\t\tcin >> a >> c1 >> b >> c2 >> ab >> c3 >> ba;\n\t\tnode[a].to.push_back(b);\n\t\tnode[a].cost.push_back(ab);\n\t\tnode[b].to.push_back(a);\n\t\tnode[b].cost.push_back(ba);\n\t}\n\tcin >> x1 >> c1 >> x2 >> c2 >> y1 >> c3 >> y2;\n\t\n\tmemset(visited,0,sizeof(visited));\n\tpriority_queue<Tri> pq;\n\tpq.push(Tri(x1,0));\n\twhile(!pq.empty())\n\t{\n\t\tTri tt = pq.top(); pq.pop();\n\t\t\n\t\tif(tt.p == x2)\n\t\t{\n\t\t\ty1-=tt.ct;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visited[tt.p])continue;\n\t\tvisited[tt.p] = true;\n\n\t\tfor(int i=0; i<node[tt.p].to.size(); i++)\n\t\t{\n\t\t\tpq.push(Tri(node[tt.p].to[i], node[tt.p].cost[i]+tt.ct));\n\t\t}\n\t}\n\tmemset(visited,0,sizeof(visited));\n\twhile(!pq.empty()) pq.pop();\n\tpq.push(Tri(x2,0));\n\twhile(!pq.empty())\n\t{\n\t\tTri tt = pq.top(); pq.pop();\n\t\t\n\t\tif(tt.p == x1)\n\t\t{\n\t\t\ty1-=tt.ct;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visited[tt.p])continue;\n\t\tvisited[tt.p] = true;\n\n\t\tfor(int i=0; i<node[tt.p].to.size(); i++)\n\t\t{\n\t\t\tpq.push(Tri(node[tt.p].to[i], node[tt.p].cost[i]+tt.ct));\n\t\t}\n\t}\n\n\tcout << y1-y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, A, B, C, D, S, G, V, P;\nint K[32][32];\nconst int inf = 1001001001;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n\n  for (int i = 0; i<M; i++) {\n    for (int j = 0; j<M; j++) {\n      K[i][j] = inf;\n    }\n  }\n\n  for (int i=0; i<M; i++) {\n    scanf(\"%d, %d, %d, %d\", &A, &B, &C, &D);\n    K[A-1][B-1] = C;\n    K[B-1][A-1] = D;\n  }\n  scanf(\"%d, %d, %d, %d\", &S, &G, &V, &P);\n\n  for (int k=0; k<N; k++) {\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        K[i][j] = min(K[i][j], K[i][k] + K[k][j]);\n      }\n    }\n  }\n\n  cout << V - P - K[S-1][G-1] - K[G-1][S-1] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define INF 100000000\nint main(){\n  int n,m;\n  cin >> n >> m;\n  int data[n+1][n+1],a,b,c,d;\n  char s;\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++) data[i][j] = INF;\n  }\n  for(int i=0;i<m;i++){\n    cin >> a >> s >> b >> s >> c >> s >> d;\n    data[a][b] = c;\n    data[b][a] = d;\n  }\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tdata[i][j] = min(data[i][j],data[i][k]+data[k][j]);\n      }\n    }\n  }\n  /*for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++) cout << data[i][j] << ' ';\n    cout << endl;\n    }*/\n  int x,x2,y,y2;\n  cin >> x >> s >> x2 >> s >> y >> s >> y2;\n  cout << y - data[x][x2] - data[x2][x] - y2 << endl;\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define INF (1 << 20)\nint g[20][20];\nint main()\n{\n    int n, m; scanf(\"%d%d\", &n, &m);\n    rep(i, n) rep(j, n) g[i][j] = INF;\n    rep(i, m) {\n        int p, q, r, s;\n        scanf(\"%d,%d,%d,%d\", &p, &q, &r, &s);\n        p--, q--;\n        g[p][q] = r; g[q][p] = s;\n    }\n    rep(i, n) g[i][i] = 0;\n    rep(k, n) rep(i, n) rep(j, n) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n    }\n\n    int w, x, y, z;\n    scanf(\"%d,%d,%d,%d\", &w, &x, &y, &z);\n    w--, x--;\n    printf(\"%d\\n\", y - (z + g[w][x] + g[x][w]));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 20\n#define INF 1e9\nusing namespace std;\n\nint dp[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\nint n,m;\n\nvoid warshall_froyd(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n    }\n  }\n}\n\nint main(){\n  cin >> n; \n  cin >> m;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dp[i][j] = (i==j ? 0 : INF);\n      dp[i][j] = (i==j ? 0 : INF);\n    }\n  }\n  \n  for(int i=0;i<m;i++){\n    int a,b,atob,btoa;\n    cin >> a >> b >> atob >> btoa;\n    a--; b--;\n    dp[a][b] = atob; dp[b][a] = btoa;\n  }\n\n  warshall_froyd();\n  cin >> start >> goal >> reward >> price;\n  cout << reward - dp[start][goal] - price << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\nconst int INF = 1 << 20;\n\nusing namespace std;\n\nint go[32][32], dict[32];\nbool node[32];\nchar cn1, cn2, cn3;\n\nint main()\n{\n\tint num, total, wk, tk, kt, kr;\n\n\t//input start\n\tcin >> total >> num;\n\n\tfor(int i = 0; i < total; i++)\n\t{\n\t\tdict[i] = INF;\n\t\tnode[i] = false;\n\t\tfor(int j = 0; j < total; j++)\n\t\t{\n\t\t\tgo[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tcin >> wk >> cn1 >> tk >> cn2 >> kt >> cn3 >> kr;\n\n\t\tgo[wk-1][tk-1] = kt;\n\t\tgo[tk-1][wk-1] = kr;\n\t}\n\n\tint start, goal, exp, rew;\n\tcin >> start >> cn1>> goal >> cn2 >> rew >> cn3 >> exp;\n\n\t//input end\n\t\n\t//go dijkstra\n\tdict[start - 1] = 0;\n\trew -= exp;\n\t\n\twhile(1)\n\t{\n\t\tint v = -1;\n\n\t\tfor(int i = 0; i < total; i++)\n\t\t{\n\t\t\tif(!node[i] && (v == -1 || dict[i] < dict[v])) v = i;\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tnode[v] = true;\n\n\t\tfor(int i = 0; i < total; i++)\n\t\t{\n\t\t\tdict[i] = min(dict[i], dict[v] + go[v][i]);\n\t\t}\n\t\n\t}\n\n\trew -= dict[goal -1];\n\n\tfor(int i = 0; i < total; i++)\n\t{\n\t\tnode[i] = false;\n\t\tdict[i] = INF;\n\t}\n\n\t//back dijkstra\n\tdict[goal - 1] = 0;\n\twhile(1)\n\t{\n\t\tint v = -1;\n\t\tfor(int i = 0; i < total; i++)\n\t\t{\n\t\t\tif(!node[i] && (v == -1 || dict[i] < dict[v]) ) v = i;\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tnode[v] = true;\n\n\t\tfor(int i = 0; i < total; i++)\n\t\t{\n\t\t\tdict[i] = min(dict[i], dict[v] + go[v][i]);\n\t\t}\n\t}\n\n\trew -= dict[start -1];\n\n\tcout << rew << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nA Reward for a Carpenter(https://onlinejudge.u-aizu.ac.jp/problems/0117)\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecll> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 32;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst int MOD = 1000000007;\n\nint wf[MAX][MAX];\n\nvoid solve(void){\n\tint N, M, s, g, V, P;\n\tchar cc;\n\tcin >> N >> M;\n\n\trep(N, i) rep(N, j) wf[i][j] = (i == j ? 0 : INF);\n\n\n\trep(M, i)\n\t{\n\t\tchar cc;\n\t\tint a, b, c, d;\n\t\tcin >> a >> cc >> b >> cc >> c >> cc >> d;\n\n\t\t//cout << a << b << c << d << endl;\n\n\t\ta--, b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\n\trep(N, k) rep(N, i) rep(N, j) wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\tcin >> s >> cc >> g >> cc >> V >> cc >> P;\n\ts--, g--;\n\n\t/*\n\trep(N, i) rep(N, j)\n\t{\n\t\tcout << wf[i][j] << ' ';\n\t\tif (j == N-1) cout << endl;\n\t}\n\t*/\n\n\tcout << V - P - wf[s][g] - wf[g][s] << endl;\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 100000000\nusing namespace std;\n//typedef pair<int,int> P\nint glid[22][22];\nint kakutei[22],leng[22];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\t//priority_queue<P, vector<P>, greater<P> > go;\n\t//P toridasi;\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<=n;i++) {\n\t\tfor(j=0;j<=n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) glid[i][i]=0;\n\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n//\tcout<<start<<finish<<okane<<value<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t//\t\t\tmi=glid[point][j];\n\t\t\t}\n\t\t}\n\t//\tokane=okane-mi;\n\t}\n\t//for(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tokane-=leng[finish];\n\t//cout<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[finish]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t//\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t\t//mi=glid[point][j];\n\t\t\t}\n\t\t}\n\t\t//okane=okane-mi;\n\t}\n//\tfor(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tswap(start,finish);\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9;\nusing namespace std;\n\nint main(){\n    int n,m,a,b,c,d,s,g,v,p;\n    int co[22][22];\n    cin >> n >> m;\n    for (int i = 0;i < 22; i++)for (int j = 0;j < 22;j++)co[i][j] = INF;\n    for (int i = 0;i < m; i++){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        co[a-1][b-1] = c;\n        co[b-1][a-1] = d;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                if(co[j][i]+co[i][k] < co[j][k]) co[j][k] = co[j][i]+co[i][k];\n            }\n        }\n    }\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n    cout << v-p-co[s-1][g-1]-co[g-1][s-1] << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,x3,x4;\n\n\nint main() {\n\n  scanf(\"%d%d\", &N, &M);\n  int K[24][24];\n  for (int i=1; i<=N; i++){\n    for(int j=1; j<=N; j++){\n      K[i][j] = 1e6;\n    }\n  }\n\n  while(M) {\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B] = C;\n    K[B][A] = D;\n    M--;\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &x3, &x4);\n  for (int k=1; k<=N; k++){\n    for(int i=1; i<=N; i++){\n      for(int j=1; j<=N; j++){\n        if(K[i][j] > K[i][k] + K[k][j]){\n          K[i][j] = K[i][k] + K[k][j];\n        }\n      }\n    }\n  }\n\n  // int answer;\n  // answer = x3 - x4 - K[x1][x2] - K[x2][x1];\n  cout << (x3 - x4 - K[x1][x2] - K[x2][x1]) << endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 100005\n#define MAX_V 100001\n#define INF (1e9 + 1)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint g[20][20];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tg[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tg[a-1][b-1]=c;\n\t\tg[b-1][a-1]=d;\n\t}\n\tint s,g,V,P;\n\tscanf(\"%d%d%d%d\",&s,&g,&V,&P);\n\tfor(int k=0;k<n;k++)\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tprintf(\"%d\\n\",V-P-g[s][g]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint cost[21][21];\nint n,m;\n\nint go_to_home(int start, int goal, int now_place, int now_cost, bool village[21]);\n\nint go_to_village(int start, int goal, int now_place, int now_cost, bool village[21]){\n    if(goal == now_place){\n        \n        int min_temp = 9999999*20;\n        for(int i=1; i<=n; i++){\n            if(cost[now_place][i]!=-1){\n                bool init_village[21]={0};\n                init_village[now_place]=1;\n                init_village[i]=1;\n                min_temp = min(min_temp, go_to_home(goal, start, i, now_cost+cost[now_place][i], init_village));\n            }\n        }\n        return min_temp;\n    }\n    \n    int min_temp = 9999999*20;\n    for(int i=1; i<=n; i++){\n        if(cost[now_place][i]!=-1&&village[i]==0){\n            bool temp_village[21];\n            for(int j=0; j<=n; j++){\n                temp_village[j]=village[j];\n            }\n            temp_village[now_place]=1;\n            temp_village[i]=1;\n            min_temp = min(min_temp, go_to_village(start, goal, i, now_cost+cost[now_place][i], temp_village));\n        }\n    }\n    return min_temp;\n    \n}\n\nint go_to_home(int start, int goal, int now_place, int now_cost, bool village[21]){\n    if(goal == now_place){\n        return now_cost;\n    }\n    \n    int min_temp = 9999999*20;\n    for(int i=0; i<=n; i++){\n        if(cost[now_place][i]!=-1&&village[i]==0){\n            bool temp_village[21];\n            for(int j=0; j<=n; j++){\n                temp_village[j]=village[j];\n            }\n            temp_village[now_place]=1;\n            temp_village[i]=1;\n            min_temp = min(min_temp, go_to_home(start, goal, i, now_cost+cost[now_place][i], temp_village));\n        }\n    }\n    return min_temp;\n}\n\n\nint main(){\n    for(int i=0; i<21; i++){\n        for(int j=0; j<21; j++){\n            cost[i][j]=-1;\n        }\n    }\n    \n    while(cin>>n){\n        cin>>m;\n        for(int i=0; i<m; i++){\n            string text;\n            cin>>text;\n            \n            for(int i=0; i<text.size(); i++){\n                if(text[i] == ',')text[i] = ' ';\n            }\n            \n            stringstream ss;\n            ss<<text;\n            \n            int a,b,c,d;\n            ss>>a>>b>>c>>d;\n            \n            cost[a][b]=c;\n            cost[b][a]=d;\n            \n            \n        }\n        \n        string text2;\n        cin>>text2;\n        \n        for(int i=0; i<text2.size(); i++){\n            if(text2[i] == ',')text2[i] = ' ';\n        }\n        \n        stringstream ss;\n        ss<<text2;\n        \n        int x1,x2,y1,y2;\n        ss>>x1>>x2>>y1>>y2;\n        \n        bool village[21]={0};\n        village[x1]=1;\n        int ans = go_to_village(x1, x2, x1, 0, village);\n        cout<<y1-y2-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n//A reward for a Carpenter\n//???????????£???????????????\n\n// 1???????????????????????°n???n???20??? \n// 2??????????????????????????°m \n// 3????????????1???????????????????????± a1, b1, c1, d1?????´??°;????§??????????????????????\n//    a1, b1?????????????????????????????§?????????????????? \n//    c1 ???a1 ?????? b1 ??????????????? (0???1000)\n//    d1 ???b1 ?????? a1 ??????????????? (0???1000)\n// 4????????????2???????????????????????± a2, b2, c2, d2?????´??°;????§??????????????????????\n//   : : \n//   : : \n// ???????????????x1, x2, y1, y2?????´??°;????§?????????????????????? \n// x1?????§??\\??????????????????????????? \n// x2?????±??????????±±???????????? \n// y1???????§?????????§??\\??????????????£????????? \n// y2?????±?????£???\n\nint n, m;\nint root[20][20];\nint dp[20][20];\n\nint s, g, y1, y2;\nint INF = 9999999;\n\nvoid print(){\n\tfor(int i=0 ; i<n ; i++){\n\t\tfor(int j=0 ; j<n ; j++){\n\t\t\tcout << root[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid init(){\n\tfor(int i=0 ; i<n ; i++){\n\t\tfor(int j=0 ; j<n ; j++){\n\t\t\troot[i][j] = INF;\n\t\t}\n\t}\n}\n\n\nvoid WF(){\n\n\tfor(int k=0 ; k<n ; k++){\n\t\tfor(int i=0 ; i<n ; i++){\n\t\t\tfor(int j=0 ; j<n ; j++){\n\t\t\t\troot[i][j] = min(root[i][j], root[i][k] + root[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tcin >> n;\n\tcin >> m;\n\n\tinit();\n\n\tfor(int i=0 ; i<m ; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;\n\t\tb--;\n\n\t\troot[a][b] = c;\n\t\troot[b][a] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\", &s,&g,&y1,&y2);\n\t// cout << s << \" \" << g << endl;\n\ts--;\n\tg--;\n\n\t// print();\n\n\tWF();\n\t// print();\n\n\tcout << y1-y2-root[s][g]-root[g][s] << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n long long d[21][21],y1,y2;\n int i,j,k,m,n,a1,b1,c1,d1,x1,x2;\n cin >> n;\n for (i=1;i<=n;i++) for (j=1;j<n;j++) if (i==j) d[i][j]=0; else d[i][j]=999999999999;\n cin >> m;\n for (i=0;i<m;i++) {\n\t scanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n     d[a1][b1]=c1; d[b1][a1]=d1;\n }\n scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n cout << y1-y2-d[x1][x2]-d[x2][x1] << endl;\n return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,s,n) for(int i=s;i<n;i++)\n#define REP(i,n) rep(i,0,n)\n#define NMAX 21\n#define INF 1<<26\nint dist[NMAX][NMAX];\nint n,m;\nint x1,x2,y1,y2;\nvoid init(){\n\tREP(i,NMAX)REP(j,NMAX)dist[i][j]=INF;\t\n}\nvoid wf(){\n\trep(k,1,n+1){\n\t\trep(i,1,n+1){\n\t\t\trep(j,1,n+1){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\t\n\t}\n}\nvoid solve(){\n\tcout<<y1-y2-dist[x1][x2]-dist[x2][x1]<<endl;\n}\nint main(){\n\tint a,b,c,d;\n\tchar dummy;\n\tcin>>n>>m;\t\n\tinit();\n\tREP(i,m){\n\t\tcin>>a>>dummy>>b>>dummy>>c>>dummy>>d;\n\t\tdist[a][b]=c;\n\t\tdist[b][a]=d;\n\t}\n\twf();\n\tcin>>x1>>dummy>>x2>>dummy>>y1>>dummy>>y2;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tgetline(cin, s);\n\tgetline(cin, s);\n\tint t = 3;\n\twhile(getline(cin, s)){\n\t\tint a = -1, b = -1;\n\t\tsscanf(s.c_str(), \"%*d,%*d,%*d,%*d%n %*c%n\", &a, &b);\n\t\tif(a != -1 && b == -1){\n\t\t\tcerr << t << \": \" << s << endl;\n\t\t}\n\t\t++t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 100;\n\nint main(){\n  for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf =1001001111;\n\nint main() {\nfor(int j=0;j<32;j++){\n\tfor(int jj=0;jj<32;jj++){\n\t\tK[j][jj]=inf;\n\t}\n}\n\t\nscanf(\"%d%d\",&N,&M);\nfor(int ii=0;ii<M;ii++){\n\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\tK[A][B]=C;\n\tK[B][A]=D;\n}\nfor(int k=1;k<=N;k++){\nfor(int i=1;i<=N;i++){\n\tfor(int j=1;j<=N;j++){\n\t\tif(K[i][j]>K[i][k]+K[k][j]){\n\t\t\tK[i][j]=K[i][k]+K[k][j];\n\t\t}\n\t}\n}\t\n}\n\nscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\nint a;\na=y1-y2-K[x1][x2]-K[x2][x1];\n\nprintf(\"%d\\n\", a);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int INF=100100100;\nusing namespace std;\nint n,m;\nint K[32][32];\n\nint main(){\n\n  scanf(\"%d%d\", &n,&m);\n  \n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      K[i][j]=INF;\n    }\n  }\n  int a,b,c,d;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    K[a][b]=c;\n    K[b][a]=d;\n  }\n  int start,goal,inp,val;\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&inp,&val);\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(K[i][j] > K[i][k]+K[k][j]){\n\t  K[i][j]=K[i][k]+K[k][j];\n\t}\n      }\n    }\n  }\n  int ans=inp-val-K[start][goal]-K[goal][start];\n  printf(\"%d\",ans);\n}\n\n  \n  \n    \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n    rep(i, n) dp[i][i] = 0;\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF 1000000\nint C[30][30];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n            C[i][j]=i==j?0:INF;\n        }\n    }\n    for(int i=0;i<m;++i){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--;b--;\n        C[a][b]=c;\n        C[b][a]=d;\n    }\n    for(int k=0;k<n;++k){\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                C[i][j]=min(C[i][j],C[i][k]+C[k][j]);\n            }\n        }\n    }\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    printf(\"%d\\n\",c-d-C[a][b]-C[b][a]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF 1000000\nint C[30][30];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n            C[i][j]=i==j?0:INF;\n        }\n    }\n    for(int i=0;i<m;++i){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--;b--;\n        C[a][b]=c;\n        C[b][a]=d;\n    }\n    for(int k=0;k<n;++k){\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                C[i][j]=min(C[i][j],C[i][k]+C[k][j]);\n            }\n        }\n    }\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    printf(\"%d\",c-d-C[a][b]-C[b][a]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<cstdio>\n#include<algorithm>\nconst int INF = 1001;\nconst int V = 20;\nint dis[V][V];\nint n, m;\n\nvoid warshall_floyd(){\n\tfor (int k = 0; k < n; ++k)\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) dis[i][j] = i == j ? 0 : INF;\n\tfor (int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t--a; --b;\n\t\tdis[a][b] = c;\n\t\tdis[b][a] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t--x1; --x2;\n\twarshall_floyd();\n\ty1 -= dis[x1][x2];\n\ty1 -= dis[x2][x1];\n\ty1 -= y2;\n\tprintf(\"%d\\n\", y1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int d[21][21];\n  fill_n(d[0],21*21,1<<29);\n  for(int i=0;i<m;i++){\n    int a[4];\n    for(int i=0;i<4;i++){\n      cin>>a[i];\n      cin.ignore();\n    }\n    d[a[0]][a[1]]=a[2];\n    d[a[1]][a[0]]=a[3];\n  }\n  for(int i=1;i<=20;i++){\n    for(int j=1;j<=20;j++){\n      for(int k=1;k<=20;k++){\n\td[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n  }\n  int s,t,p,c;\n  (((cin>>s).ignore()>>t).ignore()>>p).ignore()>>c;\n  cout<<p-c-d[s][t]-d[t][s]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  int n,m;\n  cin >> n >> m;\n\n  int d[n+1][n+1];\n  REP(i,n+1){\n    fill( d[i], d[i]+n+1, INF );\n    d[i][i] = 0;\n  }\n\n  REP(i,m){\n    int a,b,c,dd;\n    scanf( \"%d,%d,%d,%d\", &a, &b, &c, &dd );\n    d[a][b] = c;\n    d[b][a] = dd;\n  }\n  \n  int x1,x2,y1,y2;\n  scanf( \"%d,%d,%d,%d\", &x1, &x2, &y1, &y2 );\n  \n  REP(k,n+1)\n    REP(i,n+1)\n    REP(j,n+1)\n    d[i][j] = min( d[i][j], d[i][k] + d[k][j] );\n  \n  int res = y1 - y2 - d[x1][x2] - d[x2][x1];\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <sstream>\n#include <algorithm>\n\n#define INF 10000000\n\nint n, m, st, gl, money, pole;\nint roads[21][21];\nint in[4];\nstd::string input;\n\nint check( int start, int goal ){\n\tint cost[21];\n\tint used = 0;\n\n\tstd::fill( cost, cost + 21, INF );\n\tcost[start] = 0;\n\n\twhile(1){\n\t\tint v = -1;\n\t\tfor( int i = 1; i <= n; i++ ){\n\t\t\tif( !(used & 1 << i ) && (v == -1 || cost[i] < cost[v]) ) v = i;\n\t\t}\n\n\t\tif( v == -1 )break;\n\n\t\tused = used | 1 << v;\n\n\t\tfor( int i = 1; i <= n; ++i ){\n\t\t\tcost[i] = std::min( cost[i], cost[v] + roads[v][i] );\n\t\t}\n\t}\n\n\treturn cost[goal];\n}\n\nint main(){\n\tfor( int i = 0; i < 21; ++i )\n\t\tstd::fill( roads[i], roads[i] + 21, INF );\n\n\tstd::cin >> n >> m;\n\n\tfor( int i = 0; i < m; ++i ){\n\t\tstd::cin >> input;\n\n\t\tsscanf( input.c_str(), \"%d,%d,%d,%d\", in, &in[1], &in[2], &in[3] );\n\n\t\troads[ in[0] ][ in[1] ] = in[2];\n\t\troads[ in[1] ][ in[0] ] = in[3];\n\t}\n\n\tstd::cin >> input;\n\tsscanf( input.c_str(), \"%d,%d,%d,%d\", &st, &gl, &money, &pole );\n\n\tmoney -= pole;\n\n\tint cost = check( st, gl );\n\tcost += check( gl, st );\n\n\tstd::cout << money - cost << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main() {\n\tint n, m, a, b, c, d, i, j, k, x[21][21];\n\tcin >> n >> m;\n\tfor(i = 1; i <= n; i++)\n\t\tfor(j = 1; j <= n; j++)\n\t\t\tx[i][j] = 1001;\n\tfor(i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tfor(k = 1; k <= n; k++)\n\t\tfor(i = 1; i <= n; i++)\n\t\t\tfor(j = 1; j <= n; j++)\n\t\t\t\tif (x[i][j] > x[i][k] + x[k][j]) x[i][j] = x[i][k] + x[k][j];\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tcout << c - d - x[a][b] - x[b][a] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nint solve(int s, int e)\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn D[s][e];\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tV = n;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tcout << y1 - solve(x1, x2) - D[x2][x1] - y2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n\nusing namespace std;\ntypedef long long int lint;\n\n#define INF 10000000\n\ntemplate <typename _Ty>\nstd::ostream& operator << (std::ostream& ostr, const std::vector<_Ty> v) {\n\tif (v.empty()) return ostr;\n\tfor (auto itr = v.begin(); itr != v.end(); itr++) {\n\t\tif (itr == v.begin()) {\n\t\t\tstd::cout << \"{\" << *itr;\n\t\t}\n\t\telse std::cout << \", \" << *itr;\n\t}\n\tstd::cout << \"}\";\n\treturn ostr;\n}\n\nclass Point2i {\npublic:\n\tint x;\n\tint y;\n\n\tPoint2i() {\n\t\tthis->x = x; this->y = y;\n\t}\n\tPoint2i(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tfriend std::ostream& operator << (std::ostream& ostr, const Point2i& p) {\n\t\tstd::cout << \"{\" << p.x << \", \" << p.y << \"}\";\n\t\treturn ostr;\n\t}\n};\n\nint* mk_vector(int size, int init)\n{\n\tint* vec = new int[size];\n\tfor (int i = 0; i < size; i++) {\n\t\tvec[i] = init;\n\t}\n\treturn vec;\n}\n\nint** mk_matrix(int size, int init)\n{\n\tint** mat = new int*[size];\n\tfor (int i = 0; i < size; i++) {\n\t\tmat[i] = new int[size];\n\t}\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < size; j++) {\n\t\t\tmat[i][j] = init;\n\t\t}\n\t}\n\treturn mat;\n}\n\nvoid print(int** mat, int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tprintf(\"%15d\", mat[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint Dijkstra(int size, int start, int goal, int** cost)\n{\n\t//??????S\n\tbool* S = new bool[size + 1];\n\t//??????V-S\n\tbool* V = new bool[size + 1];\n\t//D[i] : i??????????????????????°??????????\n\tint* D = mk_vector(size + 1, INF);\n\n\tfor (int i = 1; i <= size; i++) {\n\t\tS[i] = false;\n\t\tV[i] = true;\n\t}\n\n\tS[start] = true;\n\tV[start] = false;\n\tfor (int i = 1; i <= size; i++) {\n\t\tif (S[i]) continue;\n\t\tD[i] = cost[start][i];\n\t}\n\n\t/*\n\tcout << \"initial state\" << endl;\n\tcout << \"S = {\";\n\tfor (int i = 1; i <= size; i++) {\n\t\tif (S[i]) cout << i << \",\";\n\t}\n\tcout << \"}\" << endl;\n\tfor (int i = 1; i <= size; i++) {\n\t\tif (i == start) continue;\n\t\tprintf(\"D[%d] = %d, \", i, D[i]);\n\t}\n\tcout << endl;\n\t*/\n\n\tfor (int i = 1; i <= size - 1; i++) {\n\t\t//D[w] ???????°???¨?????? w in V-S ????±???????\n\t\tint w;\n\t\tint minD = INF;\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (!V[i]) continue;\n\t\t\tif (D[i] < minD) {\n\t\t\t\tminD = D[i];\n\t\t\t\tw = i;\n\t\t\t}\n\t\t}\n\t\t//S = S cup {w}\n\t\tS[w] = true;\n\t\tV[w] = false;\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (!V[i]) continue;\n\t\t\tD[i] = min(D[i], D[w] + cost[w][i]);\n\t\t}\n\n\t\t/*\n\t\tcout << \"step \" << i << endl;\n\t\tcout << \"S = {\";\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (S[i]) cout << i << \",\";\n\t\t}\n\t\tcout << \"}\" << endl;\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (i == start) continue;\n\t\t\tprintf(\"D[%d] = %d, \", i, D[i]);\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\n\tint ret = D[goal];\n\n\tdelete[] S;\n\tdelete[] V;\n\tdelete[] D;\n\n\treturn ret;\n}\n\nvoid AOJ0117()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tint** cost = mk_matrix(n + 1, INF);\n\tfor (int i = 0; i < m; i++) {\n\t\tint\ta, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c; // a to b\n\t\tcost[b][a] = d; // b to a\n\t}\n\tint start, goal, V, P;\n\tscanf(\"%d,%d,%d,%d\", &start, &goal, &V, &P);\n\n\t//print(cost, n);\n\n\tint ans = V - P - Dijkstra(n, start, goal, cost) - Dijkstra(n, goal, start, cost);\n\n\tcout << ans << endl;\n\n\treturn;\n}\n\nint main()\n{\n\tAOJ0117();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define REP(i,s,n) for(long long i=(s);i<=(n);i++)\n#define repr(i,n) for(long long i=n-1;i>=0;i--)\n#define REPR(i,s,n) for(long long i=(s);i>=(n);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define Eunique(v) v.erase(unique(all(v)),v.end())\n#define Eback(s) s.erase(s.end()-1,s.end())\n#define rev(v) reverse(all(v))\n#define minvec(v) *min_element(all(v))\n#define maxvec(v) *max_element(all(v))\n#define sumvec(v) accumulate(all(v),0LL)\n#define mapmin(v) v.rbegin()->first\n#define mapmax(v) v.begin()->first\n#define pb push_back\n#define pf push_front\n#define m_p make_pair\n#define DOUBLE fixed << setprecision(15)\n#define OK cerr<<\"OK\\n\"\n#define OK1 cerr<<\"OK1\\n\"\n#define OK2 cerr<<\"OK2\\n\"\n#define sz(s) (long long)s.size()\n#define INF ((1LL<<62)-(1LL<<31))\n#define zero(x,n) setw(x) << setfill('0') << n\n#define endl '\\n'\n\ntypedef long long ll;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vll> vvll;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<string> vs;\n\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<pair<ll,ll>> vpll;\n\nconst double pi = acos(-1.0);\nconst ll mod=1000000007;\n//const ll mod=998244353;\n\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const pair<A, B>&p) {\n\tost << \"{\" << p.first << \", \" << p.second << \"} \";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost, const vector<T>&v) {\n\tost << \"{\";\n\tfor (int i = 0; i<(int)v.size(); i++) {\n\t\tif (i)ost << \" \";\n\t\tost << v[i];\n\t}\n\tost << \"} \\n\";\n\treturn ost;\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const map<A, B>&v) {\n\tost << \"{\";\n\tfor (auto p:v) {\n\t\tost << \"{\" << p.first << \", \" << p.second << \"} \";\n\t}\n\tost << \"} \";\n\treturn ost;\n}\n\nvoid out(){cout << \"\\n\";}\ntemplate<class T,class... Args>\nvoid out(const T &x,const Args &... args){\n\tcout << x << \" \";\n\tout(args...);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n\tfor(T& e: vec) is >> e;\n\treturn is;\n}\n\ntemplate<typename T>\nstring join(vector<T>& vec, string sep=\" \"){\n\tstringstream ss;\n\tfor(int i=0;i<(int)vec.size();i++){\n\t\tss << vec[i] << (i+1==(int)vec.size()?\"\\n\":sep);\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T>\ninline bool chmax(T& a, T b){if(a<b){a=b;return true;} return false;}\n\ntemplate<class T>\ninline bool chmin(T& a, T b){if(a>b){a=b;return true;} return false;}\n\nvoid YES(bool b) {cout << ((b)?\"YES\\n\":\"NO\\n\");}\nvoid Yes(bool b) {cout << ((b)?\"Yes\\n\":\"No\\n\");}\nvoid yes(bool b) {cout << ((b)?\"yes\\n\":\"no\\n\");}\nvoid Yay(bool b) {cout << ((b)?\"Yay!\\n\":\":(\\n\");}\n\nll powmod(ll a,ll b){ll c=1; while(b>0){ if(b&1){ c=a*c%mod; } a=a*a%mod; b>>=1; } return c;}\nll invmod(ll a){ return powmod(a,mod-2); }\nll nCrmod(ll n,ll r){ll x=1,y=1; for(ll i=0;i<r;i++) {x=x*(n-i)%mod; y=y*(i+1)%mod; } return x*powmod(y,mod-2)%mod;}\nll gcd(ll x, ll y) {return __gcd(x,y);}\nll lcm(ll x, ll y) {return x/__gcd(x,y)*y;}\n\nint main()\n{\n\tll n,m;\n\tchar x;\n\tcin >> n >> m;\n\tvvll dist(n,vll(n,INF));\n\trep(i,n) dist[i][i]=0;\n\trep(i,m){\n\t\tll a,b,c,d;\n\t\tcin >> a >> x >> b >> x >> c >> x >> d;\n\t\ta--;\n\t\tb--;\n\t\tdist[a][b]=c;\n\t\tdist[b][a]=d;\n\t}\n\trep(k,n)rep(i,n)rep(j,n) chmin(dist[i][j],dist[i][k]+dist[k][j]);\n\tll s,v,g,p;\n\tcin >> s >> x >> g >> x >> v >> x >> p;\n\ts--;\n\tg--;\n\tcout << v-dist[s][g]-dist[g][s]-p << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#define M 100\nusing namespace std;\nint main(void)\n{\n\tint n,i,j,k,a[41],b[41],c[41],d[41],m,min,kaku,cnt,F[100],ex;\n\tint x,y,x2,y2;\n\tint date[41][41];\n\tint cost[41],flg[41],cost1[41];\n\t\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\t\n\tfor(i=1;i<=m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a[i],&b[i],&c[i],&d[i]);//?????????\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&x2,&y2);//?????????\n\t\n\tfor(i=1;i<=n;i++) {\n\t\tcost[i]=M;\n\t\tflg[i]=0;\n\t}\n\t\n\t\n\tfor(i=1;i<=n;i++) {\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tdate[i][j]=M;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=m;i++) {\n\t\tdate[a[i]][b[i]]=c[i];\n\t\tdate[b[i]][a[i]]=d[i];\n\t}\n\t\n\tfor(i=1;i<=n;i++) date[i][i]=0;\n\t\n\tcost[x]=0;\n\tfor(i=1;i<=n;i++) {\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) F[i]=0;\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tif(flg[j]==0 && cost[j]<min) {\n\t\t\t\tkaku=j;\n\t\t\t\tmin=cost[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg[kaku]=1;\n\t\t\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tif((cost[kaku]+date[kaku][j])<cost[j]) cost[j]=cost[kaku]+date[kaku][j];\n\t\t}\n\t\t\n\t}\n//\tfor(i=1;i<=n;i++) printf(\"%d<-%d - %d\\n\",x,i,cost[i]);\n\t\n//\tprintf(\"\\n\");\n\t//??°??????\n\tfor(i=1;i<=n;i++) {\n\t\tcost1[i]=M;\n\t\tflg[i]=0;\n\t}\n\tfor(i=1;i<=n;i++) {\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tdate[i][j]=M;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=m;i++) {\n\t\tdate[a[i]][b[i]]=c[i];\n\t\tdate[b[i]][a[i]]=d[i];\n\t}\n\t\n\tfor(i=1;i<=n;i++) date[i][i]=0;\n\t\n\tcost1[y]=0;\n\tfor(i=1;i<=n;i++) {\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) F[i]=0;\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tif(flg[j]==0 && cost1[j]<min) {\n\t\t\t\tkaku=j;\n\t\t\t\tmin=cost1[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg[kaku]=1;\n\t\t\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tif((cost1[kaku]+date[kaku][j])<cost1[j]) cost1[j]=cost1[kaku]+date[kaku][j];\n\t\t}\n\t}\n//\tfor(i=1;i<=n;i++) printf(\"%d<-%d - %d\\n\",y,i,cost1[i]);\n\t/**/\n/*\tprintf(\"       \");\n\tfor(i=1;i<=n;i++) printf(\"%4d \",i);\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n\tfor(i=1;i<=n;i++) {\n\t\tprintf(\"%4d   \",i);\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tprintf(\"%4d \",date[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t/**/\n\tx2=x2-y2-cost[y]-cost1[x];\n\tprintf(\"%d\\n\",x2);\n\treturn 0;\n}\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\n\n\nint main(){\n    int n,m;\n    int a[25][25];\n    cin>>n>>m;\n    for(int i=0;i<25;i++){\n        for(int t=0;t<25;t++){\n            a[i][t]=-1;\n        }\n    }\n    char q;\n    for(int i=0;i<m;i++){\n        int b,c,d,e;\n        cin>>b>>q>>c>>q>>d>>q>>e;\n        a[b][c]=d;\n        a[c][b]=e;\n    }\n    int s,g,gold,p;\n    cin>>s>>q>>g>>q>>gold>>q>>p;\n    bool j=true;\n    int count=0;\n    //while(j){\n        j=false;\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int t=1;t<=n;t++){\n                if(a[i][k]==-1 || a[k][t]==-1){continue;}\n                if(a[i][t]==-1){a[i][t]=a[i][k]+a[k][t]; j=true; continue;}\n                if(a[i][t]>a[i][k]+a[k][t]){a[i][t]=a[i][k]+a[k][t]; j=true;}\n            }\n        }\n    }\n        count++;\n    //}\n    cout<<gold-p-a[s][g]-a[g][s]<<endl;\n    //cout<<count<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n\tint city1,city2,cost1to2,cost2to1;\n};\n\n\n\nint main(){\n\tint n=0,m=0,start=0,goal=0,budget=0,treecost=0;\n\tcin>>n>>m;\n\tedge node[m+1];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&node[i].city1,&node[i].city2,&node[i].cost1to2,&node[i].cost2to1);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&budget,&treecost);\n\tint dp[n+1][n+1];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdp[i][j]=1000000000;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdp[node[i].city1][node[i].city2]=node[i].cost1to2;\n\t\tdp[node[i].city2][node[i].city1]=node[i].cost2to1;\n\t}\n\tfor(int l=1;l<=n;l++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<budget-treecost-dp[start][goal]-dp[goal][start]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/01/16 Tazoe\n\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main()\n{\n\tstring str;\n\tistringstream is;\n\n\tgetline(cin, str);\n\tis.str(str);\n\n\tint n;\n\tis >> n;\n\n\tint cst[21][21];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(i==j)\n\t\t\t\tcst[i][j] = 0;\n\t\t\telse\n\t\t\t\tcst[i][j] = -1;\n\n\tis.clear();\n\n\tgetline(cin, str);\n\tis.str(str);\n\n\tint m;\n\tis >> m;\n\n\tfor(int i=0; i<m; i++){\n\t\tis.clear();\n\n\t\tgetline(cin, str);\n\t\tfor(int j=0; j<str.size(); j++)\n\t\t\tif(str[j]==',')\n\t\t\t\tstr[j] = ' ';\n\n\t\tis.str(str);\n\n\t\tint a, b, c, d;\n\t\tis >> a >> b >> c >> d;\n\t\tcst[a][b] = c;\n\t\tcst[b][a] = d;\n\t}\n\n\tfor(int k=1; k<=n; k++)\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tfor(int j=1; j<=n; j++)\n\t\t\t\tif(cst[i][k]!=-1&&cst[k][j]!=-1)\n\t\t\t\t\tif(cst[i][j]==-1||cst[i][j]>cst[i][k]+cst[k][j])\n\t\t\t\t\t\tcst[i][j] = cst[i][k]+cst[k][j];\n\n\tis.clear();\n\n\tgetline(cin, str);\n\tfor(int i=0; i<str.size(); i++)\n\t\tif(str[i]==',')\n\t\t\tstr[i] = ' ';\n\n\tis.str(str);\n\n\tint x1, x2, y1, y2;\n\tis >> x1 >> x2 >> y1 >> y2;\n\n\tcout << y1-y2-cst[x1][x2]-cst[x2][x1] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <map>\n#define number(node) edge_to[node][0]\n#define INFINITY 999999\nusing namespace std;\nint n, m, start[2], paid, pole, cost[2][20], edge_to[20][21], edge_cost[20][21];\n\nint comp_0(const void *a, const void *b)\n{\n    return cost[0][*(int*)a] - cost[0][*(int*)b];\n}\n\nint comp_1(const void *a, const void *b)\n{\n    return cost[1][*(int*)a] - cost[1][*(int*)b];\n}\n\nint main()\n{\n    int from, to, c1, c2;\n    fill((int *)edge_to, (int *)(edge_to + 20), 0);\n    fill((int *)edge_cost, (int *)(edge_cost + 20), 0);\n    fill((int *)cost, (int *)(cost + 2), INFINITY);\n    \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d,%d,%d,%d\", &from, &to, &c1, &c2);\n        edge_to[from][++number(from)] = to;\n        edge_cost[from][number(from)] = c1;\n        edge_to[to][++number(to)] = from;\n        edge_cost[to][number(to)] = c2;\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &start[0], &start[1], &paid, &pole);\n    for (int g = 0; g < 2; g++)\n    {\n        int unchecked[20], k = 0;\n        cost[g][start[g]] = 0;\n        for (int i = 1; i <= number(start[g]); i++)\n            cost[g][edge_to[start[g]][i]] = edge_cost[start[g]][i];\n        for (int i = 1; i <= n; i++)\n            if (i != start[g]) unchecked[k++] = i;\n\n        while (k > 0)\n        {\n            qsort(unchecked, k, sizeof(int), (g ? comp_1 : comp_0));\n            for (int i = 1; i <= number(unchecked[0]); i++)\n                if (cost[g][edge_to[unchecked[0]][i]] > cost[g][unchecked[0]] + edge_cost[unchecked[0]][i])\n                    cost[g][edge_to[unchecked[0]][i]] = cost[g][unchecked[0]] + edge_cost[unchecked[0]][i];\n            unchecked[0] = unchecked[--k];\n        }\n    }\n    \n    printf(\"%d\\n\", paid - pole - cost[0][start[1]] - cost[1][start[0]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main(void)\n{\n    int N, M;\n    int A, B, C, D;\n    int S, G, V, P;\n    scanf(\"%d%d\", &N, &M);\n    int K[24][24];\n    for (int i = 1; i <= N; i++)\n        for (int j = 1; j <= N; j++)\n            K[i][j] = 1e6;\n    while(M)\n    {\n        scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n        K[A][B] = C;\n        K[B][A] = D;\n        M--;\n    }\n    scanf(\"%d,%d,%d,%d\", &S, &G, &V, &P);\n    for (int k = 1; k <= N; k++)\n        for (int i = 1; i <= N; i++)\n            for (int j = 1; j <= N; j++)\n                if (K[i][j] > K[i][k] + K[k][j]) K[i][j] = K[i][k] + K[k][j];\n    cout << (V - P - K[S][G] - K[G][S]) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define INF 1001001001\nint n,m,a,b,c,d,x1,x2,y1,y2;\nint r[21][21];\nint used[21],dis[21];\n\nint select(){\n\tint p=INF,q;\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i]==0&&dis[i]<p){\n\t\t\tp=dis[i];q=i;\n\t\t}\n\t}\n\treturn q;\n}\nint dijkstra(int s,int g){\n\tint q=1,u;\n\tfor(int i=0;i<=n;i++)used[i]=0;\n\tfor(int i=0;i<=n;i++)dis[i]=r[s][i];\n\tused[s]=1;\n\twhile(q<n){\n\t\tu=select();\n\t\tused[u]=1;q++;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdis[i]=min(dis[i],dis[u]+r[u][i]);\n\t\t}\n\t}\n\treturn dis[g];\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tr[i][j]=(i==j)?0:INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tr[a][b]=c;r[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\t\n\tcout<<y1-y2-dijkstra(x1,x2)-dijkstra(x2,x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) {ostringstream sout; sout << x; return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a);i < (b); ++i)\n#define RFOR(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n\n//clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0 , sizeof(a))\n\n\nint n, m, x[2], y[2];\nint amat[21][21];\nint vtx[21];\nint res = 0;\nchar cht;\nqueue<int> qu;\n\n\nint main()\n{\n\tCLR(amat);\n\t\n\tFOR(i,0,21)\n\t\tvtx[i] = INT_MAX;\n\t\n\tcin >> n >> m;\n\n\tFOR(i,0,m)\n\t{\n\t\tint a, b, c, d;\n\t\t\n\t\tcin >> a >>cht>> b >>cht>> c >>cht>> d;\n\t\t\n\t\t\n\t\tamat[a][b] = c;\n\t\tamat[b][a] = d;\n\t}\n\t\n\tcin >> x[0] >>cht>> x[1] >>cht>> y[0] >>cht>> y[1];\n\t\n\tres = y[0] - y[1];\n\t\n\tqu.push(x[0]);\n\tvtx[x[0]] = 0;\n\t\n\twhile( !qu.empty() )\n\t{\n\t\tint a = qu.front();\n\t\tqu.pop();\n\t\t\n\t\tFOR(i,0,n+1)\n\t\t{\n\t\t\tif( a != i && amat[a][i] > 0 && (amat[a][i] + vtx[a] < vtx[i] ) )\n\t\t\t{\n\t\t\t\tqu.push(i);\n\t\t\t\tvtx[i] = amat[a][i] + vtx[a];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres -= vtx[x[1]];\n\n\tFOR(i,0,21)\n\t\tvtx[i] = INT_MAX;\n\t\n\tqu.push(x[1]);\n\tvtx[x[1]] = 0;\n\t\n\twhile( !qu.empty() )\n\t{\n\t\tint a = qu.front();\n\t\tqu.pop();\n\t\t\n\t\tFOR(i,0,n+1)\n\t\t{\n\t\t\tif( a != i && amat[a][i] > 0 && (amat[a][i] + vtx[a] < vtx[i] ) )\n\t\t\t{\n\t\t\t\tqu.push(i);\n\t\t\t\tvtx[i] = amat[a][i] + vtx[a];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres -= vtx[x[0]];\n\t\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\ninline int toInt(string s){int v;istringstream i(s);i>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream o;o<<x;return o.str();}\ntemplate<class T> void pv(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\nint D[21][21];\n\nint main() {\n\tint N; cin >> N;\n\tint M; cin >> M;\n\tint start, goal;\n\tint y1, y2;\n\tcin.ignore();\n\trep(i,M) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\t\tistringstream is(line);\n\t\tfor(int a, b, c, d; is >> a >> b >> c >> d;) {\n\t\t\ta--, b--;\n\t\t\tD[a][b] = c;\n\t\t\tD[b][a] = d;\n\t\t}\n\t}\n\t\n\trep(i,N) rep(j,N) D[i][j] = INF;\n\n\tstring line;\n\tgetline(cin, line);\n\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\tistringstream is(line);\n\t\n\tis >> start >> goal >> y1 >> y2;\n\tstart--, goal--;\n\trep(k,N) rep(i,N) rep(j,N) D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n#if 0\n\tdebug(D[start][goal]);\n\tdebug(D[goal][start]);\n#endif\n\tcout << y1 - (y2 + D[start][goal] + D[goal][start]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 9999999\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tint D[36][36];/*Adjacency matrix*/\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j)continue;\n\t\t\tD[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint ans = 0;\n\tint go,back,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&go,&back,&y1,&y2);\n\tans = y1-y2;\n\tint cost = 0;\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcost = D[go][back] + D[back][go];\n\t\n\tprintf(\"%d\\n\",ans-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cassert>\nusing namespace std;\n\n\nint main(){\n  int n,m,a,b,c,d,s,g,money,pay,matrix[40][40];\n  for(int i=0;i<40;i++)for(int j=0;j<40;j++)matrix[i][j]=1<<22;\n  cin >> n;\n  cin >> m;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    matrix[a][b] = c;\n    matrix[b][a] = d;\n  } \n  for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)matrix[i][j] = min(matrix[i][j],matrix[i][k]+matrix[k][j]);\n  scanf(\"%d,%d,%d,%d\",&s,&g,&money,&pay);\n  int sum=0;\n  sum += matrix[s][g];\n  sum += matrix[g][s];\n  sum += pay;\n  assert(money-sum>=0);\n  cout << money-sum << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    signed int n, m, a, b, c, d;\n    char temp[3];\n    cin >> n >> m;\n    vector<vector<int>> map(n, vector<int>(n, 2000000));\n    for(int i = 0;i<m;i++){\n        cin >> a >> temp[0] >> b >> temp[1] >> c >> temp[2] >> d;\n        map[a-1][b-1] = c;\n        map[b-1][a-1] = d;\n    }\n    cin >> a >> temp[0] >> b >> temp[1] >> c >> temp[2] >> d;\n    for(int h = 0;h<n;h++){\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<n;j++){\n            map[j][j] = 0;\n            for(int k = 0;k<n;k++){\n                map[j][i] = min(map[j][i],map[j][k] + map[k][i]);\n            }\n        }\n    }\n    }\n    cout << c - (map[a-1][b-1] + map[b-1][a-1] + d) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\nusing namespace std;\nint n;\nint s[21]={0};\nint d[21][21]={0};\nvoid warshall_floyd(){\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}\nint main(){\n\t\n\tint m;\n\tint a,b,c1,c2;\n\tchar comma;\n\tint x1,x2,y1,y2;\n\tcin>>n>>m;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i!=j)\n\t\t\t\td[i][j]=999999;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>comma>>b>>comma>>c1>>comma>>c2;\n\t\td[a][b]=c1;\n\t\td[b][a]=c2;\n\t}\n\t\n\twarshall_floyd();\n\t\n\tcin>>x1>>comma>>x2>>comma>>y1>>comma>>y2;\n\t\n\tcout<<y1-y2-d[x1][x2]-d[x2][x1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ WarshallFloyd ------ //\nMatrix WarshallFloyd(Graph &g) {\n    int n = g.size();\n    Matrix d(n, Array(n, INF));\n    for (int i = 0; i < n; i++) d[i][i] = 0;\n    for (int i = 0; i < n; i++) for (Edge &e : g[i]) {\n        d[e.src][e.dst] = min(d[e.src][e.dst], e.weight);\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n            if (d[i][k] != INF && d[k][j] != INF) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    return d;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    Graph g(n);\n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        g.add_arc(a - 1, b - 1, c);\n        g.add_arc(b - 1, a - 1, d);\n    }\n    int S, G, V, P; scanf(\"%d,%d,%d,%d\", &S, &G, &V, &P);\n    Matrix d = WarshallFloyd(g);\n    int ans = V - P - d[S - 1][G - 1] - d[G - 1][S - 1];\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin>>a>>cc>>b>>cc>>c>>cc>>d;\n            }\n        }\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t\tpq.emplace(d[E[t][i].second], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define INF 99999\n#define MAX 20\n\nusing namespace std;\n\nint grapha[MAX + 1][MAX + 1];\nbool visited[MAX + 1];\nint v[MAX + 1];\nint n,m;\n\nint Dijkstra( int start, int goal ){ // ダイクストラ法\n\n\n  for( int i = 0 ; i <= MAX ; i++ ){ // 初期化\n    v[i] = INF;\n    visited[i] = false;\n  }\n\n  v[start] = 0; // スタート地点を0にする\n  while(1){\n    int mn = INF;\n    int MN;\n    for( int i = 1 ; i <= n ; i++ ){\n      if( v[i] < mn && !visited[i] ){\n\tmn = v[i];\n\tMN = i;\n      }\n    }\n    if( mn == INF ) break; // すべて訪問(INFが変わらなかった)したのでbreak\n    visited[MN] = true; // 訪問済みにする\n\n    for( int i = 1 ; i <= n ; i++ ){\n      if( grapha[MN][i] + v[MN] < v[i] ){ // 小さい方を代入\n\tv[i] = v[MN] + grapha[MN][i];\n      }\n    }\n  }\n  return v[goal];\n}\n\nint main(void){\n\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n\n  cin >> n >> m;\n\n  for( int i = 0 ; i <= MAX ; i++ )\n    for( int j = 0 ; j <= MAX ; j++ )\n      grapha[i][j] = INF; //  grapha初期化\n\n  for( int i = 0 ; i < m ; i++ ){ // i番目の街道の情報を読む\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    grapha[a][b] = c;\n    grapha[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2); \n  // 大工の出発点、柱のある点、殿からもらったお金、柱の代金\n\n  int ans = y1;\n  ans -= Dijkstra(x1,x2);\n  // cout << Dijkstra(x1,x2) << endl;\n  ans -= Dijkstra(x2,x1);\n  // cout << Dijkstra(x2,x1) << endl;\n  ans -= y2;\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define INF (1<<30)\n\nint dist[30][30];\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse      dist[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\n\t\tdist[a-1][b-1] = c;\n\t\tdist[b-1][a-1] = d;\n\t}\t\n\n\n\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> x2 >> y1 >> y2;\n\n\tcout << (y1 - y2 - dist[x1-1][x2-1]　- dist[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=1;i<=n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nstring str;\n\nint main()\n{\n  int i,j,k;\n  int n,m,a,b;\n  int s,g,v,p;\n  int cost[25][25]={};\n\n  cin>>n>>m;\n\n  rep(i,n)rep(j,n)cost[i][j]=INF;\n  rep(i,n)cost[i][i]=0;\n\n  rep(i,m){\n    scanf(\"%d,%d,\",&a,&b);\n    scanf(\"%d,%d\",&cost[a][b],&cost[b][a]);\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\n  rep(k,n)rep(i,n)rep(j,n)\n    cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  cout<<v-p-cost[s][g]-cost[g][s]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n#include <cctype>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P; //?????¢?????????\n\nconst int MAX_V=100000;\nvector<vector<edge> > G;\nint d[MAX_V];\nconst int INF=100000000; // 10^8\nvoid dijkstra(int from){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+G.size(),INF);\n\td[from]=0;\n\tq.push(P(0,from));\n\n\twhile(!q.empty()){\n\t\tP p=q.top(); q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first) continue;\n\t\t\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG.resize(n);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,dd;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&dd);\n\t\ta--; b--;\n\t\tG[a].push_back(edge{b,c});\n\t\tG[b].push_back(edge{a,dd});\n\t}\n\t\n\tint a,b,c,dd;\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&dd);\t\n\ta--; b--;\n\tint res=c-dd;\n\tdijkstra(a);\n\tres-=d[b];\n\tdijkstra(b);\n\tres-=d[a];\n\tcout<<res<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tint M; cin >> M;\n\tint m[20][20]; fill(&m[0][0], &m[0][0]+20*20, 1e9);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d); --a, --b;\n\t\tm[a][b] = c;\n\t\tm[b][a] = d;\n\t}\n\tfor (int i = 0; i < n; ++i) m[i][i] = 0;\n\n\tfor (int k = 0; k < n; ++k) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t}\n\n\tint s, t, award, cost; scanf(\"%d,%d,%d,%d\", &s, &t, &award, &cost); --s, --t;\n\taward -= cost + m[s][t] + m[t][s];\n\tcout << award << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <stdio.h>\n#include<iostream>\n#include <list>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define MAX 101\nstruct node\n{\n\tlist<int> li;\n\tlist<int> cost;\n};\nint  sum = 0, n, m, s, g, ans, min = -1;\nnode x[MAX];\nvoid sai(int N, int a,int f) {\n\tif (N < m) {\n\t\tif (f == a) {\n\t\t\tif (min == -1 || min > sum) min = sum;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tfor (auto i = x[a].li.begin(), j = x[a].cost.begin(); i != x[a].li.end(); ++i, ++j) {\n\t\t\t\tif (min == -1 || min > sum) {\n\t\t\t\t\tsum += *j;\n\t\t\t\t\tsai(N + 1, *i, f);\n\t\t\t\t\tsum -= *j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint a, b, c, d, V, P;\n\tscanf_s(\"%d\", &n);\n\tscanf_s(\"%d\", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a].li.push_back(b); x[a].cost.push_back(c);\n\t\tx[b].li.push_back(a); x[b].cost.push_back(d);\n\t}\n\tfor (int k = 1; k <= n; ++k) {\n\t\tfor (auto i = x[k].li.begin(), j = x[k].cost.begin(); i != x[k].li.end(); ++i, ++j) {\n\t\t}\n\t}\n\tscanf_s(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tsai(0, s, g);\n\tans += min; min = -1; sum = 0;\n\tsai(0, g, s);\n\tans += min;\n\tans = V - (ans + P);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <typeinfo>\n#include <map>\n#define INF 100000000\n#define rep(i,a) for(int i=0;i<(a);i++)\n\nusing namespace std;\ntypedef long long ll;\n\nint data[30][30]={};\nint n;\n\n\nvoid wf(){\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                data[i][j]=min(data[i][j] , data[i][k]+data[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    rep(i,20){\n        rep(j,20){\n            if(i==j)data[i][j]=0;\n            else data[i][j]=INF;\n        }\n    }\n    char ch;\n\n    cin>>n;\n    int m;\n    cin>>m;\n    rep(i,m){\n        int a,b,c,d;\n        cin>>a>>ch>>b>>ch>>c>>ch>>d;\n        a--;b--;\n        data[a][b]=c;\n        data[b][a]=d;\n    }\n    int x1,x2,y1,y2;\n    cin>>x1>>ch>>x2>>ch>>y1>>ch>>y2;\n/*\n x1：大工の出発する町の番号\n x2：柱のある山里の番号\n y1：殿様から大工が受け取ったお金\n y2：柱の代金\n */\n    wf();\n    cout<<y1-y2-data[x1-1][x2-1]-data[x2-1][x1-1]<<endl;\n    \n    \n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nvector<string> split(string &str,char delim)\n{\n\tvector<string> res;\n\tsize_t current = 0,found;\n\twhile((found = str.find_first_of(delim,current)) != string::npos)\n\t{\n\t\tres.push_back(string(str,current,found  - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str,current,str.size() - current));\n\treturn res;\n}\n\nint main()\n{\n\tint n,m,cost[21][21];\n\trep(i,21)\n\t{\n\t\trep(j,21)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tcin >> n >> m;\n\n\trep(i,m)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<string> _s = split(s,',');\n\t\tint a = atoi(_s[0].c_str());\n\t\tint b = atoi(_s[1].c_str());\n\t\tint c = atoi(_s[2].c_str());\n\t\tint d = atoi(_s[3].c_str());\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\n\tREP(k,1,n+1)\n\t{\n\t\tREP(i,1,n+1)\n\t\t{\n\t\t\tREP(j,1,n+1)\n\t\t\t{\n\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstring s;\n\tcin >> s;\n\tvector<string> _s = split(s,',');\n\tint x1 = atoi(_s[0].c_str());\n\tint x2 = atoi(_s[1].c_str());\n\tint y1 = atoi(_s[2].c_str());\n\tint y2 = atoi(_s[3].c_str());\n\n\tint ans = y1 - y2;\n\tans -= cost[x1][x2] + cost[x2][x1];\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n#define REP1(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint n, m;\nint dis[21][21];\nint s, g, v, p;\n\nint main(){\n    cin >> n >> m;\n\n    REP(i, n+1){\n        REP(j, n+1){\n            if(i!=0 && i==j){\n                dis[i][j] = 0;\n            } else {\n                dis[i][j] = INF; dis[j][i] = INF;\n            }\n        }\n    }\n\n    REP(i, m){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        dis[a][b] = c;\n        dis[b][a] = d;\n    }\n\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    REP1(k, n+1){\n        REP1(i, n+1){\n            REP1(j, n+1){\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    int output = v - (p + dis[s][g] + dis[g][s]);\n    cout << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define INF 1 << 16\n\nint main() {\n\tint cost[20][20]; fill(&cost[0][0], &cost[0][0]+20*20, INF);\n\n\tint n; cin >> n;\n\tint m; cin >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b, c, d; scanf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d); --a, --b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\tint s, g, reward, price; scanf(\"%d,%d,%d,%d\\n\", &s, &g, &reward, &price); --s, --g;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tif (cost[j][i] + cost[i][k] < cost[j][k])\n\t\t\t\t\tcost[j][k] = cost[j][i] + cost[i][k];\n\n\tcout << (reward - price - cost[s][g] - cost[g][s]) << endl;\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define INF 1<<20\n#define MAX_V 20\n\nbool done[MAX_V];\nint d[MAX_V];\nint V;\nint cost[MAX_V+1][MAX_V+1];\n\nint dijkstra(int s, int t) {\n  fill(done, done+V, false);\n  fill(d, d+V, INF);\n  \n  d[s] = 0;\n\n  while(1) {\n    int v = -1;\n    for(int u = 0; u < V; u++) {\n      // find minimum\n      if(!done[u] && ( v == -1 || d[u]<d[v] )) {\n\tv = u;\n      }\n    }\n    if(v == -1) break;\n\n    done[v] = true;\n\n    // relax\n    for(int u = 0; u < V; u++) {\n      d[u] = min(d[u], d[v] + cost[v][u]);\n    }\n  }\n  \n  return d[t];\n}\n\n/*\nstruct edge{ int to, cost; };\n\ntypedef pair<int, int> Pii; // cost, vertex\n\nint V;\nint d[MAX_V];\n\nvector<edge> G[MAX_V];\n\nvoid dijkstra(int s) {\n  priority_queue<Pii> Q;\n  fill(d, d+V, INF);\n  d[s] = 0;\n  Q.push(Pii(0, s));\n\n  while(!Q.empty()) {\n    Pii p = Q.top(); Q.pop();\n    int v = p.second;\n    \n    if(d[v] < p.first) continue;\n    \n    for(int i=0; i<G[v].size(); i++) {\n      edge e = G[v][i];\n      \n      if(d[i] > d[v]+e.cost) {\n\td[i] = d[v]+e.cost;\n\tQ.push(Pii(d[i], e.to));\n      }\n    }\n  }\n}\n\n*/\n\nint main() {\n  \n  int m;\n  cin >> V >> m;\n  char dd;\n\n  fill(cost[0], cost[MAX_V], INF);\n  \n  for(int i=0; i<m; i++) {\n    int a, b, c, d;\n    cin >> a >> dd >> b >> dd >> c >> dd >> d;\n    a--, b--;\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n  \n  int x1, x2, y1, y2;\n  cin >> x1 >> dd >> x2 >> dd >> y1 >> dd >> y2;\n  int ret = y1-y2;\n\n  x1--, x2--;\n  ret -= dijkstra(x1, x2);\n  ret -= dijkstra(x2, x1);\n  \n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n#define MAX_V 100\n\nstruct edge{int to,cost;};\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nint dijkstra(int s,int V){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep(i,MAX_V)d[i]=INF;\n    d[s]=0;\n    que.push(pii(0,s));\n    \n    while(que.size()){\n        pii p=que.top();\n        que.pop();\n        \n        int v=p.second;\n        if(d[v]<p.first)continue;\n        \n        rep(i,G[v].size()){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d[V];\n}\n\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    rep(i,m){\n        int a,b,c,d;\n        char ch;\n        cin>>a>>ch>>b>>ch>>c>>ch>>d;\n        a--,b--;\n        G[a].pb(edge{b,c});\n        G[b].pb(edge{a,d});\n    }\n    int x1,x2,y1,y2;\n    char ch;\n    cin>>x1>>ch>>x2>>ch>>y1>>ch>>y2;\n    x1--,x2--;\n    cout<<y1-(dijkstra(x1,x2)+dijkstra(x2,x1)+y2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=1;i<=n;i++)\n#define MAX 200000000\nusing namespace std;\nint main(void)\n{\n\tint n,m;\n\tint a,b,c,di;\n\tint s,g,v,p;\n\tint d[21][21];\n\tchar ch;\n\tcin>>n>>m;\n\trep(i,n)rep(j,n)d[i][j]=(i==j)?0:MAX;\n\trep(i,m){\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>di;\n\t\td[a][b]=c;\n\t\td[b][a]=di;\n\t}\n\trep(k,n)rep(i,n)rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\tcin>>s>>ch>>g>>ch>>v>>ch>>p;\n\tcout<<v-p-d[s][g]-d[g][s]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct Edge\n{\n\tint to, cost;\n\n\tEdge( int t, int c ) : to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n};\n\nint dijkstra1( const vector< vector< Edge > > G, const int s, const int t )\n{\n\tconst int V = G.size();\n\n\tvector<int> dist( V, INT_MAX );\n\tdist[s] = 0;\n\n\tvector<bool> used( V, false );\n\n\twhile ( true )\n\t{\n\t\tint v = -1;\n\n\t\tfor ( int i = 0; i < V; i++ )\n\t\t{\n\t\t\tif ( !used[i] && ( v == -1 || dist[i] < dist[v] ) )\n\t\t\t{\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\n\t\tif ( v == -1 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tused[v] = true;\n\n\t\tfor ( int i = 0; i < G[v].size(); i++ )\n\t\t{\n\t\t\tdist[ G[v][i].to ] = min( dist[ G[v][i].to ], dist[v] + G[v][i].cost );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint dijkstra2( const vector< vector< Edge > > G, const int s, const int t )\n{\n\tconst int V = G.size();\n\n\tvector<int> dist( V, INT_MAX );\n\n\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\tque.push( make_pair( 0, s ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tint cost = que.top().first;\n\t\tint cur = que.top().second;\n\t\tque.pop();\n\n\t\tif ( dist[ cur ] < cost )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tdist[ cur ] = cost;\n\n\t\tfor ( int i = 0; i < G[ cur ].size(); i++ )\n\t\t{\n\t\t\tque.push( make_pair( cost + G[ cur ][i].cost, G[ cur ][i].to ) );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< vector< Edge > > G( n );\n\n\tfor ( int i = 0; i < m; i++ )\n\t{\n\t\tint a, b, c, d;\n\t\tchar dummy;\n\n\t\tcin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n\n\t\ta--;\n\t\tb--;\n\n\t\tG[a].push_back( Edge( b, c ) );\n\t\tG[b].push_back( Edge( a, d ) );\n\t}\n\n\tint s, t, money, price;\n\tchar dummy;\n\tcin >> s >> dummy >> t >> dummy >> money >> dummy >> price;\n\n\ts--;\n\tt--;\n\n\tcout << money - price - dijkstra1( G, s, t ) - dijkstra2( G, t, s ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tll i,j,k;\n\tll n,m,s,g,b,e,pp,kou;\n\tll ri[21][21];\n\tll leng[21],v[21];\n\tll min;\n\t\n\tPP p[100];\n\t\n\tcin>>n>>m;\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&p[i].ff,&p[i].fs,&p[i].sf,&p[i].ss);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&b,&e);\n\t\n\t//隣接行列\n\tsort(p,p+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[p[i].ff][p[i].fs]=p[i].sf,ri[p[i].fs][p[i].ff]=p[i].ss;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[g];\n//\tcout<<leng[g]<<endl;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[g]=0;\n\t\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[s];\n//\tcout<<leng[s]<<endl;\n\t\n\tcout<<b-e-kou<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\nstruct Node {\n    vector<pair<int, int> > to;\n    int cost;\n    bool isDone;\n};\n\nconst int MAX_N = 20;\nNode nodes[MAX_N + 1];\nint n;\n\nint Dijkstra(int start, int end) {\n    for (int i = 1; i <= n; i++) {\n        nodes[i].isDone = false;\n        nodes[i].cost = -1;\n    }\n    nodes[start].cost = 0;\n    while (true) {\n        int min_idx = -1;\n        for (int i = 1; i <= n; i++) {\n            if (nodes[i].isDone == true || nodes[i].cost < 0) {\n                continue;\n            }\n            if (min_idx < 0 || nodes[i].cost < nodes[min_idx].cost) {\n                min_idx = i;\n            }\n        }\n        if (min_idx < 0) {\n            break;\n        }\n        nodes[min_idx].isDone = true;\n        for (vector<pair<int, int> >::iterator it = nodes[min_idx].to.begin(); it != nodes[min_idx].to.end(); it++) {\n            int to = it->first;\n            int cost = nodes[min_idx].cost + it->second;\n            if (nodes[to].cost < 0 || cost < nodes[to].cost) {\n                nodes[to].cost = cost;\n            }\n        }\n    }\n    return nodes[end].cost;\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        nodes[a].to.push_back(make_pair(b, c));\n        nodes[b].to.push_back(make_pair(a, d));\n    }\n    int x1, x2, y1, y2;\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    cout << y1 - y2 - Dijkstra(x1, x2) - Dijkstra(x2, x1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n\nint main()\n{\n    const int MAXTOWN = 20;\n\n    int number_town;//????????????\n    int number_way;//????????°\n    int min_cost[MAXTOWN + 1][MAXTOWN + 1];//i????????????j??????????§?????????????????????????????????????????´?\n\n    for (int i = 0; i <= MAXTOWN; i++) {\n        for (int j = 0; j <= MAXTOWN; j++) {\n            min_cost[i][j] = 999999;//??¨????????§???????????§????????????\n        }\n    }\n\n    std::cin >> number_town;//????????°????????±???????????????\n    std::cin >> number_way;//????????°????????±???????????????\n\n    for (int way = 0; way < number_way; way++) {//??????????????????????§??????????????????????????????????\n        int from_way, to_way, cost, back_cost;\n        scanf(\"%d, %d, %d, %d\", &from_way, &to_way, &cost, &back_cost);\n\n        min_cost[from_way][to_way] = cost;\n        min_cost[to_way][from_way] = back_cost;\n    }   \n\n    for (int medium_town = 1; medium_town <= number_town; medium_town++) {//??????????????±????????????????????????????????????????????§?????????\n        for (int start_town = 1; start_town <= number_town; start_town++) {\n            for (int end_town = 1; end_town <= number_town; end_town++) {\n                int start_medium_end_long = min_cost[start_town][medium_town] + min_cost[medium_town][end_town];\n                if (min_cost[start_town][end_town] > start_medium_end_long) {//??????????????±????????????????????´???\n                    min_cost[start_town][end_town] = start_medium_end_long;\n                }   \n            }\n        }\n    }\n\n    int start_town, end_town;\n    int get_money, lost_money;\n    scanf(\"%d, %d, %d, %d\", &start_town, &end_town, &get_money, &lost_money);//????????????????????????????????????????????????\n    int profit;\n    //?????????????????\\?????£????????????????????????\n    profit = get_money - lost_money - min_cost[start_town][end_town] - min_cost[end_town][start_town];\n\n    std::cout << profit << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX\n\nint n,m,a,b,c,d,x1,x2,y1,y2;\nvector< vector<int> >M;\n\nint Dijkstra(int start,int goal)\n{\n  vector<int>d(n,NONE),visited(n,0);\n  multimap<int,int>q;\n\n  d[start]=0;\n  q.insert(make_pair(0,start));\n\n  while(q.size()){\n    int u,v;\n    u=q.begin()->second;\n    q.erase(q.begin());\n    if(visited[u]==true)continue;\n    visited[u]=true;\n    for(v=0;v<n;v++){\n      if(M[u][v]==NONE)continue;\n      if(visited[v]==true)continue;\n      if(d[v]<=d[u]+M[u][v])continue;\n      d[v]=d[u]+M[u][v];\n      q.insert(make_pair(d[v],v));\n    }\n  }\n  return d[goal];\n}\n\nint main()\n{\n  cin>>n>>m;\n  M.resize(n);\n  for(int i=0;i<n;i++)M[i].resize(n,NONE);\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    M[a][b]=c;\n    M[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  x1--;x2--;\n  cout<<(y1-y2-Dijkstra(x1,x2)-Dijkstra(x2,x1))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint dp[20][20];\n\nvoid solv(int n){\n\tfor(int k = 0;k < n;k++){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(dp[i][j] > dp[i][k] + dp[k][j]){\n\t\t\t\t\tdp[i][j] = dp[i][k] + dp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, a, b, c, d;\n\tchar s;\n\tfill((int*)dp, (int*)(dp+20), 100000);\n\tcin >> n >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> s >> b >> s >> c >> s >> d;\n\t\tdp[a-1][b-1] = c;\n\t\tdp[b-1][a-1] = d;\n\t}\n\tsolv(n);\n\tcin >> a >> s >> b >> s >> c >> s >> d;\n\tcout << c - d - dp[a-1][b-1] - dp[b-1][a-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntypedef std::pair<int, int> pii;\ntypedef std::vector<int> vi;\ntypedef std::vector<double> vd;\ntypedef std::vector<std::string> vs;\ntypedef std::vector<pii> vpii;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { rep(i,v.size()) is >> v[i]; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Array;\ntypedef std::vector<Array> Matrix;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int &src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph t(n);\n  char gomi;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> gomi >> b >> gomi >> c >> gomi >> d;\n    --a, --b;\n    t.addArc(a, b, c);\n    t.addArc(b, a, d);\n  }\n  int s, g, v, p;\n  cin >> s >> gomi >> g >> gomi >> v >> gomi >> p;\n  --s, --g;\n  vector<Weight> dist1 = dijkstra(t, s).first;\n  vector<Weight> dist2 = dijkstra(t, g).first;\n  cout << v - p - dist1[g] - dist2[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(auto i :dat){\n\t\tif(i.depart==s){\n\t\t\tq.push(i.arrival);\n\t\t\tcost.at(i.arrival)=i.cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(auto i:dat){\n\t\t\tif(i.depart==pos){\n\t\t\t\tif(cost.at(i.arrival)==INF){\n\t\t\t\t\tq.push(i.arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at(i.arrival)>i.cost+cost.at(pos)){\n\t\t\t\t\tcost.at(i.arrival)=i.cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(I,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 10000000;\nconst int MAX_V = 51;\n\nint d[MAX_V][MAX_V];\nint V;\n\nvoid warshall_floyd() {\n  for ( int k = 0; k < V; k++ ) {\n    for (int i = 0; i < V; i++ ) {\n      for ( int j = 0; j < V; j++ ) {\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j] );\n      }\n    }\n  }\n}\n\n\nint main() {\n\n  cin >> V;\n\n  for ( int i = 0; i < 51; i++ ) {\n    for ( int j = 0; j < 51; j++ ) {\n      if ( i == j ) d[i][j] = 0;\n      else d[i][j] = INF;\n    }\n  }\n\n\n  int m; cin >> m;\n  int a,b,c,dd;\n  char ch1,ch2,ch3;\n  for ( int i = 0; i < m; i++ ) {\n\n    cin >> a >> ch1 >> b >> ch2 >> c >> ch3 >> dd;\n    a--; b--;\n    d[a][b] = c;\n    d[b][a] = dd;\n  }\n\n  int x1,x2,y1,y2;\n  cin >> x1 >> ch1 >> x2 >> ch2 >> y1 >> ch3 >> y2;\n  x1--; x2--;\n  warshall_floyd();\n\n  int ans = y1 - d[x1][x2] - d[x2][x1] - y2;\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>8)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20];\n\tfor (int i = 0; i < n; i++)d[i] = 1000000000;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top(); pq.pop();\n\t\tint t = tmp.second;\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].first;\n\t\t\t\tpq.emplace(d[E[t][i].first], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tcout << c - d - djk(a, b) - djk(b, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint i,j,n,m,s,g,v,p,flg[101],ky[101],a,min,ri[21][21],sum;\n\tPP ga[101];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++) scanf(\"%d,%d,%d,%d\",&ga[i].ff,&ga[i].fs,&ga[i].sf,&ga[i].ss);\n\tsort(ga,ga+m);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) ri[i][j]=M;\n\t}\n\tfor(i=1;i<=m;i++) {\n\t\tri[ga[i].ff][ga[i].fs]=ga[i].sf;\n\t\tri[ga[i].fs][ga[i].ff]=ga[i].ss;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t/*printf(\"\\n\");\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) printf(\"%d \",ri[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[s]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum=ky[g];\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[g]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum+=ky[s];\n\tprintf(\"%d\\n\",v-sum-p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n    for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    //    for(int i=0; i<vil[i].to.size(); i++){\n    //  vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    // }\n  }\n  ans_cost+=vil[y].cost;\n  /*  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    }\n    ans_cost+=vil[x].cost;*/\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF 1e9\n\nint v, m;\nint D[21][21];\n\nvoid warshall_floyd(){\n\tfor(int k = 1; k <= v; k++){\n\t\tfor(int i = 1; i <= v; i++){\n\t\t\tfor(int j = 1; j <= v; j++){\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint x1, x2, y1, y2;\n\tint mon;\n\tscanf(\"%d\\n%d\", &v, &m);\n\n\tfor(int i = 1; i <= v; i++){\n\t\tfor(int j = 1; j <= v; j++){\n\t\t\tif(i == j)\tcontinue;\n\t\t\tD[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tmon = y1 - y2;\n\twarshall_floyd();\n\tmon -= D[x1][x2] + D[x2][x1];\n\tprintf(\"%d\\n\", mon);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.push(make_pair(0, s));\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\tpq.push(make_pair(d[t] + E[t][i].second, E[t][i].first));\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconstexpr int M_MAX = 100;\nconstexpr int N_MAX = 20;\nconstexpr int INF = 1e8;\n\nint main()\n{\n  int n,m,a,b,c,d,s,g,V,P,reward;\n  struct edge {\n    edge(int t, int c)\n      : to_(t), cost_(c) {};\n    int to_;\n    int cost_;\n  };\n  vector<edge>G[M_MAX];\n  typedef pair<int,int> PII;\n  vector<int> q(N_MAX);\n  priority_queue<PII,vector<PII>,greater<PII>> que;\n\n  cin >> n;\n  cin >> m;\n  for (int i=0;i<m;++i) {\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    G[a].push_back(edge(b,c));\n    G[b].push_back(edge(a,d));\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\n  reward = V-P;\n\n  fill(q.begin(),q.end(),INF);\n  que.push(PII(s,0));\n  q[s] = 0;\n\n  while(!que.empty()){\n    PII k  = que.top();\n    que.pop();\n    int l = k.first;\n\nfor(int i=0;i<G[l].size();i++){\n      edge r = G[l][i];\n      if(q[r.to_] > q[l] + r.cost_){\n        q[r.to_] = q[l] + r.cost_;\n        que.push(PII(r.to_, q[r.to_]));\n      }\n    }\n  }\n\n  reward = reward - q[g];\n\n  fill(q.begin(),q.end(),INF);\n  que.push(PII(g,0));\n  q[g] = 0;\n\n  while(!que.empty()){\n    PII e = que.top();\n    que.pop();\n    int l = e.first;\n\n    for(int i=0;i<G[l].size();i++){\n      edge w = G[l][i];\n      if(q[w.to_] > q[l] + w.cost_){\n        q[w.to_] = q[l] + w.cost_;\n        que.push(PII(w.to_, q[w.to_]));\n      }\n}\n  }\n\n  reward = reward - q[s];\n\n  cout << reward << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[30];\nint d[30];\nint e[30];\n\nint main(){\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(e,0x3f,sizeof(e));\n\tint n,m;cin>>n>>m;\n\trep(i,m){\n\t\tint a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tE[a].push_back(P(b,c));E[b].push_back(P(a,d));\n\t}\n\tint s,g,a,b;scanf(\"%d,%d,%d,%d\",&s,&g,&a,&b);\n\ts--;g--;\n\tpriority_queue<P,vector<P>,greater<P>>pque;\n\tpque.push(P(s,0));\n\td[s]=0;\n\twhile(!pque.empty()){\n\t\tP p=pque.top();pque.pop();\n\t\tif(p.second>d[p.first])continue;\n\t\tfor(P i:E[p.first]){\n\t\t\tif(d[i.first]>d[p.first]+i.second){\n\t\t\t\td[i.first]=d[p.first]+i.second;\n\t\t\t\tpque.push(P(i.first,d[i.first]));\n\t\t\t}\n\t\t}\n\t}\n\tpque.push(P(g,0));\n\te[g]=0;\n\twhile(!pque.empty()){\n\t\tP p=pque.top();pque.pop();\n\t\tif(p.second>e[p.first])continue;\n\t\tfor(P i:E[p.first]){\n\t\t\tif(e[i.first]>e[p.first]+i.second){\n\t\t\t\te[i.first]=e[p.first]+i.second;\n\t\t\t\tpque.push(P(i.first,e[i.first]));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a-b-d[g]-e[s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    signed int n, m, a, b, c, d;\n    char temp[3];\n    cin >> n >> m;\n    vector<vector<int>> map(n, vector<int>(n, 2000000));\n    for(int i = 0;i<m;i++){\n        cin >> a >> temp[0] >> b >> temp[1] >> c >> temp[2] >> d;\n        map[a-1][b-1] = c;\n        map[b-1][a-1] = d;\n    }\n    cin >> a >> temp[0] >> b >> temp[1] >> c >> temp[2] >> d;\n    for(int h = 0;h<n;h++){\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<n;j++){\n            map[j][j] = 0;\n            for(int k = 0;k<n;k++){\n                map[j][i] = min(map[j][i],map[j][k] + map[k][i]);\n            }\n        }\n    }\n    }\n    cout << c - (map[a-1][b-1] + map[b-1][a-1] + d) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\ninline int toInt(string s){int v;istringstream i(s);i>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream o;o<<x;return o.str();}\ntemplate<class T> void pv(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\nint D[21][21];\n\nint main() {\n\tint N; cin >> N;\n\tint M; cin >> M;\n\tint start, goal;\n\tint y1, y2;\n\trep(i,N) rep(j,N) {\n\t\tD[i][j] = INF / 10;\n\t\tD[j][i] = INF / 10;\n\t}\n\tcin.ignore();\n\trep(i,M) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\t\tistringstream is(line);\n\t\tfor(int a, b, c, d; is >> a >> b >> c >> d;) {\n\t\t\ta--, b--;\n\t\t\tD[a][b] = c;\n\t\t\tD[b][a] = d;\n\t\t}\n\t}\n\t\n\n\tstring line;\n\tgetline(cin, line);\n\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\tistringstream is(line);\n\t\n\tis >> start >> goal >> y1 >> y2;\n\tstart--, goal--;\n\trep(k,N) rep(i,N) rep(j,N) D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n#if 0\n\tdebug(D[start][goal]);\n\tdebug(D[goal][start]);\n#endif\n\tcout << y1 - (y2 + D[start][goal] + D[goal][start]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define INF 999999999\nint D[21][21];\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tfor(int j = 0; j < n; ++j)\n\t\t{\n\t\t\ti == j ? D[i][i] = 0 : D[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t--a; --b;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint start, end;\n\tint reward, pillar;\n\tscanf(\"%d,%d,%d,%d\", &start, &end, &reward, &pillar);\n\tfor(int k = 0; k < n; ++k)\n\t{\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << reward - pillar - D[start - 1][end - 1] - D[end - 1][start - 1] << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, a, b, c, d;\n\tint data[25][25];\n\tint start, end, money, price;\n\t\n\tfor (int i = 0; i < 25; i++){\n\t\tfor (int j = 0; j < 25; j++){\n\t\t\tdata[i][j] = 10000000;\n\t\t}\n\t}\n\t\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdata[a][b] = c;\n\t\tdata[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &start, &end, &money, &price);\n\t\n\tfor (int k = 1; k <= n; k++){\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << money - (price + data[start][end] + data[end][start]) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std;\n#define INF 99\n\t\nint n, m, i, j, a, b, c, d, start, goal, money, hashira, minroot, tax[102][102] = {}, root[102] = {}, used[102] = {};\n\nint main() {\n\n\tcin >> n >> m;\n\t//?????????\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) tax[i][j] = INF;\n\t\ttax[i][i] = 0;\n\t\troot[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t//?????????????????¨?????\\???\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ttax[a][b] = c;\n\t\ttax[b][a] = d;\n\t}\n\t//????????????,??´??????,????????????????????????,??±????????¨\n\tscanf(\"%d,%d,%d,%d\", &start, &goal, &money, &hashira);\n\n\tmoney -= hashira;\n\t//?????????????????????stert???goal\n\troot[start] = 0;\n\twhile (1) {\n\t\tminroot = INF;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (used[i] == 0 && root[i] < minroot) {\n\t\t\t\tminroot = root[i];\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\tif (j == goal) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tused[j] = 1;\n\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\tif (root[j] + tax[j][i] < root[i]) root[i] = root[j] + tax[j][i];\n\t\t\t}\n\t\t}\n\t}\n\t\t//???????????´??°\n\t\tmoney -= root[goal];\n\n\t\t//?????????\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\troot[i] = INF;\n\t\t\tused[i] = 0;\n\t\t}\n\t\t//?????????????????????goal???start\n\t\troot[goal] = 0;\n\t\twhile (1) {\n\t\t\tminroot = INF;\n\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\tif (used[i] == 0 && root[i] < minroot) {\n\t\t\t\t\tminroot = root[i];\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tused[j] = 1;\n\t\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\t\tif (root[j] + tax[j][i] < root[i]) root[i] = root[j] + tax[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tmoney -= root[start];\n\t\t\n\t\tcout << money << endl;\n\t\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstatic const int INF = 1<<21;\nint n, m, a, b, c, d, s, g, v, p;\nint mat[21][21];\n\nvoid floyd(){\n    for(int k = 1; k <= n; k++){\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                mat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n\n    for(int i = 0; i < 21; i++){\n        for(int j = 0; j < 21; j++){\n            mat[i][j] = INF;\n        }\n    }\n\n    for(int i = 0; i < m; i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        mat[a][b] = c;\n        mat[b][a] = d;\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    floyd();\n\n    printf(\"%d\\n\", v-(mat[s][g]+mat[g][s]+p));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n\nint main(void){\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int> > town(n+1,vector<int>(n+1,1000));\n  \n  int a,b,c,d;\n  for(int i = 0 ; i < m ; i ++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    town[a][b] = c;\n    town[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  \n  int start = a;\n  int end = b;\n  \n  int get = c;\n  int lose = d;\n  \n  int max = 0;\n  /*\n  rep(i,town.size()){\n    cout<<i<< \" : \";\n    rep(j,town[i].size()){\n      printf(\"%4d \",town[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int k = 1 ; k < m-1 ; k ++){\n    for(int i = 1 ; i < n+1 ; i ++){\n      for(int j = 1 ; j < n+1 ; j ++){\n        town[i][j]=min(town[i][j],town[i][k]+town[k][j]);\n      }\n    }\n  }\n  //cout<<town[start][end]<<\" \"<<town[end][start]<<endl;\n  cout<<get-lose-town[start][end]-town[end][start]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n\tint city1,city2,cost1to2,cost2to1;\n};\n\n\n\nint main(){\n\tint n=0,m=0,start=0,goal=0,budget=0,treecost=0;\n\tcin>>n>>m;\n\tedge node[m+1];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&node[i].city1,&node[i].city2,&node[i].cost1to2,&node[i].cost2to1);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&budget,&treecost);\n\tint dp[n+1][n+1];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdp[i][j]=1000000000;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdp[node[i].city1][node[i].city2]=node[i].cost1to2;\n\t\tdp[node[i].city2][node[i].city1]=node[i].cost2to1;\n\t}\n\tfor(int l=1;l<=n;l++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<budget-treecost-dp[start][goal]-dp[goal][start]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\nconst int INF = 1<<29;\n\nint n, m;\nint dist[51][51];\nint a, b, c, d;\n\nint main() {\n    while (cin >> n >> m) {\n        for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) dist[i][j] = INF;\n        for (int i = 0; i < n; ++i) dist[i][i] = 0;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n            a--;b--;\n            dist[a][b] = c;\n            dist[b][a] = d;\n        }\n        for (int k = 0; k < n; ++k)\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j)\n                    chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        \n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--;b--;\n        cout << c - d - dist[a][b] - dist[b][a] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 100005\n#define MAX_V 100001\n#define INF (1e9 + 1)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint g[20][20];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tg[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tg[a-1][b-1]=c;\n\t\tg[b-1][a-1]=d;\n\t}\n\tint s,G,V,P;\n\tscanf(\"%d%d%d%d\",&s,&g,&V,&P);\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",V-P-g[s-1][G-1]-g[G-1][s-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < 25; i++){\n\t\tfor (int  j = 0; j<25; j++){\n\t\t\tw[i][j] = 10000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 0; h < N; h++){\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << y1- w[x1][x2]  - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 9999999;\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tint d[21][21];\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tfor(int j = 0; j < n; ++j)\n\t\t{\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tchar c;\n\tfor(int i = 0; i < m; ++i)\n\t{\n\t\tint a1, b1, c1, d1;\n\t\tcin >> a1 >> c >> b1 >> c >> c1 >> c >> d1;\n\t\t--a1;\n\t\t--b1;\n\t\td[a1][b1] = c1;\n\t\td[b1][a1] = d1;\n\t}\n\tfor(int k = 0; k < n; ++k)\n\t{\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\t--x1;\n\t--x2;\n\tcout << y1 - y2 - d[x1][x2] - d[x2][x1] << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint dijkstra(int from, int to, VVPII & nodes, int n){\n\tVI dist(nodes.size(), (int) 10e7);\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > q;\n\tq.emplace(0, from);\n\tdist[from] = 0;\n\twhile(!q.empty()){\n\t\tint cost = q.top().first; // cost\n\t\tint place = q.top().second; // current place\n\t\tq.pop();\n\t\tif(dist[place] < cost) continue;\n\t\tfor(PII node : nodes[place]){\n\t\t\tif(node.first + dist[place] < dist[node.second]){\n\t\t\t\tdist[node.second] = node.first + dist[place];\n\t\t\t\tq.emplace(dist[node.second], node.second);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, n){\n\n\t}\n\treturn dist[to];\n}\n\n\nint main(int argc, char const *argv[])\n{\n\tint n, m;\n\tcin >> n >> m;\n\tchar c;\n\tVVPII nodes(m);\n\n\tREP(i, m){\n\t\tint from, to, value;\n\t\tcin >> from >> c >> to >> c >> value;\n\t\tnodes[from].PB(MP(value, to));\n\t\tcin >> c >> value;\n\t\tnodes[to].PB(MP(value, from));\n\t}\n\n\tint start, goal, money, price;\n\tcin >> start >> c >> goal >> c;\n\tcin >> money >> c >> price;\n\tint go = dijkstra(start, goal, nodes, n);\n\tint back = dijkstra(goal, start, nodes, n);\n\tint reward = money - (price + go + back);\n\tcout << reward << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<iostream>\n#define INF 200\n#define rep(i,a) for(i=0;i<a;i++)\nusing namespace std;\nint main(void) \n{\n\tint glid[20][20],n,m,a,b,c,d,i,j,k,p,q,w,v;\n\tcin>>n>>m;\n\trep(i,n)rep(j,n)glid[i][j]=INF;rep(i,n)glid[i][i]=0;\n\trep(i,m) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;glid[a][b]=c;glid[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&p,&q,&w,&v);\n\trep(k,n)rep(i,n)rep(j,n)glid[i][j]=min(glid[i][j],glid[i][k]+glid[k][j]);\n\tp--;q--;\n\tcout<<w-v-(glid[p][q]+glid[q][p])<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (int)1e9\n\nint dijk(std::vector<std::vector<std::pair<int, int> > > fee, int s, int g); \n\nint main(void) {\n    int n;\n    int m;\n    std::cin >> n >> m;\n    std::vector<std::vector<std::pair<int, int> > > fee(n); //cost, to\n    int a;\n    int b;\n    int c;\n    int d;\n    char temp;\n\n    for (int i = 0; i < m; i++) {\n        std::cin >> a >> temp >> b >> temp >> c >> temp >> d;    \n        a--;\n        b--;\n        fee[a].push_back(std::make_pair(c, b));\n        fee[b].push_back(std::make_pair(d, a));\n    }\n\n    int s;\n    int g;\n    int v;\n    int p;\n    std::cin >> s >> temp >> g >> temp >> v >> temp >> p;\n    --s;\n    --g;\n\n    int go_cost = dijk(fee, s, g);\n    int back_cost = dijk(fee, g, s);\n\n    std::cout << v - p - go_cost - back_cost << std::endl;\n\n    return 0;\n}\n\nint dijk(std::vector<std::vector<std::pair<int, int> > > fee, int s, int g) {\n    std::vector<int> cost(fee.size(), INF);\n    std::vector<int> search(fee.size(), 0);\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >, std::greater<std::pair<int, int> > > pq;\n    int first;\n    int second;\n    std::pair<int, int> target;\n\n    pq.push(std::make_pair(0, s));\n    cost[s] = 0;\n\n    while(1) {\n        if (pq.empty() == true) {\n            break;\n        }\n        first = pq.top().first;\n        second = pq.top().second;\n        pq.pop();\n        if (search[second] != 0) {\n            continue;\n        }\n        search[second] = 1;\n        for (int i = 0; i < fee[second].size(); i++) {\n            target = fee[second][i];\n            pq.push(std::make_pair(target.first + cost[second], target.second)); \n            if (target.first + cost[second] < cost[target.second]) {\n                cost[target.second] = target.first + cost[second];\n            }\n        }\n    }\n\n    return cost[g];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint cost[32][32];\t//[i][j]ªi©çjÖÌRXg\nint d[32];\t\t\t//s©çÌÅ¬RXg\nint b[32];\t\t\t//g©çÌÅ¬RXg\nbool used[32];\t\t//gíê½©Ç¤©\nint N;\t\t\t\t//¸_\n\n\nvoid dijkstra(int s){\n\t//ú»\n\tfill(d, d + N+1, INF);\n\tfill(used,used+N+1,false);\n\td[s] = 0;\n\t\n\t\n\twhile(true){\n\t\tint v = -1;\n\t\t//gíêÄ¢È¢àÌÅÅ¬ÌàÌðT·\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(used[i]  == false && (v == -1 || d[i] < d[v]))v = i;\n\t\t}\n\t\tif(v == -1)break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\td[i] = min(d[v]+cost[v][i],d[i]);\n\t\t}\n\t}\n}\t\n\t\nint main(void){\n\twhile(scanf(\"%d\", &N) != EOF){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\t\n\t\t//ú»\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int j = 0; j <= N; j++){\n\t\t\t\tcost[i][j] = N;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a1,b1,c1,d1;\n\t\t\tscanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n\t\t\tcost[a1][b1] = c1;\n\t\t\tcost[b1][a1] = d1;\n\t\t}\n\t\t\n\t\tint s,g,money,co;\n\t\tscanf(\"%d,%d,%d,%d\", &s, &g, &money, &co);\n\t\t\n\t\tint go,back;\n\t\t\n\t\tdijkstra(s);\n\t\tgo = d[g];\n\t\t\n\t\tdijkstra(g);\n\t\tback = d[s];\n\t\t\n\t\tprintf(\"%d\\n\",money-co-go-back);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX INT_MAX\n#define F first\n#define S second\nusing namespace std;\nvector<int> town[2000];\nvector<int> cost[2000];\ntypedef pair<int,int> P;\nint main(void)\n{\n\tint n,m;\n\tint a,b,c,d;\n\tint s,g,v,p;\n\tchar ch,ch1,ch2,ch3;\n\t\n\tint flg[2000];\n\tint length[2000];\n\tint x,y;\n\tP pp;\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\n\tint i;\n\tcin>>n>>m;\n\t\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>ch>>b>>ch1>>c>>ch2>>d;\n\t\t\n\t\ttown[a].push_back(b);\n\t\tcost[a].push_back(c);\n\t\t\n\t\ttown[b].push_back(a);\n\t\tcost[b].push_back(d);\n\t\t\n\t}\n\t\n\tcin>>s>>ch>>g>>ch>>v>>ch>>p;\n\t\n\tfill(length,length+(n+1),MAX);\n\tfill(flg,flg+(n+1),0);\n\t\n\tque.push(P(0,s));\n\n\twhile(que.size()!=0){\n\t\tpp=que.top();\n\t\tque.pop();\n\t\tx=pp.F;\n\t\ty=pp.S;\n\t\tif(x<length[y]){\n\t\t\tlength[y]=x;\n\t\t\tflg[y]=1;\n\t\t\tfor(i=0;i<town[y].size();i++){\n\t\t\t\tif(flg[town[y][i]]==0){\n\t\t\t\t\tque.push(P(x+cost[y][i],town[y][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\twhile(!que.empty()){\n\t\tque.pop();\n\t}\n\tint wk;\n\twk=length[g];\n//\tcout<<wk<<endl;\n\t\n\tfill(length,length+(n+1),MAX);\n\tfill(flg,flg+(n+1),0);\n\t\n\tque.push(P(0,g));\n\n\twhile(que.size()!=0){\n\t\tpp=que.top();\n\t\tque.pop();\n\t\tx=pp.F;\n\t\ty=pp.S;\n\t\tif(x<length[y]){\n\t\t\tlength[y]=x;\n\t\t\tflg[y]=1;\n\t\t\tfor(i=0;i<town[y].size();i++){\n\t\t\t\tif(flg[town[y][i]]==0){\n\t\t\t\t\tque.push(P(x+cost[y][i],town[y][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint wk1;\n\twk1=length[s];\n\t//cout<<wk1<<endl;\n\t\n\tcout<<v-p-wk-wk1<<endl;\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\n#define N_MAX 20\n#define M_MAX 100\n#define INF 10000\n\nstruct Edge{\n\n  Edge(int t,int c)\n    :to_(t),cost_(c) {};\n\n  int to_;\n  int cost_;\n\n};\n\nvector<int> d(N_MAX);\nvector<Edge> edge[M_MAX];\n\nint s,g,V,P;\n\nint dijkstra(int start,int goal){\n  typedef pair<int,int> PII;\n  priority_queue<PII,vector<PII>,greater<PII>> que;\n\n  fill(d.begin(),d.end(),INF);\n  d[start]=0;\n  que.push(PII(start,0));\n\n  while(!que.empty()){\n    PII p=que.top();\n    que.pop();\n    int v=p.first;\n\n    if(d[v]<p.second) continue;\n\n    for(int i=0;i<edge[v].size();++i){\n      Edge e=edge[v][i];\n      if(d[e.to_]>d[v]+e.cost_){\n\td[e.to_]=d[v]+e.cost_;\n\tque.push(PII(e.to_,d[e.to_]));\n      }\n    }\n  }\n  return d[goal];\n}\n\nint main(){\n  int n,m,a,b,c,d;\n  cin>>n;\n  cin>>m;\n\n  for(int i=0;i<m;++i){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    edge[a].push_back(Edge(b,c));\n    edge[b].push_back(Edge(a,d));\n  }\n\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\n  V-=dijkstra(s,g);\n  V-=dijkstra(g,s);\n\n  cout<<V-P<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint dijkstra(int start,int goal,int n);\nconst int INF=1000000000;\nint edge[20][20];\n\nint main()\n{\n\tchar buf[64];\n\tint n,m;\n\t\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d\",&n);\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d\",&m);\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tedge[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tchar buf[64];\n\t\tint a,b,c,d;\n\t\tfgets(buf,64,stdin);\n\t\tsscanf(buf,\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\t\n\t\tedge[a-1][b-1]=c;\n\t\tedge[b-1][a-1]=d;\n\t}\n\tint start,goal,income,pay,reward;\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d,%d,%d,%d\",&start,&goal,&income,&pay);\n\t\n\treward=income-pay-dijkstra(start-1,goal-1,n)-dijkstra(goal-1,start-1,n);\n\tprintf(\"%d\",reward);\n\treturn 0;\n}\n\nint dijkstra(int start,int goal,int n)\n{\n\tint cost[20];\n\tbool visited[20];\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcost[i]=INF;\n\t\tvisited[i]=false;\n\t}\n\t\n\tcost[start]=0;\n\twhile(1)\n\t{\n\t\tint u=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!visited[i]&&(u==-1||cost[i]<cost[u]))//未訪問でcost最小の町=u\n\t\t\t{\n\t\t\t\tu=i;\n\t\t\t}\n\t\t}\n\t\tif(u==-1)break;\n\t\t\n\t\tvisited[u]=true;\n\t\tfor(int i=0;i<n;i++)//cost更新\n\t\t{\n\t\t\tcost[i]=cost[i]>cost[u]+edge[u][i]?cost[u]+edge[u][i]:cost[i];\n\t\t}\n\t}\n\treturn cost[goal];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n\n#define inf 1000000000\n\nusing namespace std;\n\nclass sint{\n\tpublic:\n\tint iti,now;\n\tsint(){}\n\tsint(int a,int b){iti=a;now=b;}\n\tbool operator < (const sint &a) const{\n\t\treturn now>a.now;\n\t}\n};\n\nint n,m;\nint road[21][21];\nint dike(int st,int en){\n\tpriority_queue<sint> state;\n\tint sima[101];\n\tint visit[101];\n\t\n\tfor(int i=0;i<101;i++){\n\t\tsima[i]=inf;\n\t\tvisit[i]=0;\n\t}\n\t\n\tstate.push(sint(st,0));\n\tsima[st]=0;\n\t\n\twhile(1){\n\t\tsint u = state.top();\n\t\tstate.pop();\n\t\t/*\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tprintf(\"%d \",sima[i]);\n\t\t}puts(\"\");\n\t\t\n\t\tprintf(\"now = %d en = %d\\n\",u.iti,en);\n\t\t*/visit[u.iti]=1;\n\t\t\n\t\tif(u.iti==en){\n\t\t\treturn u.now;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(road[u.iti][i]==inf||visit[i]==1)continue;\n\t\t\tif(sima[u.iti]+road[u.iti][i]<sima[i]){\n\t\t\t\tsima[i]=sima[u.iti]+road[u.iti][i];\n\t\t\t\tstate.push(sint(i,sima[i]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<21;i++){\n\t\tfor(int j=0;j<21;j++){\n\t\t\troad[i][j]=inf;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\troad[a][b]=c;\n\t\troad[b][a]=d;\n\t}\n\t\n\tint st,en,d1,d2;\n\tscanf(\"%d,%d,%d,%d\",&st,&en,&d1,&d2);\n\t\n\tint gou = dike(st,en);\n\tgou+=dike(en,st);\n\t\n\tprintf(\"%d\\n\",d1-d2-gou);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define INF 100000\n\nint n = 6;\n\nstd::vector<std::vector<int> >cost;\nstd::vector<int>min_cost;\nstd::vector<bool>used;\n\nvoid dijkstra(int i){\n\n\tused[i] = true;\n\n\tbool flg = true;\n\tfor (int j = 0; j < n; j++){\n\t\tif (!used[j])flg = false;\n\t}\n\tif (flg)return;\n\n\tfor (int j = 0; j < n; j++){\n\t\tif (cost[i][j] != INF){\n\t\t\tif (min_cost[j] > min_cost[i] + cost[i][j]){\n\t\t\t\tmin_cost[j] = min_cost[i] + cost[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint min;\n\tfor (int j = 0; j < n; j++){\n\t\tif (min_cost[j] != INF&&j != i&&!used[j]){\n\t\t\tmin = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int j = 0; j < n; j++){\n\t\tif (min_cost[j] != INF&&j != i&&!used[j]){\n\t\t\tif (min_cost[min]>min_cost[j])min = j;\n\t\t}\n\t}\n\n\tdijkstra(min);\n}\n\nint main(){\n\n\tstd::cin >> n;\n\n\tfor (int i = 0; i < n; i++){\n\t\tmin_cost.push_back(INF);\n\t\tused.push_back(false);\n\t\tcost.push_back(std::vector<int>());\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tcost[i].push_back(INF);\n\t\t}\n\t}\n\n\tint m;\n\tstd::cin >> m;\n\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tchar ch;\n\t\tstd::cin >> a >> ch >> b >> ch >> c >> ch >> d;\n\n\t\ta--; b--;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\tint res = 0;\n\tint x1, x2, y1, y2;\n\tchar ch;\n\tstd::cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\n\tx1--; x2--;\n\n\tmin_cost[x1] = 0;\n\tdijkstra(x1);\n\n\tres = y1 - y2 - min_cost[x2];\n\n\tfor (int i = 0; i < n; i++){\n\t\tmin_cost[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\tmin_cost[x2] = 0;\n\tdijkstra(x2);\n\n\tres -= min_cost[x1];\n\n\tstd::cout << res << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n    for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[r].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[y].cost;\n    for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[r].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[x].cost;\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m,a,b,c,d,x,y,e,f=1000000000,cnt[25][25],ans[25];\nvoid DFS(int set,int len){ans[set]=min(len,ans[set]);for(int i=0;i<n;i++)if(len+cnt[set][i]<ans[i])DFS(i,len+cnt[set][i]);}\nint main(){cin>>n>>m;\n\tfor(int i=0;i<n;i++){ans[i]=f;for(int j=0;j<n;j++)cnt[i][j]=f;}char z;\n\tfor(int i=0;i<m;i++){cin>>a>>z>>b>>z>>c>>z>>d;a--,b--,cnt[a][b]=c,cnt[b][a]=d;}\n\tint tans=0;\n\tcin>>x>>z>>e>>z;x--,e--;DFS(x,0);tans+=ans[e];for(int i=0;i<n;i++)ans[i]=f;DFS(e,0);tans+=ans[x];cin>>x>>z>>y;cout<<x-y-tans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 1001001001;\n\nvoid show(int K[32][32], int N){\n  for(int r=1;r<M+1;r++){\n    for(int c=1; c<M+1;c++){\n      cout << K[r][c] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid init_k(int K[32][32]){\n  fill(&K[0][0], &K[0][0]+32*32,inf); //Kツづ個渉可甘コツ可サ\n}\n\nvoid senni_k(int K[32][32]){\n  K[A][B] = C;\n  K[B][A] = D;\n}\n\nvoid Floyd_Warshall(int K[32][32]){\n  int i, j, k;\n  for(k=1; k<M+1; k++){\n    for(i=1; i<M+1; i++){\n      for(j=1; j<M+1; j++){\n\tif(K[i][j] > K[i][k] + K[k][j]){\n\t  K[i][j] = K[i][k] + K[k][j];\n\t}\n      }\n    }\n  }\n}\n\n\nint main(){\n  int Reward;\n  init_k(K);\n  scanf(\"%d %d\", &M, &N);\n  for(int i=0; i<N; i++){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    senni_k(K);\n    //cerr << \"read\" << A << ' ' << B << ' ' << C << ' ' << D << endl;\n  }\n  //show(K, M);\n  Floyd_Warshall(K);\n  //show(K, M);\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  \n  Reward = y1 - y2- K[x1][x2] - K[x2][x1];\n  cout << Reward << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nvector<vector<int>> dist(30, vector<int>(30, 1e9));\n\nvoid warshall_floyd(int n){\n    for(int k=0; k<n; k++){\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m; cin>>n>>m;\n    for(int i=0; i<n; i++){\n        dist[i][i] = 0;\n    }\n\n    char c1, c2, c3;\n    for(int i=0; i<m; i++){\n        int a, b, c, d;\n        cin>>a>>c1>>b>>c2>>c>>c3>>d;\n        a--;\n        b--;\n        dist[a][b] = c;\n        dist[b][a] = d;\n    }\n\n    int s, g, v, p; cin>>s>>c1>>g>>c2>>v>>c3>>p;\n    s--, g--;\n    warshall_floyd(n);\n\n    cout << v - p - dist[s][g] - dist[g][s] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1 << 29)\n\nint main(){\n  int n, m;\n  int cost[21][21];\n  int a, b, c, d;\n  \n  for(int i = 0 ; i < 21 ; i++){\n    for(int j = 0 ; j < 21 ; j++){\n      cost[i][j] = INF;\n      if(i == j) cost[i][j] = 0;\n    }\n  }\n      \n  cin >> n >> m;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n  \n  for(int k = 1 ; k <= n ; k++){\n    for(int i = 1 ; i <= n ; i++){\n      for(int j = 1 ; j <= n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n      }\n    }\n  }\n  \n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  \n  cout << y1 - y2 - cost[x1][x2] - cost[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint K[20][20];\nint n,m,a,b,c,d;\nint Floyd(int K[20][20],int n) {\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]) {\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\\n\",&n);\n\tscanf(\"%d\\n\",&m);\n\tcout << n << \" \" << m << endl;\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<n; ++j) {\n\t\t\tK[i][j] = 40000;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\tK[a-1][b-1] = c;\n\t\tK[b-1][a-1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tFloyd(K,n);\n\tcout << c-d-K[a-1][b-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nconst int inf=1e9;\nusing namespace std;\nint main(){\n  int a,b;\n  cin>>a>>b;\n  vector<vector<int> >in(a,vector<int>(a));\n  rep(i,a)rep(j,a)in[i][j]=inf;\n  int c,d,e,f;\n  //cout<<\"!\"<<endl;\n  rep(i,b+1){\n    char x;\n    cin>>c>>x>>d>>x>>e>>x>>f;\n    c--;d--;\n    if(i==b)break;\n    in[c][d]=e;\n    in[d][c]=f;\n  }\n  rep(k,a)rep(i,a)rep(j,a){\n    in[i][j]=min(in[i][j],in[i][k]+in[k][j]);\n  }\n  cout<<e-f-(in[c][d]+in[d][c])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n#define REP(i,n) for(i=1;i<=n;i++)\n\nint n,x1,x2,y1,y2;\nint cost[22][22]={0},map[22]={0},mark[22]={0};\n\nint d(int s,int end){\n\tint i;\n\tmark[s]=1;\n\tmemset(map,0,sizeof(map));\n\tmemset(mark,0,sizeof(mark));\n\twhile(!mark[end]){\n\t\tfor(i=1;i<=n;i++)\n\t\t\tif(!cost[s][i])continue;\n\t\t\telse if(!map[i] || map[i] > cost[s][i] + map[s]){\n\t\t\tmap[i] = cost[s][i] + map[s];\n\t\t}\n\t\tint mini=-1;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tif(!mark[i] && map[i] && (mini<0 || map[mini] > map[i])) mini = i;\n\t\tmark[mini]=1;\n\t\ts=mini;\n\t}\n\treturn map[end];\n}\n\nint main(){\n\tint i,j,m,s;\n\tchar cc;\n\tcin>>n>>m;\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>cc>>b>>cc>>c>>cc>>d;\n\t\tcost[a][b]=c;cost[b][a]=d;\n\t}\n\tcin>>x1>>cc>>x2>>cc>>y1>>cc>>y2;\n\tcout << y1-y2-d(x1,x2)-d(x2,x1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 25\n#define INF 1<<21\n\nint d[MAX_V][MAX_V];\t//d[u][v]は辺e=(u,v)のコスト(存在しない場合はINF、ただしd[i][i]=0とする)\nint n, m;\t//頂点数\n\nvoid warshall_floyd(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nint main(){\n\tfor(int i = 0; i < MAX_V; i++){\n\t\tfor(int j = 0; j < MAX_V; j++){\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\n\tcin >> n >> m;\n\tchar c;\n\tfor(int i = 0; i < m; i++){\n\t\tint a1, b1, c1, d1;\n\t\tcin >> a1 >> c >> b1 >> c >> c1 >> c >> d1;\n\t\td[a1-1][b1-1] = c1;\n\t\td[b1-1][a1-1]\t= d1;\t\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\t\n\twarshall_floyd();\n\tcout << y1 - y2 - d[x1-1][x2-1] - d[x2-1][x1-1] << endl;\n}\n/*\nワーシャルフロイド法\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nconst ll INF=1e10;\n#define pb push_back\n\nint main(){\n    int n,m; cin >> n >> m;\n    char ch; //コンマを読み捨てるための変数\n    vint a(m),b(m),c(m),d(m);\n    vector<vll> K(n+1,vll(n+1,INF));\n    rep(i,m){\n        int a,b; cin >> a >> ch >> b >> ch;\n        cin >> K[a][b] >> ch >> K[b][a];\n    }\n    int s,g,v,p; cin >> s >> ch >> g >> ch >>  v >> ch >> p;\n\n    range(k,1,n+1) range(i,1,n+1) range(j,1,n+1){\n        if(K[i][j]>K[i][k]+K[k][j]){\n            K[i][j]=K[i][k]+K[k][j];\n        }\n    }\n    cout << v-p-K[s][g]-K[g][s] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m,d[20][20],s,g,pr,pi;\nconst int INF=9999999;\nchar com;\nstruct road{int a,b,c,d;};\nroad r[400];\n\nint main() {\n    cin>>n>>m;\n    for(int i=0;i<m;i++)cin>>r[i].a>>com>>r[i].b>>com>>r[i].c>>com>>r[i].d;\n    cin>>s>>com>>g>>com>>pr>>com>>pi;\n    for(int i=0;i<400;i++)d[i/20][i%20]=INF;\n    for(int i=0;i<m;i++){\n\td[r[i].a][r[i].b]=r[i].c;\n\td[r[i].b][r[i].a]=r[i].d;\n    }\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<pr-pi-d[s][g]-d[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef struct edge{\n  edge(int a, int b):to(a),cost(b){};\n  int to, cost;\n}edge;\ntypedef struct state{\n  state(int a, int b):v(a),cost(b){};\n  int v, cost;\n  bool operator<(const state s)const{return cost < s.cost;}\n  bool operator>(const state s)const{return cost > s.cost;}\n}state;\n\nint dijkstra(vector<vector<edge> > &g, int start, int goal){\n  priority_queue<state, vector<state>, greater<state> > que;\n  que.push(state(start, 0));\n  vector<int> ans(g.size(), 1e9);\n  ans[start] = 0;\n  while(not que.empty()){\n    int v = que.top().v;\n    int c = que.top().cost;\n    que.pop();\n    for (int i = 0; i < g[v].size(); i++) {\n      int nv = g[v][i].to;\n      if(ans[nv] > c + g[v][i].cost){\n        ans[nv] = c + g[v][i].cost;\n        que.push(state(nv, ans[nv]));\n      }\n    }\n  }\n  return ans[goal];\n}\n\nint main(){\n  int n, m;\n  std::cin >> n >> m;\n  vector<vector<edge> > g(n);\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--, b--;\n    g[a].push_back(edge(b, c));\n    g[b].push_back(edge(a, d));\n  }\n  int start, goal, v, p;\n  scanf(\"%d,%d,%d,%d\", &start, &goal, &v, &p);\n  start--, goal--;\n  std::cout << v - p - (dijkstra(g, start, goal) + dijkstra(g, goal, start)) << std::endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>8)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<22\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct edge\n{\n\tint to;\n\tint cost;\n};\n\nvector<edge> G[21];\n\nvector<string> split(string &str,char delim)\n{\n\tvector<string> res;\n\tsize_t current = 0,found;\n\twhile((found = str.find_first_of(delim,current)) != string::npos)\n\t{\n\t\tres.push_back(string(str,current,found  - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str,current,str.size() - current));\n\treturn res;\n}\n\nint dijkstra(int s,int g,int n)\n{\n\tint d[20];\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+n,INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty())\n\t{\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\trep(i,G[v].size())\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main()\n{\n\tint n,m,cost[21][21];\n\trep(i,21)\n\t{\n\t\trep(j,21)\n\t\t{\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\n\tcin >> n >> m;\n\trep(i,m)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<string> _s = split(s,',');\n\t\tint a = atoi(_s[0].c_str());\n\t\tint b = atoi(_s[1].c_str());\n\t\tint c = atoi(_s[2].c_str());\n\t\tint d = atoi(_s[3].c_str());\n\n\t\tedge t,t2;\n\t\tt.to = a-1;\n\t\tt.cost = d;\n\t\tt2.to = b-1;\n\t\tt2.cost = c;\n\t\tG[b-1].push_back(t);\n\t\tG[a-1].push_back(t2);\n\t}\n\n\tstring s;\n\tcin >> s;\n\tvector<string> _s = split(s,',');\n\tint x1 = atoi(_s[0].c_str());\n\tint x2 = atoi(_s[1].c_str());\n\tint y1 = atoi(_s[2].c_str());\n\tint y2 = atoi(_s[3].c_str());\n\tint ans = y1 - y2;\n\tans -= dijkstra(x1-1,x2-1,n) + dijkstra(x2-1,x1-1,n);\n\tcout << ans << endl;\n\n}\n\nint main_Volume0117_a()\n{\n\tint n,m,cost[21][21];\n\trep(i,21)\n\t{\n\t\trep(j,21)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tcin >> n >> m;\n\n\trep(i,m)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<string> _s = split(s,',');\n\t\tint a = atoi(_s[0].c_str());\n\t\tint b = atoi(_s[1].c_str());\n\t\tint c = atoi(_s[2].c_str());\n\t\tint d = atoi(_s[3].c_str());\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\n\tREP(k,1,n+1)\n\t{\n\t\tREP(i,1,n+1)\n\t\t{\n\t\t\tREP(j,1,n+1)\n\t\t\t{\n\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstring s;\n\tcin >> s;\n\tvector<string> _s = split(s,',');\n\tint x1 = atoi(_s[0].c_str());\n\tint x2 = atoi(_s[1].c_str());\n\tint y1 = atoi(_s[2].c_str());\n\tint y2 = atoi(_s[3].c_str());\n\n\tint ans = y1 - y2;\n\tans -= cost[x1][x2] + cost[x2][x1];\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 100000000\n\nusing namespace std;\nstruct edge { int to, cost; };\ntypedef pair<int, int> P;\nint n, m;\nint x1, x2, y1, y2;\nvector<edge> G[20];\nint dijkstra(int, int);\nmain(){\n  while(cin >> n){\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n      edge tmp;\n      tmp.to=b-1;\n      tmp.cost=c;\n      G[a-1].push_back(tmp);\n      tmp.to=a-1;\n      tmp.cost=d;\n      G[b-1].push_back(tmp);\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    x1--;\n    x2--;\n    cout << y1-dijkstra(x1, x2)-dijkstra(x2, x1)-y2 << endl;\n  }\n  return 0;\n}\n\nint dijkstra(int s, int g){\n  int d[20];\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d+n, INF);\n  d[s]=0;\n  que.push(P(0, s));\n  while(!que.empty()){\n    P p=que.top(); que.pop();\n    int v=p.second;\n    if(d[v]<p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n  return d[g];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <class K, class V>\nclass RadixHeap {\n    static constexpr int bit_length = sizeof(K)*8;\n    K last;\n    size_t sz, cnt;\n\n    array<vector<pair<K, V>>, bit_length> v;\n    static inline int bsr(int x){\n        return x ? bit_length-__builtin_clz(x) : 0;\n    }\n    static inline int bsr(ll x){\n        return x ? bit_length-__builtin_clzll(x) : 0;\n    }\n\n    void pull() {\n        if(cnt < v[0].size()) return;;\n        int i = 1;\n        while(v[i].empty()) i++;\n        last = min_element(v[i].begin(),v[i].end())->first;\n        for (auto &&x : v[i]) v[bsr(x.first ^ last)].push_back(x);\n        v[i].clear();\n    }\npublic:\n    RadixHeap() : last(0), sz(0), cnt(0) {}\n    void emplace(K x, V val){\n        sz++;\n        v[bsr(x^last)].emplace_back(x, val);\n    }\n\n    pair<K, V> top() {\n        pull();\n        return v[0][cnt];\n    }\n\n    void pop() {\n        pull();\n        sz--;\n        cnt++;\n    }\n\n    size_t size() const { return sz; }\n    bool empty() const { return !sz; }\n};\ntemplate <typename T>\nvector<T> dijkstra(int s,vector<vector<edge<T>>> &G){\n    auto n = G.size();\n    vector<T> d(n, INF<T>);\n    RadixHeap<T, int> Q;\n    d[s] = 0;\n    Q.emplace(0, s);\n    while(!Q.empty()){\n        T cost; int i;\n        tie(cost, i) = Q.top(); Q.pop();\n        if(d[i] < cost) continue;\n        for (auto &&e : G[i]) {\n            auto cost2 = cost + e.cost;\n            if(d[e.to] <= cost2) continue;\n            d[e.to] = cost2;\n            Q.emplace(d[e.to], e.to);\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<edge<int>>> G(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--;\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, d);\n    }\n    int s, g, v, p;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n    s--; g--;\n    cout << v-p-dijkstra(s, G)[g]-dijkstra(g, G)[s] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint n,m;\nint V; // number of Vertex\nint s,G;// number of start\nvector<pii>g[10000]; // first: to second: cost\nvi d(1000,INF); // start->index  mminimum distance\nvoid dijkstra(){\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    d[s]=0;\n    que.push(pii(0,s));\n    while(!que.empty()){\n    pii now=que.top(); que.pop();\n        int v=now.second;\n        if(d[v]<now.first)continue;\n        for(int i=0; i<g[v].size();i++){\n            pii e=g[v][i];\n            if(d[e.first]>d[v]+e.second){\n                d[e.first]=d[v]+e.second;\n                que.push(pii(d[e.first],e.first));\n            }\n        }\n    }\n}\nint main(){\n    cin>>V>>m;\n    rep(i,m){\n        int to,from,tiya,rize;\n        char gomi; cin>>from>>gomi>>to>>gomi>>tiya>>gomi>>rize;\n        g[from].push_back(pii(to,tiya));\n        g[to].push_back(pii(from,rize));\n    }\n    int gotiusa,amausa;\n    char gomi;\n    cin>>s>>gomi>>G>>gomi>>gotiusa>>gomi>>amausa;\n    dijkstra();\n    int rize=d[G];\n    int hoge=s;\n    swap(s,G);\n    vi yebi(1000,INF);\n    d=yebi;\n    dijkstra();\n    cout<<gotiusa-amausa-rize-d[G]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nint solve(int s, int e)\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn D[s][e];\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tcin >> m;\n\tV = m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tcout << y1 - solve(x1, x2) - D[x2][x1] - y2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 100000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tll n,m,s,g,v,p;\n\tll pp,kou,min;\n\tll i,j,k;\n\tll ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\t\n\tprintf(\"%lld\\n\",v-p-kou);\n\treturn 0;\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<28)\ntypedef pair<int,int> P;\nint cost1[25][25];\nint main(){\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  \n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n;j++){\n      if(i != j) cost1[i][j] = INF;\n      else cost1[i][j] = 0;\n    }\n  }\n  \n  int a,b,c,d;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost1[a][b] = c;\n    cost1[b][a] = d;\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  for(int k=1;k<=n;k++){ //経由するノード\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tcost1[i][j] = min(cost1[i][j],cost1[i][k]+cost1[k][j]);\n      }\n    }\n  }\n  c-= cost1[a][b];\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tcost1[j][i] = min(cost1[j][i],cost1[j][k]+cost1[k][i]);\n      }\n    }\n  }\n  \n  cout << c-d-cost1[b][a] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct sides{\n    int t;\n    int v;\n};\nstruct ts{\n    int f;\n    int t;\n    int v;\n    void cpy(sides s){\n        t=s.t;\n        v=s.v;\n    };\n};\nint main(){\n    int n,m,p,q,s,e,ans,value[21];\n    sides temp[2];\n    vector<sides> a[21];\n    ts t,b;\n    queue<ts> unsolved;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\",&temp[0].t,&temp[1].t,&temp[1].v,&temp[0].v);\n        temp[0].t--;\n        temp[1].t--;\n        a[temp[0].t].push_back(temp[1]);\n        a[temp[1].t].push_back(temp[0]);\n    }\n    scanf(\"%d,%d,%d,%d\",&s,&e,&p,&q);\n    s--;\n    e--;\n    ans=p-q;\n    for(int i=0;i<a[s].size();i++){\n        t.cpy(a[s][i]);\n        t.f=s;\n        unsolved.push(t);\n    }\n    for(int i=0;i<n;i++)value[i]=-1;\n    value[s]=0;\n    while(!unsolved.empty()){\n        t=unsolved.front();\n        unsolved.pop();\n        if(value[t.t]!=-1&&value[t.t]<value[t.f]+t.v)continue;\n        value[t.t]=value[t.f]+t.v;\n        b=t;\n        for(int i=0;i<a[b.t].size();i++){\n            t.cpy(a[b.t][i]);\n            t.f=b.t;\n            unsolved.push(t);\n        }\n    }\n    ans-=value[e];\n    for(int i=0;i<a[e].size();i++){\n        t.cpy(a[e][i]);\n        t.f=e;\n        unsolved.push(t);\n    }\n    for(int i=0;i<n;i++)value[i]=-1;\n    value[e]=0;\n    while(!unsolved.empty()){\n        t=unsolved.front();\n        unsolved.pop();\n        if(value[t.t]!=-1&&value[t.t]<value[t.f]+t.v)continue;\n        value[t.t]=value[t.f]+t.v;\n        b=t;\n        for(int i=0;i<a[b.t].size();i++){\n            t.cpy(a[b.t][i]);\n            t.f=b.t;\n            unsolved.push(t);\n        }\n    }\n    ans-=value[s];\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<string>\n\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long long ll;\n#define INF 1e9\n\nusing namespace std;\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tint road[n+1][n+1];\n\tREP(i,n+1)REP(j,n+1){ road[i][j] = INF;if(i == j)road[i][j] = 0;}\n\t\n\t\n\tREP(i,m)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d, %d, %d, %d\",&a,&b,&c,&d);\n\t\troad[a][b] = c;road[b][a] = d;\n\t}\n\t\n\tint x1,x2,y1,y2;\n\tscanf(\"%d, %d, %d, %d\",&x1,&x2,&y1,&y2);\n\tREP(k,n+1)REP(i,n+1)REP(j,n+1)\n\troad[i][j] = min(road[i][j] ,road[i][k] + road[k][j]);\n\t\n\tcout << y1 - y2 - road[x1][x2] - road[x2][x1] << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 200000\nint main(){\n  typedef pair<int,int> Edge;\n  typedef pair<int,vector<Edge> > Node;\n  priority_queue<Node,vector<Node>,greater<Node> >que;\n  int n,m;\n  int starts,goal,maxm,hasira;\n  int a,b,c,d;\n  Node node[21];\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    node[a].second.push_back(Edge(c,b));\n    node[b].second.push_back(Edge(d,a));\n  }\n  scanf(\"%d,%d,%d,%d\",&starts,&goal,&maxm,&hasira);\n  for(int i=1;i<=n;i++){\n    node[i].first=INF;\n  }\n  node[starts].first=0;\n  que.push(node[starts]);\n  while(!que.empty()){\n    Node n=que.top();que.pop();\n    for(int i=0;i<n.second.size();i++){\n      if(node[n.second[i].second].first>n.first+n.second[i].first){\n\tnode[n.second[i].second].first=n.first+n.second[i].first;\n\tque.push(node[n.second[i].second]);\n      }\n    }\n  }\n  int koutuuhi=node[goal].first;\n\n    for(int i=1;i<=n;i++){\n    node[i].first=INF;\n  }\n  node[goal].first=0;\n  que.push(node[goal]);\n  while(!que.empty()){\n    Node n=que.top();que.pop();\n    for(int i=0;i<n.second.size();i++){\n      if(node[n.second[i].second].first>n.first+n.second[i].first){\n\tnode[n.second[i].second].first=n.first+n.second[i].first;\n\tque.push(node[n.second[i].second]);\n      }\n    }\n  }\n  koutuuhi+=node[starts].first;\n  cout<<maxm-koutuuhi-hasira<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge{\n\tint to, cost;\n};\n\ntypedef pair<int, int> P;\n\nconst int MAX_V = 3010;\nconst int INF = 1 << 30;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tchar c0;\n\tvector<Edge> vec[MAX_V];\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tcin >> a >> c0 >> b >> c0 >> c >> c0 >> d;\n\t\t--a, --b;\n\t\tvec[a].push_back(Edge{b, c});\n\t\tvec[b].push_back(Edge{a, d});\n\t}\n\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c0 >> x2 >> c0 >> y1 >> c0 >> y2;\n\t--x1, --x2;\n\n\tint d[MAX_V];\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d + n, INF);\n\td[x1] = 0;\n\tque.push(P(0, x1));\n\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < vec[v].size(); ++i){\n\t\t\tEdge e = vec[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans1 = d[x2];\n\t//cout << ans1 << endl;\n\n\tpriority_queue<P, vector<P>, greater<P> > que2;\n\tfill(d, d + n, INF);\n\td[x2] = 0;\n\tque2.push(P(0, x2));\n\n\twhile(!que2.empty()){\n\t\tP p = que2.top();\n\t\tque2.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < vec[v].size(); ++i){\n\t\t\tEdge e = vec[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque2.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans2 = d[x1];\n\t//cout << ans2 << endl;\n\n\tcout << y1 - (ans1 + ans2 + y2) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define INFINITY 100000\nint cost[20][20];\n\nint main(void){\n  char s;\n  int n,m,x1,x2,y1,y2;\n  REP(i,20)\n    REP(j,20)\n      cost[i][j] = (i!=j)?INFINITY:0;\n  cin>>n>>m;\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>s>>b>>s>>c>>s>>d;\n    cost[a-1][b-1] = c;\n    cost[b-1][a-1] = d;\n  }\n  cin>>x1>>s>>x2>>s>>y1>>s>>y2;\n  REP(k,n)\n    REP(i,n)\n      REP(j,n)\n       cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n  cout << y1 - y2 - cost[x1-1][x2-1] - cost[x2-1][x1-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvvi adj(n,vi(n,INFTY));\n\trep(i,n)\n\t\tadj[i][i]=0;\n\trep(i,m){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tadj[a-1][b-1]=c;\n\t\tadj[b-1][a-1]=d;\n\t}\n\trep(k,n) rep(i,n) rep(j,n)\n\t\tadj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);\n\t\n\tint src,dst,money,price;\n\tscanf(\"%d,%d,%d,%d\",&src,&dst,&money,&price);\n\t\n\tint res=money-(price+adj[src-1][dst-1]+adj[dst-1][src-1]);\n\tcout<<res<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// J4180449 三宅亮輔\n// 問題名\n// - A Reward For A Carpenter\n// 問題URL\n// - https://onlinejudge.u-aizu.ac.jp/problems/0117\n// 所要時間\n// -\n// 学んだこと\n//\n//\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\n\nll m;\n\nll a[101], b[101], c[101], d[101];\n\nll s, g, V, P;\n\nll D[21][21];\n\nconst ll INF = 0xfffffff;\nvector<ll> v;\n\nstring S;\n\nint main() {\n    cin >> n >> m;\n    for(ll i = 0; i < n; i++)\n        for(ll j = 0; j < n; j++)\n            D[i][j] = INF;\n\n    for(ll i = 0; i < n + 1; i++)\n        D[i][i] = 0;\n\n    for(ll i = 0; i < m + 1; i++) {\n        v.clear();\n        cin >> S;\n        for(ll j = 0; j < S.size(); j++) {\n            if(S[j] == ',')\n                v.push_back(j);\n        }\n        ll a, b, c, d;\n        a = stoi(S.substr(0, v[0]));\n        b = stoi(S.substr(v[0] + 1, v[1] - v[0] - 1));\n        c = stoi(S.substr(v[1] + 1, v[2] - v[1] - 1));\n        d = stoi(S.substr(v[2] + 1, v.size() - v[2] - 1));\n        a--;\n        b--;\n        if(i < m) {\n            D[a][b] = c;\n            D[b][a] = d;\n        } else {\n            s = a;\n            g = b;\n            V = c;\n            P = d;\n        }\n    }\n\n    for(ll k = 0; k < n; k++)\n        for(ll i = 0; i < n; i++)\n            for(ll j = 0; j < n; j++)\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\n    cout << V - P - (D[s][g] + D[g][s]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20];\n\tfor (int i = 0; i < m; i++)d[i] = 1000000000;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top(); pq.pop();\n\t\tint t = tmp.second;\n\t\tif (d[t] < tmp.first)continue;\n\t\td[t] = tmp.first;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\tpq.emplace(d[t] + E[t][i].second, E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tcout << c - d - djk(a, b) - djk(b, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n, m, a, b, c, d, s[22][22], inf = 100000, i, j, k;\n\tchar temp;\n\tcin >> n;\n\tcin >> m;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j) {\n\t\t\t\ts[i][j] = inf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tcin >> a >> temp >> b >> temp >> c >> temp >> d;\n\t\ts[a - 1][b - 1] = c;\n\t\ts[b - 1][a - 1] = d;\n\t}\n\tfor (k = 0; k < n; k++) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> a >> temp >> b >> temp >> c >> temp >> d;\n\tcout << c - d - s[a - 1][b - 1] -s[b-1][a-1]<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(auto i :dat){\n\t\tif(i.depart==s){\n\t\t\tq.push(i.arrival);\n\t\t\tcost.at(i.arrival)=i.cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(auto i:dat){\n\t\t\tif(i.depart==pos){\n\t\t\t\tif(cost.at(i.arrival)==INF){\n\t\t\t\t\tq.push(i.arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at(i.arrival)>i.cost+cost.at(pos)){\n\t\t\t\t\tcost.at(i.arrival)=i.cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(I,m+2){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint N, M, A, B, C, D,s,g,V,P;\nint K[32][32];\nconst int inf = 1001001001;\n\n\nint main() {\n\trep(i, 32) {\n\t\trep(j, 32) K[i][j] = inf;\n\t}\n\tcin >> N;\n\tcin.ignore();\n\tcin >> M;\n\trep (i,M) {\n\t\tcin >> A;\n\t\tcin.ignore();\n\t\tcin >> B;\n\t\tcin.ignore();\n\t\tcin >> C;\n\t\tcin.ignore();\n\t\tcin >> D;\n\t\tK[A][B] = C;\n\t\tK[B][A] = D;\n\t}\n\tcin >> s;\n\tcin.ignore();\n\tcin >> g;\n\tcin.ignore(); \n\tcin >> V;\n\tcin.ignore();\n\tcin>> P;\n\t\n\tfor (int k = 1; k <= N; k++) {\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (K[i][j] > K[i][k] + K[k][j]) K[i][j] = K[i][k] + K[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tint ans = V - P - K[s][g] - K[g][s];\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint dp[21][21];\n\nint main(){\n\tint INF = (int)1e9;\n\n\tint n, m;\n\tint a, b, c, d;\n\tint x1, x2, y1, y2;\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= n; ++j){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdp[a][b] = c;\n\t\tdp[b][a] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n\tfor(int k = 1; k <= n; ++k){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tfor(int j = 1; j <= n; ++j){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint cost = dp[x1][x2] + dp[x2][x1];\n\tint ans = y1 - y2 - cost;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, M, dist[50][50];\n\nsigned main() {\n    cin >> N >> M;\n    rep(i,0,N) rep(j,0,N) {\n        if(i == j) dist[i][j] = 0;\n        else dist[i][j] = INF;\n    }\n\n    rep(i,0,M) {\n        int a, b, c, d;\n        scanf(\"%lld,%lld,%lld,%lld\", &a, &b, &c, &d);\n        a--; b--;\n        dist[a][b] = c;\n        dist[b][a] = d;\n    }\n\n    rep(k,0,N) rep(i,0,N) rep(j,0,N) {\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        // printf(\"dist[%lld][%lld] = %lld\\n\", i, j, dist[i][j]);\n    }\n\n    int s, g, V, P;\n    scanf(\"%lld,%lld,%lld,%lld\", &s, &g, &V, &P);\n    s--; g--;\n    int cost = dist[s][g] + dist[g][s];\n\n    cout << V - P - cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <cstdlib>\n#include <queue>\n#include <vector>\n#include <set>\n#include <stdio.h>\n#include <cstdio>\nusing namespace std;\nint n,m,a,b,ab,ba,x1,x2,y1,y2;\nint co[20][20];\nint main() {\n\tscanf(\"%d%d\", &n, &m); \n\tfor (int i=0; i <n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tif( i == j ) co[i][j] = 0;\n\t\t\telse co[i][j] = 1000*20;\n\t\t}\n\t}\n\tfor (int i=0; i<m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &ab, &ba);\n\t\tco[a-1][b-1] = ab;\n\t\tco[b-1][a-1] = ba;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j< n;j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif(co[k][j] > co[k][i] + co[i][j] ) \n\t\t\t\tco[k][j] = co[k][i] + co[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout  << y1 - y2 - co[x1-1][x2-1] - co[x2-1][x1-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m,d[21][21],s,g,pr,pi;\nconst int INF=9999999;\nchar com;\nstruct road{int a,b,c,d;};\nroad r[400];\n\nint main() {\n    cin>>n>>m;\n    for(int i=0;i<m;i++)cin>>r[i].a>>com>>r[i].b>>com>>r[i].c>>com>>r[i].d;\n    cin>>s>>com>>g>>com>>pr>>com>>pi;\n    for(int i=0;i<441;i++)d[i/21][i%21]=INF;\n    for(int i=0;i<m;i++){\n\td[r[i].a][r[i].b]=r[i].c;\n\td[r[i].b][r[i].a]=r[i].d;\n    }\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<n;k++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<pr-pi-d[s][g]-d[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m,d[20][20],s,g,pr,pi;\nconst int INF=9999999;\nchar com;\nstruct road{int a,b,c,d;};\nroad r[400];\n\nint main() {\n    cin>>n>>m;\n    for(int i=0;i<m;i++)cin>>r[i].a>>com>>r[i].b>>com>>r[i].c>>com>>r[i].d;\n    cin>>s>>com>>g>>com>>pr>>com>>pi;\n    for(int i=0;i<400;i++)d[i/20][i%20]=INF;\n    for(int i=0;i<m;i++){\n\td[r[i].a][r[i].b]=r[i].c;\n\td[r[i].b][r[i].a]=r[i].d;\n    }\n    for(int i=0;i<m;i++)for(int j=0;j<m;j++)for(int k=0;k<m;k++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<pr-pi-d[s][g]-d[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[20];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(;;){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    if(vil[y].done){ans_cost+=vil[y].cost;break;}\n  }\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(;;){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    if(vil[x].done){ans_cost+=vil[x].cost;break;}\n  }\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int INF = 10000000,MAX = 21;\nint main(){\n\tint n,m,edge[MAX][MAX],a,b,c,d,s,g,p,pp;\n\tcin >> n >> m;\n\tfor(int i = 0;i < MAX;++i){\n\t\tfor(int j = 0;j < MAX;++j){\n\t\t\tedge[i][j] = INF;\n\t\t}\n\t\tedge[i][i] = 0;\n\t}\n\tfor(int i = 0;i < m;++i){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tedge[a][b] = c;\n\t\tedge[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&p,&pp);\n\tp -= pp;\n\tfor(int k = 1;k <= n;++k){\n\t\tfor(int i = 1;i <= n;++i){\n\t\t\tfor(int j = 1;j <= n;++j){\n\t\t\t\tedge[i][j] = min(edge[i][j],edge[i][k] + edge[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - (edge[s][g] + edge[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,a) for(int i = 0 ; i < a ; i++)\nint main(void){\n  int maze[20][20];\n  int maze1[20][20];\n  int prv[20][20];\n  int n,m;\n  int a,b,c,d;\n  cin>>n>>m;\n  rep(i,n)rep(j,n)maze[i][j]=maze1[i][j]=10000000;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    maze[--a][--b]=c;\n    maze[b][a]=d;\n  }\n  \n  \n  rep(k,n)rep(i,n)rep(j,n){\n    maze[i][j]=min(maze[i][j],maze[i][k]+maze[k][j]);\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  \n  cout<<-maze[--a][--b]-maze[b][a]+c-d<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\ntemplate<typename M>\nvoid warshallFloyd(M &m, const int &n) {\n  rep(k, n) rep(i, n) rep(j, n) cmin(m[i][j], m[i][k] + m[k][j]);\n}\n\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vvi t(n, vi(n));\n  rep(i, n) rep(j, n) t[i][j] = i == j ? 0 : INF;\n  char gomi;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> gomi >> b >> gomi >> c >> gomi >> d;\n    a--;\n    b--;\n    t[a][b] = c;\n    t[b][a] = d;\n  }\n  warshallFloyd(t, n);\n  int s, g, v, p;\n  cin >> s >> gomi >> g >> gomi >> v >> gomi >> p;\n  s--;\n  g--;\n  cout << v - p - t[s][g] - t[g][s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i < 25; i++){\n\t\tfor (int  j = 1; j<25; j++){\n\t\t\tw[i][j] = 100000000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 1; h <= N; h++){\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << y1 - w[x1][x2] - y2 - w[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n \nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[20][20];\nconst int inf = 10;\n \nint main(){\n  for (int m=0; m < 20; m++){\n  for (int n=0; n < 20; n++){\n    K[m][n] = inf;\n    }\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n    K[A][B] = C;\n    K[B][A] = D;\n    }\n    scanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n     \n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n      for (int j=1; j <= N; j++){\n        if (K[i][j] > K[i][k] + K[k][j]){\n          K[i][j] = K[i][k] + K[k][j];\n          }\n        }\n    }\n  }\n   \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstruct edge { int to, cost; };\nvector<edge> G[21];\nint search(int start, int goal)\n{\n    //first := cost, second := now vertex\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> dist(21, INF);\n    que.push(P(0, start));\n    dist[start] = 0;\n    while(not que.empty())\n    {\n        P now = que.top(); que.pop();\n        if(now.second == goal) break;\n        if(dist[now.second] < now.first) continue;\n        for(int u = 0; u < G[now.second].size(); u++)\n        {\n            edge e = G[now.second][u];\n            if(now.first + e.cost < dist[e.to])\n            {\n                dist[e.to] = now.first + e.cost;\n                que.push(P(dist[e.to], e.to));\n            }\n        }\n    }\n    return dist[goal];\n}\nint main()\n{\n    int n, m; cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a].push_back({b, c});\n        G[b].push_back({a, d});\n    }\n    int start, goal, v, p;\n    scanf(\"%d,%d,%d,%d\", &start, &goal, &v, &p);\n    int ans = v - p;\n    int a = search(start, goal);\n    int b = search(goal, start);\n    cout << ans - a - b << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\nint main(){\n\tint n,sum,m,dp[30][30],a,b,c,d,now,tar,mon,pri;\n\tcin>>n;\n\tcin>>m;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++){\n\t\tif(i!=j)\n\t\t\tdp[i][j]=INT_MAX/2;\n\t\telse\n\t\t\tdp[i][j]=0;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tdp[a-1][b-1]=c;\n\t\tdp[b-1][a-1]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&now,&tar,&mon,&pri);\n\tfor(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\tsum=dp[now-1][tar-1]+dp[tar-1][now-1]+pri;\n\tcout<<mon-sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tint n,m;\n\tPP d[100];\n\t\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tint s,g,v,p;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tint rin[21][21];\n\tfor(int i=1;i<=n;i++) fill(rin[i]+1,rin[i]+n+1,INF);\n\tfor(int i=0;i<m;i++) rin[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t\t  rin[d[i].fs][d[i].ff]=d[i].ss;\n\t\n\tint leng[21],flg[21];\n\tfill(leng+1,leng+n+1,INF); fill(flg+1,flg+n+1,0);\n\tleng[s]=0;\n\tint sum;\n\tfor(int i=0;i<n;i++){\n\t\tint mn=INF,t;\n\t\tfor(int j=1;j<=n;j++) if(flg[j]==0&&mn>leng[j]) t=j,mn=leng[j];\n\t\tif(t==g){\n\t\t\tsum=leng[t];\n\t\t\tbreak;\n\t\t}\n\t\tflg[t]=1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(rin[t][j]!=INF){\n\t\t\t\tif(leng[t]+rin[t][j]<leng[j]) leng[j]=leng[t]+rin[t][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill(leng,leng+n+1,INF); fill(flg+1,flg+n+1,0);\n\tleng[g]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint mn=INF,t; \n\t\tfor(int j=1;j<=n;j++) if(flg[j]==0&&mn>leng[j]) t=j,mn=leng[j];\n\t\tif(t==s){\n\t\t\tsum+=leng[t];\n\t\t\tbreak;\n\t\t}\n\t\tflg[t]=1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(rin[t][j]!=INF){\n\t\t\t\tif(leng[t]+rin[t][j]<leng[j]) leng[j]=leng[t]+rin[t][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<v-p-sum<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=10000000;\nint map[21][21];\n\nint main(void){\n\tint a,b,c;\n\tint d[4];\n\tint ans;\n\tint n,m;\n\tfor(a=0;a<=20;a++){\n\t\tfor(b=0;b<=20;b++){\n\t\t\tmap[b][a]=INF;\n\t\t\tif(b==a)map[b][a]=0;\n\t\t}\n\t}\n\tcin >> n;\n\tcin >> m;\n\tfor(a=0;a<m;a++){\n\t\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\t\tmap[d[0]][d[1]]=d[2];\n\t\tmap[d[1]][d[0]]=d[3];\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tfor(c=1;c<=n;c++){\n\t\t\t\tmap[a][b]=min(map[a][b],map[a][c]+map[c][b]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tfor(c=1;c<=n;c++){\n\t\t\t\tmap[a][b]=min(map[a][b],map[a][c]+map[c][b]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\tans=d[2]-d[3]-map[d[0]][d[1]]-map[d[1]][d[0]];\n\tcout << ans <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][21],int b[],int c,int e,int m){\n  int i;\n  if(c==e){\n    if(b[c]==-1||b[c]>m)\n      b[c]=m;\n  }else if(b[c]==-1||b[c]>m){\n    b[c]=m;\n    for(i=1;i<21;i++){\n      if(a[c][i])\n\tf(a,b,i,e,m+a[c][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  int a[21][21],b[21],m,n,v,w,x,y;\n  memset(a,0,sizeof(a));\n  cin>>n>>m;\n  for(i=0;i<m;i++){\n    int p,q,r,s;\n    scanf(\"%d,%d,%d,%d\",&p,&q,&r,&s);\n    a[p][q]=r;\n    a[q][p]=s;\n  }\n  scanf(\"%d,%d,%d,%d\",&v,&w,&x,&y);\n  memset(b,-1,sizeof(b));\n  f(a,b,v,w,0);\n  x-=b[w];\n  memset(b,-1,sizeof(b));\n  f(a,b,w,v,0);\n  x-=b[v];\n  cout<<(x-y>0?x-y:0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#define f first\n#define s second\nusing namespace std;\n\nint INF = (1<<21);\ntypedef pair<int,int> P;// f=to s=cost\nvector<P> info[22];\nint m_cost[22];\npriority_queue<P, vector<P>, greater<P> > que;//queueに入るコストは合計コスト\nint n, m;\nint x1, x2;\nint ans, y2;\n\nvoid dijkstra(){\n  while(!que.empty()){\n    P now = que.top(); que.pop();\n    int size = info[now.f].size();\n    for(int i = 0; i < size; i++){\n      if(info[now.f][i].s + now.s < m_cost[info[now.f][i].f]){\n\tm_cost[info[now.f][i].f] = info[now.f][i].s + now.s;\n\tP next;\n\tnext.f = info[now.f][i].f;\n\tnext.s = m_cost[info[now.f][i].f];\n\tque.push(next);\n      }\n    }\n  }\n  return;\n}\n    \nint main(){\n  for(int i = 0; i < 22; i++) m_cost[i] = INF;\n  cin >> n;\n  cin >> m;\n  for(int i = 0; i < m; i++){\n    P p;\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    p.f = b; p.s = c;\n    info[a].push_back(p);\n    p.f = a; p.s = d;\n    info[b].push_back(p);\n  }\n\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &ans, &y2);\n  ans -= y2; \n  P p; p.f = x1; p.s = 0;\n  que.push(p);\n  dijkstra();\n  \n  ans -= m_cost[x2];\n\n  for(int i = 0; i < 22; i++) m_cost[i] = INF;\n  p.f = x2; p.s = 0;\n  que.push(p);\n  dijkstra();\n  \n  ans -= m_cost[x1];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cstdio>\n\nconst int N = 21;\nconst int infi = (int)1e9 + 7;\n\ntypedef std::pair<int, int> P;\n\nint n, m;\nstd::vector<P> g[N];\nint cost[N];\n\nvoid dijkstra(int k){\n\tfor(int i = 0; i < n; ++i)cost[i] = infi;\n\tcost[k] = 0;\n\tstd::priority_queue<P, std::vector<P>, std::greater<P> >que;\n\tque.push(P(0, k));\n\t\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\tif(cost[v] < p.first)continue;\n\t\t\n\t\tfor(int i = 0; i < g[v].size(); ++i){\n\t\t\tint to = g[v][i].first;\n\t\t\tif(cost[to] > cost[v] + g[v][i].second){\n\t\t\t\tcost[to] = cost[v] + g[v][i].second;\n\t\t\t\tque.push(P(cost[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t--a, --b;\n\t\t\n\t\tg[a].push_back(P(b, c));\n\t\tg[b].push_back(P(a, d));\n\t}\n\t\n\tint s, gg, v, p;\n\tscanf(\"%d,%d,%d,%d\", &s, &gg, &v, &p);\n\t--s, --gg;\n\tdijkstra(s);\n\tv -= cost[gg];\n\tdijkstra(gg);\n\tv -= cost[s];\n\tv -= p; \n\tprintf(\"%d\\n\", v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#define inf 99999\n\nusing namespace std;\n\nbool check(int *a, int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tif(a[i] == 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint dij(int **a, int n, int s, int t)\n{\n\tint *label, current = s, next, *cost;\n\t\n\tlabel = (int *)calloc(n+1, sizeof(int));\n\tcost = (int *)calloc(n+1, sizeof(int));\n\tlabel[current] = 1;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcost[i] = a[current][i];\n\t}\n\t\n\twhile(check(label, n)){\n\t\tfor(int i = 1, min = inf; i <= n; i++){\n\t\t\tif(min > cost[i] && label[i] == 0){\n\t\t\t\tmin = cost[i];\n\t\t\t\tnext = i;\n\t\t\t}\n\t\t}\n\t\tlabel[next] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(label[i] == 0 && cost[i] > (a[next][i]+cost[next])){\n\t\t\t\tcost[i] = a[next][i] + cost[next];\n\t\t\t}\n\t\t}\n\t\tcurrent = next;\n\t}\n\tnext = cost[t];\n\t\n\tfree(cost);\n\tfree(label);\n\t\n\treturn next;\n}\n\nint main(int argc, char **argv)\n{\n\tint n, m, **ary, a, b, c, d;\n\t\n\tcin >> n;\n\tcin >> m;\n\t\n\tary = (int **)calloc(n+1, sizeof(int));\n\tfor(int i = 1; i <= n; i++){\n\t\tary[i] = (int *)calloc(n+1, sizeof(int));\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tary[a][b] = c;\n\t\tary[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i != j && ary[i][j] == 0){\n\t\t\t\tary[i][j] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tc -= dij(ary, n, a, b);\n\tc -= d;\n\tc -= dij(ary, n, b, a);\n\tcout << c << endl;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfree(ary[i]);\n\t}\n\tfree(ary);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nconst int MAXN = 21;\nconst int INF = 1<<28;\nint N;\nint G[MAXN][MAXN];\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      G[i][j] = i == j ? 0 : INF;\n    }\n  }\n  int m;\n  cin >> m;\n  ++m;\n  int a, b, c, d;\n  while(m--) {\n    string s;\n    cin >> s;\n    replace(s.begin(), s.end(), ',', ' ');\n    stringstream ss(s);\n    ss >> a >> b >> c >> d;\n    --a;\n    --b;\n    if(!m) break;\n    G[a][b] = c;\n    G[b][a] = d;\n  }\n\n  for(int k = 0; k < N; ++k) {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  cout << c-d-G[a][b]-G[b][a] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define REP(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\nconst int MAX_V = 20;\nconst int MAX_E = 500000;\nconst int INF = INT_MAX;\n\nstruct E{\n  int to, cost;\n  E(int t, int c) : to(t), cost(c) {};\n};\ntypedef pair<int, int> pii;\n\nint v;\nvector<E> g[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s)\n{\n  fill(d, d + v, INF);\n  d[s] = 0;\n  priority_queue<pii, vector<pii>, greater<pii> > q;\n  q.push(pii(0, s));\n  \n  while(!q.empty()){\n    pii p = q.top();\n    q.pop();\n    int from = p.second;\n    if(d[from] < p.first) continue;\n    \n    for(int i = 0; i < g[from].size(); ++i){\n      int to = g[from][i].to;\n      int cost = g[from][i].cost;\n      \n      if(d[to] > d[from] + cost){\n        d[to] = d[from] + cost;\n        q.push(pii(d[to], to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  REP(i, m){\n    int a1, b1, c1, d1;\n    scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n    g[a1].push_back(E(b1, c1));\n    g[b1].push_back(E(a1, d1));\n  }\n  v = n;\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  dijkstra(x1);\n  int go = d[x2];\n  dijkstra(x2);\n  int back = d[x1];\n  cout << y1 - go - back - y2 + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <memory>\n#include <memory.h>\nusing namespace std;\n\nint d[21][21];\n\nint main(){\n  char ch;\n  int n, m;\n  memset(d, -1, sizeof(d));\n  int x1, x2, y1, y2;\n  cin >> n >> m;\n  for(int i = 0; i < m; i++){\n    int a, b, c, d2;\n    cin >> a >> ch >> b >> ch >> c >> ch >> d2;\n    d[a][b] = c;\n    d[b][a] = d2;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(d[j][i] < 0) continue;\n      for(int k = 1; k <= n; k++){\n\tif(d[i][k] >= 0 && (d[j][k] < 0 || d[j][k] > d[j][i] + d[i][k])){\n\t  d[j][k] = d[j][i] + d[i][k];\n\t}\n      }\n    }\n  }\n  cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n  cout << y1 - y2 - d[x1][x2] - d[x2][x1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nll G[20][20];\nll dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n    for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[y].cost;\n  /*  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    }\n    ans_cost+=vil[x].cost;*/\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int i,j;\n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int ans;\n  int rout[21][21];\n  int dis1[21],dis2[21];\n  int flag;\n\n  while(scanf(\"%d\",&n)!=EOF){\n    cin >> m;\n\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\trout[i][j] = 0;\n      }\n    }\n\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d,%d \",&a,&b,&c,&d);\n      rout[a][b] = c;\n      rout[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d \",&x1,&x2,&y1,&y2);\n\n    for(i=1;i<=n;i++)dis1[i] = -1;\n    for(i=1;i<=n;i++)dis2[i] = -1;\n    dis1[x1] = 0;\n    dis2[x2] = 0;\n\n    while(1){\n      flag = 0;\n\n      for(i=1;i<=n;i++){\n\tif(dis1[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>0){\n\t      if(dis1[j]<0){\n\t\tdis1[j] = dis1[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis1[i]+rout[i][j] < dis1[j]){\n\t\tdis1[j] = dis1[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n\tif(dis2[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>0){\n\t      if(dis2[j]<0){\n\t\tdis2[j] = dis2[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis2[i]+rout[i][j] < dis2[j]){\n\t\tdis2[j] = dis2[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(!flag)break;\n    }\n  \n    ans = y1 - y2 -dis1[x2] - dis2[x1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£????????????\n#endif\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf=1001001001;\nint pay,ans;\n\nint main(){\n\t//??????Inf??§???????????????????????????\n\tfor(int i=0;i<32;i++)\n\t\tfor(int j=0;j<32;j++)\n\t\t\tK[i][j]=inf;\n\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0;i<M;++i){\n\t\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\t\t//cerr<<\"read \"<<A<<' '<<B<<' '<<C<<' '<<D<<endl;\n\t\tK[A][B]=C;\n\t\tK[B][A]=D;\n\n/*\t\tfor(int i=1;i<N+1;i++){//?????§?????????\n    for(int j=1;j<N+1;j++){\n      if(K[i][j]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[i][j]<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n*/\n\tfor(int k=1;k<N+1;k++)\n\t\tfor(int i=1;i<N+1;i++)\n\t\t\tfor(int j=1;j<N+1;j++)\n\t\t\t\tif(K[i][j]>K[i][k]+K[k][j])\n\t\t\t\t\tK[i][j]=K[i][k]+K[k][j];\n\n/*\t for(int l=1;l<N+1;l++){//?????§??????2???\n    for(int m=1;m<N+1;m++){\n      if(K[l][m]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[l][m]<<\" \";\n      }\n    }\n    cout<<endl;\n    } \n    cout<<endl;\n*/\n\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\tpay=K[A][B]+K[B][A];\n  ans=C-D-pay;\n  cout<<ans<<endl; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nbool input(){\n  char t;\n  int n;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n  return true;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  init(),input();\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> graph(N, vector<int>(N, 10000));\n    for(int i = 0; i < M; ++i) {\n        string s;\n        cin >> s;\n        for(char &c : s) {\n            if(c == ',') c = ' ';\n        }\n        istringstream is(s);\n        int a, b, c, d;\n        is >> a >> b >> c >> d;\n        graph[a-1][b-1] = c;\n        graph[b-1][a-1] = d;\n    }\n    int S, T, A, B;\n    {\n        string s;\n        cin >> s;\n        for(char &c : s) {\n            if(c == ',') c = ' ';\n        }\n        istringstream is(s);\n        is >> S >> T >> A >> B;\n        --S; --T;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n            }\n        }\n    }\n    cout << A-B-graph[S][T]-graph[T][S] << endl;\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 21\n#define INF 9999999\n\nint g[MAX][MAX],v[MAX],n,mn,minm;\nbool visit[MAX];\n\nint dijkstra(int start,int goal){\n    for(int i = 0 ; i < MAX; i++){\n        v[i] = INF;\n        visit[i] = false;\n    }\n    \n    v[start] = 0;\n    while(true){\n        minm = INF;\n        for(int i = 1 ; i <= n ; i++){\n            if(v[i] < minm && !visit[i]){\n                minm = v[i];\n                mn = i;\n            }\n        }\n        \n        if(minm == INF) break;\n        visit[mn] = true;\n        \n        for(int j = 1 ; j <= n ; j++){\n            int tmp = g[mn][j]+v[mn];\n            if(tmp < v[j]) v[j] = tmp;\n        }\n    }\n\n    return v[goal];\n}\n\nint main(){\n    int m,a,b,c,d,x1,x2,y1,y2;\n    char ch;\n    \n    for(int i = 1 ; i < MAX; i++)\n        for(int j = 1 ; j < MAX ; j++)\n            g[i][j] = INF;\n\n    cin >> n >> m;\n    while(m--){\n        cin >> a >> ch >> b >> ch >> c >> ch >> d;\n        g[a][b] = c;\n        g[b][a] = d;\n    }\n    \n    cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n    cout << y1 - y2 - dijkstra(x1,x2) - dijkstra(x2,x1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 1001001001;\n\nint main(){\n for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint r[400][4];\nint d[21][21];\n\nint main(){\n\tint n,m,x1,x2,y1,y2,i,j,k;\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\td[i][j]=1000000;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&r[i][0],&r[i][1],&r[i][2],&r[i][3]);\n\t\td[r[i][0]][r[i][1]]=r[i][2];\n\t\td[r[i][1]][r[i][0]]=r[i][3];\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tfor(k=1;k<=n;k++){\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<y1-y2-d[x1][x2]-d[x2][x1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tll i,j,k;\n\tll n,m,s,g,b,e,pp,kou;\n\tll ri[21][21];\n\tll leng[21],v[21];\n\tll min;\n\t\n\tPP p[100];\n\t\n\tcin>>n>>m;\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&p[i].ff,&p[i].fs,&p[i].ss,&p[i].sf);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&b,&e);\n\t\n\t//隣接行列\n\tsort(p,p+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[p[i].ff][p[i].fs]=p[i].sf,ri[p[i].fs][p[i].ff]=p[i].ss;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[g];\n//\tcout<<leng[g]<<endl;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[g]=0;\n\t\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[s];\n//\tcout<<leng[s]<<endl;\n\t\n\tcout<<b-e-kou<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint ret = INT_MAX;\nint s, g;\nvoid dfs(vector<vector<int> > vc, int cost, int v, bool f, vector<bool> &visited) {\n\tif(ret < cost) return;\n\tif(f && v == s) {\n\t\tif(ret > cost) ret = cost;\n\t\treturn;\n\t}\n\tif(!f && v == g) {\n\t\tf = true;\n\t\trep(i,visited.size()) {\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\trep(i,vc[v].size()) {\n\t\tif(vc[v][i] != -1 && !visited[i]) {\n\t\t\tvisited[i] = true;\n\t\t\tdfs(vc, cost+vc[v][i], i, f, visited);\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n}\n\t\t\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > vc(n); \n\trep(i,n) {\n\t\tvector<int> va(n);\n\t\tvc[i] = va;\n\t\trep(j,n) {\n\t\t\tvc[i][j] = -1;\n\t\t}\n\t}\n\trep(i,m) {\n\t\tint s, t, c1, c2;\n\t\tscanf(\"%d,%d,%d,%d\", &s, &t, &c1, &c2);\n\t\tvc[--s][--t] = c1;\n\t\tvc[t][s] = c2;\n\t}\n\tint sum, cost;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &sum, &cost);\n\t--s, --g;\n\tvector<bool> visited(n);\n\trep(i,n) {\n\t\tvisited[i] = false;\n\t}\n\tdfs(vc,0,s,false,visited);\n\tcout << sum - cost - ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <algorithm>\n\nconst int kMaxTown = 21; //0?????????????????????\nconst int kInf = 1 << 16;\n\nint d[kMaxTown];\nint arrived[kMaxTown];\nint cost[kMaxTown][kMaxTown];\n\nvoid dijkstra(const int s, const int n){\n\tfor (int i = 0; i < kMaxTown; i++) d[i] = kInf;\n\tfor (int i = 0; i < kMaxTown; i++) arrived[i] = false;\n\n\td[s] = 0;\n\n\twhile (1){\n\t\tint minTown = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (!arrived[i] && (d[i] < d[minTown]))\n\t\t\t\tminTown = i;\n\t\tif (minTown == 0) break;\n\t\tarrived[minTown] = true;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\td[i] = std::min(d[i], d[minTown] + cost[minTown][i]);\n\t}\n\n}\n\nint main(){\n\n\tfor (int i = 0; i < kMaxTown; i++)\n\t\tfor (int j = 0; j < kMaxTown; j++)\n\t\t\tcost[i][j] = kMaxTown;\n\n\tint n, m;\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tdijkstra(x1, n);\n\ty1 -= d[x2];\n\tdijkstra(x2, n);\n\ty1 -= d[x1];\n\n\tprintf(\"%d\\n\", y1-y2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m,d[21][21],s,g,pr,pi;\nconst int INF=9999999;\nchar com;\nstruct road{int a,b,c,d;};\nroad r[400];\n\nint main() {\n    cin>>n>>m;\n    for(int i=0;i<m;i++)cin>>r[i].a>>com>>r[i].b>>com>>r[i].c>>com>>r[i].d;\n    cin>>s>>com>>g>>com>>pr>>com>>pi;\n    for(int i=0;i<441;i++)d[i/21][i%21]=INF;\n    for(int i=0;i<m;i++){\n\td[r[i].a][r[i].b]=r[i].c;\n\td[r[i].b][r[i].a]=r[i].d;\n    }\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=n;k++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<pr-pi-d[s][g]-d[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nbool input(){\n  char t;\n  int n;\n  if(!(cin>>n))return false;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n  return true;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX-100;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int INF = (1<<21);\nint n;\n\nstruct edge {\n  int to, cost;\n  edge(int _to, int _cost) {to = _to; cost=_cost;}\n};\ntypedef pair<int, int> P;\n\n\nint V;\nvector<edge> G[20];\nint d[20];\n\nint dij(int s,int g) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d + n, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n  \n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) {\n      continue;\n    }\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n  return (d[g]);\n}\n\nint main(){\n  int m,y1,y2,x1,x2;\n  cin>> n>> m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    G[a-1].push_back(edge(b-1,c));\n    G[b-1].push_back(edge(a-1,d));\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n  cout<< y1-(y2+dij(x1-1,x2-1)+dij(x2-1,x1-1))<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<complex>\nusing namespace std ;\ntypedef vector<int> vi ;\ntypedef vector<vi> vvi ;\ntypedef vector<string> vs ;\ntypedef pair<int, int> pii; \ntypedef long long ll ;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define INF (1<<29)\nint dist[30][30];\nint main(void){\n  int n,m;\n  char dummy;\n  cin >> n >> m;\n\n  rep(i,n){\n    rep(j,n){\n      if(i==j)dist[i][j]=0;\n      else dist[i][j]=INF;\n    }\n  }\n\n  rep(i,m){\n    int a,b,c,d;\n    cin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n    dist[a-1][b-1] = c;\n    dist[b-1][a-1] = d;\n  }\n\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n      }\n    }\n  }\n\n  int x1 , x2 , y1 , y2;\n  cin >> x1 >> dummy >> x2 >> dummy >> y1 >> dummy >> y2;\n  cout<< (y1 - y2 - dist[x1-1][x2-1] - dist[x2-1][x1-1]) <<endl; \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <sstream>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n#define print(s) cout << (s) << endl\n\nconst int INF = 1e5;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> cost = vector<vector<int>>(20,vector<int>(20,INF));\n    int a, b, c, d;\n    REP(i,m) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[--a][--b] = c;\n        cost[b][a] = d;\n    }\n    \n    REP(i,n) REP(j,n) REP(k,n) {\n        cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n    }\n    int s, g, v, p;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n    cout << v - p - cost[--s][--g] - cost[g][s] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<math.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int INF = pow(10, 8);\nint main(){\n  int n, m;cin>>n>>m;char z;\n  vector<vector<int> > dis(n, vector<int>(n, INF));\n  for(int i=0;i<m;i++){\n    int a, b, c, d;cin>>a>>z>>b>>z>>c>>z>>d;\n    a--;b--;\n    dis[a][b]=c;dis[b][a]=d;\n  }\n  for(int i=0;i<n;i++)dis[i][i]=0;\n  int s, g, v, p;cin>>s>>z>>g>>z>>v>>z>>p;s--;g--;\n  int ans=v-p;\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);\n      }\n    }\n  }\n  ans -= dis[s][g]+dis[g][s];\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint start,fin,mon,cos;\n\nint solve_go(){\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  }\n  return cost[fin];\n}\n\nint solve_ret(){\n  fill(come,come+MAX_C,0);\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[fin]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[start];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n){\n    init();\n    for(int i = n+1; i < MAX_C; i++) come[i] = 1;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve_go() - solve_ret() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n,m; scanf(\"%d%d\", &n, &m);\n  static int wf[50][50];\n  for(int i = 0; i < n; i++) fill(wf[i],wf[i]+n,1000000000);\n  for(int i = 0; i < m; i++) {\n    int a,b,c,d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d); a--; b--;\n    wf[a][b] = c;\n    wf[b][a] = d;\n  }\n  int s,g,pr0,pr1; scanf(\"%d,%d,%d,%d\", &s, &g, &pr0, &pr1); s--; g--;\n  for(int k = 0; k < n; k++) {\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        wf[i][j] = min(wf[i][j], wf[i][k]+wf[k][j]);\n      }\n    }\n  }\n  printf(\"%d\\n\", pr0-pr1-wf[s][g]-wf[g][s]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, m;\n\nint G[30][30];\nint main() {\n\n    for(int i=0; i<30; ++i) for(int j=0; j<30; ++j) G[i][j]=1e9;\n    cin >> n >> m;\n    for(int i=0; i<m; ++i){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--;\n        G[a][b] = c;\n        G[b][a] = d;\n    }\n    int s,g,V,P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    for(int k=0; k<n; ++k){\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                G[i][j] = min(G[i][j], G[i][k]+ G[k][j]);\n            }\n        }\n    }\n\n    s--;\n    g--;\n    cout << V - P - (G[s][g] + G[g][s]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint mp[20][20];\nint bfs(int n,int s,int g){\n  vector<int> dis(n);\n  queue<int> q;\n  rep(i,n)dis[i]=INF;\n  dis[s]=0;\n  q.push(s);\n\n  int u;\n\n  while(!q.empty()){\n    u=q.front(),q.pop();\n    rep(i,n){\n      if(dis[i]>dis[u]+mp[u][i]){\n        dis[i]=dis[u]+mp[u][i];\n        q.push(i);\n      }\n    }\n  }\n    return dis[g];\n}\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  char x;\n  rep(i,n)rep(j,n)mp[i][j]=INF;\n  rep(i,m){\n    int a,b,c,d;\n    cin>>a>>x>>b>>x>>c>>x>>d;\n    a--;b--;\n    mp[a][b]=c;\n    mp[b][a]=d;\n  }\n  int s,g,v,p;\n  cin>>s>>x>>g>>x>>v>>x>>p;\n  s--;g--;\n\n  int sum1=bfs(n,s,g);\n  int sum2=bfs(n,g,s);\n\n  cout<<sum1<<' '<<sum2<<endl;\n  cout<<v-p-sum1-sum2<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define N_MAX 21\n#define M_MAX 400\n \nint  L[N_MAX][N_MAX];\nint  T1[N_MAX], T2[N_MAX];\nbool U1[N_MAX], U2[N_MAX];\nint  s, g;\nint  y, h;\n\nint main( void )\n{\n  int n, m;\n  int a, b, c, d;\n  int A[M_MAX], B[M_MAX], C[M_MAX], D[M_MAX];\n  string line;\n\n  memset( L, -1, sizeof(L) );\n  for ( int i = 0; i < N_MAX; i++ )\n  {\n    for ( int j = 0; j < N_MAX; j++ )\n    {\n      L[i][j] = -1;\n    }\n    T1[i] = T2[i] = 1<<24;\n    U1[i] = U2[i] = false;\n  }\n\n  cin >> n >> m;\n  for ( int i = 0; i < m; i++ )\n  {\n    cin >> line;\n    replace( line.begin(), line.end(), ',', ' ' );\n    istringstream is( line );\n    is >> a >> b >> c >> d;\n    a--;\n    b--;\n    A[i] = a, B[i] = b, C[i] = c, D[i] = d;\n    // cout << a << \", \" << b << \", \" << c << \", \" << d << endl;\n  }\n\n/*\n  cout << \"test1\" << endl;\n  for ( int i = 0; i < n; i++ )\n  {\n    cout << T1[i] << \", \";\n  }\n  cout << endl;\n  for ( int i = 0; i < n; i++ )\n  {\n    cout << T2[i] << \", \";\n  }\n  cout << endl;\n  cout << endl;\n*/\n\n  cin >> line;\n  replace( line.begin(), line.end(), ',', ' ' );\n  istringstream is( line );\n  is >> s >> g >> y >> h;\n  s--;\n  g--;\n  // cout << s << \", \" << g << \", \" << y << \", \" << h << endl;\n  // cout << s << \", \" << g << endl;\n\n  for ( int i = 0; i < m; i++ )\n  {\n    a = A[i], b = B[i], c = C[i], d = D[i];\n    L[a][b] = c, L[b][a] = d;\n  }\n\n  for ( int i = 0; i < n; i++ )\n  {\n    for ( int j = 0; j < n; j++ )\n    {\n      // cout << L[i][j] << \", \";\n    }\n    // cout << endl;\n  }\n  // cout << endl;\n\n  // s -> g\n  // cout << s << endl;\n  int answer = y - h;\n  // cout << answer << endl;\n  U1[s] = true;\n  T1[s] = 0;\n  while ( true )\n  {\n    for ( int i = 0; i < n; i++ )\n    {\n      if ( !U1[i] ) continue;\n      for ( int j = 0; j < n; j++ )\n      {\n        if ( U1[j] ) continue;\n        if ( L[i][j] == -1 ) continue;\n        T1[j] = min( T1[j], T1[i] + L[i][j] );\n      }\n    }\n\n    int mint = 1<<24;\n    int mini = -1;\n    for ( int i = 0; i < n; i++ )\n    {\n      if ( U1[i] ) continue;\n      if ( T1[i] < mint )\n      {\n        mint = T1[i];\n        mini = i;\n      }\n    }\n    U1[mini] = true;\n    // cout << mini + 1 << endl;\n\n    if ( U1[g] ) break;\n    // cout << \"test\" << endl;\n  }\n  answer -= T1[g];\n  // cout << answer << endl;\n\n  // g -> s\n  swap( s, g );\n  U2[s] = true;\n  T2[s] = 0;\n  while ( true )\n  {\n    for ( int i = 0; i < n; i++ )\n    {\n      if ( !U2[i] ) continue;\n      for ( int j = 0; j < n; j++ )\n      {\n        if ( U2[j] ) continue;\n        if ( L[i][j] == -1 ) continue;\n        // cout << i << \" -> \" << j << \", \" << T2[i] << \", \" << L[i][j] << \", \";\n        // cout << T2[j] << \" | \";\n        T2[j] = min( T2[j], T2[i] + L[i][j] );\n        // cout << T2[j] << endl;\n      }\n    }\n\n    int mint = 1<<24;\n    int mini = -1;\n    for ( int i = 0; i < n; i++ )\n    {\n      if ( U2[i] ) continue;\n      if ( T2[i] < mint )\n      {\n        mint = T2[i];\n        mini = i;\n      }\n    }\n    U2[mini] = true;\n    // cout << mini + 1 << endl;\n\n    if ( U2[g] ) break;\n    // cout << \"test\" << endl;\n  }\n  answer -= T2[g];\n  cout << answer << endl;\n\n  // cout << answer << endl;\n/*\n  for ( int i = 0; i < n; i++ )\n  {\n    cout << T1[i] << \", \";\n  }\n  cout << endl;\n  for ( int i = 0; i < n; i++ )\n  {\n    cout << T2[i] << \", \";\n  }\n  cout << endl;\n*/\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int inf = 1001001001;\nint n,m,a,b,c,d,x1,x2,y1,y2;\nint K[32][32];\n\nvoid floyd(){\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                if(K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n}\n\nint main(){\n    for(int i=0;i<32;i++){\n        for(int j=0;j<32;j++){\n            K[i][j] = inf;\n        }\n    }\n    scanf(\"%d%d\", &n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        // cerr << \"read \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    floyd();\n    scanf(\"%d,%d,%d,%d\", &x1,&x2,&y1,&y2);\n    cout << y1 - y2 - K[x1][x2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 30\n\nint N, M, A, B, C, D, x1, x2, t1, y2;\nint K[32][32];\nconst int inf = 100010010;\n\nvoid init()\n{\n\tfor(int y=1; y<=N; ++y)\n\t{\n\t\tfor(int x=1; x<=N; ++x)\n\t\t{\n\t\t\tK[x][y] = inf;\n\t\t}\n\t}\n}\n\nvoid show()\n{\n\tfor(int x=1; x<=N; ++x)\n\t{\n\t\tfor(int y=1; y<=N; ++y)\n\t\t{\n\t\t\tif(K[x][y] == inf){cout << \"inf \";}\n\t\t\telse{printf(\"%3d \",K[x][y]);}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid floyd_warshall()\n{\n\tfor(int k=1; k<=N; ++k)\n\t{\n\t\tfor(int i=1; i<=N; ++i)\n\t\t{\n\t\t\tfor(int j=1; j<=N; ++j)\n\t\t\t{\n\t\t\t\tif(K[i][j] > K[i][k]+K[k][j])\n\t\t\t\t{\n\t\t\t\t\tK[i][j] = K[i][k]+K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\t//cout << N << \" \" << M << endl;\n\t\n\tinit();\n\t\n\tfor(int i=0; i<M; ++i)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\",&A, &B, &C, &D);\n\t\t//cout << \" \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n\t\tK[A][B] = C;\n\t\tK[B][A] = D;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&x1, &x2, &t1, &y2);\n\t//cout << \" \" << x1 << \" \" << x2 << \" \" << t1 << \" \" << y2 << endl;\n\t\n\t//show();\n\tfloyd_warshall();\n\t//show();\n\t\n\tcout << t1 - y2 - K[x1][x2] - K[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 20\n#define M 10000\n\nusing namespace std;\n\nint data[N][N];\n\nvoid Init(){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      if(i == j) data[i][j] = 0;\n      else data[i][j] = M;\n    }\n  }\n}\n\nvoid InputData(int* a, int* b, int* c, int* d){\n  char dm;\n  cin >> *a >> dm >> *b >> dm >> *c >> dm >> *d;\n  --*a;\n  --*b;\n}\n\nvoid WarshallFloyd(int& n){\n  for(int k=0; k<n; ++k){\n    for(int i=0; i<n; ++i){\n      for(int j=0; j<n; ++j){\n\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n      }\n    }\n  }\n}\n\nint main(){\n  int n, m;\n  int a, b, c, d;\n  int x1, x2, y1, y2;\n  char dm;\n\n  Init();\n  cin >> n >> m;\n\n  for(int i=0; i<m; ++i){\n    InputData(&a, &b, &c, &d);\n    data[a][b] = c;\n    data[b][a] = d;\n  }\n\n  WarshallFloyd(n);\n  InputData(&x1, &x2, &y1, &y2);\n\n  cout << (y1 - (y2 + data[x1][x2] + data[x2][x1])) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tgetline(cin, s);\n\tgetline(cin, s);\n\tint t = 3;\n\twhile(getline(cin, s)){\n\t\tint a = -1, b = -1;\n\t\tsscanf(s.c_str(), \"%*d,%*d,%*d,%*d%n %*c%n\", &a, &b);\n\t\tif(a == -1 || b != -1){\n\t\t\tcerr << t << \": \" << s << endl;\n\t\t}\n\t\t++t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Node{\npublic:\n\tint num;\n\tint cost;\n\n\tNode(){ num = 0; cost = 0; }\n\tNode(int num, int cost) : num(num), cost(cost){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.cost < n2.cost;\n}\n\nbool operator>(const Node &n1, const Node &n2){\n\treturn n1.cost > n2.cost;\n}\n\n\nbool checked[21];\n\nint main(void){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<vector<pair<int, int> > > path(n + 1);\n\tfor (int i = 0; i < m; i++){\n\t\tint\ta, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tpath[a].push_back(make_pair(b, c));\n\t\tpath[b].push_back(make_pair(a, d));\n\t}\n\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint result = V - P;\n\n\tfor (int i = 0; i <= 20; i++){\n\t\tchecked[i] = false;\n\t}\n\n\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que1;//cost, point\n\tque1.push(Node(s, 0));\n\n\twhile (!que1.empty()){\n\t\tNode cp = que1.top();\n\t\tque1.pop();\n\n\t\tint cost = cp.cost;\n\t\tint point = cp.num;\n\n\t\tif (checked[point]) continue;\n\t\tchecked[point] = true;\n\n\t\tif (point == g){\n\t\t\tresult -= cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < path[point].size(); i++){\n\t\t\tque1.push(Node(path[point][i].second, cost + path[point][i].first));\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i <= 20; i++){\n\t\tchecked[i] = false;\n\t}\n\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que2;//cost, point\n\tque1.push(Node(g, 0));\n\n\twhile (!que2.empty()){\n\t\tNode cp = que2.top();\n\t\tque2.pop();\n\n\t\tint cost = cp.cost;\n\t\tint point = cp.num;\n\n\t\tif (checked[point]) continue;\n\t\tchecked[point] = true;\n\n\t\tif (point == s){\n\t\t\tresult -= cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < path[point].size(); i++){\n\t\t\tque2.push(Node(path[point][i].second, cost + path[point][i].first));\n\t\t}\n\n\t}\n\n\tcout << result << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define INF 1<<20\n#define MAX_V 20\n\nstruct Edge{ int to, cost; };\n\ntypedef pair<int, int> Pii; // cost, vertex\n\nint V;\nint d[MAX_V];\n\nvector<Edge> G[MAX_V];\n\nint dijkstra(int s, int t) {\n  priority_queue<Pii> Q;\n  fill(d, d+V, INF);\n  d[s] = 0;\n  Q.push(Pii(0, s));\n\n  while(!Q.empty()) {\n    Pii p = Q.top(); Q.pop();\n    int v = p.second;\n    \n    if(d[v] < p.first) continue;\n    \n    for(int i=0; i<G[v].size(); i++) {\n      Edge e = G[v][i];\n      \n      if(d[e.to] > d[v]+e.cost) {\n\td[e.to] = d[v]+e.cost;\n\tQ.push(Pii(d[e.to], e.to));\n      }\n    }\n  }\n\n  return d[t];\n}\n\nint main() {\n  \n  int m;\n  cin >> V >> m;\n  char dd;\n\n  for(int i=0; i<m; i++) {\n    int a, b, c, d;\n    cin >> a >> dd >> b >> dd >> c >> dd >> d;\n    a--, b--;\n    G[a].push_back( (Edge){b, c} );\n    G[b].push_back( (Edge){a, d} );\n  }\n  \n  int x1, x2, y1, y2;\n  cin >> x1 >> dd >> x2 >> dd >> y1 >> dd >> y2;\n  x1--, x2--;\n\n  int ret = y1-y2;\n  ret -= dijkstra(x1, x2);\n  ret -= dijkstra(x2, x1);\n  \n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\t\n\tprintf(\"%d\\n\",v-p-kou);\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define REP(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_E = 500000;\nconst int INF = INT_MAX;\n\nstruct E{\n  int to, cost;\n  E(int t, int c) : to(t), cost(c) {};\n};\ntypedef pair<int, int> pii;\n\nint v;\nvector<E> g[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s)\n{\n  fill(d, d + v, INF);\n  d[s] = 0;\n  priority_queue<pii, vector<pii>, greater<pii> > q;\n  q.push(pii(0, s));\n  \n  while(!q.empty()){\n    pii p = q.top();\n    q.pop();\n    int from = p.second;\n    if(d[from] < p.first) continue;\n    \n    for(int i = 0; i < g[from].size(); ++i){\n      int to = g[from][i].to;\n      int cost = g[from][i].cost;\n      \n      if(d[to] > d[from] + cost){\n        d[to] = d[from] + cost;\n        q.push(pii(d[to], to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  v = n;\n  REP(i, m){\n    int a1, b1, c1, d1;\n    scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n    g[a1 - 1].push_back(E(b1 - 1, c1));\n    g[b1 - 1].push_back(E(a1 - 1, d1));\n  }\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  dijkstra(x1 - 1);\n  int go = d[x2 - 1];\n  dijkstra(x2 - 1);\n  int back = d[x1 - 1];\n  cout << y1 - go - back - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\n\n\nint main(){\n    int n,m;\n    int a[20][20];\n    cin>>n>>m;\n    fill(&a[0][0],&a[20][20],INT_MAX/2);\n    for(int i=0;i<m;i++){\n        int b,c,d,e;\n        cin>>b>>c>>d>>e;\n        a[b][c]=d;\n        a[c][b]=e;\n    }\n    int s,g,gold,p;\n    cin>>s>>g>>gold>>p;\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                if(a[i][t]>a[i][k]+a[k][t]){a[i][t]=a[i][k]+a[k][t];}\n            }\n        }\n    }\n    cout<<gold-p-a[s][g];\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++j)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=1;k<N;k++){\n    for (int i = 1; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j])){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1][x2]-y2 << endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <sstream>\n#include <algorithm>\n\n#define INF 10000000\n\nint n, m, st, gl, money, pole;\nint roads[21][21];\nint in[4];\nstd::string input;\n\nint check( int start, int goal ){\n\tint cost[21];\n\tint used = 0;\n\n\tstd::fill( cost, cost + 21, INF );\n\tcost[start] = 0;\n\n\twhile(1){\n\t\tint v = -1;\n\t\tfor( int i = 1; i <= m; i++ ){\n\t\t\tif( !(used & 1 << i ) && (v == -1 || cost[i] < cost[v]) ) v = i;\n\t\t}\n\n\t\tif( v == -1 )break;\n\n\t\tused = used | 1 << v;\n\n\t\tfor( int i = 1; i <= m; ++i ){\n\t\t\tcost[i] = std::min( cost[i], cost[v] + roads[v][i] );\n\t\t}\n\t}\n\n\treturn cost[goal];\n}\n\nint main(){\n\tfor( int i = 0; i < 21; ++i )\n\t\tstd::fill( roads[i], roads[i] + 21, INF );\n\n\tstd::cin >> n >> m;\n\n\tfor( int i = 0; i < m; ++i ){\n\t\tstd::cin >> input;\n\n\t\tsscanf( input.c_str(), \"%d,%d,%d,%d\", in, &in[1], &in[2], &in[3] );\n\n\t\troads[ in[0] ][ in[1] ] = in[2];\n\t\troads[ in[1] ][ in[0] ] = in[3];\n\t}\n\n\tstd::cin >> input;\n\tsscanf( input.c_str(), \"%d,%d,%d,%d\", &st, &gl, &money, &pole );\n\n\tmoney -= pole;\n\n\tint cost = check( st, gl );\n\tcost += check( gl, st );\n\n\tstd::cout << money - cost << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\nusing namespace std;\nconst double INF=100000000;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int dp[n][n];\n\n  rep(i,n){\n    rep(j,n){\n      dp[i][j]=i==j?0:INF;\n    }\n  }\n  rep(i,m){\n    int a,b,c,d;\n    char e;\n    cin>>a>>e>>b>>e>>c>>e>>d;\n    dp[a-1][b-1]=c;\n    dp[b-1][a-1]=d;\n  }\n  int s,g,V,P;\n  char e;\n  cin>>s>>e>>g>>e>>V>>e>>P;\n\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n      }\n    }\n  }\n  \n  \n  cout<<V-P-dp[s-1][g-1]-dp[g-1][s-1]<<endl;\n  \n  \n  return 0;\n}\n     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <map>\n#define MAX 1000000\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{\n    int to,cost; edge(){}\n    edge(int to,int cost):to(to),cost(cost){}\n};\n\nint st,gl,mone,wood_mone,cnt = 0;\nint n,m,costed[101];\nvector< vector<edge> > info(101);\n\nvoid init(){\n    for(int i=0;i<101;i++) costed[i] = MAX;\n}\n\nvoid add_info(){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    info[a].push_back(edge(b,c));\n    info[b].push_back(edge(a,d));\n}\n\nint Dijkstra(){\n    cnt++;\n    priority_queue<P,vector<P>,greater<P> > que;\n    if(cnt == 1){\n        que.push(P(0,st));\n        costed[st] = 0;\n    }\n    else if(cnt == 2){\n        que.push(P(0,gl));\n        costed[gl] = 0;\n    }\n    while(!que.empty()){\n        P p = que.top(); que.pop();\n        int now = p.second,c = p.first;\n        if(now == st && cnt == 2) return c;\n        else if(now == gl && cnt == 1) return c;\n        for(int i=0;i<info[now].size();i++){\n            edge e = info[now][i];\n            if(e.cost + c < costed[e.to]){\n                que.push(P(e.cost + c,e.to));\n                costed[e.to] = e.cost + c;\n            }\n        }\n    }\n}\n\nint main(){\n    init();\n    cin >> n >> m;\n    for(int i=0;i<m;i++) add_info();\n    scanf(\"%d,%d,%d,%d\",&st,&gl,&mone,&wood_mone);\n    int d = Dijkstra() + wood_mone;\n    init();\n    cout << mone - (Dijkstra() + d) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    int start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\nint d[22][22];\nint V;\nint inf=10000000;\n\nvoid warshall_floyd(){\n\tfor(int k=0; k<V; k++){\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\t\n\nint main(){\n\tint n,m;\n\tint a,b,c,e;\n\tchar tmp;\n\t\n\tcin>>n>>m;\n\tV=n;\n\trep(i,n+1){\n\t\trep(j,n+1){\n\t\t\td[i][j]=inf;\n\t\t}\n\t}\n\trep(i,n+1) d[i][i]=0;\n\trep(i,m){\n\t\tcin>>a>>tmp>>b>>tmp>>c>>tmp>>e;\n\t\t//cout<<a<<endl;\n\t\td[a-1][b-1]=c;\n\t\td[b-1][a-1]=e;\n\t}\n\t//cout<<\"hoge\";\n\twarshall_floyd();\n\tcin>>a>>tmp>>b>>tmp>>c>>tmp>>e;\n\tcout<<c-e-d[b-1][a-1]-d[a-1][b-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    int start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\nusing namespace std;\n\nint n;\nint con[21][21];\nint cost[21];\nbool used[21];\n\nint dijkstra(int stt, int end) {\n  int a, b, c, d;\n\n  for (int i=1; i<=n; i++) cost[i] = INT_MAX;\n  for (int i=1; i<=n; i++) used[i] = false;\n\n  cost[stt] = 0;\n  used[stt] = true;\n  a = stt;\n  while (!used[end]) {\n    for (int i=1; i<=n; i++) {\n      if (con[a][i]) {\n        b = cost[a] + con[a][i];\n        if (b < cost[i]) {\n          cost[i] = b;\n        }\n      }\n    }\n    c = INT_MAX;\n    d = 0;\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && cost[i] < c) {\n        c = cost[i];\n        d = i;\n      }\n    }\n    used[d] = true;\n    a = d;\n  }\n\n  return cost[end];\n}\n\nint main() {\n  int m, a, b, c, d;\n  int stt, end, budget, pole, ans;\n\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n\n  for (int i=1; i<=n; i++) {\n    for (int j=1; j<=n; j++) {\n      con[i][j] = 0;\n    }\n  }\n\n  for (int i=0; i<m; i++) {\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    con[a][b] = c;\n    con[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &stt, &end, &budget, &pole);\n\n  ans = budget - dijkstra(stt, end) - dijkstra(end, stt) - pole;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\tcin >> N;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", a, b, c, d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tcin >> s >> t >> p >> q;\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[s] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - q - D[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 100005\n#define MAX_V 100001\n#define INF (1e9 + 1)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint g[20][20];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tg[i][j]=999999999;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tg[a-1][b-1]=c;\n\t\tg[b-1][a-1]=d;\n\t}\n\tint s,G,V,P;\n\tscanf(\"%d%d%d%d\",&s,&G,&V,&P);\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",V-P-g[s-1][G-1]-g[G-1][s-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\n\ntypedef pair<int,int> mypair;\n\n\nint dak(int st, int gl, int n, int m, vector<vector<int> > zct){\n\tvector<int> mct(n+1,1<<30);\n\tvector<bool> use(n+1,false);\n\tmct[st]=0;\n\tpriority_queue<mypair> pq;\n\tpq.push(mypair(0,st));\n\twhile(!pq.empty()){\n\t\tint ct = pq.top().first;\n\t\tint to = pq.top().second;\n\t\tpq.pop();\n\t\tif(use[to]) continue;\n\t\tuse[to]=true;\n\t\t\n\t\trep(i,m){\n\t\t\tif( zct[to][i] > 0  && mct[i] > mct[to]+ zct[to][i]){\n\t\t\t\t\tmct[i] = mct[to] + zct[to][i];\n\t\t\t\tpq.push(mypair(mct[i],i));\n\t\t\t}\n\t\t}\n\t}\n\treturn mct[gl];\n\n}\n\nint main(void){\n\nint n,m;\nint a,b,c,d;\nint x1,x2,y1,y2;\nchar k;\n\tcin >> n >> m;\n\tvector<vector<int> > zct(n+1,vector<int>(n+1,0));\n\trep(i,m){\n\t\tcin >>a >>k >>b >>k >>c >>k >>d;\n\t\tzct[a][b]=c; zct[b][a]=d;\n\t}\n\tcin >>x1 >>k >>x2 >>k >>y1 >>k >>y2;\n\t\n\tint ans = y1 - (y2 +dak(x1,x2,n,m,zct) + dak(x2,x1,n,m,zct));\n\tcout << ans << endl;\n\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\n\nstruct Node{\n  int num;\n\n  vector<int> edge_to;\n  vector<int> edge_cost;\n\n  bool done;\n  int cost;\n};\n\nvector<string> splitAll(string s, string t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0, p));\n    s = s.substr(p + t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\n\nint main(){\n  int n,m;\n  cin>>n;\n\n  vector<Node> graph;\n  graph.reserve(n+1);\n  graph.resize(n+1);\n\n  for(int i=1; i<=n; i++){\n    graph[i].num=(i+1);\n    graph[i].cost=-1;\n    graph[i].done=false;\n  }\n\n  string s;\n\n  cin>>m;\n  getline(cin,s);\n\n  int a,b,c,d;\n  vector<string> vv;\n  vv.reserve(4);\n  vv.resize(4);\n\n  while(m--){\n    getline(cin,s);\n    vv = splitAll(s,\",\");\n\n    a = atoi( vv[0].c_str() );\n    b = atoi( vv[1].c_str() );\n    c = atoi( vv[2].c_str() );\n    d = atoi( vv[3].c_str() );\n\n    //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\n    graph[a].edge_to.push_back(b);\n    graph[a].edge_cost.push_back(c);\n    graph[b].edge_to.push_back(a);\n    graph[b].edge_cost.push_back(d);\n\n  }\n\n  int x1,x2,y1,y2;\n  getline(cin,s);\n  vv = splitAll(s,\",\");\n\n  x1 = atoi( vv[0].c_str() );\n  x2 = atoi( vv[1].c_str() );\n  y1 = atoi( vv[2].c_str() );\n  y2 = atoi( vv[3].c_str() );\n\n  d=-1;\n\n  vector<Node> n1;\n  n1.reserve(n+1);\n  n1.assign(graph.begin(),graph.end());\n\n  n1[x1].cost=0;\n\n  while(1){\n    d=-1;\n\n    for(int i=1;i<=n;i++){\n      if( n1[i].done || n1[i].cost < 0 ) continue;\n      if( d==-1 || n1[i].cost < n1[d].cost ) d=i;\n    }\n\n    if(d==-1) break;\n    n1[d].done=true;\n\n    for(int i=0; i< n1[d].edge_to.size(); i++){\n      int to = n1[d].edge_to[i];\n      int cost = n1[d].cost + n1[d].edge_cost[i];\n      if(n1[to].cost < 0 || cost < n1[to].cost)\n\tn1[to].cost = cost;\n    }\n  }\n\n  graph[x2].cost=0;\n\n  while(1){\n    d=-1;\n\n    for(int i=1;i<=n;i++){\n      if( graph[i].done || graph[i].cost < 0 ) continue;\n      if( d==-1 || graph[i].cost < graph[d].cost ) d=i;\n    }\n\n    if(d==-1) break;\n    graph[d].done=true;\n\n    for(int i=0; i< graph[d].edge_to.size(); i++){\n      int to = graph[d].edge_to[i];\n      int cost = graph[d].cost + graph[d].edge_cost[i];\n      if(graph[to].cost < 0 || cost < graph[to].cost)\n\tgraph[to].cost = cost;\n    }\n  }\n\n  cout<<y1-y2-graph[x1].cost-n1[x2].cost<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\t\n#include <vector>\n#include <climits>\n#include <cstdio>\n\nstruct Edge {\n\tint s;\n\tint t;\n\tint c;\n\tEdge() {}\n\tEdge(int s, int t, int c) : s(s), t(t), c(c) {}\n};\nbool operator < (const Edge& e, const Edge& f) { return e.c < f.c; }\n\n\nint main()\n{\n\tint n, m;\n\tstd::cin >> n >> m;\n\t//std::cout << n << \" \" << m << std::endl;\n\tstd::vector<Edge> edge_list;\n\t\n\tfor (int i=0; i<m; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t//std::cout << a << \" \" << b << \" \" << c << \" \" << d <<std::endl;\n\t\tedge_list.push_back( Edge(a,b,c) );\n\t\tedge_list.push_back( Edge(b,a,d) );\n\t}\n\t\n\tint* distance = new int[n+1];\n\t\n\tint S, G, V, P;\n\tscanf(\"%d,%d,%d,%d\", &S, &G, &V, &P);\n\t\n\tint res = 0;\n\t\n\t//std::cout << S << \" \" << G << std::endl;\n\t\n\tfor (int i=1; i<=n; i++) distance[i] = INT_MAX;\n\tdistance[S] = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<2*m; j++) {\n\t\t\tint s = edge_list[j].s;\n\t\t\tint t = edge_list[j].t;\n\t\t\tint c = edge_list[j].c;\n\t\t\tif (distance[s] < distance[t] - c) distance[t] = distance[s] + c;\n\t\t}\n\t}\n\tres += distance[G];\n\t\n\t//for (int i=1; i<=n; i++) {\n\t//\tstd::cout << i << \" : \" << distance[i] << std::endl;\n\t//}\n\t\n\tfor (int i=1; i<=n; i++) distance[i] = INT_MAX;\n\tdistance[G]  = 0;\n\tfor (int i=0; i<n-1; i++) {\n\t\tfor (int j=0; j<2*m; j++) {\n\t\t\tint s = edge_list[j].s;\n\t\t\tint t = edge_list[j].t;\n\t\t\tint c = edge_list[j].c;\n\t\t\tif (distance[s] < distance[t] - c) distance[t] = distance[s] + c;\n\t\t}\n\t}\n\tres += distance[S];\n\t\n\tstd::cout << V - P - res << std::endl;\n\t\n\tdelete[] distance;\n\t\n\treturn 0;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 21\n#define INF 1000000007\n#define min(a,b) (a>b?b:a)\n\nint mat[N][N];\n\nint main() {\n\tint n, m, a, b, c, d, x1, x2, y1, y2;\n\tchar du;\n\tcin >> n >> m;\n\tfor(int i=0; i<n; ++i) for(int j=0; j<n; ++j) mat[i][j] = INF;\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> a >> du >> b  >> du >> c >> du >> d; --a; --b;\n\t\tmat[a][b] = c;\n\t\tmat[b][a] = d;\n\t}\n\tcin >> x1 >> du >> x2  >> du >> y1  >> du >> y2; --x1; --x2;\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tmat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << y1 - y2 - mat[x1][x2] - mat[x2][x1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nclass Dijkstra {\npublic:\n    static const int inf = 1<<29;\n    int m_num;\n    vector<vector<int> > m;\n    void init(int n){\n        m_num = n;\n        m.resize(n);\n        REP(i,n){\n            m[i] = vector<int>(n,inf);\n            m[i][i] = 0;\n        }\n    }\n    void add(int u, int v, int e){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num || u == v);\n        m[u][v] = e;\n    }\n    int solve(int u, int v, vector<int> *result = NULL){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num);\n        int n = m_num;\n        vector<int> c(n, -1);\n        vector<int> r(n, -1);\n        priority_queue<pair<int,pair<int,int> > > q;\n        c[u] = 0;\n        while(result != NULL || u != v){\n            REP(i,n){\n                if(u == i || m[u][i] == inf || c[i] >= 0) continue;\n                q.push(mp(-(c[u]+m[u][i]),mp(u,i)));\n            }\n            if(q.empty()) break;\n            int v = q.top().second.first;\n            u = q.top().second.second;\n            if(c[u] < 0){ c[u] = -q.top().first; r[u] = v; }\n            q.pop();\n        }\n        if(result){\n            result[0] = c; result[1] = r;\n            return 0;\n        }\n        return c[v];\n    }\n};\n\nint main(){\n    int n, m;\n    string s;\n    cin >> n >> m;\n    Dijkstra di;\n    di.init(n);\n    REP(i,m){\n        cin >> s;\n        int a,b,c,d;\n        sscanf(s.c_str(), \"%d,%d,%d,%d\", &a, &b, &c, &d);\n        di.add(a-1,b-1,c);\n        di.add(b-1,a-1,d);\n    }\n    cin >> s;\n    int fr,to,m1,m2;\n    sscanf(s.c_str(), \"%d,%d,%d,%d\", &fr, &to, &m1, &m2);\n    cout << m1 - (di.solve(fr-1,to-1) + di.solve(to-1,fr-1) + m2) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 25;\nconst int INF = 1 << 25;\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint dijkstra(int s, int g) {\n  fill(d, d + V, INF);\n  fill(used, used + V, false);\n  d[s] = 0;\n\n  while(true) {\n    int v = -1;\n    for(int u = 0; u < V; u++) {\n      if(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n\n    for(int u = 0; u < V; u++) {\n      d[u] = min(d[u], d[v] + cost[v][u]);\n    }\n  }\n\n  return d[g];\n}\n\nint main() {\n  int m;\n  cin >> V >> m;\n\n  for(int i = 0; i < MAX_V; i++) {\n    for(int j = 0; j < MAX_V; j++) {\n      cost[i][j] = INF;\n    }\n  }\n\n  for(int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  cout << y1-(dijkstra(x1, x2) + dijkstra(x2, x1) + y2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define INF (1LL << 60)\nusing namespace std;\nbool used[200000]; long long dist[200000];\nvoid dijkstra(int V, int E, int s, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[s] = 0; Q.push(make_pair(0, s));\n\tint cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt > E) return; // NEGATIVE_CYCLE\n\t\tpair<long long, int> p = Q.top(); used[p.second] = true; Q.pop();\n\t\tfor (int i = 0; i < X[p.second].size(); i++) {\n\t\t\tint to = X[p.second][i].first; long long leng = X[p.second][i].second;\n\t\t\tif (dist[to] > dist[p.second] + leng && !used[to]) {\n\t\t\t\tdist[to] = dist[p.second] + leng;\n\t\t\t\tQ.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\nint V, E, a, b, c, d, f1, f2, g1, g2; vector<pair<int, long long> > G[200000];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG[a - 1].push_back(make_pair(b - 1, c));\n\t\tG[b - 1].push_back(make_pair(a - 1, c));\n\t}\n\tscanf(\"%d,%d,%d,%d\", &f1, &f2, &g1, &g2); g1 -= g2;\n\tdijkstra(V, E, f1 - 1, G); g1 -= dist[f2 - 1];\n\tdijkstra(V, E, f2 - 1, G); g1 -= dist[f1 - 1];\n\tprintf(\"%d\\n\", g1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint INF = 1 << 11;\nint main()\n{\n\tint map[21][21];\n\tint n, m,a,b,c,d;\n\tint x, y, xx, yy;\n\tchar s;\n\tcin >> n;\n\tcin >> m;\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int i2 = 0; i2 <= n; i2++){\n\t\t\tmap[i][i2] = INF;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> a >> s >> b >> s >> c >> s >> d;\n\t\tmap[a][b] = c;\n\t\tmap[b][a] = d;\n\t}\n\tfor (int k = 1; k <= n; k++){\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tfor (int i2 = 1; i2 <= n; i2++){\n\t\t\t\tmap[i][i2] = min(map[i][i2],map[i][k] + map[i2][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x >> s >> y >> s >> xx >> s >> yy;\n\tint ans = xx - (yy + map[x][y] + map[y][x]);\n\tcout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n#define MAX_N 20\n\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > open;\nmap<int, int> closed;\n\nint search(int start, int goal);\nvoid resetDx();\n\nint n, maxCost, dx[MAX_N][MAX_N][2];\nvoid set(int now, int next, int nowCost, int plusCost);\n\nint main(){\n    resetDx();\n    int m, x1, x2, y1, y2;\n    cin >>n >>m;\n    for(int i = 0; i < m; i++){\n        int a1, b1, c1, d1;\n        scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n        dx[a1][b1][0] = c1;\n        dx[a1][b1][1] = d1;\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    int cost = 0;\n    maxCost = y1 - y2;\n    open.push( make_pair(x1, 0) );\n    cost += search(x1, x2);\n    closed.clear();\n    open.push( make_pair(x2, 0) );\n    cost += search(x2, x1);\n    cout <<maxCost - cost <<endl;\n}\n\nvoid resetDx(){\n    for(int i = 0; i < MAX_N; i++){\n        for(int j = 0; j < MAX_N; j++){\n            dx[i][j][0] = -1;\n            dx[i][j][1] = -1;\n        }\n    }\n}\n\nint search(int start, int goal){\n    while(!open.empty()){\n        int now = open.top().first;\n        int cost = open.top().second;\n        open.pop();\n        for(int i = 1; i <= n; i++){\n            if(dx[now][i][0] != -1) set(now, i, cost, dx[now][i][0]);\n            if(dx[i][now][1] != -1) set(now, i, cost, dx[i][now][1]);\n        }\n    }\n    return closed[goal];\n}\n\n\nvoid set(int now, int next, int nowCost, int plusCost){\n    int sum = nowCost + plusCost;\n    \n    if((closed.find(next) == closed.end() || closed[next] > sum) && sum <= maxCost){\n        open.push( make_pair(next, sum));\n        closed[next] = sum;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,m;\nint t[22][22];\n\nint main(void){\n\tmemset(t,-1,sizeof(t));\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tchar ch;\n\t\tint a,b,c,d;\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\ta--;\n\t\tb--;\n\t\tt[a][b] = c;\n\t\tt[b][a] = d;\n\t}\n\tchar ch;\n\tint s,d,x,y;\n\tcin>>s>>ch>>d>>ch>>x>>ch>>y;\n\ts--;\n\td--;\n\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i == j || t[i][k] == -1 || t[k][j] == -1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(t[i][j] == -1 || t[i][j] > t[i][k] + t[k][j]){\n\t\t\t\t\tt[i][j] = t[i][k] + t[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<x - y - t[s][d] - t[d][s]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tEACH(i,dat){\n\t\tif((*i).depart==s){\n\t\t\tq.push((*i).arrival);\n\t\t\tcost.at((*i).arrival)=(*i).cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tEACH(i,dat){\n\t\t\tif((*i).depart==pos){\n\t\t\t\tif(cost.at((*i).arrival)==INF){\n\t\t\t\t\tq.push((*i).arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at((*i).arrival)>(*i).cost+cost.at(pos)){\n\t\t\t\t\tcost.at((*i).arrival)=(*i).cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(I,m+2){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "def show(m,a,b,c,d,x):\n    for i in xrange(m):\n        x[a[i]-1][b[i]-1] = c[i]\n        x[b[i]-1][a[i]-1] = d[i]\n    return x\n\ndef fw(n,x):\n    for r in xrange(n):\n        for p in xrange(n):\n            for q in xrange(n):\n                if x[p][q] > x[p][r] + x[r][q]:\n                    x[p][q] = x[p][r] + x[r][q]\n    return x\n\nn = int(input())\nm = int(input())\na = []\nb = []\nc = []\nd = []\nfor i in xrange(m):\n    e,f,g,h = map(int,raw_input().split(','))\n    a.append(e)\n    b.append(f)\n    c.append(g)\n    d.append(h)\nx1,x2,y1,y2 = map(int,raw_input().split(','))\n\nk = [[1000000000 for x in xrange(n)] for x in xrange(n)]\nfor i in xrange(n):\n    for j in xrange(n):\n        k[i][j] = inf\nk = show(m,a,b,c,d,k)\nk = fw(n,k)\n\nans1 = k[x1-1][x2-1]\nans2 = k[x2-1][x1-1]\n\nprint int(y1-ans1-y2-ans2)"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint n,m;\nint pass[30][30];\n\nint dijk(int s,int g){\n    int d[30];\n    bool used[30];\n    rep(i,30)d[i]=999999999;\n    rep(i,30)used[i]=false;\n    d[s]=0;\n    \n    while(1){\n        int v=-1;\n        rep(u,n){\n            if( !used[u] && (v==-1||d[u]<d[v]) )v=u;\n        }\n        if(v==-1)break;\n        \n        used[v]=true;\n        \n        rep(u,n){\n            d[u]=min(d[u],d[v]+pass[v][u]);\n        }\n        \n    }\n    return d[g];\n}\n\n\n\nint main(){\n    rep(i,30)rep(j,30)pass[i][j]=999999999;\n    cin>>n>>m;\n    char ch;\n    rep(i,m){\n        int a,b,c,d;\n        cin>>a>>ch>>b>>ch>>c>>ch>>d;\n        a--,b--;\n        pass[a][b] = c;\n        pass[b][a] = d;\n    }\n    int s,g,y1,y2;\n    cin>>s>>ch>>g>>ch>>y1>>ch>>y2;\n    s--,g--;\n\n    \n    int x,y;\n    x=dijk(s,g);\n    y=dijk(g,s);\n    \n    cout<<y1-y2-x-y<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define EPS 1e-10\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\n\nbool isLeap(int y);\nll gcd(ll a, ll b);\nll lcm(ll a, ll b);\ndouble distanceAB(double xa, double ya, double xb, double yb);\nvoid trace(int A[], int N);\n\n/*\nclass Target\n{\npublic:\n\tvector <string> draw(int n)\n\t{\n\n\t}\n};\n*/\n\n\nint acc[1024][1001];\n\n\nint main()\n{\n\tint n, m;\n\twhile (~scanf(\"%d%d\", &n, &m))\n\t{\n\t\tint road[n][n];\n\t\trep(i, n) rep(j, n) road[i][j] = INF;\n\t\trep(i, m)\n\t\t{\n\t\t\tint a, b, c, d;\n\t\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\troad[a - 1][b - 1] = c;\n\t\t\troad[b - 1][a - 1] = d;\n\t\t}\n\t\tint x1, x2, y1, y2;\n\t\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\trep(k, n) rep(i, n) rep(j, n)\n\t\t{\n\t\t\troad[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n\t\t}\n\t\tcout << y1 - y2 - road[x1 - 1][x2 - 1] - road[x2 - 1][x1 - 1] << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\nbool isLeap(int y)\n{\n\treturn y % 400 == 0\n\t\t\t\t\t\t? true : y % 100 == 0\n\t\t\t\t\t\t? false : y % 4 == 0\n\t\t\t\t\t\t? true : false;\n}\n\nll gcd(ll a, ll b)\n{\n\treturn (b > 0) ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nvoid trace(int A[], int N)\n{\n\tREP(N)\n\t{\n\t\tif (i > 0) cout << \" \";\n\t\tcout << A[i];\n\t}\n\tcout << endl;\n}\n\ndouble distanceAB(double xa, double ya, double xb, double yb)\n{\n\treturn sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef struct edge{\n  edge(int a, int b):to(a),cost(b){};\n  int to, cost;\n}edge;\ntypedef struct state{\n  state(int a, int b):v(a),cost(b){};\n  int v, cost;\n  bool operator<(const state s)const{return cost < s.cost;}\n  bool operator>(const state s)const{return cost > s.cost;}\n}state;\n\nint dijkstra(vector<vector<edge> > &g, int start, int goal){\n  priority_queue<state, vector<state>, greater<state> > que;\n  que.push(state(start, 0));\n  vector<int> ans(g.size(), 1e9);\n  ans[start] = 0;\n  while(not que.empty()){\n    int v = que.top().v;\n    int c = que.top().cost;\n    que.pop();\n    if(ans[v] < c)continue;\n    if(v == goal)break;\n    for (int i = 0; i < g[v].size(); i++) {\n      int nv = g[v][i].to;\n      if(ans[nv] > c + g[v][i].cost){\n        ans[nv] = c + g[v][i].cost;\n        que.push(state(nv, ans[nv]));\n      }\n    }\n  }\n  return ans[goal];\n}\n\nint main(){\n  int n, m;\n  std::cin >> n >> m;\n  vector<vector<edge> > g(n);\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--, b--;\n    g[a].push_back(edge(b, c));\n    g[b].push_back(edge(a, d));\n  }\n  int start, goal, v, p;\n  scanf(\"%d,%d,%d,%d\", &start, &goal, &v, &p);\n  start--, goal--;\n  std::cout << v - p - (dijkstra(g, start, goal) + dijkstra(g, goal, start)) << std::endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0117 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117)\n#include<cstdio>\n#include<algorithm>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_N = 20, INF = std::numeric_limits<int>::max()>>4;\n\nint n, m;\nint d[MAX_N][MAX_N];\nint x1, x2, Y1, y2;\n\nint main()\n{\n\tscanf( \"%d%d\", &n, &m );\n\n\trep( i, n ) rep( j, n )\n\t\td[i][j] = i==j?0:INF;\n\n\trep( i, m )\n\t{\n\t\tint a, b, c, di;\n\t\tscanf( \"%d,%d,%d,%d\", &a, &b, &c, &di );\n\t\t--a; --b;\n\t\td[a][b] = c;\n\t\td[b][a] = di;\n\t}\n\n\trep( k, n ) rep( i, n ) rep( j, n )\n\t\td[i][j] = std::min( d[i][j], d[i][k]+d[k][j] );\n\n\tscanf( \"%d,%d,%d,%d\", &x1, &x2, &Y1, &y2 );\n\t--x1; --x2;\n\n\tprintf( \"%d\\n\", Y1-d[x1][x2]-d[x2][x1]-y2 );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < 25; i++){\n\t\tfor (int  j = 0; j<25; j++){\n\t\t\tw[i][j] = 10000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tfor (int h = 0; h < N; h++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << w[x1][x2] - y1 - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1001001;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin>>a>>cc>>b>>cc>>c>>cc>>d;\n            }\n        }\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n_town, n_road;\nvector<vector<int>> costs;\n\nvoid fw(vector<vector<int>> &conn_mat)\n{\n\tcosts = vector<vector<int>>(n_town, vector<int>(n_town, -1));\n\tint i(0), j(0);\n\tfor (auto dep : conn_mat)\n\t{\n\t\tj = 0;\n\t\tfor (int cost : dep)\n\t\t{\n\t\t\tif (cost != -1)\n\t\t\t{\n\t\t\t\tcosts[i][j] = cost;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\tfor (int k = 0; k < n_town; k++)\n\t{\n\t\tfor (int i = 0; i < n_town; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n_town; j++)\n\t\t\t{\n\t\t\t\tif (costs[i][k] != -1 && costs[k][j] != -1) {\n\t\t\t\t\tif ((costs[i][j] > costs[i][k] + costs[k][j] && costs[i][j] != -1) || (costs[i][j] == -1))\n\t\t\t\t\t\tcosts[i][j] = costs[i][k] + costs[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tchar tmp;\n\tcin >> n_town >> n_road;\n\tvector<vector<int>> conn_mat(n_town, vector<int>(n_town, -1));\n\twhile (n_road--)\n\t{\n\t\tint dep, dest, cost_go, cost_back;\n\t\tcin >> dep >> tmp >> dest >> tmp >> cost_go >> tmp >> cost_back;\n\t\tconn_mat[dep - 1][dest - 1] = cost_go;\n\t\tconn_mat[dest - 1][dep - 1] = cost_back;\n\t}\n\tfw(conn_mat);\n\tint dep, dest, budget, cost;\n\tcin >> dep >> tmp >> dest >> tmp >> budget >> tmp >> cost;\n\tcout << budget - cost - costs[dep - 1][dest - 1] - costs[dest - 1][dep - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 200000000\n\nint n,m;\nint a,b,c,d;\nint s,g,V,P;\n\nint mat[21][21];\n\nint main(){\n\t//init\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tmat[i][j] = INF;\n\t\t\tif(i == j)\n\t\t\t\tmat[i][j] = 0;\n\t\t}\n\t}\n\t//input\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1; i <= m; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tmat[a][b] = c;\n\t\tmat[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\t//update mat\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tint r = mat[i][k] + mat[k][j];\n\t\t\t\tmat[i][j] = mat[i][j] > r ? r : mat[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t//output\n\tprintf(\"%d\\n\", V - P - mat[s][g] - mat[g][s]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define INF (1<<29)\n\nint m;\nint graph[101][101];\n\nvoid wa(){\n\n  for(int i=1;i<=m;i++){\n    for(int j=1;j<=m;j++){\n      for(int k=1;k<=m;k++){\n\tgraph[j][k] = min(graph[j][k],graph[j][i]+graph[i][k]);\n      }\n    }\n  }\n  \n}\n\nint main(){\n  int n,a,b,c,d,k;\n  \n  scanf(\"%d %d\",&m,&n);\n    \n  fill_n(*graph,101*101,INF);\n  for(int i=1;i<=m;i++) graph[i][i]=0;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    graph[a][b]=c;\n    graph[b][a]=d;\n  }\n  \n  wa();\n  \n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  printf(\"%d\\n\",c-d-graph[a][b]-graph[b][a]);\n\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nstruct Edge {\n    int src,dst,cost;\n};\ntypedef vector<vector<Edge> > Graph;\n\n// Shortest Path Faster Algorithm\n// O(E)\nvoid spfa(const Graph &g,int s,vector<int> &dist) {\n    const int n = g.size();\n    vector<bool> inQ(n, false);\n    queue<int> q;\n\n    q.push(s); fill(dist.begin(), dist.end(), INF);\n    dist[s] = 0; inQ[s] = true;\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        inQ[v] = false;\n\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i].dst, d = g[v][i].cost;\n            if(dist[v] + d < dist[u]) {\n                dist[u] = dist[v] + d;\n                if(!inQ[u]) {\n                    q.push(u);\n                    inQ[u] = true;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n,m,a,b,c,s,t,d1,d2,d;\n    scanf(\" %d %d\", &n, &m);\n    Graph g(n);\n    vector<int> dist(n);\n\n    for(int i=0; i<m; ++i) {\n        scanf(\" %d,%d,%d,%d\", &a, &b, &c, &d);\n        a--,b--;\n        g[a].push_back((Edge){a,b,c});\n        g[b].push_back((Edge){b,a,d});\n    }\n    scanf(\" %d,%d,%d,%d\", &s, &t, &d1, &d2);\n    s--,t--;\n\n    spfa(g,s,dist);\n    int ans = d1-d2-dist[t];\n    spfa(g,t,dist);\n    ans -= dist[s];\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\n#define INF (1e+9)\n\n#define MAX_N 20\n\nusing namespace std;\n\nint cost[MAX_N + 1][MAX_N + 1];\n\nint N,M;\n\n\nvoid init(){\n\tfor(int i = 0;i <= MAX_N;i++){\n\t\tfor(int j = 0;j <= MAX_N;j++){\n\t\t\tif(i == j) cost[i][j] = 0;\n\t\t\telse cost[i][j] = INF;\n\t\t}\n\t}\n\treturn ;\n}\n\nvoid solve(){\n\tfor(int k = 1;k <= N;k++){\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\tfor(int j = 1;j <= N;j++){\n\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ;\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&N,&M);\n\tint _u,_v;\n\tint _cost0;\n\tint _cost1;\n\tfor(int i = 0;i < M;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&_u,&_v,&_cost0,&_cost1);\n\t\tcost[_u][_v] = _cost0;\n\t\tcost[_v][_u] = _cost1;\n\t}\n\t\n\tsolve();\n\n\tint rest,price;\n\tscanf(\"%d,%d,%d,%d\",&_u,&_v,&rest,&price);\n\tint ans = rest - price - cost[_u][_v] - cost[_v][_u];\n\tprintf(\"%d\\n\",ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 1001001001;\n\nint main(){\n  for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\n\ntypedef pair<int,int> mypair;\n\n\nint dak(int st, int gl, int n, int m, vector<vector<int> > zct){\n\tvector<int> mct(n+1,1<<22);\n\tvector<bool> use(n+1,false);\n\tmct[st]=0;\n\tpriority_queue<mypair, vector<mypair>, greater<mypair> > pq;\n\tpq.push(mypair(0,st));\n\twhile(!pq.empty()){\n\t\tint ct = pq.top().first;\n\t\tint to = pq.top().second;\n\t\tpq.pop();\n\t\tif(use[to]) continue;\n\t\tuse[to]=true;\n\t\t\n\t\trep(i,m){\n\t\t\tif( mct[i] > mct[to]+ zct[to][i]){\n\t\t\t\t\tmct[i] = mct[to] + zct[to][i];\n\t\t\t\tpq.push(mypair(mct[i],i));\n\t\t\t}\n\t\t}\n\t}\n\treturn mct[gl];\n\n}\n\nint main(void){\n\nint n,m;\nint a,b,c,d;\nint x1,x2,y1,y2;\nchar k;\n\tcin >> n >> m;\n\tvector<vector<int> > zct(n+1,vector<int>(n+1,1<<20));\n\trep(i,m){\n\t\tcin >>a >>k >>b >>k >>c >>k >>d;\n\t\ta--;  b--;\n\t\tzct[a][b]=c; zct[b][a]=d;\n\t}\n\tcin >>x1 >>k >>x2 >>k >>y1 >>k >>y2;\n\tx1--; x2--;\n\tint ans = y1 - (y2 +dak(x1,x2,n,m,zct) + dak(x2,x1,n,m,zct));\n\tcout << ans << endl;\n\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n,m;\n  int a,b,c,d;\n  int st,go;\n  int hi,yo;\n  int road[1111][1111];\n  cin >> n >> m;\n  for(int i=0;i<n;i++){//ありえない大きさの数を入れておく\n    for(int j=0;j<n;j++){\n      road[i][j]=8478;\n    }\n  }\n  for(int i=0;i<m;i++){//エッジそれぞれにとりあえずの値を置換\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    road[a-1][b-1]=c;\n    road[b-1][a-1]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&st,&go,&yo,&hi);\n  for(int i=0;i<n;i++){//ワーシャルフロイド開始\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\troad[j][k]=min(road[j][k],road[j][i]+road[i][k]);\n      }\n    }\n  }\n  cout << yo-(hi+road[st-1][go-1]+road[go-1][st-1]) << endl;//road１つ目は往路、２つ目は復路\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<30);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    if(minPos == -1) break;\n    come[minPos] = 1;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    int start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>2){\n                co[now][i]--;\n                return 0;\n            }\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint n,m,t[21][21],u[21],v[21],a,b,c,d;\nint cost(int start,int goal){\n\tint mini,miniNo;\n\tfor(int i=0;i<21;i++){\n\t\tu[i]=INF;\n\t\tv[i]=0;\n\t}\n\tu[start]=0;\n\twhile(1){\n\t\tmini=INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(v[i]==0&&u[i]<mini){\n\t\t\t\tminiNo=i;\n\t\t\t\tmini=u[i];\n\t\t\t}\n\t\t}\n\t\tif(mini==INF)break;\n\t\tv[miniNo]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(u[i]>u[miniNo]+t[miniNo][i]){\n\t\t\t\tu[i]=u[miniNo]+t[miniNo][i];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn u[goal];\n}\nint main(){\n\tfor(int i=0;i<21;i++)for(int j=0;j<21;j++)t[i][j]=INF;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\tt[a][b]=c;t[b][a]=d;\n\t}\n\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\tcout<<c-d-cost(a,b)-cost(b,a)<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=10000000;\nint map[21][21];\n\nint main(void){\n\tint a,b,c;\n\tint d[4];\n\tint ans;\n\tint n,m;\n\tfor(a=0;a<=20;a++){\n\t\tfor(b=0;b<=20;b++){\n\t\t\tmap[b][a]=INF;\n\t\t\tif(b==a)map[b][a]=0;\n\t\t}\n\t}\n\tcin >> n;\n\tcin >> m;\n\tfor(a=0;a<m;a++){\n\t\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\t\tmap[d[0]][d[1]]=d[2];\n\t\tmap[d[1]][d[0]]=d[3];\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tfor(c=1;c<=n;c++){\n\t\t\t\tmap[a][b]=min(map[a][b],map[a][c]+map[c][b]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\tans=d[2]-d[3]-map[d[0]][d[1]]-map[d[1]][d[0]];\n\tcout << ans <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct road{\n\tint to;\n\tint cost;\n};\n\nint main() {\n\tint n, m;\n\tchar gomi;\n\tcin >> n >> m;\n\tvector < vector<road>> vvr(n+1);\n\tREP(i,m){\n\t\tint a, b, c, d;\n\t\tcin >> a >> gomi >> b >> gomi >> c >> gomi >> d;\n\t\tvvr[a].push_back({ b, c });\n\t\tvvr[b].push_back({ a, d });\n\t}\n\tint start, goal, money,hashira;\n\tcin >> start >> gomi >> goal >> gomi >> money >> gomi >> hashira;\n\tvector<int> cost1(n + 1);\n\tvector<int> cost2(n + 1);\n\tvector<bool> cb1(n + 1);\n\tvector<bool> cb2(n+1);\n\tREP(i, n + 1){\n\t\tcost1[i] = 1 << 30;\n\t\tcost2[i] = 1 << 30;\n\t\tif (i){\n\t\t\tcb1[i]=false;\n\t\t\tcb2[i] = false;\n\t\t}\n\t\telse{\n\t\t\tcb1[i] = true;\n\t\t\tcb2[i] = true;\n\t\t}\n\t}\n\tcost1[start] = 0;\n\tcost2[goal] = 0;\n\twhile (1){\n\t\tint min = 1 << 30;\n\t\tint town;\n\t\tREP(i,cost1.size()){\n\t\t\tif (!cb1[i])\n\t\t\t\tif (min > cost1[i]){\n\t\t\t\t\tmin = cost1[i];\n\t\t\t\t\ttown = i;\n\t\t\t\t}\n\t\t}\n\n\t\tcb1[town] = true;\n\t\tif (town == goal)break;\n\t\tREP(i,vvr[town].size()){\n\t\t\tcost1[vvr[town][i].to] = cost1[town] + vvr[town][i].cost;\n\t\t}\n\t}\n\twhile (1){\n\t\tint min = 1 << 30;\n\t\tint town;\n\t\tREP(i, cost2.size()){\n\t\t\tif (!cb2[i])\n\t\t\t\tif (min > cost2[i]){\n\t\t\t\t\tmin = cost2[i];\n\t\t\t\t\ttown = i;\n\t\t\t\t}\n\t\t}\n\t\tcb2[town] = true;\n\t\tif (town == start)break;\n\t\tREP(i, vvr[town].size()){\n\t\t\tif (cost2[vvr[town][i].to] > cost2[town] + vvr[town][i].cost)\n\t\t\tcost2[vvr[town][i].to] = cost2[town] + vvr[town][i].cost;\n\t\t}\n\t}\n\tcout <<money-hashira-cost1[goal]-cost2[start] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX 21\n#define INF 9999999\n\nint main(){\n    int mm[MAX][MAX],n,m,a,b,c,d,x1,x2,y1,y2;\n    \n    cin >> n >> m;\n    for(int i = 1 ; i <= n ; i++)\n        for(int j = 1 ; j <= n ; j++)\n            mm[i][j] = INF;\n    \n    while(m--){\n        scanf(\"%d,%d,%d,%d\" ,&a ,&b , &c ,&d);\n        mm[a][b] = c;\n        mm[b][a] = d;\n    }\n    \n    for(int k = 1 ; k <= n ; k++)\n        for(int i = 1 ; i <= n ; i++)\n            for(int j = 1 ; j <= n ; j++)\n                mm[i][j] = min(mm[i][j],mm[i][k]+mm[k][j]);\n    \n    scanf(\"%d,%d,%d,%d\" ,&x1 ,&x2 ,&y1 ,&y2);\n    cout << y1 - y2 - mm[x1][x2] - mm[x2][x1] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n//#include <algorthm>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\nconst int MAX  = 1<<28;\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<vector<int> > map1(n,vector<int>(n,MAX));\n  //vector<vector<int> > map2(n,vector<int>(n,MAX));\n  for(int i = 0;i < m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    // cout << a << \" \"<<  b << \" \"<< c << \" \"<<  d << \" \" << endl;\n    map1[a-1][b-1] = c;\n    map1[b-1][a-1] = d;\n  }\n  //  cout << \"bababa\" << endl;\n  int x1,x2,y1,y2;\n  //  cin >> x1 >> x2 >> y1 >> y2;  \n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  for(int l = 0;l < n;l++){\n    for(int i = 0;i < n;i++){\n      for(int j = 0;j < n;j++){\n\t\n\tif(map1[i][j] > map1[i][l] + map1[l][j]){\n\t  map1[i][j] = map1[i][l] + map1[l][j];\n\t}\n      }\n    }\n  }\n  cout << y1 - (y2 + map1[x1-1][x2-1] + map1[x2-1][x1-1])  << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\ninline int toInt(string s){int v;istringstream i(s);i>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream o;o<<x;return o.str();}\ntemplate<class T> void pv(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\nint D[21][21];\n\nint main() {\n\tint N; cin >> N;\n\tint M; cin >> M;\n\tint start, goal;\n\tint y1, y2;\n\trep(i,N) rep(j,N) {\n\t\tD[i][j] = INF / 10;\n\t\tD[j][i] = INF / 10;\n\t}\n\tcin.ignore();\n\trep(i,M) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\t\tistringstream is(line);\n\t\tfor(int a, b, c, d; is >> a >> b >> c >> d;) {\n\t\t\ta--, b--;\n\t\t\tD[a][b] = c;\n\t\t\tD[b][a] = d;\n\t\t}\n\t}\n\t\n\n\tstring line;\n\tgetline(cin, line);\n\trep(j,line.size()) if(line[j] == ',') line[j] = ' ';\n\tistringstream is(line);\n\t\n\tis >> start >> goal >> y1 >> y2;\n\tstart--, goal--;\n\trep(k,N) rep(i,N) rep(j,N) D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n#if 0\n\tdebug(D[start][goal]);\n\tdebug(D[goal][start]);\n#endif\n\tcout << y1 - (y2 + D[start][goal] + D[goal][start]) << endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int a[20][20],m,n,o,p,q,r;\n  cin>>n>>m;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      a[i][j]=200000000;\n  for(i=0;i<m;i++){\n    int t,u,v,w;\n    scanf(\"%d,%d,%d,%d\",&t,&u,&v,&w);\n    t--;\n    u--;\n    a[t][u]=v;\n    a[u][t]=w;\n  }\n  scanf(\"%d,%d,%d,%d\",&o,&p,&q,&r);\n  o--;\n  p--;\n  for(k=0;k<n;k++)\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\ta[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n  cout<<q-r-a[o][p]-a[p][o]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[20][20];\n\tint n,m,a,b,c,d;\n\tcin >> n >> m;\n\t\n\trep(i,n)rep(j,n)wf[i][j]=(1<<21);\n\t\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\ta--;b--;\n\t\n\trep(k,n)rep(i,n)rep(j,n)wf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\n\tcout << c-d-wf[a][b]-wf[b][a] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define INF 1000000000\nusing namespace std;\n\nint d[20];\nint cost[20][20];\nbool done[20];\n\nint N, M, x1, x2, y1, y2;\n\nvoid dj(int s)\n{\n  fill(d, d + 20, INF);\n  fill(done, done + 20, 0);\n  d[s] = 0;\n  while(1)\n  {\n    int v = -1;\n    for(int i = 0; i < N; i++)\n      if(!done[i] && (v == -1 || d[i] < d[v]))\n          v = i;\n    if(v == -1)\n      break;\n    done[v] = 1;\n    for(int i = 0; i < N; i++)\n      d[i] = min(d[i], d[v] + cost[v][i]);\n  }\n}\n\nint main()\n{\n  fill((int*)cost, (int*)cost + 400, 100);\n  cin >> N >> M;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--; b--;\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  x1--; x2--;\n\n  int ans = y1 - y2;\n  dj(x1);\n  ans -= d[x2];\n  dj(x2);\n  ans -= d[x1];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\nconst int inf = 1000000000;\n\n/*\nvoid show(vector<vector<int> > &array){\n\tfor(int i = 0; i < array.size(); i++){\n\t\tfor(int j = 0; j < array[i].size(); j++) {\n\t\t\tcout << array[i][j] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n*/\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > cost(n + 1, vector<int>(n + 1, inf));\n\tint town_a, town_b, from_a_to_b, from_b_to_a;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &town_a, &town_b, &from_a_to_b, &from_b_to_a);\n\t\tcost[town_a][town_b] = from_a_to_b;\n\t\tcost[town_b][town_a] = from_b_to_a;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tfor(int k = 1; k <= n; k++)\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(cost[i][j] > cost[i][k] + cost[k][j])\n\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\tcout << y1 - cost[x1][x2] - cost[x2][x1] - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 9876543210;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nint n, m, start, goal, money, pole;\nint roads[21][21];\nint in[4];\nstd::string input;\n\nint check( int pos, int hbt, unsigned int c ){\n\tif( pos == goal ) return c;\n\n\tunsigned int cost = -1;\n\n\tfor( int i = 1; i <= m; ++i ){\n\t\tif( roads[pos][i] != -1 && !(hbt & 1 << i) ){\n\t\t\tcost = std::min( cost, (unsigned int)check( i, hbt|1<<i, c + roads[pos][i] ) );\n\t\t}\n\t}\n\n\treturn cost;\n}\n\nint main(){\n\tmemset( roads, -1, sizeof( roads ) );\n\n\tstd::cin >> n >> m;\n\n\tfor( int i = 0; i < m; ++i ){\n\t\tstd::cin >> input;\n\n\t\tsscanf( input.c_str(), \"%d,%d,%d,%d\", in, &in[1], &in[2], &in[3] );\n\n\t\troads[ in[0] ][ in[1] ] = in[2];\n\t\troads[ in[1] ][ in[0] ] = in[3];\n\t}\n\n\tstd::cin >> input;\n\tsscanf( input.c_str(), \"%d,%d,%d,%d\", &start, &goal, &money, &pole );\n\n\tmoney -= pole;\n\n\tint cost = check( start, 0, 0 );\n\tstd::swap( start, goal );\n\tcost += check( start, 0, 0 );\n\n\tstd::cout << money - cost << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 20\n#define INF (1<<29)\n\nint main()\n{\n    int N, M;\n    while (cin >> N) {\n        cin >> M;\n        int d[MAX_N][MAX_N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        int a, b, c1, c2;\n        for (int i = 0; i < M; i++) {\n            scanf(\"%d,%d,%d,%d\", &a, &b, &c1, &c2);\n            a--; b--;\n            d[a][b] = c1;\n            d[b][a] = c2;\n        }\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c1, &c2);\n        a--; b--;\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        cout << c1 - c2 - d[a][b] - d[b][a] << endl;\n    }           \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++j)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=0;k<N;k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j])){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1-1][x2-1]-y2-K[x2-1][x1-1]<< endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <utility>\n#include <stdio.h>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint cost[111][111];\nint dics(int st,int go);\nint main(){\n  int st,go,yo,ha;//左からスタート、ゴール、予算、柱代金\n  int a,b,c,d;//a,b=つないでる街 c=aからbのコスト　d=bからaのコスト\n  int iki,kaeri;\n  int ans=0;\n  cin >> n >> m;\n  for(int i=0;i<21;i++){\n    for(int j=0;j<21;j++){\n      cost[i][j]=999999;\n    }\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost[a][b]=c;//aからbへのコスト\n    cost[b][a]=d;//bからaへのコスト\n  }\n  scanf(\"%d,%d,%d,%d\",&st,&go,&yo,&ha);\n  iki=dics(st,go);\n  kaeri=dics(go,st);\n  ans=iki+kaeri;\n  cout << yo-ha-ans << endl;//予算から柱代金と運賃を引いた褒美\n}\n\nint dics(int st,int go){//運賃図りますよー\n  int d[1111];//エッジのコスト格納用\n  queue<pair<int,int> > q;\n  pair<int,int> p;\n  for(int i=0;i<21;i++){//めっちゃ多い数を\n    d[i]=999999;\n  }\n  d[st]=0;//スタート地点はコスト0確定だから\n  q.push( make_pair(0, st) );\n  while(!q.empty()){//見るところが無くなりすべての値が確定するまで\n    p=q.front();\n    q.pop();\n    for(int i=1;i<=n;i++){//各街は1?nで表されるから\n      if(cost[p.S][i]!=999999){//通れたら\n\tif(d[i]>p.F+cost[p.S][i]){//現在のそのエッジまでの最小値よりも小さかったら\n\t  d[i]=cost[p.S][i]+p.F;\n\t q.push( make_pair(d[i], i) );//そこまでのコストと今いる場所\n\t}\n      }\n    }\n  }\n  return d[go];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top(); pq.pop();\n\t\tint t = tmp.second;\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t\tpq.emplace(d[E[t][i].first], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tcout << c - d - djk(a, b) - djk(b, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21],minnum[21];\nint serch(int start,int finish,int money,int go,int now)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=minnum[now];i<=maxnum[now];i++){\n        if(place[now][i]>-1&&co[now][i]<2){\n            co[now][i]++;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=1;i<21;i++)minnum[i]=22;\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[1]],num[0]);\n\t    minnum[num[0]]=min(minnum[num[0]],num[1]);\n\t    minnum[num[1]]=min(minnum[num[1]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct State{\n    int num,cost;\n    bool operator < (const State &obj)const{\n        if(cost != obj.cost) return cost > obj.cost;\n        return false;\n    }\n};\nint mini[21];\n\nint main(){\n    int n,m;\n    scanf(\"%d\",&n);\n    vector<State> costs[n+1];\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;++i){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        costs[a].push_back((State){b,c});\n        costs[b].push_back((State){a,d});\n    }\n    int s,g,v,p;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n    int wayToG, wayToS;\n    for(int j=0;j<2;++j){\n        for(int i=0;i<=n;++i)mini[i]=INT_MAX;\n        priority_queue<State> Q;\n        if(j==0){\n            mini[s] = 0;\n            Q.push((State){s,0});\n        }\n        else{\n            mini[g] = 0;\n            Q.push((State){g,0});\n        }\n        while(!Q.empty()){\n            State now = Q.top();\n            Q.pop();\n            int oldNum = now.num, oldCost = now.cost;\n            if(j == 0 && oldNum == g){\n                wayToG = oldCost;\n                break;\n            }\n            else if(j == 1 && oldNum == s){\n                wayToS = oldCost;\n                break;\n            }\n            for(int i=0;i<costs[oldNum].size();++i){\n                int newNum = costs[oldNum][i].num;\n                int newCost = oldCost + costs[oldNum][i].cost;\n                if(newCost < mini[newNum]){\n                    mini[newNum] = newCost;\n                    Q.push((State){newNum,newCost});\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",v-(p+wayToS+wayToG));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i,n)    for(int i=0;i<n;i++)\n#define rep1(i,n)   for(int i=1;i<=n;i++)\n#define INF         ( 1<<20 )\n\nusing namespace std;\n\nint costs[21][21];\n\nint main()\n{\n\tint N,M;\n\tcin>>N>>M;\n\n\trep1(i,N)rep1(j,N)costs[i][j] = INF;\n\trep1(i,N)costs[i][i] = 0;\n\n\tchar comma;\n\tint a, b, c, d;\n\trep(i,M)\n\t{\n\t\tcin>>a>>comma>>b>>comma>>c>>comma>>d;\n\t\tcosts[a][b] = c;\n\t\tcosts[b][a] = d;\n\t}\n\n\tint S, G, money, hashira;\n\tcin>>S>>comma>>G>>comma>>money>>comma>>hashira;\n\n\trep1(k,N)rep1(i,N)rep1(j,N)\n\t{\n\t\tcosts[i][j] = min(costs[i][j], costs[i][k] + costs[k][j]);\n\t}\n\tcout << (money - hashira - (costs[S][G] + costs[G][S])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define MAX 100\n#define INT_MAX 100000\nusing namespace std;\n\nint N;\nint M[MAX][MAX];\n\nvoid shortestPath(int src,int d[],int path[]){\n\tbool visited[MAX];//Sツづ可堕ョツつキツづゥツノツーツトツづ衡rue\n\tREP(i,N){\n\t\td[i]=INT_MAX;\n\t\tvisited[i]=false;\n\t}\n\t\n\td[src]=0;\n\tpath[src]=-1;\n\n\twhile(1){\n\t\tint u;\n\t\tint mincost=INT_MAX;\n\t\tREP(i,N){\n\t\t\tif(!visited[i] && d[i]<mincost){\n\t\t\t\tmincost=d[i];\n\t\t\t\tu=i;\n\t\t\t}\n\t\t}\n\n\t\tif(mincost==INT_MAX)break;\n\n\t\tvisited[u]=true;\n\t\tREP(v,N){\n\t\t\tif(visited[v]||M[u][v]==INT_MAX)continue;\n\t\t\tif(d[u]+M[u][v] <d[v]){\n\t\t\t\td[v]=d[u]+M[u][v];\n\t\t\t\tpath[v]=u;\n\t\t\t}\n\t\t//REP(i,N)cout<<d[i]<<endl;\n\t\t//cout<<endl;\n\t\t}\n\t}\n}\n\nint main(void){\n\tint m;\n\tcin>>N>>m;\n\tint a1,b1,c1,d1;\n\tREP(i,N)REP(j,N)M[i][j]=INT_MAX;\n\tREP(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n\t\tM[a1][b1]=c1;\n\t\tM[b1][a1]=d1;\n\t/*\t\n\tREP(k,N){\n\t\tREP(j,N){\n\t\t\tcout<<M[k][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\tcout<<endl;\n\t*/\n\t}\n\tint start,end,syozi,hashira;\n\tscanf(\"%d,%d,%d,%d\",&start,&end,&syozi,&hashira);\n\tint d[21],path[21];\n\tshortestPath(start,d,path);\n\tint go,back;\n\tgo=d[end];//ツ行ツつォツつェツつッツづ個コツスツト\n\tshortestPath(end,d,path);\n\tback=d[start];//ツ帰ツづィツつェツつッツづ個コツスツト\n\n\tcout<<syozi-hashira-go-back<<endl;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nstruct Edge\n{\n\tint from, to, cost;\n\n\tEdge( const int f, const int t, const int c ) : from( f ), to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n};\n\nint bellmanford1( const int V, const vector< Edge > E, const int s, const int t )\n{\n\tvector<int> dist( V, INF );\n\tdist[s] = 0;\n\n\twhile ( true )\n\t{\n\t\tbool update = false;\n\n\t\tfor ( int i = 0; i < E.size(); i++ )\n\t\t{\n\t\t\tif ( dist[ E[i].from ] != INF && dist[ E[i].from ] + E[i].cost < dist[ E[i].to ] )\n\t\t\t{\n\t\t\t\tdist[ E[i].to ] = dist[ E[i].from ] + E[i].cost;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( !update )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint bellmanford2( const int V, const vector< Edge > E, const int s, const int t )\n{\n\tvector<int> dist( V, INF );\n\tdist[s] = 0;\n\n\tfor ( int i = 1; i < V; i++ )\n\t{\n\t\tfor ( int j = 0; j < E.size(); j++ )\n\t\t{\n\t\t\tdist[ E[j].to ] = min( dist[ E[j].to ], dist[ E[j].from ] + E[j].cost );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< Edge > E;\n\n\tfor ( int i = 0; i < m; i++ )\n\t{\n\t\tint a, b, ab, ba;\n\t\tchar d;\n\n\t\tcin >> a >> d >> b >> d >> ab >> d >> ba;\n\n\t\ta--;\n\t\tb--;\n\n\t\tE.push_back( Edge( a, b, ab ) );\n\t\tE.push_back( Edge( b, a, ba ) );\n\t}\n\n\tint s, t, money, price;\n\tchar d;\n\n\tcin >> s >> d >> t >> d >> money >> d >> price;\n\n\ts--;\n\tt--;\n\n\tcout << money - price - bellmanford1( n, E, s, t ) - bellmanford2( n, E, t, s ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before&&co[now][i]<2){\n            co[now][i]++;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n\n#define dbg if(0)\nusing namespace std;\n#define ll long long\n\nstd::vector<std::string> split(const std::string& input, char delimiter)\n{\n    std::istringstream stream(input);\n\n    std::string field;\n    std::vector<std::string> result;\n    while (std::getline(stream, field, delimiter)) {\n        result.push_back(field);\n    }\n    return result;\n}\n\nint main(){\n    int n,m;\n    int map[20][20];\n    string ans;\n    cin >> n>>m;\n    for(int i=0;i<20;i++){\n        for(int j=0;j<20;j++){\n            map[i][j]=151919;\n        }\n    }\n    for(int i=0;i<m;i++){\n        int a[4];\n        string mojir;\n        cin >> mojir;\n        int l=0;\n        for (const std::string& s : split(mojir, ',')) {\n            dbg std::cout << s << std::endl;\n            a[l]=stoi(s);\n            l++;\n        }\n        map[a[0]-1][a[1]-1]=a[2];\n        map[a[1]-1][a[0]-1]=a[3];\n//        map[a-1][b-1]=c;\n//        map[b-1][a-1]=d;\n    }\n    int s,g,V,P;\n    int a[4];\n    string mojir;\n    cin >> mojir;\n    int l=0;\n    for (const std::string& s : split(mojir, ',')) {\n        dbg std::cout << s << std::endl;\n        a[l]=stoi(s);\n        l++;\n    }\n    s=a[0];\n    g=a[1];\n    V=a[2];\n    P=a[3];\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if (map[i][j]>map[i][k]+map[k][j]){\n                    map[i][j]=map[i][k]+map[k][j];\n                }\n            }\n        }\n    }\n    dbg{\n        for(int i=0;i<20;i++){\n            cout <<\"Debug\"<<i<<endl;;\n            for(int j=0;j<20;j++){\n                cout << map[i][j]<<\" \";\n            }\n            cout <<endl;\n        }\n    }\n\n    cout<<(V-P)-(map[s-1][g-1]+map[g-1][s-1])<<endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\nconst int inf = 1000000000;\n\n/*\nvoid show(vector<vector<int> > &array){\n\tfor(int i = 0; i < array.size(); i++){\n\t\tfor(int j = 0; j < array[i].size(); j++) {\n\t\t\tcout << array[i][j] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n*/\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > cost(n + 1, vector<int>(n + 1, inf));\n\tint town_a, town_b, from_a_to_b, from_b_to_a;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &town_a, &town_b, &from_a_to_b, &from_b_to_a);\n\t\tcost[town_a][town_b] = from_a_to_b;\n\t\tcost[town_b][town_a] = from_b_to_a;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tfor(int k = 1; k <= n; k++)\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(cost[i][j] > cost[i][k] + cost[k][j])\n\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\tcout << y1 - cost[x1][x2] - cost[x2][x1] - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <stdio.h>\n#include<iostream>\n#include <list>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define MAX 101\nstruct node\n{\n\tlist<int> li;\n\tlist<int> cost;\n};\nint  sum = 0, n, m, s, g, ans,flag = 0,min = -1;\nnode x[MAX];\nvoid sai(int N, int a,int f) {\n\tif (N < m) {\n\t\tif (f == a) { //&& flag == 0) {\n\t\t\tif (min == -1 || min > sum) min = sum;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tfor (auto i = x[a].li.begin(), j = x[a].cost.begin(); i != x[a].li.end(); ++i, ++j) {\n\t\t\t\tif (min == -1 || min > sum) {\n\t\t\t\t\tsum += *j;\n\t\t\t\t\tsai(N + 1, *i, f);\n\t\t\t\t\tsum -= *j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint a, b, c, d, V, P;\n\tscanf_s(\"%d\", &n);\n\tscanf_s(\"%d\", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a].li.push_back(b); x[a].cost.push_back(c);\n\t\tx[b].li.push_back(a); x[b].cost.push_back(d);\n\t}\n\tfor (int k = 1; k <= n; ++k) {\n\t\tfor (auto i = x[k].li.begin(), j = x[k].cost.begin(); i != x[k].li.end(); ++i, ++j) {\n\t\t}\n\t}\n\tscanf_s(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tsai(0, s, g);\n\tans += min; min = -1; sum = 0;\n\tsai(0, g, s);\n\tans += min;\n\tans = V - (ans + P);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define inf 1000000000\nusing namespace std;\n\nvoid show(int n, vector<vector<int>> A)\n{\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << A[i][j] << \" \";\n        }\n        cout << endl;\n    } \n}\n\nint main()\n{   \n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> K(30, vector<int>(30));\n    int a, b, c, d;\n    string str;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            K[i][j] = inf;\n        }\n    }\n\n    REP(i, m) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n\n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n\n    cout << V - K[s][g] - K[g][s] - P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n;\n  for(;cin>>n;)\n    {\n      int edge[n][n],m;\n      cin>>m;\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      if(i==j)\n\t\tedge[i][j]=0;\n\t      else\n\t\tedge[i][j]=1000000;\n\t    }\n      for(int i=0;i<m;i++)\n\t{\n\t  char ch;\n\t  int a,b,c,d;\n\t  cin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t  a--;b--;\n\t  edge[a][b]=c;\n\t  edge[b][a]=d;\n\t}\n      for(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      /*   \n      for(int i=0;i<n;i++,cout<<endl)\n\t  for(int j=0;j<n;j++)\n\t    cout<<edge[i][j]<<\" \";\n      */\n      int a,b,c,d;\n      char ch;\n      cin>>a>>ch>>b>>ch>>c>>ch>>d;\n      a--;b--;\n      cout<<c-d-edge[a][b]-edge[b][a]<<endl;\n      \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#define INF 1<<28\nusing namespace std;\n\nstruct edge{\n  int to;\n  int cost; //ちょっと処理を楽にするために\n};\n\ntypedef pair < int, int > P; // < 最短経路, ノードの番号 >\n\nint V;\nvector < edge > G[100]; //入力(iからjはコストG[i][j]でいける)\nint d[100]; //答えを入れる(最小コストを入れる)\n\nint dijkstra(int s){ //スタート地点\n  priority_queue <P, vector<P>, greater<P> > que; //小さい順になるようにqueueに代入\n  \n  fill(d, d+V+1, INF); //全ノードのコストをINFで初期化(d[0]~d[V])\n  d[s] = 0; //スタート地点のコストを0で初期化\n  \n  que.push(P(0, s)); //最短経路(0), 頂点の番号(スタート)\n  \n  while( !que.empty() ){ //queueの中身が空になるまでループ(行ける場所が無くなるまで)\n    \n    P p = que.top(); que.pop(); //最小コストを取得\n    int v = p.second; //最小コストであるノードの番号\n    \n    if(d[v] < p.first) continue; //取り出した最小コストが大きかったらループの最初に戻る\n    \n    for(int i=0;i<G[v].size();i++){ //今居る頂点からつながってる辺の数だけループ\n      edge e = G[v][i]; //i番目のvからいけるノードとそのコストを代入\n      \n      if(d[e.to] > d[v] + e.cost){ //最短経路が見つかった\n\td[e.to] = d[v] + e.cost; //最短経路を更新\n\tque.push( P(d[e.to], e.to) ); //新しい最短経路をqueueにpush\n      }\n    }\n  }\n}\n\nint main(){\n  \n  int m; //エッジ数\n  int a,b,ca,cb; //abでつながっている cost_a cost_b\n  int x1,x2,y1,y2; //スタート、ゴール、所持金、柱の代金\n  \n  cin >> V >> m;\n  \n  edge k;\n  for(;m>0;m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&ca,&cb);\n    \n    k.to = b, k.cost = ca;\n    G[a].push_back( k );\n    \n    k.to = a, k.cost = cb;\n    G[b].push_back( k );\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  \n  //行き\n  dijkstra(x1);\n  y1 -= d[x2];\n  \n  //帰り\n  dijkstra(x2);\n  y1 -= d[x1];\n  \n  //for(int i=1;i<=V;i++) cout << d[i] << endl; //確認\n  \n  cout << y1-y2 << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 100005\n#define MAX_V 100001\n#define INF (1e9 + 1)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint g[20][20];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tg[i][j]=99999999;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tg[a-1][b-1]=c;\n\t\tg[b-1][a-1]=d;\n\t}\n\tint s,G,V,P;\n\tscanf(\"%d%d%d%d\",&s,&G,&V,&P);\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",V-P-g[s-1][G-1]-g[G-1][s-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n\tint city1,city2,cost1to2,cost2to1;\n};\n\n\n\nint main(){\n\tint n=0,m=0,start=0,goal=0,budget=0,treecost=0;\n\tcin>>n>>m;\n\tedge node[m+1];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&node[i].city1,&node[i].city2,&node[i].cost1to2,&node[i].cost2to1);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&budget,&treecost);\n\tint dp[n+1][n+1];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdp[i][j]=1000000000;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdp[node[i].city1][node[i].city2]=node[i].cost1to2;\n\t\tdp[node[i].city2][node[i].city1]=node[i].cost2to1;\n\t}\n\tfor(int l=1;l<=n;l++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<dp[start][goal]<<endl;\n\tcout<<budget-treecost-dp[start][goal]-dp[goal][start]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\n\n\nint main(){\n    int n,m;\n    int a[25][25];\n    cin>>n>>m;\n    for(int i=0;i<25;i++){\n        for(int t=0;t<25;t++){\n            a[i][t]=-1;\n        }\n    }\n    char q;\n    for(int i=0;i<m;i++){\n        int b,c,d,e;\n        cin>>b>>q>>c>>q>>d>>q>>e;\n        a[b][c]=d;\n        a[c][b]=e;\n    }\n    int s,g,gold,p;\n    cin>>s>>q>>g>>q>>gold>>q>>p;\n    bool j=true;\n    int count=0;\n    while(j){\n        j=false;\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int t=1;t<=n;t++){\n                if(a[i][k]==-1 || a[k][t]==-1){continue;}\n                if(a[i][t]==-1){a[i][t]=a[i][k]+a[k][t]; j=true; continue;}\n                if(a[i][t]>a[i][k]+a[k][t]){a[i][t]=a[i][k]+a[k][t]; j=true;}\n            }\n        }\n    }\n        count++;\n    }\n    cout<<gold-p-a[s][g]-a[g][s]<<endl;\n    //cout<<count<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 50000000\nusing namespace std;\n\nint graf[20][20];\nint kyo[20];\nbool use[20];\n\nvoid dijk(int ve, int st) {\n\tfill(kyo, kyo + ve, INF);\n\tfill(use, use + ve, false);\n\tkyo[st - 1] = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int i = 0;i < ve; i++) {\n\t\t\tif (!use[i] && (v == -1 || kyo[i] < kyo[v]))v = i;\n\t\t}\n\t\tif (v == -1)break;\n\t\tuse[v] = true;\n\t\tfor (int i = 0;i < ve;i++) {\n\t\t\tkyo[i] = min(kyo[i], kyo[v] + graf[v][i]);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++)graf[i][j] = INF;\n\t}\n\tfor (int i = 0;i < m;i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tgraf[a - 1][b - 1] = c;\n\t\tgraf[b - 1][a - 1] = d;\n\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint sum = 0;\n\tdijk(n, s - 1);\n\tsum += kyo[g - 1];\n\tdijk(n, g - 1);\n\tsum += kyo[s - 1];\n\tcout << V - P - sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int d[21][21]; rep(i, 21) rep(j, 21) d[i][j] = inf;\n    int N;\n    cin >> N;\n    int m; cin >> m;\n    char ch;\n    rep(i, m) {\n        int a, b, c, dd; cin >> a >> ch >> b >> ch >> c >> ch >> dd;\n        a--; b--;\n        d[a][b] = c;\n        d[b][a] = dd;\n    }\n    rep(k, N) rep(i, N) rep(j, N) {\n        if (d[i][k] + d[k][j] < d[i][j]) d[i][j] = d[i][k] + d[k][j];\n    }\n    int s, g, v, p; cin >> s >> ch >> g >> ch >> v >> ch >> p; s--; g--;\n    cout << v - p - (d[s][g] + d[g][s]) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\nchar c;\nlong n,m,a,b,d,e,f,i,j,k,p[20][20],x1,x2,y1,y2,q[20];\ncin>>n>>m;\nfor(i=0;i<m;i++){\nq[i]=-1;\nfor(j=0;j<n;j++)p[i][j]=-1;\n}\nfor(i=0;i<m;i++){\ncin>>a>>c>>b>>c>>d>>c>>e;\np[a-1][b-1]=d;\np[b-1][a-1]=e;\n}\ncin>>x1>>c>>x2>>c>>y1>>c>>y2;\nq[x1-1]=0;\nfor(k=0;k<n;k++){\nf=0;\nfor(i=0;i<n;i++){\nif(q[i]<0){f=1;continue;}\nfor(j=0;j<n;j++){\nif(p[i][j]<0)continue;\nif(q[j]<0||q[j]>q[i]+p[i][j])q[j]=q[i]+p[i][j];\n}\n}\nif(f==0)break;\n}\ny1-=(q[x2-1]+y2);\nfor(i=0;i<m;i++)q[i]=-1;\nq[x2-1]=0;\nfor(k=0;k<n;k++){\nf=0;\nfor(i=0;i<n;i++){\nif(q[i]<0){f=1;continue;}\nfor(j=0;j<n;j++){\nif(p[i][j]<0)continue;\nif(q[j]<0||q[j]>q[i]+p[i][j])q[j]=q[i]+p[i][j];\n}\n}\nif(f==0)break;\n}\ny1-=q[x1-1];\ncout<<y1<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//↓template↓\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define Would\n#define you\n#define all(n)  n.begin(),n.end()\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst double pi = acos(-1);\nconst int SIZE = 1 << 17;\nint dx[] = { 1,0,-1,0 }, dy[] = { 0,1,0,-1 }, alp[30];\nlong long fac[200005], finv[200005], inv[200005];\nvector<long long>dij;\nstruct edge { long long to, cost; };\nvector<vector<edge> >G;\n\nlong long mod_pow(long long a, long long b) {\n\tlong long res = 1, mul = a;\n\tfor (int i = 0; i < 31; ++i) {\n\t\tif (b >> i & 1) {\n\t\t\tres *= mul;\n\t\t\tres %= MOD;\n\t\t}\n\t\tmul = (mul * mul) % MOD;\n\t}\n\n\treturn res;\n}\n\nvoid addedge(int from, int to, int cost) {\n\tG[from].push_back({ to,cost });\n\tG[to].push_back({ from,cost });\n}\n\n//↑template↑\n\nvoid dijkstra(int n) {\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>que;\n\tfill(all(dij), INF);\n\tdij[n] = 0;\n\tque.push(pair<long long, long long>(0, n));\n\n\twhile (!que.empty()) {\n\t\tpair<long long, long long>p = que.top();\n\t\tque.pop();\n\t\tlong long mon = p.second;\n\t\tif (dij[mon] < p.first) continue;\n\t\tfor (int i = 0; i < G[mon].size(); ++i) {\n\t\t\tedge e = G[mon][i];\n\t\t\tif (dij[e.to] > dij[mon] + e.cost) {\n\t\t\t\tdij[e.to] = dij[mon] + e.cost;\n\t\t\t\tque.push(pair<long long, long long>(dij[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tdij.resize(n + 1);\n\tG.resize(n + 1);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b, c, d;\n\t\tchar yu, ru, sann;\n\t\tcin >> a >> yu >> b >> ru >> c >> sann >> d;\n\t\t--a; --b;\n\t\tG[a].push_back({ b,c });\n\t\tG[b].push_back({ a,d });\n\t}\n\tint q, w, e, r, ans;\n\tchar ze, tta, i;\n\tcin >> q >> ze >> w >> tta >> e >> i >> r;\n\t--q; --w;\n\tans = e - r;\n\tdijkstra(q);\n\tans -= dij[w];\n\tdijkstra(w);\n\tcout << ans - dij[q] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint cost[32][32];\t//[i][j]ªi©çjÖÌRXg\nint d[32];\t\t\t//s©çÌÅ¬RXg\nbool used[32];\t\t//gíê½©Ç¤©\nint N;\t\t\t\t//¸_\n\n\nvoid dijkstra(int s){\n\t//ú»\n\tfill(d, d + 32, INF);\n\tfill(used,used+32,false);\n\td[s] = 0;\n\t\n\t\n\twhile(true){\n\t\tint v = -1;\n\t\t//gíêÄ¢È¢àÌÅÅ¬ÌàÌðT·\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(used[i]  == false && (v == -1 || d[i] < d[v]))v = i;\n\t\t}\n\t\tif(v == -1)break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\td[i] = min(d[v]+cost[v][i],d[i]);\n\t\t}\n\t}\n}\t\n\t\nint main(void){\n\twhile(scanf(\"%d\", &N) != EOF){\n//\t\tscanf(\"%d\", &N);\n\t\tint m;\n\t\tint a1,b1,c1,d1;\n\t\tint start,goal,money,price;\n\t\tint go,back;\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\t\n\t\t//ú»\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int j = 0; j <= N; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n\t\t\tcost[a1][b1] = c1;\n\t\t\tcost[b1][a1] = d1;\n\t\t}\n\t\t\n\t\tscanf(\"%d,%d,%d,%d\", &start, &goal, &money, &price);\n\t\t\n\t\t\n\t\tdijkstra(start);\n\t\tgo = d[goal];\n\t\t\n\t\tdijkstra(goal);\n\t\tback = d[start];\n\t\t\n\t\tprintf(\"%d\\n\",money-price-go-back);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*****include*****/\n#include <iostream>\n#include <fstream>\n\n/*****デバッグ定義*****/\n//#define DEBUG\n#define INF 10000\n/*****マクロ定義*****/\n\n/*****名前空間*****/\nusing namespace std;\n\n/*****グローバル変数置き場*****/\nint Field[20][20];\n\n/*****その他関数置き場*****/\nint djikstra(int start,int goal,int townnum){\n\tint *dis;\n\tbool *used;\n\tint town;\n\tdis = new int [townnum];\n\tused = new bool [townnum];\n\tfor(int i=0;i<townnum;i++){\n\t\tdis[i] = INF;\n\t\tused[i] = false;\n\t}\n\tdis[start] = 0;\n\twhile(true){\n\t\ttown = -1;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(!used[i] && (town == -1 || dis[town] > dis[i])){\n\t\t\t\ttown = i;\n\t\t\t}\n\t\t}\n\t\tif(town == -1)\tbreak;\n\t\tused[town] = true;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(dis[i] > dis[town] + Field[town][i]){\n\t\t\t\tdis[i] = dis[town] + Field[town][i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<townnum;i++)\tcout << dis[i] << \" \";\n\tcout << endl;*/\n\tdelete used;\n\tdelete dis;\n\treturn dis[goal];\n}\n/*****main関数*****/\nint main(){\n\t/*****ファイルオープン*****/\n#ifdef DEBUG\n\tofstream fout(\"output.txt\");\n\tifstream fin(\"input.txt\");\n\tif(!fout || !fin){\n\t\tcout << \"Can't open the file.\\n\";\n\t\treturn;\n\t}\n#endif\n\t/*****変数置き場*****/\n\tint townnum;\n\tint rootnum;\n\tint ts,tg,value,price;\n\tint cost=0;\n\tint t1,t2,c1,c2;\n\t/*****処理部*****/\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tField[i][j] = INF;\n\t\t}\n\t}\n\tcin >> townnum >> rootnum;\n\tfor(int i=0;i<rootnum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&t1,&t2,&c1,&c2);\n\t\t//cin >> t1 >> ',' >> t2 >> ',' >> c1 >> ',' >> c2;\n\t\tField[t1-1][t2-1] = c1;Field[t2-1][t1-1] = c2;\n\t\tField[t1-1][t1-1] = 0;Field[t2-1][t2-1] = 0;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&ts,&tg,&value,&price);\n\t//cout << ts << \" \" << tg << \" \" << townnum <<endl;\n\tcost = 0;\n\tcost += djikstra(ts-1,tg-1,townnum);\n\t//cout << cost << endl;\n\tcost += djikstra(tg-1,ts-1,townnum);\n\t//cout << cost << endl;\n\tcout << (value - price - cost) << endl;\n\t/*****処理終了後*****/\n#ifdef DEBUG\n\tfout.close();\n\tfin.close();\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nconst int inf=1000000000;\nint K[32][32];\n\nint main(){\n\tfor(int i=0;i<32;i++){\n\t\tfor(int j=0;j<32;j++){\n\t\t\tif(i==j){\n\t\t\t\tK[i][j]=0;\n\t\t\t}else{\n\t\t\t\tK[i][j]=inf;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\t\tK[A][B]=C;\n\t\tK[B][A]=D;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tfor(int k=1;k<N+1;k++){\n\t\tfor(int i=1;i<N+1;i++){\n\t\t\tfor(int j=1;j<N+1;j++){\n\t\t\t\tint temp=K[i][k]+K[k][j];\n\t\t\t\tif(K[i][j]>temp){\n\t\t\t\t\tK[i][j]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << y1-K[x1][x2]-K[x2][x1]-y2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\n\nint mini(int s,int t){\n  if(s>t){\n    return t;\n  }\n  return s;\n}\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; i < 32; ++j)\n    {\n      K[i][j]=1001001001;\n    }\n  }\n\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M;++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B]=C;\n    K[B][A]=D;\n    // cerr << \"read \" <<A<<\" \" << B << \" \" << C <<\" \"<< D <<endl;\n  }\n  for (int i = 1; i < N+1 ; ++i)\n  {\n    for (int j = 0; j < N+1; ++j)\n    {\n      for(int k=0;k<N+1;++k)\n      {\n        K[j][k]=mini(K[j][i]+K[i][k],K[j][k]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  cerr << y2-y1-K[x1][x2]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nbool input(){\n  char t;\n  int n;\n  if(!(cin>>n))return false;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  init(),input();\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 25;\nconst int INF = 1 << 25;\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint dijkstra(int s, int g) {\n  fill(d, d + V, INF);\n  fill(used, used + V, false);\n  d[s] = 0;\n\n  while(true) {\n    int v = -1;\n    for(int u = 0; u < V; u++) {\n      if(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n\n    for(int u = 0; u < V; u++) {\n      d[u] = min(d[u], d[v] + cost[v][u]);\n    }\n  }\n\n  return d[g];\n}\n\nint main() {\n  int m;\n  cin >> V >> m;\n\n  for(int i = 0; i < V; i++) {\n    for(int j = 0; j < V; j++) {\n      cost[i][j] = INF;\n    }\n  }\n\n  for(int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--, b--;\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  x1--, x2--;\n  cout << y1-(dijkstra(x1, x2) + dijkstra(x2, x1) + y2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include\"bits/stdc++.h\"\n#ifdef _DEBUG\n#define DBG(n) n\n#else\n#define DBG(n)\n#endif\n#define INF         1e9\n#define INFLL       1e18\n#define EPS         1e-9\n#define REP(i,n)    for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)   for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)   for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)  for(ll i=(n);i>0;--i)\n#define REPC(i,obj) for(auto i:obj)\n#define ALL(obj)    (obj).begin(),(obj).end()\n#define SETP(n)     cout<<fixed<<setprecision(n)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T ret; cin >> ret; return ret; }\n\nvector<ll>Dijkstra(const vector<vector<pair<ll, ll>>>&edge, ll start = 0)\n{\n\tvector<ll>dist(edge.size(), INFLL); dist[start] = 0;\n\tpriority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> node_queue;\n\tnode_queue.push(make_pair(0, start));\n\twhile (!node_queue.empty()) {\n\t\tll tpn_cost = node_queue.top().first, tpn_index = node_queue.top().second; node_queue.pop();\n\t\tfor (auto i : edge[tpn_index]) {\n\t\t\tll dst_cost = i.first, dst_index = i.second;\n\t\t\tif (dist[dst_index] > tpn_cost + dst_cost) {\n\t\t\t\tdist[dst_index] = tpn_cost + dst_cost;\n\t\t\t\tnode_queue.push(make_pair(dist[dst_index], dst_index));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nsigned main()\n{\n\tll n = in(), m = in();\n\tvector<vector<pair<ll, ll>>>edge(n);\n\tREP(i, m) {\n\t\tll a, b, c, d;\n\t\tscanf(\"%lld,%lld,%lld,%lld\", &a, &b, &c, &d);\n\t\t--a, --b;\n\t\tedge[a].push_back(make_pair(c, b));\n\t\tedge[b].push_back(make_pair(d, a));\n\t}\n\tll s, g, v, p;\n\tscanf(\"%lld,%lld,%lld,%lld\", &s, &g, &v, &p);\n\t--s, --g;\n\tauto dist1(move(Dijkstra(edge, s))), dist2(move(Dijkstra(edge, g)));\n\tcout << v - dist1[g] - p - dist2[s] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 20\n#define INF 1e9\nusing namespace std;\n\nint dp[MAX_N][MAX_N];\nint n,m;\n\nvoid warshall_froyd(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n    }\n  }\n}\n\nint main(){\n  cin >> n; \n  cin >> m;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dp[i][j] = (i==j ? 0 : INF);\n      dp[i][j] = (i==j ? 0 : INF);\n    }\n  }\n  \n  for(int i=0;i<m;i++){\n    int a,b,atob,btoa;\n    cin >> a >> b >> atob >> btoa;\n    a--; b--;\n    dp[a][b] = atob; dp[b][a] = btoa;\n  }\n\n  warshall_froyd();\n\n  int start,goal,reward,price;\n  cin >> start >> goal >> reward >> price;\n  cout << reward - dp[start][goal] - price << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\nusing namespace std;\nmain(){\n  int n,m,a,b,c,d;;\n  cin>>n>>m;\n  int di[n][n];\n  r(i,n)r(j,n)di[i][j]=(i==j)?0:INF;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    di[a][b]=c;\n    di[b][a]=d;\n  }\n  r(k,n)r(i,n)r(j,n)di[i][j]=min(di[i][j],di[i][k]+di[k][j]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--;b--;\n  cout<<c-d-di[a][b]-di[b][a]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£????????????\n#endif\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf=1001001001;\nint pay;\n\nint main(){\n\t//??????Inf??§???????????????????????????\n\tfor(int i=0;i<32;i++)\n\t\tfor(int j=0;j<32;j++)\n\t\t\tK[i][j]=inf;\n\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0;i<M;++i){\n\t\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\t\t//cerr<<\"read \"<<A<<' '<<B<<' '<<C<<' '<<D<<endl;\n\t\tK[A][B]=C;\n\t\tK[B][A]=D;\n\n\t\tfor(int i=1;i<N+1;i++){//?????§?????????\n    for(int j=1;j<N+1;j++){\n      if(K[i][j]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[i][j]<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n\n\tfor(int k=1;k<N+1;k++)\n\t\tfor(int i=1;i<N+1;i++)\n\t\t\tfor(int j=1;j<N+1;j++)\n\t\t\t\tif(K[i][j]>K[i][k]+K[k][j])\n\t\t\t\t\tK[i][j]=K[i][k]+K[k][j];\n\n\t for(int l=1;l<N+1;l++){//?????§??????2???\n    for(int m=1;m<N+1;m++){\n      if(K[l][m]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[l][m]<<\" \";\n      }\n    }\n    cout<<endl;\n    } \n    cout<<endl;\n\n\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\tpay=K[A][B]+K[B][A];\n\tcout<<C-D-pay<<endl; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nconst int INF=10000000;\nint map[21][21];\n \nint main(void){\n    int a,b,c;\n    int d[4];\n    int ans;\n    int n,m;\n    for(a=0;a<=20;a++){\n        for(b=0;b<=20;b++){\n            map[b][a]=INF;\n            if(b==a)map[b][a]=0;\n        }\n    }\n    cin >> n;\n    cin >> m;\n    for(a=0;a<m;a++){\n        scanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n        map[d[0]][d[1]]=d[2];\n        map[d[1]][d[0]]=d[3];\n    }\n    for(a=1;a<=n;a++){\n        for(b=1;b<=n;b++){\n            for(c=1;c<=n;c++){\n                map[c][b]=min(map[c][b],map[c][a]+map[a][b]);\n            }\n        }\n    }\n    scanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n    ans=d[2]-d[3]-map[d[0]][d[1]]-map[d[1]][d[0]];\n    cout << ans <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 20\nusing namespace std;\n\nstruct edge { \n  int to, cost;\n  edge(){}\n  edge(int to,int cost):to(to),cost(cost){};\n};\ntypedef pair<int ,int> P;\nconst int INF = 1 << 30;\nint V; //ノードの数\nvector<edge> Graph[MAX_V];\nint min_cost[MAX_V];\n\nvoid Dijkstra(int s){ // s:スタートからの最小コストをmin_costに設定\n  priority_queue<P,vector< P >, greater<P> > que;\n  fill(min_cost,min_cost + V,INF);\n  min_cost[s] = 0;\n  que.push(P(0,s));\n  \n  while(!que.empty()){\n    P p = que.top();que.pop();\n    int now = p.second;\n    int cost = p.first;\n    if(min_cost[now] < cost) continue;\n    \n    for(int i = 0; i < Graph[now].size(); i++){\n      edge e = Graph[now][i];\n      if(min_cost[e.to] > min_cost[now] + e.cost){\n\tmin_cost[e.to] = min_cost[now] + e.cost;\n\tque.push(P(min_cost[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int m;\n  cin>>V;\n  cin>>m;\n  int ans;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    char ch;\n    cin>>a>>ch>>b>>ch>>c>>ch>>d;\n    a--;b--;\n    Graph[a].push_back(edge(b,c));\n    Graph[b].push_back(edge(a,d));\n  }\n  int s1,s2,money,cst;\n  char ch;\n\n  cin>>s1>>ch>>s2>>ch>>money>>ch>>cst;\n  s1--;s2--;\n  ans = money - cst;\n  \n  Dijkstra(s1);\n  ans -= min_cost[s2];\n  Dijkstra(s2);\n  ans -= min_cost[s1];\n  \n  cout << ans << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_V 20\n\nint d[MAX_V][MAX_V];\nint V;\n\nvoid wf(){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}\n\n\nint main(){\n  int m;\n  cin>>V>>m;\n\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      d[i][j]=100000;\n    }\n    d[i][i]=0;\n  }\n\n  int a,b,c,e;\n  char yomisute;\n  for(int i=0;i<m;i++){\n    cin>>a>>yomisute>>b>>yomisute>>c>>yomisute>>e;\n    --a;--b;\n    d[a][b]=c;\n    d[b][a]=e;\n  }\n  \n  wf();\n\n\n  cin>>a>>yomisute>>b>>yomisute>>c>>yomisute>>e;\n  int money=0;\n\n  a--;b--;\n  money=d[a][b]+d[b][a];\n  cout<<c-e-money<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*****include*****/\n#include <iostream>\n#include <fstream>\n\n/*****デバッグ定義*****/\n//#define DEBUG\n#define INF 10000\n/*****マクロ定義*****/\n\n/*****名前空間*****/\nusing namespace std;\n\n/*****グローバル変数置き場*****/\nint Field[20][20];\n\n/*****その他関数置き場*****/\nint djikstra(int start,int goal,int townnum){\n\tint *dis;\n\tbool *used;\n\tint town;\n\tdis = new int [townnum];\n\tused = new bool [townnum];\n\tfor(int i=0;i<townnum;i++){\n\t\tdis[i] = INF;\n\t\tused[i] = false;\n\t}\n\tdis[start] = 0;\n\twhile(true){\n\t\ttown = -1;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(!used[i] && (town == -1 || dis[town] > dis[i])){\n\t\t\t\ttown = i;\n\t\t\t}\n\t\t}\n\t\tif(town == -1)\tbreak;\n\t\tused[town] = true;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(dis[i] > dis[town] + Field[town][i]){\n\t\t\t\tdis[i] = dis[town] + Field[town][i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<townnum;i++)\tcout << dis[i] << \" \";\n\tcout << endl;\n\tdelete used;\n\tdelete dis;\n\treturn dis[goal];\n}\n/*****main関数*****/\nint main(){\n\t/*****ファイルオープン*****/\n#ifdef DEBUG\n\tofstream fout(\"output.txt\");\n\tifstream fin(\"input.txt\");\n\tif(!fout || !fin){\n\t\tcout << \"Can't open the file.\\n\";\n\t\treturn;\n\t}\n#endif\n\t/*****変数置き場*****/\n\tint townnum;\n\tint rootnum;\n\tint ts,tg,value,price;\n\tint cost=0;\n\tint t1,t2,c1,c2;\n\t/*****処理部*****/\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tField[i][j] = INF;\n\t\t}\n\t}\n\tcin >> townnum >> rootnum;\n\tfor(int i=0;i<rootnum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&t1,&t2,&c1,&c2);\n\t\t//cin >> t1 >> ',' >> t2 >> ',' >> c1 >> ',' >> c2;\n\t\tField[t1-1][t2-1] = c1;Field[t2-1][t1-1] = c2;\n\t\tField[t1-1][t1-1] = 0;Field[t2-1][t2-1] = 0;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&ts,&tg,&value,&price);\n\t//cout << ts << \" \" << tg << \" \" << townnum <<endl;\n\tcost = 0;\n\tcost += djikstra(ts-1,tg-1,townnum);\n\tcout << cost << endl;\n\tcost += djikstra(tg-1,ts-1,townnum);\n\tcout << cost << endl;\n\tcout << (value - price - cost) << endl;\n\t/*****処理終了後*****/\n#ifdef DEBUG\n\tfout.close();\n\tfin.close();\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostrem>\n#include <cstdio>\n\nusing namspace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++i)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=1;k<N;k++){\n    for (int i = 1; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j]){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1][x2]-y2 <<endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mapData[21][21];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tmapData[i][j] = 1001;\n\t\t}\n\t}\n}\n\nvoid solve(int n) {\n\tfor (int k = 1; k < n; k++) {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif (mapData[i][j] > mapData[i][k] + mapData[k][j]) {\n\t\t\t\t\tmapData[i][j] = mapData[i][k] + mapData[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint n, m, u, v, V, P;\n\n\tcin >> n >> m;\n\tinit(n+1);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &u, &v, &V, &P);\n\t\tmapData[u][v] = V;\n\t\tmapData[v][u] = P;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &u, &v, &V, &P);\n\n\tsolve(n+1);\n\tcout << V - P - mapData[u][v] - mapData[v][u] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tconst int nmax = 21;\n\tint route[nmax][nmax];\n\tint n;\n\tint m;\n\tint a, b, c, d;\n\tint x1, x2, y1, y2;\n\tchar ch;\n\tint cost1, cost2;\n\tcin >> n >> m;\n\tfor(int i = 0; i < nmax; i++){\n\t\tfor(int j = 0; j < nmax; j++){\n\t\t\troute[i][j] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\troute[a][b] = c;\n\t\troute[b][a] = d;\n\t}\n\tfor(int i = 1; i < nmax; i++){\n\t\tfor(int j = 1; j < nmax; j++){\n\t\t\tif(route[j][i] != -1)\n\t\t\t\tfor(int k = 1; k < nmax; k++)\n\t\t\t\t\tif(route[i][k] != -1)\n\t\t\t\t\t\tif(route[j][k] == -1 || (route[j][i] + route[i][k] < route[j][k]))\n\t\t\t\t\t\t\troute[j][k] = route[j][i] + route[i][k];\n\t\t}\n\t}\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\tcost1 = route[x1][x2];\n\tcost2 = route[x2][x1];\n\tcout << y1 - y2 - cost1 - cost2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,a,b) for(int i=(a); i<(b); i++)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<vi> vii;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n\n\n\n\nconst int MAX_V = 10000;\n\n\nstruct edge{ int to, cost; };\n\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n\nvoid dijkstra(int s){\n\t//greater<pii>????????????????????¨??§first????°???????????????????????????????????????????\n\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tque.push(pii(0, s));\n\n\twhile(!que.empty()){\n\t\tpii p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(pii(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n, m;\n\tcin>>n>>m;\n\tV = m;\n\tint a[4];\n\tedge tmp;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a[0],&a[1],&a[2],&a[3]);\n\t\t// for(int j=0; j<4; j++){\n\t\t// \tcout<<\" \"<<a[j];\n\t\t// }\n\t\t// cout<<endl;\n\t\ta[0]--;\n\t\ta[1]--;\n\t\ttmp.to = a[1];\n\t\ttmp.cost = a[2];\n\t\tG[a[0]].pb(tmp);\n\t\ttmp.to = a[0];\n\t\ttmp.cost = a[3];\n\t\tG[a[1]].pb(tmp);\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tint ans = y1 - y2;\n\tx1--;\n\tx2--;\n\tdijkstra(x1);\n\tans-=d[x2];\n\t// for(int i = 0; i < n; i++){\n\t// \tcout<<i+1<<\":\"<<d[i]<<endl;\n\t// }\n\tdijkstra(x2);\n\tans-=d[x1];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX>>1\n\nvector< vector<int> > WarshallFloyd(vector< vector<int> >A)\n{\n  for(int k=0;k<A.size();k++)for(int i=0;i<A.size();i++)for(int j=0;j<A.size();j++)\n    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n  return A;\n}\n\nint main()\n{\n  int n,m,a,b,c,d,x1,x2,y1,y2;\n  vector< vector<int> >M;\n  cin>>n>>m;\n  M.resize(n);\n  for(int i=0;i<n;i++)M[i].resize(n,NONE);\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    M[a][b]=c;\n    M[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  x1--;x2--;\n  vector< vector<int> >A=WarshallFloyd(M);\n  cout<<(y1-y2-A[x1][x2]-A[x2][x1])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int INF=100100100;\nusing namespace std;\nint n,m;\nint K[32][32];\n\nint main(){\n\n  scanf(\"%d%d\", &n,&m);\n  \n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      K[i][j]=INF;\n    }\n  }\n  int a,b,c,d;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    K[a][b]=c;\n    K[b][a]=d;\n  }\n  int start,goal,inp,val;\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&inp,&val);\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(K[i][j] > K[i][k]+K[k][j]){\n\t  K[i][j]=K[i][k]+K[k][j];\n\t}\n      }\n    }\n  }\n  int ans=inp-val-K[start][goal]-K[goal][start];\n  printf(\"%d\\n\",ans);\n}\n\n  \n  \n    \n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n\n#define MAX_V 25\n#define INF 1e+8\n\nusing namespace std;\n\nvoid dijkstra(int s);\n\nint goCost[MAX_V][MAX_V],backCost[MAX_V][MAX_V];\t//cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint dist[MAX_V];\t//頂点sからの最短距離\nbool used[MAX_V];\t//既に使われたかどうかのフラグ\nint V;\t//頂点数\nint M;\t//辺の数\n\n\nint main(void){\n\t\n\tcin>>V;\n\tcin>>M;\n\n\tint a,b,c,d,sTown,gTown,reward,pay,ans;\n\t\n\t//ポインタにキャストして渡すと2次元配列が初期化出来る\n\tfill((int *)goCost,(int *)(goCost+MAX_V),(int)INF);    \n\t//fill((int *)backCost,(int *)(backCost+MAX_V),INF);\n\t\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tgoCost[a-1][b-1]=c;\n\t\tgoCost[b-1][a-1]=d;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&sTown,&gTown,&reward,&pay);\n\t\n\n\tdijkstra(sTown-1);\n\ta=dist[gTown-1];\n\tdijkstra(gTown-1);\n\tb=dist[sTown-1];\n\t\n\tans=reward-(a+b+pay);\n\tprintf(\"%d\\n\",ans);\n}\n\nvoid dijkstra(int s){\n\tfill(dist,dist+V,(int)INF);\n\tfill(used,used+V,false);\n\tdist[s]=0;\n\n\twhile(true){\n\t\tint v=-1;\n\t\t\n\t\t//まだ使われていない頂点のうち距離が最小のものを探す\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(used[u]==false && (v==-1 || dist[u]<dist[v])){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\n\t\tused[v]=true;\n\n\t\tfor(int u=0;u<V;u++){\n\t\t\tdist[u]=min(dist[u],dist[v]+goCost[v][u]);\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nconst int inf = 1<<29;\nint edge[22][22];\n\nint main(){\n    int i,j,k,n,m,a,b,c,d,start,end,money,hasira;\n\n    rep(i,22) rep(j,22) edge[i][j] = inf;\n    rep(i,22) edge[i][i] = 0;\n\n    cin >> n;\n    cin >> m;\n    rep(i,m){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--, b--;\n        edge[a][b] = c;\n        edge[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\",&start,&end,&money,&hasira);\n\n    // worshall\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n            }\n        }\n    }\n\n    printf(\"%d\\n\",money - hasira - (edge[start-1][end-1] + edge[end-1][start-1]));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 50000000\nusing namespace std;\n\nint graf[20][20];\nint kyo[20];\nbool use[20];\n\nvoid dijk(int ve, int st) {\n\tfill(kyo, kyo + ve, INF);\n\tfill(use, use + ve, false);\n\tkyo[st - 1] = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int i = 0;i < ve; i++) {\n\t\t\tif (!use[i] && (v == -1 || kyo[i] < kyo[v]))v = i;\n\t\t}\n\t\tif (v == -1)break;\n\t\tuse[v] = true;\n\t\tfor (int i = 0;i < ve;i++) {\n\t\t\tkyo[i] = min(kyo[i], kyo[v] + graf[v][i]]);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++)graf[i][j] = INF;\n\t}\n\tfor (int i = 0;i < m;i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tgraf[a - 1][b - 1] = c;\n\t\tgraf[b - 1][a - 1] = d;\n\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint m = 0;\n\tdijk(n, s - 1);\n\tm += kyo[g - 1];\n\tdijk(n, g - 1);\n\tm += kyo[s - 1];\n\tcout << V - P - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\n\nint mini(int s,int t){\n  if(s>t){\n    return t;\n  }\n  return s\n}\n\nint main(){\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M;++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B]=C;\n    K[B][A]=D;\n    // cerr << \"read \" <<A<<\" \" << B << \" \" << C <<\" \"<< D <<endl;\n  }\n  for (int i = 1; i < N+1 ; ++i)\n  {\n    for (int j = 0; j < N+1; ++j)\n    {\n      for(int k=0;k<N+1;++k)\n      {\n        K[j][k]=mini(K[j][i]+K[i][k],K[j][k]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  cerr << y2-y1-K[x1][x2]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\n/*\nconst int MAX_E=2*(100-1);\nconst int MAX_V=100;\nconst long long int INF=100000000;\nstruct edge { int from,to,cost;};\nedge es[MAX_E];\n//int d[MAX_V];\nint V,E;\nvoid shortest_path(int s,int e,vector<int>& d);\nint main(){\n\tint n,k;\n\twhile(cin >> n >> k&&n!=0&&k!=0){\n\t\tint V=n;\n\t\tint E=2*(n-1);\n\t\tvector<int> land(V);\n\t\tint l=0;\n\t\tfor(int i=0; i<E; ++i){\n\t\t\tes[i].cost=-1;\n\t\t\tes[i].from=-1;\n\t\t\tes[i].to=-1;\n\t\t}\n\t\tfor(int i=0; i<k; ++k){\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tif(m==0){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tshortest_path(a,b,land);\n\t\t\t\tcout << land[b] << \"\\n\";\n\t\t\t} else if(m==1){\n\t\t\t\tint c,d,e;\n\t\t\t\tcin >> c >> d >> e;\n\t\t\t\tes[l].from=c;\n\t\t\t\tes[l].to=d;\n\t\t\t\tes[l].cost=e;\n\t\t\t\tes[l+1].from=d;\n\t\t\t\tes[l+1].to=c;\n\t\t\t\tes[l+1].cost=e;\n\t\t\t\tl+=2;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n*/\nvoid func(string str,vector<int>& a);\nconst int INF=10000000;\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector< vector<int> > wf(n+1,vector<int>(n+1));\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\twf[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\tif(i==j)wf[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i){\n\t\tstring str;\n\t\tvector<int> abcd(4);\n\t\tcin >> str;\n\t\tfunc(str,abcd);\n\t\twf[abcd[0]][abcd[1]]=abcd[2];\n\t\twf[abcd[1]][abcd[0]]=abcd[3];\n\t}\n\tvector<int> xy(4);\n\tstring hoge;\n\tcin >> hoge;\n\tfunc(hoge,xy);\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\tfor(int k=1; k<n+1; ++k){\n\t\t\t\twf[j][k]=min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << xy[2] << \" \" << xy[3] << \" \" << wf[xy[0]][xy[1]] << \" \" << wf[xy[1]][xy[0]] << \"\\n\";\n\tcout << xy[2]-xy[3]-wf[xy[0]][xy[1]]-wf[xy[1]][xy[0]] << \"\\n\";\n\treturn 0;\n}\n\nvoid func(string str,vector<int>& a){\n\tint n;\n\tn=str.size();\n\tint j=0;\n\tstring tmp;\n\tfor(int i=0; i<n; ++i){\n\t\tif(i==n-1){\n\t\t\ttmp+=str[i];\n\t\t\ta[j]=atoi(tmp.c_str());\n\t\t} else {\n\t\t\tif(str[i] != ','&&i!=n-1) {\n\t\t\t\ttmp+=str[i];\n\t\t\t} else{\n\t\t\t\ta[j]=atoi(tmp.c_str());\n\t\t\t\t++j;\n\t\t\t\ttmp=\"\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nvoid solve()\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tV = n;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\ta--; b--;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tsolve();\n\tcout << y1 - D[--x1][--x2] - D[x2][x1] - y2 << endl;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\tif((*i).depart==s){\n\t\t\tq.push((*i).arrival);\n\t\t\tcost.at((*i).arrival)=(*i).cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\t\tif((*i).depart==pos){\n\t\t\t\tif(cost.at((*i).arrival)==INF){\n\t\t\t\t\tq.push((*i).arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at((*i).arrival)>(*i).cost+cost.at(pos)){\n\t\t\t\t\tcost.at((*i).arrival)=(*i).cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tfor(int i=0;i<n+1;i++){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\tfor(int i=0;i<n+1;i++){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF (1<<21)\n\nint main()\n{\n\tint wf[20][20];\n\tint n,m,a,b,c,d;\n\t\n\t/*ú»*/\n\trep(i,20)\n\t\trep(j,20)\n\t\t\twf[i][j] = INF;\n\trep(i,20)\n\t\twf[i][i] = 0;\n\t\t\n\t/*üÍ*/\n\tcin >> n >> m;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\ta--;b--;\n\t\n\t/* [VtCh@ */\n\trep(k,n)\n\t\trep(i,n)\n\t\t\trep(j,n)\n\t\t\t\twf[i][j] = min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\n\t/* oÍ */\n\tcout << c - d - wf[a][b] - wf[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    rep(i, 20) rep(j, 20) G[i][j] = INF;\n    rep(i, m) {\n        int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = G[i][j];\n    rep(i, n) dp[i][i] = 0;\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\nusing namespace std;\nconst double INF=100000000;\n \nint main(){\n  int n,m;\n  cin>>n>>m;\n  int dp[n][n];\n \n  rep(i,n){\n    rep(j,n){\n      dp[i][j]=i==j?0:INF;\n    }\n  }\n  rep(i,m){\n    int a,b,c,d;\n    char e;\n    cin>>a>>e>>b>>e>>c>>e>>d;\n    dp[a-1][b-1]=c;\n    dp[b-1][a-1]=d;\n  }\n  int s,g,V,P;\n  char e;\n  cin>>s>>e>>g>>e>>V>>e>>P;\n \n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n      }\n    }\n  }\n   \n   \n  cout<<V-P-dp[s-1][g-1]-dp[g-1][s-1]<<endl;\n   \n   \n  return 0;\n}\n     "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#define MM 200000000\nusing namespace std;\nint main(void)\n{\n\tint n,m,i,j,k,a,b,c,d,mi[21][21],s,g,v,p,sum;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++)\t{\n\t\tfor(j=1;j<=n;j++)\t{\n\t\t\tif(i==j)\tmi[i][j]=0;\n\t\t\telse mi[i][j]=MM;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++)\t{\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tmi[a][b]=c;\tmi[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\tfor(k=1;k<=n;k++)\t{\n\t\tfor(i=1;i<=n;i++)\t{\n\t\t\tfor(j=1;j<=n;j++)\t{\n\t\t\t\tmi[i][j]=min(mi[i][j],mi[i][k]+mi[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tsum=v-p-mi[s][g]-mi[g][s];\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nint main() {\n\tint n, m;\n\tint dis[20][20];\n\t\n\tcin >> n >> m;\n\t\n\tfill(dis[0], dis[20], INF);\n\tREP(i, n) dis[i][i] = 0;\n\tREP(i, m) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tdis[a][b] = c;\n\t\tdis[b][a] = d;\n\t}\n\t\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tx1--; x2--;\n\t\n\tREP(k, n) REP(i, n) REP(j, n) {\n\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t}\n\t\n\tint ans = y1 - y2 - (dis[x1][x2] + dis[x2][x1]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_CITY 20\n#define MAX_PRICE 1000\n#define INF 100000\nusing namespace std;\nint n, m;\nint d[MAX_CITY+1][MAX_CITY+1];\n\nvoid init() {\n    for(int r = 1; r <= n; r++) {\n        for(int c = 1; c <= n; c++) {\n            d[r][c] = INF;\n        }\n    }\n}\n\nvoid warshall_floyd() {\n    for(int via = 1; via <= n; via++) {\n        for(int from = 1; from <= n; from++) {\n            for(int to = 1; to <= n; to++) {\n                d[from][to] = min(d[from][to], d[from][via] + d[via][to]);\n            }\n        }\n    }\n}\n\nvoid print() {\n    for(int r = 1; r <= n; r++) {\n        for(int c = 1; c <= n; c++) {\n            cout << d[r][c];\n            if(c == n) putchar('\\n');\n            else putchar(' ');\n        }\n    }\n}\n\nint main(void) {\n    memset(d, 0, sizeof(d));\n    cin >> n >> m;\n    init();\n    for(int r = 0; r < m; r++) {\n        int from, to, cost1, cost2;\n        scanf(\"%d,%d,%d,%d\", &from, &to, &cost1, &cost2);\n        d[from][to] = cost1;\n        d[to][from] = cost2;\n    }\n    warshall_floyd();\n    int start, goal, salary, pole_cost;\n    scanf(\"%d,%d,%d,%d\", &start , &goal , &salary , &pole_cost);\n    cout << (salary - (pole_cost + d[start][goal] + d[goal][start])) << endl;\n    \n    //print();\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>10){\n                co[now][i]--;\n                return 0;\n            }\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#define INF 50000000\nusing namespace std;\n\nint graf[20][20];\nint kyo[20];\nbool use[20];\n\nvoid dijk(int ve, int st) {\n\tfill(kyo, kyo + ve, INF);\n\tfill(use, use + ve, false);\n\tkyo[st] = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int i = 0;i < ve; i++) {\n\t\t\tif (!use[i] && (v == -1 || kyo[i] < kyo[v]))v = i;\n\t\t}\n\t\tif (v == -1)break;\n\t\tuse[v] = true;\n\t\tfor (int i = 0;i < ve;i++) {\n\t\t\tkyo[i] = min(kyo[i], kyo[v] + graf[v][i]);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++)graf[i][j] = INF;\n\t}\n\n\tfor (int i = 0;i < m;i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tgraf[a - 1][b - 1] = c;\n\t\tgraf[b - 1][a - 1] = d;\n\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint sum = 0;\n\n\tdijk(n, s - 1);\n\tsum += kyo[g - 1];\n\n\tdijk(n, g - 1);\n\tsum += kyo[s - 1];\n\tcout << V - P - sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10e6\nusing namespace std;\n\nint cost[20][20];\n\nint main(void){\n\tint n,m;\n\tchar tmp;\n\tcin >> n >>m; \n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tcost[i][j]=INF;\n\tint a,b,c,d;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> a >> tmp >> b >> tmp >> c >> tmp >> d;\n\t\tcost[a-1][b-1]=c,cost[b-1][a-1]=d;\n\t}\n\tfor(int k=0;k<n;k++)\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\tint s,g;\n\tcin >> s >> tmp >> g >> tmp >> m >> tmp >> c;\n\tint ans=m-c-cost[s-1][g-1]-cost[g-1][s-1];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nA Reward for a Carpenter(https://onlinejudge.u-aizu.ac.jp/problems/0117)\n右\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecll> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 32;\nconst int INF = 1<<29;\n\nint wf[MAX][MAX];\n\nvoid solve(void){\n\tint N, M, s, g, V, P;\n\tchar cc;\n\tcin >> N >> M;\n\n\t//初期化\n\trep(N, i) rep(N, j) wf[i][j] = INF;\n\n\n\trep(M, i)\n\t{\n\t\tchar cc;\n\t\tint a, b, c, d;\n\t\tcin >> a >> cc >> b >> cc >> c >> cc >> d;\n\n\t\t//cout << a << b << c << d << endl;\n\n\t\ta--, b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\n\t//WF\n\trep(N, k) rep(N, i) rep(N, j) wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\tcin >> s >> cc >> g >> cc >> V >> cc >> P;\n\ts--, g--;\n\n\t/*Debug\n\trep(N, i) rep(N, j)\n\t{\n\t\tcout << wf[i][j] << ' ';\n\t\tif (j == N-1) cout << endl;\n\t}\n\t*/\n\n\n\t//往復の交通費と柱代を差し引いたものが答え\n\tcout << V - P - wf[s][g] - wf[g][s] << endl;\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n,m;\nint t[22][22];\n\nint main(void){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tchar ch;\n\t\tint a,b,c,d;\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\ta--;\n\t\tb--;\n\t\tt[a][b] = c;\n\t\tt[b][a] = d;\n\t}\n\tchar ch;\n\tint s,d,x,y;\n\tcin>>s>>ch>>d>>ch>>x>>ch>>y;\n\ts--;\n\td--;\n\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i == j || t[i][k] == 0 || t[k][j] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(t[i][j] == 0 || t[i][j] > t[i][k] + t[k][j]){\n\t\t\t\t\tt[i][j] = t[i][k] + t[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<x - y - t[s][d] - t[d][s]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*****include*****/\n#include <iostream>\n#include <fstream>\n\n/*****デバッグ定義*****/\n//#define DEBUG\n#define INF 10000\n/*****マクロ定義*****/\n\n/*****名前空間*****/\nusing namespace std;\n\n/*****グローバル変数置き場*****/\nint Field[20][20];\n\n/*****その他関数置き場*****/\nint djikstra(int start,int goal,int townnum){\n\tint *dis;\n\tbool *used;\n\tint town;\n\tint res;\n\tdis = new int [townnum];\n\tused = new bool [townnum];\n\tfor(int i=0;i<townnum;i++){\n\t\tdis[i] = INF;\n\t\tused[i] = false;\n\t}\n\tdis[start] = 0;\n\twhile(true){\n\t\ttown = -1;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(!used[i] && (town == -1 || dis[town] > dis[i])){\n\t\t\t\ttown = i;\n\t\t\t}\n\t\t}\n\t\tif(town == -1)\tbreak;\n\t\tused[town] = true;\n\t\tfor(int i=0;i<townnum;i++){\n\t\t\tif(dis[i] > dis[town] + Field[town][i]){\n\t\t\t\tdis[i] = dis[town] + Field[town][i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<townnum;i++)\tcout << dis[i] << \" \";\n\tcout << endl;*/\n\tres = dis[goal];\n\tdelete used;\n\tdelete dis;\n\treturn res;\n}\n/*****main関数*****/\nint main(){\n\t/*****ファイルオープン*****/\n#ifdef DEBUG\n\tofstream fout(\"output.txt\");\n\tifstream fin(\"input.txt\");\n\tif(!fout || !fin){\n\t\tcout << \"Can't open the file.\\n\";\n\t\treturn;\n\t}\n#endif\n\t/*****変数置き場*****/\n\tint townnum;\n\tint rootnum;\n\tint ts,tg,value,price;\n\tint cost=0;\n\tint t1,t2,c1,c2;\n\t/*****処理部*****/\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tField[i][j] = INF;\n\t\t}\n\t}\n\tcin >> townnum >> rootnum;\n\tfor(int i=0;i<rootnum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&t1,&t2,&c1,&c2);\n\t\t//cin >> t1 >> ',' >> t2 >> ',' >> c1 >> ',' >> c2;\n\t\tField[t1-1][t2-1] = c1;Field[t2-1][t1-1] = c2;\n\t\tField[t1-1][t1-1] = 0;Field[t2-1][t2-1] = 0;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&ts,&tg,&value,&price);\n\t//cout << ts << \" \" << tg << \" \" << townnum <<endl;\n\tcost = 0;\n\tcost += djikstra(ts-1,tg-1,townnum);\n\tcost += djikstra(tg-1,ts-1,townnum);\n\tcout << (value - price - cost) << endl;\n\t/*****処理終了後*****/\n#ifdef DEBUG\n\tfout.close();\n\tfin.close();\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\n\nstruct edge{\n\tll to;\n\tll cost;\n\tedge(ll to, ll cost) :to(to), cost(cost){};\n};\n\nvector<edge> G[100];\nll n, m;\nll a, b, c, d;\nchar k;\nll sum[100];\nll iki, kaeri;\n\nvoid djikstra(int start){\n\tREP(i, 100){\n\t\tsum[i] = INF;\n\t}\n\tsum[start] = 0;\n\n\tpriority_queue<P> que;//fi:cost,se:vertex\n\tque.push(P(0, start));\n\n\twhile (que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (sum[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (sum[e.to] > sum[v] + e.cost){\n\t\t\t\tsum[e.to] = sum[v] + e.cost;\n\t\t\t\tque.push(P(sum[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n >> m;\n\tREP(i, m){\n\t\tcin >> a >> k >> b >> k >> c >> k >> d;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, d));\n\t}\n\tcin >> a >> k >> b >> k >> c >> k >> d;\n\tdjikstra(a);\n\tiki = sum[b];\n\tdjikstra(b);\n\tkaeri = sum[a];\n\tcout << c - d - iki - kaeri << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(void){\n\tint n;\n\tint m;\n\tint dist[21][21];\n\t\n\tcin >> n;\n\tcin >> m;\n\n\tfor( int i = 0;i < 21;i++ ){\n\t\tfor( int j = 0;j < 21;j++ ){\n\t\t\tdist[i][j] = 99999;\n\t\t}\n\t}\n\tfor( int i = 0;i < 21;i++ ){\n\t\tdist[i][i] = 0;\n\t}\n\n\tfor( int i = 0;i < m;i++ ){\n\t\tint a1,b1,c1,c2;\n\t\tscanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&c2 );\n\t\tdist[a1][b1] = c1; dist[b1][a1] = c2;\n\t}\n\n\tfor( int k = 1;k <= n;k++ ){\n\t\tfor( int i = 1;i <= n;i++ ){\n\t\t\tif( dist[i][k] == 99999 ) continue;\n\t\t\tfor( int j = 1;j <= n;j++ ){\n\t\t\t\tdist[i][j] = min( dist[i][k] + dist[k][j], dist[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\n\tint x1,x2,y1,y2;\n\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tcout << y1 - ( dist[x1][x2] + dist[x2][x1] + y2 ) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint cost[20][20];\nint main() {\n\tfor(int i=0;i<20;i++) {\n\t\tfor(int j=0;j<20;j++) {\n\t\t\tif(i!=j)cost[i][j]=cost[j][i]=1<<27;\n\t\t\telse cost[i][i]=0;\n\t\t}\n\t}\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<m;i++) {\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tcost[a-1][b-1]=c;\n\t\tcost[b-1][a-1]=d;\n\t}\n\tfor(int k=0;k<n;k++) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tprintf(\"%d\\n\",y1-y2-cost[x1-1][x2-1]-cost[x2-1][x1-1]);\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a);i < (b); ++i)\n#define RFOR(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n\n//clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0 , sizeof(a))\n\n\n#define INF 1<<21\nint n, m, x[2], y[2];\nint amat[20][20];\nint res = 0;\nchar cht;\n\nint main()\n{\n\tcin >> n >> m;\n\t\n\tFOR(i, 0, n)\n\t\tFOR(j, 0, n)\n\t\t\tamat[i][j] = INF;\n\n\tFOR(i,0,m)\n\t{\n\t\tint a, b, c, d;\n\t\t\n\t\tcin >> a >>cht>> b >>cht>> c >>cht>> d;\n\t\t\n\t\ta--; b--;\n\t\tamat[a][b] = c;\n\t\tamat[b][a] = d;\n\t}\n\t\n\tcin >> x[0] >>cht>> x[1] >>cht>> y[0] >>cht>> y[1];\n\tx[0]--; x[1]--;\n\t\n\tFOR(k,0,n)\n\tFOR(i,0,n)\n\tFOR(j,0,n)\n\t{\n\t\tamat[i][j] = min( amat[i][j], amat[i][k] + amat[k][j]);\n\t}\n\t\n\tres = y[0] -y[1] -amat[x[0]][x[1]] -amat[x[1]][x[0]];\n\t\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define MAX 20\n\nclass Node {\npublic:\n\tvector<int> to, ct;\n};\n\nNode node[MAX];\n\nclass Trl {\npublic:\n\tint p, cost;\n\tTrl(int p, int c) : p(p), cost(c) {}\n\tbool operator<(const Trl& n) const {\n\t\treturn cost > n.cost;\n\t}\n};\n\nint N;\n\nint dijkstra(int s, int d) {\n\tpriority_queue<Trl> q;\n\tbool v[MAX] = {0};\n\tq.push(Trl(s, 0));\n\twhile (!q.empty()) {\n\t\tTrl t=q.top(); q.pop();\n\t\tif (v[t.p]) continue;\n\t\tv[t.p] = true;\n\t\tif (t.p == d) return t.cost;\n\t\tfor (int i=0; i<node[t.p].to.size(); i++) {\n\t\t\tint next = node[t.p].to[i];\n\t\t\tif (v[next]) continue;\n\t\t\tq.push(Trl(next, t.cost+node[t.p].ct[i]));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i=0; i<MAX ;i++) {\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].ct.clear();\n\t\t}\n\t\tint n;\n\t\tchar c;\n\t\tint w,x,y,z;\n\t\tcin >> n;\n\t\twhile (n--) {\n\t\t\tcin >> w >> c >> x >> c >> y >> c >> z;\n\t\t\tnode[w].to.push_back(x);\n\t\t\tnode[x].to.push_back(w);\n\t\t\tnode[w].ct.push_back(y);\n\t\t\tnode[x].ct.push_back(z);\n\t\t}\n\t\tcin >> w >> c >> x >> c >> y >> c >> z;\n\t\tcout << y-z-dijkstra(w,x)-dijkstra(x,w) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint cost[25][25];\nint N, M;\n\n\n\nsigned main() {\n\tfill( cost[0], cost[25], INF );\n\tREPONE( i, N ) cost[i][i] = 0;\n\n\tchar c;\n\tcin >> N >> M;\n\tREP( i, M ) {\n\t\tint from, to, ft, tf;\n\t\tcin >> from >> c >> to >> c >> ft >> c >>  tf;\n\t\tcost[from][to] = ft;\n\t\tcost[to][from] = tf;\n\t}\n\tint s, g, v, p;\n\tcin >> s >> c >> g >> c >> v >> c >> p;\n\n\tREPONE( k, N ) {\n\t\tREPONE( i, N ) {\n\t\t\tREPONE( j, N ) {\n\t\t\t\tchmin( cost[i][j], cost[i][k] + cost[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << v - ( cost[s][g] + cost[g][s] ) - p << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define inf 1000000000\nusing namespace std;\n\nvoid show(int n, vector<vector<int>> A)\n{\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << A[i][j] << \" \";\n        }\n        cout << endl;\n    } \n}\n\nint main()\n{   \n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> K(30, vector<int>(30));\n    int a, b, c, d;\n    string str;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            K[i][j] = inf;\n        }\n    }\n\n    REP(i, m) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n\n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n\n    cout << V - K[s][g] - K[g][s] - P << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\n\nint N;\nconst ll INF = 1e15;\nvector<ll> dijkstra(vector<Edge> g[100000],int start){\n  priority_queue<NODE> Q;\n  Q.push({start,0});\n  vector<ll> res(N+1,INF);\n  while(Q.size()){\n    NODE q= Q.top();Q.pop();\n    if(res[q.pos] == INF){\n      res[q.pos] = q.cost;\n    }\n    else{\n      continue;\n    }\n    for(auto n : g[q.pos]){\n      Q.push({n.to,q.cost+n.cost});\n    }\n  }\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int m,a,b,d,e,x,x2,y,y2;\n  char c;\n  cin >>N>>m;\n  rep(i,m){\n    cin >> a>>c>>b>>c>>d>>c>>e;\n    g[a].push_back(Edge{b,d});\n    g[b].push_back(Edge{a,e});\n  }\n  cin >> x >>c>> x2>>c >> y>>c >> y2;\n  auto res = dijkstra(g,x);\n  auto res2 = dijkstra(g,x2);\n  cout << y - res[x2]-res2[x] -y2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nint e[20][20];\n\nint main(){\n\tcin >> n >> m;\n\trep(i,n) rep(j,n) e[i][j] = INF;\n\trep(i,n) e[i][i] = 0;\n\trep(i,m){\n\t\tint x[4];\n\t\tstring str;\n\t\tcin >> str;\n\t\tint tmp = 0, cnt = 0;\n\t\trep(j,str.size()){\n\t\t\tif(str[j] != ','){\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[j]-'0';\n\t\t\t} else{\n\t\t\t\tx[cnt] = tmp;\n\t\t\t\tcnt++; tmp = 0;\n\t\t\t}\n\t\t\tif(j == str.size()-1) x[cnt] = tmp;\n\t\t}\n\t\tx[0]--; x[1]--;\n\t\te[x[0]][x[1]] = x[2];\n\t\te[x[1]][x[0]] = x[3];\n\t}\n\trep(k,n) rep(i,n) rep(j,n) e[i][j] = min(e[i][j],e[i][k]+e[k][j]);\n\tint y[4];\n\tstring str; cin >> str;\n\tint tmp = 0, cnt = 0;\n\trep(j,str.size()){\n\t\tif(str[j] != ','){\n\t\t\ttmp *= 10;\n\t\t\ttmp += str[j]-'0';\n\t\t} else{\n\t\t\ty[cnt] = tmp;\n\t\t\tcnt++; tmp = 0;\n\t\t}\n\t\tif(j == str.size()-1) y[cnt] = tmp;\n\t}\n\ty[0]--; y[1]--;\n\tcout << y[2]-y[3]-e[y[0]][y[1]]-e[y[1]][y[0]] << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 25\n#define INF 1<<21\n\nint d[MAX_V][MAX_V];\nint n, m;\n\nvoid warshall_floyd(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nint main(){\n\tfor(int i = 0; i < MAX_V; i++){\n\t\tfor(int j = 0; j < MAX_V; j++){\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\n\tcin >> n >> m;\n\tchar c;\n\tfor(int i = 0; i < m; i++){\n\t\tint a1, b1, c1, d1;\n\t\tcin >> a1 >> c >> b1 >> c >> c1 >> c >> d1;\n\t\td[a1-1][b1-1] = c1;\n\t\td[b1-1][a1-1]\t= d1;\t\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\t\n\twarshall_floyd();\n\tcout << y1 - y2 - d[x1-1][x2-1] - d[x2-1][x1-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/07/23  Problem: AOJ 0117 / Link: https://onlinejudge.u-aizu.ac.jp/challenges/search/volumes/0117  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\n\nint main() {\n\n\tint N, M; cin >> N >> M;\n\tVVI dist(N, VI(N, INF));\n\tFOR(i, 0, N)dist[i][i] = 0;\n\tFOR(i, 0, M) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d,\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tdist[a][b] = min(dist[a][b], c);\n\t\tdist[b][a] = min(dist[b][a], d);\n\t}\n\tFOR(k, 0, N)FOR(i, 0, N)FOR(j, 0, N)dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\tint s, g, v, p;\n\tscanf(\"%d,%d,%d,%d,\", &s, &g, &v, &p);\n\ts--, g--;\n\tLL ans = v - dist[s][g] - dist[g][s] - p;\n\t\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N, M, A, B, C, D, x1, x2, y1, y2, Ans;\nint main(){\n  scanf(\"%d%d\", &N, &M);\n  int K[N+10][N+10];\n  for(int i=1; i<=N; i++){\n    for(int j=1; j<=N; j++){\n      K[i][j] = 2000;\n    }\n  }\n  for(int i=1; i<=M; i++){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    //cerr << \"read \" << A << ' ' << B << ' ' << C << ' ' << D << endl;\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n  for(int k=1; k<=N; k++){\n    for(int i=1; i<=N; i++){\n      for(int j=1; j<=N; j++){\n        if(K[i][j] > K[i][k] + K[k][j]){\n          K[i][j] = K[i][k] + K[k][j];\n        }\n      }\n    }\n  }\n\n  int s, g, V, P;\n  scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n  Ans = V - P - K[s][g] - K[g][s];\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint city[21][21],n,load[21][21];\nint power(int n)\n{\n    int num=1;\n    for(int i=0;i<n;i++)num*=10;\n    return num;\n}\nint aserch(int endp,int now,int befor)\n{\n    int money=50000;\n    if(city[now][endp]!=-1)return city[now][endp];\n    else{\n        for(int i=1;i<=n;i++){\n                if(city[now][i]!=-1&&i!=befor&&load[now][i]!=10){\n                    load[now][i]++;\n                    money=min(aserch(endp,i,now)+city[now][i],money);\n                }\n        }\n    }\n    return money;\n}\nint bserch(int stap,int now,int befor)\n{\n    int money=50000,num;\n    if(city[now][stap]!=-1){\n        return city[now][stap];\n    }\n    else{\n        for(int i=1;i<=n;i++){\n            if(city[now][i]!=-1&&i!=befor&&load[now][i]!=20){\n                    load[now][i]++;\n                   num=bserch(stap,i,now)+city[now][i];\n                   if(num>-1)money=min(num,money);\n            }\n        }\n    }\n    return money;\n\n}\nint main()\n{\n    int m;\n    cin>>n>>m;\n    memset(city,-1,sizeof(city));\n    memset(load,0,sizeof(load));\n    string str;\n    for(int i=0;i<m;i++){\n        int kawa[2]={};\n        cin>>str;\n        for(int j=0,co=0,point=0;;j++){\n            if(str[j]==','||str[j]=='\\0'){\n                int mo=0;\n                if(co<2){\n                    for(int k=point;k<j;k++)kawa[co]+=(str[k]-'0')*power(j-k-1);\n                    point=j+1;\n                    co++;\n                }\n                else if(co==2){\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[0]][kawa[1]]=mo;\n                    point=j+1;\n                    co++;\n                }\n                else{\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[1]][kawa[0]]=mo;\n                    break;\n                }\n            }\n        }\n    }\n    cin>>str;\n    int pointing[3]={},Pillar=0;\n    for(int i=0,co=0,point=0;;i++){\n        if(str[i]==','){\n            for(int j=point;j<i;j++)pointing[co]+=(str[j]-'0')*power(i-j-1);\n            point=i+1;\n            co++;\n        }\n        if(str[i]=='\\0'){\n            for(int j=point;j<i;j++)Pillar+=(str[j]-'0')*power(i-j-1);\n            break;\n        }\n    }\n    cout<<pointing[2]-Pillar-aserch(pointing[1],pointing[0],0)-bserch(pointing[0],pointing[1],0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//Cost,Pos\ntypedef std::pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(int a, int b):to(a), cost(b){};\n};\n\nconst int max = 25; \nconst int inf = 1000000000;\n\nint n, m;\nstd::vector<edge> g[max];\nint d[max];\n\nvoid dijkstra(int s){\n\tstd::priority_queue<P, std::vector<P>, std::greater<P> > que;\n\tfor(int i = 0; i <= n; i++)d[i] = inf;\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)continue;\n\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\tedge e = g[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tchar ch;\n\tstd::cin >> n >> m;\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tstd::cin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\tedge f(b, c), s(a, d);\n\t\tg[a].push_back(f);\n\t\tg[b].push_back(s);\n\t}\n\tint x1, x2, y1, y2;\n\tstd::cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\ty1 -= y2;\n\tdijkstra(x1);\n\ty1 -= d[x2];\n\tdijkstra(x2);\n\ty1 -= d[x1];\n\tstd::cout << y1 << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP( i, m, n ) for ( int i = (int)m; i < (int)n; i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)m; i < (unsigned int)n; i++ )\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( a, b )\n#define fst first\n#define snd second\n\nint dijkstra( vector< vector< pair<int,int> > > graph, const int start, const int goal )\n{\n\tvector<int> distance( graph.size() );\n\tfill( ALL( distance ), INT_MAX );\n\n\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que; // 累計コスト, ノード番号\n\tque.push( MP( 0, start ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tint total = que.top().fst;\n\t\tint node = que.top().snd;\n\t\tque.pop();\n\n\t\tif ( total < distance[ node ] )\n\t\t{\n\t\t\tdistance[ node ] = total;\n\n\t\t\tREP( i, 0, graph[ node ].size() )\n\t\t\t{\n\t\t\t\tint to = graph[ node ][i].fst;\n\t\t\t\tint cost = graph[ node ][i].snd;\n\n\t\t\t\tque.push( MP( total + cost, to ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn distance[ goal ];\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< vector< pair<int,int > > > graph( n );\n\n\tREP( i, 0, m )\n\t{\n\t\tstring buffer;\n\t\tcin >> buffer;\n\n\t\tREP( j, 0, buffer.length() )\n\t\t{\n\t\t\tif ( buffer[j] == ',' )\n\t\t\t{\n\t\t\t\tbuffer[j] = ' ';\n\t\t\t}\n\t\t}\n\n\t\tint from, to, forward, back;\n\t\tistringstream( buffer ) >> from >> to >> forward >> back;\n\n\t\tgraph[ from - 1 ].PB( MP( to - 1, forward ) );\n\t\tgraph[ to - 1 ].PB( MP( from - 1, back ) );\n\t}\n\t\n\tstring buffer;\n\tcin >> buffer;\n\n\tREP( j, 0, buffer.length() )\n\t{\n\t\tif ( buffer[j] == ',' )\n\t\t{\n\t\t\tbuffer[j] = ' ';\n\t\t}\n\t}\n\n\tint start, goal, given, pay;\n\tistringstream( buffer ) >> start >> goal >> given >> pay;\n\n\tcout << given - pay - dijkstra( graph, start - 1, goal - 1 ) - dijkstra( graph, goal - 1, start - 1 ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<ios>\nusing namespace std;\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nvector<T>dijkstra(int s,const vector<vector<pair<int,T> > >&G,T INF=numeric_limits<T>::max())\n{\n\tint n=G.size();\n\tvector<T>d(n,INF);\n\tvector<int>parent(n,-1);\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\td[s]=0;\n\tP.push(make_pair(d[s],s));\n\twhile(!P.empty())\n\t{\n\t\tpair<T,int>p=P.top();P.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(const pair<int,T>&e:G[v])\n\t\t{\n\t\t\tint u=e.first;\n\t\t\tT cost=d[v]+e.second;\n\t\t\tif(d[u]>cost)\n\t\t\t{\n\t\t\t\td[u]=cost;\n\t\t\t\tparent[u]=v;\n\t\t\t\tP.push(make_pair(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nmain()\n{\n    int n,m;\n    cin>>n>>m;\n    vector<vector<pair<int,int> > >G;\n    for(;m--;)\n    {\n        int a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--,b--;\n        G[a].push_back(make_pair(b,c));\n        G[b].push_back(make_pair(a,d));\n    }\n    int s,t,P,V;\n    scanf(\"%d,%d,%d,%d\",&s,&t,&P,&V);\n    s--,t--;\n    cout<<P-V-dijkstra(s,G)[t]-dijkstra(t,G)[s]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint N, M, A, B, C, D, S, G, V, P;\nint K[32][32];\nconst int Inf = 1000000100;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++)\n      K[i][j] = Inf;\n  }\n  for (int i=0; i<M; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n  scanf(\"%d,%d,%d,%d\", &S, &G, &V, &P);\n  for (int k = 1; k <= N; k++) {\n    for (int i = 1; i <= N; i++) {\n      for (int j = 1; j <= N; j++)\n        K[i][j] = min(K[i][j],K[i][k] + K[k][j]);\n    }\n  }\n  printf(\"%d\\n\", (V-P-K[S][G]-K[G][S]));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX>>2\n\nstruct Data{int id,cost;};\nbool operator<(Data a,Data b){return a.cost!=b.cost?a.cost<=b.cost:a.id<=b.id;}\n\nint n,m,a,b,c,d,x1,x2,y1,y2;\nvector< vector<int> >D;\n\nint Dijkstra(int start,int goal)\n{\n  vector<int>l(n,NONE),visited(n,0);\n  priority_queue<Data>q;\n  int u;\n  Data d={start,0};\n  q.push(d);\n  l[start]=0;\n  while(q.size()){\n    u=q.top().id;q.pop();\n    visited[u]=1;\n    for(int v=0;v<n;v++){\n      if(visited[v])continue;\n      if(l[u]+D[u][v] >= l[v])continue;\n      l[v]=l[u]+D[u][v];\n      Data d={v,l[v]};\n      q.push(d);\n    }\n  }\n  return l[goal];\n}\n\nint main()\n{\n  cin>>n>>m;\n  D.resize(n);\n  for(int i=0;i<n;i++)D[i].resize(n,NONE);\n  while(m-->0){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;\n    b--;\n    D[a][b]=c;\n    D[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  x1--;x2--;\n  cout<<(y1-y2-Dijkstra(x1,x2)-Dijkstra(x2,x1))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a);i < (b); ++i)\n#define RFOR(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n\n//clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0 , sizeof(a))\n\n\n#define MAXVTX 21\nint n, m, x[2], y[2];\nint amat[21][21];\nint vtx[21];\nint res = 0;\nchar cht;\nqueue<int> qu;\n\nint djk(int start, int goal)\n{\n\tFOR(i,0,MAXVTX)\n\t\tvtx[i] = INT_MAX;\n\t\n\tqu.push(start);\n\tvtx[start] = 0;\n\t\n\twhile( !qu.empty() )\n\t{\n\t\tint a = qu.front();\n\t\tqu.pop();\n\t\t\n\t\tFOR(i,0,MAXVTX)\n\t\t{\n\t\t\tif( a != i && amat[a][i] > 0 && (amat[a][i] + vtx[a] < vtx[i] ) )\n\t\t\t{\n\t\t\t\tqu.push(i);\n\t\t\t\tvtx[i] = amat[a][i] + vtx[a];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vtx[goal];\n}\n\nint main()\n{\n\tCLR(amat);\n\t\n\tcin >> n >> m;\n\n\tFOR(i,0,m)\n\t{\n\t\tint a, b, c, d;\n\t\t\n\t\tcin >> a >>cht>> b >>cht>> c >>cht>> d;\n\t\t\n\t\t\n\t\tamat[a][b] = c;\n\t\tamat[b][a] = d;\n\t}\n\t\n\tcin >> x[0] >>cht>> x[1] >>cht>> y[0] >>cht>> y[1];\n\t\n\t\n\tres = y[0] - y[1] -djk(x[0], x[1]) -djk(x[1], x[0]);\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#define INF 50000000\nusing namespace std;\n\nint graf[20][20];\nint kyo[20];\nbool use[20];\n\nvoid dijk(int ve, int st) {\n\tfill(kyo, kyo + ve, INF);\n\tfill(use, use + ve, false);\n\tkyo[st - 1] = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int i = 0;i < ve; i++) {\n\t\t\tif (!use[i] && (v == -1 || kyo[i] < kyo[v]))v = i;\n\t\t}\n\t\tif (v == -1)break;\n\t\tuse[v] = true;\n\t\tfor (int i = 0;i < ve;i++) {\n\t\t\tkyo[i] = min(kyo[i], kyo[v] + graf[v][i]);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++)graf[i][j] = INF;\n\t}\n\tfor (int i = 0;i < m;i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tgraf[a - 1][b - 1] = c;\n\t\tgraf[b - 1][a - 1] = d;\n\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint sum = 0;\n\tdijk(n, s - 1);\n\tsum += kyo[g - 1];\n\tdijk(n, g - 1);\n\tsum += kyo[s - 1];\n\tcout << V - P - sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n//struct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; std::cin >> x; return x;}\ntemplate <typename T> void print(T x) {std::cout << x << '\\n';}\ntemplate <typename T>\nvoid print(std::vector<T>& v, std::string s = \" \") {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << s;\n    std::cout << v[i];\n  }\n  std::cout << '\\n';\n}\n\n/* }}} */\n\nint n, m;\n\nvoid warshall_floyd(vvi& d)\n{\n  REP(k, n) REP(i, n) REP(j, n) {\n    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n  }\n}\n\nsigned main()\n{\n  scanf(\"%d%d\", &n, &m);\n  vvi dp(n, vi(n, INF));\n  REP(i, m) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--; b--;\n    dp[a][b] = c; dp[b][a] = d;\n  }\n  warshall_floyd(dp);\n  int s, g, v, p;\n  scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n  s--; g--;\n  print(v - p - dp[s][g] - dp[g][s]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main(){\n\tint cityNum,roadNum;\n\tint city[20];\n\tint road[190][2];\n\tint roadCost[190][2];\t//0:0-1 1:1-0\n\n\tint i,j;\n\tint start,goal,money,hashira;\n\tbool flg;\n\n\tcin>>cityNum>>roadNum;\n\tfor(i=0;i<roadNum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&road[i][0],&road[i][1],&roadCost[i][0],&roadCost[i][1]);\n\t\troad[i][0]--;road[i][1]--;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&money,&hashira);\n\tstart--;goal--;\n\t\n\t\n\tfor(i=0;i<cityNum;i++) city[i]=1000000;\n\tcity[start]=0;\n\tdo{\n\t\tflg=false;\n\t\tfor(i=0;i<roadNum;i++){\n\t\t\tfor(j=0;j<2;j++){\n\t\t\t\tif(city[road[i][j]]+roadCost[i][j]<city[road[i][1-j]]){\n\t\t\t\t\tcity[road[i][1-j]]=city[road[i][j]]+roadCost[i][j];\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(flg);\n\t\n\tcout<<money-hashira-road[goal]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#define MAX_N 21\n#define INF 10000000\nusing namespace std;\n\ntypedef pair<int, int> P;\n\ntypedef struct {\n  int to, cost;\n} edge;\n\nvector<edge> G[MAX_N];\nint d[2][MAX_N];\n\nvoid dijkstra(int s, int index) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  for (int j = 0; j < MAX_N; j++) {\n    d[index][j] = INF;\n  }\n  d[index][s] = 0;\n  que.push(P(0, s));\n\n  while (que.empty() == false) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    if (d[index][v] < p.first) continue;\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[index][e.to] > d[index][v] + e.cost) {\n\td[index][e.to] = d[index][v] + e.cost;\n\tque.push(P(d[index][e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    edge e;\n    e.to = b;\n    e.cost = c;\n    G[a].push_back(e);\n    e.to = a;\n    e.cost = d;\n    G[b].push_back(e);\n  }\n\n  int s, g, money, p;\n  scanf(\"%d,%d,%d,%d\", &s, &g, &money, &p);\n\n  dijkstra(s, 0);\n  dijkstra(g, 1);\n  cout << money - p - d[0][g] - d[1][s] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// a Reard For a Carpenter\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117&lang=jp\n//\n//\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint n, m, a, b, c, d, ans=0, s, g, V, P;\nint Cost[32][32]={};\nconst int inf = 1001001001;\n\nvoid show(){\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j){\n            if(Cost[i][j] == inf) cout << \"INF \";\n            else cout << Cost[i][j] << \" \";\n    \n            if(j == n) cout << endl;\n    } \n}\n\nvoid solve(){\n    for(int k = 1; k <= n; ++k)\n        for(int i = 1; i <= n; ++i)\n            for(int j = 1; j <= n; ++j)\n                Cost[i][j] = min(Cost[i][j],Cost[i][k] + Cost[k][j]);\n    // show();\n\n    cout << V - P - Cost[s][g] - Cost[g][s] << endl;\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j) Cost[i][j] = inf;\n\n    for(int i = 0; i < m; ++i){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        // cerr << \"(a, b, c, d) = (\" << a << \", \" << b << \", \" << c << \", \" << d << \")\" << endl;\n        Cost[a][b] = c;\n        Cost[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    // cerr << \"(s,g,V,P) = (\" << s << \", \" << g << \", \" << V << \", \" << P  << \")\" << endl;\n\n    // show();\n\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nvoid solve()\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tV = n;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\ta--; b--;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tsolve();\n\tcout << y1 - D[x1][x2] - D[x2][x1] - y2 << endl;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\ntypedef pair<int,int> pii;\n#define MAX_V 30\n#define INF (1<<30)\n\nstruct edge{int to,cost;};\nvector<edge> G[MAX_V],IN[MAX_V];\nint d[MAX_V];\n \nvoid dijkstra(int s,int V){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep(i,V)d[i]=INF;\n    d[s]=0;\n    que.push(pii(0,s));\n     \n    while(que.size()){\n        pii p=que.top();\n        que.pop();\n         \n        int v=p.second;\n        if(d[v]<p.first)continue;\n         \n        rep(i,G[v].size()){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint N,M;\nint maze[100][100],tim[100][100];\nint main(void){\n\tcin>>N>>M;\n\twhile(M--){\n\t\tint a,b,c,f;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&f);\n\t\tedge e = {b,c},e1 = {a,f};\n\t\tIN[a].push_back( e);\n\t\tIN[b].push_back(e1);\n\t}\n\n\tint a,b,c,f;\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&f);\n\trep(i,N+1)G[i] = IN[i];\n\tdijkstra(a,N+1);\n\tint s = d[b];\n\t//cout<<d[b]<<endl;\n\trep(i,N+1)G[i] = IN[i];\n\n\tdijkstra(b,N+1);\n\ts += d[a];\n\t//cout<<d[a]<<endl;\n\tcout<<c-f-s<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdio.h>\nusing namespace std;\n#define MAX 100000\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n\n// 重み付き有向グラフの隣接リスト\nvector<pair<int,int> > adj[MAX];\n\nint dijkstra(vector<pair<int,int> >* adj,int n,int startIndex,int dest){\n    priority_queue<pair<int,int> >pq;\n    // weight[v]に始点sからvまでの最短コストを保存する\n    int weight[MAX];\n    // 訪問状態を記録\n    int color[MAX];\n    // 1.初期化\n    for(int i = 0;i < n;++i){\n        weight[i] = __INT_MAX__;\n        color[i] = WHITE;\n    }\n    \n    // 始点\n    weight[startIndex] = 0;\n    color[startIndex] = GRAY;\n    pq.push(make_pair(0,startIndex));\n    \n    // 2\n    while(!pq.empty()){\n        // 2.1最小である頂点の決定\n        pair<int,int> first = pq.top();\n        pq.pop();\n        // 頂点\n        int u = first.second;\n        color[u] = BLACK;\n        // 最短値を取りだして、最短でなければ飛ばす\n        if(weight[u] < first.first * -1) continue;\n        // uに隣接する頂点vが存在する限り最短店を更新する\n        for(int i = 0;i < adj[u].size();++i){\n            int v = adj[u][i].first;\n            if(color[v] == BLACK)continue;\n            // 2.2最短点の更新\n            if(weight[v] > weight[u] + adj[u][i].second){\n                weight[v] = weight[u] + adj[u][i].second;\n                // priority_queueはデフォルトで大きい値を優先するので-にする\n                pq.push(make_pair(weight[v] * -1, v));\n                color[v] = GRAY;\n            }\n        }\n    }\n    return weight[dest];\n}\n\nint main(){\n    int begin,vNum,eNum,dest,salary,cost,totalCost = 0;\n    cin >> vNum;\n    cin >> eNum;\n\n    int s,t,d1,d2;\n    for(int i = 0;i < eNum;++i){\n        scanf(\"%d,%d,%d,%d\",&s,&t,&d1,&d2);\n        adj[s - 1].push_back(make_pair(t - 1,d1));\n        adj[t - 1].push_back(make_pair(s - 1,d2));\n    }\n    scanf(\"%d,%d,%d,%d\",&begin,&dest,&salary,&cost);\n    totalCost += dijkstra(adj,vNum,begin - 1,dest - 1);\n    totalCost += dijkstra(adj,vNum,dest - 1,begin - 1);\n    int ans = salary - (cost + totalCost);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nclass Town\n{\npublic:\n\tTown() : totalCost( 0 ), isGoal( false ), isThrough( false ){}\n\t~Town(){}\n\n\tvoid clear(){\n\t\ttotalCost = 0;\n\t\tisGoal = false;\n\t\tisThrough = false;\n\t}\n\n\tvector< pair< int, int > > routes;\n\tint totalCost;\n\tbool isGoal;\n\tbool isThrough;\n};\n\nint startToGoal( Town* towns, int start, int goal )\n{\n\tint move = start;\n\ttowns[ goal ].isGoal = true;\n\tvector< pair< int, pair< int, int > > > gotoList;\n\n\twhile( !towns[ move ].isGoal ){\n\t\ttowns[ move ].isThrough = true;\n\t\tint count = towns[ move ].routes.size();\n\t\tfor( int i = 0; i < count; ++i ){\n\t\t\tgotoList.push_back( make_pair( move, towns[ move ].routes[ i ] ) );\n\t\t}\n\t\tint minCost = INT_MAX;\n\t\tint here, go, c;\n\t\tvector< pair< int, pair< int, int > > >::iterator itr = gotoList.begin();\n\t\twhile( itr != gotoList.end() ){\n\t\t\there = itr->first;\n\t\t\tgo = itr->second.first;\n\n\t\t\tif( towns[ go ].isThrough ){\n\t\t\t\titr = gotoList.erase( itr );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tc = towns[ here ].totalCost + itr->second.second;\n\t\t\tif( c < minCost ){\n\t\t\t\tminCost = c;\n\t\t\t\tmove = go;\n\t\t\t}\n\t\t\t++itr;\n\t\t}\n\t\ttowns[ move ].totalCost = minCost;\n\t}\n\treturn towns[ move ].totalCost;\n}\n\nint main()\n{\n\tint n, m;\n\tint a, b, c, d;\n\tint bugget, cost;\n\tint home, turn;\n\n\tcin >> n;\n\tcin >> m;\n\n\tTown* towns = new Town[ n + 1 ];\n\n\tchar dummy;\n\tfor( int i = 0; i < m; ++i ){\n\t\tcin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n\t\ttowns[ a ].routes.push_back( make_pair( b, c ) );\n\t\ttowns[ b ].routes.push_back( make_pair( a, d ) );\n\t}\n\n\tcin >> home >> dummy >> turn >> dummy >> bugget >> dummy >> cost;\n\n\tcost += startToGoal( towns, home, turn );\n\n\tfor( int i = 0; i < n; ++i ){\n\t\ttowns[ i ].clear();\n\t}\n\n\tcost += startToGoal( towns, turn, home );\n\n\tcout << bugget - cost << endl;\n\n\tdelete[] towns;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n,go_min = 100000000,back_min = 100000000,Table[21][21];\n\nvoid func(int sum,int current,int goal,bool FLG,int checkTable[21]){\n\tif(current == goal){\n\t\tif(FLG){\n\t\t\tgo_min = min(go_min,sum);\n\t\t}else{\n\t\t\tback_min = min(back_min,sum);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=1; i <= n; i++){\n\t\tif(Table[current][i] > 0 && checkTable[i] == 0){\n\t\t\tint newCheckTable[21];\n\t\t\tfor(int k=0; k < 21; k++)newCheckTable[k] = checkTable[k];\n\t\t\tnewCheckTable[i] = 1;\n\t\t\tfunc(sum+Table[current][i],i,goal,FLG,newCheckTable);\n\t\t}\n\t}\n\n}\n\n\nint main(){\n\n\tint m,a,b,c,d,start,end,V,P,checkTable[21];\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0; i < 21; i++){\n\t\tcheckTable[i] = 0;\n\t\tfor(int k=0; k < 21; k++){\n\t\t\tTable[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&m);\n\n\tfor(int i=0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tTable[a][b] = c;\n\t\tTable[b][a] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\",&start,&end,&V,&P);\n\n\tfunc(0,start,end,true,checkTable);\n\tfunc(0,end,start,false,checkTable);\n\n\tprintf(\"%d\\n\",V-(P+go_min+back_min));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nconstexpr int MAX_N = 20;\nconstexpr int INF = (int)1e7;\nusing P = std::pair<int, int>;\n\nstruct edge {\n\tint to, cost;\n\tedge() = default;\n\tedge(const edge&) = default;\n\tedge(int _t, int _c) : to(_t), cost(_c) {}\n\tedge& operator= (const edge&) = default;\n};\n\nint n, m;\nstd::vector<edge> G[MAX_N];\nint f, t, mym, cm;\nint d[MAX_N];\n\nint dijkstra(int s, int g) {\n\tstd::fill(d, d + n, INF);\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> que;\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (v == g)\n\t\t\tbreak;\n\n\t\tif (d[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tchar ch;\n\tint a, b, c, d;\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\t--a;\n\t\t--b;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, d));\n\t}\n\tstd::cin >> f >> ch >> t >> ch >> mym >> ch >> cm;\n\n\t--f;\n\t--t;\n\n\tint x = dijkstra(f, t), y = dijkstra(t, f);\n\tint ans = mym - cm - x - y;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MAX_N 21\n#define INF 1e+9\nusing namespace std;\nint main(void){\n\tint n,m;cin>>n>>m;\n\tint g[MAX_N][MAX_N];\n\tfor(int i=0;i<MAX_N;++i)for(int j=0;j<MAX_N;++j)g[i][j]=INF;\n\tfor(int i=0,a,b,c,d;i<m;++i){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tg[a][b]=c;\n\t\tg[b][a]=d;\n\t}\n\tint d[MAX_N][MAX_N];\n\tfor(int i=0;i<MAX_N;++i)for(int j=0;j<MAX_N;++j)d[i][j]=(i==j)?0:INF;\n\tfor(int i=1;i<=n;++i){\n\t\tbool f=false;\n\t\tfor(;;){\n\t\t\tfor(int j=1;j<=n;++j){//from\n\t\t\t\tfor(int k=1;k<=n;++k){//to\n\t\t\t\t\tif(d[i][j]!=INF && d[i][j] + g[j][k] < d[i][k]){\n\t\t\t\t\t\td[i][k] = d[i][j] + g[j][k];\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==false) break;\n\t\t\tf=false;\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tcout<<y1-y2-d[x1][x2]-d[x2][x1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_V 20\nconst int INF = 1<<20;\n\nint cost[MAX_V][MAX_V];\nint V;\nbool used[MAX_V];  // 最小距離の確定した頂点\nint d[MAX_V];\n\nvoid dijkstra(int s) {\n  fill(d, d+V, INF);\n  fill(used, used+V, false);\n  \n  d[s] = 0;\n  while(true) {\n    int v = -1;\n    for(int u=0; u<V; u++) {\n      // 最小が確定していない頂点からd[v]を最小距離であることが確定させる\n      if(!used[u] && ( v == -1 || d[u] < d[v] ) ) v = u;\n    }\n    if(v == -1) {\n      // 全ての頂点の最小距離が確定\n      break;\n    }\n    used[v] = true;\n    \n\n    \n    // 上で確定させた最小距離の頂点から伸びうる頂点を更新しておく\n    for(int u=0; u<V; u++) {\n      d[u] = min(d[u], d[v]+cost[v][u]);\n    }\n  }\n}\n\nint main() {\n  int m;\n\n  cin >> V >> m;\n\n  for(int i=0; i<V; i++) {\n    for(int j=0; j<V; j++) {\n      cost[i][j] = INF;\n    }\n  }\n  \n  for(int i=0; i<m; i++) {\n    int a, b;\n    char c1, c2;\n    cin >> a >> c1 >> b >> c2; a--, b--;\n    cin >> cost[a][b] >> c1 >> cost[b][a];\n  }\n  \n  int x1, x2, y1, y2;\n  char c1,c2,c3;\n  cin >> x1 >> c1 >> x2 >> c2 >> y1 >> c3 >> y2; x1--, x2--;\n  \n  dijkstra(x1);\n  \n  int money = y1-(y2+d[x2]);\n  \n  dijkstra(x2);\n  \n  money -= d[x1];\n  cout << money << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nint solve(int s, int e)\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn D[s][e];\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\twhile (cin >> n && n)\n\t{\n\t\tcin >> m;\n\t\tV = m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\t\tD[a][b] = c;\n\t\t\tD[b][a] = d;\n\t\t}\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\t\tcout << y1 - solve(x1, x2) - D[x2][x1] - y2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 10000;\n\nvoid p(vector<int> v){\n\tfor(int i = 0; i < v.size(); i++){\n//\t\tcout << v[i] << ' ';\n\t\tprintf(\"%6d\", v[i]);\n\t}\n\tcout << endl;\n}\n\nvoid p(vector<vector<int> > v){\n\tfor(int i = 0; i < v.size(); i++){\n\t\tp(v[i]);\n\t}\n}\n\nint main(){\n\tint n, m;\n\n\tcin >> n >> m;\n\n\tvector<vector<int> > road(++n);\n\tfor(int i = 0; i < n; i++){\n\t\troad[i].resize(n, INF);\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\troad[a][b] = c;\n\t\troad[b][a] = d;\n\t}\n\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 1; j < n; j++){\n\t\t\tfor(int k = 1; k < n; k++){\n\t\t\t\troad[j][k] = min(road[j][k], road[j][i] + road[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n//\tp(road);\n\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n\tint reward = y1 - (y2 + road[x1][x2] + road[x2][x1]);\n\n\tcout << reward << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£????????????35m\nFloyd-Warshall????????£?????¨??????????????????????±??????????\n???????????????????????????????????????????°?????????????\n#endif\n\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf=1001001001;\n\nint main() {\n\tlong long pay,ans;\n\tfor(int i=0;i<32;i++)\n\t\tfor(int j=0;j<32;j++)\n\t\t\tK[i][j]=inf;\n\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i=0; i<M; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\t\t//cerr << \"read \" << A <<\" \"<< B <<\" \" << C <<\" \" << D<< endl;\n\t\tK[A][B]=C;\n\t\tK[B][A]=D;\n\t}\n\t\n\tfor(int k=1;k<N+1;k++){\n\t\tfor(int i=1;i<N+1;i++){\n\t\t\tfor(int j=1;j<N+1;j++){\n\tif(K[i][j]>K[i][k]+K[k][j]){\n\t\tK[i][j]=K[i][k]+K[k][j];\n\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\tpay=K[A][B]+K[B][A];\n\tans=C-D-pay;\n\tcout<<ans<<endl; \n}\n#if 0\n??£??\\???????¨????????????§???\nInf  2   4   4  Inf Inf \n 2  Inf Inf Inf  3  Inf \n 3  Inf Inf  4  Inf  1  \n 2  Inf  2  Inf Inf  1  \nInf  2  Inf Inf Inf  1  \nInf Inf  2   1   2  Inf \nInf  2   4   4  Inf Inf \n 2   4   6   6   3  Inf \n 3   5   7   4  Inf  1  \n 2   4   2   6  Inf  1  \nInf  2  Inf Inf Inf  1  \nInf Inf  2   1   2  Inf \n??¨?????????????????????\n???????????????\n4   2   4   4   5   5  \n 2   4   6   5   3   4  \n 3   5   3   2   3   1  \n 2   4   2   2   3   1  \n 4   2   3   2   3   1  \n 3   4   2   1   2   2\n ?????§????????????????¢??????§?????????\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[30][30];\nint ans;\nconst int infty = 10000000;\n\nint main() {\n  // 初期化\n  for (int i=0; i<30; i++) {\n    for (int j=0; j<30; j++) {\n      K[i][j] = infty;\n    }\n  }\n  // 入力\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M; i++) {\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  // Floyd-Warshall アルゴリズム\n  for (int k=1; k<=N; k++) {\n    for (int i=1; i<=N; i++) {\n      for (int j=1; j<=N; j++) {\n\tif (K[i][j] > K[i][k] + K[k][j]) {\n\t  K[i][j] = K[i][k] + K[k][j];\n\t} \n      }\n    }\n  }\n  ans = y1 - y2 - K[x1][x2] - K[x2][x1];\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int  MAX_C = 21;\nconst long long  INF = (1<<30);\n\nlong long edge[MAX_C][MAX_C];\nlong long cost[MAX_C];\nint come[MAX_C];\n\nlong long n,m;\n\nlong long solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    long long  minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      long long from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    long long  start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint n;\nvector<int> edge[101];\nvector<int> weight[101];\n\nint v[100];\nint M = 1001001001;\n\n\nint dijkstra(int a){\n\tfor(int i=0; i<100; i++){\n\t\tv[i] = M;\n\t}\n\tpriority_queue<pair<int, int> > pq;\n\tpq.push(pair<int,int>(0, a));\n\n\twhile(!pq.empty()){\n\t\tpair<int, int> t = pq.top();\n\t\tpq.pop();\n\t\tif(v[t.second]!=M) continue;\n\n\t\tv[t.second] = -t.first;\n\t\tfor(int i=0; i<edge[t.second].size(); i++){\n\t\t\tpq.push(pair<int, int>(t.first-weight[t.second][i], edge[t.second][i]));\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n/*\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdst[i][j] = M;\n\t\t}\n\t}\n\t*/\n\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tedge[a-1].push_back(b-1);\n\t\tweight[a-1].push_back(c);\n\t\tedge[b-1].push_back(a-1);\n\t\tweight[b-1].push_back(d);\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = 0;\n\tdijkstra(x1-1);\n\tans += v[x2-1];\n\tdijkstra(x2-1);\n\tans += v[x1-1];\n\tcout << y1 - y2 - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n\nint di(int s, int f, vector< vector<int> > E, const int Size){\n\tint* cost = new int[Size + 1];\n\tbool* used = new bool[Size + 1];\n\n\tfor(int i = 0; i < Size + 1; i++){\n\t\tcost[i] = INT_MAX / 4;\n\t\tif(i == s){\n\t\t\tcost[i] = 0;\n\t\t}\n\t\tused[i] = false;\n\t}\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int i = 0 ; i < Size + 1; i++){\n\t\t\tif( !used[i] && (v == -1 || cost[v] > cost[i])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\n\t\tfor(int i = 0; i < Size + 1; i++){\n\t\t\tcost[i] = min(cost[i], cost[v] + E[v][i]);\n\t\t}\n\t}\n\n\treturn cost[f];\n}\n\n\nint main(){\n\tint n, m;\n\tint x1, x2, y1, y2;\n\tchar dummy;\n\tint cost = 0;\n\n\tcin >> n;\n\tcin >> m;\n\n\tint* a = new int[m + 1];\n\tint* b = new int[m + 1];\n\tint* c = new int[m + 1];\n\tint* d = new int[m + 1];\n\n\tvector< vector <int > > E(n + 1, vector<int> (n + 1, INT_MAX / 4));\n\n\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> a[i] >> dummy >> b[i] >> dummy >> c[i] >> dummy >> d[i];\n\t\tE[a[i]][b[i]] = c[i];\n\t\tE[b[i]][a[i]] = d[i];\n\t}\n\tcin >> x1 >> dummy >> x2 >> dummy >> y1 >> dummy >> y2;\n\n\n\tcost += di(x1, x2, E, n);\n\tcost += di(x2, x1, E, n);\n\n\tcout << y1 - y2 - cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\nvector<P> v[30];\nint n,m;\n\nint bfs(int s, int t) {\n  int d[n+1];\n  fill(d,d+n+1,MAX);\n  d[s]=0;\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0,s));\n  while(!que.empty()) {\n    int cost=que.top().F,x=que.top().S;que.pop();\n    //PR(cost,x);\n    //if(x==t) break;\n    for(int i=0; i<v[x].size(); i++) {\n      int y=v[x][i].F,c=v[x][i].S;\n      if(d[y]<cost+c) continue;\n      d[y]=min(d[y],cost+c);\n      que.push(P(d[y],y));\n    }\n  }\n  return d[t];\n}\n\nint main() {\n  cin >> n >> m;\n  rep(i,m) {\n    int a,b,c,d;\n    scanf(\"%d%*c%d%*c%d%*c%d\",&a,&b,&c,&d);\n    v[a].pb(P(b,c));\n    v[b].pb(P(a,d));\n  }\n  int s,t,sum,z;\n  scanf(\"%d%*c%d%*c%d%*c%d\",&s,&t,&sum,&z);\n  sum-=z;\n  sum-=bfs(s,t);  sum-=bfs(t,s);\n  pr(sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e+9;\n\nint main(){\n\tint n,m,dist[21][21];\n\t\n\tfor(int i=0 ; i < 21 ; i++ )\n\t\tfor(int j=0 ; j < 21 ; j++ )\n\t\t\tdist[i][j] = INF;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i=0 ; i < m ; i++ ){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdist[a][b] = c;\n\t\tdist[b][a] = d;\n\t}\n\tfor(int k=1 ; k <= n ; k++ ){\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tfor(int j=1 ; j <= n ; j++ ){\n\t\t\t\tdist[i][j] = min( dist[i][j] , dist[i][k]+dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = y1 - (y2 + dist[x1][x2] + dist[x2][x1]);\n\tprintf(\"%d\\n\", ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <map>\n#include <list>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n#include <time.h>\nusing namespace std;\nclock_t fi, endtime;\n\nconst int r_c = 0;\nconst int r_t = 1;\nconst int MAX_V = 20;\nconst int MAX_E = 100;\nconst int MAX_D = 1000;\n\nconst int INF = MAX_V * MAX_E * MAX_D;\n\nint main()\n{\n\tint wf[MAX_V][MAX_V];\n\tint n, m, a, b, c, d, s, g, V, P;\n\tint sum = 0;\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\twf[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\twf[a - 1][b - 1] = c; wf[b - 1][a - 1] = d;\n\t}\n\tfor (int k = 0; k < n; ++k) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (wf[i][j] > wf[i][k] + wf[k][j])\n\t\t\t\t\twf[i][j] = wf[i][k] + wf[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\n\tsum = wf[s - 1][g - 1] + wf[g - 1][s - 1] + P;\n\tprintf(\"%d\\n\", V - sum);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tll i,j,k,n,m,ma[21],flg[21],s,g,v,p,min,ri[21][21],sum;\n\tPP ga[101];\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&ga[i].ff,&ga[i].fs,&ga[i].ss,&ga[i].sf);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&v,&p);\n\tsort(ma,ma+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[ga[i].ff][ga[i].fs]=ga[i].sf,ri[ga[i].fs][ga[i].ff]=ga[i].ss;\n\tfor(i=0;i<n;i++){\n\t\tflg[i]=0;\n\t\tma[i]=M;\n\t}\n\tma[s]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(flg[j]==0&&ma[j]<min) k=j,min=ma[j];\n\t\t}\n\t\tflg[k]=1;\n\t\tif(min==M) break;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif((ma[k]+ri[k][j])<ma[j]) ma[j]=ma[k]+ri[k][j];\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++) printf(\"ma[i]=%d\\n\",ma[i]);\n\tsum=ma[g];\n\tprintf(\"%d\\n\",sum);\n\tfor(i=0;i<n;i++){\n\t\tflg[i]=0;\n\t\tma[i]=M;\n\t}\n\tma[g]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(flg[j]==0&&ma[j]<min) k=j,min=ma[j];\n\t\t}\n\t\tflg[k]=1;\n\t\tif(min==M) break;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif((ma[k]+ri[k][j])<ma[j]) ma[j]=ma[k]+ri[k][j];\n\t\t}\n\t}\n\tsum+=ma[s];\n\tprintf(\"%d\\n\",v-p-sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORR(i,a,b) for(int i=(a);i>(b);i--)\n#define REP(i,n)  FOR(i,0,n)\n\n#define INF (1<<21)\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//debug\n//-------------------------------------------\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define VISITED 1\n#define NOT_VISITED 0\n\n//typedef\n//-------------------------------------------\ntypedef long long ll;\n\nint g[21][21];\nint visited[21];\nint d[21];\nint n;\n\nint dijkstra(int start) {\n    d[start] = 0;\n\n    while(1) {\n        int u = -1;\n        int tmpd = INF;\n        REP(i, n + 1) {\n            if (visited[i] == NOT_VISITED) {\n                if (tmpd > d[i]) {\n                    u = i;\n                    tmpd = d[i];\n                }\n            }\n        }\n        if (u < 0) break;\n        visited[u] = VISITED;\n\n        REP(i, n + 1) {\n            if (g[u][i] != INF && visited[i] == NOT_VISITED) {\n               if ((d[u] + g[u][i]) < d[i]) {\n                   d[i] = d[u] + g[u][i];\n               }\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    REP(i, 21) REP(j, 21) g[i][j] = INF;\n    int m;\n    cin >> n;\n    cin >> m;\n    REP(i, m) {\n        string str;\n        cin >> str;\n        stringstream ss(str);\n        string buf;\n        vector<int> tmp;\n        while (getline(ss, buf, ',')) {\n            tmp.push_back(stoi(buf));\n        }\n        int a = tmp[0];\n        int b = tmp[1];\n        int c = tmp[2];\n        int d = tmp[3];\n\n        g[a][b] = c;\n        g[b][a] = d;\n    }\n\n    string str;\n    cin >> str;\n    stringstream ss(str);\n    string buf;\n    vector<int> tmp;\n    while (getline(ss, buf, ',')) {\n        tmp.push_back(stoi(buf));\n    }\n    int s = tmp[0];\n    int goal = tmp[1];\n    int v = tmp[2];\n    int p = tmp[3];\n\n    REP(i, 21) visited[i] = NOT_VISITED;\n    REP(i, 21) d[i] = INF;\n    dijkstra(s);\n    int up = d[goal];\n\n    REP(i, 21) visited[i] = NOT_VISITED;\n    REP(i, 21) d[i] = INF;\n    dijkstra(goal);\n    int down = d[s];\n\n    cout << v - p - (up + down) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Dijkstra's Algorithm ( O(|V|^2) ) */\n\n#include<cstdio>\n#include<climits>\n#include<algorithm>\n\nusing namespace std;\n\nint adj[20][20],n;\n\nint dijkstra(int s,int g)\n{\n\tint d[20];\n\tbool visited[20];\n\tfor(int i=1;i<=n;i++)\td[i]=INT_MAX,visited[i]=false;\n\n\td[s]=0;\n\twhile(1){\n\t\t// find next u\n\t\tint u,cmin=INT_MAX;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!visited[i] && d[i]<cmin)\tcmin=d[i],u=i;\n\t\t}\n\t\tif(cmin==INT_MAX)\tbreak;\n\n\t\tvisited[u]=true;\n\n\t\t// update d[v]\n\t\tfor(int v=1;v<=n;v++){\n\t\t\tif(visited[v] || adj[u][v]==INT_MAX)\tcontinue;\n\t\t\td[v]=min(d[v],d[u]+adj[u][v]);\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main()\n{\n\n\tint m;\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)adj[i][j]=INT_MAX;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tadj[a][b]=c;\n\t\tadj[b][a]=d;\n\t}\n\tint x1,x2,y1,y2;\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tprintf(\"%d\\n\",y1-y2-dijkstra(x1,x2)-dijkstra(x2,x1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<ios>\nusing namespace std;\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nvector<T>dijkstra(int s,const vector<vector<pair<int,T> > >&G,T INF=numeric_limits<T>::max())\n{\n\tint n=G.size();\n\tvector<T>d(n,INF);\n\tvector<int>parent(n,-1);\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\td[s]=0;\n\tP.push(make_pair(d[s],s));\n\twhile(!P.empty())\n\t{\n\t\tpair<T,int>p=P.top();P.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(const pair<int,T>&e:G[v])\n\t\t{\n\t\t\tint u=e.first;\n\t\t\tT cost=d[v]+e.second;\n\t\t\tif(d[u]>cost)\n\t\t\t{\n\t\t\t\td[u]=cost;\n\t\t\t\tparent[u]=v;\n\t\t\t\tP.push(make_pair(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nmain()\n{\n    int n,m;\n    cin>>n>>m;\n    vector<vector<pair<int,int> > >G(n);\n    for(;m--;)\n    {\n        int a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--,b--;\n        G[a].push_back(make_pair(b,c));\n        G[b].push_back(make_pair(a,d));\n    }\n    int s,t,P,V;\n    scanf(\"%d,%d,%d,%d\",&s,&t,&P,&V);\n    s--,t--;\n    cout<<P-V-dijkstra(s,G)[t]-dijkstra(t,G)[s]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair< int , int > P;\n#define INF (1<<30)\nint main(){\n  int n,m;\n  int a,b,c,d;\n  int cost[21][21];\n  int min_cost[21];\n  cin >> n;\n  cin >> m;\n  for(int i=0;i<21;i++){\n    for(int j=0;j<21;j++){\n      cost[i][j]=INF;\n    }\n    min_cost[i]=INF;\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  queue<P> que;\n  que.push(P(0,a));\n  min_cost[a]=0;\n  while(!que.empty()){\n    P p;\n    p = que.front();\n    que.pop();\n    int v = p.second;\n    for(int i=1;i<=n;i++){\n      if(cost[v][i] != INF){\n\tif(min_cost[i] > cost[v][i] + p.first){\n\t  min_cost[i] = cost[v][i] + p.first;\n\t  que.push(P(cost[v][i] + p.first,i));\n\t}\n      }\n    }\n  }\n  c -= min_cost[b];\n  for(int i=0;i<21;i++){\n    min_cost[i] = INF;\n  }\n  que.push(P(0,b));\n  min_cost[b]=0;\n  while(!que.empty()){\n    P p;\n    p = que.front();\n    que.pop();\n    int v = p.second;\n    for(int i=1;i<=n;i++){\n      if(cost[v][i] != INF){\n\tif(min_cost[i] > cost[v][i] + p.first){\n\t  min_cost[i] = cost[v][i] + p.first;\n\t  que.push(P(cost[v][i] + p.first,i));\n\t}\n      }\n    }\n  }\n  cout << c - min_cost[a] - d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Node{\npublic:\n\tint node;\n\tint cost;\n\tNode(int n,int c){\n\t\tnode = n;\n\t\tcost = c;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn cost > o.cost;\n\t}\n};\n#define MAX 2000000000\nint main(){\n\tint n,m;\n\tint s,g,money,hashira;\n\tpriority_queue<Node> pq;\n\tpriority_queue<Node> pq2;\n\tint map[50][50];\n\tbool visited[100];\n\tchar ch;\n\n\tcin >> n >> m;\n\tfor(int i = 1; i <=n;i++ ){\n\t\tvisited[i] = false;\n\t}\n\tfor(int i = 1 ; i <=n ;i++){\n\t\tfor(int j = 1;j <=n ;j++){\n\t\t\tmap[i][j] = MAX;\n\t\t}\n\t}\n\n\tfor(int i = 1 ; i <= m;i++){\n\t\tint a,b,c,d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\tmap[a][b] = c;\n\t\tmap[b][a] = d;\n\t}\n\n\tcin >> s >> g >> money >> hashira;\n\t//ツ行ツつォツづ個コツスツトツづーツ仰づ淞づゥ\n\tpq.push(Node(s,0));\n\twhile(!pq.empty()){\n\t\tNode c_node = pq.top();\n\t\tpq.pop();\n\t\tif(c_node.node == g){\n\t\t\tpq2.push(c_node);\n\t\t\tbreak;\n\t\t}\n\t\tif(visited[c_node.node])continue;\n\t\tvisited[c_node.node]= true;\n\t\tfor(int i = 1;i <= n;i++ ){\n\t\t\tif(map[c_node.node][i] == MAX)continue;\n\t\t\tint n_cost = c_node.cost + map[c_node.node][i];\n\t\t\tpq.push(Node(i,n_cost));\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n;i++ ){\n\t\tvisited[i] = false;\n\t}\n\n\t//ツ帰ツづィツづ個コツスツトツづーツ仰づ淞づゥ\n\twhile(!pq2.empty()){\n\t\tNode c_node = pq2.top();\n\t\tpq2.pop();\n\t\tif(c_node.node == s){\n\t\t\tint ans = money - hashira-c_node.cost;\n\t\t\tcout <<ans <<endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(visited[c_node.node])continue;\n\t\tvisited[c_node.node]= true;\n\t\tfor(int i = 1;i <= n;i++ ){\n\t\t\tif(map[c_node.node][i] == MAX)continue;\n\t\t\tint n_cost = c_node.cost + map[c_node.node][i];\n\t\t\tpq2.push(Node(i,n_cost));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct edge{\n  int to,cost;\n};\nint d[100];\nvector<vector<struct edge> >E(100);\nvoid dijkstra(int s){\n  priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >que;\n  for(int i=0;i<100;i++)\n    d[i]=1000000000;\n  d[s] = 0;\n  que.push(pair<int,int>(0,s));\n  while(!que.empty()){\n    pair<int,int> p=que.top();que.pop();\n    int v = p.second;\n    if(d[v]<p.first)continue;\n    for(int j=0;j<E[v].size();j++){\n      edge t = E[v][j];\n      if(d[t.to]>d[v]+t.cost){\n\td[t.to]=d[v]+t.cost;\n\tque.push(pair<int,int>(d[t.to],t.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int n,m;cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    struct edge A,B;\n    A.to=b;A.cost=c;B.to=a;B.cost=d;\n    E[a].push_back(A);E[b].push_back(B);\n  }\n  int s,g,V,P;\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n  int ans=V-P;\n  dijkstra(s);\n  ans-=d[g];\n  //cout<<d[g]<<endl;\n  dijkstra(g);\n  ans-=d[s];\n  // cout<<d[s]<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\tcin >> N;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &t, &s, &p, &q);\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[s] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - q - D[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tint D[32][32][2]={{{0}}};/*Adjacency matrix*/\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tD[a-1][b-1][0] = c;\n\t\tD[b-1][a-1][0] = c;\n\t\tD[a-1][b-1][1] = d;\n\t\tD[b-1][a-1][1] = d;\n\t}\n\tint ans = 0;\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tans = y1-y2;\n\tfor(int k = 0; k < 2; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j)continue;\n\t\t\t\tif(D[i][j][k] == 0)D[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = 0;\n\tfor(int l = 0; l < 2; l++){\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tD[i][j][l] = min(D[i][j][l],D[i][k][l]+D[k][j][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(l == 0) ? cost += D[x1-1][x2-1][0] : cost += D[x2-1][x1-1][1];\n\t}\n\tprintf(\"%d\\n\",ans-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint main() {\n\tconst int INF = (1 << 29);\n\n\tint n, m;\n\tscanf(\"%d\\n%d\", &n, &m);\n\n\tvector<vector<int>> mat(n, vector<int>(n, INF));\n\tfor(int i = 0; i < n; ++i) {\n\t\tmat[i][i] = 0;\n\t}\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t--a; --b;\n\t\tmat[a][b] = c;\n\t\tmat[b][a] = d;\n\t}\n\n\tfor(int k = 0; k < n; ++k) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t--x1; --x2;\n\tprintf(\"%d\\n\", y1 - (mat[x1][x2] + mat[x2][x1] + y2));\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nint road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=n;i++)if(place[now][i]>-1)ans=max(ans,serch(start,finish,money-place[now][i],go,i));\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<stdio.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  const int INF=(1<<29);\n  int min[1010],fix[1010];\n  int map[1010][1010];\n  int s1,g1; //スタート地点の座標をs1,ゴール地点の座標をg1とおく\n  int n,m,i,j,x,y,z1,z2,v,price; //nは頂点の本数,mは辺の本数\n  priority_queue<P,vector<P>,greater<P> > que;  //greater<P>の右の空白は重要\n  scanf(\"%d\\n%d\\n\",&n,&m);\n  for(i=0;i<=n;i++){\n    min[i]=INF,fix[i]=0;\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      map[i][j]=-1;\n    }\n  }\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\\n\",&x,&y,&z1,&z2);\n    if(map[x][y]==-1 || map[x][y]>z1){\n    map[x][y]=z1;\n    }\n    if(map[y][x]==-1 || map[y][x]>z2){\n    map[y][x]=z2;\n    }\n  }\n  scanf(\"%d,%d,%d,%d\\n\",&s1,&g1,&v,&price);\n  v=v-price;\n  que.push(P(0,s1));\n  min[s1]=0;\n  while(!que.empty()){\n    if(fix[g1]==1){\n      break;\n    }\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(min[v]<p.first){\n      continue;\n    }\n    for(i=0;i<=n;i++){\n      if(map[v][i]!=-1 && min[i]>min[v]+map[v][i] && fix[i]==0){\n        min[i]=min[v]+map[v][i];\n        que.push(P(min[v]+map[v][i],i));\n      }\n    }\n    fix[v]=1;\n  }\n  v=v-min[g1];\n  while(!que.empty()){\n    que.pop();\n  }\n    for(i=0;i<=n;i++){\n    min[i]=INF,fix[i]=0;\n  }\n  que.push(P(0,g1));\n  min[g1]=0;\n  while(!que.empty()){\n    if(fix[s1]==1){\n      break;\n    }\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(min[v]<p.first){\n      continue;\n    }\n    for(i=0;i<=n;i++){\n      if(map[v][i]!=-1 && min[i]>min[v]+map[v][i] && fix[i]==0){\n        min[i]=min[v]+map[v][i];\n        que.push(P(min[v]+map[v][i],i));\n      }\n    }\n    fix[v]=1;\n  }\n  v=v-min[s1];\n  printf(\"%d\\n\",v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n\nusing namespace std;\ntypedef long long int lint;\n\n#define INF 10000000\n\nint* mk_vector(int size, int init)\n{\n\tint* vec = new int[size];\n\tfor (int i = 0; i < size; i++) {\n\t\tvec[i] = init;\n\t}\n\treturn vec;\n}\n\nint** mk_matrix(int size, int init)\n{\n\tint** mat = new int*[size];\n\tfor (int i = 0; i < size; i++) {\n\t\tmat[i] = new int[size];\n\t}\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < size; j++) {\n\t\t\tmat[i][j] = init;\n\t\t}\n\t}\n\treturn mat;\n}\n\nint Dijkstra(int size, int start, int goal, int** cost)\n{\n\t//??????S\n\tbool* S = new bool[size + 1];\n\t//??????V-S\n\tbool* V = new bool[size + 1];\n\t//D[i] : i??????????????????????°??????????\n\tint* D = mk_vector(size + 1, INF);\n\n\tfor (int i = 1; i <= size; i++) {\n\t\tS[i] = false;\n\t\tV[i] = true;\n\t}\n\n\tS[start] = true;\n\tV[start] = false;\n\tfor (int i = 1; i <= size; i++) {\n\t\tif (S[i]) continue;\n\t\tD[i] = cost[start][i];\n\t}\n\n\tfor (int i = 1; i <= size - 1; i++) {\n\t\t//D[w] ???????°???¨?????? w in V-S ????±???????\n\t\tint w;\n\t\tint minD = INF;\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (!V[i]) continue;\n\t\t\tif (D[i] < minD) {\n\t\t\t\tminD = D[i];\n\t\t\t\tw = i;\n\t\t\t}\n\t\t}\n\t\t//S = S cup {w}\n\t\tS[w] = true;\n\t\tV[w] = false;\n\t\tfor (int i = 1; i <= size; i++) {\n\t\t\tif (!V[i]) continue;\n\t\t\tD[i] = min(D[i], D[w] + cost[w][i]);\n\t\t}\n\t}\n\n\tint ret = D[goal];\n\n\tdelete[] S;\n\tdelete[] V;\n\tdelete[] D;\n\n\treturn ret;\n}\n\nvoid AOJ0117()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tint** cost = mk_matrix(n + 1, INF);\n\tfor (int i = 0; i < m; i++) {\n\t\tint\ta, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c; // a to b\n\t\tcost[b][a] = d; // b to a\n\t}\n\tint start, goal, V, P;\n\tscanf(\"%d,%d,%d,%d\", &start, &goal, &V, &P);\n\n\t//print(cost, n);\n\n\tint ans = V - P - Dijkstra(n, start, goal, cost) - Dijkstra(n, goal, start, cost);\n\n\tcout << ans << endl;\n\n\treturn;\n}\n\nint main()\n{\n\tAOJ0117();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long int\n#define INF 1000000\nusing namespace std;\t\nint main(void)\n{\n\tLL i,j,k,n,m,glid[21][21],start,gorl,v[21]={INF},clr[21]={0},a,b,c,d,mm,p,ans2,mini,x,ans1;\n\tcin>>n>>m;\n\tfor(i=0;i<=n;i++)for(j=0;j<n;j++) glid[i][j]=INF;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%lld,%lld,%lld,%lld\",&a,&b,&c,&d);\n\t\tglid[a][b]=c;\n\t\tglid[b][a]=d;\n\t}\n\tscanf(\"%lld,%lld,%lld,%lld\",&start,&gorl,&mm,&p);\n\tfor(i=0;i<21;i++) {\n\t\tv[i]=INF;\n\t\tclr[i]=0;\n\t}\n\tv[start]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans1=v[gorl];\n\tfor(i=0;i<21;i++) {\n\t\tv[i]=INF;\n\t\tclr[i]=0;\n\t}\n\tv[gorl]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans2=v[start];\n\tcout<<mm-p-ans1-ans2<<endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int INF = 100000000;\n\nint K[25][25];\n\nvoid init()\n{\n\tfor (int i = 0; i < 25; ++i)\n\t{\n\t\tfor (int j = 0; j < 25; ++j)\n\t\t{\n\t\t\tK[i][j] = INF;\n\t\t}\n\t}\n}\n\nvoid show(int N)\n{\n\tfor (int i = 1; i <= N; ++i)\n\t{\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t{\n\t\t\tif (K[i][j] == INF)\n\t\t\t{\n\t\t\t\tcout << \"INF\" << \" \";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << K[i][j] << \" \";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tinit();\n\tint N,M,A,B,C,D,S,G,V,P;\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < M; ++i)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\t\t//cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n\t\tK[A][B] = C;\n\t\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &S, &G, &V, &P);\n\n\t//show(N);\n\n\tfor (int k = 1; k <= N; ++k)\n\t{\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= N; ++j)\n\t\t\t{\n\t\t\t\tif (K[i][j] > K[i][k] + K[k][j])\n\t\t\t\t{\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//show(N);\n\t}\n\n\tcout << V - P - K[S][G] -K[G][S] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define MG 210000000\n\n main(){\n\t\n\tint n,m;\n\tint i,j;\n\tint a[40],b[40],c[40],d[40];\n\tint e,f,g=MG,h,l;\n\tint k[21][21],flg[21],dk[21],dkn;\n\tint flg2[21],dk2[21];\n\t\n\tscanf(\"%d\",&n);\n\t\n\tscanf(\"%d\",&m);\n\t\n\tfor(i=0;i<=n;i++){\n\t\tdk[i]=MG;\n\t\tflg[i]=0;\n\t\tdk2[i]=MG;\n\t\tflg2[i]=0;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tk[i][j]=MG;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&e,&f,&dkn,&h);\n\t\n\t\n\n\t\n\tfor(i=1;i<=m;i++){\n\t\tk[a[i]][b[i]]=c[i];\n\t\tk[b[i]][a[i]]=d[i];\n\t}\n\t\n\n\tdk[e]=0;\n\t\n\tfor(i=0;i<=n;i++){\n\t\tg=MG;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0 && dk[j]<g){\n\t\t\t\tg=dk[j];\n\t\t\t\tl=j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg[l]=1;\n\t\t\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(dk[l]+k[l][j]<dk[j]){\n\t\t\t\tdk[j]=dk[l]+k[l][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdk2[f]=0;\n\t\n\tfor(i=0;i<=n;i++){\n\t\tg=MG;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg2[j]==0 && dk2[j]<g){\n\t\t\t\tg=dk2[j];\n\t\t\t\tl=j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tflg2[l]=1;\n\t\t\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(dk2[l]+k[l][j]<dk2[j]){\n\t\t\t\tdk2[j]=dk2[l]+k[l][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdkn=dkn-(h+dk[f]+dk2[e]);\n\t\n\tprintf(\"%d\\n\",dkn);\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\n/*\nconst int MAX_E=2*(100-1);\nconst int MAX_V=100;\nconst long long int INF=100000000;\nstruct edge { int from,to,cost;};\nedge es[MAX_E];\n//int d[MAX_V];\nint V,E;\nvoid shortest_path(int s,int e,vector<int>& d);\nint main(){\n\tint n,k;\n\twhile(cin >> n >> k&&n!=0&&k!=0){\n\t\tint V=n;\n\t\tint E=2*(n-1);\n\t\tvector<int> land(V);\n\t\tint l=0;\n\t\tfor(int i=0; i<E; ++i){\n\t\t\tes[i].cost=-1;\n\t\t\tes[i].from=-1;\n\t\t\tes[i].to=-1;\n\t\t}\n\t\tfor(int i=0; i<k; ++k){\n\t\t\tint m;\n\t\t\tcin >> m;\n\t\t\tif(m==0){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tshortest_path(a,b,land);\n\t\t\t\tcout << land[b] << \"\\n\";\n\t\t\t} else if(m==1){\n\t\t\t\tint c,d,e;\n\t\t\t\tcin >> c >> d >> e;\n\t\t\t\tes[l].from=c;\n\t\t\t\tes[l].to=d;\n\t\t\t\tes[l].cost=e;\n\t\t\t\tes[l+1].from=d;\n\t\t\t\tes[l+1].to=c;\n\t\t\t\tes[l+1].cost=e;\n\t\t\t\tl+=2;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n*/\nvoid func(string str,vector<int>& a);\nconst int INF=10000000;\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector< vector<int> > wf(n+1,vector<int>(n+1));\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\twf[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\tif(i==j)wf[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i){\n\t\tstring str;\n\t\tvector<int> abcd(4);\n\t\tcin >> str;\n\t\tfunc(str,abcd);\n\t\twf[abcd[0]][abcd[1]]=abcd[2];\n\t\twf[abcd[1]][abcd[0]]=abcd[3];\n\t}\n\tvector<int> xy(4);\n\tstring hoge;\n\tcin >> hoge;\n\tfunc(hoge,xy);\n\tfor(int i=1; i<n+1; ++i){\n\t\tfor(int j=1; j<n+1; ++j){\n\t\t\tfor(int k=1; k<n+1; ++k){\n\t\t\t\twf[j][k]=min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << xy[2] << \" \" << xy[3] << \" \" << wf[xy[0]][xy[1]] << \" \" << wf[xy[1]][xy[0]] << \"\\n\";\n\tcout << xy[2]-xy[3]-wf[xy[0]][xy[1]]-wf[xy[1]][xy[0]] << \"\\n\";\n\treturn 0;\n}\n\nvoid func(string str,vector<int>& a){\n\tint n;\n\tn=str.size();\n\tint j=0;\n\tstring tmp;\n\tfor(int i=0; i<n; ++i){\n\t\tif(i==n-1){\n\t\t\ttmp+=str[i];\n\t\t\ta[j]=atoi(tmp.c_str());\n\t\t} else {\n\t\t\tif(str[i] != ','&&i!=n-1) {\n\t\t\t\ttmp+=str[i];\n\t\t\t} else{\n\t\t\t\ta[j]=atoi(tmp.c_str());\n\t\t\t\t++j;\n\t\t\t\ttmp=\"\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000\nusing namespace std;\n\nint main(){\n    int n,m,a,b,c,d;\n    char ch;\n    int cost[21][21];\n\n    for(int i=0;i<21;i++){\n        for(int j=0;j<21;j++){\n            cost[i][j]=INF;\n        }\n    }\n\n    cin>>n>>m;\n\n    for(int i=0;i<m;i++){\n        cin>>a>>ch>>b>>ch>>c>>ch>>d;\n        cost[a][b]=c;\n        cost[b][a]=d;\n    }\n\n    cin>>a>>ch>>b>>ch>>c>>ch>>d;\n\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n            }\n        }\n    }\n\n    cout<<c-cost[a][b]-cost[b][a]-d<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 20\n#define INF 1e9\nusing namespace std;\n\nint dp[MAX_N][MAX_N];\nint n,m;\n\nvoid warshall_froyd(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n    }\n  }\n}\n\nint main(){\n  cin >> n; \n  cin >> m;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dp[i][j] = (i==j ? 0 : INF);\n      dp[i][j] = (i==j ? 0 : INF);\n    }\n  }\n  \n  char camma;\n  for(int i=0;i<m;i++){\n    int a,b,atob,btoa;\n    cin >> a >> camma >> b >> camma >> atob >> camma >> btoa;\n    a--; b--;\n    dp[a][b] = atob; dp[b][a] = btoa;\n  }\n\n  warshall_froyd();\n\n  int start,goal,reward,price;\n  cin >> start >> camma >> goal >> camma >> reward >> camma >> price;\n  cout << reward - dp[start][goal] - price << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 10000000;\nint n,m;\nint data[101][101];\n\nvoid warshall_floyd() {\n  for ( int k = 0; k <= n; k++ ) {\n    for (int i = 0; i <= n; i++ ) {\n      for ( int j = 0; j <= n; j++ ) {\n\tdata[i][j] = min( data[i][j], data[i][k] + data[k][j] );\n      }\n    }\n  }\n}\n\nint main() {\n  for ( int i = 0; i < 101; i++ ) {\n    for ( int j = 0; j < 101; j++ ) {\n      if ( i == j ) data[i][j] = 0;\n      else data[i][j] = INF;\n    }\n  }\n  cin >> n;\n  cin >> m;\n  char ch;\n  for ( int i = 1; i <= m; i++ ) {\n    int a,b,c,d;\n    cin >> a >> ch >> b >> ch >> c >> ch >> d;\n    data[a][b] = c;\n    data[b][a] = d;\n  }\n  warshall_floyd();\n  int x1,x2,y1,y2; cin >> x1  >> ch >> x2 >> ch >> y1 >> ch >> y2;\n  \n  cout << y1 - y2 - data[x1][x2] - data[x2][x1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\tcin >> N;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &t, &s, &p, &q);\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[s] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp = p - q - D[t];\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[t] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - D[s] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconstexpr int M_MAX = 100;\nconstexpr int N_MAX = 20;\nconstexpr int INF = 1e8;\n\nint main()\n{\n  int n,m,a,b,c,d,s,g,V,P,reward;\n  struct edge {\n    edge(int t, int c)\n      : to_(t), cost_(c) {};\n    int to_;\n    int cost_;\n  };\n  vector<edge>G[M_MAX];\n  typedef pair<int,int> PII;\n  vector<int> q(N_MAX);\n  priority_queue<PII,vector<PII>,greater<PII>> que;\n\n  cin >> n;\n  cin >> m;\n  for (int i=0;i<m;++i) {\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    G[a].push_back(edge(b,c));\n    G[b].push_back(edge(a,d));\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\n  reward = V-P;\n\nfill(q.begin(),q.end(),INF);\n  que.push(PII(s,0));\n  q[s] = 0;\n\n  while(!que.empty()){\n    PII k  = que.top();\n    que.pop();\n    int l = k.first;\n\n    for(int i=0;i<G[l].size();i++){\n      edge r = G[l][i];\n      if(q[r.to_] > q[l] + r.cost_){\n        q[r.to_] = q[l] + r.cost_;\n        que.push(PII(r.to_, q[r.to_]));\n      }\n    }\n  }\n\n  reward = reward - q[g];\n\nfill(q.begin(),q.end(),INF);\n  que.push(PII(g,0));\n  q[g] = 0;\n\n  while(!que.empty()){\n    PII e = que.top();\n    que.pop();\n    int l = e.first;\n\n    for(int i=0;i<G[l].size();i++){\n      edge w = G[l][i];\n      if(q[w.to_] > q[l] + w.cost_){\n        q[w.to_] = q[l] + w.cost_;\n        que.push(PII(w.to_, q[w.to_]));\n      }\n    }\n  }\n\n  reward = reward - q[s];\n\n  cout << reward << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstruct edge { int to, cost; };\nvector<edge> G[21];\nint search(int start, int goal)\n{\n    //first := cost, second := now vertex\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> dist(21, INF);\n    que.push(P(0, start));\n    dist[start] = 0;\n    while(not que.empty())\n    {\n        P now = que.top(); que.pop();\n        if(now.second == goal) break;\n        if(d[now.second] < now.first) continue;\n        for(int u = 0; u < G[now.second].size(); u++)\n        {\n            edge e = G[now.second][u];\n            if(now.first + e.cost < dist[e.to])\n            {\n                dist[e.to] = now.first + e.cost;\n                que.push(P(dist[e.to], e.to));\n            }\n        }\n    }\n    return dist[goal];\n}\nint main()\n{\n    int n, m; cin >> n >> m;\n    for(int i = 0; i < m; i++)\n    {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a].push_back({b, c});\n        G[b].push_back({a, d});\n    }\n    int start, goal, v, p;\n    scanf(\"%d,%d,%d,%d\", &start, &goal, &v, &p);\n    int ans = v - p;\n    int a = search(start, goal);\n    int b = search(goal, start);\n    cout << ans - a - b << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cstdlib>\n#include<iomanip>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\nvoid Solution()\n{\n    int cost[22][22] = {{0}};\n    \n    int n, m;\n    int i, j, k;\n    int a, b, c, d;\n    \n    char comma;\n    \n    cin>>n>>m;\n    \n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n        {\n            cost[i][j] = 1<<28;\n        }\n    }\n    \n    for(i=0; i < m; i++)\n    {\n        cin>>a>>comma>>b>>comma>>c>>comma>>d;\n        \n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    \n    for(k=1;k<=n;k++)\n    {\n        for(i=1;i<=n;i++)\n        {\n            for(j=1;j<=n;j++)\n            {\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n            }\n        }\n        \n    }\n    \n    cin>>a>>comma>>b>>comma>>c>>comma>>d;\n    \n    cout<<c - d- cost[a][b] - cost[b][a]<<endl;\n}\n\nint main()\n{\n    Solution();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define INF 1 << 21\nusing namespace std;\ntypedef struct{\n  int to;int cost;\n}Edge;\ntypedef pair<int,int> P;\npriority_queue<P, vector<P>, greater<P> > pq;\nint main(){\n  int d[11111];\n  int n,m;\n  int ans;\n  char ch;\n  int a,b,c,z;\n  int st,go,hasira,money;\n  vector<Edge> G[111];\n  cin >> n;\n  cin >> m;\n  fill(d,d+m,INF);\n  for(int i=0;i<m;i++){\n    cin >> a >> ch >> b >> ch >> c >> ch >> z;\n    G[a].push_back( (Edge){ b,c});\n    G[b].push_back( (Edge){ a,z});\n  }\n  \n  cin >> st >> ch >> go >> ch >> money >> ch >> hasira;\n  d[st]=0;//出発地点の自明\n  pq.push(P(0,st));\n  \n  while(!pq.empty()){\n    P p=pq.top();\n    pq.pop();\n    int v=p.S;//使っていないところからの最短距離について調べる\n    if(d[v]<p.first)continue; //すでに今までのが小さいならみなくてもいい\n    for(int i=0;i<G[v].size()/*そこからつながっている道の数わかっちゃうやつ*/;i++){\n      Edge e=G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n\td[e.to] = d[v] + e.cost;\n\tpq.push(P(d[e.to],e.to));\n      }\n    }\n  }\n\n  ans=d[go];\n  \n  /*帰り道*/\n  fill(d,d+m,INF);\n\n  d[go]=0;//出発地点の自明\n  pq.push(P(0,go));\n  \n  while(!pq.empty()){\n    P p=pq.top();\n    pq.pop();\n    int v=p.S;//使っていないところからの最短距離について調べる\n    if(d[v]<p.first)continue; //すでに今までのが小さいならみなくてもいい\n    for(int i=0;i<G[v].size()/*そこからつながっている道の数わかっちゃうやつ*/;i++){\n      Edge e=G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n\td[e.to] = d[v] + e.cost;\n\tpq.push(P(d[e.to],e.to));\n      }\n    }\n  }\n  ans+=d[st];\n  \n  cout << money-ans-hasira << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21],minnum[21];\nint serch(int start,int finish,int money,int go,int now)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=minnum[now];i<=maxnum[now];i++){\n        if(place[now][i]>-1&&co[now][i]<2){\n            co[now][i]++;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=1;i<21;i++)minnum[i]=22;\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[1]],num[0]);\n\t    minnum[num[0]]=min(minnum[num[0]],num[1]);\n\t    minnum[num[1]]=min(minnum[num[1]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 2100000000\nusing namespace std;\nint glid[100][100];\nint kakutei[100],leng[100];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<=n;i++) {\n\t\tfor(j=0;j<=n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) glid[i][i]=0;\n\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n//\tcout<<start<<finish<<okane<<value<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t//\t\t\tmi=glid[point][j];\n\t\t\t}\n\t\t}\n\t//\tokane=okane-mi;\n\t}\n\t//for(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tokane-=leng[finish];\n\t//cout<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[finish]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t//\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t\t//mi=glid[point][j];\n\t\t\t}\n\t\t}\n\t\t//okane=okane-mi;\n\t}\n//\tfor(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tswap(start,finish);\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nvector<int> split_s2i(const std::string &str, char sep){\n  vector<int> v;\n  stringstream ss(str);\n  string buffer;\n  while(getline(ss, buffer, sep)){ v.push_back(stoi(buffer)); }\n  return v;\n}\n\nint main(void){\n  int n, m;\n  cin >> n;\n  cin >> m;\n\n  vector<vector<int> > dp(n, vector<int>(n, INF));\n  string input;\n  for(int i = 0; i < m; i++){\n    cin >> input;    \n    vector<int> inp = split_s2i(input, ',');\n    dp[inp[0] - 1][inp[1] - 1] = inp[2];\n    dp[inp[1] - 1][inp[0] - 1] = inp[3];\n  }\n  for(int i = 0; i < n; i++)\n    dp[i][i] = 0;\n\n  // ???????????£???????????????\n  for(int k = 0; k < n; k++)\n    for(int i = 0; i < n; i++)\n      for(int j = 0; j < n; j++)\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);  \n\n  // ?????¨?????????\n  cin >> input;\n  vector<int> query = split_s2i(input, ',');\n  int s = query[0] - 1;\n  int g = query[1] - 1;\n  int v = query[2];\n  int p = query[3];\n  int ans = v - (dp[s][g] + p + dp[g][s]);\n\n  // ??????\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = (1 << 20);\n\nint main(){\n    int n, m, x1, x2, y1, y2;\n    int G[25][25];\n    for(int i = 1; i <= 20; i++){\n        for(int j = 1; j <= 20; j++){\n            if( i == j ) G[i][j] = 0;\n            else G[i][j] = INF;\n        }\n    }\n    scanf(\"%d\\n%d\", &n, &m);\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            G[i][j] = INF;\n            if( i == j ) G[i][j] = 0;\n        }\n    }\n    while( m-- > 0 ){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a][b] = c;\n        G[b][a] = d;\n    }\n    for(int k = 1; k <= n; k++){\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                G[i][j] = min( G[i][j], G[i][k] + G[k][j] );\n            }\n        }\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    printf(\"%d\\n\", y1 - y2 - G[x1][x2] - G[x2][x1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n/*\n * Dijkstra's algorithm\n */\n\ntypedef int Y;\nconstexpr Y INF = numeric_limits<Y>::max() / 3;\n\n\nstruct Edge {\n    int to;\n    Y cost;\n\n    Edge () {}\n    Edge(int a,Y b): to(a), cost(b) {}\n} ;\n\n\nstruct State {\n    int pos;\n    Y cost;\n\n    State () {}\n    State(int a, Y b): pos(a), cost(b) {}\n} ;\n\nclass Dijkstra {\npublic:\n    vector<vector<Edge>> graph;\n    vector<Y> dist;\n    int N;\n\n    Dijkstra() {}\n\n    void init(int n) {\n        graph.clear();\n        graph.resize(N = n);\n        dist.resize(N);\n        fill(begin(dist), end(dist), INF);\n    }\n    \n    void add_edge(int from, int to, Y cost) {\n        graph[from].push_back(Edge(to, cost));\n    }\n\n    void shortest_path_from(int start) {\n        static auto y_comparator = [&](const State& a, const State& b) -> bool {\n            return a.cost > b.cost;\n        };\n\n        priority_queue<State, vector<State>, decltype(y_comparator)> pq(y_comparator);\n\n        dist[start] = 0;\n\n        pq.push(State(start, 0));\n\n        while (!pq.empty()) {\n            State s = pq.top(); pq.pop();\n            if (s.cost > dist[s.pos]) {\n                continue;\n            }\n\n            for (Edge& e: graph[s.pos]) {\n                if (e.cost + s.cost < dist[e.to]) {\n                    dist[e.to] = e.cost + s.cost;\n                    pq.push(State(e.to, dist[e.to]));\n                }\n            }\n        }\n    }\n\n} ;\n\nint N, M;\nDijkstra graph;\nint s, g, V, P;\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    graph.init(N);\n    for (int j = 0; j < M; ++j) {\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        --a; --b;\n        graph.add_edge(a, b, c);\n        graph.add_edge(b, a, d);\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    --s; --g;\n\n    graph.shortest_path_from(s);\n    int d1 = graph.dist[g];\n    graph.shortest_path_from(g);\n    int d2 = graph.dist[s];\n\n    cout << V - P - d1 - d2 << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 1e6\nusing namespace std;\n\nint main(){\n\tint n,m,a,b,c,d,s,g,v,p;\n\tscanf(\"%d %d\",&n,&m);\n\tint dist[n][n];\n\trep(i,n)rep(j,n)dist[i][j]=INF;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tdist[a-1][b-1]=c;\n\t\tdist[b-1][a-1]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<v-(dist[s-1][g-1]+dist[g-1][s-1]+p)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint city[21][21],n,load[21][21];\nint power(int n)\n{\n    int num=1;\n    for(int i=0;i<n;i++)num*=10;\n    return num;\n}\nint aserch(int endp,int now,int befor)\n{\n    int money=50000;\n    if(city[now][endp]!=-1)return city[now][endp];\n    else{\n        for(int i=1;i<=n;i++){\n                if(city[now][i]!=-1&&i!=befor&&load[now][i]!=1){\n                    load[now][i]++;\n                    money=min(aserch(endp,i,now)+city[now][i],money);\n                }\n        }\n    }\n    return money;\n}\nint bserch(int stap,int now,int befor)\n{\n    int money=50000,num;\n    if(city[now][stap]!=-1){\n        return city[now][stap];\n    }\n    else{\n        for(int i=1;i<=n;i++){\n            if(city[now][i]!=-1&&i!=befor&&load[now][i]!=2){\n                    load[now][i]++;\n                   num=bserch(stap,i,now)+city[now][i];\n                   if(num>-1)money=min(num,money);\n            }\n        }\n    }\n    return money;\n\n}\nint main()\n{\n    int m;\n    cin>>n>>m;\n    memset(city,-1,sizeof(city));\n    memset(load,0,sizeof(load));\n    string str;\n    for(int i=0;i<m;i++){\n        int kawa[2]={};\n        cin>>str;\n        for(int j=0,co=0,point=0;;j++){\n            if(str[j]==','||str[j]=='\\0'){\n                int mo=0;\n                if(co<2){\n                    for(int k=point;k<j;k++)kawa[co]+=(str[k]-'0')*power(j-k-1);\n                    point=j+1;\n                    co++;\n                }\n                else if(co==2){\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[0]][kawa[1]]=mo;\n                    point=j+1;\n                    co++;\n                }\n                else{\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[1]][kawa[0]]=mo;\n                    break;\n                }\n            }\n        }\n    }\n    cin>>str;\n    int pointing[3]={},Pillar=0;\n    for(int i=0,co=0,point=0;;i++){\n        if(str[i]==','){\n            for(int j=point;j<i;j++)pointing[co]+=(str[j]-'0')*power(i-j-1);\n            point=i+1;\n            co++;\n        }\n        if(str[i]=='\\0'){\n            for(int j=point;j<i;j++)Pillar+=(str[j]-'0')*power(i-j-1);\n            break;\n        }\n    }\n    m=pointing[2]-Pillar-aserch(pointing[1],pointing[0],0);\n    cout<<m-bserch(pointing[0],pointing[1],0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n, m, a, b, c, d, s[22][22], inf = 100000, i, j, k;\n\tchar temp;\n\tcin >> n;\n\tcin >> m;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j) {\n\t\t\t\ts[i][j] = inf;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tcin >> a >> temp >> b >> temp >> c >> temp >> d;\n\t\ts[a - 1][b - 1] = c;\n\t\ts[b - 1][a - 1] = d;\n\t}\n\tfor (k = 0; k < n; k++) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> a >> temp >> b >> temp >> c >> temp >> d;\n\tcout << c - d - s[a - 1][b - 1] -s[b-1][a-1]<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n\nstruct edge {\n\tint cost;\n\tint to;\n};\n\nll INF = 1000000000;\nint N,M,s,g,v,p;\nll d[110];\nvector<edge> G[110];\n\nvoid dijkstra(int s) {\n\tpriority_queue<pl, vector<pl>, greater<pl>> q;\n\tfill(d, d + N, INF);\n\td[s] = 0;\n\tq.push(pl(0, s));\n\n\twhile (!q.empty()) {\n\t\tpl p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(pl(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll ans = 0;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tG[a].push_back({c,b});\n\t\tG[b].push_back({d,a});\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--, g--;\n\tdijkstra(s);\n\tans += d[g];\n\tdijkstra(g);\n\tans += d[s];\n\tcout << v - p - ans << endl;\n\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int N, M; scanf(\"%d%d\", &N, &M);\n  static int wf[20][20];\n  for(int i = 0; i < N; i++)\n    for(int j = 0; j < N; j++)\n      wf[i][j] = 1000000000;\n  for(int i = 0; i < M; i++) {\n    int a,b,c,d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d); a--; b--;\n    wf[a][b] = c;\n    wf[b][a] = d;\n  }\n  int s,t,m1,m2; scanf(\"%d,%d,%d,%d\", &s, &t, &m1, &m2); s--; t--;\n  for(int k = 0; k < N; k++)\n    for(int i = 0; i < N; i++)\n      for(int j = 0; j < N; j++)\n        wf[i][j] = min(wf[i][j], wf[i][k]+wf[k][j]);\n  printf(\"%d\\n\", m1-m2-wf[s][t]-wf[t][s]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  REP(i,m) {\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n    a--;b--;\n    g[a].push_back(Edge(a,b,c));\n    g[b].push_back(Edge(b,a,d));\n  }\n  int s, d, y1, y2;\n  scanf(\"%d,%d,%d,%d\\n\",&s,&d,&y1,&y2);\n  s--;d--;\n  vector<int> dist;\n  int hoge;\n  shortestPath(g, s, dist);\n  hoge = dist[d];\n  shortestPath(g,dist[d],dist);\n  hoge += dist[s];\n  cout << y1 - y2 - hoge << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\twhile (cin >> N) {\n\t\tcin >> M;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\tx[a][b] = c;\n\t\t\tx[b][a] = d;\n\t\t}\n\t\tscanf(\"%d,%d,%d,%d\", &t, &s, &p, &q);\n\t\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\t\tD[s] = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = p - q - D[t];\n\t\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\t\tD[t] = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p - D[s] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<queue>\n#include<functional>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n#define INF (1 << 30)\nint n, m, a, b, c, d, x1, x2, y1, y2, cost[100][100], dist[100];\nint distanc(int start, int goal){\n    fill(dist, dist + n, INF);\n    dist[start] = 0;\n    priority_queue<P, vector<P>, greater<P> > PQ;\n    PQ.push(P(0, start));\n    while(!PQ.empty()){\n\tP tmp = PQ.top();PQ.pop();\n\tint from = tmp.second;\n\tif(dist[from] < tmp.first)continue;\n\tdist[from] = tmp.first;\n\tfor(int i = 0;i < n;i++){\n\t    if(cost[from][i] == INF)continue;\n\t    if(cost[from][i] + dist[from] <= dist[i])PQ.push(P(dist[from] + cost[from][i], i));\n\t}\n    }\n    return dist[goal];\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0;i < n;i++)\n\tfor(int j = 0;j < n;j++)\n\t    cost[i][j] = INF;\n    for(int i = 0;i < m;i++){\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\ta--;b--;\n\tcost[a][b] = c;\n\tcost[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    x1--;x2--;\n    int res = 0;\n    res += distanc(x1, x2);\n    res += distanc(x2, x1);\n    printf(\"%d\\n\", y1 - y2 - res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nclass WarshallFloyd {\npublic:\n    static const int inf = 1<<29;\n    int m_num;\n    vector<vector<int> > m;\n    void init(int n){\n        m_num = n;\n        m.resize(n);\n        REP(i,n){\n            m[i] = vector<int>(n,inf);\n            m[i][i] = 0;\n        }\n    }\n    void add(int u, int v, int e){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num || u == v);\n        m[u][v] = e;\n    }\n    void solve(){\n        int n = m_num;\n        REP(k,n) REP(i,n) REP(j,n)\n            m[i][j] = MIN(m[i][j], m[i][k] + m[k][j]);\n    }\n    int get(int u, int v){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num);\n        return m[u][v];\n    }\n};\n\nint main(){\n\n    int n, m;\n    string s;\n    cin >> n >> m;\n    WarshallFloyd wf;\n    wf.init(n);\n    REP(i,m){\n        cin >> s;\n        int a,b,c,d;\n        sscanf(s.c_str(), \"%d,%d,%d,%d\", &a, &b, &c, &d);\n\n        wf.add(a-1,b-1,c);\n        wf.add(b-1,a-1,d);\n    }\n    wf.solve();\n\n    cin >> s;\n    int fr,to,m1,m2;\n    sscanf(s.c_str(), \"%d,%d,%d,%d\", &fr, &to, &m1, &m2);\n\n    pr(wf.get(fr-1,to-1));\n    pr(wf.get(to-1,fr-1));\n\n    cout << m1 - (wf.get(fr-1,to-1) + wf.get(to-1,fr-1) + m2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n\nstruct e{\n\tint f,t,c;\n};\n\nint main(){\n\tint n,m,x[2],y1,y2,a,b,c,d,cost;\n\tint di[20];\n\te l[800];\n\tconst int inf = 9999999;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;\n\t\tb--;\n\t\tl[i*2].f=l[i*2+1].t=a;\n\t\tl[i*2].t=l[i*2+1].f=b;\n\t\tl[i*2].c=c;\n\t\tl[i*2+1].c=d;\n\t}\n\tcost=0;\n\trep(i,2){\n\t\trep(j,n)di[j]=inf;\n\t\tdi[x[i]-1]=0;\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\trep(j,m*2){\n\t\t\t\te t=l[j];\n\t\t\t\tif(di[t.f]<inf && di[t.t]>di[t.f]+t.c){\n\t\t\t\t\tdi[t.t]=di[t.f]+t.c;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost+=di[x[1-i]-1];\n\t}\n\tprintf(\"%d\\n\",y1-y2-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=10000000;\nint map[21][21];\n\nint main(void){\n\tint a,b,c;\n\tint d[4];\n\tint ans;\n\tint n,m;\n\tfor(a=0;a<=20;a++){\n\t\tfor(b=0;b<=20;b++){\n\t\t\tmap[b][a]=INF;\n\t\t\tif(b==a)map[b][a]=0;\n\t\t}\n\t}\n\tcin >> n;\n\tcin >> m;\n\tfor(a=0;a<m;a++){\n\t\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\t\tmap[d[0]][d[1]]=d[3];\n\t\tmap[d[1]][d[0]]=d[2];\n\t}\n\t/*for(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tprintf(\"%d \",map[b][a]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tfor(c=1;c<=n;c++){\n\t\t\t\tmap[a][b]=min(map[a][b],map[a][c]+map[c][b]);\n\t\t\t}\n\t\t}\n\t}\n\t/*for(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tprintf(\"%d \",map[b][a]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\tans=d[2]-d[3]-map[d[0]][d[1]]-map[d[1]][d[0]];\n\tcout << ans <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define REP(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\nconst int MAX_V = 20;\nconst int MAX_E = 500000;\nconst int INF = INT_MAX;\n\nstruct E{\n  int to, cost;\n  E(int t, int c) : to(t), cost(c) {};\n};\ntypedef pair<int, int> pii;\n\nint v;\nvector<E> g[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s)\n{\n  fill(d, d + v, INF);\n  d[s] = 0;\n  priority_queue<pii, vector<pii>, greater<pii> > q;\n  q.push(pii(0, s));\n  \n  while(!q.empty()){\n    pii p = q.top();\n    q.pop();\n    int from = p.second;\n    if(d[from] < p.first) continue;\n    \n    for(int i = 0; i < g[from].size(); ++i){\n      int to = g[from][i].to;\n      int cost = g[from][i].cost;\n      \n      if(d[to] > d[from] + cost){\n        d[to] = d[from] + cost;\n        q.push(pii(d[to], to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  REP(i, m){\n    int a1, b1, c1, d1;\n    scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n    g[a1].push_back(E(b1, c1));\n    g[b1].push_back(E(a1, d1));\n  }\n  v = n;\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  dijkstra(x1);\n  int go = d[x2];\n  dijkstra(x2);\n  int back = d[x1];\n  cout << y1 - go - back - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define INF 100000000\nusing namespace std;\n\nint main(){\n\tint d[20][20];\n\tint n,m,s,g,v,p;\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) d[i][j] = INF;\n\t\td[i][i] = 0;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b,c,e;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&e);\n\t\td[a - 1][b - 1] = c;\n\t\td[b - 1][a - 1] = e;\n\t}\n\tfor(int k = 0;k < n;k++){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++) d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\tcout << v - p - (d[s - 1][g - 1] + d[g - 1][s - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=(ll)a;i<(ll)n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V; /*?????§????????°*/\nstruct edge { int to, cost; };\ntypedef std::pair<int, int> PP;\n// ???cost??¨????????????????????¢\nstd::vector<edge> list[20];\nint d[20];\nvoid DIJX(int st) {\n\tfor (int i = 0; i<V; i++)d[i] = INF; // std::fill??§????????????\n\td[st] = 0; // ?§????\n\tstd::priority_queue<PP, std::vector<PP>, std::greater<PP>> pq;\n\tpq.push(std::make_pair(d[st], st)); // (cost,????????????)\n\twhile (!pq.empty()) {\n\t\tPP p = pq.top();\n\t\tpq.pop();\n\t\tint i = p.second; // cost???first??????????????????second\n\t\tif (d[i]<p.first)continue;\n\t\tfor (int k = 0; k<list[i].size(); k++) {\n\t\t\tedge e = list[i][k];\n\t\t\tif (d[e.to] <= d[i] + e.cost)continue;\n\t\t\td[e.to] = d[i] + e.cost;\n\t\t\tpq.push(std::make_pair(d[e.to], e.to));\n\t\t}\n\t}\n}\nint main() {\n\t\tint m, a, b, c,dd;\n\t\tstd::cin >> V;\n\t\tstd::cin >> m;\n\t\tchar c1, c2, c3;\n\t\tfor (int i = 0; i<m; i++) {\n\t\t\tstd::cin >> a >>c1>> b >>c2>> c>>c3>>dd;\t\n\t\t\tlist[a-1].push_back(edge { b-1, c });\n\t\t\tlist[b-1].push_back(edge{ a-1, dd });\n\t\t}\n\t\tint s, g, get, lost,ans=0;\n\t\tstd::cin >> s >>c1>> g >>c2>> get >>c3>> lost;\n\t\tans += get - lost;\n\t\tDIJX(s-1);\n\t\tans -= d[g-1];\n\t\tDIJX(g-1);\n\t\tans -= d[s - 1];\n\t\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\ntypedef pair<int,int> NODE;\n\nint dijk(int a,int b,int n, vector<vector<pair<int,int> > >info){\n\tpriority_queue<NODE,vector<NODE>,greater<NODE> > Q;\n\n\tvector<NODE> node(n);\n\tfor(int i=0;i<node.size();i++){\n\t\tnode[i].first  = INT_MAX;\n\t\tnode[i].second = i;\n\t}\n\t\n\tnode[a].first = 0;\t\n\tQ.push(node[a]);\n\n\twhile(!Q.empty()){\n\t\tNODE now = Q.top();\n\t\tQ.pop();\n\t\t\n\t\tfor(int i=0;i<info[now.second].size();i++){\n\t\t\tint to   = info[now.second][i].first;\n\t\t\tint cost = now.first + info[now.second][i].second;\n\t\t\t\n\t\t\tif(cost < node[to].first){\n\t\t\t\tnode[to].first = cost;\n\t\t\t\tQ.push(node[to]);\n\t\t\t}\n\t\t}\n\t}\n\treturn node[b].first;\n}\n\nint main(){\n\tint n,m,a,b,c,d,ret;\n\tcin >> n >> m;\n\t\t\n\tvector< vector< pair<int,int> > > info(n);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tinfo[a].push_back( make_pair(b,c) );\n\t\tinfo[b].push_back( make_pair(a,d) );\n\t}\n\n\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\ta--;b--;\n\t\t\n\tret = c-d;\n\n\tcout << ret - dijk(a,b,n,info) - dijk(b,a,n,info) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nint path[21][21];\n\nint main(){\n\tint n,m;\n\tmemset(path,0x3,sizeof(path));\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,cost_ab,cost_ba;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&cost_ab,&cost_ba);\n\t\tpath[a][b] = cost_ab;\n\t\tpath[b][a] = cost_ba;\n\t}\n\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tpath[i][j] = min(path[i][k] + path[k][j],path[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",y1 - path[x1][x2] - path[x2][x1] - y2);\n}"
  },
  {
    "language": "C++",
    "code": "//A Reward for a Carpenter\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\nusing namespace std;\n\nconst int inf = 1e9;\nint dis[30][30];\nint main(){\n    int n,m;\n    cin >> n>>m;\n    rep(i,n){\n        rep(j,n){\n            dis[i][j]=inf;\n        }\n    }\n    rep(i,n){\n        dis[i][i]=0;\n    }\n    rep(i,m){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\" ,&a,&b,&c,&d);\n        a--;\n        b--;\n        dis[a][b]=c;\n        dis[b][a]=d;\n    }\n    int x1,x2,y1,y2;\n    scanf(\"%d,%d,%d,%d\" ,&x1,&x2,&y1,&y2);\n    x1--;\n    x2--;\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                dis[i][j]=min(dis[i][j],min(inf,dis[i][k]+dis[k][j]));\n            }\n        }\n    }\n    \n    cout << -dis[x2][x1]-dis[x1][x2] + y1 - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define INF (1LL << 60)\nusing namespace std;\nbool used[200000]; long long dist[200000];\nvoid dijkstra(int V, int E, int s, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[s] = 0; Q.push(make_pair(0, s));\n\tint cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt > E) return; // NEGATIVE_CYCLE\n\t\tpair<long long, int> p = Q.top(); used[p.second] = true; Q.pop();\n\t\tfor (int i = 0; i < X[p.second].size(); i++) {\n\t\t\tint to = X[p.second][i].first; long long leng = X[p.second][i].second;\n\t\t\tif (dist[to] > dist[p.second] + leng && !used[to]) {\n\t\t\t\tdist[to] = dist[p.second] + leng;\n\t\t\t\tQ.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\nint V, E, a, b, c, d, f1, f2, g1, g2; vector<pair<int, int> > G[200000];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG[a - 1].push_back(make_pair(b - 1, c));\n\t\tG[b - 1].push_back(make_pair(a - 1, c));\n\t}\n\tscanf(\"%d,%d,%d,%d\", &f1, &f2, &g1, &g2); g1 -= g2;\n\tdijkstra(V, E, f1 - 1, G); g1 -= dist[f2 - 1];\n\tdijkstra(V, E, f2 - 1, G); g1 -= dist[f1 - 1];\n\tprintf(\"%d\\n\", g1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][21],int b[],int c,int e,int m){\n  int i;\n  if(c==e){\n    if(b[c]==-1||b[c]>m)\n      b[c]=m;\n  }else if(b[c]==-1||b[c]>m){\n    b[c]=m;\n    for(i=1;i<21;i++){\n      if(a[c][i])\n\tf(a,b,i,e,m+a[c][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  int a[21][21],b[21],m,n,v,w,x,y;\n  memset(a,0,sizeof(a));\n  cin>>n>>m;\n  for(i=0;i<m;i++){\n    int p,q,r,s;\n    scanf(\"%d,%d,%d,%d\",&p,&q,&r,&s);\n    a[p][q]=r;\n    a[q][p]=s;\n  }\n  scanf(\"%d,%d,%d,%d\",&v,&w,&x,&y);\n  memset(b,-1,sizeof(b));\n  f(a,b,v,w,0);\n  x-=b[w];\n  memset(b,-1,sizeof(b));\n  f(a,b,w,v,0);\n  x-=b[v];\n  cout<<x-y>0?x-y:0<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\nint X1,X2;\nint Y1,Y2;\nint a1,b1,c1,d1;\nint n;//町の総数\nint m;//街道の総数\nint cost[21][21];//町iから町jへの交通費\nconst int INF = 1000000;\nvoid warshall_floyd(){\n  for(int i = 1;i <=n;i++){\n    for(int j = 1;j <=n;j++){\n      for(int k = 1;k <=n;k++){\n\tcost[j][k] =min(cost[j][k],cost[j][i]+cost[i][k]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  cin >>n;\n  cin>>m;\n  for(int i = 1;i <=n;i++){\n    for(int j =1;j <=n;j++){\n      if(i!=j)\n\tcost[i][j] =INF;\n      else\n\tcost[i][j] = 0;\n    }\n  }\n  for(int i = 0;i < m;i++){\n    scanf(\"%d,%d,%d,%d\\n\",&a1,&b1,&c1,&d1);\n    cost[a1][b1] =c1;\n    cost[b1][a1] =d1;\n  }\n  warshall_floyd();\n  scanf(\"%d,%d,%d,%d\",&X1,&X2,&Y1,&Y2);\n  cout<<Y1-(Y2+cost[X1][X2]+cost[X2][X1])<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[y].cost;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[x].cost;\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\n\n\nint main(){\n    int n,m;\n    int a[20][20];\n    cin>>n>>m;\n    fill(&a[0][0],&a[20][20],INT_MAX/2);\n    for(int i=0;i<m;i++){\n        int b,c,d,e;\n        scanf(\"%d,%d,%d,%d\",&b,&c,&d,&e);\n        a[b][c]=d;\n        a[c][b]=e;\n    }\n    int s,g,gold,p;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&gold,&p);\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                if(a[i][t]>a[i][k]+a[k][t]){a[i][t]=a[i][k]+a[k][t];}\n            }\n        }\n    }\n    cout<<gold-p-a[s][g];\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stdio.h>\n\n#define N 20\n#define INF 10e6\n\nint main(void){\n    int cost[N][N];\n    int n,m;\n    int s,g,v,p;\n    \n    scanf(\"%d%d\", &n, &m);\n    for (int i=0; i<n; i++){\n        for (int j=0; j<n; j++){\n            cost[i][j] = INF;\n        }\n    }\n    for (int i=0; i<m; i++){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--;\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n    s--; g--;\n    // wf\n    for (int k=0; k<n; k++){\n        for (int i=0; i<n; i++){\n            for (int j=0; j<n; j++){\n                cost[i][j] = std::min(\n                    cost[i][j], cost[i][k]+cost[k][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\", v-p-cost[s][g]-cost[g][s]);\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 100000000;\nconst int MAX_N = 20;\nint dis[MAX_N + 1][MAX_N + 1];\nint main() {\n\tfor (int i = 0; i < MAX_N + 1; i++) {\n\t\tfor (int j = 0; j < MAX_N + 1; j++) {\n\t\t\tdis[i][j] = INF;\n\t\t}\n\t}\n\tint n, m;\n\tscanf(\"%d\",&n);\n  \tscanf(\"%d\",&m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdis[a][b] = c;\n\t\tdis[b][a] = d;\n\t}\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = y1 - y2 - dis[x1][x2] - dis[x2][x1];\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\tcin >> N;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tcin >> s >> t >> p >> q;\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[s] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << p - q - D[t] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF 1111111\nusing namespace std;\nint N;\nint A[100][100];\nvoid floyd(){\n  for(int k=0;k<=N;k++)\n    for(int i=0;i<=N;i++)\n      for ( int j=0;j<=N;j++)\n\tA[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n}\nint main(void){\n  int m,a,b,c,d,x1,x2,y1,y2;\n  scanf(\"%d\",&N);\n  for(int i=0;i<=N;i++)\n    for(int j=0;j<=N;j++)\n      A[i][j] = INF;\n  scanf(\"%d\",&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    A[a][b]=min(c,A[a][b]);\n    A[b][a]=min(d,A[a][b]);\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  floyd();\n  printf(\"%d\\n\",y1-(A[x1][x2]+A[x2][x1]+y2));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint main() {\n\twhile (cin >> N) {\n\t\tcin >> M;\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tx[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\tx[a][b] = c;\n\t\t\tx[b][a] = d;\n\t\t}\n\t\tscanf(\"%d,%d,%d,%d\", &t, &s, &p, &q);\n\t\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\t\tD[s] = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tif (x[j][k] != 0) {\n\t\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = p - q - D[t];\n\t\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\t\tD[t] = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tif (x[j][k] < 1145141919) {\n\t\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p - D[s] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define INFINITY 100000\nint cost[20][20];\n\nint dijkstra(int n, int s, int g){\n  set<int> S;\n  S.insert(s);\n  int distance[n];\n  REP(i,n)\n    distance[i] = cost[s][i];\n  while(S.find(g) == S.end()){\n    int sol,mindis=INFINITY;\n    REP(i,n)\n      if(S.find(i) == S.end()&&distance[i]<mindis){\n        mindis = distance[i];\n        sol = i;\n      }\n    S.insert(sol);\n    REP(i,n)\n      distance[i] = min(distance[i],distance[sol] + cost[sol][i]);\n  }\n  return distance[g];\n}\n\nint main(void){\n  int n,m,x1,x2,y1,y2;\n  REP(i,20)\n    REP(j,20)\n      cost[i][j] = (i!=j)?INFINITY:0;\n  cin>>n>>m;\n  while(m--){\n    int a,b,c,d;\n    cin>>a; getchar(); cin>>b; getchar(); cin>>c; getchar(); cin>>d;\n    cost[a-1][b-1] = c;\n    cost[b-1][a-1] = d;\n  }\n  cin>>x1; getchar(); cin>>x2; getchar(); cin>>y1; getchar(); cin>>y2;\n  cout << y1 - y2 - dijkstra(n,x1-1,x2-1) - dijkstra(n,x2-1,x1-1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v){\n    os << \"{ \";\n    for(typename vector<T>::const_iterator it=v.begin(); it!=v.end(); ++it)\n        os << '\\\"' << *it << '\\\"' << (it+1==v.end() ? \"\" : \", \");\n    os << \" }\";\n    return os;\n}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n#define vv(type,w,h,init) vector<vector<type>>(h,vector<type>(w,init))\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef unsigned uint;\ntypedef unsigned long ul;\ntypedef unsigned long long ull;\n\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define mp make_pair\n\nstring const resstr[] = {\"Impossible\",\"Possible\",\"No\",\"Yes\"};\n\nconst int MAX_V = 100;\n\nint cost[MAX_V][MAX_V];\n\nint V;\n\nvoid bm(){\n    rep(k,V)rep(i,V)rep(j,V){\n        cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n    }\n\n    // rep(i,V)rep(j,V){\n    //     // printf(\"%d -> %d %d\\n\", i,j, cost[i][j]);\n    // }\n}\n\nint main(){\n    rep(i,100)rep(j,100){\n        cost[i][j]=1<<29;\n    }\n    rep(i,100) cost[i][i]=0;\n\n    int E;\n    cin >> V >> E;\n    rep(i,E){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--,b--;\n        cost[a][b]=c, cost[b][a]=d;\n    }\n\n    bm();\n    int x1,x2,y1,y2; \n    scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n    x1--, x2--;\n\n    int dis = cost[x1][x2] + cost[x2][x1];\n    // cout << cost[x1][x2] << \" \" <<  cost[x2][x1] << endl;\n    cout << y1 - y2 - dis << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1000000\n\nint n, m;\nint cost[32][32];\nint x1, x2, y1, y2;\n\nvoid init() {\n\tfor(int i = 0; i < 32; i++)\n\t\tfor(int j = 0; j < 32; j++)\n\t\t\tcost[i][j] = INF;\n\tfor(int i = 0; i < 32; i++)\n\t\tcost[i][i] = 0;\n}\n\nvoid input() {\n\tint a, b, c, d;\n\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a - 1][b - 1] = c;\n\t\tcost[b - 1][a - 1] = d;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n}\n\nvoid warshall_floyd() {\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\tcost[j][k] = min(cost[j][i] + cost[i][k], cost[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve() {\n\twarshall_floyd();\n\treturn y1 - (y2 + cost[x1 - 1][x2 - 1] + cost[x2 - 1][x1 - 1]);\n}\n\nint main() {\n\tinit();\n\tinput();\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 2100000000\nusing namespace std;\nint glid[22][22];\nint kakutei[22],leng[22];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<=n;i++) {\n\t\tfor(j=0;j<=n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) glid[i][i]=0;\n\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n//\tcout<<start<<finish<<okane<<value<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t//\t\t\tmi=glid[point][j];\n\t\t\t}\n\t\t}\n\t//\tokane=okane-mi;\n\t}\n\t//for(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tokane-=leng[finish];\n\t//cout<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[finish]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t//\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t\t//mi=glid[point][j];\n\t\t\t}\n\t\t}\n\t\t//okane=okane-mi;\n\t}\n//\tfor(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tswap(start,finish);\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nconst int inf = 100000000;\n\nint main(){\n    int n,m,s,g,V,P,K[210][210],a,b,c,d;\n    cin >> n >> m;\n    for(int i = 0;i < 210;i++){\n        for(int j = 0;j < 210;j++){\n            K[i][j] = inf;\n        }\n    }\n    for(int i = 0;i < m;i++){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n    for(int k = 1;k <= n;k++){\n        for(int i = 1;i <= n;i++){\n            for(int j = 1;j <= n;j++){\n                if(K[i][j] > K[i][k] + K[k][j]){\n                    K[i][j] =  K[i][k] + K[k][j];\n                }\n            }\n        }\n    }\n    cout << V-P-K[s][g]-K[g][s] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\n\nint mini(int s,int t){\n  if(s>t){\n    return t;\n  }\n  return s;\n}\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++j)\n    {\n      K[i][j]=100100100;\n    }\n  }\n\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M;++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B]=C;\n    K[B][A]=D;\n    // cerr << \"read \" <<A<<\" \" << B << \" \" << C <<\" \"<< D <<endl;\n  }\n  for (int i = 1; i < N+1 ; ++i)\n  {\n    for (int j = 0; j < N+1; ++j)\n    {\n      for(int k=0;k<N+1;++k)\n      {\n        K[j][k]=mini(K[j][i]+K[i][k],K[j][k]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  // cout << K[x1][x2];\n  cout << y1-y2-K[x1][x2]-K[x2][x1] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint parse(string a) {\n\tint b = 0;\n\tfor (char c : a) {\n\t\tb *= 10; b += c - 48;\n\t}\n\treturn b;\n}\nvector<int>split(string a) {\n\tvector<int>b;\n\tstring c = \"\";\n\tfor (char d : a) {\n\t\tif (d == ',') { b.push_back(parse(c)); c = \"\"; }\n\t\telse c += d;\n\t}\n\tb.push_back(parse(c));\n\treturn b;\n}\nint main() {\n\tint a, b;\n\tcin >> a >> b;\n\tint c[100][100];\n\tfor (int g = 0; g<a; g++) {\n\t\tfor (int h = 0; h < a; h++) {\n\t\t\tif (g == h)c[g][h] = 0;\n\t\t\telse c[g][h] = 1<<29;\n\t\t}\n\t}\n\tfor (int d = 0; d < b; d++) {\n\t\tstring e;\n\t\tcin >> e;\n\t\tvector<int>f = split(e);\n\t\tf[0]--; f[1]--;\n\t\tc[f[0]][f[1]] = f[2];\n\t\tc[f[1]][f[0]] = f[3];\n\t}\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (int y = 0; y < a; y++) {\n\t\t\tfor (int z = 0; z < a; z++) {\n\t\t\t\tc[y][z] = min(c[y][z], c[y][x] + c[x][z]);\n\t\t\t}\n\t\t}\n\t}\n\tstring s;\n\tcin >> s;\n\tvector<int>q = split(s);\n\tq[0]--; q[1]--;\n\tcout << q[2] - q[3] - c[q[0]][q[1]] - c[q[1]][q[0]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++j)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=0;k<N;k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j])){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1-1][x2-1]-y2-K[x2-1][x1-1]<< endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n//#include <algorthm>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\nconst int MAX  = 1<<28;\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<vector<int> > map1(n,vector<int>(n,MAX));\n  //vector<vector<int> > map2(n,vector<int>(n,MAX));\n  for(int i = 0;i < m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    // cout << a << \" \"<<  b << \" \"<< c << \" \"<<  d << \" \" << endl;\n    map1[a-1][b-1] = c;\n    map1[b-1][a-1] = d;\n  }\n  //  cout << \"bababa\" << endl;\n  int x1,x2,y1,y2;\n  //  cin >> x1 >> x2 >> y1 >> y2;  \n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < n;j++){\n      for(int l = 0;l < n;l++){\n\tif(map1[i][j] > map1[i][l] + map1[l][j]){\n\t  map1[i][j] = map1[i][l] + map1[l][j];\n\t}\n      }\n    }\n  }\n  cout << y1 - (y2 + map1[x1-1][x2-1] + map1[x2-1][x1-1]) + 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint w[25][25];\n\nint main(){\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 1; i < 25; i++){\n\t\tfor (int  j = 1; j<25; j++){\n\t\t\tw[i][j] = 100000;\n\t\t} \n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d,%d,%d,&d\", &A, &B, &C, &D);\n\t\tw[A][B] = C;\n\t\tw[B][A] = D;\n\t}\n\tfor (int h = 1; h <= N; h++){\n\t\tfor (int i = 1; i <= N; i++){\n\t\t\tfor (int j = 1; j <= N; j++){\n\t\t\t\tif (w[i][j]>w[i][h] + w[h][j])w[i][j] = w[i][h] + w[h][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tcout << y1 - w[x1][x2] - y2 - w[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define INF 1 << 16\nusing namespace std;\n\nint main(){\n  int cost[20][20]; fill(&cost[0][0], &cost[0][0]+20*20, INF);\n  int n, m, a, b, c, d;\n  scanf(\"%d%d\", &n, &m);\n  rep(i, m){\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);--a;--b;\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n\n  rep(i, n) rep(j, n) rep(k, n)\n    cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n  int s, g, weges, value;\n  scanf(\"%d,%d,%d,%d\", &s, &g, &weges, &value);--s;--g;\n  printf(\"%d\\n\", weges - value - cost[s][g] - cost[g][s]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[y].cost;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(int j=0; j<n; j++){\n    int r = 0,p = 9999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n  }\n  ans_cost+=vil[x].cost;\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint K[20][20];\nint n,m,a,b,c,d;\nint Floyd(int K[20][20],int n) {\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]) {\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\\n\",&n);\n\tscanf(\"%d\\n\",&m);\n\tcout << n << \" \" << m << endl;\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<n; ++j) {\n\t\t\tK[i][j] = 40000;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\tK[a-1][b-1] = c;\n\t\tK[b-1][a-1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tFloyd(K,n);\n\tcout << c-d-K[a-1][b-1]-K[b-1][a-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint city[21][21],n,load[21][21];\nint power(int n)\n{\n    int num=1;\n    for(int i=0;i<n;i++)num*=10;\n    return num;\n}\nint aserch(int endp,int now,int befor)\n{\n    int money=50000;\n    if(city[now][endp]!=-1)return city[now][endp];\n    else{\n        for(int i=1;i<=n;i++){\n                if(city[now][i]!=-1&&i!=befor&&load[now][i]!=1000){\n                    load[now][i]++;\n                    money=min(aserch(endp,i,now)+city[now][i],money);\n                }\n        }\n    }\n    return money;\n}\nint bserch(int stap,int now,int befor)\n{\n    int money=50000,num;\n    if(city[now][stap]!=-1){\n        return city[now][stap];\n    }\n    else{\n        for(int i=1;i<=n;i++){\n            if(city[now][i]!=-1&&i!=befor&&load[now][i]!=2000){\n                    load[now][i]++;\n                   num=bserch(stap,i,now)+city[now][i];\n                   if(num>-1)money=min(num,money);\n            }\n        }\n    }\n    return money;\n\n}\nint main()\n{\n    int m;\n    cin>>n>>m;\n    memset(city,-1,sizeof(city));\n    memset(load,0,sizeof(load));\n    string str;\n    for(int i=0;i<m;i++){\n        int kawa[2]={};\n        cin>>str;\n        for(int j=0,co=0,point=0;;j++){\n            if(str[j]==','||str[j]=='\\0'){\n                int mo=0;\n                if(co<2){\n                    for(int k=point;k<j;k++)kawa[co]+=(str[k]-'0')*power(j-k-1);\n                    point=j+1;\n                    co++;\n                }\n                else if(co==2){\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[0]][kawa[1]]=mo;\n                    point=j+1;\n                    co++;\n                }\n                else{\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[1]][kawa[0]]=mo;\n                    break;\n                }\n            }\n        }\n    }\n    cin>>str;\n    int pointing[3]={},Pillar=0;\n    for(int i=0,co=0,point=0;;i++){\n        if(str[i]==','){\n            for(int j=point;j<i;j++)pointing[co]+=(str[j]-'0')*power(i-j-1);\n            point=i+1;\n            co++;\n        }\n        if(str[i]=='\\0'){\n            for(int j=point;j<i;j++)Pillar+=(str[j]-'0')*power(i-j-1);\n            break;\n        }\n    }\n    cout<<pointing[2]-Pillar-aserch(pointing[1],pointing[0],0)-bserch(pointing[0],pointing[1],0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define min(a,b)((a)<=(b)?(a):(b))\nint n,m;\nint a,b,c,d;\nint x1,x2,y1,y2;\nint cost[20][20];\nint main() {\n\tmemset(cost,0x10,sizeof(cost));\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\trep(i,m) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tcost[a][b]=c;\n\t\tcost[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tx1--;x2--;\n\trep(k,n)rep(i,n)rep(j,n) {\n\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t}\n\tprintf(\"%d\\n\",y1-(cost[x1][x2]+cost[x2][x1]+y2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint n;\nint dst[100][100];\n\nint v[100];\nint c[100];\nint M = 1001001001;\n\n\nint dijkstra(int a){\n\tfor(int i=0; i<100; i++){\n\t\tv[i] = M;\n\t\tc[i] = 0;\n\t}\n\tint t[100];\n\tt[0] = a;\n\tv[a] = 0;\n\tint ns = 0, nn = 1;\n\twhile(nn>0){\n\t\tint mn = M;\n\t\tint mnx = 0;\n\t\tfor(int i=ns; i<ns+nn; i++){\n\t\t\tif(v[t[i]]<mn){\n\t\t\t\tmn = v[t[i]];\n\t\t\t\tmnx = i;\n\t\t\t}\n\t\t}\n\t\tint tmp = t[ns];\n\t\tt[ns] = t[mnx];\n\t\tt[mnx] = tmp;\n\t\tint x = t[ns];\n\t\tns++;\n\t\tnn--;\n\n\t\tc[x] = 1;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(dst[x][i]<M && c[i]==0){\n\t\t\t\tif(v[x]+dst[x][i] < v[i]){\n\t\t\t\t\tv[i] = v[x]+dst[x][i];\n\t\t\t\t\tt[ns+nn] = i;\n\t\t\t\t\tnn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tdst[i][j] = M;\n\t\t}\n\t}\n\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdst[a-1][b-1] = c;\n\t\tdst[b-1][a-1] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = 0;\n\tdijkstra(x1-1);\n\tans += v[x2-1];\n\tdijkstra(x2-1);\n\tans += v[x1-1];\n\tcout << y1 - y2 - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<queue>\n\nconst int INFTY = 1 << 22;\nusing namespace std;\n\nclass Town{\npublic:\n  Town(){\n    this->init();\n  }\n  void init(void){\n    this->cost = INFTY;\n    this->done = false;\n  }\n  int cost;\n  bool done;\n  vector<int> vcon;\n  vector<int> vcost;\n  bool operator <(const Town *t) const{\n    return cost < t->cost;\n  };\n};\n\nvoid Dijkstra( map<int, Town> &G, int st ){\n  priority_queue<Town*> q;\n  Town *pt;\n\n  G[st].cost = 0;\n  q.push( &G[st] );\n\n  while( !q.empty() ){\n    pt = q.top();\n    q.pop();\n    if( pt->done ){\n      continue;\n    }\n    pt->done = true;\n\n    for(int i = 0; i < pt->vcon.size(); i++){\n      G[ pt->vcon[i] ].cost = min( G[ pt->vcon[i] ].cost, pt->cost + pt->vcost[i] );\n      /*if( G[ pt->vcon[i] ].done ){\n\tcontinue;\n\t}*/\n      q.push( &G[ pt->vcon[i] ] );\n    }\n  }\n}\nvoid ResetGraph( map<int, Town> &G, vector<int> &V){\n  for(int i = 0; i < V.size(); i++ ){\n    G[ V[i] ].init();\n  }\n}\nint main(void){\n  int n,m;\n  int s,g;\n  int money,pay;\n  map<int, Town> G;\n  vector<int> V;\n\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 0; i < m; i++){\n    int a,b,c,d;\n\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    V.push_back( a );\n    V.push_back( b );\n    G[a].vcon.push_back( b );\n    G[a].vcost.push_back( c );\n    G[b].vcon.push_back( a );\n    G[b].vcost.push_back( d );\n  }\n  scanf(\"%d,%d,%d,%d\", &s, &g, &money, &pay);\n\n  Dijkstra( G , s );\n  /*for(int i = 0; i < 6; i++){\n    cout << i+1 << \":\\n\";\n    for(int j=0; j<G[i+1].vcon.size();j++){\n      cout << G[i+1].vcon[j] << \" \";\n      }\n    cout << '\\n';\n    }*/\n\n  money -= pay;\n  money -= G[ g ].cost;\n\n  ResetGraph( G , V );\n  Dijkstra( G , g );\n\n  money -= G[ s ].cost;\n\n  cout << money << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int  MAX_C = 21;\nconst long long  INF = (1<<30);\n\nlong long edge[MAX_C][MAX_C];\nlong long cost[MAX_C];\nint come[MAX_C];\n\nlong long n,m;\n\nlong long solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      long long from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    long long  start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\n#define MAX_V 20 //最大頂点数\n\nstruct edge{\n  int to,cost;\n  edge(int _to,int _cost){to=_to;cost=_cost;}\n};\n\nint V; //頂点数\nvector <edge> G[MAX_V];\nint d[MAX_V]; //頂点sからの最短距離\n\nvoid dij(int s){\n  priority_queue<pii,vector<pii>,greater<pii> > q;\n  fill(d,d+V,INF);\n  d[s]=0;\n  q.push(pii(0,s));\n\n  while(!q.empty()){\n    pii p=q.top(); q.pop();\n    int v=p.second; //secondは頂点の番号\n    if(d[v]<p.first) continue; //firstは最短距離\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tq.push(pii(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  int m; //道の総数\n  cin>> V>> m;\n  for(int i=0;i<m;i++){\n    int a1,b1,c1,d1;\n    scanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n    G[a1-1].pb(edge(b1-1,c1));\n    G[b1-1].pb(edge(a1-1,d1));\n  }\n  int x1,x2,y1,y2;\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  dij(x1-1);\n  int go=d[x2-1];\n  dij(x2-1);\n  int back=d[x1-1];\n  int ans=y1-go-back-y2;\n  cout<< ans<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<vector <int>> G;\n\nvoid create_edge(int a, int b, int c, int d);\nint search(int st, int go);\n\n\nint main(){\n\n  int n,m;\n  int start;\n  int goal;\n  int money;\n  int pay;\n  int g_money,b_money;\n  int sarary;\n  \n    \n  cin >> n;\n  cin >> m;\n  //cout << \"ihjiwohjwi\" << endl;\n  \n  G = vector <vector<int>>(20,vector<int>(20,1001));\n  \n  // cout << \"1\" << endl;\n\n  for(int i = 0; m>i; ++i){\n    int a,b,c,d;\n    \n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    create_edge(a,b,c,d);\n  }\n\n  //cout << \"2\" << endl;\n\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&pay);\n  \n  // cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n\n  g_money = search(start, goal);\n  b_money = search(goal, start);\n  \n  sarary = money - (g_money + b_money + pay);\n  \n  //cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n \n  cout << sarary << endl;\n  \n  \n}\n\n\n\nvoid create_edge(int a, int b, int c, int d){\n\n  G[a][b] = c;\n  G[b][a] = d;\n\n}\n\n\n\nint search(int st, int go){\n\n  int current;\n  \n  typedef pair < int, int > PII;\n  vector <int>  cost(100, 1001);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  //cout << \"search\" << endl;\n  que.push(PII(0,st));\n  cost[st] = 0;\n  \n  \n  while(!que.empty()){\n    current = que.top().second;\n    que.pop();\n\n    for(int k=0; k<20; k++){\n      int temp;\n      temp = G[current][k] + cost[current];\n\n      if(G[current][k] != 1001 && temp < cost[k]){\n\tque.push(PII(temp,k));\n\tcost[k] = temp;\n      }\n    }  \t\t \n  }\n  \n  return cost[go];\n}\n      \n  \n\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n, m;\n  cin >> n >> m;\n\n  const int INF = 1 << 30;\n  int dis[20][20];\n  fill((int*)dis, (int*)(dis + n), INF);\n  for (int i = 0; i < n; i++) dis[i][i] = 0;\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    char ch;\n    cin >> a >> ch >> b >> ch >> c >> ch >> d;\n    a--, b--;\n    dis[a][b] = c;\n    dis[b][a] = d;\n  }\n  for (int k = 0; k < n; k++) {\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (dis[i][k] == INF || dis[k][j] == INF) continue;\n        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n      }\n    }\n  }\n  int s, g, V, P;\n  char ch;\n  cin >> s >> ch >> g >> ch >> V >> ch >> P;\n  s--, g--;\n  cout << V - P - dis[s][g] - dis[g][s] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int INF=100000000;\nint dp[20][20];\nint main(){\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      if(i!=j) dp[i][j]=INF;\n    }\n  }\n  int n,m,s,g,V,P;\n  scanf(\"%d\",&n);\n  scanf(\"%d\",&m);\n  int a,b,c,d;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    dp[a][b]=c;\n    dp[b][a]=d;\n  }\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n  s--;g--;\n  int ans=V-P-dp[s][g]-dp[g][s];\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n\nint main(void){\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int> > town(n+1,vector<int>(n+1,1000));\n  \n  int a,b,c,d;\n  for(int i = 0 ; i < m ; i ++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    town[a][b] = c;\n    town[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  \n  int start = a;\n  int end = b;\n  \n  int get = c;\n  int lose = d;\n  \n  int max = 0;\n  /*\n  rep(i,town.size()){\n    cout<<i<< \" : \";\n    rep(j,town[i].size()){\n      printf(\"%4d \",town[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int k = 1 ; k < m-1 ; k ++){\n    for(int i = 1 ; i < n+1 ; i ++){\n      for(int j = 1 ; j < n+1 ; j ++){\n        town[i][j]=min(town[i][j],town[i][k]+town[k][j]);\n      }\n    }\n  }\n  //cout<<town[start][end]<<\" \"<<town[end][start]<<endl;\n  cout<<get-lose-town[start][end]-town[end][start]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n\nstruct e{\n\tint f,t,c;\n};\n\nint main(){\n\tint n,m,x[2],y1,y2,a,b,c,d,cost;\n\tint di[20];\n\te l[800];\n\tconst int inf = 9999999;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;\n\t\tb--;\n\t\tl[i*2].f=l[i*2+1].t=a;\n\t\tl[i*2].t=l[i*2+1].f=b;\n\t\tl[i*2].c=c;\n\t\tl[i*2+1].c=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",x,x+1,&y1,&y2);\n\tcost=0;\n\trep(i,2){\n\t\trep(j,n)di[j]=inf;\n\t\tdi[x[i]-1]=0;\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\trep(j,m*2){\n\t\t\t\te t=l[j];\n\t\t\t\tif(di[t.f]<inf && di[t.t]>di[t.f]+t.c){\n\t\t\t\t\tdi[t.t]=di[t.f]+t.c;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost+=di[x[1-i]-1];\n\t}\n\tprintf(\"%d\\n\",y1-y2-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  REP(i,m) {\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n    a--;b--;\n    g[a].push_back(Edge(a,b,c));\n    g[b].push_back(Edge(b,a,d));\n  }\n  int s, d, y1, y2;\n  scanf(\"%d,%d,%d,%d\\n\",&s,&d,&y1,&y2);\n  s--;d--;\n  vector<int> dist;\n  int hoge;\n  shortestPath(g, s, dist);\n  hoge = dist[d];\n  shortestPath(g,d,dist);\n  hoge += dist[s];\n  cout << y1 - y2 - hoge << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tint g[30][30];\n\tREP(i, n)REP(j, n) g[i][j] = (i == j ? 0 : INF);\n\tREP(i, m)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tg[a][b] = c;\n\t\tg[b][a] = d;\n\t}\n\tREP(k, n)REP(i, n)REP(j, n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\tint a, b, c, d; \n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\ta--; b--;\n\tcout << c - d - g[a][b] - g[b][a] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n#define rep(i,a) for(i=0;i<a;i++)\n#define LL long long int\n#define MAX_VAL 2100000000\nusing namespace std;\nLL dist[114][114];\nint main(void)\n{\n\tint n,m,i,j,k;\n\tint a,b,c,d;\n\tint s,g,v,p;\n\tcin>>n>>m;\n\trep(i,n)rep(j,n)dist[i][j]=MAX_VAL;\n\trep(i,n)dist[i][i]=0;\n\trep(i,m) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--,b--;\n\t\tdist[a][b]=c,dist[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--,g--;\n\trep(k,n)rep(i,n)rep(j,n) dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\t\n\tcout<<v-p-dist[s][g]-dist[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#define inf 999\n\nusing namespace std;\n\nbool check(int *a, int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tif(a[i] == 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint dij(int **a, int n, int s, int t)\n{\n\tint *label, current = s, next, *cost;\n\t\n\tlabel = (int *)calloc(n+1, sizeof(int));\n\tcost = (int *)calloc(n+1, sizeof(int));\n\tlabel[current] = 1;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcost[i] = a[current][i];\n\t}\n\t\n\twhile(check(label, n)){\n\t\tfor(int i = 1, min = inf; i <= n; i++){\n\t\t\tif(min > cost[i] && label[i] == 0){\n\t\t\t\tmin = cost[i];\n\t\t\t\tnext = i;\n\t\t\t}\n\t\t}\n\t\tlabel[next] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(label[i] == 0 && cost[i] > (a[next][i]+cost[next])){\n\t\t\t\tcost[i] = a[next][i] + cost[next];\n\t\t\t}\n\t\t}\n\t\tcurrent = next;\n\t}\n\tnext = cost[t];\n\t\n\tfree(cost);\n\tfree(label);\n\t\n\treturn next;\n}\n\nint main(int argc, char **argv)\n{\n\tint n, m, **ary, a, b, c, d;\n\t\n\twhile(cin >> n >> m){\n\t\n\tary = (int **)calloc(n+1, sizeof(int));\n\tfor(int i = 1; i <= n; i++){\n\t\tary[i] = (int *)calloc(n+1, sizeof(int));\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tary[a][b] = c;\n\t\tary[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i != j && ary[i][j] == 0){\n\t\t\t\tary[i][j] = ary[j][i] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tc -= dij(ary, n, a, b);\n\tc -= d;\n\tc -= dij(ary, n, b, a);\n\tcout << c << endl;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfree(ary[i]);\n\t}\n\tfree(ary);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits> // int ???????????§????????????????????????\nusing namespace std;\nconst int MAX_V = 100000; // ???????????°????????§???\nconst int MAX_E = 500000; // ????????°????????§???\nconst int INF = 10000; // ???????????§?????????(int ???????????§???)\nstruct E {\n  int to, cost;\n  E(int t, int c) : to(t), cost(c) {};\n};\ntypedef pair<int, int> pii;\nint v; // ????????°\nvector<E> g[MAX_V]; // ??£??\\?????????\nint d[MAX_V]; // ??????s ????????????????????¢\nvoid dijkstra(int s)\n{\n  // ??????\n  fill(d, d + v, INF);\n  d[s] = 0;\n  // greater<pii>??§first ????°???????????????????????????????????????????\n  priority_queue<pii, vector<pii>, greater<pii> > q;\n  q.push(pii(0, s));\n  // ??????s ????????????????????????????????¢????¨????\n  while(!q.empty()){\n    // ???????¢???????????????????????????????????????¢???????°???????????????¢???\n    // ?????????????????¢???????????????????????¢????¢??????????\n    pii p = q.top();\n    q.pop();\n    int from = p.second;\n    if(d[from] < p.first)continue; // ???????????¢??§??????????????°??????\n    // ???????????§????????°??????from ??????????????¢?¢????\n    // ???????????¢????¢?????????????????????£??\\????????????????????±?????´??°\n    for(int i = 0; i < g[from].size(); ++i){\n      int to = g[from][i].to;\n      int cost = g[from][i].cost;\n      if(d[to] > d[from] + cost){ // ???????????¢??¨??????????????´???\n\td[to] = d[from] + cost;\n\tq.push(pii(d[to], to)); // ???????????¢???????£?????????????????????\\\n      }\n    }\n  }\n}\n\n\nint main()\n{\n  // ??\\??????????????????gv ??????????????°???ge ???????????°???gr ????§????\n  int gv, ge, gr;\n  cin >> gv >> ge;\n  v = gv;\n  //fill(&g[0][0], &g[v][0], INF); // ??£??\\??????????????????\n  for(int i = 0; i < ge; ++i){\n    // ??\\??????????????????gs ??????????§???????gt ??????????????????gd ???????????????\n    int gs, gt, gd,gd2;\n    //cin >> gs >> gt >> gd >> gd2;\n    scanf(\"%d,%d,%d,%d\",&gs,&gt,&gd,&gd2);\n    //printf(\"%d,%d,%d,%d\",gs,gt,gd,gd2);\n\n    g[gs-1].push_back(E(gt-1,gd)); // 2 ???????????????????????±????¨????\n    g[gt-1].push_back(E(gs-1,gd2));\n  }\n\n  int goal,okane,daikin;\n\n  //cin >> gr >> goal >> okane >> daikin;\n  scanf(\"%d,%d,%d,%d\",&gr,&goal,&okane,&daikin);\n\n\n  dijkstra(gr-1);\n  int kane=d[goal-1];\n  dijkstra(goal-1);\n  kane+=d[gr-1];\n\n  // ??????????????????gr ????????????????????????????????¢\n\n  cout << (okane-kane-daikin) << endl;\n    \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main(){\n\tint cityNum,roadNum;\n\tint city[20];\n\tint road[190][2];\n\tint roadCost[190][2];\t//0:0-1 1:1-0\n\n\tint i,j;\n\tint start,goal,money,hashira;\n\tbool flg;\n\n\tcin>>cityNum>>roadNum;\n\tfor(i=0;i<roadNum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&road[i][0],&road[i][1],&roadCost[i][0],&roadCost[i][1]);\n\t\troad[i][0]--;road[i][1]--;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&money,&hashira);\n\tstart--;goal--;\n\t\n\t\n\tfor(i=0;i<cityNum;i++) city[i]=1000000;\n\tcity[start]=0;\n\tdo{\n\t\tflg=false;\n\t\tfor(i=0;i<roadNum;i++){\n\t\t\tfor(j=0;j<2;j++){\n\t\t\t\tif(city[road[i][j]]+roadCost[i][j]<city[road[i][1-j]]){\n\t\t\t\t\tcity[road[i][1-j]]=city[road[i][j]]+roadCost[i][j];\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(flg);\n\t\n\tcout<<money-hashira-city[goal]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nqueue<int> now_n,go_n,money_n;\nint serch(int start,int finish,int money,int go,int now)\n{\n\tif(money<=0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(place[now][i])ans=max(ans,serch(start,finish,money-place[now][i],go,i));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tchar a;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tplace[num[0]][num[1]]=num[2];\n\t\tplace[num[1]][num[0]]=num[3];\n\t}\n\tint get[4];\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int INF=100100100;\nusing namespace std;\nint n,m;\nint K[32][32];\n\nint main(){\n\n  scanf(\"%d%d\", &n,&m);\n  \n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      K[i][j]=INF;\n    }\n  }\n  int a,b,c,d;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    K[a][b]=c;\n    K[b][a]=d;\n  }\n  int start,goal,inp,val;\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&inp,&val);\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(K[i][j] > K[i][k]+K[k][j]){\n\t  K[i][j]=K[i][k]+K[k][j];\n\t}\n      }\n    }\n  }\n  int ans=inp-val-K[start][goal]-K[goal][start];\n  printf(\"%d\\n\",ans);\n}\n\n  \n  \n    \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 99999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<int> d;\nvector< vector<SEdge> > G;\n\nvoid Dijkstra(int s)\n{\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, s));\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = G[v][i];\n\t\t\tif(d[e.To] > d[v] + e.Cost)\n\t\t\t{\n\t\t\t\td[e.To] = d[v] + e.Cost;\n\t\t\t\tPQue.push(P(d[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tcin >> V >> E;\n\td.resize(V);\n\tG.resize(V);\n\tfor(int i = 0; i < E; ++i)\n\t{\n\t\tint From, To, Cost1, Cost2;\n\t\tscanf(\"%d,%d,%d,%d\", &From, &To, &Cost1, &Cost2);\n\t\t--From;\n\t\t--To;\n\t\tSEdge e1, e2;\n\t\te1.To = To;\n\t\te2.To = From;\n\t\te1.Cost = Cost1;\n\t\te2.Cost = Cost2;\n\t\tG[From].push_back(e1);\n\t\tG[To].push_back(e2);\n\t}\n\tint sum = 0;\n\tint x[2], y[2];\n\tscanf(\"%d,%d,%d,%d\", &x[0], &y[0], &x[1], &y[1]);\n\t--x[0];\n\t--y[0];\n\tDijkstra(x[0]);\n\tsum += d[y[0]];\n\tDijkstra(y[0]);\n\tsum += d[x[0]];\n\tcout << x[1] - y[1] - sum << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nint road[22][22];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++)if(place[now][i]>-1&&i!=before)ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n\nconst int INF = 1 << 30;\t\ntypedef std::pair<int, int> P;\nstruct edge{ \n\tint to, cost; \n\n\tedge(int to, int cost)\n\t\t: to(to), cost(cost)\n\t{}\n};\nconst int V = 20;\nstd::vector<edge> G[V];\nint d[V];\n\nvoid dijkstra(int s){\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> que;\n\tstd::fill(d, d + V, INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); ++i){\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i != m; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, d));\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tdijkstra(x1);\n\ty1 -= d[x2];\n\tdijkstra(x2);\n\ty1 -= d[x1];\n\ty1 -= y2;\n\tprintf(\"%d\\n\", y1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nmain(){\n  int n,a,b,c,d,M[22][22],i,j,k;\n  std::cin>>n>>k;\n  for(i=0;i++<n;)for(j=0;j++<n;)M[i][j]=1<<29;\n  for(;k+1;){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    if(k--){M[a][b]=c;M[b][a]=d;}\n  }\n  for(k=0;k++<n;)for(i=0;i++<n;)for(j=0;j++<n;)\n    M[i][j]=std::min(M[i][j],M[i][k]+M[k][j]);\n  printf(\"%d\\n\",c-d-M[a][b]-M[b][a]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <iostream>\n#define rep(i,n) for(int i = 0;i<(n);i++)\nconst int inf = 1001001001;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M;\nint X1,X2,Y1,Y2;\nint mindist[22];\nvector<pair<int,int> > G[22];\n\nvoid dijkstra(int s){\n\trep(i,22){\n\t\tmindist[i] = inf;\n\t}\n\tmindist[s]=0;\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(P(0,s));\n\twhile(!Q.empty()){\n\t\tP p = Q.top(); Q.pop();\n\t\tint v = p.second;\n\t\tif(mindist[v] < p.first) continue;\n\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\tP e = G[v][i];\n\t\t\tif(mindist[e.first] > mindist[v] + e.second){\n\t\t\t\tmindist[e.first] = mindist[v] + e.second;\n\t\t\t\tQ.push(P(mindist[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tscanf(\"%d\",&M);\n\trep(i,M){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,d));\n\t}\n\tscanf(\"%d,%d,%d,%d\",&X1,&X2,&Y1,&Y2);\n\tint cost = 0;\n\tdijkstra(X1);\n\tcost += mindist[X2];\n\t//cout << cost << endl;\n\tdijkstra(X2);\n\tcost += mindist[X1];\n\t//cout << cost << endl;\n\tcout << Y1 - cost - Y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define INF 10000000\n\nint n,m,x1,x2,y1,y2;\nint fee[21][21];\nint ans[21][21];\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n\n  for(int i=1; i<=n; i++){\n    for(int j=1; j<=n; j++){\n      fee[i][j] = i==j?0:INF;\n    }\n  }\n\n  for(int i=0; i<m; i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    fee[a][b] = c;\n    fee[b][a] = d;\n  }\n\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n  for(int k=1; k<=n; k++){\n    for(int i=1; i<=n; i++){\n      for(int j=1; j<=n; j++){\n\tif(fee[i][j] > fee[i][k]+fee[k][j]){\n\t  fee[i][j] = fee[i][k]+fee[k][j];\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\", y1-y2-fee[x1][x2]-fee[x2][x1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    rep(i, m) {\n        int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/* #include <iostream> */\n/* #include <vector> */\nusing namespace std;\n#define _GLIBCXX_DEBUG\n\nconst int INF = 1001001001;\ntemplate <typename itr> void output(itr first, itr last) {\n  for (auto iter = first; iter != last; ++iter) {\n    for (int i : *iter) {\n      if (i == INF)\n        cerr << \"INF\"\n             << \", \";\n      else\n        cerr << i << \", \";\n    }\n    cerr << endl;\n  }\n  cerr << endl;\n}\n/* auto output = [](auto first, auto last) { */\n/*   cerr << '{'; */\n/*   for (auto iter = first; iter != last; ++iter) { */\n/*     cerr << *iter << \", \"; */\n/*   } */\n/*   cerr << '}' << endl; */\n/* }; */\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  vector<vector<int>> K(n + 1, vector<int>(n + 1, INF));\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    K[a][b] = c;\n    K[b][a] = d;\n  }\n  int s, g, V, P;\n  scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n  for (int k = 1; k <= n; k++) {\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (K[i][j] > K[i][k] + K[k][j]) {\n          K[i][j] = K[i][k] + K[k][j];\n        }\n      }\n    }\n  }\n  cout << V - P - K[s][g] - K[g][s] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\nint n,m;\nint d[30];\nvector<pii> G[500];\n\n#define TO first\n#define COST second\nvoid dijkstra(int s){\n    rep(i,30)d[i]=INF;\n    priority_queue<pii,vector<pii>,greater<pii>> que;\n    que.push(pii(0,s));\n    d[s]=0;\n    \n    while(que.size()){\n        pii q=que.top();\n        que.pop();\n        \n        int v=q.second;\n        if(d[v]<q.first)continue;\n        \n        rep(i,G[v].size()){\n            pii e=G[v][i];\n            if(d[e.TO]>d[v]+e.COST){\n                d[e.TO]=d[v]+e.COST;\n                que.push(pii(d[e.TO],e.TO));\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m;\n    char ch;\n    cin>>n>>m;\n    rep(i,m){\n        int a,b,c,f;\n        cin>>a>>ch>>b>>ch>>c>>ch>>f;\n        G[a].pb(pii(b,c));\n        G[b].pb(pii(a,f));\n    }\n    int a,b,c,f;\n    cin>>a>>ch>>b>>ch>>c>>ch>>f;\n    int s=0;\n    dijkstra(a);\n    s+=d[b];\n    dijkstra(b);\n    s+=d[a];\n    cout<<c-f-s<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<functional>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\ntypedef unsigned long long UInt64;\ntypedef long long Int64;\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nusing namespace std;\n\ntypedef pair<int ,int > P;\n\nclass edge\n{\npublic:\n\tint to;\n\tint cost;\n\n\tedge(int _to,int _cost)\n\t{\n\t\tthis->to=_to;\n\t\tthis->cost=_cost;\n\t}\n};\n\nint d[30];\nvector<edge> G[30];\n\nint n,m;\n\nint dijkstra(int s,int t)\n{\n\tpriority_queue<P,vector<P> , greater<P> > que;\n\tfill(d,d+30,INF);\n\td[s]=0;\n\tque.push(P(0,s));\n\n\twhile(que.size())\n\t{\n\t\tP p=que.top();\n\t\tque.pop();\n\n\t\tif(p.sc==t) return d[t];\n\n\t\trep(i,G[p.sc].size())\n\t\t{\n\t\t\tedge e=G[p.sc][i];\n\t\t\tif(d[e.to] > d[p.sc]+e.cost)\n\t\t\t{\n\t\t\t\td[e.to]=d[p.sc]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nint main()\n{\n\tcin>>n>>m;\n\tint a,b,c,d;\n\trep(i,m)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tG[a].pb(edge(b,c));\n\t\tG[b].pb(edge(a,d));\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\n\tprintf(\"%d\\n\",c-d-dijkstra(a,b)-dijkstra(b,a));\n\n\n\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\n    int N, M, st, A, B, C, D, X1, X2, Y1, Y2;\n    int K[20][20];\n    scanf(\"%d%d\", &N, &M);\n    {\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                K[i][j] = INT_MAX;\n            }\n        }\n        for(int i=0;i<M;++i){\n            scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n            K[A-1][B-1]=C;\n            K[B-1][A-1]=D;\n        }\n        scanf(\"%d,%d,%d,%d\", &X1, &X2, &Y1, &Y2);\n        for(int k=0;k<N;++k){\n            for(int j=0;j<N;++j){\n                for(int i=0;i<N;++i){\n                    K[j][i] = min(K[j][i], K[j][k] + K[k][i]);\n                }\n            }\n        }\n    }\n    return Y1-Y2-K[X1-1][X2-1]-K[X2-1][X1-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint n,m;\nint V; // number of Vertex\nint s,G;// number of start\nvector<pii>g[10000]; // first: to second: cost\nvi d(1000,INF); // start->index  mminimum distance\nvoid dijkstra(){\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    d[s]=0;\n    que.push(pii(0,s));\n    while(!que.empty()){\n    pii now=que.top(); que.pop();\n        int v=now.second;\n        if(d[v]<now.first)continue;\n        for(int i=0; i<g[v].size();i++){\n            pii e=g[v][i];\n            if(d[e.first]>d[v]+e.second){\n                d[e.first]=d[v]+e.second;\n                que.push(pii(d[e.first],e.first));\n            }\n        }\n    }\n}\nint main(){\n    cin>>V>>m;\n    rep(i,m){\n        int to,from,tiya,rize;\n        char gomi; cin>>from>>gomi>>to>>gomi>>tiya>>gomi>>rize;\n        g[from].push_back(pii(to,tiya));\n        g[to].push_back(pii(from,rize));\n    }\n    int gotiusa,amausa;\n    char gomi;\n    cin>>s>>gomi>>G>>gomi>>gotiusa>>gomi>>amausa;\n    dijkstra();\n    int rize=d[G];\n    int hoge=s;\n    swap(s,G);\n    vi yebi(1000,INF);\n    d=yebi;\n    dijkstra();\n    cout<<gotiusa-amausa-rize-d[G]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<vector <int>> G;\n\nvoid create_edge(int a, int b, int c, int d);\nint search(int st, int go);\n\n\nint main(){\n\n  int n,m;\n  int start;\n  int goal;\n  int money;\n  int pay;\n  int g_money,b_money;\n  int sarary;\n  \n    \n  cin >> n;\n  cin >> m;\n  //cout << \"ihjiwohjwi\" << endl;\n  \n  G = vector <vector<int>>(20,vector<int>(20,1001));\n  \n  // cout << \"1\" << endl;\n\n  for(int i = 0; m>i; ++i){\n    int a,b,c,d;\n    \n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    create_edge(a,b,c,d);\n  }\n\n  //cout << \"2\" << endl;\n\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&pay);\n  \n  // cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n\n  g_money = search(start, goal);\n  b_money = search(goal, start);\n  \n  sarary = money - (g_money + b_money + pay);\n  \n  //cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n \n  cout << sarary << endl;\n  \n  \n}\n\n\n\nvoid create_edge(int a, int b, int c, int d){\n\n  G[a][b] = c;\n  G[b][a] = d;\n\n}\n\n\n\nint search(int st, int go){\n\n  int current;\n  \n  typedef pair < int, int > PII;\n  vector <int>  cost(100, 1001);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  cout << \"search\" << endl;\n  que.push(PII(0,st));\n  cost[st] = 0;\n  \n  \n  while(!que.empty()){\n    current = que.top().second;\n    que.pop();\n\n    for(int k=0; k<20; k++){\n      int temp;\n      temp = G[current][k] + cost[current];\n\n      if(G[current][k] != 1001 && temp < cost[k]){\n\tque.push(PII(temp,k));\n\tcost[k] = temp;\n      }\n    }  \t\t \n  }\n  \n  return cost[go];\n}\n      \n  \n\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 25;\nint g[N][N];\n\nint bfs(int n, int s, int G){\n    int dis[N]; //?????¢\n    queue<int> q; //?¨??????????????????\\??????\n    rep(i,N) dis[i] = INF;\n\n    dis[s] = 0;\n    q.push(s);\n\n    int u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(v,n){\n            if(dis[v] > dis[u] + g[u][v]){\n                dis[v] = dis[u] + g[u][v]; //??°???????????±??? \n                q.push(v);\n            }\n        }\n    }\n    return dis[G];\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n\n    rep(i,N) rep(j,N) g[i][j] = INF;\n    char k;\n    rep(i,m){\n        int a, b, c, d;\n        cin >> a >>k>> b>>k >> c>>k >> d;\n        a--; b--;\n        g[a][b] = c;\n        g[b][a] = d;\n    }\n\n    int s, g, v, p;\n    cin >> s >>k>> g >> k>>v >>k>> p;\n    s--; g--;\n\n    int a = bfs(n,s,g);\n    int b = bfs(n,g,s);\n    cout << v - p - a - b << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\nint main()\n{\n\tint n,m,a,b,ab,ba,x1,x2,y1,y2,t[32][32];\n\n\tscanf(\"%d %d\",&n,&m);\n\tREP(i,n)REP(j,n)\n\t{\n\t\tt[i][j]=(i==j?0:1<<20);\n\t}\n\n\twhile(m--)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&ab,&ba);\n\t\ta--;b--;\n\t\tt[a][b]=ab;\n\t\tt[b][a]=ba;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tREP(k,n)REP(i,n)REP(j,n)\n\t{\n\t\tif(t[i][j]>t[i][k]+t[k][j]) t[i][j]=t[i][k]+t[k][j];\n\t}\n\n\tx1--;x2--;\n\tprintf(\"%d\\n\",y1-y2-t[x1][x2]-t[x2][x1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long int\n#define INF 10000000\nusing namespace std;\t\nint main(void)\n{\n\tLL i,j,k,n,m,glid[21][21],start,gorl,v[21],clr[21],a,b,c,d,mm,p,ans2,mini,x,ans1;\n\tcin>>n>>m;\n\tfor(i=0;i<21;i++)for(j=0;j<n;j++) glid[i][j]=INF;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%lld,%lld,%lld,%lld\",&a,&b,&c,&d);\n\t\tglid[a][b]=c;\n\t\tglid[b][a]=d;\n\t}\n\tscanf(\"%lld,%lld,%lld,%lld\",&start,&gorl,&mm,&p);\n\tfor(i=0;i<21;i++) v[i]=INF,clr[i]=0;\n\tv[start]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans1=v[gorl];\n\tfor(i=0;i<21;i++) {\n\t\tv[i]=INF;\n\t\tclr[i]=0;\n\t}\n\tv[gorl]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans2=v[start];\n\tcout<<mm-p-ans1-ans2<<endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src_, int dst_, Weight weight_) :\n\t\tsrc(src_), dst(dst_), weight(weight_) { }\n\tEdge(int src_, int dst_) :\n\t\tsrc(src_), dst(dst_) {\n\n\t}\n};\npair<bool, vector<Weight>> spfa(const int v_num, const vector<vector<Edge>>&es, const int start) {\n\tvector<Weight>diss(v_num, INT_MAX);\n\tqueue<int>que;\n\tvector<bool>use(v_num);\n\tvector<int>count(v_num);\n\tque.emplace(start);\n\tdiss[start] = 0;\n\twhile (!que.empty()) {\n\t\tint src(que.front());\n\t\tque.pop();\n\t\tuse[src] = false;\n\t\tfor (auto e : es[src]) {\n\t\t\tconst int d = e.dst;\n\t\t\tif (diss[src] + e.weight < diss[d]) {\n\t\t\t\tdiss[d] = diss[src] + e.weight;\n\t\t\t\tif (!use[d]) {\n\t\t\t\t\tuse[d] = true;\n\t\t\t\t\tcount[d]++;\n\t\t\t\t\tif (count[d] >= v_num)return make_pair(false, vector<Weight>());\n\t\t\t\t\tque.emplace(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(true, diss);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tes[a].push_back(Edge(a, b, c));\n\t\tes[b].push_back(Edge(b, a, d));\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\ts--; g--;\n\tauto p1 = spfa(N, es, s);\n\tauto p2 = spfa(N, es, g);\n\tcout << V - P - p1.second[g] - p2.second[s] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 100005\n#define MAX_V 100001\n#define INF (1e9 + 1)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint g[20][20];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tg[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tg[a-1][b-1]=c;\n\t\tg[b-1][a-1]=d;\n\t}\n\tint s,G,V,P;\n\tscanf(\"%d%d%d%d\",&s,&G,&V,&P);\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",V-P-g[s-1][G-1]-g[G-1][s-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main() {\n\tint n, m, a, b, c, d, i, j, k, x[32][32];\n\tcin >> n >> m;\n\tfor(i = 1; i <= n; i++)\n\t\tfor(j = 1; j <= n; j++)\n\t\t\tx[i][j] = 1001001001;\tfor(i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a][b] = c;\n\t\tx[b][a] = d;\n\t}\n\tfor(k = 1; k <= n; k++)\n\t\tfor(i = 1; i <= n; i++)\n\t\t\tfor(j = 1; j <= n; j++)\n\t\t\t\tif (x[i][j] > x[i][k] + x[k][j]) x[i][j] = x[i][k] + x[k][j];\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tcout << c - d - x[a][b] - x[b][a] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int kMaxTown = 21; //0?????????????????????\nconst int kInf = 1 << 16;\n\nint main(){\n\tint d[kMaxTown] = { kInf };\n\tint arrived[kMaxTown] = { false };\n\tint cost[kMaxTown][kMaxTown] = { kInf };\n\n\tint n, m;\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\td[x1] = 0;\n\n\twhile (!arrived[x2]){\n\t\tint minTown = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (!arrived[i] && (d[i] < d[minTown]))\n\t\t\t\tminTown = i;\n\t\tarrived[minTown] = true;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\td[i] = std::min(d[i], d[minTown] + cost[minTown][i]);\n\t}\n\tprintf(\"%d\\n\", y1 - y2 - d[x2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\nint d[21][21];\n\nint main(){\n  char ch;\n  int n, m;\n  memset(d, -1, sizeof(d));\n  int x1, x2, y1, y2;\n  cin >> n >> m;\n  for(int i = 0; i < m; i++){\n    int a, b, c, d2;\n    cin >> a >> ch >> b >> ch >> c >> ch >> d2;\n    d[a][b] = c;\n    d[b][a] = d2;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(d[j][i] < 0) continue;\n      for(int k = 1; k <= n; k++){\n\tif(d[i][k] >= 0 && (d[j][k] < 0 || d[j][k] > d[j][i] + d[i][k])){\n\t  d[j][k] = d[j][i] + d[i][k];\n\t}\n      }\n    }\n  }\n  cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n  cout << y1 - y2 - d[x1][x2] - d[x2][x1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,s,g,V,P;\nint cost[32][32];\nint length[32][32];\nconst int Inf = 10000*100000+100;\n\nint main()\n{\n    scanf(\"%d%d\", &N, &M); \n    for(int i=1;i<=N;i++)\n       for(int j=1;j<=N;j++)\n       {\n           if(i==j)\n             cost[i][j]=0;\n           else\n             cost[i][j]=Inf;\n       }\n    for (int i=0; i<M; ++i) \n    {\n        scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n        cost[A][B]=C;\n        cost[B][A]=D;\n    }\n    for(int i=1;i<=N;i++)\n       for(int j=1;j<=N;j++)\n       {\n           length[i][j]=cost[i][j];\n       }\n    for(int k=1;k<=N;k++)\n       for(int i=1;i<=N;i++)\n          for(int j=1;j<=N;j++)\n             if(length[i][k]+length[k][j]<length[i][j])\n               length[i][j]=length[i][k]+length[k][j];\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    int reward=V-P-length[s][g]-length[g][s];\n    printf(\"%d\\n\",reward);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=1; i<=n; i++)\n\nint main()\n{\n\tint n,m,a,b,c,d,x,y,z,w,t[32][32];\n\n\tscanf(\"%d %d\",&n,&m);\n\tREP(i,n)REP(j,n)\n\t{\n\t\tt[i][j]=(i==j?0:1<<20);\n\t}\n\n\twhile(m--)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt[a][b]=c;\n\t\tt[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n\n\tREP(k,n)REP(i,n)REP(j,n)\n\t{\n\t\tif(t[i][j]>t[i][k]+t[k][j]) t[i][j]=t[i][k]+t[k][j];\n\t}\n\n\tprintf(\"%d\\n\",z-w-t[x][y]-t[y][x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\tpq.emplace(d[t] + E[t][i].second, E[t][i].first);\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <sstream>\n#include <algorithm>\n\nint n, m, start, goal, money, pole;\nint roads[21][21];\nint in[4];\nstd::string input;\n\nint check( int pos, int hbt, unsigned int c ){\n\tif( pos == goal ) return c;\n\n\tunsigned int cost = -1;\n\n\tfor( int i = 1; i <= m; ++i ){\n\t\tif( roads[pos][i] != -1 && !(hbt & 1 << i) ){\n\t\t\tcost = std::min( cost, (unsigned int)check( i, hbt|1<<i, c + roads[pos][i] ) );\n\t\t}\n\t}\n\n\treturn cost;\n}\n\nint main(){\n\tmemset( roads, -1, sizeof( roads ) );\n\n\tstd::cin >> n >> m;\n\n\tfor( int i = 0; i < m; ++i ){\n\t\tstd::cin >> input;\n\n\t\tsscanf( input.c_str(), \"%d,%d,%d,%d\", in, &in[1], &in[2], &in[3] );\n\n\t\troads[ in[0] ][ in[1] ] = in[2];\n\t\troads[ in[1] ][ in[0] ] = in[3];\n\t}\n\n\tstd::cin >> input;\n\tsscanf( input.c_str(), \"%d,%d,%d,%d\", &start, &goal, &money, &pole );\n\n\tmoney -= pole;\n\n\tint cost = check( start, 0, 0 );\n\tstd::swap( start, goal );\n\tcost += check( start, 0, 0 );\n\n\tstd::cout << money - cost << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n int i,j,k,m,n,a1,b1,x1,x2,y1,y2,c1,d1,d[21][21];\n cin >> n;\n for (i=1;i<=n;i++) for (j=1;j<=n;j++) if (i==j) d[i][j]=0; else d[i][j]=1200000000;\n cin >> m;\n for (i=0;i<m;i++) {\n\t scanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n     d[a1][b1]=c1; d[b1][a1]=d1;\n }\n scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n cout << y1-y2-d[x1][x2]-d[x2][x1] << endl;\n return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nvoid warshallFloyd(int alt[100][100], int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                alt[i][j] = min(alt[i][j], alt[i][k] + alt[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    int a, b, c, d;\n    int n, m;\n    int atl[100][100];\n    rep(i,100) rep(j,100) atl[i][j] = INF;\n    cin >> n >> m;\n    rep(i,m){\n        scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n        atl[a][b] = c;\n        atl[b][a] = d;\n    }\n    warshallFloyd(atl, n);\n    scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n    cout << 50 - atl[a][b] - atl[b][a] - 30 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nclass Dijkstra{\n\tusing Point = pair<ll,ll>;\n\tvector<ll> dist;\npublic:\n\tvoid CalcShortestPath(int start,ConnectNodeInfo& connect){\n\t\tdist.resize(connect.size(),1LL<<60);\n\t\tfill(ALL(dist),1LL<<60);\n\t\tdist[start] = 0;\n\n\t\tpriority_queue<Point,vector<Point>,greater<Point>> Q;\n\t\tQ.emplace(0,start);\n\t\twhile(!Q.empty()){\n\t\t\tauto p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v]<p.first){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(auto e:connect[v]){\n\t\t\t\tif(dist[e.first]>dist[v]+e.second){\n\t\t\t\t\tdist[e.first] = dist[v]+e.second;\n\t\t\t\t\tQ.emplace(dist[e.first],e.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll GetDistance(int i){\n\t\treturn dist[i];\n\t}\n};\n\nint main(){\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tint N=in(),M=in();\n\tConnectNodeInfo connect(N);\n\tREP(i,M){\n\t\tstring S=in<string>();\n\t\tint a,b,c,d;\n\t\tsscanf(S.c_str(),\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tconnect.AddDirectionalConnection(a-1,b-1,c);\n\t\tconnect.AddDirectionalConnection(b-1,a-1,d);\n\t}\n\tstring S=in<string>();\n\tint s,g,V,P;\n\tsscanf(S.c_str(),\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\n\tDijkstra Dij;\n\tDij.CalcShortestPath(s-1,connect);\n\tauto dist1 = Dij.GetDistance(g-1);\n\tDij.CalcShortestPath(g-1,connect);\n\tauto dist2 = Dij.GetDistance(s-1);\n\n\tout(V-P-dist1-dist2);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 30\n#define INFTY (1<<21)\nint main(){\n\tint a1, b1, c1, d1, x1, x2, y2, y1, n, m; \n\tint dai[MAX][MAX];\n\tchar v;\n\tfor (int i = 0;i<MAX;i++){\n\t\tfor(int l=0;l<MAX;l++){\n\t\t\tdai[i][l] = INFTY;\n\t\t}\n\t}\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> a1 >> v >> b1 >> v >> c1 >> v >>  d1;\n\t\tdai[a1-1][b1-1] = c1;\n\t\tdai[b1-1][a1-1] = d1;\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\tfor (int k = 0; k < m; k++){\n\t\t\t\tdai[j][k] = min(dai[j][k], dai[j][i] + dai[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x1 >> v >> x2 >> v >> y1 >> v >> y2;\n\tcout << y1 - (y2 + dai[x1-1][x2-1]+dai[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n\nstruct edge {\n\tint cost;\n\tint to;\n};\n\nll INF = 1000000000;\nint N,M,s,g,v,p;\nll d[110];\nvector<edge> G[110];\n\nvoid dijkstra(int s) {\n\tpriority_queue<pl, vector<pl>, greater<pl>> q;\n\tfill(d, d + N, INF);\n\td[s] = 0;\n\tq.push(pl(0, s));\n\n\twhile (!q.empty()) {\n\t\tpl p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(pl(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll ans = 0;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c, d;\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tG[a].push_back({c,b});\n\t\tG[b].push_back({d,a});\n\t}\n\tscanf_s(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--, g--;\n\tdijkstra(s);\n\tans += d[g];\n\tdijkstra(g);\n\tans += d[s];\n\tcout << v - p - ans << endl;\n\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 1000000000;\nusing namespace std;\nint main() {\n  int n, m;\n  char q;\n  cin >> n >> m;\n  int dp[n][n];\n  rep(i, n) rep(j, n) dp[i][j] = i == j ? 0 : INF;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> q >> b >> q >> c >> q >> d;\n    a--;\n    b--;\n    dp[a][b] = c;\n    dp[b][a] = d;\n  }\n  rep(k, n) rep(i, n) rep(j, n) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n  int s, g, V, P;\n  cin >> s >> q >> g >> q >> V >> q >> P;\n  s--;\n  g--;\n  cout << V - P - dp[s][g] - dp[g][s] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconstexpr int INF = 1 << 20;\n\nclass Graph {\nprivate:\n\tconst int N;\n\tvector<int> edge;\npublic:\n\tGraph(int n) : N(n), edge(n*n, INF) {}\n\tvoid InputEdge(int a, int b, int c, int d) {\n\t\tedge[(a - 1) * N + b - 1] = c;\n\t\tedge[(b - 1) * N + a - 1] = d;\n\t}\n\tvoid Show() {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tint e = edge[i * N + j];\n\t\t\t\tif (e == INF)\n\t\t\t\t\tcout << \"Inf\" << \"\\t\";\n\t\t\t\telse\n\t\t\t\t\tcout << e << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tint FWSearch(int s, int g);\n};\n\nint Graph::FWSearch(int s, int g) {\n\tfor (int k = 0; k < N; k++)\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tif (edge[i * N + j] > edge[i * N + k] + edge[k * N + j])\n\t\t\t\t\tedge[i * N + j] = edge[i * N + k] + edge[k * N + j];\n\treturn edge[(s - 1) * N + g - 1];\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tGraph G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG.InputEdge(a, b, c, d);\n\t}\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint C[2] = { G.FWSearch(s, g), G.FWSearch(g, s) };\n\tcout << V - P - C[0] - C[1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint dijkstra(int start,int goal,int n);\nconst int INF=1000000000;\nint edge[20][20];\n\nint main()\n{\n\tchar buf[64];\n\tint n,m;\n\t\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d\",&n);\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d\",&m);\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tedge[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tchar buf[64];\n\t\tint a,b,c,d;\n\t\tfgets(buf,64,stdin);\n\t\tsscanf(buf,\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\t\n\t\tedge[a-1][b-1]=c;\n\t\tedge[b-1][a-1]=d;\n\t}\n\tint start,goal,income,pay,reward;\n\tfgets(buf,64,stdin);\n\tsscanf(buf,\"%d,%d,%d,%d\",&start,&goal,&income,&pay);\n\t\n\treward=income-pay-dijkstra(start-1,goal-1,n)-dijkstra(goal-1,start-1,n);\n\tprintf(\"%d\\n\",reward);\n\treturn 0;\n}\n\nint dijkstra(int start,int goal,int n)\n{\n\tint cost[20];\n\tbool visited[20];\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcost[i]=INF;\n\t\tvisited[i]=false;\n\t}\n\t\n\tcost[start]=0;\n\twhile(1)\n\t{\n\t\tint u=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!visited[i]&&(u==-1||cost[i]<cost[u]))//未訪問でcost最小の町=u\n\t\t\t{\n\t\t\t\tu=i;\n\t\t\t}\n\t\t}\n\t\tif(u==-1)break;\n\t\t\n\t\tvisited[u]=true;\n\t\tfor(int i=0;i<n;i++)//cost更新\n\t\t{\n\t\t\tcost[i]=cost[i]>cost[u]+edge[u][i]?cost[u]+edge[u][i]:cost[i];\n\t\t}\n\t}\n\treturn cost[goal];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int INF=100000000;\nstruct edge{\n    int to,cost;\n    edge(int a,int b){\n        to=a;cost=b;\n    }\n    edge(){}\n};\nvector<vector<edge> >V;\n\nint dijkstra(int s,int g){\n    int d[100];\n    fill(d,d+100,INF);\n    d[s]=0;\n    priority_queue<pii>Q;\n    Q.push(pii(0,s));\n    while(!Q.empty()){\n        pii p=Q.top();Q.pop();\n        int n=p.second,cost=p.first;\n        if(d[n]<cost)continue;\n        d[n]=cost;\n        for(int i=0;i<V[n].size();i++){\n            edge e=V[n][i];\n            if(d[e.to]>d[n]+e.cost){\n                Q.push(pii(d[n]+e.cost,e.to));\n            }\n        }\n    }\n\n    return d[g];\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    V.resize(n);\n    for(int i=0;i<m;i++){\n        int a,b,ab,ba;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&ab,&ba);\n        a--;b--;\n        V[a].push_back(edge(b,ab));\n        V[b].push_back(edge(a,ba));\n    }\n    int s,g,w,c;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&w,&c);\n    s--;g--;\n    cout<<w-c-dijkstra(s,g)-dijkstra(g,s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\n\nint n, e, dp[22][22], s, g;\nconst int inf = 1<<29;\n\nint solve() {\n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n      }\n    }\n  }\n  return dp[s][g] + dp[g][s];\n}\n\nint main() {\n  rep (i,22) fill(dp[i], dp[i] + 22, inf);\n  rep (i,22) dp[i][i] = 0;\n\n  cin >> n >> e;\n  int a, b, c, d;\n  char x;\n  rep (i,e) {\n    cin >> a >> x >> b >> x >> c >> x >> d;\n    a--; b--;\n    dp[a][b] = c;\n    dp[b][a] = d;\n  }\n  int y1, y2;\n  cin >> s >> x >> g >> x >> y1 >> x >> y2;\n  s--; g--;\n  cout << y1 - y2 - solve() << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nconst int INF=100000;\n\nusing namespace std;\n\nint main(void){\n    int list[21][21];\n    int n,m;\n    int a,b,c,d;\n    int x,y,z,w;\n    int i,j,k;\n    int cost;\n    \n    for(i=0;i<21;i++){\n        fill(list[i],list[i]+21,INF);\n    }\n    \n    scanf(\"%d\",&n);\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        list[a-1][b-1]=c;\n        list[b-1][a-1]=d;\n    }\n    scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            for(k=0;k<n;k++){\n                if(list[j][k]>list[j][i]+list[i][k]){\n                    list[j][k]=list[j][i]+list[i][k];\n                }\n            }\n        }\n    }\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n        }\n    }\n    cost=z-w-list[x-1][y-1]-list[y-1][x-1];\n    cout<<cost<<endl;\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tint a,b,c,d;\n\tint G[n][n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tG[i][j] = 100000000;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tG[a - 1][b - 1] = c;\n\t\tG[b - 1][a - 1] = d;\n\t}\n\tint s,g,v,p;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--; g--;\n\tvector <int> used(n,0);\n\tvector <int> dist(n,100000000);\n\tdist[s] = 0;\n\twhile(1){\n\t\tint va = -1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(used[i] == 0 && (va == -1 || dist[va] > dist[i]))\n\t\t\t\tva = i;\n\t\tif(va == -1)\n\t\t\tbreak;\n\t\tused[va] = 1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tdist[i] = min(dist[i] , G[va][i] + dist[va]);\n\t}\n\tint iki = dist[g];\n\tused = vector <int> (n,0);\n\tdist = vector <int> (n,100000000);\n\tdist[g] = 0;\n\twhile(1){\n\t\tint va = -1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(used[i] == 0 && (va == -1 || dist[va] > dist[i]))\n\t\t\t\tva = i;\n\t\tif(va == -1)\n\t\t\tbreak;\n\t\tused[va] = 1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tdist[i] = min(dist[i] , G[va][i] + dist[va]);\n\t}\n\tcout << v - p - dist[s] - iki << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nvoid solve()\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tV = n;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tsolve();\n\tcout << y1 - D[x1][x2] - D[x2][x1] - y2 + 1 << endl;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint n,m,a,b,c,d,s,g,v,p,K[30][30];\nconst int inf=10000000;\n\nint main(){\n    for(int i=0;i<30;i++){\n        for(int j=0;j<30;j++){K[i][j]=inf;}\n    }\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        //cout<<a<<b<<c<<d<<endl;\n        K[a][b]=c;\n        K[b][a]=d;\n    }\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n    //cout<<s<<g<<v<<g<<endl;\n    for(int k=1;k<=n;k++){\n        for(int l=1;l<=n;l++){\n            for(int j=1;j<=n;j++){\n                if(K[l][j]>K[l][k]+K[k][j]){K[l][j]=K[l][k]+K[k][j];}\n            }\n        }\n    }\n    cout<<v-p-K[s][g]-K[g][s]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nint D[20][20];\nint V;\nconst int INF = 1 << 20;\n\nvoid solve()\n{\n\tfor (int k = 0; k < V; k++)\n\t{\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tD[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfill(D[0], D[0] + 400, INF);\n\tchar comma;\n\tcin >> n;\n\tV = n + 1;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> comma >> b >> comma >> c >> comma >> d;\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint x1, y1, x2, y2;\n\tcin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\tsolve();\n\tcout << y1 - D[x1][x2] - D[x2][x1] - y2 << endl;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef int Y;\nconstexpr Y INF = numeric_limits<Y>::max() / 3;\n\nstruct Edge {\n    int to;\n    Y cost;\n\n    Edge () {}\n    Edge(int a,Y b): to(a), cost(b) {}\n} ;\n\nstruct State {\n    int pos;\n    Y cost;\n\n    State () {}\n    State(int a, Y b): pos(a), cost(b) {}\n} ;\n\nclass Dijkstra {\npublic:\n    vector<vector<Edge>> graph;\n    vector<Y> dist;\n    int N;\n\n    Dijkstra() {}\n\n    void init(int n) {\n        graph.clear();\n        graph.resize(N = n);\n        dist.resize(N);\n        fill(begin(dist), end(dist), INF);\n    }\n    \n    void add_edge(int from, int to, Y cost) {\n        graph[from].push_back(Edge(to, cost));\n    }\n\n    void shortest_path_from(int start) {\n        static auto y_comparator = [&](const State& a, const State& b) -> bool {\n            return a.cost > b.cost;\n        };\n\n        priority_queue<State, vector<State>, decltype(y_comparator)> pq(y_comparator);\n\n        fill(begin(dist), end(dist), INF);\n        dist[start] = 0;\n\n        pq.push(State(start, 0));\n\n        while (!pq.empty()) {\n            State s = pq.top(); pq.pop();\n            if (s.cost > dist[s.pos]) {\n                continue;\n            }\n\n            for (Edge& e: graph[s.pos]) {\n                if (e.cost + s.cost < dist[e.to]) {\n                    dist[e.to] = e.cost + s.cost;\n                    pq.push(State(e.to, dist[e.to]));\n                }\n            }\n        }\n    }\n\n} ;\n\nint N, M;\nDijkstra graph;\nint s, g, V, P;\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    graph.init(N);\n    for (int j = 0; j < M; ++j) {\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        --a; --b;\n        graph.add_edge(a, b, c);\n        graph.add_edge(b, a, d);\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    --s; --g;\n\n    graph.shortest_path_from(s);\n    int d1 = graph.dist[g];\n    graph.shortest_path_from(g);\n    int d2 = graph.dist[s];\n\n    cout << V - P - d1 - d2 << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Node{\npublic:\n\tint node;\n\tint cost;\n\tNode(int n,int c){\n\t\tnode = n;\n\t\tcost = c;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn cost > o.cost;\n\t}\n};\n#define MAX 2000000000\nint main(){\n\tint n,m;\n\tint s,g,money,hashira;\n\tpriority_queue<Node> pq;\n\tpriority_queue<Node> pq2;\n\tint map[50][50];\n\tbool visited[100];\n\tchar ch;\n\n\tcin >> n >> m;\n\tfor(int i = 1; i <=n;i++ ){\n\t\tvisited[i] = false;\n\t}\n\tfor(int i = 1 ; i <=n ;i++){\n\t\tfor(int j = 1;j <=n ;j++){\n\t\t\tmap[i][j] = MAX;\n\t\t}\n\t}\n\n\tfor(int i = 1 ; i <= m;i++){\n\t\tint a,b,c,d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\tmap[a][b] = c;\n\t\tmap[b][a] = d;\n\t}\n\n\tcin >> s >> ch >> g >> ch >> money >> ch >> hashira;\n\t//ツ行ツつォツづ個コツスツトツづーツ仰づ淞づゥ\n\tpq.push(Node(s,0));\n\twhile(!pq.empty()){\n\t\tNode c_node = pq.top();\n\t\tpq.pop();\n\t\tif(c_node.node == g){\n\t\t\tpq2.push(c_node);\n\t\t\tbreak;\n\t\t}\n\t\tif(visited[c_node.node])continue;\n\t\tvisited[c_node.node]= true;\n\t\tfor(int i = 1;i <= n;i++ ){\n\t\t\tif(map[c_node.node][i] == MAX)continue;\n\t\t\tint n_cost = c_node.cost + map[c_node.node][i];\n\t\t\tpq.push(Node(i,n_cost));\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n;i++ ){\n\t\tvisited[i] = false;\n\t}\n\n\t//ツ帰ツづィツづ個コツスツトツづーツ仰づ淞づゥ\n\twhile(!pq2.empty()){\n\t\tNode c_node = pq2.top();\n\t\tpq2.pop();\n\t\tif(c_node.node == s){\n\t\t\tint ans = money - hashira-c_node.cost;\n\t\t\tcout <<ans <<endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(visited[c_node.node])continue;\n\t\tvisited[c_node.node]= true;\n\t\tfor(int i = 1;i <= n;i++ ){\n\t\t\tif(map[c_node.node][i] == MAX)continue;\n\t\t\tint n_cost = c_node.cost + map[c_node.node][i];\n\t\t\tpq2.push(Node(i,n_cost));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\n#define inf 1000000\nvoid daikustora(int s,vector<vector<mypair> > &g,vector<int> &cost){\n\tpriority_queue<mypair,vector<mypair> ,greater<mypair> > q;\n\tcost[s] = 0;\n\tq.push(mypair(0,s));\n\twhile(!q.empty()){\n\t\tmypair now =q.top();\n\t\tq.pop();\t\n\t\tif(now.first>cost[now.second])continue;\n\t\tfor(int i=0;i<g[now.second].size();i++){\n\t\t\tint next = g[now.second][i].second;\n\t\t\tint ncost = g[now.second][i].first;\n\t\t\tif(cost[next]>cost[now.second]+ncost){\n\t\t\t\tcost[next] = cost[now.second]+ncost;\n\t\t\t\tq.push(mypair(cost[next],next));\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn ;\n}\nint main(){\nint n,m;\ncin>>n>>m;\nint s,f,v,p;\nvector<vector<mypair> > g(n+1);\nfor(int i=0;i<m;i++){\nint a,b,c,d;\nscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\ng[a].push_back(mypair(c,b));\ng[b].push_back(mypair(d,a));\n\n}\nscanf(\"%d,%d,%d,%d\",&s,&f,&v,&p);\n\nvector<int> cost_go(n+1,inf),cost_re(n+1,inf);\ndaikustora(s,g,cost_go);\ndaikustora(f,g,cost_re);\np+=cost_go[f]+cost_re[s];\ncout<<v-p<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000000\nint n,m,r[21][21],cost[21][21];\nint x1,x2,y1,y2;\nint d[21];\nint BF(int a,int b){\n  for(int i=0;i<21;i++)d[i]=INF;\n  d[a]=0;\n  for(int i=0;i<n*2;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n        if(r[j][k])\n          d[k]=min(d[k],d[j]+cost[j][k]);\n      }\n    }\n  }\n  return d[b];\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    r[a][b]=1;r[b][a]=1;\n    cost[a][b]=c;cost[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  // cout<<BF(x1,x2)<<endl;\n  //cout<<BF(x2,x1)<<endl;\n  cout<<y1-y2-BF(x1,x2)-BF(x2,x1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n#include <complex>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef complex<double> Point;\n\nstruct Edge\n{\n\tint src, dst;\n\tint weight;\n\tEdge(int src, int dst, int weight) : src(src), dst(dst), weight(weight) {}\n\n\tbool operator< (const Edge& e)const\n\t{\n\t\treturn weight != e.weight ? weight > e.weight :\n\t\t\tsrc != e.src ? src < e.src : dst < e.dst;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid Dijkstra(const Graph& g, int s, vi& dist, vi& prev)\n{\n\tint n = g.size();\n\tdist.assign(n, INT_MAX);\n\tdist[s] = 0;\n\tprev.assign(n, -1);\n\t\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-2, s, 0));\n\n\twhile(!Q.empty()){\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif(prev[e.dst] != -1)\n\t\t\tcontinue;\n\t\tprev[e.dst] = e.src;\n\n\t\trep(i, g[e.dst].size()){\n\t\t\tint pw = e.weight + g[e.dst][i].weight;\n\t\t\tif(dist[g[e.dst][i].dst] > pw){\n\t\t\t\tdist[g[e.dst][i].dst] = pw;\n\t\t\t\tQ.push(Edge(g[e.dst][i].src, g[e.dst][i].dst, pw));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tGraph g(n);\n\trep(i, m){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t--a; --b;\n\t\tg[a].push_back(Edge(a, b, c));\n\t\tg[b].push_back(Edge(b, a, d));\n\t}\n\t\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t--x1; --x2;\n\t\n\tvi dist, prev;\n\tDijkstra(g, x1, dist, prev);\n\tint cost = dist[x2];\n\tDijkstra(g, x2, dist, prev);\n\tcost += dist[x1];\n\t\n\tprintf(\"%d\\n\", y1-y2-cost);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\nconstexpr int MOD = 1000000007;\nconstexpr int INF = 2000000000;\nusing namespace std;\ntypedef pair<int, int> P;\nvector<P> v[100001];\n\nint dij(int s, int g) {\n\n\tint i;\n\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tbool used[100001] = { false };\n\n\tque.push(P(0, s));\n\n\twhile (!que.empty()) {\n\t\tP now = que.top();\n\t\tque.pop();\n\n\t\tint cost = now.first;\n\t\tint to = now.second;\n\t\tused[to] = true;\n\t\tif (to == g) {\n\t\t\treturn cost;\n\t\t}\n\n\t\tfor (i = 0; i < v[to].size(); i++) {\n\n\t\t\tint nextcost = cost + v[to][i].first;\n\t\t\tint next = v[to][i].second;\n\n\t\t\tif (used[next] == false) {\n\t\t\t\tque.push(P(nextcost, next));\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main() {\n\tint N, M;\n\tint a, b, c, d;\n\n\tcin >> N >> M;\n\tchar ch;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(P(c, b));\n\t\tv[b].push_back(P(d, a));\n\t}\n\tint s, g, v, p;\n\tcin >> s >> ch >> g >> ch >> v >> ch >> p;\n\tcout << v - p - dij(s - 1, g - 1) - dij(g - 1, s - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1234567;\nconst ll INF=1000000010;\nconst ll LINF=1000000000000000010LL;\nconst int MAX=10000010;\nconst double EPS=1e-3;\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\nstruct edge{int to,cost;};\nvector<edge> G[30];\nint d[30];\nvoid dijkstra(int s){\n\tfill(d,d+25,INF);\n\tpriority_queue<P,vector<P>,greater<P>> q;\n\tq.push(P(0,s));\n\td[s]=0;\n\twhile(!q.empty()){\n\t\tP p=q.top();\n\t\tint v=p.second;\n\t\tq.pop();\n\t\tfor(auto e:G[v]){\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint n,m;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tG[a].push_back({b,c});\n\t\tG[b].push_back({a,d});\n\t}\n\tint s,g,v,p;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);s--;g--;\n\tint ans=v-p;\n\tdijkstra(s);\n\tans-=d[g];\n\tdijkstra(g);\n\tans-=d[s];\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main(void){\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int> > t(n,vector<int>(n,1<<22));\n  int a,b,c,d;\n  char dm;\n  for(int i = 0 ; i < m ; i ++){\n    cin>>a>>dm>>b>>dm>>c>>dm>>d;\n    a--,b--;\n    t[a][b] = c;\n    t[b][a] = d; \n  }\n  \n  int x1,x2,y1,y2;\n  cin>>x1>>dm>>x2>>dm>>y1>>dm>>y2;\n  for(int i = 0 ; i < n ; i ++) \n    t[i][i] = 0;\n  for(int k = 0 ; k < n ; k ++)\n  for(int i = 0 ; i < n ; i ++)\n  for(int j = 0 ; j < n ; j ++)\n    t[i][j] = min(t[i][j] , t[i][k] + t[k][j]);\n  \n  int s = t[--x1][--x2];\n  int r = t[x2][x1];\n  cout<< y1 - (y2 + s + r) <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int> gaidou;//first=nextbangou,second=nowcost\nmain(){\n  vector< gaidou > to[22];\n  int min_cost[22];\n  queue< gaidou > que;\n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int ans=0;\n  gaidou g;\n  cin>>n>>m;\n  for(int i=1;i<=n;i++){\n    min_cost[i]=1<<21;\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    g.first=b;\n    g.second=c;\n    to[a].push_back(g);\n    g.first=a;\n    g.second=d;\n    to[b].push_back(g);\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&ans,&y2);\n  ans-=y2;\n  //cout<<\"A\"<<ans<<endl;\n  g.first=x1;\n  g.second=0;\n  que.push(g);\n  while(!que.empty()){\n    gaidou now=que.front();\n    int size=to[now.first].size();\n    for(int i=0;i<size;i++){\n      if(to[now.first][i].second+now.second<min_cost[to[now.first][i].first]){\n\tmin_cost[to[now.first][i].first]=to[now.first][i].second+now.second;\n\tg.first=to[now.first][i].first;\n\tg.second=to[now.first][i].second+now.second;\n\t//cout<<g.first<<\" | \"<<g.second<<endl;\n\tque.push(g);\n      }\n    }\n    que.pop();\n  }\n  while(!que.empty()){\n    que.pop();\n  }\n  ans-=min_cost[x2];\n  //cout<<\"B\"<<ans<<endl;\n  for(int i=1;i<=n;i++){\n    min_cost[i]=1<<21;\n  }\n  g.first=x2;\n  g.second=0;\n  que.push(g);\n  while(!que.empty()){\n    gaidou now=que.front();\n    //cout<<\"now=\"<<now.first<<\" \"<<now.second<<endl;\n    int size=to[now.first].size();\n    for(int i=0;i<size;i++){\n      if(to[now.first][i].second+now.second<min_cost[to[now.first][i].first]){\n\tmin_cost[to[now.first][i].first]=to[now.first][i].second+now.second;\n\tg.first=to[now.first][i].first;\n\tg.second=to[now.first][i].second+now.second;\n\t//cout<<g.first<<\" | \"<<g.second<<endl;\n\tque.push(g);\n      }\n    }\n    que.pop();\n  }\n  while(!que.empty()){\n    que.pop();\n  }\n  ans-=min_cost[x1];\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\nstruct edge { int to, cost; };\n\nconst int INF = 10000000;\n\nint main()\n{\n    int n,m;\n    while(cin >> n && n) {\n        cin >> m;\n        vector<edge> G[n+1];\n        for(int i = 0; i < m; i++) {\n            int a, b, c, d;\n            scanf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d);\n            G[a].push_back((edge){b, c});\n            G[b].push_back((edge){a, d});\n        }\n        \n        int x1, x2, y1, y2;\n        scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n        \n        priority_queue<P, vector<P>, greater<P> > que;\n        int dist1[n+1];\n        fill(dist1, dist1 + n + 1, INF);\n        dist1[x1] = 0;\n        que.push(P(0, x1));\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(dist1[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if(dist1[e.to] > dist1[v] + e.cost) {\n                    dist1[e.to] = dist1[v] + e.cost;\n                    que.push(P(dist1[e.to], e.to));\n                }\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que2;\n        int dist2[n+1];\n        fill(dist2, dist2 + n + 1, INF);\n        dist2[x2] = 0;\n        que2.push(P(0, x2));\n        while(!que2.empty()) {\n            P p = que2.top(); que2.pop();\n            int v = p.second;\n            if(dist2[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if(dist2[e.to] > dist2[v] + e.cost) {\n                    dist2[e.to] = dist2[v] + e.cost;\n                    que2.push(P(dist2[e.to], e.to));\n                }\n            }\n        }\n\n        cout << y1 - y2 - dist1[x2] - dist2[x1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nint prevv[MAX_V];\n\nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> > que;\n  fill(d,d+MAX_V,INF);\n  fill(prevv,prevv+MAX_V,-1);\n  d[s] = 0;\n  que.push(P(0,s));\n  while(!que.empty()){\n\t  P p = que.top();\n\t  que.pop();\n\t  int v = p.second;\n\t  if(d[v] < p.first)\n\t\t  continue;\n\t  for(int i = 0; i < G[v].size(); i++){\n\t\t  edge e = G[v][i];\n\t\t  if(d[e.to] > d[v] + e.cost){\n\t\t\t  d[e.to] = d[v] + e.cost;\n\t\t\t  que.push(P(d[e.to],e.to));\n\t\t\t  // ツつサツづ個ノツーツドツづ鳴づ個催短ツ仰猟猟」ツ経ツ路ツづーツ記ツ録ツつオツづつィツつュ\n\t\t\t  prevv[e.to] = v;\n\t\t  }\n\t  }\n  }\n}\n\n\nint main(){\n\n\tint n,m;\n\tcin>>n;\n\tcin>>m;\n\tchar cm;\n\tfor(int i = 0; i < m; i++){\n\t\tint from,to,c1,c2;\n\t\tcin>>from>>cm>>to>>cm>>c1>>cm>>c2;\n\t\tedge e;\n\t\te.to = to;\n\t\te.cost = c1;\n\t\tG[from].push_back(e);\n\t\te.cost=c2;\n\t\te.to=from;\n\t\tG[to].push_back(e);\n\t}\n\n\tint s,g;\n\tint money;\n\tint val;\n\tcin>>s>>cm>>g>>cm>>money>>cm>>val;\n\n\tint sumCost=0;\n\tdijkstra(s);\n\tsumCost+=d[g];\n\tdijkstra(g);\n\tsumCost+=d[s];\n\n\tint t=money-val-sumCost;\n\tcout<<t<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\n\n#define SIZE 100\n#define INF 1000000\nusing namespace std;\n\nint main(){\n\n  int i,j,k;\n  int n,m;\n  int a,b,c,d;\n  int s,g,x,y;\n  int cost[SIZE][SIZE];\n\n  cin>>n;\n  cin>>m;\n\n  for(i=1;i<n+1;i++){\n    for(j=1;j<n+1;j++){\n      cost[i][j]=INF;\n    }\n  }\n\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\n    cost[a][b]=c;\n    cost[b][a]=d;\n  }\n\n  for(i=1;i<n+1;i++){\n    for(j=1;j<n+1;j++){\n      for(k=1;k<n+1;k++){\n\tcost[j][k]=min(cost[j][k],cost[j][i]+cost[i][k]);\n      }\n    }\n  }\n\n  scanf(\"%d,%d,%d,%d\",&s,&g,&x,&y);\n\n  x-=cost[s][g]+cost[g][s]+y;\n  printf(\"%d\\n\",x);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int inf = 1001001001;\nint n,m,a,b,c,d,x1,x2,y1,y2;\nint K[32][32];\n\nvoid floyd(){\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                if(K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n}\n\nvoid show(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(j!=1)\n                cout <<\" \";\n            cout << K[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    for(int i=0;i<32;i++){\n        for(int j=0;j<32;j++){\n            K[i][j] = inf;\n        }\n    }\n    scanf(\"%d%d\", &n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        // cerr << \"read \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    floyd();\n    scanf(\"%d,%d,%d,%d\", &x1,&x2,&y1,&y2);\n    // show();\n    cout << y1 - y2 - K[x1][x2] - K[x2][x1]<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf = 1001001001;\n\nint main(){\n for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1<<29\n#define F first\n#define S second;\n\ntypedef pair<int,int>P;\ntypedef struct{\n  int cost,to;\n}Edge;\nint n,m;\nvector<Edge>g[21];\nint D[21];\nint starts,goal; \n\nint daikusutora();\n\nint main(){\n  int a,b,c,d;\n  int money,hasi;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    g[a].push_back((Edge){c,b});\n    g[b].push_back((Edge){d,a});\n  }\n  scanf(\"%d,%d,%d,%d\",&starts,&goal,&money,&hasi);\n  starts--;goal--;\n  money-=hasi;\n  money-=daikusutora();\n  money-=daikusutora();\n  cout<<money<<endl;\n}\n\nint daikusutora(){\n  for(int i=0;i<21;i++){\n   D[i]=INF;\n  }\n  priority_queue<P,vector<P>,greater<P> >que;\n  D[starts]=0;\n  que.push(P(0,starts));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int now =p.F;\n    int place =p.S;\n    for(int i=0;i<g[place].size();i++){\n      if(D[g[place][i].to]>now+g[place][i].cost){\n\tD[g[place][i].to]=now+g[place][i].cost;\n\tque.push(P(D[g[place][i].to],g[place][i].to));\n      }\n    }\n  }\n  int temp;\n  temp=starts;\n  starts=goal;\n  goal=temp;\n  return D[starts];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21][2];\nbool road[21][21];\nint serch(int start,int finish,int money,int go,int now)\n{\n\tif(money<0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(road[now][i])ans=max(ans,serch(start,finish,money-place[now][i][go],go,i));\n\tfor(int i=1;i<=n;i++)if(road[i][now])ans=max(ans,serch(start,finish,money-place[i][now][go],go,i));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tchar a;\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tfor(int j=0;j<2;j++)place[num[0]][num[1]][j]=num[2+j];\n\t\troad[num[0]][num[1]]=1;\n\t}\n\tint get[4];\n\tchar a;\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define INF (1LL << 60)\nusing namespace std;\nbool used[200000]; long long dist[200000];\nvoid dijkstra(int V, int E, int s, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[s] = 0; Q.push(make_pair(0, s));\n\tint cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt > E) return;\n\t\tpair<long long, int> p = Q.top(); used[p.second] = true; Q.pop();\n\t\tfor (int i = 0; i < X[p.second].size(); i++) {\n\t\t\tint to = X[p.second][i].first; long long leng = X[p.second][i].second;\n\t\t\tif (dist[to] > dist[p.second] + leng && !used[to]) {\n\t\t\t\tdist[to] = dist[p.second] + leng;\n\t\t\t\tQ.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\nint V, E, a, b, c, d, f1, f2, g1, g2; vector<pair<int, long long> > G[200000];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG[a - 1].push_back(make_pair(b - 1, c));\n\t\tG[b - 1].push_back(make_pair(a - 1, d));\n\t}\n\tscanf(\"%d,%d,%d,%d\", &f1, &f2, &g1, &g2); g1 -= g2;\n\tdijkstra(V, E, f1 - 1, G); g1 -= dist[f2 - 1];\n\tdijkstra(V, E, f2 - 1, G); g1 -= dist[f1 - 1];\n\tprintf(\"%d\\n\", g1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\n#include <array>\n\nusing namespace std;\n\nstruct Edge{\n  int to;\n  int cost;\n};\n\ntypedef pair<int, int> P; // min distance, vertex id\n\nconst int kMaxVertex = 21;\nconst int kInf = 1 << 30;\nvector<Edge> G[kMaxVertex];\nint d[kMaxVertex];\n\nvoid Dijkstra(int start, int num_vertex){\n  priority_queue<P, vector<P>, greater<P> > q;\n  fill(d, d + num_vertex + 1, kInf);\n  d[start] = 0;\n  q.push(P(0, start));\n\n  while(q.size()){\n\tP p = q.top();\n\tq.pop();\n\tint from = p.second;\n\tif(d[from] < p.first){\n\t  continue;\n\t}\n\n\tfor(int i=0; i<G[from].size(); i++){\n\t  Edge e = G[from][i];\n\t  // new route requires less cost\n\t  if(d[e.to] > d[from] + e.cost){\n\t\td[e.to] = d[from] + e.cost;\n\t\tq.push(P(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  int num_vertex, num_road;\n  scanf(\"%d \", &num_vertex);\n  scanf(\"%d \", &num_road);\n  for(int i=0; i<num_road; i++){\n\tint a, b, c, d;\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tG[a].push_back({b, c});\n\tG[b].push_back({a, d});\n  }\n  int start, goal, money, cost;\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&cost);\n  Dijkstra(start, num_vertex);\n  cost += d[goal];\n  Dijkstra(goal, num_vertex);\n  cost += d[start];\n\n  printf(\"%d\\n\", money - cost);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<list>\n#include<stdio.h>\n#include<math.h>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nint dp[1005][1005];\n\nint main(){\n    int n,m;\n    while(cin >> n >> m){\n        rep(i,1005){\n            rep(j, 1005){\n                dp[i][j] = 2 << 24;\n            }\n        }\n        rep(i,m){\n            int a, b, c ,d;\n            scanf(\"%d%*c%d%*c%d%*c%d\",&a, &b, &c, &d);\n            dp[a][b] = c;\n            dp[b][a] = d;\n        }\n        int st, ed, in, out;\n        scanf(\"%d%*c%d%*c%d%*c%d\",&st, &ed, &in, &out);\n        rep(k,n + 1){\n            rep(i,n + 1){\n                rep(j,n + 1){\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n        cout << in - out - dp[st][ed] - dp[ed][st] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>8)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 1 << 25;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INFG); //distance\n\tdist[s] = 0; PQ.push(State(0, s, -1)); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.push(State(dist[e.d], e.d, v));\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tGraph g(n);\n\tchar cc;\n\trep(i, 0, m) {\n\t\tint a, b, c, d; cin >> a >> cc >> b >> cc >> c >> cc >> d; a--, b--;\n\t\tg[a].emplace_back(a, b, c);\n\t\tg[b].emplace_back(b, a, d);\n\t}\n\tint s, d, V, P; cin >> s >> cc >> d >> cc >> V >> cc >> P; s--, d--;\n\tvector<Weight> dist;\n\tdijkstra(g, s, dist);\n\tvector<Weight> dist2;\n\tdijkstra(g, d, dist2);\n\tcout << V - P - dist[d] - dist2[s] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// A Reward For a Carpenter\n// 問題URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117&lang=jp\n// 中央*右\n//  \n// 直感的で分かりやすいアルゴリズムだと思いました。scanfによる入出力に戸惑いました。\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n, m, a, b, c, d, ans=0, s, g, V, P;\nint Cost[32][32]={};\n\nconst int inf = 1001001001;\n\nvoid show(){ //隣接行列を表示\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j){\n            if(Cost[i][j] == inf) cout << \"INF \";\n            else cout << Cost[i][j] << \" \";\n            if(j == n) cout << endl;\n    } \n}\n\nvoid solve(){\n    for(int k = 1; k <= n; ++k)\n        for(int i = 1; i <= n; ++i)\n            for(int j = 1; j <= n; ++j)\n                Cost[i][j] = min(Cost[i][j],Cost[i][k] + Cost[k][j]); //iからjまで行くのに、地点kを経由した方がコストが低ければ書き換える\n    // show();\n\n    cout << V - P - Cost[s][g] - Cost[g][s] << endl;\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n\n    for(int i = 1; i <= n; ++i) //隣接行列をinfで初期化\n        for(int j = 1; j <= n; ++j) Cost[i][j] = inf;\n\n    for(int i = 0; i < m; ++i){\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        // cerr << \"(a, b, c, d) = (\" << a << \", \" << b << \", \" << c << \", \" << d << \")\" << endl;\n        Cost[a][b] = c;\n        Cost[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    // cerr << \"(s,g,V,P) = (\" << s << \", \" << g << \", \" << V << \", \" << P  << \")\" << endl; \n    // show();\n\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e+9;\n\nint main(){\n\tint n,m,dist[21][21];\n\t\n\tfor(int i=0 ; i < 21 ; i++ )\n\t\tfor(int j=0 ; j < 21 ; j++ )\n\t\t\tdist[i][j] = INF;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i=0 ; i < m ; i++ ){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdist[a][b] = c;\n\t\tdist[b][a] = d;\n\t}\n\tfor(int k=1 ; k <= n ; k++ ){\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tfor(int j=1 ; j <= n ; j++ ){\n\t\t\t\tdist[i][j] = min( dist[i][j] , dist[i][k]+dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = y1 - (y2 + dist[x1][x2] + dist[x2][x1]);\n\tprintf(\"%d\\n\", ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf = 1001001001;\nint main() {\n scanf(\"%d%d\", &N, &M);\n for (int i=1; i<=N; ++i) {\n  for (int j=1; j<=N; ++j) {\n   K[i][j] = inf;\n  }\n }\n for (int i=0; i<M; ++i) {\n  scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n  K[A][B] = C;\n  K[B][A] = D;\n }\n for (int k=1; k<=N; ++k) {\n  for (int i=1; i<=N; ++i) {\n   for (int j=1; j<=N; ++j) {\n    if (K[i][j] > K[i][k] + K[k][j]) { K[i][j] = K[i][k] + K[k][j]; }\n   }\n  }\n }\n scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n int ans = y1 - K[x1][x2] - K[x2][x1] - y2;\n printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nconst int inf = 100100100;\nint edge[30][30];\n\nint main() {\n  int N, M; scanf(\"%d%d\", &N, &M);\n  REP(i, N) REP(j, N) edge[i][j] = inf;\n  REP(i, N) edge[i][i] = 0;\n  \n  REP(m, M) {\n      int a, b, c, d;\n      scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n      a--, b--;\n      edge[a][b] = c;\n      edge[b][a] = d;\n  }\n  REP(k, N) REP(i, N) REP(j, N)\n      edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\n  int start, end, have, price;\n  scanf(\"%d,%d,%d,%d\", &start, &end, &have, &price);\n  start--, end--;\n  int ans = have - (edge[start][end] + edge[end][start] + price);\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint city[21][21],n,load[21][21];\nint power(int n)\n{\n    int num=1;\n    for(int i=0;i<n;i++)num*=10;\n    return num;\n}\nint aserch(int endp,int now,int befor)\n{\n    int money=50000;\n    if(city[now][endp]!=-1)return city[now][endp];\n    else{\n        for(int i=1;i<=n;i++){\n                if(city[now][i]!=-1&&i!=befor&&load[now][i]!=1000){\n                    load[now][i]++;\n                    money=min(aserch(endp,i,now)+city[now][i],money);\n                }\n        }\n    }\n    return money;\n}\nint bserch(int stap,int now,int befor)\n{\n    int money=50000,num;\n    if(city[now][stap]!=-1){\n        return city[now][stap];\n    }\n    else{\n        for(int i=1;i<=n;i++){\n            if(city[now][i]!=-1&&i!=befor&&load[now][i]!=1000){\n                    load[now][i]++;\n                   num=bserch(stap,i,now)+city[now][i];\n                   if(num>-1)money=min(num,money);\n            }\n        }\n    }\n    return money;\n\n}\nint main()\n{\n    int m;\n    cin>>n>>m;\n    memset(city,-1,sizeof(city));\n    memset(load,0,sizeof(load));\n    string str;\n    for(int i=0;i<m;i++){\n        int kawa[2]={};\n        cin>>str;\n        for(int j=0,co=0,point=0;;j++){\n            if(str[j]==','||str[j]=='\\0'){\n                int mo=0;\n                if(co<2){\n                    for(int k=point;k<j;k++)kawa[co]+=(str[k]-'0')*power(j-k-1);\n                    point=j+1;\n                    co++;\n                }\n                else if(co==2){\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[0]][kawa[1]]=mo;\n                    point=j+1;\n                    co++;\n                }\n                else{\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[1]][kawa[0]]=mo;\n                    break;\n                }\n            }\n        }\n    }\n    cin>>str;\n    int pointing[3]={},Pillar=0;\n    for(int i=0,co=0,point=0;;i++){\n        if(str[i]==','){\n            for(int j=point;j<i;j++)pointing[co]+=(str[j]-'0')*power(i-j-1);\n            point=i+1;\n            co++;\n        }\n        if(str[i]=='\\0'){\n            for(int j=point;j<i;j++)Pillar+=(str[j]-'0')*power(i-j-1);\n            break;\n        }\n    }\n    cout<<pointing[2]-Pillar-aserch(pointing[1],pointing[0],0)-bserch(pointing[0],pointing[1],0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£????????????\n#endif\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[32][32];\nconst int inf=1001001001;\nint pay;\n\nint main(){\n\t//??????Inf??§???????????????????????????\n\tfor(int i=0;i<32;i++)\n\t\tfor(int j=0;j<32;j++)\n\t\t\tK[i][j]=inf;\n\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=0;i<M;++i){\n\t\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\t\t//cerr<<\"read \"<<A<<' '<<B<<' '<<C<<' '<<D<<endl;\n\t\tK[A][B]=C;\n\t\tK[B][A]=D;\n\n/*\t\tfor(int i=1;i<N+1;i++){//?????§?????????\n    for(int j=1;j<N+1;j++){\n      if(K[i][j]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[i][j]<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n*/\n\tfor(int k=1;k<N+1;k++)\n\t\tfor(int i=1;i<N+1;i++)\n\t\t\tfor(int j=1;j<N+1;j++)\n\t\t\t\tif(K[i][j]>K[i][k]+K[k][j])\n\t\t\t\t\tK[i][j]=K[i][k]+K[k][j];\n\n/*\t for(int l=1;l<N+1;l++){//?????§??????2???\n    for(int m=1;m<N+1;m++){\n      if(K[l][m]==inf){\n\tcout<<\"inf\"<<\" \";\n      }else{\n\tcout<<K[l][m]<<\" \";\n      }\n    }\n    cout<<endl;\n    } \n    cout<<endl;\n*/\n\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\tpay=K[A][B]+K[B][A];\n\tcout<<C-D-pay<<endl; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#import<cstdio>\nint main(){int i,j,k,a,b,c,d,n,m,D[21][21];for(i=0;i<21;i++)for(j=0;j<21;j++)D[i][j]=1e+9;scanf(\"%d%d\",&n,&m);for(i=0;i<m;i++)scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d),D[a][b]=c,D[b][a]=d;for(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)D[i][j]=(D[i][j]<D[i][k]+D[k][j])?D[i][j]:D[i][k]+D[k][j];scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);printf(\"%d\\n\",c-d-D[a][b]-D[b][a]);}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\n    int N, M, st, A, B, C, D, X1, X2, Y1, Y2;\n    int K[24][24];\n    scanf(\"%d%d\", &N, &M);\n    {\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                K[i][j] = INT_MAX;\n            }\n        }\n        for(int i=0;i<M;++i){\n            scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n            K[A-1][B-1]=C;\n            K[B-1][A-1]=D;\n        }\n        scanf(\"%d,%d,%d,%d\", &X1, &X2, &Y1, &Y2);\n        for(int k=0;k<N;++k){\n            for(int j=0;j<N;++j){\n                for(int i=0;i<N;++i){\n                    K[j][i] = min(K[j][i], K[j][k] + K[k][i]);\n                }\n            }\n        }\n    }\n    return Y1-Y2-K[X1-1][X2-1]-K[X2-1][X1-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n\nstruct edge {\n\tint cost;\n\tint to;\n};\n\nll INF = 1000000000;\nint N,M,s,g,v,p;\nll d[110];\nvector<edge> G[110];\n\nvoid dijkstra(int s) {\n\tpriority_queue<pl, vector<pl>, greater<pl> > q;\n\tfill(d, d + N, INF);\n\td[s] = 0;\n\tq.push(pl(0, s));\n\n\twhile (!q.empty()) {\n\t\tpl p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(pl(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll ans = 0;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c, d;\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tG[a].push_back({c,b});\n\t\tG[b].push_back({d,a});\n\t}\n\tscanf_s(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--, g--;\n\tdijkstra(s);\n\tans += d[g];\n\tdijkstra(g);\n\tans += d[s];\n\tcout << v - p - ans << endl;\n\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define inf 999999\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n\tint f[21][21], n, m, a, b, c, d;\n\t\n\twhile(cin >> n >> m){\n\t\tfill(&f[1][1], &f[n+1][n+1], inf);\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tf[i][i] = 0;\n\t\t}\n\t\twhile(m--){\n\t\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\tf[a][b] = c;\n\t\t\tf[b][a] = d;\n\t\t}\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tf[i][j] = (f[i][j] < f[i][k]+f[k][j])? f[i][j] : f[i][k]+f[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (c-d-f[a][b]-f[b][a]) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nconst int inf = 1001000100;\nint K[32][32]={};\n\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n\n  for (int i=1; i<N+1; i++)\n    for (int j=1; j<N+1; j++)\n      K[i][j] = inf;\n  \n  for (int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  \n  for (int k=1; k<N+1; k++){\n    for (int i=1; i<N+1; i++){\n      for (int j=1; j<N+1; j++){\n\tif (K[i][j] > K[i][k] + K[k][j])\n\t  K[i][j] = K[i][k] + K[k][j];\n\t//cout << K[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n  }\n\n  \n\n  cout << y1 - y2 - K[x1][x2] -K[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20];\n\tfor (int i = 0; i < n; i++)d[i] = 1000000000;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top(); pq.pop();\n\t\tint t = tmp.second;\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t\tpq.emplace(d[E[t][i].first], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tcout << c - d - djk(a, b) - djk(b, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint N,M,A,B,C,D;\nconst int inf = 100000;\nint main()\n{\n\tcin >> N >> M;\n\tint K[32][32];\n\tfor(int i = 1; i < N+1; i++)\n\t{\n\t\tfor(int j = 1; j < N+1; j++)\n\t\t{\n\t\t\tK[i][j] = inf;\n\t\t}\n\t}\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\t\tK[A][B] = C;\n\t\tK[B][A] = D;\n\t}\n\tfor(int k = 1; k < N+1; k++)\n\t{\n\t\tfor(int i = 1;i < N+1;i++)\n\t\t{\n\t\t\tfor(int j = 1;j < N+1;j++)\n\t\t\t{      \n\t\t\t\tK[i][j] = min( K[i][j], K[i][k] + K[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint s,g,V,P;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\tV -= K[s][g];\n\tV -= K[g][s];\n\tV -= P;\n\tcout << V <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX>>1\n\nint n,m,a,b,c,d,x1,x2,y1,y2;\nvector< vector<int> >M;\n\nint WarshallFloyd(int start,int goal)\n{\n  vector< vector<int> >A(n,vector<int>(n,NONE));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(M[i][j]!=NONE)A[i][j]=M[i][j];\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tA[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n  return A[start][goal];\n}\n\nint main()\n{\n  cin>>n>>m;\n  M.resize(n);\n  for(int i=0;i<n;i++)M[i].resize(n,NONE);\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    M[a][b]=c;\n    M[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  x1--;x2--;\n  cout<<(y1-y2-WarshallFloyd(x1,x2)-WarshallFloyd(x2,x1))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\nconst int MAX_N = 20;\n// 隣接行列\n// map[a][b] = a->bのコスト\nconst int MAX = 0x7fffffff;//通行不可を表す\nint map[MAX_N+1][MAX_N+1];\n// 街の総数，街道の総数\nint n, m;\n\n// そこまでのコスト-場所\ntypedef pair<int, int> node;\nbool visited[MAX_N+1];\nint solve(int from, int to) {\n\tfill(visited, visited + MAX_N+1, false);\n\tpriority_queue< node, vector<node>, greater<node> > que;\n\tque.push(node(0, from));\n\twhile (!que.empty()) {\n\t\tnode point = que.top();\n\t\tque.pop();\n\t\tif (point.second == to) {\n\t\t\treturn point.first;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (map[point.second][i] < MAX && !visited[i]) {\n\t\t\t\tque.push(node(point.first + map[point.second][i], i));\n\t\t\t}\n\t\t}\n\t\tvisited[point.second] = true;\n\t}\n\treturn -1;\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\t//最大コストで初期化\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tmap[i][j] = MAX;\n\tint a, b, c, d;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tmap[a][b] = c;\n\t\tmap[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tprintf(\"%d\\n\", c - d - solve(a, b) - solve(b, a));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint MAP[21][21],mn,MN,a,b,c,d,n,m,w,x,y,z,v[21],u[21];\nint compute(int start,int goal){\n  for(int i=1;i<=n;i++)v[i]=u[i]=INF;\n  v[start]=0;\n  while(1){\n    mn=INF;\n    for(int i=1;i<=n;i++){\n      if(v[i]<mn&&u[i]==INF){\n\tmn=v[i];\n\tMN=i;\n      }\n    }\n    if(mn==INF)break;\n    u[MN]=0;\n    for(int i=1;i<=n;i++)if(MAP[MN][i]+v[MN]<v[i])v[i]=v[MN]+MAP[MN][i];\n  }\n  return v[goal]; \n}\nint main(){\n  cin>>n>>m;\n  \n  for(int i=1;i<=20;i++)for(int j=1;j<=20;j++)MAP[i][j]=INF;\n  for(int i=1;i<=m;i++){\n    cin>>a>>ch>>b>>ch>>c>>ch>>d;\n    MAP[a][b]=c;\n    MAP[b][a]=d;\n  }\n  cin>>w>>ch>>x>>ch>>y>>ch>>z;\n  cout<<y-z-compute(w,x)-compute(x,w)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nint main() {\n\tint n, m, s, g, V, P;\n\tint mincost[20][20];\n\t\n\tcin >> n >> m;\n\t\n\tREP(i, n) REP(j, n) {\n\t\tif (i == j) mincost[i][j] = 0;\n\t\telse mincost[i][j] = INF;\n\t}\n\t\n\tREP(i, m) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tmincost[a][b] = c;\n\t\tmincost[b][a] = d;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\ts--; g--;\n\t\n\tREP(k, n) REP(i, n) REP(j, n) {\n\t\tif (mincost[i][j] > mincost[i][k] + mincost[k][j])\n\t\t\tmincost[i][j] = mincost[i][k] + mincost[k][j];\n\t}\n\t\n\tcout << V - P - mincost[s][g] - mincost[g][s] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n\nusing namespace std;\n\nint main(){\n\tconst int maxsize=20;\n\tint size;\n\tint E[maxsize][maxsize];\n\tint qqq = 999999999;\n\tint cost[maxsize];\n\tbool used[maxsize];\n\n\tint m;\n\n\tcin >> size;\n\tcin >> m;\n\n\tfor(int i=0;i<size;i++){\n\t\tused[i] = false;\n\t\tcost[i] = qqq;\n\t\tfor(int j=0;j<size;j++){\n\t\t\tE[i][j] = qqq;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tchar cnm;\n\t\tcin >> a >> cnm >> b >> cnm >> c >> cnm >> d;\n\t\tE[a-1][b-1] = c;\n\t\tE[b-1][a-1] = d;\n\t}\n\tint x,y,xx,yy;\n\tchar cnm;\n\tcin >> x >> cnm >> y >> cnm >> xx >> cnm >> yy;\n\tcost[x-1] = 0;\n\txx -= yy;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(!used[i] && (v==-1 || cost[v] > cost[i])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\t\t\n\t\tif(v==-1 || v == y-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcost[i] = min(cost[i],cost[v]+E[v][i]);\n\t\t}\n\t}\n\txx -= cost[y-1];\n\tfor(int i=0;i<size;i++){\n\t\tused[i] = false;\n\t\tcost[i] = qqq;\n\t}\n\tcost[y-1] = 0;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(!used[i] && (v==-1 || cost[v] > cost[i])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\t\t\n\t\tif(v==-1 || v == x-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcost[i] = min(cost[i],cost[v]+E[v][i]);\n\t\t}\n\t}\n\txx -= cost[x-1];\n\tcout << xx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\n#define mp make_pair\n#define all(x) x.begin(),x.end()\nusing namespace std;\nint n, m, i1, i2, i3, i4;\ntypedef pair<int, int>P;\nvector<P>v[34];\nint dijkstra(int p, int key) {\n\tpriority_queue<P, vector<P>, greater<P>>pq;\n\tpq.push(make_pair(0, p));\n\tint a[123456]; for (int i = 0; i < 123456; i++)a[i] = -1;\n\twhile (pq.size()) {\n\t\tP p1 = pq.top(); pq.pop();\n\t\tif (p1.second == key)return p1.first;\n\t\tif (a[p1.second] == -1) {\n\t\t\ta[p1.second] = p1.first;\n\t\t\tfor (P i : v[p1.second])\n\t\t\t\tif (a[i.first] == -1)pq.push(make_pair(p1.first + i.second, i.first));\n\t\t}\n\t}\n}\nint input() {\n\tstring s; cin >> s;\n\ts += ',';\n\tint cnt = 0, k = 0;\n\tfor (char ch : s) {\n\t\tif (ch == ',') {\n\t\t\tif (cnt == 0)i1 = k;\n\t\t\tif (cnt == 1)i2 = k;\n\t\t\tif (cnt == 2)i3 = k;\n\t\t\tif (cnt == 3)i4 = k;\n\t\t\tk = 0; cnt++;\n\t\t}\n\t\telse {\n\t\t\tk *= 10; k += ch - '0';\n\t\t}\n\t}\n}\nsigned main() {\n\tcin >> n >> m;\n\tfor1(i, m) {\n\t\tinput();\n\t\tv[i1].push_back(mp(i2, i3));\n\t\tv[i2].push_back(mp(i1, i4));\n\t}\n\tinput();\n\tcout << i3 - i4 - dijkstra(i1, i2) - dijkstra(i2, i1) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\n\nstruct Node{\n  int num;\n\n  vector<int> edge_to;\n  vector<int> edge_cost;\n\n  bool done;\n  int cost;\n};\n\nvector<string> splitAll(string s, string t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0, p));\n    s = s.substr(p + t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nint dijkstra (vector<Node> g,int start,int goal){\n  int d;\n  g[start].cost=0;\n\n  while(1){\n    d=-1;\n\n    for(int i=1;i<=g.size();i++){\n      if( g[i].done || g[i].cost < 0 ) continue;\n      if( d==-1 || g[i].cost < g[d].cost ) d=i;\n    }\n\n    if(d==-1) break;\n    g[d].done=true;\n\n    for(int i=0; i< g[d].edge_to.size(); i++){\n      int to = g[d].edge_to[i];\n      int cost = g[d].cost + g[d].edge_cost[i];\n      if(g[to].cost < 0 || cost < g[to].cost)\n\tg[to].cost = cost;\n    }\n  }\n\n  return g[goal].cost;\n}\n\n\nint main(){\n  int n,m;\n  cin>>n;\n\n  vector<Node> graph;\n  graph.reserve(n+1);\n  graph.resize(n+1);\n\n  for(int i=1; i<=n; i++){\n    graph[i].num=(i+1);\n    graph[i].cost=-1;\n    graph[i].done=false;\n  }\n\n  string s;\n\n  cin>>m;\n  getline(cin,s);\n\n  int a,b,c,d;\n  vector<string> vv;\n  vv.reserve(4);\n  vv.resize(4);\n\n  while(m--){\n    getline(cin,s);\n    vv = splitAll(s,\",\");\n\n    a = atoi( vv[0].c_str() );\n    b = atoi( vv[1].c_str() );\n    c = atoi( vv[2].c_str() );\n    d = atoi( vv[3].c_str() );\n\n    graph[a].edge_to.push_back(b);\n    graph[a].edge_cost.push_back(c);\n    graph[b].edge_to.push_back(a);\n    graph[b].edge_cost.push_back(d);\n\n  }\n\n  int x1,x2,y1,y2;\n  getline(cin,s);\n  vv = splitAll(s,\",\");\n\n  x1 = atoi( vv[0].c_str() );\n  x2 = atoi( vv[1].c_str() );\n  y1 = atoi( vv[2].c_str() );\n  y2 = atoi( vv[3].c_str() );\n\n  vector<Node> n;\n  n.reserve(n+1);\n  n.assign(graph.begin(),graph.end());\n\n  int rcost = dijkstra(graph,x2,x1);\n  int gcost = dijkstra(n,x1,x2);\n\n  cout<<y1-y2-rcost-gcost<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 1000000000;\nusing namespace std;\nint main() {\n  int n, m;\n  char q;\n  cin >> n >> m;\n  int dp[n][n];\n  rep(i, n) rep(j, n) dp[i][j] = i == j ? 0 : INF;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> q >> b >> q >> c >> q >> d;\n    a--;\n    b--;\n    dp[a][b] = c;\n    dp[b][a] = d;\n  }\n  rep(k, n) rep(i, n) rep(j, n) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n  int s, g, V, P;\n  cin >> s >> q >> g >> q >> V >> q >> P;\n  s--;\n  g--;\n  cout << V - P - dp[s][g] - dp[g][s] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\ntypedef pair<ll,int> LL_IP;\n\n\n#define ARRAY_MAX 101\n\n\n\n\n\ntypedef struct edge{\n    int from;\n    int to;\n    int cost;\n}EDGE;\n\n\n/*頂点sから各頂点への最短距離を求めること、頂点sから到達できる負閉路があれば真が返る、目的地が決まっているバージョン*/\n/*V-1回の更新で各ノードへの最短距離は求められる*/\n/*V回目から2V回目までに最短距離が更新される場合は目的地を含む負閉路が存在する*/\nbool shortest_path(int v,int e,int s,int t,vector<EDGE>& arr,vector<int>& d){\n    /*頂点の個数、辺の個数、始点となる頂点、目的地の頂点、辺の情報、最短距離*/\n    for(int i = 0;i < d.size();i++){\n        d[i] = INF;\n    }\n    d[s]=0;\n    \n    for(int i = 0;i < 2*v;i++){\n        for(int j = 0;j < e;j++){\n            EDGE tmp = arr[j];\n            if(d[tmp.from] != INF && d[tmp.to] > d[tmp.from] + tmp.cost){\n                d[tmp.to] = d[tmp.from] + tmp.cost;\n                if(i >= v-1 && tmp.to == t){\n                    return true;\n                }\n\n            }\n        }\n    }\n    return false;\n}\n\n\n\n\n\nint main(){\n\n\n    int n,m,a,b,c,d;\n    int s,g,v,p;\n    char t;\n    cin >> n >> m;\n   \n    vector<EDGE> G;/*n個の各頂点からそれ以外の頂点へのコスト*/\n    vector<int> d1(n,INF);/*出発地点から柱までの最短経路*/\n    vector<int> d2(n,INF);/*柱から出発地点までの最短経路*/\n\n    \n    REP(i,m){\n        cin >> a >> t >> b >> t >> c >> t >> d;\n\n        a--;\n        b--;/*配列の添え字へ合わせる*/\n        EDGE e1 = {a,b,c};\n        EDGE e2 = {b,a,d};\n        G.push_back(e1);\n        G.push_back(e2);\n    }\n    /*グラフの作成が終了*/\n\n    cin >> s >> t >> g >> t >> v >> t >> p;\n    s--;\n    g--;/*配列の添え字に合わせる*/\n\n   \n    bool ans1 = shortest_path(n,m*2,s,g,G,d1);\n    bool ans2 = shortest_path(n,m*2,g,s,G,d2);\n\n    /*REP(i,n){\n        cout << d1[i] << \" \";\n    }\n    cout << endl;\n\n    REP(i,n){\n        cout << d2[i] << \" \";\n    }\n    cout << endl;\n    cout << g << s << endl;\n    cout << d1[g] << \" \" << d2[s] << endl;\n    */\n     \n    ll ans = v - p - d1[g] - d2[s];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <map>\n#define number(node) edge_to[node][0]\n#define INFINITY 999999\nusing namespace std;\nint n, m, start[2], paid, pole, cost[2][20], edge_to[20][21], edge_cost[20][21];\n\nint comp_0(const void *a, const void *b)\n{\n    return cost[0][*(int*)a] - cost[0][*(int*)b];\n}\n\nint comp_1(const void *a, const void *b)\n{\n    return cost[1][*(int*)a] - cost[1][*(int*)b];\n}\n\nint main()\n{\n    int from, to, c1, c2;\n    fill((int *)edge_to, (int *)(edge_to + 20), 0);\n    fill((int *)edge_cost, (int *)(edge_cost + 20), 0);\n    fill((int *)cost, (int *)(cost + 2), INFINITY);\n    \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d,%d,%d,%d\", &from, &to, &c1, &c2);\n        edge_to[from][++number(from)] = to;\n        edge_cost[from][number(from)] = c1;\n        edge_to[to][++number(to)] = from;\n        edge_cost[to][number(to)] = c2;\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &start[0], &start[1], &paid, &pole);\n    for (int g = 0; g < 2; g++)\n    {\n        int unchecked[20], k = 0;\n        for (int i = 1; i <= n; i++)\n            if (i == start[g]) cost[g][i] = 0;\n            else\n            {\n                for (int j = 1; j <= number(i); j++)\n                    if (edge_to[i][j] == start[g])\n                    {\n                        cost[g][i] = edge_cost[i][j];\n                        break;\n                    }\n                unchecked[k++] = i;\n            }\n\n        while (k > 0)\n        {\n            qsort(unchecked, k, sizeof(int), (g ? comp_1 : comp_0));\n            for (int i = 0; i < number(unchecked[0]); i++)\n                if (cost[g][edge_to[unchecked[0]][i + 1]] > cost[g][unchecked[0]] + edge_cost[unchecked[0]][i + 1])\n                    cost[g][edge_to[unchecked[0]][i + 1]] = cost[g][unchecked[0]] + edge_cost[unchecked[0]][i + 1];\n            unchecked[0] = unchecked[--k];\n        }\n    }\n    \n    printf(\"%d\\n\", paid - pole - cost[0][start[1]] - cost[1][start[0]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int i,j;\n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int ans;\n  int rout[21][21];\n  int dis1[21],dis2[21];\n  int flag;\n\n  while(scanf(\"%d\",&n)!=EOF){\n    cin >> m;\n\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\trout[i][j] = 0;\n      }\n    }\n\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d,%d \",&a,&b,&c,&d);\n      rout[a][b] = c;\n      rout[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d \",&x1,&x2,&y1,&y2);\n\n    for(i=1;i<=n;i++)dis1[i] = -1;\n    for(i=1;i<=n;i++)dis2[i] = -1;\n    dis1[x1] = 0;\n    dis2[x2] = 0;\n\n    while(1){\n      flag = 0;\n\n      for(i=1;i<=n;i++){\n\tif(dis1[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>0){\n\t      if(dis1[j]<0){\n\t\tdis1[j] = dis1[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis1[i]+rout[i][j] < dis1[j]){\n\t\tdis1[j] = dis1[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n\tif(dis2[i]>=0){\n\t  for(j=1;j<=n;j++){\n\t    if(rout[i][j]>0){\n\t      if(dis2[j]<0){\n\t\tdis2[j] = dis2[i] + rout[i][j];\n\t\tflag = 1;\n\t      }else if(dis2[i]+rout[i][j] < dis2[j]){\n\t\tdis2[j] = dis2[i]+rout[i][j];\n\t\tflag = 1;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(!flag)break;\n    }\n  \n    ans = y1 - y2 -dis1[x2] - dis2[x1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\n#define pInt pair<int, int>\n\nstruct asc {\n\tbool operator() (const pInt &x, const pInt &y) const {\n\t\treturn x.second > y.second;\n\t}\n};\n\npriority_queue <pInt, vector<pInt>, asc> pq;\nint dijkstra(int *cost, int terminal, int n, vector<vector<int> > vc) {\n\twhile(!pq.empty()) {\n\t\tpInt p = pq.top();\n\t\tpq.pop();\n\t\trep(i,n) {\n\t\t\tif(vc[p.first][i] != -1) {\n\t\t\t\tint total = p.second + vc[p.first][i];\n\t\t\t\tif(total < cost[i]) {\n\t\t\t\t\tpq.push(make_pair(i,total));\n\t\t\t\t\tcost[i] = total;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cost[terminal];\n}\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > vc(n); \n\trep(i,n) {\n\t\tvector<int> va(n);\n\t\tvc[i] = va;\n\t\trep(j,n) {\n\t\t\tvc[i][j] = -1;\n\t\t}\n\t}\n\trep(i,m) {\n\t\tint s, t, c1, c2;\n\t\tscanf(\"%d,%d,%d,%d\", &s, &t, &c1, &c2);\n\t\tvc[--s][--t] = c1;\n\t\tvc[t][s] = c2;\n\t}\n\tint s, g, a, b;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &a, &b);\n\t--s, --g;\n\tint cost[20] = {};\n\n\trep(i,n) {\n\t\tif(i==s)cost[i] = 0;\n\t\telse cost[i] = INT_MAX;\n\t}\n\tpq.push(make_pair(s,0));\n\tint ret = 0;\n\tret += dijkstra(cost, g, n, vc);\n\n\trep(i,n) {\n\t\tif(i==g)cost[i] = 0;\n\t\telse cost[i] = INT_MAX;\n\t}\n\tpq.push(make_pair(g,0));\n\tret += dijkstra(cost, s, n, vc);\n\n\tcout << a - b - ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 21;\nconst int INF = (1<<25);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint start,fin,mon,cos;\n\nint solve_go(){\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  }\n  return cost[fin];\n}\n\nint solve_ret(){\n  fill(come,come+MAX_C,0);\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[fin]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n\t  minPos = i;\n\t}\n      }\n    }\n    come[minPos] = 1;\n\n    if(minPos == -1) break;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[start];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  cin >> n;\n  init();\n  for(int i = n+1; i < MAX_C; i++) come[i] = 1;\n  cin >> m;\n  for(int i = 0; i < m; i++){\n    int from,to,cft,ctf;\n    cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n    edge[from][to] = cft;\n    edge[to][from] = ctf;\n  }\n  cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n  cout << mon - cos - solve_go() - solve_ret() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<vector<int> >cost(n,vector<int>(n));\n\trep(i,n)rep(j,n)cost[i][j]=inf;\n\tint a,b,c,e;char x;\n\trep(i,m){\n\t\tcin>>a>>x>>b>>x>>c>>x>>e;\n\t\ta--;b--;\n\t\tcost[a][b]=c;\n\t\tcost[b][a]=e;\n\t}\n\tcin>>a>>x>>b>>x>>c>>x>>e;\n\ta--;b--;\n\tvector<bool>used(n);\n\tvector<int>d(n,inf);\n\td[a]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\trep(i,n)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\trep(i,n)d[i]=min(d[i],d[v]+cost[v][i]);\n\t}\n\tc-=d[b];\n\trep(i,n){used[i]=false;d[i]=inf;}\n\td[b]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\trep(i,n)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\trep(i,n)d[i]=min(d[i],d[v]+cost[v][i]);\n\t}\n\tc-=d[a];\n\tcout<<c-e<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n//\nint main(void){\n\n\tchar str;\n\tint n, m, a, b, c, d, s, g, s_cost, g_cost;\n\tint cost[21][21];\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i < n+1; i++){\n\t\tfor (int j = 1; j < n+1; j++) cost[i][j] = 1001;\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\n\t\tcin >> a >> str >> b  >> str >> c >> str >> d;\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\tcin >> s >> str >> g >> str >> s_cost >> str >> g_cost;\n\n\t/*for (int i = 1; i < n + 1; i++){\n\t\tfor (int j = 1; j < n + 1; j++) printf(\"%5d\",cost[i][j]);\n\t\tcout << endl;\n\t}\n\tcout << endl;*/\n\n\tfor (int i = 1; i < n + 1; i++){\n\t\tfor (int j = 1; j < n + 1; j++){\n\t\t\tfor (int k = 1; k < n + 1; k++){\n\t\t\t\tcost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\t\t\t\t//printf(\"%5d\", cost[i][j]);\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tcout << s_cost - g_cost - cost[s][g] - cost[g][s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct CITY{\n  vector<int> to;\n  vector<int> pay;\n  int cost;\n  bool done;\n};\nint main(){\n  int n,m,a,b,c,d,x,y,z,w,ans_cost=0;\n  CITY vil[30];\n  cin >>n>>m;\n  for(int i=0; i<m; i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    vil[a-1].to.push_back(b-1);\n    vil[a-1].pay.push_back(c);\n    vil[b-1].to.push_back(a-1);\n    vil[b-1].pay.push_back(d);\n  }\n  scanf(\"%d,%d,%d,%d\",&x,&y,&z,&w);\n  x--;y--;\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[x].cost = 0;\n  for(;;){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    if(vil[y].done){ans_cost+=vil[y].cost;break;}\n  }\n  for(int i=0; i<n; i++){vil[i].cost = 999999;vil[i].done = false;}\n  vil[y].cost = 0;\n  for(;;){\n    int r = 0,p = 999999;\n    for(int i=0; i<n; i++){\n      if(!vil[i].done){if(vil[i].cost<p){p = vil[i].cost;r = i;}}\n    }\n    vil[r].done = true;\n    for(int i=0; i<vil[i].to.size(); i++){\n      vil[vil[r].to[i]].cost = min(vil[vil[r].to[i]].cost,vil[r].cost+vil[r].pay[i]);\n    }\n    if(vil[x].done){ans_cost+=vil[x].cost;break;}\n  }\n  cout <<z-w-ans_cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22] = {0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin >> n >> m;\n    for(i = 1;i <= n;i++){\n        for(j = 1;j <= n;j++){\n            cost[i][j] = 1001001;\n        }\n    }\n    for(i = 0;i < m;i++){\n        cin >> a >> cc >> b >> cc >> c >> cc >> d;\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    for(k = 1;k <= n;k++){\n        for(i = 1;i <= n;i++){\n            for(j = 1;j <= n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin >> a >> cc >> b >> cc >> c >> cc >> d;\n            }\n        }\n    }\n    cout << c - d - cost[a][b] - cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nint G[20][20];\nint dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    rep(i, 20) rep(j, 20) G[i][j] = INF;\n    rep(i, m) {\n        int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    int x1, x2, y1, y2; scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = G[i][j];\n    //rep(i, n) dp[i][i] = 0;\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vp;\n\nint n, m;\nvector<vp> g; //pos, cost\n\nint dijkstra(int from, int to) {\n\tpriority_queue<pii, vector<pii>, greater<pii> > que; //cost, pos\n\tvector<int> d(n, INF);\n\t\n\tque.push(pii(0, from));\n\td[from] = 0;\n\twhile (! que.empty()) {\n\t\tint cost = que.top().first;\n\t\tint pos = que.top().second;\n\t\tque.pop();\n\t\t\n\t\tif (d[pos] < cost) continue;\n\t\t\n\t\tREP(i, g[pos].size()) {\n\t\t\tpii now = g[pos][i];\n\t\t\tif (d[now.first] > d[pos] + now.second) {\n\t\t\t\td[now.first] = d[pos] + now.second;\n\t\t\t\tque.push(pii(d[now.first], now.first));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn d[to];\n}\n\nint main() {\t\n\tcin >> n >> m;\n\tg.resize(m);\n\tREP(i, m) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, c));\n\t\tg[b].push_back(pii(a, d));\n\t}\n\t\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tx1--; x2--;\n\t\n\tint ans = y1 - y2 - (dijkstra(x1, x2) + dijkstra(x2, x1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint n; \n\tint m; \n\tint a, b, c, d, s, g, V, P;\n\tint cost, reward;\n\tscanf(\"%d%d\", &n, &m);\n\tint K[n][n];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tK[i][j] = 100010010;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--; b--;\n\t\tK[a][b] = c;\n\t\tK[b][a] = d;\n\t}\n\t// FoyldWarshall\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (K[i][j] > K[i][k] + K[k][j])\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\ts--; g--;\n\tcost = K[s][g] + K[g][s];\n\treward = V - P - cost;\n\tcout << reward << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#include<limits.h>\n\n\nint min( int a ,int b )\n{\n\treturn a > b ? b : a ;\n}\n\n\nvoid in( int move[][ 200 ] ,int next[][ 200 ] ,int *ans ,int m )\n{\n\tint now ,nex ;\n\tint go ,back ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < m ; ++i )\n\t{\n\t\tscanf( \"%d,%d,%d,%d\" ,&now ,&nex ,&go ,&back ) ;\n\n\n\t\t++next[ now ][ 0 ] ;\n\t\t++next[ nex ][ 0 ] ;\n\n\t\tnext[ now ][ next[ now ][ 0 ] ] =\tnex ;\n\t\tnext[ nex ][ next[ nex ][ 0 ] ] =\tnow ;\n\n\n\t\tmove[ now ][ nex ] = go ;\n\t\tmove[ nex ][ now ] = back ;\n/*\n\t\tgo_k[ now ][ nex ] = go ;\n\n\t\tback_k[ nex ][ now ] = back ;\n*/\n\t}\n}\n\n\nint next[ 200 ][ 200 ] ;\n\nint move[ 200 ][ 200 ] ;\n\nbool came[ 200 ][ 200 ] ;\n\n\nint n ,m ;\n\nint st ,end ;\n\nvoid search( int *ans ,int kale[][ 200 ] ,int now )\n{\n\tint i ;\n\tfor( i = 1 ; i <= next[ now ][ 0 ] ; ++i )\n\t{\n\t\tif( next[ now ][ i ] != st && came[ now ][ i ] == false )\n\t\t{\n\t\t\tcame[ now ][ i ] = true ;\n\n\t\t\tans[ next[ now ][ i ] ] = min( ans[ now ] + kale[ now ][ next[ now ][ i ] ] ,ans[ next[ now ][ i ] ] ) ;\n\t\t\n\t\t\tif( next[ now ][ i ] != end )\n\t\t\t{\n\t\t\t\tsearch( ans ,kale ,next[ now ][ i ] ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid init( int *ans ,int n )\n{\n\twhile( n )\n\t{\n\t\tans[ n-- ] = INT_MAX ;\n\t}\n}\n\t\n\n\nint main()\n{\n\tint kale ,stick ;\n\n\tint ans[ 20 + 1 ] ;\n\n\n\tscanf( \"%d\" ,&n ) ;\n\n\tinit( ans ,n ) ;\n\n\n\tscanf( \"%d\" ,&m ) ;\n\n\tin( move ,next ,ans ,m ) ;\n\n\n\tscanf( \"%d,%d,%d,%d\" ,&st ,&end ,&kale ,&stick ) ;\n\n\tans[ st ] = 0 ;\n\t\n\tsearch( ans ,move ,st ) ;\n\n\tstick += ans[ end ] ;\n\n\tinit( ans ,n ) ;\n\n\n\tst += end ;\n\tend = st - end ;\n\tst -= end ;\n\n\n\tans[ st ] = 0 ;\n\n\tmemset( came ,0 ,sizeof came ) ;\n\n\tsearch( ans ,move ,st ) ;\n\n\n\tprintf( \"%d\\n\" ,kale - ( stick + ans[ end ] ) ) ;\n\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tchar c;\n\tint x1,x2,y1,y2;\n\tint n,m,a,b,ab,ba;\n\tint tb[32][32];\n\n\tcin >> n >> m;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<n; j++)\n\t{\n\t\ttb[i][j] = (i==j ? 0 : 1<<20);\n\t}\n\n\twhile(m--)\n\t{\n\t\tcin >> a >> c >> b >> c >> ab >> c >> ba;\n\t\ta--; b--;\n\t\ttb[a][b] = ab;\n\t\ttb[b][a] = ba;\n\t}\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\n\tfor(int k=0; k<n; k++)\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<n; j++)\n\t{\n\t\tif(tb[i][j]>tb[i][k]+tb[k][j]) tb[i][j]=tb[i][k]+tb[k][j];\n\t}\n\n\tx1--; x2--;\n\tcout << y1-y2-tb[x1][x2]-tb[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint n;\n\nint main(){\n  int m;\n  cin >> n >> m;\n  int graph[n+1][n+1];\n  //memset(graph,0,sizeof(graph));\n  for(int i=0;i<n+1;i++){\n    for(int j=0;j<n+1;j++){\n      graph[i][j] = 1000000;\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    graph[a][b] = c;\n    graph[b][a] = d;\n  }\n\n  for(int k=0;k<=n;k++){\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){      \n\tgraph[i][j] = min( graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n\n  int city1,city2,money,hasira;\n  scanf(\"%d,%d,%d,%d\",&city1,&city2,&money,&hasira);\n  //city1--;city2--;\n  //cout << \"行きの代金 : \" << graph[city1][city2] << endl;\n  money -= graph[city1][city2];\n  //cout << \"帰りの代金 : \" << graph[city2][city1] << endl;\n  money -= graph[city2][city1];\n  money -= hasira;\n\n  cout << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n\nstruct edge {\n\tint cost;\n\tint to;\n};\n\nll INF = 1000000000;\nint N,M,s,g,v,p;\nll d[110];\nvector<edge> G[110];\n\nvoid dijkstra(int s) {\n\tpriority_queue<pl, vector<pl>, greater<pl> > q;\n\tfill(d, d + N, INF);\n\td[s] = 0;\n\tq.push(pl(0, s));\n\n\twhile (!q.empty()) {\n\t\tpl p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(pl(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll ans = 0;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ta--, b--;\n\t\tG[a].push_back({c,b});\n\t\tG[b].push_back({d,a});\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\ts--, g--;\n\tdijkstra(s);\n\tans += d[g];\n\tdijkstra(g);\n\tans += d[s];\n\tcout << v - p - ans << endl;\n\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define INF (1LL << 60)\nusing namespace std;\nbool used[200000]; long long dist[200000];\nvoid dijkstra(int V, int E, int s, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[s] = 0; Q.push(make_pair(0, s));\n\tint cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt > E) return; // NEGATIVE_CYCLE\n\t\tpair<long long, int> p = Q.top(); used[p.second] = true; Q.pop();\n\t\tfor (int i = 0; i < X[p.second].size(); i++) {\n\t\t\tint to = X[p.second][i].first; long long leng = X[p.second][i].second;\n\t\t\tif (dist[to] > dist[p.second] + leng && !used[to]) {\n\t\t\t\tdist[to] = dist[p.second] + leng;\n\t\t\t\tQ.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\nint V, E, a, b, c, d, x1, x2, y1, y2; vector<pair<int, int> > G[200000];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tG[a - 1].push_back(make_pair(b - 1, c));\n\t\tG[b - 1].push_back(make_pair(a - 1, c));\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tdijkstra(V, E, x1 - 1, G);\n\tprintf(\"%d\\n\", y1 - y2 - dist[x2 - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22][2];\nbool road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n\tif(money<0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(road[now][i])ans=max(ans,serch(start,finish,money-place[now][i][go],go,i));\n\tfor(int i=1;i<=n;i++)if(road[i][now])ans=max(ans,serch(start,finish,money-place[i][now][go],go,i));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tchar a;\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tfor(int j=0;j<2;j++)place[num[0]][num[1]][j]=num[2+j];\n\t\troad[num[0]][num[1]]=1;\n\t}\n\tint get[4];\n\tchar a;\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nvoid warshallFloyd(int alt[22][22], int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                alt[i][j] = min(alt[i][j], alt[i][k] + alt[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    int a, b, c, d;\n    int n, m;\n    int atl[22][22];\n    rep(i,22) rep(j,22) atl[i][j] = INF;\n    cin >> n >> m;\n    rep(i,m){\n        scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n        atl[a][b] = c;\n        atl[b][a] = d;\n    }\n    warshallFloyd(atl, n);\n    scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n    cout << 50 - atl[a][b] - atl[b][a] - 30 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define all(n) n.begin(),n.end()\n\nconst int MAXN = 21, INF = 1<<29;\n\nint cost[MAXN][MAXN] ;\nint d[MAXN];\nbool used[MAXN];\nint a, b, c1, c2, x1, x2, y1, y2, n, m;\nchar t;\n\nint main()\n{\n    cin >> n >> m;\n    \n    memset(cost, INF, sizeof(cost));\n    rep(i,n)rep(j,n) cost[i][j] = INF;\n    memset(d, INF, sizeof(d));\n    REP(n) d[i] = INF;\n    REP(m)\n    {\n        cin >> a >> t >> b >> t >> c1 >> t >> c2;\n        a--; b--;\n        cost[a][b] = c1;\n        cost[b][a] = c2;\n    }\n    cin >> x1 >> t >> x2 >> t >> y1 >> t >> y2;\n    x1--; x2--;\n\n    d[x1] = 0;\n    int cgo, cback;\n\n    while(true)\n    {\n        int v = -1;\n        rep(i,n)if(!used[i] &&(v == -1 || d[i] < d[v])) v = i;\n        if(v == -1) break;\n\n        used[v] = true;\n        rep(i,n) d[i] = min(d[i], d[v] + cost[v][i]);\n    }\n    cgo = d[x2];\n\n    memset(d, INF, sizeof(d));\n    \n    REP(n) d[i] = INF;\n    d[x2] = 0;\n    memset(used, false, sizeof(used));\n    \n    while(true)\n    {\n        int v = -1;\n        rep(i,n)if(!used[i] &&(v == -1 || d[i] < d[v])) v = i;\n        if(v == -1) break;\n\n        used[v] = true;\n        rep(i,n) d[i] = min(d[i], d[v] + cost[v][i]);\n    }\n    cback = d[x1];\n\n    cout << y1 - y2 - cgo - cback << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<vector <int>> G;\n\nvoid create_edge(int a, int b, int c, int d);\nint search(int st, int go);\n\n\nint main(){\n\n  int n,m;\n  int start;\n  int goal;\n  int money;\n  int pay;\n  int g_money,b_money;\n  int sarary;\n  \n    \n  cin >> n;\n  cin >> m;\n  //cout << \"ihjiwohjwi\" << endl;\n  \n  G = vector <vector<int>>(20,vector<int>(20,1001));\n  \n  // cout << \"1\" << endl;\n\n  for(int i = 0; m>i; ++i){\n    int a,b,c,d;\n    \n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    create_edge(a,b,c,d);\n  }\n\n  //cout << \"2\" << endl;\n\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&pay);\n  \n  // cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n\n  g_money = search(start, goal);\n  b_money = search(goal, start);\n  \n  sarary = money - (g_money + b_money + pay);\n  \n  //cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n \n  cout << sarary << endl;\n  \n  \n}\n\n\n\nvoid create_edge(int a, int b, int c, int d){\n\n  G[a][b] = c;\n  G[b][a] = d;\n\n}\n\n\n\nint search(int st, int go){\n\n  int current;\n  \n  typedef pair < int, int > PII;\n  vector <int>  cost(100, 1001);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  cout << \"search\" << endl;\n  que.push(PII(0,st));\n  cost[st] = 0;\n  \n  \n  while(!que.empty()){\n    current = que.top().second;\n    que.pop();\n\n    for(int k=0; k<20; k++){\n      int temp;\n      temp = G[current][k] + cost[current];\n\n      if(G[current][k] != 1001 && temp < cost[k]){\n\tque.push(PII(temp,k));\n\tcost[k] = temp;\n      }\n    }  \t\t \n  }\n  \n  return cost[go];\n}\n      \n  \n\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<queue>\n\nconst int INFTY = 1 << 22;\nusing namespace std;\n\nclass Town{\npublic:\n  Town(){\n    this->init();\n  }\n  void init(void){\n    this->cost = INFTY;\n    this->vis = false;\n  }\n  int cost;\n  bool vis;\n  vector<int> vcon;\n  vector<int> vcost;\n  bool operator <(const Town *t) const{\n    return cost < t->cost;\n  };\n};\n\nvoid Dijkstra( map<int, Town> &G, int st ){\n  priority_queue<Town*> q;\n  Town *pt;\n\n  G[st].cost = 0;\n  q.push( &G[st] );\n\n  while( !q.empty() ){\n    pt = q.top();\n    q.pop();\n    pt->vis = false;\n\n    for(int i = 0; i < pt->vcon.size(); i++){\n      if( G[ pt->vcon[i] ].cost > pt->cost + pt->vcost[i] ){\n\tG[ pt->vcon[i] ].cost = pt->cost + pt->vcost[i];\n\tif( G[ pt->vcon[i] ].vis ){\n\t  continue;\n\t}else{\n\t  G[ pt->vcon[i] ].vis = true;\n\t  q.push( &G[ pt->vcon[i] ] );\n\t}\n      }\n    }\n  }\n}\nvoid ResetGraph( map<int, Town> &G, vector<int> &V){\n  for(int i = 0; i < V.size(); i++ ){\n    G[ V[i] ].init();\n  }\n}\nint main(void){\n  int n,m;\n  int s,g;\n  int money,pay;\n  map<int, Town> G;\n  vector<int> V;\n\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 0; i < m; i++){\n    int a,b,c,d;\n\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    V.push_back( a );\n    V.push_back( b );\n    G[a].vcon.push_back( b );\n    G[a].vcost.push_back( c );\n    G[b].vcon.push_back( a );\n    G[b].vcost.push_back( d );\n  }\n  scanf(\"%d,%d,%d,%d\", &s, &g, &money, &pay);\n\n  Dijkstra( G , s );\n\n  money -= pay;\n  money -= G[ g ].cost;\n\n  ResetGraph( G , V );\n  Dijkstra( G , g );\n\n  money -= G[ s ].cost;\n\n  cout << money << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nstruct edge{\n\tint to,cost;\n\tedge(int a,int b):to(a),cost(b){}\n};\nvector<edge>az[25];\nint V;\nint d[25];\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(mp(0,s));\n\tfill(d,d+(V+1),INF);\n\td[s]=0;\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(d[p.second]<p.first) continue;\n\t\tfor(int y=0;y<az[p.second].size();y++){\n\t\t\tedge e=az[p.second][y];\n\t\t\tif(d[e.to]>d[p.second]+e.cost){\n\t\t\t\td[e.to]=d[p.second]+e.cost;\n\t\t\t\tque.push(mp(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint m;\n\tscanf(\"%d %d\",&V,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint aa,bb,cc,dd;\n\t\tscanf(\"%d,%d,%d,%d\",&aa,&bb,&cc,&dd);\n\t\taz[aa].pb(edge(bb,cc));\n\t\taz[bb].pb(edge(aa,dd));\n\t}\n\tint st,en,total,cut;\n\tscanf(\"%d,%d,%d,%d\",&st,&en,&total,&cut);\n\tdijkstra(st);\n\ttotal-=d[en];\n\tdijkstra(en);\n\ttotal-=d[st];\n\ttotal-=cut;\n\tprintf(\"%d\\n\",total);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tll i,j,n,m;\n\tll s,g,v,pp;\n\tll ri[21][21];\n\tll leng[21],flg[21];\n\tll min,ki,sam;\n\tPP p[100];\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&p[i].ff,&p[i].fs,&p[i].sf,&p[i].ss);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&v,&pp);\n\tsort(p,p+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[p[i].ff][p[i].fs]=p[i].sf,ri[p[i].fs][p[i].ff]=p[i].ss;\n\tfor(i=0;i<=n;i++) flg[i]=0,leng[i]=M;\n\tleng[s]=0;\n\tfor(i=0;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0&&leng[j]<min){\n\t\t\t\tmin=leng[j];\n\t\t\t\tki=j;\n\t\t\t}\n\t\t}\n\t\tflg[ki]=1;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(min+ri[ki][j]<leng[j]){\n\t\t\t\tleng[j]=min+ri[ki][j];\n\t\t\t}\n\t\t}\n\t}\n\tsam=leng[g];\n\t//printf(\"%d\\n\",leng[g]);\n\tfor(i=0;i<=n;i++) flg[i]=0,leng[i]=M;\n\tleng[g]=0;\n\tfor(i=0;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0&&leng[j]<min){\n\t\t\t\tmin=leng[j];\n\t\t\t\tki=j;\n\t\t\t}\n\t\t}\n\t\tflg[ki]=1;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(min+ri[ki][j]<leng[j]){\n\t\t\t\tleng[j]=min+ri[ki][j];\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d\\n\",leng[s]);\n\tsam=v-pp-leng[s]-sam;\n\tprintf(\"%d\\n\",sam);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n//テ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテ」ツ?軍untime Errorティツオツキテ」ツ?禿」ツ?療」ツ?ヲテ」ツ?療」ツ?セテ」ツ?」テ」ツ??テつエテ」ツδサテ渉嘉」ツδサ`)テッツセツ?ッツスツセテッツセツ?\n/*\nclass Node{\npublic:\n\tint num;\n\tint cost;\n\n\tNode(){ num = 0; cost = 0; }\n\tNode(int num, int cost) : num(num), cost(cost){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.cost < n2.cost;\n}\n\nbool operator>(const Node &n1, const Node &n2){\n\treturn n1.cost > n2.cost;\n}\n\n\nbool checked[21];\n\nint main(void){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<vector<pair<int, int> > > path(n + 1);\n\tfor (int i = 0; i < m; i++){\n\t\tint\ta, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tpath[a].push_back(make_pair(b, c));\n\t\tpath[b].push_back(make_pair(a, d));\n\t}\n\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tint result = V - P;\n\n\tfor (int i = 0; i <= 20; i++){\n\t\tchecked[i] = false;\n\t}\n\n\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que1;//cost, point\n\tque1.push(Node(s, 0));\n\n\twhile (!que1.empty()){\n\t\tNode cp = que1.top();\n\t\tque1.pop();\n\n\t\tint cost = cp.cost;\n\t\tint point = cp.num;\n\n\t\tif (checked[point]) continue;\n\t\tchecked[point] = true;\n\n\t\tif (point == g){\n\t\t\tresult -= cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < path[point].size(); i++){\n\t\t\tque1.push(Node(path[point][i].second, cost + path[point][i].first));\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i <= 20; i++){\n\t\tchecked[i] = false;\n\t}\n\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que2;//cost, point\n\tque1.push(Node(g, 0));\n\n\twhile (!que2.empty()){\n\t\tNode cp = que2.top();\n\t\tque2.pop();\n\n\t\tint cost = cp.cost;\n\t\tint point = cp.num;\n\n\t\tif (checked[point]) continue;\n\t\tchecked[point] = true;\n\n\t\tif (point == s){\n\t\t\tresult -= cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < path[point].size(); i++){\n\t\t\tque2.push(Node(path[point][i].second, cost + path[point][i].first));\n\t\t}\n\n\t}\n\n\tcout << result << endl;\n\n\treturn 0;\n}\n*/\n\n#define INF 1000000\n\nint main(void){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tint dist[21][21];\n\n\tfor (int i = 1; i < 21; i++){\n\t\tfor (int j = 1; j < 21; j++){\n\t\t\tif (i == j) dist[i][j] = 0;\n\t\t\telse dist[i][j] = INF;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\t\tint\ta, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdist[a][b] = c;\n\t\tdist[b][a] = d;\n\t}\n\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\n\tfor (int k = 1; k <= n; k++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tfor (int i = 1; i <= n; i++){\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << V - P - dist[s][g] - dist[g][s] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 1000000000;\nusing namespace std;\nint main() {\n  int n, m;\n  char q;\n  cin >> n >> m;\n  int dp[n][n];\n  rep(i, n) rep(j, n) dp[i][j] = i == j ? 0 : INF;\n  rep(i, m) {\n    int a, b, c, d;\n    cin >> a >> q >> b >> q >> c >> q >> d;\n    dp[a][b] = c;\n    dp[b][a] = d;\n  }\n  rep(k, n) rep(i, n) rep(j, n) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n  int s, g, V, P;\n  cin >> s >> q >> g >> q >> V >> q >> P;\n  cout << V - P - dp[s][g] - dp[g][s] + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\tif((*i).depart==s){\n\t\t\tq.push((*i).arrival);\n\t\t\tcost.at((*i).arrival)=(*i).cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\t\tif((*i).depart==pos){\n\t\t\t\tif(cost.at((*i).arrival)==INF){\n\t\t\t\t\tq.push((*i).arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at((*i).arrival)>(*i).cost+cost.at(pos)){\n\t\t\t\t\tcost.at((*i).arrival)=(*i).cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\tfor(int i=0;i<cost.size();i++){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tcost.clear();\n\tFOR(k,0,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\tfor(int i=0;i<n+1;i++){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-(y2+Cost+cost.at(x1))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=(ll)a;i<(ll)n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V; /*?????§????????°*/\nstruct edge { int to, cost; };\ntypedef std::pair<int, int> PP;\n// ???cost??¨????????????????????¢\nstd::vector<edge> list[20];\nint d[20];\nvoid DIJX(int st) {\n\tfor (int i = 0; i<V; i++)d[i] = INF; // std::fill??§????????????\n\td[st] = 0; // ?§????\n\tstd::priority_queue<PP, std::vector<PP>, std::greater<PP>> pq;\n\tpq.push(std::make_pair(d[st], st)); // (cost,????????????)\n\twhile (!pq.empty()) {\n\t\tPP p = pq.top();\n\t\tpq.pop();\n\t\tint i = p.second; // cost???first??????????????????second\n\t\tif (d[i]<p.first)continue;\n\t\tfor (int k = 0; k<list[i].size(); k++) {\n\t\t\tedge e = list[i][k];\n\t\t\tif (d[e.to] <= d[i] + e.cost)continue;\n\t\t\td[e.to] = d[i] + e.cost;\n\t\t\tpq.push(std::make_pair(d[e.to], e.to));\n\t\t}\n\t}\n}\nint main() {\n\t\tint m, a, b, c,dd;\n\t\tstd::cin >> V;\n\t\tstd::cin >> m;\n\t\tchar c1, c2, c3;\n\t\tfor (int i = 0; i<m; i++) {\n\t\t\tstd::cin >> a >>c1>> b >>c2>> c>>c3>>dd;\t\n\t\t\tlist[a-1].push_back(edge { b-1, c });\n\t\t\tlist[b-1].push_back(edge{ a-1, dd });\n\t\t}\n\t\tint s, g, get, lost,ans=0;\n\t\tstd::cin >> s >>c1>> g >>c2>> get >>c3>> lost;\n\t\tans += get - lost;\n\t\tDIJX(s-1);\n\t\tans -= d[g-1];\n\t\tDIJX(g-1);\n\t\tans -= d[s - 1];\n\t\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <stdio.h>\n#include<iostream>\n#include <list>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define MAX 101\nstruct node\n{\n\tlist<int> li;\n\tlist<int> cost;\n};\nint  sum = 0, n, m, s, g, ans,flag = 0,min = -1;\nnode x[MAX];\nvoid sai(int N, int a,int f) {\n\tif (N < m) {\n\t\tif (f == a) { //&& flag == 0) {\n\t\t\tif (min == -1 || min > sum) min = sum;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tfor (auto i = x[a].li.begin(), j = x[a].cost.begin(); i != x[a].li.end(); ++i, ++j) {\n\t\t\t\tif (min == -1 || min > sum) {\n\t\t\t\t\tsum += *j;\n\t\t\t\t\tsai(N + 1, *i, f);\n\t\t\t\t\tsum -= *j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint a, b, c, d, V, P;\n\tscanf_s(\"%d\", &n);\n\tscanf_s(\"%d\", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a].li.push_back(b); x[a].cost.push_back(c);\n\t\tx[b].li.push_back(a); x[b].cost.push_back(d);\n\t}\n\tfor (int k = 1; k <= n; ++k) {\n\t\tfor (auto i = x[k].li.begin(), j = x[k].cost.begin(); i != x[k].li.end(); ++i, ++j) {\n\t\t}\n\t}\n\tscanf_s(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tsai(0, s, g);\n\tans += min; min = -1; sum = 0;\n\tsai(0, g, s);\n\tans += min;\n\tans = V - (ans + P);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint cost[21][21];\nint n,m;\nint start,goal,tono,hashira;\n\nint dijkstra_go_village[21];\nint dijkstra_go_home[21];\n\n\n\n\nint main(){\n    for(int i=0; i<21; i++){\n        for(int j=0; j<21; j++){\n            cost[i][j]=999999999;\n        }\n    }\n    \n    while(cin>>n){\n        cin>>m;\n        for(int i=0; i<m; i++){\n            string text;\n            cin>>text;\n            \n            for(int i=0; i<text.size(); i++){\n                if(text[i] == ',')text[i] = ' ';\n            }\n            \n            stringstream ss;\n            ss<<text;\n            \n            int a,b,c,d;\n            ss>>a>>b>>c>>d;\n            \n            cost[a][b]=c;\n            cost[b][a]=d;\n            \n            \n        }\n        \n        string text2;\n        cin>>text2;\n        \n        for(int i=0; i<text2.size(); i++){\n            if(text2[i] == ',')text2[i] = ' ';\n        }\n        \n        stringstream ss;\n        ss<<text2;\n        \n        ss>>start>>goal>>tono>>hashira;\n        \n        for(int i=0; i<21; i++){\n            dijkstra_go_home[i]=999999;\n            dijkstra_go_village[i]=999999;\n        }\n        \n        bool flag1[21] = {0};\n        dijkstra_go_village[start]=0;\n        \n        int now_place;\n        while(1){\n            bool break_flag=true;;\n            int min_cost = 9999999;\n            for(int i=1; i<=n; i++){\n                if(flag1[i]==0&&min_cost>dijkstra_go_village[i]){\n                    min_cost=dijkstra_go_village[i];\n                    now_place=i;\n                    \n                }\n            }\n            \n            flag1[now_place]=1;\n            \n            for(int i=1; i<=n; i++){\n                if(flag1[i]==0){\n                    dijkstra_go_village[i]=min(dijkstra_go_village[i], dijkstra_go_village[now_place]+cost[now_place][i]);\n                    break_flag=false;\n                }\n            }\n            \n            if(break_flag)break;\n        }\n        \n        /////////\n        \n        bool flag2[21] = {0};\n        dijkstra_go_home[goal]=0;\n        \n        while(1){\n            bool break_flag=true;;\n            int min_cost = 9999999;\n            for(int i=1; i<=n; i++){\n                if(flag2[i]==0&&min_cost>dijkstra_go_home[i]){\n                    min_cost=dijkstra_go_home[i];\n                    now_place=i;\n                    \n                }\n            }\n            \n            flag2[now_place]=1;\n            \n            for(int i=1; i<=n; i++){\n                if(flag2[i]==0){\n                    dijkstra_go_home[i]=min(dijkstra_go_home[i], dijkstra_go_home[now_place]+cost[now_place][i]);\n                    break_flag=false;\n                }\n            }\n            \n            if(break_flag)break;\n        }\n        \n        /*\n        for(int i=1; i<=n; i++){\n            cout<<dijkstra_go_village[i]<<endl;\n        }\n        */\n        \n        //cout<<dijkstra_go_village[goal]<<endl;\n        //cout<<dijkstra_go_home[start]<<endl;\n        cout<<tono-hashira-dijkstra_go_village[goal]-dijkstra_go_home[start]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n, m, reward;\n\tint a, b, c, d;\n\tint x1, x2, y1, y2;\n\tint cost[21][21];\n\tchar ch;\n\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < 21; i++)\n\t{\n\t\tfor (int j = 0; j < 21; j++)\n\t\t{\n\t\t\tcost[i][j] = 10000;\t\t\t//????°?????????¨?????????????????????cost>1000\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t{\n\t\t\t\tcost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\t\t//???????????£??????????????????????????£?????????????????????????????????\n\t\t\t}\n\t\t}\n\t}\n\treward = y1 - y2 - cost[x1][x2] - cost[x2][x1];\n\t\n\tcout << reward << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <list>\n#include <stack>\n#include <queue>\nusing namespace std;\n\ntypedef list<int> L;\ntypedef pair <int,int> P;\ntypedef vector<int> V;\ntypedef queue<int> Q;\ntypedef stack<int> S;\ntypedef map<string,int> M;\n\nconst int MAX = 21;\nconst int INF = 999999;\n\nint n, m, f[MAX][MAX];\nV d[MAX];\n\nint sreach (int start, int goal) {\n    int res = 0;\n\n    int s[MAX];\n    memset(s, INF, sizeof(s));\n    Q q;\n    q.push(start);\n    s[start] = 0;\n\n    while (q.size()) {\n        int t1 = q.front(); q.pop();\n\n        for (int i = 0; i < d[t1].size(); i++) {\n            int t2 = d[t1][i];\n            if (s[t2] > s[t1] + f[t1][t2]) {\n                s[t2] = s[t1] + f[t1][t2];\n                q.push(t2);\n            }\n        }\n    }\n\n    return s[goal];\n}\n\nint main()\n{\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b, c, dd;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &dd);\n        f[a][b] = c;\n        f[b][a] = dd;\n\n        d[a].push_back(b);\n        d[b].push_back(a);\n    }\n    int x1, x2, y1, y2;\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    int res = y1 - y2;\n    res -= sreach(x1, x2);\n    res -= sreach(x2, x1);\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf=1001001001;\n\nint main() {\n\tlong long pay,ans;\n\tfor(int i=0;i<32;i++)\n\t\tfor(int j=0;j<32;j++)\n\t\t\tK[i][j]=inf;\n\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i=0; i<M; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\t\t//cerr << \"read \" << A <<\" \"<< B <<\" \" << C <<\" \" << D<< endl;\n\t\t//?????????\n\t\tK[A][B]=C; // A ??? B ????????????C\n\t\tK[B][A]=D;// B ??? A ????????????D    \n\t}\n\t/*\n\tfor(int i=1;i<N+1;i++){//?????§?????????\n\t\tfor(int j=1;j<N+1;j++){\n\t\t\tif(K[i][j]==inf){\n\tcout<<\"i\"<<\" \";\n\t\t\t}else{\n\tcout<<K[i][j]<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tfor(int k=1;k<N+1;k++){\n\t\tfor(int i=1;i<N+1;i++){\n\t\t\tfor(int j=1;j<N+1;j++){\n\tif(K[i][j]>K[i][k]+K[k][j]){\n\t\tK[i][j]=K[i][k]+K[k][j];\n\t}\n\t\t\t}\n\t\t}/*\n\t\tfor(int l=1;l<N+1;l++){//?????§??????2???\n\t\tfor(int m=1;m<N+1;m++){\n\t\t\tif(K[l][m]==inf){\n\tcout<<\"i\"<<\" \";\n\t\t\t}else{\n\tcout<<K[l][m]<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t\t} \n\t\tcout<<endl;*/\n\t}\n\tscanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n\tpay=K[A][B]+K[B][A];\n\tans=C-D-pay;\n\tcout<<ans<<endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n/** Problem0117 : A reward for a Carpenter **/\nconst int INF = 100000;\nint d[100][100];\nint path[100][100];\nint V, E;\n\n\nint main()\n{\n\tint s, g, plus, minus;\n\tchar c;\n\tcin >> V >> E;\n\t\n\tfor (int i=0; i<100; i++)\n\t\tfor (int j=0; j<100; j++) d[i][j] = INF;\n\t\n\tfor (int i=0; i<E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> c >> b >> c >> d[a-1][b-1] >> c >> d[b-1][a-1];\n\t}\n\t\n\tcin >> s >> c >> g >> c >> plus >> c >> minus;\n\ts--; g--;\n\t\n\tfor (int k=0; k<V; k++)\n\t\tfor (int i=0; i<V; i++)\n\t\t\tfor (int j=0; j<V; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\n\tcout << plus - (minus + d[s][g] + d[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin>>a>>cc>>b>>cc>>c>>cc>>d;\n            }\n        }\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to, cost;\n    edge_t(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    int min_cost;\n    state_t(int v, int min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline void add_edge(int from, int to, double cost) {\n        g[from].push_back(edge_t(from, to, cost));\n    }\n\n    void dijkstra(int s, vector<int> &min_cost) {\n        min_cost.resize(g.size());\n        priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n        \n        fill(min_cost.begin(), min_cost.end(), INF);\n\n        min_cost[s] = 0;\n        q.push(state_t(s, 0));\n\n        while (!q.empty()) {\n            state_t p = q.top(); q.pop();\n            int v = p.v;\n            if (min_cost[v] < p.min_cost) continue;\n            for (int i = 0; i < g[v].size(); i++) {\n                edge_t e = g[v][i];\n                if (min_cost[e.to] > min_cost[v] + e.cost)  {\n                    min_cost[e.to] = min_cost[v] + e.cost;\n                    q.push(state_t(e.to, min_cost[e.to]));\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    graph_t graph(n+1);\n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        graph.add_edge(a, b, c);\n        graph.add_edge(b, a, d);\n    }\n    int s, g, init_money, tree_cost;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &init_money, &tree_cost);\n    int reward = init_money - tree_cost;\n    vector<int> min_cost;\n    graph.dijkstra(s, min_cost);\n    reward -= min_cost[g];\n    graph.dijkstra(g, min_cost);\n    reward -= min_cost[s];\n    cout << reward << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n, m;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n\n    int E[n][n], F[n][n];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i == j) E[i][j] = 0;\n            else E[i][j] = 1e9;\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--;\n        E[a][b] = c;\n        E[b][a] = d;\n    }\n\n    int s, g, v, p;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n    s--; g--;\n\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k < n; k++){\n                E[j][k] = min(E[j][k], E[j][i] + E[i][k]);\n            }\n        }\n    }\n\n    int t = 1e9;\n    for(int i = 0; i < n; i++){\n        t = min(t, E[s][g] + E[g][s]);\n    }\n\n    cout << v - p - t << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define INF 100010\n\nint cost[24][24];\nint d[24][24];\nint V, E;\n\nint main(){\n    cin >> V >> E;\n\n    for(int i=0; i < 24; i++){\n        for(int j=0; j < 24; j++){\n            cost[i][j] = INF;\n        }\n        cost[i][i] = 0;\n    }\n\n    for(int i=0; i < E; i++){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--;\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n\n    int start, pillar, money, subtotal;\n    scanf(\"%d,%d,%d,%d\", &start, &pillar, &money, &subtotal);\n    start--;\n    pillar--;\n\n    for(int k=0; k < V; k++){\n        for(int i=0; i < V; i++){\n            for(int j=0; j < V; j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n            }\n        }\n    }\n\n    cout << money - subtotal - cost[start][pillar] - cost[pillar][start] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c>b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nbool input(){\n  char t;\n  int n;\n  if(!(cin>>n))return false;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n  return true;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=-1;\n  }\n  q.push(edge(start,0));\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    \n    if(dp[now.p]!=-1)continue;\n    dp[now.p]=now.c;\n    \n    if(now.p==end)return now.c;\n    \n    for(int i=0;i<edges[now.p].size();i++){\n      edge to = edges[now.p][i];\n      q.push(edge(to.p,now.c+to.c));\n    }\n\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <stdio.h>\n#include<iostream>\n#include <list>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define MAX 101\nstruct node\n{\n\tlist<int> li;\n\tlist<int> cost;\n};\nint  sum = 0, n, m, s, g, ans,flag = 0,min = -1;\nvoid sai(int N, int a,int f) {\n\tif (N < m) {\n\t\tif (f == a) { //&& flag == 0) {\n\t\t\tif (min == -1 || min > sum) min = sum;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tfor (auto i = x[a].li.begin(), j = x[a].cost.begin(); i != x[a].li.end(); ++i, ++j) {\n\t\t\t\tif (min == -1 || min > sum) {\n\t\t\t\t\tsum += *j;\n\t\t\t\t\tsai(N + 1, *i, f);\n\t\t\t\t\tsum -= *j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint a, b, c, d, V, P;\n\tscanf_s(\"%d\", &n);\n\tscanf_s(\"%d\", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tx[a].li.push_back(b); x[a].cost.push_back(c);\n\t\tx[b].li.push_back(a); x[b].cost.push_back(d);\n\t}\n\tfor (int k = 1; k <= n; ++k) {\n\t\tfor (auto i = x[k].li.begin(), j = x[k].cost.begin(); i != x[k].li.end(); ++i, ++j) {\n\t\t}\n\t}\n\tscanf_s(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tsai(0, s, g);\n\tans += min; min = -1; sum = 0;\n\tsai(0, g, s);\n\tans += min;\n\tans = V - (ans + P);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nconst ll INF=1e10;\n#define PI 3.141592\n#define pb push_back\n\nvoid show(vector<vll> a){\n    range(i,1,a.size()){\n        range(j,1,a[i].size()){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    int n,m; cin >> n >> m;\n    char ch;\n    vint a(m),b(m),c(m),d(m);\n    vector<vll> K(n+1,vll(n+1,INF));\n    rep(i,m){\n        int a,b; cin >> a >> ch >> b >> ch;\n        cin >> K[a][b] >> ch >> K[b][a];\n    }\n    int s,g,v,p; cin >> s >> ch >> g >> ch >>  v >> ch >> p;\n\n    range(k,1,n+1) range(i,1,n+1) range(j,1,n+1){\n        if(K[i][j]>K[i][k]+K[k][j]){\n            K[i][j]=K[i][k]+K[k][j];\n        }\n    }\n    cout << v-p-K[s][g]-K[g][s];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n\nstruct e{\n\tint f,t,c;\n};\n\nint main(){\n\tint n,m,x[2],y1,y2,a,b,c,d,cost;\n\tint di[200];\n\te l[8000];\n\tconst int inf = 9999999;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;\n\t\tb--;\n\t\tl[i*2].f=l[i*2+1].t=a;\n\t\tl[i*2].t=l[i*2+1].f=b;\n\t\tl[i*2].c=c;\n\t\tl[i*2+1].c=d;\n\t}\n\tcost=0;\n\trep(i,2){\n\t\trep(j,n)di[j]=inf;\n\t\tdi[x[i]-1]=0;\n\t\tint f=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\trep(j,m*2){\n\t\t\t\te t=l[j];\n\t\t\t\tif(di[t.f]<inf && di[t.t]>di[t.f]+t.c){\n\t\t\t\t\tdi[t.t]=di[t.f]+t.c;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost+=di[x[1-i]-1];\n\t}\n\tprintf(\"%d\\n\",y1-y2-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int n,m;\n    int a,b,c,d;\n    const int INF=10000000;\n    scanf(\"%d\\n%d\\n\",&n,&m);\n    int dist[20][20];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            dist[i][j]=INF;\n        }\n    }\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n        a--;b--;\n        dist[a][b]=c;\n        dist[b][a]=d;\n    }\n    int fr,to,y1,y2;\n    scanf(\"%d,%d,%d,%d\\n\",&fr,&to,&y1,&y2);\n    fr--;to--;\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\",y1-y2-dist[fr][to]-dist[to][fr]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int LIMIT = 999999;\n\nint d[MAX_V][MAX_V]; // コスト i==jのとき0, それ以外INF\nint n, m; // 町, 街道\n\nvoid warshall_floyd() {\n  for(int k=0; k<m; k++)\n    for(int i=0; i<m; i++)\n      for(int j=0; j<m; j++)\n\td[i][j]=min(d[i][j], d[i][k]+d[k][j]); // i-jの最短経路\n}\n\nint main() {\n  int a, b;\n  int start, hashira, givenMoney, cost;\n  int ans;\n\n  for(int i=0; i<MAX_V; i++) {\n    for(int j=0; j<MAX_V; j++) {\n      d[i][j]=LIMIT;\n    }\n  }\n\n  cin>>n;\n  cin>>m;\n  for(int i=0; i<m; i++) {\n    cin>>a;\n    cin.ignore();\n    cin>>b;\n    cin.ignore();\n    cin>>d[a][b];\n    cin.ignore();\n    cin>>d[b][a];\n  }\n  cin>>start;\n  cin.ignore();\n  cin>>hashira;\n  cin.ignore();\n  cin>>givenMoney;\n  cin.ignore();\n  cin>>cost;\n\n  warshall_floyd();\n\n  ans = givenMoney - cost - (d[start][hashira] + d[hashira][start]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n, m;\n\tint x1, x2, y1, y2;\n\tchar dummy;\n\n\tcin >> n;\n\tcin >> m;\n\n\tvector<int> a(m), b(m), c(m), d(m);\n\tvector< vector <int> > map(n + 1, vector<int>(n + 1, INT_MAX / 4));\n\t\n\tfor(int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> dummy >> b[i] >> dummy >> c[i] >> dummy >> d[i];\n\t}\n\tcin >> x1 >> dummy >> x2 >> dummy >> y1 >> dummy >> y2;\n\n\tfor(int i = 0; i < m; i++) {\n\t\tmap[a[i]][b[i]] = c[i];\n\t\tmap[b[i]][a[i]] = d[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tmap[i][i] = 0;\n\t}\n\n\tfor(int k = 0; k < n + 1; k++) {\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tfor(int j = 0; j < n + 1; j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\ty1 -= map[x1][x2] + map[x2][x1] + y2;\n\n\tcout << y1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int inf = 1001001001;\nint n,m,a,b,c,d,x1,x2,y1,y2;\nint K[32][32];\n\nvoid floyd(){\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                if(K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n}\n\nint main(){\n    for(int i=0;i<32;i++){\n        for(int j=0;j<32;j++){\n            K[i][j] = inf;\n        }\n    }\n    scanf(\"%d%d\", &n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cerr << \"read \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    floyd();\n    scanf(\"%d,%d,%d,%d\", &x1,&x2,&y1,&y2);\n    cout << y1 - y2 - K[x1][x2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\nconst int INF = 1001;\n\nint n, m;\nint dist[20][20];\nint s, e, x, y;\n\nint main()\n{\n\tfor( int i = 0; i != 20; ++i )\n\t\tfor( int j = 0; j != 20; ++j )\n\t\t\t\tdist[i][j] = i == j ? 0 : INF;\n\n\tstd::cin >> n >> m;\n\t\n\tfor( int i = 0; i != m; ++i )\n\t{\n\t\tint a, b, c, d;\n\t\tscanf( \"%d,%d,%d,%d\", &a, &b, &c, &d );\n\t\tdist[a-1][b-1] = c;\n\t\tdist[b-1][a-1] = d;\n\t}\n\n\tscanf( \"%d,%d,%d,%d\", &s, &e, &x, &y );\n\n\tfor( int k = 0; k != n; ++k )\n\t\tfor( int i = 0; i != n; ++i )\n\t\t\tfor( int j = 0; j != n; ++j )\n\t\t\t\tdist[i][j] = std::min( dist[i][j], dist[i][k] + dist[k][j] );\n\n\tstd::cout << x - y - dist[s-1][e-1] - dist[e-1][s-1] << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N=0;\nint M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf = 1001001001;\nint s,g,V,P;\nvoid Floyd_Warshall(){\n    for(int k=1;k<=N;k++){\n        for(int i=1;i<=N;i++){\n            for(int j=1;j<=N;j++){\n                if(K[i][j]>K[i][k]+K[k][j]){\n                    K[i][j]=K[i][k]+K[k][j];\n                }\n            }\n        }\n    }\n}\nvoid init_K(){\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            K[i][j]=inf;\n        }\n    }\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    init_K();\n    for (int i=0; i<M; ++i) {\n        scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n        K[A][B]=C;\n        K[B][A]=D;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g,&V,&P);\n    Floyd_Warshall();\n    int sum=V-P-K[s][g]-K[g][s];\n    cout<<sum<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nstruct edge\n{\n\tint to, cost;\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nconst int INF = 1 << 29;\n\n\nint main()\n{\n    int n, m;\n\t\n\tcin >> n >> m;\n\t\n\tvector<vint> G(n, vint(n, INF));\n\trep(i, m)\n\t{\n\t\tint a, b, c, d;\n\t\tchar k;\n\t\t\n\t\tcin >> a >> k >> b >> k >> c >> k >> d;\n\t\t\n\t\tG[a-1][b-1] = c;\n\t\tG[b-1][a-1] = d;\n\t}\n\t\n\t\n\trep(k, n) rep(i, n) rep(j, n)\n\t\tchmin(G[i][j], G[i][k] + G[k][j]);\n\t\n\tint s, t, ta, gi;\n\tchar k;\n\tcin >> s >> k >> t >> k >> ta >> k >> gi;\n\t\n\tcout << ta - gi - G[s-1][t-1] - G[t-1][s-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nconst int inf = 1001000100;\nint K[32][32]={};\n\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n\n  for (int i=1; i<N+1; i++)\n    for (int j=1; j<N+1; j++)\n      K[i][j] = inf;\n  \n  for (int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    //cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A][B] = C;\n    K[B][A] = D;\n  }\n\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  \n  for (int k=1; k<N+1; k++){\n    for (int i=1; i<N+1; i++){\n      for (int j=1; j<N+1; j++){\n\tif (K[i][j] > K[i][k] + K[k][j])\n\t  K[i][j] = K[i][k] + K[k][j];\n\t//cout << K[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n  }\n\n \n  cout << y1 - y2 - K[x1][x2] -K[x2][x1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tll i,j,n,m;\n\tll s,g,v,pp;\n\tll ri[21][21];\n\tll leng[21],flg[21];\n\tll min,ki,sam;\n\tPP p[100];\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&p[i].ff,&p[i].fs,&p[i].sf,&p[i].ss);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&v,&pp);\n\t//sort(p,p+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[p[i].ff][p[i].fs]=p[i].sf,ri[p[i].fs][p[i].ff]=p[i].ss;\n\tfor(i=0;i<=n;i++) flg[i]=0,leng[i]=M;\n\tleng[s]=0;\n\tfor(i=0;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0&&leng[j]<min){\n\t\t\t\tmin=leng[j];\n\t\t\t\tki=j;\n\t\t\t}\n\t\t}\n\t\tflg[ki]=1;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(min+ri[ki][j]<leng[j]){\n\t\t\t\tleng[j]=min+ri[ki][j];\n\t\t\t}\n\t\t}\n\t}\n\tsam=leng[g];\n\t//printf(\"%d\\n\",leng[g]);\n\tfor(i=0;i<=n;i++) flg[i]=0,leng[i]=M;\n\tleng[g]=0;\n\tfor(i=0;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(flg[j]==0&&leng[j]<min){\n\t\t\t\tmin=leng[j];\n\t\t\t\tki=j;\n\t\t\t}\n\t\t}\n\t\tflg[ki]=1;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(min+ri[ki][j]<leng[j]){\n\t\t\t\tleng[j]=min+ri[ki][j];\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d\\n\",leng[s]);\n\tsam=v-pp-leng[s]-sam;\n\tprintf(\"%d\\n\",sam);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long int\n#define INF 10000000\nusing namespace std;\t\nint main(void)\n{\n\tLL i,j,k,n,m,glid[21][21],start,gorl,v[21],clr[21],a,b,c,d,mm,p,ans2,mini,x,ans1;\n\tcin>>n>>m;\n\tfor(i=0;i<21;i++)for(j=0;j<21;j++) glid[i][j]=INF;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%lld,%lld,%lld,%lld\",&a,&b,&c,&d);\n\t\tglid[a][b]=c;\n\t\tglid[b][a]=d;\n\t}\n\tscanf(\"%lld,%lld,%lld,%lld\",&start,&gorl,&mm,&p);\n\tfor(i=0;i<21;i++) v[i]=INF,clr[i]=0;\n\tv[start]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans1=v[gorl];\n\tfor(i=0;i<21;i++) {\n\t\tv[i]=INF;\n\t\tclr[i]=0;\n\t}\n\tv[gorl]=0;\n\twhile(1) {\n\t\tx=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tif(v[i]<v[x]&&clr[i]==0) x=i;\n\t\t}\n\t\tif(x==0) break;\n\t\tclr[x]=1;\n\t\tfor(i=1;i<=n;i++) v[i]=min(v[i],glid[x][i]+v[x]);\n\t}\n\tans2=v[start];\n\tcout<<mm-p-ans1-ans2<<endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nint road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=n;i++)if(place[now][i])ans=max(ans,serch(start,finish,money-place[now][i],go,i));\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 10000000\nusing namespace std;\nint glid[21][21];\nint kakutei[21],leng[21];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++) {\n\t\tfor(j=0;j<n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++) glid[i][i]=0;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n//\tcout<<start<<finish<<okane<<value<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t//\t\t\tmi=glid[point][j];\n\t\t\t}\n\t\t}\n\t//\tokane=okane-mi;\n\t}\n\t//for(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tokane-=leng[finish];\n\t//cout<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[finish]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t//\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t\t//mi=glid[point][j];\n\t\t\t}\n\t\t}\n\t\t//okane=okane-mi;\n\t}\n//\tfor(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tswap(start,finish);\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <utility>\n#define rep(i,l,n) for(lint i=l;i<n;i++)\n#define rer(i,l,n) for(lint i=l;i<=n;i++)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<lint> vli;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint d[20][20];//d[u][v]??????e=(u,v)????????????(?????¨???????????´??????INF,??????d[i][i]=0??¨??????)\nint V;//????????°\n\nvoid warshall_floyd(){\n\tfor(int k=0;k<V;k++){\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>V;\n\trep(i,0,20){\n\t\trep(j,0,20){\n\t\t\tif(i==j) d[i][j]=0;\n\t\t\telse d[i][j]=1000000000;\n\t\t}\n\t}\n\tint m;\n\tcin>>m;\n\tint a,b,c,d1;\n\trep(i,0,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d1);\n\t\ta--; b--;\n\t\td[a][b]=c;\n\t\td[b][a]=d1;\n\t}\n\tint x1,x2,y1,y2,MIN;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\twarshall_floyd();\n\tint ans=y1-y2-d[x1-1][x2-1]-d[x2-1][x1-1];\n\to(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000\n#define PII pair<int, int>\n#define VPII vector<pair<int,int> >\n\nint dijkstra(int n, const vector<vector<int> >& edge, int s, int g) {\n  vector<bool> used(n, false);\n  vector<int> dist(n, INF);\n  dist[s] = 0;\n  priority_queue<PII, VPII, greater<PII > >q;\n  q.push(make_pair(0, s));\n  while(q.size() > 0) {\n    PII v = q.top(); q.pop();\n    int current = v.second;\n    used[current] = true;\n    for (int i = 0; i < n; i++) {\n      if (edge[current][i] != INF) {\n\tdist[i] = min(dist[i], dist[current] + edge[current][i]);\n\tif (!used[i]) {\n\t  q.push(make_pair(dist[i], i));\n\t}\n      }\n    }\n  }\n  return dist[g];\n}\n\nint main() {\n  int n, m;\n  cin >> n;\n  cin >> m;\n  vector<vector<int> > edge(n, vector<int>(n, INF));\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d);\n    a--; b--;\n    edge[a][b] = c;\n    edge[b][a] = d;\n  }\n  int s, g, V, P;\n  scanf(\"%d,%d,%d,%d\\n\", &s, &g, &V, &P);\n  s--; g--;\n  int outward = dijkstra(n, edge, s, g);\n  int homeward = dijkstra(n, edge, g, s);\n  cout << V - P - outward - homeward << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<algorithm>\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int cost[22][22];\n  int dcost[22];\n  int ans;\n  for(int i=0;i<22;i++){\n    for(int j=0;j<22;j++){\n      cost[i][j]=INF;\n    }\n    dcost[i]=INF;\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost[a][b]=c;\n    cost[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  ans=y1-y2;\n  // ダイクストラ\n  dcost[x1]=0;\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0,x1));\n  \n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    int nc=p.first;\n    for(int i=0;i<=n;i++){\n      if(cost[v][i]!=INF && cost[v][i]+nc<dcost[i]){\n\tdcost[i]=cost[v][i]+nc;\n\tque.push(P(dcost[i],i));\n      }\n    }\n  }\n  ans-=dcost[x2];\n  for(int i=0;i<22;i++){\n    dcost[i]=INF;\n  }\n  \n  dcost[x2]=0;\n  \n  que.push(P(0,x2));\n  \n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    int nc=p.first;\n    for(int i=0;i<=n;i++){\n      if(cost[v][i]!=INF && cost[v][i]+nc<dcost[i]){\n\tdcost[i]=cost[v][i]+nc;\n\tque.push(P(dcost[i],i));\n      }\n    }\n  }\n  ans-=dcost[x1];\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n long long d[21][21];\n int i,j,k,m,n,a1,b1,c1,d1,x1,x2,y1,y2;\n cin >> n;\n for (i=1;i<=n;i++) for (j=1;j<n;j++) if (i==j) d[i][j]=0; else d[i][j]=999999999999;\n cin >> m;\n for (i=0;i<m;i++) {\n\t scanf(\"%d,%d,%d,%d\",&a1,&b1,&c1,&d1);\n     d[a1][b1]=c1; d[b1][a1]=d1;\n }\n scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n cout << y1-y2-d[x1][x2]-d[x2][x1] << endl;\n return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define INF (1 << 20)\nusing namespace std;\n\nint V, E, d[20][20];\nint main()\n{\n  cin >> V >> E;\n  for(int i = 0; i < 20; i++)\n    for(int j = 0; j < 20; j++)\n      d[i][j] = (i != j) * INF;\n  for(int i = 0; i < E; i++)\n  {\n    int a, b, c1, c2;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c1, &c2);\n    a--; b--;\n    d[a][b] = c1;\n    d[b][a] = c2;\n  }\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  x1--; x2--;\n\n  for(int k = 0; k < V; k++)\n    for(int i = 0; i < V; i++)\n      for(int j = 0; j < V; j++)\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n  cout << y1 - y2 - d[x1][x2] - d[x2][x1] << endl;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n#define REP1(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint n, m;\nint dis[21][21];\nint s, g, v, p;\n\nint main(){\n    cin >> n >> m;\n\n    REP(i, n+1){\n        REP(j, n+1){\n            if(i!=0 && i==j){\n                dis[i][j] = 0;\n            } else {\n                dis[i][j] = INF; dis[j][i] = INF;\n            }\n        }\n    }\n\n    REP(i, m){\n        int a, b, c, d;\n        scanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        dis[a][b] = c;\n        dis[b][a] = d;\n    }\n\n    scanf_s(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    REP1(k, n+1){\n        REP1(i, n+1){\n            REP1(j, n+1){\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    int output = v - (p + dis[s][g] + dis[g][s]);\n    cout << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define REP(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_E = 500000;\nconst int INF = INT_MAX;\n\nstruct E{\n  int to, cost;\n  E(int t, int c) : to(t), cost(c) {};\n};\ntypedef pair<int, int> pii;\n\nint v;\nvector<E> g[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s)\n{\n  fill(d, d + v, INF);\n  d[s] = 0;\n  priority_queue<pii, vector<pii>, greater<pii> > q;\n  q.push(pii(0, s));\n  \n  while(!q.empty()){\n    pii p = q.top();\n    q.pop();\n    int from = p.second;\n    if(d[from] < p.first) continue;\n    \n    for(int i = 0; i < g[from].size(); ++i){\n      int to = g[from][i].to;\n      int cost = g[from][i].cost;\n      \n      if(d[to] > d[from] + cost){\n        d[to] = d[from] + cost;\n        q.push(pii(d[to], to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  v = n;\n  REP(i, m){\n    int a1, b1, c1, d1;\n    scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n    g[a1].push_back(E(b1, c1));\n    g[b1].push_back(E(a1, d1));\n  }\n  int x1, x2, y1, y2;\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  dijkstra(x1 - 1);\n  int go = d[x2];\n  dijkstra(x2 - 1);\n  int back = d[x1];\n  cout << y1 - go - back - y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tint D[32][32]={{0}};/*Adjacency matrix*/\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tD[a][b] = c;\n\t\tD[b][a] = d;\n\t}\n\tint ans = 0;\n\tint go,back,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&go,&back,&y1,&y2);\n\tans = y1-y2;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j)continue;\n\t\t\tif(D[i][j] == 0)D[i][j] = INF;\n\t\t}\n\t}\n\t\n\tint cost = 0;\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcost = D[go][back] + D[back][go];\n\t\n\tprintf(\"%d\\n\",ans-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n+1,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\n\tprintf(\"%d\\n\",v-p-kou);\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int inf = 1001001001;\nint n,m,a,b,c,d,x1,x2,y1,y2;\nint K[32][32];\n\nvoid floyd(){\n    for(int k=1;k<=n;k++){\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                if(K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n        }\n    }\n}\n\nint main(){\n    for(int i=0;i<32;i++){\n        for(int j=1;j<32;j++){\n            K[i][j] = inf;\n        }\n    }\n    scanf(\"%d%d\", &n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cerr << \"read \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    floyd();\n    scanf(\"%d,%d,%d,%d\", &x1,&x2,&y1,&y2);\n    cout << y1 - y2 - K[x1][x2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20] = {};\n\tfor (int i = 0; i < m; i++)d[i] = 1000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.push(make_pair(0, s));\n\twhile (pq.size()) {\n\t\tP tmp = pq.top();\n\t\tint t = tmp.second;\n\t\tpq.pop();\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tif (d[E[t][i].first] > d[t] + E[t][i].second) {\n\t\t\t\tpq.push(make_pair(d[t] + E[t][i].second, E[t][i].first));\n\t\t\t\td[E[t][i].first] = d[t] + E[t][i].second;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tint ans = 0;\n\tans += (djk(a, b) + djk(b, a));\n\tcout << c - d - ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t}\n\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\t//processing\n\n\tint lowest = wfloyd(n,x1,x2) + wfloyd(n,x2,x1),\n\t\tres = y1 - y2 - lowest;\n\n\tstd::cout << wfloyd(n,x1,x2) << std::endl;\n\tstd::cout << wfloyd(n,x2,x1) << std::endl;\n\tstd::cout << res << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n,m,a,b,c,d,s,g,V,P;\nchar S;\nint adm[22][22]={0}; //adjacency matrix\nconst int inf=1000000000;\n\nint main()\n{\n    cin >> n >> m;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            adm[i][j]=inf;\n        }\n    }\n\n    for(int i=0;i<m;i++)\n    {\n        cin >> a >> S >> b >> S >> c >> S >> d;\n        adm[a][b]=c;\n        adm[b][a]=d;\n    }\n\n    for(int k=1;k<=n;k++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                if(adm[i][j]>adm[i][k]+adm[k][j])\n                {\n                    adm[i][j]=adm[i][k]+adm[k][j];\n                }\n            }\n        }\n    }\n\n    cin >> s >> S >> g >> S >> V  >> S >> P;\n    cout << V-P-adm[s][g]-adm[g][s] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\n// float pinf = std::numeric_limits<float>::infinity();\n//double pinf = INFINITY;\n// これはどうやって使う？ #define INFINITY inf;\nconst int INF = 100000000;\n\nvoid floyd_warshall(vector<vector<int>>& K) {\n\tfor (int k = 0; k < K.size(); k++) {\n\t\tfor (int i = 0; i < K.size(); i++) {\n\t\t\tfor (int j = 0; j < K.size(); j++) {\n\t\t\t\tif (K.at(i).at(k) + K.at(k).at(j) < K.at(i).at(j)) {\n\t\t\t\t\tK.at(i).at(j) = K.at(i).at(k) + K.at(k).at(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\t// 隣接行列の作成\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> K(n, vector<int>(n, INF));\n\tint a, b, c, d;\n\twhile(m--) {\n\t\tcin >> a;\n\t\tcin.ignore();\n\t\tcin >> b;\n\t\tcin.ignore();\n\t\tcin >> c;\n\t\tcin.ignore();\n\t\tcin >> d;\n\t\tK.at(a-1).at(b-1) = c;\n\t\tK.at(b-1).at(a-1) = d;\n\t}\n\n\tint s, g, V, P;\n\tcin >> s;\n\tcin.ignore();\n\tcin >> g;\n\tcin.ignore();\n\tcin >> V;\n\tcin.ignore();\n\tcin >> P;\n\n//\tfor(auto x:K) {\n//\t\tfor(auto i:x) {\n//\t\t\tcout << i;\n//\t\t}\n//\t\tcout << \" \" << endl;\n//\t}\n\tfloyd_warshall(K);\n\n\tint ans;\n\tans = V - P - K.at(s-1).at(g-1) - K.at(g-1).at(s-1);\n\tcout << ans << endl;\n\n//\tfor(auto x:K) {\n//\t\tfor(auto i:x) {\n//\t\t\tcout << i;\n//\t\t}\n//\t\tcout << \" \" << endl;\n//\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nstruct Edge\n{\n\tint to, cost;\n\n\tEdge( int t, int c ) : to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n};\n\nint dijkstra1( const vector< vector< Edge > > G, const int s, const int t )\n{\n\tconst int V = G.size();\n\n\tvector<int> dist( V, INT_MAX );\n\tdist[s] = 0;\n\n\tvector<bool> used( V, false );\n\n\twhile ( true )\n\t{\n\t\tint v = -1;\n\n\t\tfor ( int i = 0; i < V; i++ )\n\t\t{\n\t\t\tif ( !used[i] && ( v == -1 || dist[i] < dist[v] ) )\n\t\t\t{\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\n\t\tif ( v == -1 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tused[v] = true;\n\n\t\tfor ( int i = 0; i < G[v].size(); i++ )\n\t\t{\n\t\t\tdist[ G[v][i].to ] = min( dist[ G[v][i].to ], dist[v] + G[v][i].cost );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint dijkstra2( const vector< vector< Edge > > G, const int s, const int t )\n{\n\tconst int V = G.size();\n\n\tvector<int> dist( V, INT_MAX );\n\n\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\tque.push( make_pair( 0, s ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tint cost = que.top().first;\n\t\tint cur = que.top().second;\n\t\tque.pop();\n\n\t\tif ( dist[ cur ] <= cost )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tdist[ cur ] = cost;\n\n\t\tfor ( int i = 0; i < G[ cur ].size(); i++ )\n\t\t{\n\t\t\tque.push( make_pair( cost + G[ cur ][i].cost, G[ cur ][i].to ) );\n\t\t}\n\t}\n\n\treturn dist[t];\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< vector< Edge > > G( n );\n\n\tfor ( int i = 0; i < m; i++ )\n\t{\n\t\tint a, b, c, d;\n\t\tchar dummy;\n\n\t\tcin >> a >> dummy >> b >> dummy >> c >> dummy >> d;\n\n\t\ta--;\n\t\tb--;\n\n\t\tG[a].push_back( Edge( b, c ) );\n\t\tG[b].push_back( Edge( a, d ) );\n\t}\n\n\tint s, t, money, price;\n\tchar dummy;\n\tcin >> s >> dummy >> t >> dummy >> money >> dummy >> price;\n\n\ts--;\n\tt--;\n\n\tcout << money - price - dijkstra1( G, s, t ) - dijkstra2( G, t, s ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF 200000000\n\nusing namespace std;\n\nint main(void){\n\tint n,m,s,t,c[2];\n\tcin >> n >> m;\n\t\n\tint d[n][n];\n\tfill((int *)d, (int *)d+n*n, INF);\n\tfor(int i=0;i<n;i++) d[i][i] = 0;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> s;\n\t\tcin.ignore();\n\t\tcin >> t;\n\t\tcin.ignore();\n\t\tcin >> c[0];\n\t\tcin.ignore();\n\t\tcin >> c[1];\n\t\td[s-1][t-1] = c[0];\n\t\td[t-1][s-1] = c[1];\n\t}\n\t\n\t//WF\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> s;\n\tcin.ignore();\n\tcin >> t;\n\tcin.ignore();\n\tcin >> c[0];\n\tcin.ignore();\n\tcin >> c[1];\n\tcout << c[0]-c[1]-d[s-1][t-1]-d[t-1][s-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\n    int N, M, st, A, B, C, D, X1, X2, Y1, Y2;\n    int K[20][20];\n    for(int i=0;i<20;++i){\n        for(int j=0;j<20;++j){\n            K[i][j] = INT_MAX / 2;\n        }\n    }\n    scanf(\"%d%d\", &N, &M);\n    {\n\n        for(int i=0;i<M;++i){\n            scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n            K[A-1][B-1]=C;\n            K[B-1][A-1]=D;\n        }\n        scanf(\"%d,%d,%d,%d\", &X1, &X2, &Y1, &Y2);\n        for(int k=0;k<N;++k){\n            for(int i=0;i<N;++i){\n                for(int j=0;j<N;++j){\n                    K[i][j] = min(K[i][j], K[i][k] + K[k][j]);\n                }\n            }\n        }\n    }\n    cout << (Y1-Y2-K[X1-1][X2-1]-K[X2-1][X1-1]) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define INF 1000000000\nusing namespace std;\n\nint d[20];\nint cost[20][20];\nbool done[20];\n\nint N, M, x1, x2, y1, y2;\n\nvoid dj(int s)\n{\n  fill(d, d + 20, INF);\n  fill(done, done + 20, 0);\n  d[s] = 0;\n  while(1)\n  {\n    int v = -1;\n    for(int i = 0; i < N; i++)\n      if(!done[i] && (v == -1 || d[i] < d[v]))\n          v = i;\n    if(v == -1)\n      break;\n    done[v] = 1;\n    for(int i = 0; i < N; i++)\n      d[i] = min(d[i], d[v] + cost[v][i]);\n  }\n  for(int i = 0; i < N; i++)\n    cout << d[i] << \" \";\n  cout << endl;\n}\n\nint main()\n{\n  fill((int*)cost, (int*)cost + 400, 100);\n  cin >> N >> M;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, c, d;\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    a--; b--;\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  x1--; x2--;\n\n  int ans = y1 - y2;\n  dj(x1);\n  ans -= d[x2];\n  dj(x2);\n  ans -= d[x1];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-12;\nconst double INF = 1e9;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;//firstは最短距離,secondは頂点番号\n\n#define MAX_V 21\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+V,INF);\n\td[s]=0;\n\tque.push(P(0,s));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();//仮の最短距離が短い順に取り出す\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tREP(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));//仮の最短距離と頂点の組を更新が行われる度に追加していく\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>V;\n\tint m;\n\tcin>>m;\n\tchar c;\n\tREP(i,m){\n\t\tedge e1,e2;\n\t\tint a,b;\n\t\tcin>>a>>c>>b>>c>>e1.cost>>c>>e2.cost;\n\t\ta--;b--;\n\t\te1.to=b;e2.to=a;\n\t\tG[a].PB(e1);\n\t\tG[b].PB(e2);\n\t}\n\tint x1,x2,y1,y2;\n\tcin>>x1>>c>>x2>>c>>y1>>c>>y2;\n\tx1--;x2--;\n\tdijkstra(x1);\n\tint sum=d[x2];\n\tdijkstra(x2);\n\tsum+=d[x1];\n\tcout<<y1-sum-y2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nconst int inf=1e9;\nusing namespace std;\nint main(){\n  int a,b;\n  cin>>a>>b;\n  vector<vector<int> >in(a,vector<int>(a));\n  rep(i,a)rep(j,a)in[i][j]=inf;\n  int c,d,e,f;\n  cout<<\"!\"<<endl;\n  rep(i,b+1){\n    char x;\n    cin>>c>>x>>d>>x>>e>>x>>f;\n    c--;d--;\n    if(i==b)break;\n    in[c][d]=e;\n    in[d][c]=f;\n  }\n  vector<vector<int> >tmp(a,vector<int>(a));\n  rep(i,a)rep(j,a)tmp[i][j]=in[i][j];\n  rep(k,a)rep(i,a)rep(j,a){\n    tmp[i][j]=min(tmp[i][j],tmp[i][k]+tmp[k][j]);\n    in[i][j]=min(in[i][j],in[i][k]+in[k][j]);\n  }\n  cout<<e-f-(tmp[c][d]+in[d][c])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n\tint city1,city2,cost1to2,cost2to1;\n};\n\n\n\nint main(){\n\tint n=0,m=0,start=0,goal=0,budget=0,treecost=0;\n\tcin>>n>>m;\n\tedge node[m+1];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&node[i].city1,&node[i].city2,&node[i].cost1to2,&node[i].cost2to1);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&budget,&treecost);\n\tint dp[n+1][n+1];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdp[i][j]=10000;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdp[node[i].city1][node[i].city2]=node[i].cost1to2;\n\t\tdp[node[i].city2][node[i].city1]=node[i].cost2to1;\n\t}\n\tfor(int l=1;l<=n;l++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcout<<dp[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<dp[start][goal]<<endl;\n\tcout<<budget-treecost-dp[start][goal]-dp[goal][start]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\n\nint mini(int s,int t){\n  if(s>t){\n    return t;\n  }\n  return s;\n}\n\nint main(){\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M;++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    K[A][B]=C;\n    K[B][A]=D;\n    // cerr << \"read \" <<A<<\" \" << B << \" \" << C <<\" \"<< D <<endl;\n  }\n  for (int i = 1; i < N+1 ; ++i)\n  {\n    for (int j = 0; j < N+1; ++j)\n    {\n      for(int k=0;k<N+1;++k)\n      {\n        K[j][k]=mini(K[j][i]+K[i][k],K[j][k]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n  cerr << y2-y1-K[x1][x2]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>7)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n#define REP1(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint n, m;\nint dis[21][21];\nint s, g, v, p;\n\nint main(){\n    cin >> n >> m;\n\n    REP(i, n+1){\n        REP(j, n+1){\n            if(i!=0 && i==j){\n                dis[i][j] = 0;\n            } else {\n                dis[i][j] = INF; dis[j][i] = INF;\n            }\n        }\n    }\n\n    REP(i, m){\n        int a, b, c, d;\n        scanf_s(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        dis[a][b] = c;\n        dis[b][a] = d;\n    }\n\n    scanf_s(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    REP1(k, n+1){\n        REP1(i, n+1){\n            REP1(j, n+1){\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n\n    int output = v - (p + dis[s][g] + dis[g][s]);\n    cout << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n    }\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<iostream>\n#define INF 100000000\nusing namespace std;\n//typedef pair<int,int> P\nint glid[22][22];\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\t//priority_queue<P, vector<P>, greater<P> > go;\n\t//P toridasi;\n\tint i,j,k;\n\tint n,m,a,b,a_b,b_a;\n\tint kakutei[21],leng[21];\n\tint start,finish,okane,value,mi,point;\n\tcin>>n>>m;\n\tfor(i=0;i<=n;i++) {\n\t\tfor(j=0;j<=n;j++) {\n\t\t\tglid[i][j]=INF;\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) glid[i][i]=0;\n\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&a_b,&b_a);\n\t\ta--;b--;\n\t\tglid[a][b]=a_b;\n\t\tglid[b][a]=b_a;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&finish,&okane,&value);\n\tstart--;finish--;\n//\tcout<<start<<finish<<okane<<value<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[start]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t//\t\t\tmi=glid[point][j];\n\t\t\t}\n\t\t}\n\t//\tokane=okane-mi;\n\t}\n\t//for(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tokane-=leng[finish];\n\t//cout<<endl;\n\tfor(i=0;i<n;i++) {leng[i]=INF;kakutei[i]=0;}\n\tleng[finish]=0;\n\tfor(i=0;i<n;i++) {\n\t\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(kakutei[j]==0 && leng[j]<mi) {\n\t\t\t\tpoint=j;\n\t\t\t\tmi=leng[j];\n\t\t\t}\n\t\t}\n\t\tkakutei[point]=1;\n\t//\tmi=INF;\n\t\tfor(j=0;j<n;j++) {\n\t\t\tif(leng[point]+glid[point][j]<leng[j]) {\n\t\t\t\tleng[j]=leng[point]+glid[point][j];\n\t\t\t\t//mi=glid[point][j];\n\t\t\t}\n\t\t}\n\t\t//okane=okane-mi;\n\t}\n//\tfor(i=0;i<n;i++) cout<<leng[i]<<endl;\n\tswap(start,finish);\n\tokane-=leng[finish];\n\tcout<<okane-value<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_V 20\n\nint d[MAX_V][MAX_V];\nint V;\n\nvoid wf(){\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}\n\n\nint main(){\n  int m;\n  cin>>V>>m;\n\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      d[i][j]=100000;\n    }\n    d[i][i]=0;\n  }\n\n  int a,b,c,e;\n  char yomisute;\n  for(int i=0;i<m;i++){\n    cin>>a>>yomisute>>b>>yomisute>>c>>yomisute>>e;\n    --a;--b;\n    d[a][b]=c;\n    d[b][a]=e;\n  }\n  \n  wf();\n\n\n  cin>>a>>yomisute>>b>>yomisute>>c>>yomisute>>e;\n  int money=0;\n\n  a--;b--;\n  money=d[a][b]+d[b][a];\n  cout<<c-e-money<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#pragma warning(disable:4996)\n\nint x[30][30], D[30];\nint N, M, a, b, c, d;\nint s, t, p, q;\n\nint gr(int st, int go) {\n\tfor (int i = 0; i < 30; i++) { D[i] = 1145141919; }\n\tD[st] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (x[j][k] < 1145141919) {\n\t\t\t\t\tD[k] = min(D[k], D[j] + x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn D[go];\n}\n\nint main() {\n\twhile (cin >> N) {\n\t\tcin >> M;\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < 30; j++) {\n\t\t\t\tx[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\t\tx[a][b] = c;\n\t\t\tx[b][a] = d;\n\t\t}\n\t\tscanf(\"%d,%d,%d,%d\", &t, &s, &p, &q);\n\t\t\n\t\tcout << p - q - gr(s, t) - gr(t, s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define max 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n+1,max);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=max,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=max;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=max,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=max;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\n\tprintf(\"%d\\n\",v-p-kou);\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#define inf 999\n\nusing namespace std;\n\nbool check(int *a, int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tif(a[i] == 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint dij(int **a, int n, int s, int t)\n{\n\tint *label, current = s, next, *cost;\n\t\n\tlabel = (int *)calloc(n+1, sizeof(int));\n\tcost = (int *)calloc(n+1, sizeof(int));\n\tlabel[current] = 1;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcost[i] = a[current][i];\n\t}\n\t\n\twhile(check(label, n)){\n\t\tfor(int i = 1, min = inf; i <= n; i++){\n\t\t\tif(min > cost[i] && label[i] == 0){\n\t\t\t\tmin = cost[i];\n\t\t\t\tnext = i;\n\t\t\t}\n\t\t}\n\t\tlabel[next] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(label[i] == 0 && cost[i] > (a[next][i]+cost[next])){\n\t\t\t\tcost[i] = a[next][i] + cost[next];\n\t\t\t}\n\t\t}\n\t\tcurrent = next;\n\t}\n\tnext = cost[t];\n\t\n\tfree(cost);\n\tfree(label);\n\t\n\treturn next;\n}\n\nint main(int argc, char **argv)\n{\n\tint n, m, **ary, a, b, c, d;\n\t\n\tcin >> n;\n\tcin >> m;\n\t\n\tary = (int **)calloc(n+1, sizeof(int));\n\tfor(int i = 1; i <= n; i++){\n\t\tary[i] = (int *)calloc(n+1, sizeof(int));\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tary[a][b] = c;\n\t\tary[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = i+1; j <= n; j++){\n\t\t\tif(ary[i][j] == 0){\n\t\t\t\tary[i][j] = ary[j][i] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tc -= dij(ary, n, a, b);\n\tc -= d;\n\tc -= dij(ary, n, b, a);\n\tcout << c << endl;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfree(ary[i]);\n\t}\n\tfree(ary);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++j)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=0;k<N;k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j])){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cout << y1-K[x1-1][x2-1]-y2-K[x2-1][x1-1]<< endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n\nint V,E,sta,fin,mon,cha,sum,inf=100000,cost[25][25],dist[25];\nbool used[25];\n\nint main(){\n\tchar tmp;\n\tcin>>V>>E;\n\tfor(int i=0;i<V;i++){\n\t\tfor(int j=0;j<V;j++){\n\t\t\tcost[i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=0;i<V;i++){\n\t\tcost[i][i]=0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>tmp>>b>>tmp>>c>>tmp>>d;\n\t\tcost[a-1][b-1]=c;\n\t\tcost[b-1][a-1]=d;\n\t}\n\tcin>>sta>>tmp>>fin>>tmp>>mon>>tmp>>cha;\n\tfor(int k=0;k<2;k++){\n\t\tint x,y;\n\t\tif(k==0){\n\t\t\tx=sta;\n\t\t\ty=fin;\n\t\t}\n\t\telse{\n\t\t\tx=fin;\n\t\t\ty=sta;\n\t\t}\n\t\tfill(dist,dist+V,inf);\n\t\tfill(used,used+V,false);\n\t\tdist[x-1]=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tif(!used[i]&&(v==-1||dist[i]<dist[v])) v=i;\n\t\t\t}\n\t\t\tif(v==-1) break;\n\t\t\tused[v]=true;\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tdist[i]=min(dist[i],dist[v]+cost[v][i]);\n\t\t\t}\n\t\t}\n\t\tsum+=dist[y-1];\n\t}\n\tcout<<mon-sum-cha<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nconst int MAX_N = 20, INF = 500000;\nint dis[MAX_N+1][MAX_N+1];\n\n//V ¸_ from n_ to I_\nint wfloyd(int V, int from, int to){\n\tfor(int k=0;k<=V;k++){\n\t\tfor(int i=0;i<=V;i++){\n\t\t\tfor(int j=0;j<=V;j++)dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t}\n\t}\n\treturn dis[from][to];\n}\n\nint main(){\n\t//Initialization\n\tfor(int i=0;i<MAX_N+1;i++){\n\t\tfor(int j=0;j<MAX_N+1;j++){\n\t\t\tdis[i][j] = INF;\n\t\t}\n\t}\n\n\t//Input\n\tint n, m;//XÌC¹Ì\n\tstd::cin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tdis[a][b] = c;\n\t\tdis[b][a] = d;\n\t}\n\n\tint x1, x2, y1, y2;\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\t//Processing\n\tint lowest = wfloyd(n,x1,x2) + wfloyd(n,x2,x1),\n\t\tres = y1 - y2 - lowest;\n\n\tstd::cout << res << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nqueue<int> now_n,go_n,money_n;\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n\tif(money<=0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(place[now][i]&&i!=before)ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tchar a;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tplace[num[0]][num[1]]=num[2];\n\t\tplace[num[1]][num[0]]=num[3];\n\t}\n\tint get[4];\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main(){\n\tint cityNum,roadNum;\n\tint city[20];\n\tint road[190][2];\n\tint roadCost[190][2];\t//0:0-1 1:1-0\n\n\tint i,j;\n\tint start,goal,money,hashira;\n\tbool flg;\n\n\tcin>>cityNum>>roadNum;\n\tfor(i=0;i<roadNum;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&road[i][0],&road[i][1],&roadCost[i][0],&roadCost[i][1]);\n\t\troad[i][0]--;road[i][1]--;\n\t}\n\t\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&money,&hashira);\n\tstart--;goal--;\n\t\n\t\n\tfor(i=0;i<cityNum;i++) city[i]=1000000;\n\tcity[start]=0;\n\tdo{\n\t\tflg=false;\n\t\tfor(i=0;i<roadNum;i++){\n\t\t\tfor(j=0;j<2;j++){\n\t\t\t\tif(city[road[i][j]]+roadCost[i][j]<city[road[i][1-j]]){\n\t\t\t\t\tcity[road[i][1-j]]=city[road[i][j]]+roadCost[i][j];\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(flg);\n\thashira+=city[goal];\n\t\n\tfor(i=0;i<cityNum;i++) city[i]=1000000;\n\tcity[goal]=0;\n\tdo{\n\t\tflg=false;\n\t\tfor(i=0;i<roadNum;i++){\n\t\t\tfor(j=0;j<2;j++){\n\t\t\t\tif(city[road[i][j]]+roadCost[i][j]<city[road[i][1-j]]){\n\t\t\t\t\tcity[road[i][1-j]]=city[road[i][j]]+roadCost[i][j];\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(flg);\n\thashira+=city[start];\n\t\n\tcout<<money-hashira<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint cost[22][22]={0};\n \nint main(){\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n            cost[i][j] = 1<<28;\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <functional>\nusing namespace std;\nstruct edge { \n    int to, cost;\n    edge(int _to, int _cost) { to = _to; cost = _cost; }\n};\ntypedef pair<int, int> P;\nvoid solve() {\n    int T, N;\n    scanf(\"%d%d\",&N,&T);\n    vector<edge> G[N];\n    int d[N];\n    for (int i=0; i<T; i++) {\n        int x, y, c1, c2;\n        scanf(\"%d%*c%d%*c%d%*c%d\", &x,&y,&c1,&c2);\n        G[x-1].push_back(edge(y-1,c1));\n        G[y-1].push_back(edge(x-1,c2));\t\n    }\n    int start, goal, gift, cost;\n    scanf(\"%d%*c%d%*c%d%*c%d\",&start,&goal,&gift,&cost);\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d+N, INT_MAX);\n    d[start-1] = 0;\n    que.push(P(0,start-1));\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i=0; i<G[v].size(); i++) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n    int res = gift-cost-d[goal-1];\n    fill(d, d+N, INT_MAX);\n    d[goal-1] = 0;\n    que.push(P(0,goal-1));\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i=0; i<G[v].size(); i++) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n    printf(\"%d\\n\", res-d[start-1]);\n}\nint main() {\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define INF (1<<29)\n\nusing namespace std;\n\nint g[21][21];\nint V;\n\nint main(void){\n\n  fill(g[0],g[21],INF);\n\n  int n;\n  cin >> V >> n;\n\n  int a,b,c,d;\n  for(int i=0;i<n;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    g[a][b]=c,g[b][a]=d;\n  }\n  int x1,x2,y1,y2;\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  for(int k=0;k<=V;k++){\n    for(int i=0;i<=V;i++){\n      for(int j=0;j<=V;j++){\n        g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n      }\n    }\n  }\n\n  cout << y1-g[x1][x2]-g[x2][x1]-y2 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#define inf 99999\n\nusing namespace std;\n\nbool check(int *a, int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tif(a[i] == 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint dij(int **a, int n, int s, int t)\n{\n\tint *label, current=s, next, *cost;\n\t\n\tlabel = (int *)calloc(n+1, sizeof(int));\n\tcost = (int *)calloc(n+1, sizeof(int));\n\tlabel[current] = 1;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcost[i] = a[current][i];\n\t}\n\t\n\twhile(check(label, n)){\n\t\tfor(int i = 1, min = inf; i <= n; i++){\n\t\t\tif(min > cost[i] && label[i] == 0){\n\t\t\t\tmin = cost[i];\n\t\t\t\tnext = i;\n\t\t\t}\n\t\t}\n\t\tlabel[next] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(label[i] == 0 && cost[i] > (a[next][i]+cost[next])){\n\t\t\t\tcost[i] = a[next][i] + cost[next];\n\t\t\t}\n\t\t}\n\t\tcurrent = next;\n\t}\n\tnext = cost[t];\n\t\n\tfree(cost);\n\tfree(label);\n\t\n\treturn next;\n}\n\nint main(int argc, char **argv)\n{\n\tint n, m, **ary1, **ary2, a, b, c, d;\n\t\n\tcin >> n;\n\tcin >> m;\n\t\n\tary1 = (int **)calloc(n+1, sizeof(int));\n\tary2 = (int **)calloc(n+1, sizeof(int));\n\tfor(int i = 1; i <= n; i++){\n\t\tary1[i] = (int *)calloc(n+1, sizeof(int));\n\t\tary2[i] = (int *)calloc(n+1, sizeof(int));\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tary1[a][b] = ary1[b][a] = c;\n\t\tary2[b][a] = ary2[a][b] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i != j && ary1[i][j] == 0){\n\t\t\t\tary1[i][j] = inf;\n\t\t\t\tary2[i][j] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tc -= dij(ary1, n, a, b);\n\tc -= d;\n\tc -= dij(ary2, n, b, a);\n\tcout << c << endl;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfree(ary1[i]);\n\t\tfree(ary2[i]);\n\t}\n\tfree(ary1);\n\tfree(ary2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\nusing namespace std;\n\nint n;\nint con[21][21];\nint cost[21];\nbool used[21];\n\nint dijkstra(int stt, int end) {\n  int a, b, c, d;\n\n  for (int i=1; i<=n; i++) cost[i] = INT_MAX;\n  for (int i=1; i<=n; i++) used[i] = false;\n\n  cost[stt] = 0;\n  used[stt] = true;\n  a = stt;\n  while (!used[end]) {\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && con[a][i]) {\n        b = cost[a] + con[a][i];\n        if (b < cost[i]) {\n          cost[i] = b;\n        }\n      }\n    }\n    c = INT_MAX;\n    d = 0;\n    for (int i=1; i<=n; i++) {\n      if (!used[i] && cost[i] < c) {\n        c = cost[i];\n        d = i;\n      }\n    }\n    used[d] = true;\n    a = d;\n  }\n\n  return cost[end];\n}\n\nint main() {\n  int m, a, b, c, d;\n  int stt, end, budget, pole, ans;\n\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n\n  for (int i=1; i<=n; i++) {\n    for (int j=1; j<=n; j++) {\n      con[i][j] = 0;\n    }\n  }\n\n  for (int i=0; i<m; i++) {\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    con[a][b] = c;\n    con[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &stt, &end, &budget, &pole);\n\n  ans = budget - dijkstra(stt, end) - dijkstra(end, stt) - pole;\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cost;\n};\n\nvector<edge> G[20];\nll longinf = 123451234512345LL;\n\nll dijkstra(int v, int e, int r, int g){   //(vertex, edge, start, goal)\n  ll res = 0;\n  int i, j;\n  ll d[v];\n  rep(i, v)d[i] = longinf;\n  d[r] = 0LL;\n  priority_queue<ll_i, vector<ll_i>, greater<ll_i> > Q;\n  Q.push(mp(0LL, r));\n  for(;!Q.empty();){\n    ll_i now = Q.top();\n    Q.pop();\n    if(d[now.Y] < now.X)continue;\n    rep(i, G[now.Y].size()){\n      edge tmp = G[now.Y][i];\n      if(d[tmp.to] > d[now.Y] + tmp.cost){\n        d[tmp.to] = d[now.Y] + tmp.cost;\n        Q.push(mp(d[tmp.to], tmp.to));\n      }\n    }\n  }\n  res = d[g];\n  return res;\n}\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    int2(n, m);\n    int a, b, c, d;\n    rep(i, m){\n      scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n      --a; --b;\n      G[a].pb((edge){b, c});\n      G[b].pb((edge){a, d});\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    --a; --b;\n    pri(c - d - dijkstra(n, m, a, b) - dijkstra(n, m, b, a));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define INF (1<<20)\nint n,m;\nint wa[21][21];\nmain(){\n  cin >> n;\n  cin >> m;\n  for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) wa[i][j]=INF;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    wa[a][b]=c;\n    wa[b][a]=d;\n  }\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++)\n\twa[i][j] = min(wa[i][j],wa[i][k]+wa[k][j]);\n    }\n  }\n  int x1,x2,y1,y2;\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  int res = y1 - (wa[x1][x2] + wa[x2][x1] + y2 );\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct edge{\n    int to;\n    int cost;\n    edge(int _to,int _cost){\n        to=_to,cost=_cost;\n    }\n};\nstruct node{\n    int num;\n    int cost;\n    node(int _num,int _cost){\n        num=_num,cost=_cost;\n    }\n    bool operator<(const node &a)const{\n        if(cost==a.cost)num>a.num;\n        return cost>a.cost;\n    }\n};\nint N,M;\nvector<edge> E[1000];\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        a--;b--;\n        E[a].push_back(edge(b,c));\n        E[b].push_back(edge(a,d));\n    }\n    int x1,x2,y1,y2;\n    scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n    x1--;\n    x2--;\n    int karians=0;\n\n    priority_queue<node> Q;\n    int mini[1000]={1};\n    //??????\n    for(int i=0;i<1000;i++)mini[i]=2000000000;\n    Q.push(node(x1,0));\n    mini[x1]=0;\n    while(!Q.empty()){\n        node now=Q.top();Q.pop();\n        for(int i=0;i<E[now.num].size();i++){\n            if(mini[E[now.num][i].to]>mini[now.num]+E[now.num][i].cost){\n                mini[E[now.num][i].to]=mini[now.num]+E[now.num][i].cost;\n                Q.push(node(E[now.num][i].to,mini[now.num]+E[now.num][i].cost));\n            }\n        }\n    }\n    karians+=mini[x2];\n\n    //??°???\n    for(int i=0;i<1000;i++)mini[i]=2000000000;\n    Q.push(node(x2,0));\n    mini[x2]=0;\n    while(!Q.empty()){\n        node now=Q.top();Q.pop();\n        for(int i=0;i<E[now.num].size();i++){\n            if(mini[E[now.num][i].to]>mini[now.num]+E[now.num][i].cost){\n                mini[E[now.num][i].to]=mini[now.num]+E[now.num][i].cost;\n                Q.push(node(E[now.num][i].to,mini[now.num]+E[now.num][i].cost));\n            }\n        }\n    }\n    karians+=mini[x1];\n\n    cout<<y1-y2-karians<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,a) for(int i = 0 ; i < a ; i++)\nint main(void){\n  int maze[20][20];\n  int maze1[20][20];\n  int prv[20][20];\n  int n,m;\n  int a,b,c,d;\n  cin>>n>>m;\n  rep(i,n)rep(j,n)maze[i][j]=maze1[i][j]=10000000;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    maze[--a][--b]=c;\n    maze[b][a]=d;\n  }\n  \n  \n  rep(k,n)rep(i,n)rep(j,n){\n    maze[i][j]=min(maze[i][j],maze[i][k]+maze[k][j]);\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  \n  cout<<-maze[--a][--b]-maze[b][a]+c-d<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin>>a>>cc>>b>>cc>>c>>cc>>d;\n            }\n        }\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconstexpr int M_MAX = 100;\nconstexpr int N_MAX = 20;\nconstexpr int INF = 1e8;\n\nint main()\n{\n  int n,m,a,b,c,d,s,g,V,P,reward;\n  struct edge {\n    edge(int t, int c)\n      : to_(t), cost_(c) {};\n    int to_;\n    int cost_;\n  };\n  vector<edge>G[M_MAX];\n  typedef pair<int,int> PII;\n  vector<int> q(N_MAX);\n  priority_queue<PII,vector<PII>,greater<PII>> que;\n\n  cin >> n;\n  cin >> m;\n  for (int i=0;i<m;++i) {\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    G[a].push_back(edge(b,c));\n    G[b].push_back(edge(a,d));\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n\n  reward = V-P;\n\nfill(q.begin(),q.end(),INF);\n  que.push(PII(s,0));\n  q[s] = 0;\n\n  while(!que.empty()){\n    PII k  = que.top();\n    que.pop();\n    int l = k.first;\n\n    for(int i=0;i<G[l].size();i++){\n      edge r = G[l][i];\n      if(q[r.to_] > q[l] + r.cost_){\n        q[r.to_] = q[l] + r.cost_;\n        que.push(PII(r.to_, q[r.to_]));\n      }\n    }\n  }\n\n  reward = reward - q[g];\n\nfill(q.begin(),q.end(),INF);\n  que.push(PII(g,0));\n  q[g] = 0;\n\n  while(!que.empty()){\n    PII e = que.top();\n    que.pop();\n    int l = e.first;\n\n    for(int i=0;i<G[l].size();i++){\n      edge w = G[l][i];\n      if(q[w.to_] > q[l] + w.cost_){\n        q[w.to_] = q[l] + w.cost_;\n        que.push(PII(w.to_, q[w.to_]));\n      }\n    }\n  }\n\n  reward = reward - q[s];\n\n  cout << reward << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define INF 11111111\nusing namespace std;\n\nint main(){\n\n  int n,m;\n  int a,b,c,d;\n  int x,y,r,z;\n  int cost[100][100];\n\n  cin >> n >> m;\n\n  for(int i=0;i<100;i++){\n    for(int j=0;j<100;j++) cost[i][j] = INF;\n  }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost[a][b] = c;\n    cost[b][a] = d;\n  }\n\n  scanf(\"%d,%d,%d,%d\",&x,&y,&r,&z);\n\n  for(int k=1;k<=m;k++){\n    for(int i=1;i<=m;i++){\n      for(int j=1;j<=m;j++) cost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n    }\n  }\n\n  cout << r - z - cost[x][y] - cost[y][x] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n,m,start,end,money,price;\nstruct edge{int to,cost;};\nvector<edge> g[30];\nint d[30];\nvoid dijkstra(int s)\n{\n\tfill(d,d+n,INF);\n\td[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tq.push(mp(0,s));\n\twhile(!q.empty())\n\t{\n\t\tP a=q.top();\n\t\tq.pop();\n\t\tint v=a.sec;\n\t\tif(d[v]<a.fi)continue;\n\t\tfor(int i=0;i<g[v].size();i++)\n\t\t{\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost)\n\t\t\t{\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(mp(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tcin >> n;\n\tcin >> m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tedge in;\n\t\tin.to=b;in.cost=c;\n\t\tg[a].pb(in);\n\t\tin.to=a;in.cost=d;\n\t\tg[b].pb(in);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&end,&money,&price);\n\tstart--;end--;\n\tmoney-=price;\n\tdijkstra(start);\n\tmoney-=d[end];\n\tdijkstra(end);\n\tmoney-=d[start];\n\tcout << money << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF 1000000\n\nint r, n, m;\n\nint dijk(int s, int e, int d[21][21]) {\n  int mi, i, j;\n  int c[m + 1] = {};\n    \n  for(i = 0; i <= m; i++) {\n    c[i] = INF;\n  }\n    \n  int f[m + 1] = {};\n  mi = s;\n  c[s] = 0;\n\n  for(i = 0; i < m; i++){\n    f[mi] = 1;\n\n    for(j = 0; j <= m; j++) {\n      if(f[j] == 1) continue;\n      if(c[j] > d[mi][j] + c[mi]) {\n\tc[j] = d[mi][j] + c[mi];\n\t//\tcout << j << c[j] << endl;\n      }\n    }\n\n    int MIN = INF * 2;\n\n    for(j = 0; j <= m; j++) {\n      if(f[j] == 1) continue;\n      if(MIN > c[j]) {\n\tMIN = c[j];\n\tmi = j;\n      }\n    }\n  }\n  return c[e];\n}\n\n  \nint main() {\n  int i, j, a,b, cost_c, cost_d, h_cost, re, s, e;\n  while(cin >> m >> n) {\n    int d[21][21] = {};\n    \n    for(i = 0; i <= m; i++) {\n      for(j = 0;j <= m; j++) {\n\td[i][j] = INF;\n      }\n    }\n    \n    for(i = 0; i < n; i++) {\n      scanf(\"%d,%d,%d,%d\", &a, &b, &cost_c, &cost_d);\n      //      cin >> a >> b >> cost_c >> cost_d;\n      d[a][b] = cost_c;\n      d[b][a] = cost_d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &e, &re, &h_cost);\n    //    cin >> s >> e >> re >> h_cost;\n    cout << re -dijk(s, e, d) - dijk(e, s, d) - h_cost<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint mini[21][21];\nconst int Inf = 1e5;\n\nint main(){\n\n    int n,m;\n    cin >> n >> m;\n\n    for(int i=0;i<=n;++i){\n        for(int j=0;j<=n;++j){\n            if(i == j)mini[i][j] = 0;\n            else mini[i][j] = Inf;\n        }\n    }\n\n    for(int i=0;i<m;++i){\n        int a,b,c,d;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n        mini[a][b] = c;\n        mini[b][a] = d;\n    }\n\n    int s,g,v,p;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\n    for(int k=1;k<=n;++k){\n        for(int i=1;i<=n;++i){\n            for(int j=1;j<=n;++j){\n                mini[i][j] = min(mini[i][j],mini[i][k]+mini[k][j]);\n            }\n        }\n    }\n\n    cout << v - (p+mini[s][g]+mini[g][s]) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define X 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint n,m,s,g,v,p;\n\tint pp,kou,min;\n\tint i,j,k;\n\tint ri[21][21],leng[21],flg[21];\n\t\n\tPP d[100];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++) scanf(\"%d,%d,%d,%d\",&d[i].ff,&d[i].fs,&d[i].sf,&d[i].ss);\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t\n\tsort(d,d+m);\n\tfor(i=0;i<=n;i++) fill(ri[i]+1,ri[i]+n,X);\n\tfor(i=0;i<m;i++) ri[d[i].ff][d[i].fs]=d[i].sf,\n\t\t\t\t\t ri[d[i].fs][d[i].ff]=d[i].ss;\n\t\t\t\t\t \n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[g];\n\t\n\tfor(i=1;i<=n;i++) leng[i]=X,flg[i]=0;\n\tleng[g]=0;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tmin=X;\n\t\t\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&leng[j]<min) pp=j,min=leng[j];\n\t\tflg[pp]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif(leng[pp]+ri[pp][k]<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\t\n\t}\n\tkou+=leng[s];\n\n\tprintf(\"%d\\n\",v-p-kou);\n\treturn 0;\n}\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tconst int nmax = 21;\n\tint route[nmax][nmax];\n\tint n;\n\tint m;\n\tint a, b, c, d;\n\tint x1, x2, y1, y2;\n\tchar ch;\n\tint cost = 0;\n\tcin >> n >> m;\n\tfor(int i = 0; i < nmax; i++){\n\t\tfor(int j = 0; j < nmax; j++){\n\t\t\troute[i][j] = 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\troute[a][b] = c;\n\t\troute[b][a] = d;\n\t}\n\tfor(int i = 1; i < nmax; i++){\n\t\tfor(int j = 1; j < nmax; j++){\n\t\t\tif(route[j][i])\n\t\t\t\tfor(int k = 1; k < nmax; k++)\n\t\t\t\t\tif(route[i][k])\n\t\t\t\t\t\tif(!route[j][k] || (route[j][i] + route[i][k] < route[j][k]))\n\t\t\t\t\t\t\troute[j][k] = route[j][i] + route[i][k];\n\t\t}\n\t}\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\tcost = route[x1][x2];\n\tcout << y1 - y2 - cost << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\nint dp[30][30];\nint n, m, s, g, V, P;\n\nvoid warshallFloyd() {\n    for (int k = 0; k < n; k++)\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\nint main(void) {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            if (i == j) dp[i][j] = 0;\n            else dp[i][j] = INF;\n        }\n\n    int a, b, c, d;\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        dp[a - 1][b - 1] = c;\n        dp[b - 1][a - 1] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\n    warshallFloyd();\n\n    cout << V - P - dp[s - 1][g - 1] - dp[g - 1][s - 1] << endl;\n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nbool input(){\n  char t;\n  int n;\n  if(!(cin>>n))return false;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nconst int max = 21;\nint cost[max];\nstd::vector<P> g[max];\nint n, m;\n\nvoid dijkstra(int k){\n\tstd::priority_queue < P, std::vector<P>, std::greater<P> > que;\n\tfor (int i = 0; i < n; ++i)cost[i] = infi;\n\tcost[k] = 0;\n\tque.push(P(0, k));\n\twhile (!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (cost[v] < p.first)continue;\n\t\tfor (int i = 0; i < g[v].size(); ++i){\n\t\t\tP e = g[v][i];\n\t\t\tif (cost[e.first] > cost[v] + e.second){\n\t\t\t\tcost[e.first] = cost[v] + e.second;\n\t\t\t\tque.push(P(cost[e.first], e.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> m;\n\trep(i, m){\n\t\tint a, b, c, d;\n\t\tchar ch;\n\t\tstd::cin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\t--a, --b;\n\t\tP p(b, c), q(a, d);\n\t\tg[a].push_back(p);\n\t\tg[b].push_back(q);\n\t}\n\tint x1, x2, y1, y2;\n\tchar ch;\n\tstd::cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\t--x1, --x2;\n\tdijkstra(x1);\n\ty1 -= cost[x2];\n\tdijkstra(x2);\n\ty1 -= cost[x1];\n\ty1 -= y2;\n\tstd::cout << y1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nint n, m;\nint s, t, c, d;\nint dp[500][500];\n\nint main()\n{\n  cin >> n >> m;\n\n  rep(i, n) rep(j, n) dp[i][j] = INF;\n  rep(i, n) dp[i][i] = 0;\n  rep(i, m){\n    scanf(\"%d,%d,%d,%d\", &s, &t, &c, &d);\n    dp[s - 1][t - 1] = c;\n    dp[t - 1][s - 1] = d;\n  }\n\n  scanf(\"%d,%d,%d,%d\", &s, &t, &c, &d);\n  rep(k, n) rep(i, n) rep(j, n) minup(dp[i][j], dp[i][k] + dp[k][j]);\n\n  cout << c - d - dp[s - 1][t - 1] - dp[t - 1][s - 1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\n#define  FOR(i, c) for(__typeof((c).begin())i = (c).begin(); i != (c).end(); ++i)\n\nusing namespace std;\n\ntypedef int Weight;\nconst Weight INF = 1e9;\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s,\n                  vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        if (prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight) {\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n, m;\n    char ch;\n    \n    cin >> n >> m;\n    Graph g(n);\n    for (int i = 0; i < m; i++) {\n        int a, b, c, d;\n\n        cin >> a >> ch >> b >> ch >> c >> ch >> d;\n        a--, b--;\n        g[a].push_back(Edge(a, b, c));\n        g[b].push_back(Edge(b, a, d));\n    }\n    \n    int x1, x2, y1, y2;\n    int w1, w2;\n    vector<Weight> dist;\n    vector<int> prev;\n    cin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n    x1--, x2--;\n    \n    shortestPath(g, x1, dist, prev);\n    w1 = dist[x2];\n    shortestPath(g, x2, dist, prev);\n    w2 = dist[x1];\n    cout << y1 - (y2 + w1 + w2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[20][20];\n\tint n,m,a,b,c,d;\n\tcin >> n >> m;\n\t\n\trep(i,n)rep(j,n)wf[i][j]=(1<<21);\n\t\n\trep(i,m){\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\ta--;b--;\n\t\n\trep(k,n)rep(i,n)rep(j,n)wf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\n\tcout << c-d-wf[a][b]-wf[b][a] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint n,m,t[21][21],u[21],v[21],a,b,c,d;\nint cost(int start,int goal){\n\tint mini,miniNo;\n\tfor(int i=0;i<21;i++){\n\t\tu[i]=INF;\n\t\tv[i]=0;\n\t}\n\tu[start]=0;\n\twhile(1){\n\t\tmini=INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(v[i]==0&&u[i]<mini){\n\t\t\t\tminiNo=i;\n\t\t\t\tmini=u[i];\n\t\t\t}\n\t\t}\n\t\tif(mini==INF)break;\n\t\tv[miniNo]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(u[i]>u[miniNo]+t[miniNo][i]){\n\t\t\t\tu[i]=u[miniNo]+t[miniNo][i];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn u[goal];\n}\nint main(){\n\tfor(int i=0;i<21;i++)for(int j=0;j<21;j++)t[i][j]=INF;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\tt[a][b]=c;t[b][a]=d;\n\t}\n\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\tcout<<c-d-cost(a,b)-cost(b,a)<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define NMAX 22\nbool visited[NMAX];\nint n,m,x1,x2,y1,y2;\nint dist[NMAX][NMAX];\nclass Node{\npublic:\n\tint p,cost;\n\tNode(int _p, int _cost):p(_p),cost(_cost){\n\t}\n\tbool operator < (const Node &o)const{\n\t\treturn cost>o.cost;\n\t}\n};\nint dijkstra(int from,int to){\n\tfill(visited,visited+NMAX,false);\n\tpriority_queue<Node> pq;\n\tpq.push(Node(from,0));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.top();pq.pop();\n\t\tif(cur.p==to)return cur.cost;\n\t\tif(visited[cur.p])continue;\n\t\tvisited[cur.p]=true;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(cur.p==i||dist[cur.p][i]==-1)continue;\n\t\t\tpq.push(Node(i,cur.cost+dist[cur.p][i]));\t\t\t\n\t\t}\n\t}\n}\nvoid solve(){\n\tcout<<y1-y2-dijkstra(x1,x2)-dijkstra(x2,x1)<<endl;\n}\nvoid init(){\n\tfor(int i=0;i<=NMAX;i++)fill(dist[i],dist[i]+NMAX,-1);\t\n}\nint main(){\n\tint a,b,c,d;\n\tcin>>n>>m;\n\tchar dmy;\n\tinit();\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>dmy>>b>>dmy>>c>>dmy>>d;\n\t\tdist[a][b]=c;\n\t\tdist[b][a]=d;\n\t}\n\tcin>>x1>>dmy>>x2>>dmy>>y1>>dmy>>y2;\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nvector<int> split_s2i(const std::string &str, char sep){\n  vector<int> v;\n  stringstream ss(str);\n  string buffer;\n  while(getline(ss, buffer, sep)){ v.push_back(stoi(buffer)); }\n  return v;\n}\n\nint main(void){\n  int n, m;\n  cin >> n;\n  cin >> m;\n\n  vector<vector<int> > dp(n, vector<int>(n, INF));\n  string input;\n  for(int i = 0; i < m; i++){\n    cin >> input;    \n    vector<int> inp = split_s2i(input, ',');\n    dp[inp[0] - 1][inp[1] - 1] = inp[2];\n    dp[inp[1] - 1][inp[0] - 1] = inp[3];\n  }\n  for(int i = 0; i < n; i++)\n    dp[i][i] = 0;\n\n  // ???????????£???????????????\n  for(int k = 0; k < n; k++)\n    for(int i = 0; i < n; i++)\n      for(int j = 0; j < n; j++)\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);  \n\n  // ?????¨?????????\n  cin >> input;\n  vector<int> query = split_s2i(input, ',');\n  int s = query[0] - 1;\n  int g = query[1] - 1;\n  int v = query[2];\n  int p = query[3];\n  int ans = v - (dp[s][g] + p + dp[g][s]);\n\n  // ??????\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint cost[20][20];\nint INF = 1e9;\nint n;\n\nint dikst(int s, int g)\n{\n    bool used[n] = {};\n    int d[n];\n    rep(i, n) d[i] = INF;\n    d[s] = 0;\n    while (1)\n    {\n        int minv = INF;\n        int u;\n        rep(i, n)\n        {\n            if (!used[i] && d[i] < minv)\n            {\n                minv = d[i];\n                u = i;\n            }\n        }\n        if (minv == INF)\n            break;\n\n        used[u] = 1;\n        rep(i, n)\n        {\n            if (!used[i] && cost[u][i] != INF && d[i] > cost[u][i] + d[u])\n                d[i] = cost[u][i] + d[u];\n        }\n    }\n    return d[g];\n}\n\nint main()\n{\n    int m;\n    cin >> n >> m;\n    rep(i, 20) rep(j, 20) cost[i][j] = INF;\n    char ch;\n    rep(i, m)\n    {\n        int a, b, c, d;\n        cin >> a >> ch >> b >> ch >> c >> ch >> d;\n        --a, --b;\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n\n    int s, g, v, p;\n    cin >> s >> ch >> g >> ch >> v >> ch >> p;\n    --s, --g;\n\n    OP(v - p - dikst(s, g) - dikst(g, s));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n\tif(money<=0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=maxnum[now];i++)if(place[now][i]&&i!=before)ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tchar a;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tplace[num[0]][num[1]]=num[2];\n\t\tplace[num[1]][num[0]]=num[3];\n\t\tmaxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n\t}\n//\tfor(int i=1;i<=n;i++){for(int j=1;j<=n;j++){cout<<place[i][j]<<\" \";}cout<<endl;}\n\tint get[4];\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define INF 999999\n#define MAX_V 999\n\nusing namespace std;\n\nstruct Node{\n\tint cost;\n\tint depart;\n\tint arrival;\n};\n\nvector<Node> dat;\nvector<int> cost;\n\nvoid dijkstra(int s){\n\tint pos;\n\tqueue<int> q;\n\tint t;\n\tcost.at(s)=0;\n\t\n\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\n\t\tif((*i).depart==s){\n\t\t\tq.push((*i).arrival);\n\t\t\tcost.at((*i).arrival)=(*i).cost;\n\t\t}\n\t}\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tpos=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(vector<Node>::iterator i=dat.begin();i!=dat.end();i++){\t\t\tif((*i).depart==pos){\n\t\t\t\tif(cost.at((*i).arrival)==INF){\n\t\t\t\t\tq.push((*i).arrival);\n\t\t\t\t}\n\t\t\t\tif(cost.at((*i).arrival)>(*i).cost+cost.at(pos)){\n\t\t\t\t\tcost.at((*i).arrival)=(*i).cost+cost.at(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=true;\n\t\trep(i,cost.size()){\n\t\t\tif(cost.at(i)==INF){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint a, b, c, d, x1, x2, y1, y2;\n\tNode t;\n\tint n, m;\n\tcin>>n>>m;\n\trep(I,m){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tt.depart =a;\n\t\tt.cost   =c;\n\t\tt.arrival=b;\n\t\tdat.push_back(t);\n\t\tt.depart =b;\n\t\tt.cost   =d;\n\t\tt.arrival=a;\n\t\tdat.push_back(t);\n\t}\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tdijkstra(x1);\n\tint Cost=cost.at(x2);\n\tcost.clear();\n\trep(k,n+1){\n\t\tcost.push_back(INF);\n\t}\n\tdijkstra(x2);\n\tcout<<y1-y2-Cost-cost.at(x1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n\tint city1,city2,cost1to2,cost2to1;\n};\n\n\n\nint main(){\n\tint n=0,m=0,start=0,goal=0,budget=0,treecost=0;\n\tcin>>n>>m;\n\tedge node[m+1];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&node[i].city1,&node[i].city2,&node[i].cost1to2,&node[i].cost2to1);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&budget,&treecost);\n\tint dp[n+1][n+1];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdp[i][j]=10000;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tdp[node[i].city1][node[i].city2]=node[i].cost1to2;\n\t\tdp[node[i].city2][node[i].city1]=node[i].cost2to1;\n\t}\n\tfor(int j=1;j<=n;j++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<=n;j++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\tif(!(j==k || k==l || l==j))dp[j][k]=min(dp[j][k],dp[j][l]+dp[l][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[start][goal]<<endl;\n\tcout<<budget-treecost-dp[start][goal]-dp[goal][start]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  const int INF = 1e9 + 10;\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n        }\n      }\n    }\n\n    return d;\n  }\n};\n\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Dijkstra dijkstra(n);\n  for (int i = 0; i < m; i++) {\n    int a, b, c, d;\n    char delim;\n    cin >> a >> delim >> b >> delim >> c >> delim >> d;\n    a--;\n    b--;\n    \n    dijkstra.AddEdge(a, b, c);\n    dijkstra.AddEdge(b, a, d);\n  }\n\n  int s, g, v, p;\n  char delim;\n  cin >> s >> delim >> g >> delim >> v >> delim >> p;\n  s--;\n  g--;\n  \n  vector<int> dgo = dijkstra.Solve(s);\n  vector<int> dreturn = dijkstra.Solve(g);\n\n  int cost = dgo[g] + dreturn[s];\n\n  int ans = v - p - cost;\n\n  cout << ans << endl;\n   \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nvoid input(){\n  char t;\n  int n;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  init();\n  input();\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define MAX_V 190\n#define INF 100000\nusing namespace std;\nint go[MAX_V];\nint back[MAX_V];\nbool used[MAX_V];\nint cost[MAX_V][MAX_V];\nint n;\n\nvoid dijkstra(int s, int d[]) {\n\tfill(d, d + n + 1, INF);\n\tfill(used, used + n + 1, false);\n\td[s] = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (!used[i] && (v == -1 || d[i] < d[v])) v = i;\n\t\t}\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\td[i] = min(d[i], d[v] + cost[v][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint m, a, b, c, d, x1, x2, y1, y2;\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfill(cost[i], cost[i] + n + 1, INF);\n\t}\n\twhile (m--) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c; cost[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tdijkstra(x1, go);\n\tdijkstra(x2, back);\n\tcout << y1 - (go[x2] + back[x1] + y2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define INF (1<<30)\n\nint dist[30][30];\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i == j)dist[i][j] = 0;\n\t\t\telse      dist[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\n\t\tdist[a-1][b-1] = c;\n\t\tdist[b-1][a-1] = d;\n\t}\t\n\n\n\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> x2 >> y1 >> y2;\n\n\tcout << (y1 - y2 - dist[x1-1][x2-1] - dist[x2-1][x1-1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nclass Node{\npublic:\n\tvector< int > e_to;\n\tvector< int > e_cost;\n\t\n\tbool def;\n\tint min_cost;\n\t\n\tNode(){\n\t\tdef = false;\n\t\tmin_cost = -1;\n\t}\n};\nbool operator==(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost == ot2.min_cost;\n}\nbool operator!=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 == ot2);\n}\nbool operator<(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost < ot2.min_cost;\n}\nbool operator>(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost > ot2.min_cost;\n}\nbool operator<=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 > ot2);\n}\nbool operator>=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 < ot2);\n}\nvector< Node > nodes;\npriority_queue< Node, vector< Node >, greater< Node > > que;\n\nint dijkstra(int s, int t){\n\tfor(vector< Node >::iterator it = nodes.begin(); it != nodes.end(); ++it){\n\t\tit->def = false;\n\t\tit->min_cost = -1;\n\t}\n\tnodes[s].min_cost = 0;\n\tque.push(nodes[s]);\n\twhile(!que.empty()){\n\t\tNode def_node = que.top();\n\t\tque.pop();\n\t\tif(def_node.def)continue;\n\t\tdef_node.def = true;\n\t\tfor(int i = 0; i < def_node.e_to.size(); ++i){\n\t\t\tint to = def_node.e_to[i];\n\t\t\tint cost = def_node.min_cost + def_node.e_cost[i];\n\t\t\tif(nodes[to].min_cost == -1 || cost < nodes[to].min_cost){\n\t\t\t\tnodes[to].min_cost = cost;\n\t\t\t\tque.push(nodes[to]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nodes[t].min_cost;\n}\n\nint main(){\n\tint n, m, a, b, c, d, x1, x2, y1, y2;\n\t\n\t\n\tcin >> n >> m;\n\tnodes.resize(n);\n\t\n\tfor(int i = 0; i < n; ++i){\n\t\tnodes[i] = Node();\n\t}\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tnodes[a - 1].e_to.push_back(b - 1);\n\t\tnodes[a - 1].e_cost.push_back(c);\n\t\t\n\t\tnodes[b - 1].e_to.push_back(a - 1);\n\t\tnodes[b - 1].e_cost.push_back(d);\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tcout << y1 - y2 - (dijkstra(x1-1, x2-1) + dijkstra(x2-1, x1-1)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m;\n\tint x1, x2, y1, y2;\n\tchar dummy;\n\n\tcin >> n;\n\tcin >> m;\n\n\tvector<int> a(m), b(m), c(m), d(m);\n\tvector< vector <int> > map(n + 1, vector<int>(n + 1, INT_MAX / 4));\n\t\n\tfor(int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> dummy >> b[i] >> dummy >> c[i] >> dummy >> d[i];\n\t}\n\tcin >> x1 >> dummy >> x2 >> dummy >> y1 >> dummy >> y2;\n\n\tfor(int i = 0; i < m; i++) {\n\t\tmap[a[i]][b[i]] = c[i];\n\t\tmap[b[i]][a[i]] = d[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tmap[i][i] = 0;\n\t}\n\n\tfor(int k = 0; k < n + 1; k++) {\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tfor(int j = 0; j < n + 1; j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\ty1 -= map[x1][x2] + map[x2][x1] + y2;\n\n\tcout << y1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define MAX 100000\n\ntypedef pair<int, int> P;\n\nint main(){\n\tvector <P> city[20];\n\tint n;\n\tint m;\n\tint a, b, c, d;\n\tchar e;\n\tcin >> n;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> e >> b >> e >> c >> e >> d;\n\t\tcity[a].push_back(P(c, b));\n\t\tcity[b].push_back(P(d, a));\n\t}\n\tint citty[20];\n\tfor (int i = 0; i < 20; i++) {\n\t\tcitty[i] = MAX;\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> e >> x2 >> e >> y1 >> e >> y2;\n\n\tcitty[x1] = 0;\n\tpriority_queue< P, vector<P>, greater<P> > pq;\n\tpq.push(P(0, x1));\n\n\twhile (!pq.empty()) {\n\t\tP p = pq.top();\n\t\tpq.pop();\n\t\tint v = p.second;\n\t\tif (citty[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < city[v].size(); i++) {\n\t\t\tP pp = city[v][i];\n\t\t\tif (citty[pp.second] > citty[v] + pp.first) {\n\t\t\t\tcitty[pp.second] = citty[v] + pp.first;\n\t\t\t\tpq.push(P(citty[pp.second], pp.second));\n\t\t\t}\n\t\t}\n\t}\n\tint ouro = citty[x2];\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tcitty[i] = MAX;\n\t}\n\tcitty[x2] = 0;\n\tpq.push(P(0, x2));\n\twhile (!pq.empty()) {\n\t\tP p = pq.top();\n\t\tpq.pop();\n\t\tint v = p.second;\n\t\tif (citty[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < city[v].size(); i++) {\n\t\t\tP pp = city[v][i];\n\t\t\tif (citty[pp.second] > citty[v] + pp.first) {\n\t\t\t\tcitty[pp.second] = citty[v] + pp.first;\n\t\t\t\tpq.push(P(citty[pp.second], pp.second));\n\t\t\t}\n\t\t}\n\t}\n\tint fukuro = citty[x1];\n\tcout << y1-y2-ouro-fukuro << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <iostream>\n#define rep(i,n) for(int i = 0;i<(n);i++)\nconst int inf = 1001001001;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M;\nint X1,X2,Y1,Y2;\nint mindist[22];\nvector<pair<int,int> > G[22];\nint main(){\n\trep(i,22){\n\t\tmindist[i] = inf;\n\t}\n\tscanf(\"%d\",&N);\n\tscanf(\"%d\",&M);\n\trep(i,M){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,d));\n\t}\n\tscanf(\"%d,%d,%d,%d\",&X1,&X2,&Y1,&Y2);\n\tmindist[X1]=0;\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(P(0,X1));\n\twhile(!Q.empty()){\n\t\tP p = Q.top(); Q.pop();\n\t\tint v = p.second;\n\t\tif(mindist[v] < p.first) continue;\n\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\tP e = G[v][i];\n\t\t\tif(mindist[e.second] > mindist[v] + e.first){\n\t\t\t\tmindist[e.second] = mindist[v] + e.first;\n\t\t\t\tQ.push(P(mindist[e.second],e.second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << Y1 - mindist[X2] - Y2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n\nint D[30][30];\n\nint main() {\n  int n, m; scanf(\"%d%d\", &n, &m);\n  memset(D, 0x0f, sizeof(D));\n  REP(i, n) { D[i][i] = 0; }\n  REP(i, m) {\n    int a, b, c, d; scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d); --a; --b;\n    D[a][b] = c; D[b][a] = d;\n  }\n  int x1, x2, y1, y2; scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2); --x1; --x2;\n  REP(k, n) REP(i, n) REP(j, n) {\n    D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n  }\n  printf(\"%d\\n\", y1 - (y2 + D[x1][x2] + D[x2][x1]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nconst ll INF=1e10;\n#define PI 3.141592\n#define pb push_back\n\nvoid show(vector<vll> a){\n    range(i,1,a.size()){\n        range(j,1,a[i].size()){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    int n,m; cin >> n >> m;\n    char ch;\n    vint a(m),b(m),c(m),d(m);\n    vector<vll> K(n+1,vll(n+1,INF));\n    rep(i,m){\n        int a,b; cin >> a >> ch >> b >> ch;\n        cin >> K[a][b] >> ch >> K[b][a];\n    }\n    int s,g,v,p; cin >> s >> ch >> g >> ch >>  v >> ch >> p;\n\n    range(k,1,n+1) range(i,1,n+1) range(j,1,n+1){\n        if(K[i][j]>K[i][k]+K[k][j]){\n            K[i][j]=K[i][k]+K[k][j];\n        }\n    }\n    cout << v-p-K[s][g]-K[g][s] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint cost[20][20];\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<20;i++)for(int j=0;j<20;j++)cost[i][j]=1<<29;\n\tfor(int i=0;i<20;i++)cost[i][i]=0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a;\n\t\tcin.ignore();\n\t\tcin>>b;\n\t\tcin.ignore();\n\t\tcin>>c;\n\t\tcin.ignore();\n\t\tcin>>d;\n\t\ta--;b--;\n\t\tcost[a][b]=c;\n\t\tcost[b][a]=d;\n\t}\n\tint x1,x2,y1,y2;\n\tcin>>x1;\n\tcin.ignore();\n\tcin>>x2;\n\tcin.ignore();\n\tcin>>y1;\n\tcin.ignore();\n\tcin>>y2;\n\tx1--;x2--;\n\tfor(int k=0;k<n;k++)\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\tcout<<y1-y2-cost[x1][x2]-cost[x2][x1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n  const int MAX=20;\n  const int INF=(1<<21);\nint main(){\n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  int road[MAX][MAX];\n  cin>> n>> m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      road[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    road[a-1][b-1]=c;\n    road[b-1][a-1]=d;\n  }\n   for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\troad[j][k]=min(road[j][k],road[j][i]+road[i][k]);\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  cout<< y1-(y2+road[x1-1][x2-1]+road[x2-1][x1-1])<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n#define INF 100000000\n#define fi first\n#define sec second\ntypedef pair<int,int> P;\n\nint n, m, ans;\nint x1, x2, y1, y2;\nchar tsh;\nvector<P> G[20];\nint dis[20];\n\nvoid dijkstra(int s){\n\tfor(int i = 0; i < 20; i++) dis[i] = INF;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tdis[s] = 0;\n\tque.push(P(0,s));\n\t\n\twhile(!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dis[G[v][i].fi] > dis[v]+G[v][i].sec){\n\t\t\t\tdis[G[v][i].fi] = dis[v]+G[v][i].sec;\n\t\t\t\tque.push(P(dis[G[v][i].fi],G[v][i].fi));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%c%d%c%d%c%d\",&a,&tsh,&b,&tsh,&c,&tsh,&d);\n\t\ta--; b--;\n\t\tG[a].push_back(P(b,c));\n\t\tG[b].push_back(P(a,d));\n\t}\n\tscanf(\"%d%c%d%c%d%c%d\",&x1,&tsh,&x2,&tsh,&y1,&tsh,&y2);\n\tans = y1-y2;\n\tx1--; x2--;\n\tdijkstra(x1);\n\tans -= dis[x2];\n\tdijkstra(x2);\n\tans -= dis[x1];\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nstatic const int MAX = 21;\nstatic const int INFTY = (1 << 30);\nint V;\nstd::vector<std::pair<int, int> > G[MAX];\n\nint dijkstra(int r, int t) {\n    priority_queue<std::pair<int, int> > pq;\n    bool visited[MAX];\n    int d[MAX];\n    for (int i = 0; i < V; i++) {\n        visited[i] = false;\n        d[i] = INFTY;\n    }\n    d[r] = 0;\n    pq.push({0, r}); //dist from target * -1, current node\n    visited[r] = true;\n\n    while ( !pq.empty() ) {\n        pair<int, int> f = pq.top(); pq.pop();\n        int current = f.second;\n        visited[current] = true;\n\n        if (d[current] < f.first * (-1)) continue;\n\n        for (unsigned long i = 0; i < G[current].size(); i++) {\n            int target = G[current][i].first;\n            if (visited[target]) continue;\n            if (d[target] > d[current] + G[current][i].second) {\n                d[target] = d[current] + G[current][i].second;\n                pq.push({d[target] * (-1), target});\n            }\n        }\n    }\n    return d[t];\n}\n\nint main()\n{\n    int E, source, target, cost, back, s, g, VV, P;\n    scanf(\"%d %d\", &V, &E);\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d,%d,%d,%d\", &source, &target, &cost, &back);\n        source--; target--;\n        G[source].push_back({target, cost});\n        G[target].push_back({source, back});\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &VV, &P);\n    s--; g--;\n    printf(\"%d\\n\", VV-P-dijkstra(s, g)-dijkstra(g, s));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint K[20][20];\nint n,m,a,b,c,d;\nint Floyd(int K[20][20],int n) {\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]) {\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\\n\",&n);\n\tscanf(\"%d\\n\",&m);\n\tcout << n << \" \" << m << endl;\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<n; ++j) {\n\t\t\tK[i][j] = 100000;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\tK[a-1][b-1] = c;\n\t\tK[b-1][a-1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tFloyd(K,n);\n\tcout << c-d-K[a-1][b-1]-K[b-1][a-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int SIZE = 20;\nconst int MAX = 255;\nint town,way;\nint e[SIZE][SIZE];\nint cost[SIZE];\nbool used[SIZE];\n\nint dijkstra(int start, int end){\n\tfor(int i=0; i<town; i++){\n\t\tcost[i] = MAX;\n\t\tused[i] = false;\n\t}\n\tcost[start] = 0;\n\n\twhile(1){\n\t\t//step1\n\t\tint v = -1;\n\t\tfor(int i=0; i<town; i++)\n\t\t\tif(!used[i] && (v==-1 || cost[v]>cost[i])) v=i;\n\t\tif(v==-1) break;\n\t\t//step2\n\t\tused[v] = true;\n\t\t//step3\n\t\tfor(int i=0; i<town; i++)\n\t\t\tcost[i] = min(cost[i],cost[v]+e[v][i]);\n\t}\n\n\treturn cost[end];\n}\n\nint main(void){\n\tint start,end,money,price,prize;\n\tchar dummy;\n\n\tcin >> town >> way;\n\tfor(int i=0; i<town; i++){\n\t\tfor(int j=0; j<town; j++){\n\t\t\te[i][j]=MAX;\n\t\t}\n\t}\n\tfor(int i=0; i<way; i++){\n\t\tint a,b,atob,btoa;\n\t\tcin >> a >> dummy >> b >> dummy >> atob >> dummy >> btoa;\n\t\ta--; b--;\n\t\te[a][b] = atob;\n\t\te[b][a] = btoa;\n\t}\n\tcin >> start >> dummy >> end >> dummy >> money >> dummy >> price;\n\tend--; start--;\n\n\tprize = money - price;\n\tprize -= dijkstra(start,end);\n\tprize -= dijkstra(end,start);\n\n\tcout << prize << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=10000000;\nint map[21][21];\n\nint main(void){\n\tint a,b,c;\n\tint d[4];\n\tint ans;\n\tint n,m;\n\tfor(a=0;a<=20;a++){\n\t\tfor(b=0;b<=20;b++){\n\t\t\tmap[b][a]=INF;\n\t\t\tif(b==a)map[b][a]=0;\n\t\t}\n\t}\n\tcin >> n;\n\tcin >> m;\n\tfor(a=0;a<m;a++){\n\t\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\t\tmap[d[0]][d[1]]=d[2];\n\t\tmap[d[1]][d[0]]=d[3];\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tfor(b=1;b<=n;b++){\n\t\t\tfor(c=1;c<=n;c++){\n\t\t\t\tmap[c][b]=min(map[c][b],map[c][a]+map[a][b]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\",&d[0],&d[1],&d[2],&d[3]);\n\tans=d[2]-d[3]-map[d[0]][d[1]]-map[d[1]][d[0]];\n\tcout << ans <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define ALL(c) c.begin(), c.end()\n#define mp make_pair\n#define pb push_back\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n \nusing namespace std; \n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 20;\nint n, d[N], cost[N][N];\nbool used[N];\n\nvoid dijkstra(int);\n\nint main(void){\n    rep(i, N) fill(cost[i], cost[i] + N, INF);\n\n    char sp;\n    int m; cin >> n >> m;\n    while(m--){\n        int a, b, c1, c2; cin >> a >> sp >> b >> sp >> c1 >> sp >> c2;\n        a--, b--;\n        cost[a][b] = c1;\n        cost[b][a] = c2;\n    }\n    int x1, x2, y1, y2; cin >> x1 >> sp >> x2 >> sp >> y1 >> sp >> y2;\n    int res = y1 - y2;\n\n    x1--, x2--;\n    dijkstra(x1), res -= d[x2];\n    dijkstra(x2), res -= d[x1];\n\n    cout << res << endl;\n\n    return 0;\n}\n\nvoid dijkstra(int s){\n    fill(used, used + N, false);\n    fill(d, d + N, INF);\n\n    d[s] = 0;\n\n    while(1){\n        int v = -1;\n        rep(u, n){\n            if(!used[u] && (v == -1 || d[u] < d[v])) v = u;\n        }\n        if(v == -1) break;\n        used[v] = true;\n\n        rep(u, n){\n            d[u] = min(d[u], d[v] + cost[v][u]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1001001;\n        }\n    }\n    for(i=0;i<m;i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++){\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin>>a>>cc>>b>>cc>>c>>cc>>d;\n            }\n        }\n    }\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n/** Problem0117 : A reward for a Carpenter **/\nconst int INF = 100000;\nint d[21][21];\nint path[21][21];\nint V, E;\n\n\nint main()\n{\n\tint s, g, plus, minus;\n\tchar c;\n\tcin >> V >> E;\n\t\n\tfor (int i=0; i<21; i++)\n\t\tfor (int j=0; j<21; j++) d[i][j] = INF;\n\t\n\tfor (int i=0; i<E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> c >> b >> c >> d[a][b] >> c >> d[b][a];\n\t}\n\t\n\tcin >> s >> c >> g >> c >> plus >> c >> minus;\n\t\n\tfor (int k=1; k<=V; k++)\n\t\tfor (int i=1; i<=V; i++)\n\t\t\tfor (int j=1; j<=V; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\n\tcout << plus - (minus + d[s][g] + d[g][s]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 6;\nconst ll LLINF = 1e18 + 1;\n\n// dijkstra O(ElogV)\n// verify : https://onlinejudge.u-aizu.ac.jp/problems/GRL_1_A\ntemplate<typename T>\nstruct Dijkstra {\nprivate:\n    int V;\n    struct edge { int to; T cost; };\n    vector<vector<edge>> G;\npublic:\n    const T inf = numeric_limits<T>::max();\n\n    // s から i の最小コスト\n    // 経路がない場合は inf\n    vector<T> d;\n\n    Dijkstra(int V) : V(V) {\n        G.resize(V);\n    }\n\n    // 辺の追加\n    // 有向の場合　directed = true\n    void add_edge(int from, int to, T weight, bool directed = false) {\n        G[from].push_back({to,weight});\n        if (!directed) G[to].push_back({from,weight});\n    }\n\n    void build(int s) {\n        d.assign(V, inf);\n        typedef pair<T, int> P; //(cost,v)\n        priority_queue<P, vector<P>, greater<P>> pq;\n        d[s] = 0;\n        pq.push(P(d[s], s));\n\n        while (!pq.empty()) {\n            P p = pq.top(); pq.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (const edge &e : G[v])\n            {\n                // 最小値が更新されるとき push\n                if (d[e.to] > d[v] + e.cost) {\n                    d[e.to] = d[v] + e.cost;\n                    pq.push({d[e.to], e.to});\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    Dijkstra<ll> G(n);\n    REP(i, m) {\n        int a, b, c, d; scanf(\"%d%*c%d%*c%d%*c%d\", &a, &b, &c, &d);\n        G.add_edge(a - 1, b - 1, c, true);\n        G.add_edge(b - 1, a - 1, d, true);\n    }\n    int s, g, V, P; scanf(\"%d%*c%d%*c%d%*c%d\", &s, &g, &V, &P);\n    s--; g--; V -= P;\n    G.build(s);\n    ll ans = V - G.d[g];\n    G.build(g);\n    ans -= G.d[s];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tlong long int cost[21][21];\n\tint n,m;\n\tchar com;\n\tcin>>n>>m;\n\tfor(int i=0;i<21;i++){\n\t\tfor(int j=0;j<21;j++){\n\t\t\tcost[i][j]=1<<27;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>com>>b>>com>>c>>com>>d;\n\t\tcost[a][b]=c;cost[b][a]=d;\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tcin>>x1>>com>>x2>>com>>y1>>com>>y2;\n\tcout<<y1-y2-cost[x1][x2]-cost[x2][x1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> P;\n#define REP(i, x, n) for(lint i = x ; i < n ; i++)\n#define rep(i, n) REP(i, 0, n)\n#define repr(i, n) for(lint i = n - 1 ; i >= 0 ; i--)\n#define SORT(c) sort((c).begin(), (c).end())\n\nconst int IINF = 1e9 + 10;\nconst lint LLINF = (lint)1e18 + 10;\nconst lint MOD = (lint)1e9 + 7;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    int dis[25][25];\n    rep(i, 25){\n        rep(j, 25){\n            dis[i][j] = IINF;\n        }\n        dis[i][i] = 0;\n    }\n    string tmp;\n    int l = 0;\n    rep(i, m){\n        cin >> tmp;\n        l = 0;\n        int a = 0, b = 0, c = 0, d = 0;\n        while(true){\n            if(tmp[l] == ','){\n                break;\n            }\n            a *= 10;\n            a += tmp[l] - '0';\n            l++;\n        }\n        l++;\n        while(true){\n            if(tmp[l] == ','){\n                break;\n            }\n            b *= 10;\n            b += tmp[l] - '0';\n            l++;\n        }\n        l++;\n        while(true){\n            if(tmp[l] == ','){\n                break;\n            }\n            c *= 10;\n            c += tmp[l] - '0';\n            l++;\n        }\n        l++;\n        while(l < tmp.size()){\n            d *= 10;\n            d += tmp[l] - '0';\n            l++;\n        }\n        a--;\n        b--;\n        dis[a][b] = c;\n        dis[b][a] = d;\n    }\n    cin >> tmp;\n    l = 0;\n    int s = 0, g = 0, v = 0, p = 0;\n    while(true){\n        if(tmp[l] == ','){\n            break;\n        }\n        s *= 10;\n        s += tmp[l] - '0';\n        l++;\n    }\n    l++;\n    while(true){\n        if(tmp[l] == ','){\n            break;\n        }\n        g *= 10;\n        g += tmp[l] - '0';\n        l++;\n    }\n    l++;\n    while(true){\n        if(tmp[l] == ','){\n            break;\n        }\n        v *= 10;\n        v += tmp[l] - '0';\n        l++;\n    }\n    l++;\n    while(l < tmp.size()){\n        p *= 10;\n        p += tmp[l] - '0';\n        l++;\n    }\n    s--;\n    g--;\n    rep(k, n){\n        rep(i, n){\n            rep(j, n){\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n        }\n    }\n    int ans = v - (dis[s][g] + dis[g][s] + p);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//A_reward_for_a_Carpenter.cc\n\n#include <iostream>\n#include <cstdio>\n#define Inf 1001001001\nusing namespace std;\n\nint main()\n{\n    int n,m,s,g,V,P,i,j,k,last;\n    int K[32][32];\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&m);\n    //cin >> n >> m;\n    int a[110],b[110],c[110],d[110];\n    for(i=1;i<32;i++)\n        for(j=1;j<=32;j++)\n            K[i][j]=Inf;\n    for(i=0;i<m;i++)\n    {\n        scanf(\"%d,%d,%d,%d\",&a[i],&b[i],&c[i],&d[i]);\n        //cin >> a[i] >> b[i] >> c[i] >> d[i];\n        K[a[i]][b[i]]=c[i];\n        K[b[i]][a[i]]=d[i];\n    }\n    //cin >> s >> g >> V >> P;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&V,&P);\n    for(k=1;k<=n;k++)\n        for(i=1;i<=n;i++)\n            for(j=1;j<=n;j++)\n            {\n                if(K[i][j] > K[i][k] + K[k][j])\n                    K[i][j] = K[i][k] + K[k][j];\n            }\n    last = V - P - K[s][g] - K[g][s];\n    cout << last << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX 21\n#define INF 9999999\n\nint grapha[MAX][MAX],v[MAX],mini,minnum,n;\nbool visited[MAX];\n\nint dijkstra(int x1, int x2){\n  for(int i = 0 ; i < MAX ; i++){\n    v[i] = INF;\n    visited[i] = false;\n  }\n\n  v[x1] = 0;\n\n  while(true){\n    mini = INF;\n    for(int i = 1 ; i <= n ; i++){\n      if(v[i] < mini && !visited[i]){\n\tmini = v[i];\n\tminnum = i;\n      }\n    } \n    if(mini == INF) break;\n    visited[minnum] = true;\n    for(int j = 1 ; j <= n ; j++){\n      if(grapha[minnum][j]+v[minnum] < v[j] && grapha[minnum][j]!=INF){\n\tv[j] = v[minnum] + grapha[minnum][j];\n      }\n    }\n  }\n  return v[x2];\n}\n\nint main(){\n  int m,a,b,c,d,x1,x2,y1,y2,v[MAX];\n\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      grapha[i][j] = INF;\n    }\n    visited[i] = false;\n    v[i] = INF;\n  }\n\n  cin >> n >> m;\n  for(int i = 0 ; i < m ; i++){\n    scanf(\"%d,%d,%d,%d\" ,&a ,&b ,&c ,&d);\n    grapha[a][b] = c;\n    grapha[b][a] = d; \n  }\n\n  scanf(\"%d,%d,%d,%d\" ,&x1, &x2 ,&y1 ,&y2);\n  cout << y1-y2-(dijkstra(x1,x2)+dijkstra(x2,x1)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\naccept?????????\n30?????????????????£???\n\n??????????????????????????????????§£???????????£?????????\n??????????????????????????????????§£???????????£????????§\n??????????????????????§£????????????????????¨????????????\n\nFloyd-Warshall????????¨??????\n#endif\n\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf=1001001001;\n\nint main() {\n  long long pay,ans;\n  for(int i=0;i<32;i++)\n    for(int j=0;j<32;j++)\n      K[i][j]=inf;\n\n  scanf(\"%d%d\", &N, &M);\n  for (int i=0; i<M; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    //cerr << \"read \" << A <<\" \"<< B <<\" \" << C <<\" \" << D<< endl;\n    //?????????\n    K[A][B]=C; // A ??? B ????????????C\n    K[B][A]=D;// B ??? A ????????????D    \n  }\n  /*\n  for(int i=1;i<N+1;i++){//?????§?????????\n    for(int j=1;j<N+1;j++){\n      if(K[i][j]==inf){\n\tcout<<\"i\"<<\" \";\n      }else{\n\tcout<<K[i][j]<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n  */\n  for(int k=1;k<N+1;k++){\n    for(int i=1;i<N+1;i++){\n      for(int j=1;j<N+1;j++){\n\tif(K[i][j]>K[i][k]+K[k][j]){\n\t  K[i][j]=K[i][k]+K[k][j];\n\t}\n      }\n    }/*\n    for(int l=1;l<N+1;l++){//?????§??????2???\n    for(int m=1;m<N+1;m++){\n      if(K[l][m]==inf){\n\tcout<<\"i\"<<\" \";\n      }else{\n\tcout<<K[l][m]<<\" \";\n      }\n    }\n    cout<<endl;\n    } \n    cout<<endl;*/\n  }\n  scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n  pay=K[A][B]+K[B][A];\n  ans=C-D-pay;\n  cout<<ans<<endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m,d[21][21],s,g,pr,pi;\nconst int INF=9999999;\nchar com;\nstruct road{int a,b,c,d;};\nroad r[400];\n\nint main() {\n    cin>>n>>m;\n    for(int i=0;i<m;i++)cin>>r[i].a>>com>>r[i].b>>com>>r[i].c>>com>>r[i].d;\n    cin>>s>>com>>g>>com>>pr>>com>>pi;\n    for(int i=0;i<441;i++)d[i/21][i%21]=INF;\n    for(int i=0;i<m;i++){\n\td[r[i].a][r[i].b]=r[i].c;\n\td[r[i].b][r[i].a]=r[i].d;\n    }\n    for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<pr-pi-d[s][g]-d[g][s]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint main(){\n    int n,m;\n    int cost[30][30];\n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        rep(i,30)rep(j,30)cost[i][j]=999999999;\n        rep(i,m){\n            int a,b,c,d;\n            char ch;\n            cin>>a>>ch>>b>>ch>>c>>ch>>d;\n            a--,b--;\n            cost[a][b] = c;\n            cost[b][a] = d;\n        }\n        rep(l,n){\n            rep(i,n){\n                rep(j,n){\n                    cost[i][j]=min(cost[i][j],cost[i][l]+cost[l][j]);\n                }\n            }\n        }\n        int a,b,c,d;\n        char ch;\n        cin>>a>>ch>>b>>ch>>c>>ch>>d;\n        a--,b--;\n        int sum=cost[a][b]+cost[b][a];\n        cout<<c-d-sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1234567;\nconst ll INF=1000000010;\nconst ll LINF=1000000000000000010LL;\nconst int MAX=10000010;\nconst double EPS=1e-3;\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\nstruct edge{int to,cost;};\nvector<edge> G[30];\nint d[30];\nvoid dijkstra(int s){\n\tfill(d,d+25,INF);\n\tpriority_queue<P,vector<P>,greater<P>> q;\n\tq.push(P(0,s));\n\td[s]=0;\n\twhile(!q.empty()){\n\t\tP p=q.top();\n\t\tint v=p.second;\n\t\tq.pop();\n\t\tfor(auto e:G[v]){\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint n,m;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c,d;scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tG[a].push_back({b,c});\n\t\tG[b].push_back({a,d});\n\t}\n\tint s,g,v,p;\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);s--;g--;\n\tint ans=v-p;\n\tdijkstra(s);\n\tans-=d[g];\n\tdijkstra(g);\n\tans-=d[s];\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 25\n#define INF 1<<21\n\nint d[MAX_V][MAX_V];\t//d[u][v]テ」ツ?ッティツセツコe=(u,v)テ」ツ?ョテ」ツつウテ」ツつケテ」ツδ?テ・ツュツ佚・ツ慊ィテ」ツ?療」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッINFテ」ツ??」ツ?淌」ツ??」ツ?妖[i][i]=0テ」ツ?ィテ」ツ?凖」ツつ?\nint n, m;\t//テゥツ?づァツつケテヲツ閉ー\n\nvoid warshall_floyd(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nint main(){\n\tfor(int i = 0; i < MAX_V; i++){\n\t\tfor(int j = 0; j < MAX_V; j++){\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\n\n\tcin >> n >> m;\n\tchar c;\n\tfor(int i = 0; i < m; i++){\n\t\tint a1, b1, c1, d1;\n\t\tcin >> a1 >> c >> b1 >> c >> c1 >> c >> d1;\n\t\td[a1-1][b1-1] = c1;\n\t\td[b1-1][a1-1]\t= d1;\t\n\t}\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> c >> x2 >> c >> y1 >> c >> y2;\n\t\n\twarshall_floyd();\n\tcout << y1 - y2 - d[x1-1][x2-1] - d[x2-1][x1-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tint D[32][32]={{0}};/*Adjacency matrix*/\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tD[a-1][b-1] = c;\n\t\tD[b-1][a-1] = d;\n\t}\n\tint ans = 0;\n\tint go,back,y1,y2;\n\tscanf(\"%d,%d,%d,%d\",&go,&back,&y1,&y2);\n\tans = y1-y2;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j)continue;\n\t\t\tif(D[i][j] == 0)D[i][j] = INF;\n\t\t}\n\t}\n\t\n\tint cost = 0;\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcost = D[go-1][back-1] + D[back-1][go-1];\n\t\n\tprintf(\"%d\\n\",ans-cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define M(a,b) (a<b?a:b)\n#define F(i,n) for(int i=0;i<n;i++)\nint n,m,a,b,c,d,e[20][20];int main(){memset(e,31,1600);scanf(\"%d%d\",&n,&m);F(i,m){scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--;b--;e[a][b]=c;e[b][a]=d;}scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--;b--;F(k,n)F(i,n)F(j,n) e[i][j] = M(e[i][j],e[i][k]+e[k][j]);printf(\"%d\\n\",c-d-e[a][b]-e[b][a]);return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nusing ll = long long;\nconst int INF = 10010;\n\nint n, m, s, g, V, P;\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    vector<vector<int>> K(n, vector<int>(n, INF));\n    rep(i, m)\n    {\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        K[a - 1][b - 1] = c;\n        K[b - 1][a - 1] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    rep(k, n) rep(i, n) rep(j, n)\n    {\n        if (K[i][j] > K[i][k] + K[k][j])\n            K[i][j] = K[i][k] + K[k][j];\n    }\n    int ans;\n    ans = V - P - K[s - 1][g - 1] - K[g - 1][s - 1];\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<ll,ll> P;\ntypedef pair<P,P> PP;\nint main(void){\n\tll i,j,k;\n\tll n,m,s,g,b,e,pp,kou;\n\tll ri[21][21];\n\tll leng[21],v[21];\n\tll min;\n\t\n\tPP p[100];\n\t\n\tcin>>n>>m;\n\tfor(i=0;i<m;i++) scanf(\"%lld,%lld,%lld,%lld\",&p[i].ff,&p[i].fs,&p[i].ss,&p[i].sf);\n\tscanf(\"%lld,%lld,%lld,%lld\",&s,&g,&b,&e);\n\t\n\t//隣接行列\n\tsort(p,p+m);\n\tfor(i=0;i<=n;i++) for(j=0;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[p[i].ff][p[i].fs]=p[i].sf,ri[p[i].fs][p[i].ff]=p[i].ss;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[s]=0;\n\t\n\tkou=0;\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[g];\n//\tcout<<leng[g]<<endl;\n\t\n\t//初期化\n\tfor(k=0;k<=n;k++)leng[k]=M,v[k]=0;\n\tleng[g]=0;\n\t\n\t//ダイクストラ法\n\tfor(j=1;j<=n;j++){\n\t\tmin=M;\n\t\tfor(k=1;k<=n;k++) if(v[k]==0&&leng[k]<min) pp=k,min=leng[k];\n\t\tv[pp]=1;\n\t\t\n\t\tif(min==M)break;\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tif((leng[pp]+ri[pp][k])<leng[k]) leng[k]=leng[pp]+ri[pp][k];\n\t\t}\n\t}\n\tkou+=leng[s];\n//\tcout<<leng[s]<<endl;\n\t\n\tcout<<b-e-kou<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nvector<vector <int>> G;\n\nvoid create_edge(int a, int b, int c, int d);\nint search(int st, int go);\n\n\nint main(){\n\n  int n,m;\n  int start;\n  int goal;\n  int money;\n  int pay;\n  int g_money,b_money;\n  int sarary;\n  \n    \n  cin >> n;\n  cin >> m;\n  //cout << \"ihjiwohjwi\" << endl;\n  \n  G = vector <vector<int>>(20,vector<int>(20,1001));\n  \n  // cout << \"1\" << endl;\n\n  for(int i = 0; m>i; ++i){\n    int a,b,c,d;\n    \n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    create_edge(a,b,c,d);\n  }\n\n  //cout << \"2\" << endl;\n\n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&pay);\n  \n  // cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n\n  g_money = search(start, goal);\n  b_money = search(goal, start);\n  \n  sarary = money - (g_money + b_money + pay);\n  \n  //cout << \"money :\" << money << endl;\n  //cout << \"pay :\" << pay << endl;\n  //cout << \"koutuuhi :\" << g_money + b_money << endl;\n \n  cout << sarary << endl;\n  \n  \n}\n\n\n\nvoid create_edge(int a, int b, int c, int d){\n\n  G[a][b] = c;\n  G[b][a] = d;\n\n}\n\n\n\nint search(int st, int go){\n\n  int current;\n  \n  typedef pair < int, int > PII;\n  vector <int>  cost(100, 1001);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  cout << \"search\" << endl;\n  que.push(PII(0,st));\n  cost[st] = 0;\n  \n  \n  while(!que.empty()){\n    current = que.top().second;\n    que.pop();\n\n    for(int k=0; k<20; k++){\n      int temp;\n      temp = G[current][k] + cost[current];\n\n      if(G[current][k] != 1001 && temp < cost[k]){\n\tque.push(PII(temp,k));\n\tcost[k] = temp;\n      }\n    }  \t\t \n  }\n  \n  return cost[go];\n}\n      \n  \n\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_C = 100;\nconst int INF = (1<<30);\n\nint edge[MAX_C][MAX_C];\nint cost[MAX_C];\nint come[MAX_C];\n\nint n,m;\n\nint solve(int start ,int fin){\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n  for(int i = n+1; i < MAX_C; i++) come[i] =1;\n  fill(cost,cost+MAX_C,INF);\n  queue <int> Q;\n  cost[start]= 0;\n\n  while(1){\n    int minPos=-1,minCos = INF;\n\n    for(int i = 0; i < MAX_C; i++){\n      if(!come[i]){\n\tif(minCos > cost[i]){\n\t  minCos = cost[i];\n \t  minPos = i;\n\t}\n      }\n    }\n    if(minPos == -1) break;\n    come[minPos] = 1;\n\n    for(int i = 1; i < MAX_C; i++){\n      if(edge[minPos][i]) Q.push(i);\n    }\n\n    while(!Q.empty()){\n      int now = Q.front();\n      Q.pop();\n      cost[now] = min(cost[now],cost[minPos] + edge[minPos][now]);\n    }\n  } \n  return cost[fin];\n}\n\nvoid init(){\n  for(int i = 0; i < MAX_C; i++) fill(edge[i],edge[i]+MAX_C,0);\n  fill(cost,cost+MAX_C,INF);\n  fill(come,come+MAX_C,0);\n  come[0] = 1;\n}\n\nint main(){\n  char trash;\n  while(cin >> n && n){\n    init();\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int from,to,cft,ctf;\n      cin >> from >> trash >> to >> trash >> cft >> trash>> ctf;\n      edge[from][to] = cft;\n      edge[to][from] = ctf;\n    }\n    int start,fin,mon,cos;\n    cin >> start >>trash >> fin >> trash >> mon >> trash >> cos;\n    cout << mon - cos - solve(start,fin) - solve(fin,start) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22][2];\nbool road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n\tif(money<0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(road[now][i])ans=max(ans,serch(start,finish,money-place[now][i][0],go,i));\n\tfor(int i=1;i<=n;i++)if(road[i][now])ans=max(ans,serch(start,finish,money-place[i][now][1],go,i));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tchar a;\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tfor(int j=0;j<2;j++)place[num[0]][num[1]][j]=num[2+j];\n\t\troad[num[0]][num[1]]=1;\n\t}\n\tint get[4];\n\tchar a;\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit(){\n  return S[cur++]-'0';\n}\n\nint number(){\n  int n=digit();\n  while(cur<S.size()&&isdigit(S[cur])){\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor(){\n  if(isdigit(S[cur]))return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint term(){\n  int t=factor();\n  for(;cur<S.size()&&(S[cur]=='*'||S[cur]=='/');){\n    if(S[cur++]=='*')t*=factor();\n\telse t/=factor();\n  }\n  return t;\n}\n\nint expression(){\n  int t=term();\n  for(;cur<S.size()&&(S[cur]=='+'||S[cur]=='-');){\n    if(S[cur++]=='+')t+=term();\n\telse t-=term();\n  }\n  return t;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  for(;n--;){\n    cur=0;\n    cin>>S;\n\tcout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint city[21][21],n,load[21][21];\nint power(int n)\n{\n    int num=1;\n    for(int i=0;i<n;i++)num*=10;\n    return num;\n}\nint aserch(int endp,int now,int befor)\n{\n    int money=50000;\n    if(city[now][endp]!=-1)return city[now][endp];\n    else{\n        for(int i=1;i<=n;i++){\n                if(city[now][i]!=-1&&i!=befor&&load[now][i]!=10){\n                    load[now][i]++;\n                    money=min(aserch(endp,i,now)+city[now][i],money);\n                }\n        }\n    }\n    return money;\n}\nint bserch(int stap,int now,int befor)\n{\n    int money=50000,num;\n    if(city[now][stap]!=-1){\n        return city[now][stap];\n    }\n    else{\n        for(int i=1;i<=n;i++){\n            if(city[now][i]!=-1&&i!=befor,load[now][i]!=20){\n                    load[now][i]++;\n                   num=bserch(stap,i,now)+city[now][i];\n                   if(num>-1)money=min(num,money);\n            }\n        }\n    }\n    return money;\n\n}\nint main()\n{\n    int m;\n    cin>>n>>m;\n    memset(city,-1,sizeof(city));\n    memset(load,0,sizeof(load));\n    string str;\n    for(int i=0;i<m;i++){\n        int kawa[2]={};\n        cin>>str;\n        for(int j=0,co=0,point=0;;j++){\n            if(str[j]==','||str[j]=='\\0'){\n                int mo=0;\n                if(co<2){\n                    for(int k=point;k<j;k++)kawa[co]+=(str[k]-'0')*power(j-k-1);\n                    point=j+1;\n                    co++;\n                }\n                else if(co==2){\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[0]][kawa[1]]=mo;\n                    point=j+1;\n                    co++;\n                }\n                else{\n                    for(int k=point;k<j;k++)mo+=(str[k]-'0')*power(j-k-1);\n                    city[kawa[1]][kawa[0]]=mo;\n                    break;\n                }\n            }\n        }\n    }\n    cin>>str;\n    int pointing[3]={},Pillar=0;\n    for(int i=0,co=0,point=0;;i++){\n        if(str[i]==','){\n            for(int j=point;j<i;j++)pointing[co]+=(str[j]-'0')*power(i-j-1);\n            point=i+1;\n            co++;\n        }\n        if(str[i]=='\\0'){\n            for(int j=point;j<i;j++)Pillar+=(str[j]-'0')*power(i-j-1);\n            break;\n        }\n    }\n    m=pointing[2]-Pillar-aserch(pointing[1],pointing[0],0);\n    memset(load,0,sizeof(load));\n    cout<<m-bserch(pointing[0],pointing[1],0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint main() {\n long long d[21][21],y1,y2,c1,d1;\n int i,j,k,m,n,a1,b1,x1,x2;\n cin >> n;\n for (i=1;i<=n;i++) for (j=1;j<=n;j++) if (i==j) d[i][j]=0; else d[i][j]=99999999999999;\n cin >> m;\n for (i=0;i<m;i++) {\n\t scanf(\"%d,%d,%lld,%lld\",&a1,&b1,&c1,&d1);\n     d[a1][b1]=c1; d[b1][a1]=d1;\n }\n scanf(\"%d,%d,%lld,%lld\",&x1,&x2,&y1,&y2);\n for (k=1;k<=n;k++) for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n cout << y1-y2-d[x1][x2]-d[x2][x1] << endl;\n return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int inf = 1001001001;\nint n, m, a, b, c, d, s, g, v, p;\nint K[32][32] = {};\n\nvoid show()\n{\n    for (int i = 1; i < n + 1; i++)\n    {\n        for (int j = 1; j < n + 1; j++)\n        {\n            cout << K[i][j];\n            if (j != n)\n            {\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < 32; i++)\n    {\n        for (int j = 0; j < 32; j++)\n        {\n            K[i][j] = inf;\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        //cerr << \"read \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n        K[a][b] = c;\n        K[b][a] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n    // show();\n    for (int k = 1; k < n + 1; k++)\n    {\n        for (int i = 1; i < n + 1; i++)\n        {\n            for (int j = 1; j < n + 1; j++)\n            {\n                if (K[i][j] > K[i][k] + K[k][j])\n                {\n                    K[i][j] = K[i][k] + K[k][j];\n                }\n            }\n        }\n    }\n    //show();\n    //cout << K[s][g] << K[g][s] << endl;\n    cout << v - p - K[s][g] - K[g][s] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tint n,m,a,b,c,d,x1,x2,y1,y2;\n\tchar ch;\n\tcin >> n >> m;\n\tvector< vector<int> > road(n+1,vector<int>(n+1,100001));\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\troad[a][b] = c;\n\t\troad[b][a] = d;\n\t}\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (road[i][k] != 100001 && road[k][j] != 100001)\n\t\t\t\t\tif(road[i][j] > road[i][k] + road[k][j]) road[i][j] = road[i][k] + road[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tcin >> x1 >> ch >> x2 >> ch >> y1 >> ch >> y2;\n\tcout << y1 - y2 - road[x1][x2] - road[x2][x1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<vector<P>> E;//to cost\n\nint djk(int s, int e) {\n\tint d[20];\n\tfor (int i = 0; i < m; i++)d[i] = 2000000000;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\td[s] = 0;\n\tpq.emplace(0, s);\n\twhile (pq.size()) {\n\t\tP tmp = pq.top(); pq.pop();\n\t\tint t = tmp.second;\n\t\tif (d[t] < tmp.first)continue;\n\t\tfor (int i = 0; i < E[t].size(); i++) {\n\t\t\tP T = E[t][i];\n\t\t\tif (T.first > d[t] + T.second) {\n\t\t\t\td[T.first] = d[t] + T.second;\n\t\t\t\tpq.emplace(d[E[t][i].first], E[t][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[e];\n}\n\nint main() {\n\tcin >> n >> m;\n\tE.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tchar ch;\n\t\tint a, b, c, d;\n\t\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\t\ta--, b--;\n\t\tE[a].push_back(make_pair(b, c));\n\t\tE[b].push_back(make_pair(a, d));\n\t}\n\tint a, b, c, d;\n\tchar ch;\n\tcin >> a >> ch >> b >> ch >> c >> ch >> d;\n\ta--, b--;\n\tcout << c - d - djk(a, b) - djk(b, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint di[21][21], n, m, s, e, i, j, mi, a, b, c, d, p, in, ha;\n\nint dic(int start, int goal) {\n  int min, mi = start, cost[200], f[21] = {0};\n  for(i = 0; i < 200; i++) cost[i] = 100000000;\n  cost[mi] = 0;//テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツつ津ッツシツ静」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n\n  for(i = 0; i < n; i++) {\n    f[mi] = 1;\n    for(j = 1; j <= n; j++) {\n      if(f[j]) continue;\n      if(cost[j] > cost[mi] + di[mi][j]) cost[j] = cost[mi] + di[mi][j];\n    }\n    \n    min = 200000000;\n    for(j = 1; j <= n; j++) {\n      if(f[j]) continue;\n      if(min > cost[j]) min = cost[mi = j];\n    }\n  }\n  return cost[goal];\n}\n\n\nint main(){\n \n  for(i = 0; i < 20; i++) {\n    for(j = 0; j < 20; j++) di[i][j] = 100000000;\n  }\n  \n  scanf(\"%d%d\", &n, &m);\n  while(m--) {\n    scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n    di[a][b] = c;\n    di[b][a] = d;\n  }\n  scanf(\"%d,%d,%d,%d\", &s, &p, &in, &ha);\n  cout << in - dic(s, p) - dic(p, s) - ha << endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\n#define MAX 987654321\n\nusing namespace std;\n\nint dijkstra (vector <vector <int> > M, int curr, int target )\n{\n\tint size = M.size();\n\n\tvector <bool> v(size, false );\n\tvector <int> len (size, MAX );\n\tvector <int> path (size, 0 );\n\n\tlen[curr] = 0;\n\tpath[curr] = -1;\n\n\tint minlen;\n\tint i,p;\n\n\tdo{\n\t\tminlen = MAX;\n\t\t\n\t\tfor (i = 0; i < size; ++i){\n\t\t\tif (!v[i] && len[i] < minlen ){\n\t\t\t\tminlen = len[i];\n\t\t\t\tp = i;\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tv[p] = true;\n\n\t\tfor (i = 0; i < size; ++i){\n\t\t\tif (M[p][i] + len[p] < len[i] ){\n\t\t\t\tlen[i] = M[p][i] + len[p];\n\t\t\t\tpath[i] = p;\n\t\t\t} // end if\n\t\t} // end for\n\t}while (minlen != MAX );\n\n\treturn len[target];\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.reward\", \"r\", stdin);\n\tstring str = \"\";\n\tint n;\t\t\t// XÌ\n\tint m;\t\t\t// X¹Ì\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\tgetline (cin, str );\n\tstringstream ssm(str);\n\tssm >> m;\n\n\tint i;\n\tvector <vector <int> > M (n+1, vector <int> (n+1, MAX ) );\n\n\n\tfor (i = 0; i < m; ++i){\n\t\tgetline (cin, str );\n\n\t\twhile (str.find(',') != string::npos ){\n\t\t\tstr = str.replace(str.find(','), 1, \" \");\n\t\t} // end while\n\t\tint from, to, costf, costr;\n\t\tstringstream ss(str);\n\n\t\tss >> from >> to >> costf >> costr;\n\t\tM[from][to] = costf; M[to][from] = costr;\n\n\t} // end for\n\n\tgetline (cin, str );\n\twhile (str.find(',') != string::npos ){\n\t\tstr = str.replace(str.find(','), 1, \" \");\n\t} // end while\n\tstringstream ss (str );\t\n\n\tint curr, target, money, tree;\n\n\tss >> curr >> target >> money >> tree;\n\n\tint going = 0;\n\tint comeback = 0;\n\n\tgoing = dijkstra (M, curr, target );\n\tcomeback = dijkstra (M, target, curr );\n\t\n\tint res = money - tree - going - comeback;\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<Edge> > edges(n);\n    for(int i=0; i<m; ++i){\n        int a, b, c, d;\n        char z;\n        cin >> a >> z >> b >> z >> c >> z >> d;\n        edges[a-1].push_back(Edge(b-1, c));\n        edges[b-1].push_back(Edge(a-1, d));\n    }\n\n    int x1, x2, y1, y2;\n    char z;\n    cin >> x1 >> z >> x2 >> z >> y1 >> z >> y2;\n\n    vector<int> dist1, dist2;\n    shortestPath(edges, x1-1, dist1);\n    shortestPath(edges, x2-1, dist2);\n\n    int ret = y1 - y2 - dist1[x2-1] - dist2[x1-1];\n    cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define size 32\nusing namespace std;\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint cost;\nint K[size][size];\nconst int inf = 1001001001;\n\nint main(){\n\tfor(int i=1; i<size ; i++){\n\t\tfor(int j=1 ; j<size ; j++){\n\t\t\tK[i][j]=inf;\n\t\t}\n\t}// 行列初期化\n\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0; i< M ;++i){\n\tscanf(\"%d,%d,%d,%d\",&A,&B,&C,&D);\n\tK[A][B]=C;\n\tK[B][A]=D;\n\t}//初期化完了\n\n\n\tfor(int k=1 ; k<N+1 ; k++){\n\t\tfor(int i=1 ; i<N+1; i++){\n\t\t\tfor(int j=1 ; j<N+1; j++){\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]){\n\t\t\t\t\tK[i][j] = K[i][k]+K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}//i-j間最短路のコスト計算\n\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tcost= y1-y2-K[x1][x2]-K[x2][x1];\n\tcout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[21][21];\nint road[21][21];\nint co[21][21];\nint maxnum[21];\nint serch(int start,int finish,int money,int go,int now,int before)\n{\n    if(money<0)return 0;\n    if(go==1&&start==now)return money;\n    if(finish==now)go=1;\n    int ans=0;\n    for(int i=1;i<=maxnum[now];i++){\n        if(place[now][i]>-1&&i!=before){\n            co[now][i]++;\n            if(co[now][i]>5)return 0;\n            ans=max(ans,serch(start,finish,money-place[now][i],go,i,now));\n            co[now][i]--;\n        }\n    }\n    return ans;\n}\nint main() {\n    cin>>n>>m;\n    char a;\n    memset(place,-1,sizeof(place));\n    for(int i=0,num[4];i<m;i++){\n        for(int j=0;j<3;j++)cin>>num[j]>>a;\n        cin>>num[3];\n        place[num[0]][num[1]]=num[2];\n        place[num[1]][num[0]]=num[3];\n        maxnum[num[0]]=max(maxnum[num[0]],num[1]);\n\t    maxnum[num[1]]=max(maxnum[num[0]],num[0]);\n    }\n    int get[4];\n    for(int i=0;i<3;i++)cin>>get[i]>>a;\n    cin>>get[3];\n    cout<<serch(get[0],get[1],get[2]-get[3],0,get[0],get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10000000\n\nusing namespace std;\n\nint cost[21][21];\nint m,n;\n\nvoid W(){\n\n  for(int k = 0 ; k < n ; k++ ){\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = 0 ; j < n ; j++ ){\n\tcost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n      }\n    }\n  }\n\n}\n\nint main(){\n\n  cin >> n >> m;\n  n++;\n\n      for(int i = 0 ; i < n ; i++ ){\n\tfor(int j = 0 ; j < n ; j++ ){\n\t  if(i == j )cost[i][j] = 0;\n\t  else cost[i][j] = INF;\n\t}\n      }\n\n  char ch;\n\n  for(int i = 0 ; i < m ; i++ ){\n    int a,b,c,d;\n\n    cin >> a >> ch >> b >> ch >> c >> ch >> d;\n    cost[a][b] = c;\n    cost[b][a] = d;\n\n  }\n\n  int s,g,mone,hasira;\n  cin >> s >> ch >> g >> ch >> mone >> ch >> hasira;\n\n  W();\n\n  int go = cost[s][g];\n  int back = cost[g][s];\n\n  cout << mone - (go+back+hasira) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INF = 987654321;\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nll G[20][20];\nll dp[20][20];\nint V;\n\nvoid warshall_floyd() {\n    rep(k, V) rep(i, V) rep(j, V) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n}\n\n\nint main() {\n    int n; cin >> n;\n    int m; cin >> m;\n    char comma;\n    rep(i, m) {\n        int a, b, c, d; cin >> a >> comma >> b >> comma >> c >> comma >> d;\n        G[a - 1][b - 1] = c;\n        G[b - 1][a - 1] = d;\n    }\n    ll x1, x2, y1, y2; cin >> x1 >> comma >> x2 >> comma >> y1 >> comma >> y2;\n\n    V = n;\n    rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) if (G[i][j] != 0) dp[i][j] = G[i][j];\n\n    warshall_floyd();\n    cout << y1 - dp[x1 - 1][x2 - 1] - dp[x2 - 1][x1 - 1] - y2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 20\n#define M 10000\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\nusing namespace std;\n\nint data[N][N];\nvoid init(){\n  rep(i,N){\n    rep(j,N){\n      if(i==j)data[i][j] = 0;\n      else data[i][j] = M;\n    }\n  }\n}\n\nvoid input(int *a,int *b,int *c,int *d){\n  char dm;\n  cin >> *a >> dm >> *b >> dm >> *c >> dm >> *d;\n  --*a;\n  --*b;\n}\nint main(void){  \n  int n,m;\n  int a,b,c,d;\n  int x1,x2,y1,y2;\n  char dm;\n  init();\n  cin>>n>>m;\n  \n  rep(i,m){\n    input(&a,&b,&c,&d);\n    data[a][b] = c;\n    data[b][a] = d;\n  }\n   \n  rep(k,n)\n    rep(i,n)\n      rep(j,n)\n        data[i][j] = min(data[i][j],data[i][k] + data[k][j]);\n  \n  input(&x1,&x2,&y1,&y2);\n   \n \n  cout << (y1 - (y2 + data[x1][x2] + data[x2][x1])) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\n\n\nint main(){\n    int n,m;\n    int a[20][20];\n    cin>>n>>m;\n    fill(&a[0][0],&a[20][20],INT_MAX/2);\n    for(int i=0;i<m;i++){\n        int b,c,d,e;\n        scanf(\"%d%d%d%d\",&b,&c,&d,&e);\n        a[b][c]=d;\n        a[c][b]=e;\n    }\n    int s,g,gold,p;\n    scanf(\"%d%d%d%d\",&s,&g,&gold,&p);\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                if(a[i][t]>a[i][k]+a[k][t]){a[i][t]=a[i][k]+a[k][t];}\n            }\n        }\n    }\n    cout<<gold-p-a[s][g];\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (ll)n; i++)\n#define rep1(i, n) for (ll i = 1; i <= (ll)n; i++)\n#define PI 3.14159265358979323846\n#define vll vector<long long>\n#define vvll vector<vector<long long>>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\n// ----本問について----\n// 問題：大工の褒美\n// 問題文URL：https://onlinejudge.u-aizu.ac.jp/problems/0117\n// 所要時間：\n// 学んだこと：\n// ------------------\n\n// ----ここから本問のソースコード----\nconst ll INF = 1001001001;\n\n// グローバル変数（入力）\nll n, s, g, V, P, K[32][32];\n\nvoid initK() {\n  rep(i, 32) {\n    rep(j, 32) { K[i][j] = INF; }\n  }\n}\n\n// 入力\nvoid input() {\n  ll m;\n  scanf(\"%lld%lld\", &n, &m);\n  initK();\n  rep(i, m) {\n    ll a, b, c, d;\n    scanf(\"%lld,%lld,%lld,%lld\", &a, &b, &c, &d);\n    K[a][b] = c;\n    K[b][a] = d;\n  }\n  scanf(\"%lld,%lld,%lld,%lld\", &s, &g, &V, &P);\n}\n\nvoid solve() {\n  // ワーシャルフロイド\n  rep1(k, n) {\n    rep1(i, n) {\n      rep1(j, n) { K[i][j] = min(K[i][j], K[i][k] + K[k][j]); }\n    }\n  }\n\n  cout << V - P - K[s][g] - K[g][s] << endl;\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint K[20][20];\nint n,m,a,b,c,d;\nint Floyd(int K[20][20],int n) {\n\tfor(int k=0; k<n; ++k) {\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(K[i][j] > K[i][k] + K[k][j]) {\n\t\t\t\t\tK[i][j] = K[i][k] + K[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\\n\",&n);\n\tscanf(\"%d\\n\",&m);\n\tcout << n << \" \" << m << endl;\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<n; ++j) {\n\t\t\tK[i][j] = 100000;\n\t\t}\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tscanf(\"%d,%d,%d,%d\\n\",&a,&b,&c,&d);\n\t\tK[a-1][b-1] = c;\n\t\tK[b-1][a-1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\tFloyd(K,n);\n\tcout << c-d-K[a-1][b-1]-K[b-1][a-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define max 100\n#define inf 100000000\nusing namespace std;\nint dijkustra(int s, int e);\nint n,m;\nint G[max][max];\n\n\nint main(){\n  int start,goal;\n  int a,b,c,d,money,pay,go,back;\n  cin >>n>>m;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++) G[i][j]=inf;}\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    a--;b--;\n    //  cout << \"hoge\\n\";\n    G[a][b]=c;\n    G[b][a]=d;\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&start,&goal,&money,&pay);\n\n  go = dijkustra(start-1,goal-1);\n  back = dijkustra(goal-1,start-1);\n \n cout <<money-pay-go-back<<endl; \n    return 0;\n}\n\nint dijkustra(int s,int g){\n  int mindist[max];\n  bool used[max];\n  int qur,value,next;\n\n  for(int i=0;i<n;i++){\n    mindist[i]=inf;\n    used[i]=false;\n  }\n\n  mindist[s]=0;\n\n  while(1){\n\n    /* for(int i=0;i<n;i++)\n      cout<<mindist[i]<<\" \";     \n      cout <<endl;*/\n\n\n    value=inf;\n    for(int i=0;i<n;i++){\n      if(value > mindist[i]  && used[i] == false){\n\tvalue=mindist[i];\n\tqur=i;}\n    }\n    //    cout <<value<<endl;\n    used[qur]=true;\n    if(value==inf)break;\n\n    for(int j=0;j<n;j++){\n      if(G[qur][j]!=inf){\n\tnext = j;\n\tif(mindist[next] > mindist[qur] + G[qur][next])\n\t  mindist[next] = mindist[qur] + G[qur][next];\n \t}\n    }\n\n  }\n  return mindist[g];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=1;i<=n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nstring str;\n\nint main()\n{\n  int i,j,k;\n  int n,m,a,b;\n  int s,g,v,p;\n  int cost[25][25]={};\n\n  cin>>n>>m;\n\n  rep(i,n)rep(j,n)cost[i][j]=INF;\n  rep(i,n)cost[i][i]=0;\n\n  rep(i,m){\n    scanf(\"%d,%d,\",&a,&b);\n    scanf(\"%d,%d\",&cost[a][b],&cost[b][a]);\n  }\n  scanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\n  rep(k,n)rep(i,n)rep(j,n)\n    cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  cout<<v-p-cost[s][g]-cost[g][s]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nint place[22][22][2];\nint road[22][22];\nint serch(int start,int finish,int money,int go,int now)\n{\n\tif(money<0)return 0;\n\tif(go==1&&start==now)return money;\n\tif(finish==now)go=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(road[now][i])ans=max(ans,serch(start,finish,money-place[now][i][0],go,i));\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tchar a;\n\tfor(int i=0,num[4];i<m;i++){\n\t\tfor(int j=0;j<3;j++)cin>>num[j]>>a;\n\t\tcin>>num[3];\n\t\tfor(int j=0;j<2;j++){\n\t\t    place[num[0]][num[1]][j]=num[2+j];\n\t\t    place[num[1]][num[0]][j]=num[3-j];\n\t\t    road[num[0+j]][num[1-j]]=1;\n\t\t}\n\t\t\n\t}\n\tint get[4];\n\tfor(int i=0;i<3;i++)cin>>get[i]>>a;\n\tcin>>get[3];\n\tcout<<serch(get[0],get[1],get[2]-get[3],0,get[0])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#define INF (1<<21)\nusing namespace std;\n\nclass State{\npublic:\n  int n,cost,f;\n  State(int n = 0,int cost = 0,int f = 0):n(n),cost(cost),f(f){}\n  bool operator < (const State &s) const{ return cost > s.cost;}\n};\n\nint main(){\n  int i,j,n,m,a,b,c,e,x1,x2,ans,y2,G[21][21];\n  State d[21];\n  priority_queue<State> PQ;\n  cin >> n >> m;\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++) G[i][j] = INF;\n\td[i].cost = INF;\n\td[i].n = i;\n\td[i].f = 0;\n  }\n\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&e);\n    G[a][b] = c;\n    G[b][a] = e;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&ans,&y2);\n  ans -= y2;\n\n  d[x1].cost = 0;\n  State p = d[x1];\n  PQ.push(p);\n  while(!PQ.empty()){\n    p = PQ.top();\n    PQ.pop();\n    d[p.n].f = 1;\n    \n    for(i=0;i<=n;i++){\n      if(d[i].f == 0 && G[p.n][i] + p.cost < d[i].cost){\n\td[i].cost = G[p.n][i] + p.cost;\n\tPQ.push(d[i]);\n      }\n    }\n  }\n  ans -= d[x2].cost;\n  \n  for(i=0;i<=n;i++){\n    d[i].cost = INF;\n    d[i].n = i;\n    d[i].f = 0;\n  }\n  \n  d[x2].cost = 0;\n  p = d[x2];\n  PQ.push(p);\n  while(!PQ.empty()){\n    p = PQ.top();\n    PQ.pop();\n    d[p.n].f = 1;\n    \n    for(i=0;i<=n;i++){\n      if(d[i].f == 0 && G[p.n][i] + p.cost < d[i].cost){\n\td[i].cost = G[p.n][i] + p.cost;\n\tPQ.push(d[i]);\n      }\n    }\n  }\n  ans -= d[x1].cost;\n  \n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n,go_min = 100000000,back_min = 100000000,Table[21][21];\n\nvoid func(int sum,int current,int goal,bool FLG,int checkTable[21]){\n\tif(current == goal){\n\t\tif(FLG){\n\t\t\tgo_min = min(go_min,sum);\n\t\t}else{\n\t\t\tback_min = min(back_min,sum);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=1; i <= n; i++){\n\t\tif(Table[current][i] != -1 && checkTable[i] == 0){\n\t\t\tint newCheckTable[21];\n\t\t\tfor(int k=0; k < 21; k++)newCheckTable[k] = checkTable[k];\n\t\t\tnewCheckTable[i] = 1;\n\t\t\tfunc(sum+Table[current][i],i,goal,FLG,newCheckTable);\n\t\t}\n\t}\n\n}\n\n\nint main(){\n\n\tint m,a,b,c,d,start,end,V,P,checkTable[21];\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0; i < 21; i++){\n\t\tcheckTable[i] = 0;\n\t\tfor(int k=0; k < 21; k++){\n\t\t\tTable[i][k] = -1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&m);\n\n\tfor(int i=0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tTable[a][b] = c;\n\t\tTable[b][a] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\",&start,&end,&V,&P);\n\n\tfunc(0,start,end,true,checkTable);\n\tfunc(0,end,start,false,checkTable);\n\n\tprintf(\"%d\\n\",V-(P+go_min+back_min));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define INF (1 << 25)\nusing namespace std;\n\nint n,m,cost[32][32],x1,x2,y1,y2;\n\nvoid init(){\n    for(int i=0;i<32;i++){\n        for(int j=0;j<32;j++) cost[i][j] = INF;\n    }\n}\n\nvoid add_info(){\n    int a,b,c,d;\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    cost[a][b] = c; cost[b][a] = d;\n}\n\nint main(){\n    cin >> n >> m;\n    init();\n    for(int i=0;i<m;i++) add_info();\n    scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=0;k<=n;k++){\n                cost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n            }\n        }\n    }\n    cout << y1-(cost[x1][x2]+cost[x2][x1]+y2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint n,m,t[21][21],u[21],v[21],a,b,c,d;\nint cost(int start,int goal){\n\tint mini,miniNo;\n\tfor(int i=0;i<21;i++){\n\t\tu[i]=INF;\n\t\tv[i]=0;\n\t}\n\tu[start]=0;\n\twhile(1){\n\t\tmini=INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(v[i]==0&&u[i]<mini){\n\t\t\t\tminiNo=i;\n\t\t\t\tmini=u[i];\n\t\t\t}\n\t\t}\n\t\tif(mini==INF)break;\n\t\tv[miniNo]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(u[i]>u[miniNo]+t[miniNo][i]){\n\t\t\t\tu[i]=u[miniNo]+t[miniNo][i];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn u[goal];\n}\nint main(){\n\tfor(int i=0;i<21;i++)for(int j=0;j<21;j++)t[i][j]=INF;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\t\tt[a][b]=c;t[b][a]=d;\n\t}\n\tcin>>a>>ch>>b>>ch>>c>>ch>>d;\n\tcout<<c-d-cost(a,b)-cost(b,a)<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std;\n#define INF 99\n\t\nint n, m, i, j, a, b, c, d, start, goal, money, hashira, minroot, tax[102][102] = {}, root[102] = {}, used[102] = {};\n\nint main() {\n\n\tcin >> n >> m;\n\t//?????????\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) tax[i][j] = INF;\n\t\ttax[i][i] = 0;\n\t\troot[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t//?????????????????¨?????\\???\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\ttax[a][b] = c;\n\t\ttax[b][a] = d;\n\t}\n\t//????????????,??´??????,????????????????????????,??±????????¨\n\tscanf(\"%d,%d,%d,%d\", &start, &goal, &money, &hashira);\n\n\tmoney -= hashira;\n\t//?????????????????????stert???goal\n\troot[start] = 0;\n\twhile (1) {\n\t\tminroot = INF;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (used[i] == 0 && root[i] < minroot) {\n\t\t\t\tminroot = root[i];\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\tif (j == goal) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tused[j] = 1;\n\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\tif (root[j] + tax[j][i] < root[i]) root[i] = root[j] + tax[j][i];\n\t\t\t}\n\t\t}\n\t}\n\t\t//???????????´??°\n\t\tmoney -= root[goal];\n\n\t\t//?????????\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\troot[i] = INF;\n\t\t\tused[i] = 0;\n\t\t}\n\t\t//?????????????????????goal???start\n\t\troot[goal] = 0;\n\t\twhile (1) {\n\t\t\tminroot = INF;\n\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\tif (used[i] == 0 && root[i] < minroot) {\n\t\t\t\t\tminroot = root[i];\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tused[j] = 1;\n\t\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\t\tif (root[j] + tax[j][i] < root[i]) root[i] = root[j] + tax[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tmoney -= root[start];\n\t\t\n\t\tcout << money << endl;\n\t\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int,int>pii;\nconst int INF=100000000;\nstruct edge{\n    int to,cost;\n    edge(int a,int b){\n        to=a;cost=b;\n    }\n    edge(){}\n};\nvector<vector<edge> >V;\n\nint dijkstra(int s,int g){\n    int d[100];\n    fill(d,d+100,INF);\n    d[s]=0;\n    priority_queue<pii>Q;\n    Q.push(pii(0,s));\n    while(!Q.empty()){\n        pii p=Q.top();Q.pop();\n        int n=p.second,cost=p.first;\n        if(d[n]<cost)continue;\n        d[n]=cost;\n        for(int i=0;i<V[n].size();i++){\n            edge e=V[n][i];\n            if(d[e.to]>d[n]+e.cost){\n                Q.push(pii(d[n]+e.cost,e.to));\n            }\n        }\n    }\n\n    return d[g];\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    V.resize(n);\n    for(int i=0;i<m;i++){\n        int a,b,ab,ba;\n        scanf(\"%d,%d,%d,%d\",&a,&b,&ab,&ba);\n        a--;b--;\n        V[a].push_back(edge(b,ab));\n        V[b].push_back(edge(a,ba));\n    }\n    int s,g,w,c;\n    scanf(\"%d,%d,%d,%d\",&s,&g,&w,&c);\n    s--;g--;\n    cout<<w-c-dijkstra(s,g)-dijkstra(g,s)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint N,M,A,B,C,D,x1,x2,y1,y2;\nint K[22][22];\nconst int inf = 1000;\n\nint main(){\n  for (int m=0; m < 32; m++){\n  for (int n=0; n < 32; n++){\n    K[m][n] = inf;\n\t}\n  }\n  scanf(\"%d%d\", &N,&M);\n  for (int i=0; i<=M-1; ++i) {\n    scanf(\"%d,%d,%d,%d\", &A,&B, &C, &D);\n\tK[A][B] = C;\n\tK[B][A] = D;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1,&x2, &y1, &y2);\n\t\n  for (int k=1; k <= N; k++){\n    for (int i=1; i <= N; i++){\n\t  for (int j=1; j <= N; j++){\n\t    if (K[i][j] > K[i][k] + K[k][j]){\n\t\t  K[i][j] = K[i][k] + K[k][j];\n\t\t  }\n\t\t}\n\t}\n  }\n  \nint money = y1 -y2 -K[x1][x2] - K[x2][x1];\ncerr << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define INF 1000000000\nint K[32][32];\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint main(void) {\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            K[i][j] = INF;\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n        K[A][B] = C;\n        K[B][A] = D;\n    }\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (K[i][j] > K[i][k] + K[k][j]) {\n                    K[i][j] = K[i][k] + K[k][j];\n                }\n            }\n        }\n    }\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n    cout << y1 - (K[x1][x2] + K[x2][x1]) - y2 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 9999999\nusing namespace std;\nchar ch;\nint MAP[21][21],mn,MN,a,b,c,d,n,m,w,x,y,z,v[21],u[21];\nint compute(int start,int goal){\n  for(int i=1;i<=n;i++)v[i]=u[i]=INF;\n  v[start]=0;\n  while(1){\n    mn=INF;\n    for(int i=1;i<=n;i++){\n      if(v[i]<mn&&u[i]==INF){\n\tmn=v[i];\n\tMN=i;\n      }\n    }\n    if(mn==INF)break;\n    u[MN]=0;\n    for(int i=1;i<=n;i++)if(MAP[MN][i]+v[MN]<v[i])v[i]=v[MN]+MAP[MN][i];\n  }\n  return v[goal]; \n}\nint main(){\n  cin>>n>>m;\n  \n  for(int i=1;i<=20;i++)for(int j=1;j<=20;j++)MAP[i][j]=INF;\n  for(int i=1;i<=m;i++){\n    cin>>a>>ch>>b>>ch>>c>>ch>>d;\n    MAP[a][b]=c;\n    MAP[b][a]=d;\n  }\n  for(int i=1;i<=20;i++){\n    for(int j=1;j<=20;j++)\n      cout<<MAP[i][j]<<' ';\n    cout<<endl;\n  }\n  cin>>w>>ch>>x>>ch>>y>>ch>>z;\n  cout<<y-z-compute(w,x)-compute(x,w)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint main(void)\n{\n\tint i,j,n,m,s,g,v,p,flg[101],ky[101],a,min,ri[21][21],sum;\n\tPP ga[101];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++) scanf(\"%d,%d,%d,%d\",&ga[i].ff,&ga[i].fs,&ga[i].sf,&ga[i].ss);\n\tsort(ga,ga+m);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) ri[i][j]=M;\n\t}\n\tfor(i=1;i<=m;i++) {\n\t\tri[ga[i].ff][ga[i].fs]=ga[i].sf;\n\t\tri[ga[i].fs][ga[i].ff]=ga[i].ss;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&v,&p);\n\t/*printf(\"\\n\");\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) printf(\"%d \",ri[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[s]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum=ky[g];\n\tfor(i=1;i<=n;i++) flg[i]=0,ky[i]=M;\n\tky[g]=0;\n\tfor(i=1;i<=n;i++){\n\t\tmin=M;\n\t\tfor(j=1;j<=n;j++) if(flg[j]==0&&min>ky[j]) a=j,min=ky[j];\n\t\tflg[a]=1;\n\t\tif(M==min) break;\n\t\tfor(j=1;j<=n;j++) if(ky[j]>ky[a]+ri[a][j]) ky[j]=ky[a]+ri[a][j];\n\t}\n\t/*for(i=1;i<=n;i++) printf(\"%d=%d \",i,ky[i]);\n\tprintf(\"\\n\");*/\n\tsum+=ky[s];\n\tprintf(\"%d\",v-sum-p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <map>\n#define number(node) edge_to[node][0]\n#define INFINITY 999999\nusing namespace std;\nint n, m, start[2], paid, pole, cost[2][20], edge_to[20][21], edge_cost[20][21];\n\nint comp_0(const void *a, const void *b)\n{\n    return cost[0][*(int*)a] - cost[0][*(int*)b];\n}\n\nint comp_1(const void *a, const void *b)\n{\n    return cost[1][*(int*)a] - cost[1][*(int*)b];\n}\n\nint main()\n{\n    int from, to, c1, c2;\n    fill((int *)edge_to, (int *)(edge_to + 20), 0);\n    fill((int *)edge_cost, (int *)(edge_cost + 20), 0);\n    fill((int *)cost, (int *)(cost + 2), INFINITY);\n    \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d,%d,%d,%d\", &from, &to, &c1, &c2);\n        edge_to[from][++number(from)] = to;\n        edge_cost[from][number(from)] = c1;\n        edge_to[to][++number(to)] = from;\n        edge_cost[to][number(to)] = c2;\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &start[0], &start[1], &paid, &pole);\n    for (int g = 0; g < 2; g++)\n    {\n        int unchecked[20], k = 0;\n        cost[g][start[g]] = 0;\n        for (int i = 1; i <= number(start[g]); i++)\n            cost[g][edge_to[start[g]][i]] = edge_cost[start[g]][i];\n        for (int i = 1; i <= n; i++)\n            if (i != start[g]) unchecked[k++] = i;\n\n        while (k > 0)\n        {\n            qsort(unchecked, k, sizeof(int), (g ? comp_1 : comp_0));\n            for (int i = 1; i <= number(unchecked[0]); i++)\n                if (cost[g][edge_to[unchecked[0]][i]] > cost[g][unchecked[0]] + edge_cost[unchecked[0]][i])\n                    cost[g][edge_to[unchecked[0]][i]] = cost[g][unchecked[0]] + edge_cost[unchecked[0]][i];\n            unchecked[0] = unchecked[--k];\n        }\n    }\n    \n    printf(\"%d,%d,%d,%d\\n\", paid , pole , cost[0][start[1]] , cost[1][start[0]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst long N=200000;\n\nint main(){\n\tint n, m;\n\tint ct[21][21];\n\t\n\tmemset(ct, -1, sizeof(ct));\n\t\n\tscanf(\" %d %d\", &n, &m);\n\tfor(int i=0; i<m; ++i){\n\t\tint a, b, c, d;\n\t\tscanf(\" %d,%d,%d,%d\", &a, &b, &c, &d);\t\n\t\tct[a][b]=c;\n\t\tct[b][a]=d;\n\t}\n\t\n\tint x1, x2;\n\tlong y1, y2;\n\tscanf(\" %d,%d,%ld,%ld\", &x1, &x2, &y1, &y2);\n\ty1-=y2;\n\t\n\tlong cost[21]; //各街までかかる最小の交通費\n\tfor(int i=0; i<=20; ++i) cost[i]=N;\n\t//行きのbfs\n\tqueue<int> que;\n\tcost[x1]=0;\n\tque.push(x1);\n\twhile( !que.empty() ){\n\t\tint v=que.front();\n\t\tque.pop();\t\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tif(ct[v][i]>=0 && ct[v][i]+cost[v] < cost[i]){\n\t\t\t\tcost[i]=ct[v][i]+cost[v];\t\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\ty1-=cost[x2];\n\n\tfor(int i=0; i<=20; ++i) cost[i]=N;\n\t//帰りのbfs\n\tcost[x2]=0;\n\tque.push(x2);\n\twhile( !que.empty() ){\n\t\tint v=que.front();\n\t\tque.pop();\t\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tif(ct[v][i]>=0 && ct[v][i]+cost[v] < cost[i]){\n\t\t\t\tcost[i]=ct[v][i]+cost[v];\t\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\ty1-=cost[x1];\n\t\n\tprintf(\"%ld\\n\", y1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\n\ntypedef pair<int,int> mypair;\n\n\nint dak(int st, int gl, int n, int m, vector<vector<int> > zct){\n\tvector<int> mct(n+1,1<<22);\n\tvector<bool> use(n+1,false);\n\tmct[st]=0;\n\tpriority_queue<mypair, vector<mypair>, greater<mypair>> pq;\n\tpq.push(mypair(0,st));\n\twhile(!pq.empty()){\n\t\tint ct = pq.top().first;\n\t\tint to = pq.top().second;\n\t\tpq.pop();\n\t\tif(use[to]) continue;\n\t\tuse[to]=true;\n\t\t\n\t\trep(i,m){\n\t\t\tif( mct[i] > mct[to]+ zct[to][i]){\n\t\t\t\t\tmct[i] = mct[to] + zct[to][i];\n\t\t\t\tpq.push(mypair(mct[i],i));\n\t\t\t}\n\t\t}\n\t}\n\treturn mct[gl];\n\n}\n\nint main(void){\n\nint n,m;\nint a,b,c,d;\nint x1,x2,y1,y2;\nchar k;\n\tcin >> n >> m;\n\tvector<vector<int> > zct(n+1,vector<int>(n+1,1<<20));\n\trep(i,m){\n\t\tcin >>a >>k >>b >>k >>c >>k >>d;\n\t\ta--;  b--;\n\t\tzct[a][b]=c; zct[b][a]=d;\n\t}\n\tcin >>x1 >>k >>x2 >>k >>y1 >>k >>y2;\n\tx1--; x2--;\n\tint ans = y1 - (y2 +dak(x1,x2,n,m,zct) + dak(x2,x1,n,m,zct));\n\tcout << ans << endl;\n\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1001001001;\nint K[25][25];\n\ntemplate<class T> inline bool chmin(T& a, T b){if(a > b){a = b;return true;} return false;} //aをより小さい値にする関数\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0; i < n; i++){ //ワーシャルフロイド用に初期化\n        for(int j = 0; j < n; j++){\n            if(i == j) K[i][j] = 0;\n            else K[i][j] = INF;\n        }\n    }\n    for(int i = 0; i < m; i++){\n        int a, b, c, d;\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        a--; b--; // 0-indexed\n        K[a][b] = c; //aからbはコストc\n        K[b][a] = d; //bからaはコストd\n    }\n    int s, g, V, P;\n    scanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n    s--; g--;\n    for(int k = 0; k < n; k++){ //kは経由地点\n        for(int i = 0; i < n; i++){ //iは始点\n            for(int j = 0; j < n; j++){ //jは終点\n                chmin(K[i][j], K[i][k] + K[k][j]);\n            }\n        }\n    }\n    int cost = K[s][g] + K[g][s] + P; //かかったお金は移動費と木材費\u000e\n    cout << V - cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nconst int inf=1e9;\nusing namespace std;\nint main(){\n  int a,b;\n  cin>>a>>b;\n  vector<vector<int> >in(a,vector<int>(a));\n  rep(i,a)rep(j,a)in[i][j]=inf;\n  int c,d,e,f;\n  //cout<<\"!\"<<endl;\n  rep(i,b+1){\n    char x;\n    cin>>c>>x>>d>>x>>e>>x>>f;\n    c--;d--;\n    if(i==b)break;\n    in[c][d]=e;\n    in[d][c]=f;\n  }\n  vector<vector<int> >tmp(a,vector<int>(a));\n  rep(i,a)rep(j,a)tmp[i][j]=in[i][j];\n  rep(k,a)rep(i,a)rep(j,a){\n    tmp[i][j]=min(tmp[i][j],tmp[i][k]+tmp[k][j]);\n    in[i][j]=min(in[i][j],in[i][k]+in[k][j]);\n  }\n  cout<<e-f-(tmp[c][d]+in[d][c])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define MAX_V  21;\n\nstruct edge{ int to, cost; };\ntypedef pair<int , int> P;\n\n\nint V;\n\nint INF = 10000000;\nvector<edge> G[22];\nint d[22];\nint m;\nint a1,b1,c1,d1;\n\nbool operator < (P a,P b){\n\treturn a.first == b.first;\n}\nbool comp(P a,P b){\n\treturn a.first < b.first;\n}\n\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+V+1, INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\t\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\t//cout<<\" que top \"<<v<<endl;\n\t\tif (d[v] < p.first) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t//cout<<e.to<< \" \"<<d[e.to]<<endl;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tchar t;\n\tint go,come;\n\tcin>>V>>m;\n\trep(i,m){\n\t\tedge tmp;\n\t\tcin>>a1>>t>>b1>>t>>c1>>t>>d1;\n\t\t//cout<<a1<<endl;\n\t\ttmp.to = b1; tmp.cost = c1;\n\t\tG[a1].push_back(tmp);\n\t\ttmp.to = a1; tmp.cost = d1;\n\t\tG[b1].push_back(tmp);\n\t}\n\t/*\n\trep(i,V+1){\n\t\trep(j,G[i].size()){\n\t\t\tcout<<i<< \" \"<<G[i][j].to<< \" \"<<G[i][j].cost<<endl;\n\t\t}\n\t}\n\t*/\n\tcin>>a1>>t>>b1>>t>>c1>>t>>d1;\n\tdijkstra(a1);\n\tgo = d[b1];\n\t\n\t//cout<<\"go  d[i]\\n\";\n\trep(i,V+1){\n\t\t//cout<<i<<\" \"<<d[i]<<endl;\n\t}\n\t\n\t//cout<<\"go = \"<< go<< endl;\n\tdijkstra(b1);\n\tcome = d[a1];\n\t//cout << \"come = \" << come<< endl;\n\tcout<<c1-d1-go-come<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  edge(){};\n  edge(int to,int cost){\n    p=to;\n    c=cost;\n  }\n  int p,c;\n};\nbool operator<(edge a,edge b){\n  return a.c<b.c;\n}\nint s,e,money,pay;\nvector<vector<edge> > edges;\n\n\nvoid init(){\n  edges.clear();\n}\n\nvoid input(){\n  char t;\n  int n;\n  cin>>n;\n  edges.resize(n);\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    int a,b,c,d;\n    cin>>a>>t>>b>>t>>c>>t>>d;\n    a--;b--;\n    edges[a].push_back(edge(b,c));\n    edges[b].push_back(edge(a,d));\n  }\n  cin>>s>>t>>e>>t>>money>>t>>pay;\n  s--,e--;\n}\n\nint path_cost(int start,int end){\n  priority_queue<edge> q;\n  vector<int> dp(edges.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i]=INT_MAX-100;\n  }\n  q.push(edge(start,0));\n  dp[start]=0;\n  while(!q.empty()){\n    edge now = q.top();q.pop();\n    if(now.p==end)return now.c;\n    for(int i=0;i<edges[now.p].size();i++){\n      edge tmp = edges[now.p][i];\n      if(dp[tmp.p]>tmp.c+now.c){\n        dp[tmp.p]=tmp.c+now.c;\n        q.push(edge(tmp.p,tmp.c+now.c));\n      }\n    }\n  }\n  return dp[end];\n}\n\n\nint solve(){\n  int tmp=0;\n  tmp += path_cost(s,e);\n  tmp += path_cost(e,s);\n  return money - tmp - pay;\n}\n\n\nint main(){\n  init();\n  input();\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22] = {0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin >> n >> m;\n    for(i = 1;i <= n;i++){\n        for(j = 1;j <= n;j++){\n            cost[i][j] = 1001001;\n        }\n    }\n    for(i = 0;i < m;i++){\n        cin >> a >> cc >> b >> cc >> c >> cc >> d;\n        cost[a][b] = c;\n        cost[b][a] = d;\n    }\n    for(k = 1;k <= n;k++){\n        for(i = 1;i <= n;i++){\n            for(j = 1;j <= n;j++){\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                cin >> a >> cc >> b >> cc >> c >> cc >> d;\n            }\n        }\n    }\n    cout << c - d - cost[a][b] - cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint main(){\n    int cost[22][22]={0};\n    int n,m,i,j,k,a,b,c,d;\n    char cc;\n    cin>>n>>m;\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            cost[i][j] = 1<<28;\n        }\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>cc>>b>>cc>>c>>cc>>d;\n        cost[a][b]=c;cost[b][a]=d;\n    }\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    cin>>a>>cc>>b>>cc>>c>>cc>>d;\n    cout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e+9;\n\nint main(){\n\tint n,m,dist[21][21];\n\t\n\tfor(int i=0 ; i < 21 ; i++ )\n\t\tfor(int j=0 ; j < 21 ; j++ )\n\t\t\tdist[i][j] = INF;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i=0 ; i < m ; i++ ){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tdist[a][b] = c;\n\t\tdist[b][a] = d;\n\t}\n\tfor(int k=1 ; k <= n ; k++ ){\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tfor(int j=1 ; j <= n ; j++ ){\n\t\t\t\tdist[i][j] = min( dist[i][j] , dist[i][k]+dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tint ans = y1 - (y2 + dist[x1][x2] + dist[x2][x1]);\n\tprintf(\"%d\\n\", ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, cost[36][36];\n\tfor (int i = 0;i < 36; ++i)\n\t\tfor (int j = 0; j < 36; ++j)\n\t\t\tcost[i][j] = 9999999;\n\tfor (int i = 0; i < 36; ++i)\n\t\tcost[i][i] = 0;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\tint start, end, given, pay;\n\tscanf(\"%d,%d,%d,%d\", &start, &end, &given, &pay);\n\n\tfor (int k = 1; k <= n; ++k)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\n\tprintf(\"%d\\n\", given - (cost[start][end] + cost[end][start] + pay));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<climits>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<stack>\n#include<functional>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int N,M,A,B,C1,C2,d[20][20],S,G,Mny,V;\n    fill_n((int*)d,20*20,INT_MAX/2);\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        scanf(\"%d,%d,%d,%d\",&A,&B,&C1,&C2); A--; B--;\n        d[A][B] = C1; d[B][A] = C2;\n    }\n    scanf(\"%d,%d,%d,%d\",&S,&G,&Mny,&V); S--; G--;\n    for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)\n        d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n    printf(\"%d\\n\",Mny-V-d[S][G]-d[G][S]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostrem>\n#include <cstdio>\n\nusing namspace  std;\nint N, M, A, B, C, D, x1, x2, y1, y2;\nint K[32][32];\nconst int inf =1001001001;\n\nint main(){\n  for (int i = 0; i < 32; ++i)\n  {\n    for (int j = 0; j < 32; ++i)\n    {\n     K[i][j]= inf;\n    }\n  }\n  scanf(\"%d%d\", &N, &M);\n  for(int i=0; i<M; ++i){\n    scanf(\"%d,%d,%d,%d\", &A, &B, &C, &D);\n    // cerr << \"read \" << A << \" \" << B << \" \" << C << \" \" << D << endl;\n    K[A-1][B-1]=C;\n    K[B-1][A-1]=D;\n  }\n\n\n  for (int k=1;k<N;k++){\n    for (int i = 1; i < N; i++){\n      for (int j = 0; j < N; j++){\n        if(K[i][j]>(K[i][k]+K[k][j]){\n          K[i][j]=K[i][k]+K[k][j];\n        }\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  cerr << y1-K[x1][x2]-y2 <<endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint dijkstra(int from, int to, VVPII & nodes, int n){\n\tVI dist(nodes.size(), (int) 10e7);\n\n\tpriority_queue<PII, vector<PII>, greater<PII> > q;\n\tq.emplace(0, from);\n\tdist[from] = 0;\n\twhile(!q.empty()){\n\t\tint cost = q.top().first; // cost\n\t\tint place = q.top().second; // current place\n\t\tq.pop();\n\t\tif(dist[place] < cost) continue;\n\t\tfor(PII node : nodes[place]){\n\t\t\tif(node.first + dist[place] < dist[node.second]){\n\t\t\t\tdist[node.second] = node.first + dist[place];\n\t\t\t\tq.emplace(dist[node.second], node.second);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, n){\n\n\t}\n\treturn dist[to];\n}\n\n\nint main(int argc, char const *argv[])\n{\n\tint n, m;\n\tcin >> n >> m;\n\tchar c;\n\tVVPII nodes(m);\n\n\tREP(i, m){\n\t\tint from, to, value;\n\t\tcin >> from >> c >> to >> c >> value;\n\t\tnodes[from].PB(MP(value, to));\n\t\tcin >> c >> value;\n\t\tnodes[to].PB(MP(value, from));\n\t}\n\n\tint start, goal, money, price;\n\tcin >> start >> c >> goal >> c;\n\tcin >> money >> c >> price;\n\tint go = dijkstra(start, goal, nodes, n);\n\tint back = dijkstra(goal, start, nodes, n);\n\tint reward = money - (price + go + back);\n\tcout << reward << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][21],int b[],int p,int e,int n,int m){\n  int i;\n  if(p==e){\n    if(b[p]==-1||b[p]>m)\n      b[p]=m;\n  }else if(b[p]==-1||b[p]>m){\n    b[p]=m;\n    for(i=1;i<n+1;i++){\n      if(a[p][i])\n\tf(a,b,i,e,n,m+a[p][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  int a[21][21],b[21],m,n,o,p,q,r;\n  cin>>n>>m;\n  memset(a,0,sizeof(a));\n  for(i=0;i<m;i++){\n    int t,u,v,w;\n    scanf(\"%d,%d,%d,%d\",&t,&u,&v,&w);\n    if(a[t][u]==0||a[t][u]>v)\n      a[t][u]=v;\n    if(a[u][t]==0||a[u][t]>w)\n      a[u][t]=w;\n  }\n  scanf(\"%d,%d,%d,%d\",&o,&p,&q,&r);\n  q-=r;\n  memset(b,-1,sizeof(b));\n  f(a,b,o,p,n,0);\n  q-=b[p];\n  memset(b,-1,sizeof(b));\n  f(a,b,p,o,n,0);\n  q-=b[o];\n  cout<<q<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint cost[22][22]={0};\n\n\nint main(){\n\tint n,m,i,j,k,a,b,c,d;\n\tchar cc;\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tcost[i][j] = 1<<28;\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>cc>>b>>cc>>c>>cc>>d;\n\t\tcost[a][b]=c;cost[b][a]=d;\n\t}\n\tfor(k=1;k<=n;k++)\n\t  for(i=1;i<=n;i++)\n\t    for(j=1;j<=n;j++)\n\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tcin>>a>>cc>>b>>cc>>c>>cc>>d;\n\tcout << c-d-cost[a][b]-cost[b][a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\n#define MAX 1000000\n\nint main(){\n  int n, m;\n  while(~scanf(\"%d%d\",&n,&m)){\n    int road[n][n];\n    REP(i,n) REP(j,n) road[i][j] = MAX;\n    REP(i,m){\n      int a,b,c,d;\n      scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n      road[a-1][b-1] = c;\n      road[b-1][a-1] = d;\n    }\n    int x1,x2,y1,y2;\n    scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n    REP(k,n) REP(i,n) REP(j,n)\n      road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n    //cout << road[x1-1][x2-1] + road[x2-1][x1-1] << endl;\n    cout << y1 - y2 - road[x1-1][x2-1] - road[x2-1][x1-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nconst int NUM = 25;\n\nint main() {\n\tint wf[NUM][NUM];\n\t\n\tfor ( int i = 0; i < NUM; i++ ) {\n\t\tfor ( int j = 0; j < NUM; j++ ) {\n\t\t\tif ( i == j ) {\n\t\t\t\twf[i][j] = 0;\n\t\t\t} else {\n\t\t\t\twf[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n,m;\n\tcin >> n >> m;\n\tfor ( int i = 0; i < m; i++ ) {\n\t\tint a,b,c,d;\n\t\tscanf ( \"%d,%d,%d,%d\",&a,&b,&c,&d );\n\t\ta--;b--;\n\t\twf[a][b] = c;\n\t\twf[b][a] = d;\n\t}\n\t\n\tfor ( int a = 0; a < n; a++ ) {\n\t\tfor ( int b = 0; b < n; b++ ) {\n\t\t\tfor ( int c = 0; c < n; c++ ) {\n\t\t\t\twf[b][c] = min ( wf[b][c] , wf[b][a] + wf[a][c] );\n\t\t\t}\n\t\t}\n\t}\n\tint x1,x2,y1,y2;\n\tscanf ( \"%d,%d,%d,%d\",&x1,&x2,&y1,&y2 );\n\tx1--;x2--;\n\tint cost = wf[x1][x2] + wf[x2][x1];\n\tcout << y1 - ( y2 + cost ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,a) for(int i = 0 ; i < a ; i++)\nint main(void){\n  int maze[20][20];\n  int maze1[20][20];\n  int prv[20][20];\n  int n,m;\n  int a,b,c,d;\n  cin>>n>>m;\n  rep(i,n)rep(j,n)maze[i][j]=maze1[i][j]=10000000;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    maze[--a][--b]=c;\n    maze[b][a]=d;\n  }\n  \n  \n  rep(k,n)rep(i,n)rep(j,n){\n    maze[i][j]=min(maze[i][j],maze[i][k]+maze[k][j]);\n  }\n  \n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  \n  cout<<-maze[--a][--b]-maze[b][a]+c-d<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 20\n#define INF 1e9\nusing namespace std;\n\nint dp[MAX_N][MAX_N];\nint n,m;\n\nvoid warshall_froyd(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> n; \n  cin >> m;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dp[i][j] = (i==j ? 0 : INF);\n    }\n  }\n  \n  char camma;\n  for(int i=0;i<m;i++){\n    int a,b,atob,btoa;\n    cin >> a >> camma >> b >> camma >> atob >> camma >> btoa;\n    a--; b--;\n    dp[a][b] = atob; dp[b][a] = btoa;\n  }\n\n  warshall_froyd();\n\n  int start,goal,reward,price;\n  cin >> start >> camma >> goal >> camma >> reward >> camma >> price;\n  start--; goal--;\n  cout << reward - dp[start][goal] - dp[goal][start] - price << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll> > P3;\n\nconst ll MOD = ll(1e9 + 7);\nconst ll LLINF = LLONG_MAX;\nconst int IINF = INT_MAX;\nconst int MAX_N = int(1e8) + 5;\nconst int MAX_A = int(15e6);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\nstring dir = \"RDLU\";\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, cost;\n};\n\nint n, m;\nint s, g, vv, pp;\nint dmin[25];\nvector<edge> G[25];\n\nvoid dijkstra(){\n    fill(dmin,dmin+n,IINF);\n    dmin[s] = 0;\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(0,s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(p.first > dmin[p.second])continue;\n        int v = p.second;\n        for(auto e : G[v]){\n            if(dmin[e.to] > dmin[v] + e.cost){\n                dmin[e.to] = dmin[v] + e.cost;\n                que.push(P(dmin[e.to],e.to));\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    cin >> n >> m;\n    REP(i,m+1){\n        string ss;\n        cin >> ss;\n        vector<int> ls;\n        int bg = 0;\n        while(ss.find(',', bg) != ss.npos){\n            bg = ss.find(',', bg);\n            ls.push_back(bg);\n            bg++;\n        }\n        int a, b, c, d;\n        a = stoi(ss.substr(0,ls[0]));\n        b = stoi(ss.substr(ls[0]+1,ls[1]-ls[0]));\n        c = stoi(ss.substr(ls[1]+1,ls[2]-ls[1]));\n        d = stoi(ss.substr(ls[2]+1,ss.size()-ls[2]));\n\n        a--;\n        b--;\n        if(i<m){\n            G[a].push_back({b,c});\n            G[b].push_back({a,d});\n        }\n        else{\n            s = a;\n            g = b;\n            vv = c;\n            pp = d;\n        }\n    }\n    int ans = pp;\n    dijkstra();\n    ans += dmin[g];\n    swap(s,g);\n    dijkstra();\n    ans += dmin[g];\n    cout << vv - ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nstruct P{\n\tint p, cost;\n\n\tbool operator >(const P& p)const {\n\t\treturn cost > p.cost;\n\t}\n};\n\nstruct Edge{\n\tint to, cost;\n};\n\nconst int MAX_TOWN = 21;\n\nint G[MAX_TOWN];\n\nint main() {\n\tint town_n, road_n, start, goal, money, pay;\n\tcin >> town_n >> road_n;\n\tvector<vector<Edge>> E(town_n + 1);\n\n\tchar gm;\n\tREP(i, road_n){\n\t\tint from, to, costA, costB;\n\t\tcin >> from >>gm>> to >>gm>> costA >>gm>> costB;\n\t\tE[from].push_back({to, costA});\n\t\tE[to].push_back({from, costB});\n\t}\n\tcin >> start >>gm>> goal >>gm>> money >>gm>> pay;\n\tmoney -= pay;\n\n\n\t{\n\t\tfill_n((int * )G, MAX_TOWN, 1e9);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tG[start] = 0;\n\t\tque.push({start, 0});\n\n\t\tint res = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif(p.p == goal){\n\t\t\t\tres = p.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(Edge e:E[p.p]){\n\t\t\t\tint next_town = e.to;\n\t\t\t\tint next_cost = p.cost + e.cost;\n\t\t\t\tif (G[next_town] > next_cost){\n\t\t\t\t\tG[next_town] = next_cost;\n\t\t\t\t\tque.push({next_town, next_cost});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoney -= res;\n\t}\n\t{\n\t\tfill_n((int * )G, MAX_TOWN, 1e9);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tG[goal] = 0;\n\t\tque.push({goal, 0});\n\n\t\tint res = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif(p.p == start){\n\t\t\t\tres = p.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(Edge e:E[p.p]){\n\t\t\t\tint next_town = e.to;\n\t\t\t\tint next_cost = p.cost + e.cost;\n\t\t\t\tif (G[next_town] > next_cost){\n\t\t\t\t\tG[next_town] = next_cost;\n\t\t\t\t\tque.push({next_town, next_cost});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmoney -= res;\n\t}\n\n\tcout << money << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\n\nstruct Node{\n  int num;\n\n  vector<int> edge_to;\n  vector<int> edge_cost;\n\n  bool done;\n  int cost;\n};\n\nvector<string> splitAll(string s, string t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0, p));\n    s = s.substr(p + t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nint dijkstra (vector<Node> g,int start,int goal){\n  int d;\n  g[start].cost=0;\n\n  while(1){\n    d=-1;\n\n    for(int i=1;i<=g.size();i++){\n      if( g[i].done || g[i].cost < 0 ) continue;\n      if( d==-1 || g[i].cost < g[d].cost ) d=i;\n    }\n\n    if(d==-1) break;\n    g[d].done=true;\n\n    for(int i=0; i< g[d].edge_to.size(); i++){\n      int to = g[d].edge_to[i];\n      int cost = g[d].cost + g[d].edge_cost[i];\n      if(g[to].cost < 0 || cost < g[to].cost)\n\tg[to].cost = cost;\n    }\n  }\n\n  return g[goal].cost;\n}\n\n\nint main(){\n  int n,m;\n  cin>>n;\n\n  vector<Node> graph;\n  graph.reserve(n+1);\n  graph.resize(n+1);\n\n  for(int i=1; i<=n; i++){\n    graph[i].num=(i+1);\n    graph[i].cost=-1;\n    graph[i].done=false;\n  }\n\n  string s;\n\n  cin>>m;\n  getline(cin,s);\n\n  int a,b,c,d;\n  vector<string> vv;\n  vv.reserve(4);\n  vv.resize(4);\n\n  while(m--){\n    getline(cin,s);\n    vv = splitAll(s,\",\");\n\n    a = atoi( vv[0].c_str() );\n    b = atoi( vv[1].c_str() );\n    c = atoi( vv[2].c_str() );\n    d = atoi( vv[3].c_str() );\n\n    graph[a].edge_to.push_back(b);\n    graph[a].edge_cost.push_back(c);\n    graph[b].edge_to.push_back(a);\n    graph[b].edge_cost.push_back(d);\n\n  }\n\n  int x1,x2,y1,y2;\n  getline(cin,s);\n  vv = splitAll(s,\",\");\n\n  x1 = atoi( vv[0].c_str() );\n  x2 = atoi( vv[1].c_str() );\n  y1 = atoi( vv[2].c_str() );\n  y2 = atoi( vv[3].c_str() );\n\n  vector<Node> copy;\n  copy.reserve(n+1);\n  copy.assign(graph.begin(),graph.end());\n\n  int rcost = dijkstra(graph,x2,x1);\n  int gcost = dijkstra(copy,x1,x2);\n\n  cout<<y1-y2-rcost-gcost<<endl;\n\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List.Split (splitOn)\n\ndata LDGraph a c = LDG { p :: [a]\n                       , v :: [((a,a),c)]\n                       } deriving Show\n\nmain = do\n  n <- readLn\n  m <- readLn\n  roads <- replicateM m getRoad\n  [start,goal,value,price] <- map read.splitOn \",\"<$>getLine\n  let graph = toGraph [1..n] roads\n      Just min = (+)<$>minMoney graph [] start goal<*>minMoney graph [] goal start\n  print $ value - price - min\n\ngetRoad :: IO (Int,Int,Int,Int)\ngetRoad = do\n  [a,b,c,d] <- map read.splitOn \",\"<$>getLine\n  return (a,b,c,d)\n\ntoGraph :: [Int] -> [(Int,Int,Int,Int)] -> LDGraph Int Int\ntoGraph ps xs = LDG ps vs\n  where vs = toVecs xs\n\ntoVecs :: [(Int,Int,Int,Int)] -> [((Int,Int),Int)]\ntoVecs = foldr (\\x -> (func x ++)) []\n  where func (a,b,c,d) = [((a,b),c),((b,a),d)]\n\nlabel :: Eq a => LDGraph a c -> a -> a -> Maybe c\nlabel g a b = if null vect then Nothing\n                           else Just $ snd.head $ vect\n  where vect = filter (\\x -> fst x == (a,b)) $ v g\n\nminMoney :: (Eq a) => LDGraph a Int -> [a] -> a -> a -> Maybe Int\nminMoney g h a b \n  | a == b = Just 0\n  | otherwise = minimum' $ [ (+)<$>label g a j<*>minMoney g (a:h) j b | j <- list]\n  where list = map snd.filter (\\(x,y) -> (x == a) && not (y `elem` h)).map fst $ v g\n        minimum' = \\x -> if null x then Just 0\n                                   else minimum x\n\ntestData :: LDGraph Int Int\ntestData = LDG [1..6] [((1,2),2),((1,3),4),((1,4),4),((2,1),2),((2,5),3),((3,1),3),((3,4),4),((3,6),1),((4,1),2),((4,3),2),((4,6),2),((5,2),2),((5,6),1),((6,3),2),((6,4),1),((6,5),2)]"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\ndata Point = Point { point :: Int\n                    ,trail :: Int\n                    ,flag :: Bool} deriving (Eq,Show)\n\ndata Road = Road { p1 :: Int\n                  ,p2 :: Int\n                  ,len :: Int} deriving (Show)\n\nminPoint :: [Point] -> Point\nminPoint ps = foldl1 f ps\n                where f p1 p2\n                        | flag p1 = p2\n                        | (not (flag p2)) && (trail p1 > trail p2) = p2\n                        | otherwise = p1\n\nallAcces :: [Road] -> [Point]-> [Point]\nallAcces [] visited = visited\nallAcces roads visited = allAcces roads' visited'\n  where minP = minPoint visited\n        roads' = deleteRoad minP roads\n        visited' = used minP (acces minP roads visited)\n\nacces :: Point -> [Road] -> [Point] -> [Point]\nacces p [] visited = visited\nacces p (r:rs) visited\n  | point p == p1 r = acces p rs (update p r visited)\n  | otherwise       = acces p rs visited\n\nupdate :: Point -> Road -> [Point] -> [Point]\nupdate p r [] = [(Point (p2 r) ((trail p) + (len r)) False)]\nupdate p r (v:vs)\n  | p2 r == point v = (Point (point v) (min (trail v) ((trail p) + (len r))) (flag v)):vs\n  | otherwise       = v:(update p r vs)\n\nused :: Point -> [Point] -> [Point]\nused p [] = []\nused p (x:xs)\n  | point p == point x  = (Point (point p) (trail p) True):xs\n  | otherwise           = x:(used p xs)\n\ndeleteRoad :: Point -> [Road] -> [Road]\ndeleteRoad _ [] = []\ndeleteRoad p (r:rs)\n  | point p == p1 r = deleteRoad p rs\n  | otherwise       = r:(deleteRoad p rs)\n\nsplitByC :: String -> [String] -> [String]\nsplitByC \"\" ss = ss\nsplitByC (',':xs) ss = splitByC xs (ss ++ [\"\"])\nsplitByC (x:xs) ss = splitByC xs ((init ss) ++ [(last ss) ++ [x]])\n\nsplit' :: String -> [String]\nsplit' s = splitByC s [\"\"]\n\nmakeRoadL :: [Road]-> [Int] -> [Road]\nmakeRoadL rs [] = rs\nmakeRoadL rs [a,b,c,d] = (Road a b c):(Road b a d):rs\n\nminTrail :: Int -> [Point] -> Int\nminTrail i (p:ps)\n  | i == point p = trail p\n  | otherwise    = minTrail i ps\n\nmain :: IO ()\nmain = do\n  n <- getLine\n  m <- readLn\n  sss <- replicateM m getLine\n  sgvp <- getLine\n  let ss = map (map (read :: String -> Int)) $ map split' sss\n      [s,g,v,p] = map (read :: String -> Int) $  split' sgvp\n      rs = foldl makeRoadL [] ss\n      go = allAcces rs [(Point s 0 False)]\n      back = allAcces rs [(Point g 0 False)]\n      ans = - (minTrail g go) - (minTrail s back) + v - p\n  putStrLn $ show ans"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport Data.Foldable (foldMap)\nimport Data.List.Split\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\n-- end of templete\n\nwf :: IOUArray (Int,Int) Int -> [Int] -> IO ()\nwf arr range = do\n    forM_ range $ \\k -> do\n        forM_ range $ \\i -> do\n            forM_ range $ \\j -> do\n                u <- readArray arr (i,k)\n                v <- readArray arr (k,j)\n                d <- readArray arr (i,j)\n                when (u/=(-1) && v/=(-1)) $ do\n                  let w = u + v\n                  when (d==(-1) || w<d) $ writeArray arr (i,j) w \n\n\n\nmain = do\n    n <- getInt\n    m <- getInt\n    arr <- newArray ((1,1),(n,n)) (-1) :: IO (IOUArray (Int,Int) Int)\n    replicateM_ m $ do\n        [a,b,c,d] <- map readInt . wordsBy (==',') <$> getLine\n        writeArray arr (a,b) c\n        writeArray arr (b,a) d\n    wf arr [1..n]\n    [s,g,v,p] <- map readInt . wordsBy (==',') <$> getLine\n    x <- (+) <$> readArray arr (s,g) <*> readArray arr (g,s)\n    print $ v - p - x"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } //*/\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30];//,f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;1;i++){//printf(\"a\\n\");\n      //f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }printf(\"\\n\");g();printf(\"\\n\");\n      a=h[j=1]%30;\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }//printf(\"a==%d\\n\",a);\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 20\n#define UL ( INT_MAX >> 1 )\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n\nstatic int d[ N ][ N ];\nstatic int n;\n\nstatic int jintan[ N ] = { 0 };\n\nstatic int\nFSA (\n  int p,\n  int t\n  )\n{\n  int res = UL;\n  int i;\n\n  if ( p == t )       return ( 0 );\n  if ( jintan[ p ] )  return ( UL );\n\n  jintan[ p ] = 1;\n\n  for ( i = 0; i < n; ++i )\n  {\n    int tmp;\n\n    if ( d[ p ][ i ] == -1 ) continue ;\n\n    tmp = FSA ( i, t ) + d[ p ][ i ];\n    res = MIN( res, tmp );\n  }\n\n  jintan[ p ] = 0;\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int m, x1, x2, y1, y2;\n  int res;\n\n  scanf ( \"%d %d\", &n, &m );\n\n  memset ( d, -1, sizeof ( d ) );\n  while ( m-- )\n  {\n    int a, b, c1, c2;\n\n    scanf ( \" %d,%d,%d,%d\", &a, &b, &c1, &c2 );\n    d[ a - 1 ][ b - 1 ] = c1;\n    d[ b - 1 ][ a - 1 ] = c2;\n  }\n  scanf ( \" %d,%d,%d,%d\", &x1, &x2, &y1, &y2 );\n\n  res  = FSA ( x1 - 1, x2 - 1 );\n  res += FSA ( x2 - 1, x1 - 1 );\n\n  printf ( \"%d\\n\", y1 - y2 - res );\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 100000000\nint main(){\n  int n,m,i,j,k,l;\n  int d[21][21];\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<21*21;i++)d[i/21][i%21]=M;\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&i,&j,&k,&l);\n    d[i][j]=k;\n    d[j][i]=l;\n    d[i][i]=d[j][j]=0;\n  }\n  for(k=1;k<=n;k++){\n    for(j=1;j<=n;j++){\n      for(i=1;i<=n;i++){\n\tif(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n      }\n    }\n  }\n  scanf(\"%d,%d,%d,%d\",&i,&j,&k,&l);\n  printf(\"%d\\n\",k-d[i][j]-d[j][i]-l);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 1000000000\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nint route[21][21];\nint cost[21];\nint check[21];\nint n, m;\n\nvoid dijkstra(int start) {                                                      \n    int i, u;                                                                   \n                                                                                \n    for (i = 1; i < n + 1; i++) {                                               \n        cost[i] = MAX;                                                          \n        check[i] = 0;                                                           \n    }                                                                           \n    cost[start] =0;                                                             \n    while (1) {                                                                 \n        int v = -1;                                                             \n        for (u = 1; u < n + 1; u++) {                                           \n            if (check[u] == 0 && (v == -1 || cost[u] < cost[v]))                \n                v = u;                                                          \n        }                                                                       \n        if (v == -1)                                                            \n            break;                                                              \n        check[v] = 1;                                                           \n                                                                                \n        for (u = 1; u < n + 1; u++) {                                           \n            cost[u] = min(cost[u], cost[v] + route[v][u]);                      \n        }                                                                       \n    }                                                                           \n}\n\nvoid warshall_floyd() {                                                         \n    int i, j, k;                                                                \n    for (k = 1; k < n + 1; k++)                                                 \n        for (i = 1; i < n + 1; i++)                                             \n            for (j = 1; j < n + 1; j++)                                         \n                route[i][j] = min(route[i][j], route[i][k] + route[k][j]);      \n}\n\nint main(void) {                                                                \n    int i, a, b, c, d;                                                          \n    int x1, x2, y1, y2;                                                         \n    int money;                                                                  \n                                                                                \n    for (i = 0; i < 21*21; i++) {                                               \n        route[i/20][i%20] = MAX;                                                \n    }                                                                           \n                                                                                \n    scanf(\"%d%d\", &n, &m);                                                      \n    while (m > 0) {                                                             \n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);                                   \n        route[a][b] = c;                                                        \n        route[b][a] = d;                                                        \n        m--;                                                                    \n    }                                                                           \n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);                                   \n                                                                                \n    dijkstra(x1);                                                               \n    money = y1 - y2 - cost[x2];                                                 \n    dijkstra(x2);                                                               \n    money -= cost[x1];                                                          \n    //    warshall_floyd();                                                     \n    //money = y1 - (route[x1][x2] + route[x2][x1] + y2);                        \n    printf(\"%d\\n\", money);                                                      \n                                                                                \n    return 0;       \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } //*/\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      //f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      a%=30;\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      //while(f[a%10]){//printf(\"a==%d\\n\",a);\n      a=h[j=1];\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }//printf(\"a==%d\\n\",a);\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 0x10000000\n\nint cities, roads, road[1000][1000], startcity, goalcity;\n\nint main()\n{\n\tint i, j, a, b, c, d,\n\t    reward, woodcost;\n\tfor(i = 0; i < 1000; i++) {\n\t\tfor(j = 0; j < 1000; j++) road[i][j] = INF;\n\t}\n\t/* input */\n\tscanf(\"%d\\n%d\", &cities, &roads);\n\tfor(i = 0; i < roads; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\troad[a - 1][b - 1] = c;\n\t\troad[b - 1][a - 1] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &startcity, &goalcity, &reward, &woodcost);\n\treward -= woodcost;\n\t/* Dijkstra */\n\t/* outward way */\n\treward -= dijkstra(startcity - 1, goalcity - 1);\n\t/* return path */\n\treward -= dijkstra(goalcity - 1, startcity - 1);\n\tprintf(\"%d\\n\", reward);\n\treturn 0;\n}\nint dijkstra(int start, int goal)\n{\n\tint i, u,\n\t    d[20], used[20];\n\tfor(i = 0; i < 20; i++) {\n\t\td[i] = INF;\n\t\tused[i] = 0;\n\t}\n\td[start] = 0;\n\tfor(i = 0; i < cities; i++) {\n\t\tif(road[start][i] != INF) d[i] = road[start][i];\n\t}\n\twhile(1) {\n\t\tu = -1;\n\t\tfor(i = 0; i < cities; i++) {\n\t\t\tif(!used[i] && (u == -1 || d[i] < d[u])) u = i;\n\t\t}\n\t\tif(u == -1) break;\n\t\tused[u] = 1;\n\t\tfor(i = 0; i < cities; i++) {\n\t\t\tif(d[i] > d[u] + road[u][i]) d[i] = d[u] + road[u][i];\n\t\t}\n\t}\n\treturn d[goal];\n}"
  },
  {
    "language": "C",
    "code": "main(){\n    int i,n,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&k);\n        /*initialize*/\n        memset(dist,11,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(;k;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n \n        {/*warshall-floyd*/\n            int k,i,j;\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n \n        {/*query*/\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;*c,t,T,f;D(S){for(memset(c=g,1,84),f=c[S]=0;T=S;)for(f|=1<<T,S=i=0;++i<=n;S=f&1<<i|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]?c[i]=t:0;}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y),~i--?g[g[x][X]=y,X][x]=Y:0;);D(x),y-=c[X],D(X);exit(!printf(\"%d\\n\",y-Y-c[x]));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 999\n\nint main(void)\n{\n\tint N, V, graph[20][20], node[20], node2[20], s, t, x, y,i, j, f, g;\n\t\n\tscanf(\"%d%d\", &V, &N);\n\tfor (i = 0; i < V; i++)\n\t{\n\t\tfor (j = 0; j < V; j++)\n\t\t\tgraph[i][j] = INF;\n\t\tnode[i] = node2[i] = INF;\n\t}\n\tfor (i = 0; i <= N; i++)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\", &s, &t, &x, &y);\n\t\ts--;\n\t\tt--;\n\t\tif (i != N)\n\t\t{\n\t\t\tgraph[s][t] = x;\n\t\t\tgraph[t][s] = y;\n\t\t}\n\t}\n\tnode[s] = node2[t] = 0;\n\twhile (1)\n\t{\n\t\tf = g = 0;\n\t\tfor (i = 0; i < V; i++)\n\t\t\tfor (j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tif (node[i] != INF && graph[i][j] != INF && node[j] > node[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tf = 1;\n\t\t\t\t\tnode[j] = node[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t\tif (node2[i] != INF && graph[i][j] != INF && node2[j] > node2[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tg = 1;\n\t\t\t\t\tnode2[j] = node2[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f && !g)\n\t\t\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", x - y - node[t] - node2[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[1000010]={0};\nint N[1000010]={-1000};\n//ヒープに入れる\nvoid hin(int a){\n  int i=C++;\n  for(N[R]=a;a<N[H[i/2]];i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//ヒープから最小値を取り出す\nint hout(){\n  int rt=H[1],nt=1,i=0,k=H[--C];\n  while(nt-i){\n    H[i=nt]=k;\n    if(i*2  <C&&N[  k  ]>N[H[i*2  ]])H[i]=H[nt=i*2  ];\n    if(i*2+1<C&&N[H[nt]]>N[H[i*2+1]])H[i]=H[nt=i*2+1];\n  }\n  return rt;\n}\nint CO[100010];\nvoid dijk(int v,int e,int *a,int *to,int *co,int mi){\n  int i,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=CO[mi]=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  while(--v){//printf(\"%d\\n\",mi);\n    f[mi]=1;\n    for(i=ta[mi];i+1;i=nt[i]){\n      if(CO[to[i]]>CO[mi]+co[i])hin(CO[id[R]=to[i]]=CO[mi]+co[i]);\n    }\n    while(f[mi])mi=id[hout()];\n  }\n}\nint main(){\n  int n,m,fr[10000],to[10000],co[10000],a,b,c,d,i;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<m*2;i+=2){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    fr[i]=to[i+1]=a-1;\n    to[i]=fr[i+1]=b-1;\n    co[i]=c;\n    co[i+1]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  dijk(n,m*2,fr,to,co,a-1);\n  c-=d+CO[b-1];\n  //for(i=0;i<n;i++)printf(\"%d \",CO[i]);printf(\"\\n\");\n  dijk(n,m*2,fr,to,co,b-1);\n  printf(\"%d\\n\",c-CO[a-1]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 100000000\nint main(void){\n\tint n, m, x1, x2, y1, y2;\n\tint a, b, c, d;\n\tint exp[20][20];\n\tint answer;\n\tint i, j, k;\n\n\tfor(i=0; i<20; i++){\n\t\tfor(j=0; j<20; j++){\n\t\t\texp[i][j] = INF; \n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor(i=0; i<m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\texp[a-1][b-1] = c;\n\t\texp[b-1][a-1] = d;\n\t}\n\tfor(i=0; i<n; i++){\n\t\texp[i][i] = 0;\n\t}\n\n\tfor(k=0; k<n; k++){\n\t\tfor(i=0; i<n; i++){\n\t\t\tfor(j=0; j<n; j++){\n\t\t\t\tif(exp[i][j] > exp[i][k] + exp[k][j]){\n\t\t\t\t\texp[i][j] = exp[i][k] + exp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\tanswer = y1 - (exp[x1-1][x2-1] + exp[x2-1][x1-1] + y2);\n\n\tprintf(\"%d\\n\", answer);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\n/*void g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } */\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[21][21]={0};\n  int n,l,i,j,r;\n  int a,b,e,d;\n  int c[21][2]={0};\n  int q[21]={0};\n  scanf(\"%d\\n%d\",&n,&l);\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  e-=d;\n  q[0]=a;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=a){\n\tq[r++]=j;\n\tif(c[j][0]==0)c[j][0]=c[q[i]][0]+m[q[i]][j];\n\telse if(c[j][0]>c[q[i]][0]+m[q[i]][j]){\n\t  c[j][0]=c[q[i]][0]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  //for(i=0;i<n;i++)printf(\"%d \",c[i+1][0]);\n  e-=c[b][0];\n  q[0]=b;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=b){\n\tq[r++]=j;\n\tif(c[j][1]==0)c[j][1]=c[q[i]][1]+m[q[i]][j];\n\telse if(c[j][1]>c[q[i]][1]+m[q[i]][j]){\n\t  c[j][1]=c[q[i]][1]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  e-=c[a][1];\n  printf(\"%d\\n\",e);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\nint main(void)\n{\n\tint way[21][21];\n\tint i, j, k;\n\tint n, m;\n\tint sp, ep, p, c;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (i = 1; i <= n; i++){\n\t\tfor (j = 1; j <= n; j++){\n\t\t\tway[i][j] = INT_MAX / 4;\n\t\t}\n\t\tway[i][i] = 0;\n\t}\n\tfor (i = 0; i < m; i++){\n\t\tint f, t, fc, tc;\n\t\tscanf(\"%d,%d,%d,%d\", &f, &t, &fc, &tc);\n\t\tway[f][t] = fc;\n\t\tway[t][f] = tc;\n\t}\n\n\tfor (i = 1; i <= n; i++){\n\t\tfor (j = 1; j <= n; j++){\n\t\t\tfor (k = 1; k <= n; k++){\n\t\t\t\tway[j][k] = fmin(way[j][k], way[j][i] + way[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &sp, &ep, &p, &c);\n\n\tp -= way[sp][ep] + way[ep][sp] + c;\n\tprintf(\"%d\\n\", p);\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,m,l,x,y,route[2][21][21];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i!=j)route[0][i][j]=999999999;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&j,&k,&x,&y);\n\t\troute[0][j-1][k-1]=x;\n\t\troute[0][k-1][j-1]=y;\n\t}\n\n\tfor(l=1;pow(2.0,l-1)<n-1;l++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][j];\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(route[l%2][i][j]>route[(l+1)%2][i][k]+route[(l+1)%2][k][j]){\n\t\t\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][k]+route[(l+1)%2][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tl=(l-1)%2;\n\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&j,&k);\n\tprintf(\"%d\\n\",j-k-route[l][x-1][y-1]-route[l][y-1][x-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } //*/\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      //while(f[a%10]){//printf(\"a==%d\\n\",a);\n      a=h[j=1];\n      d=h[--r];\n      //if(r==1)break;\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }//printf(\"a==%d\\n\",a);\n      if(r==1)break;\n      h[j/2]=d;\n\t//}//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n   "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,m,l,x,y,route[2][21][21];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i!=j)route[0][i][j]=999999999;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&j,&k,&x,&y);\n\t\troute[0][j-1][k-1]=x;\n\t\troute[0][k-1][j-1]=y;\n\t}\n\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tprintf(\"%10d\",route[0][i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor(l=1;pow(2.0,l-1)<n-1;l++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][j];\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(route[l%2][i][j]>route[(l+1)%2][i][k]+route[(l+1)%2][k][j]){\n\t\t\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][k]+route[(l+1)%2][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tl=(l-1)%2;\n\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tprintf(\"%10d\",route[l][i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&j,&k);\n\tprintf(\"%d\\n\",j-k-route[l][x-1][y-1]-route[l][y-1][x-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 100000\n\nint n;\nint machi[20][20];\n\nint kotsuhi(int start, int goal) {\n  int d[20], f[20];\n  int i, min, p;\n  for(i = 0; i < 20; i++) {\n    d[i] = INF;\n    f[i] = 0;\n  }\n  d[start-1] = 0;\n  while(1) {\n    min = INF;\n    for(i = 0; i < n; i++) {\n      if(d[i] < min && f[i] == 0) {\n        min = d[i];\n        p = i;\n      }\n    }\n    if(min == INF) break;\n    f[p] = 1;\n    for(i = 0; i < n; i++) {\n      if(d[p] + machi[p][i] < d[i]) {\n        d[i] = d[p] + machi[p][i];\n      }\n    }\n  }\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, m, a1, b1, c1, d1, x1, x2, y1, y2;\n\n  for(i = 0; i < 20; i++) {\n    for(j = 0; j < 20; j++) {\n      machi[i][j] = INF;\n    }\n  }\n\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for(i = 0; i < m; i++) {\n    scanf(\"%d,%d,%d,%d\", &a1, &b1, &c1, &d1);\n    a1 -= 1;\n    b1 -= 1;\n    machi[a1][b1] = c1;\n    machi[b1][a1] = d1;\n  }\n  scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n  printf(\"%d\\n\", y1 - y2 - kotsuhi(x1, x2) - kotsuhi(x2, x1));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,m,l,x,y,route[2][21][21];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i!=j)route[0][i][j]=999999999;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&j,&k,&x,&y);\n\t\troute[0][j-1][k-1]=x;\n\t\troute[0][k-1][j-1]=y;\n\t}\n\n\tfor(l=1;pow(2.0,l)<n-1;l++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][j];\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(route[l%2][i][j]>route[(l+1)%2][i][k]+route[(l+1)%2][k][j]){\n\t\t\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][k]+route[(l+1)%2][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tl=(l-1)%2;\n\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&j,&k);\n\tprintf(\"%d\\n\",j-k-route[l][x-1][y-1]-route[l][y-1][x-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,l,a,b,o,h,min,mi;\n  int d[21][21],f[21][2],c[21][2],s[2];\n  scanf(\"%d %d\",&n,&m);\n  for(i=1;i<=n;i++){\n    for(j=1;j<=n;j++)d[i][j]=100000000;\n    c[i][0]=c[i][1]=100000000;\n    f[i][0]=f[i][1]=0;\n  }\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&o,&h);\n    d[a][b]=o;\n    d[b][a]=h;\n  }\n  scanf(\"%d,%d,%d,%d\",&s[0],&s[1],&h,&o);\n  h-=o;\n  for(l=0;l<2;l++){\n    c[mi=s[l]][l]=0;\n    for(i=0;i<n;i++){\n      f[mi][l]=1;\n      for(j=1;j<=n;j++){\n\tif(f[j][l])continue;\n\tif(c[j][l]>c[mi][l]+d[mi][j])c[j][l]=c[mi][l]+d[mi][j];\n      }\n      min=2100000000;\n      for(j=1;j<=n;j++){//printf(\"%d \",c[j][l]);\n\tif(f[j][l])continue;\n\tif(min>c[j][l])min=c[mi=j][l];\n      }//printf(\"\\n\");\n    }//printf(\"\\n\");\n    h-=c[s[1-l]][l];\n  }\n  printf(\"%d\\n\",h);\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i,f;x,X;c[21],t,T;D(S){for(memset(c,1,84),f=c[S]=0;T=S;)for(f|=1<<T,S=i=0;++i<=n;S=f&1<<i|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]?c[i]=t:0;}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);~i--;~i?g[g[x][X]=y,X][x]=Y:0)scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y);D(x),y-=c[X],D(X);exit(!printf(\"%d\\n\",y-Y-c[x]));}"
  },
  {
    "language": "C",
    "code": "g[21][21],*p;x,X,y,Y;m,i,j,c;main(n){for(memset(g,scanf(\"%d%d\",&n,&m),1764);scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y),m--;g[X][x]=Y)g[x][X]=y;for(m=++n;--m;)for(i=n;--i;)for(j=n,p=g[i];--j;p[j]=p[j]<c?p[j]:c)c=p[m]+g[m][j];exit(!printf(\"%d\\n\",y-Y-g[x][X]-g[X][x]));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[21][21]={0};\n  int n,l,i,j,r;\n  int a,b,e,d;\n  int c[21][2]={0};\n  int q[100000]={0};\n  scanf(\"%d\\n%d\",&n,&l);\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  e-=d;\n  q[0]=a;\n  r=1;\n  for(i=0;i<10000;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=a){\n\tq[r++]=j;\n\tif(c[j][0]==0)c[j][0]=c[q[i]][0]+m[q[i]][j];\n\telse if(c[j][0]>c[q[i]][0]+m[q[i]][j]){\n\t  c[j][0]=c[q[i]][0]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  //for(i=0;i<n;i++)printf(\"%d \",c[i+1][0]);\n  e-=c[b][0];\n  q[0]=b;\n  r=1;\n  for(i=0;i<10000;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=b){\n\tq[r++]=j;\n\tif(c[j][1]==0)c[j][1]=c[q[i]][1]+m[q[i]][j];\n\telse if(c[j][1]>c[q[i]][1]+m[q[i]][j]){\n\t  c[j][1]=c[q[i]][1]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  for(i=0;i<n;i++)printf(\"%d \",c[i+1][1]);\n  e-=c[a][1];\n  printf(\"%d\\n\",e);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define INF 10000000\n#define N 21\n#define error(s) do{fprintf(stderr , s); exit(-1);}while(0)\n\nint M[N][N];\nvoid floyd(int n);\n\nint main(){\n\tint i,j,n,m,a,b,c,d,x1,x2,y1,y2;\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tfor(i = 1 ; i <= n ; i++){\n\t\tfor(j = 1 ; j <= n ; j++){\n\t\t\tM[i][j] = INF;\n\t\t}\n\t}\n\tfor(i = 1 ; i <= m ; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tM[a][b] = c;\n\t\tM[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tfloyd(n);\n\ty1 = y1 - y2 - M[x1][x2] - M[x2][x1];\n\tprintf(\"%d\\n\",y1);\n\treturn 0;\n}\n\nvoid floyd(int n){\n\tint i , j , k ;\n\tfor(k = 1 ; k <= n ; k++){\n\t\tfor(i = 1 ; i <= n ; i++){\n\t\t\tfor(j = 1 ; j <= n ; j++){\n\t\t\t\tif(M[i][k] + M[k][j] < M[i][j]){\n\t\t\t\t\tM[i][j] = M[i][k] + M[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define MAX_N 20\n\nconst int INF = 1000000000;\n\nint cost[MAX_N][MAX_N];\nint d[MAX_N];\nbool used[MAX_N];\nint n;\n\nint\ndijkstra(int s, int e)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\td[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\td[s] = 0;\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\tfor (int u = 0; u < n; ++u)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v]))\n\t\t\t\tv = u;\n\t\t}\n\n\t\tif (v == -1)\n\t\t\tbreak;\n\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < n; ++u)\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]); \n\t}\n\n\treturn d[e];\n}\n\nint\nmain(int argc, char **argv)\n{\n\tscanf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcost[i][j] = INF;\n\t}\n\n\tint m;\n\tint a, b, c, d;\n\tscanf(\"%d\\n\", &m);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d);\n\t\tcost[a - 1][b - 1] = c;\n\t\tcost[b - 1][a - 1] = d;\n\t}\n\n\tint s, g, V, P;\n\tscanf(\"%d,%d,%d,%d\\n\", &s, &g, &V, &P);\n\ts--, g--;\n\tprintf(\"%d\\n\", V - P - dijkstra(s, g) - dijkstra(g, s));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;*c,t,T,f;D(S){for(memset(c=g,1,84),f=c[S]=0;T=S;)for(f|=1<<T,S=i=0;++i<=n;S=f&1<<i|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]?c[i]=t:0;}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y),~i--?g[g[X][x]=Y,x][X]=y:0;);D(x),y-=c[X],D(X);exit(!printf(\"%d\\n\",y-Y-c[x]));}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;*c,t,T,f;D(S){for(memset(c=g,1,84),f=c[S]=0;T=S;)for(f|=1<<T,S=i=0;++i<=n;S=f&1<<i|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]?c[i]=t:0;}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);~i;i--?g[g[x][X]=y,X][x]=Y:0)scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y);D(x),y-=c[X],D(X);exit(!printf(\"%d\\n\",y-Y-c[x]));}"
  },
  {
    "language": "C",
    "code": "main(){\n    int i,n,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&k);\n        /*initialize*/\n        memset(dist,11,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(;k>0;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n  \n        {/*warshall-floyd*/\n            int k,i,j;\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n  \n        {/*query*/\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,m,l,x,y,route[2][21][21];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i!=j)route[0][i][j]=999999999;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&j,&k,&x,&y);\n\t\troute[0][j-1][k-1]=x;\n\t\troute[0][k-1][j-1]=y;\n\t}\n\n\tfor(l=1;pow(2.0,l)<n-1;l++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][j];\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(route[l%2][i][j]>route[(l+1)%2][i][k]+route[(l+1)%2][k][j]){\n\t\t\t\t\t\troute[l%2][i][j]=route[(l+1)%2][i][k]+route[(l+1)%2][k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tl=(l-1)%2;\n\n\tscanf(\"%d,%d,%d,%d\",&x,&y,&j,&k);\n\tprintf(\"%d\\n\",j-k-route[l][x-1][y-1]-route[l][y-1][x-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,a,b,d,e,min,mj,i,j,l,k;\n  int f[21]={0};\n  int m[21][21]={0};\n  int c[21];\n  scanf(\"%d %d\",&n,&l);\n  for(i=0;i<n;i++)c[i+1]=2100000000;\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  f[a]=1;\n  c[a]=0;\n  mj=a;\n  for(i=1;i<=n;i++){\n    for(j=1;j<=n;j++){\n      if(f[j])continue;//printf(\"j%d\\n\",j);\n      if(m[mj][j]){//道あったら\n\tif(c[j]>c[mj]+m[mj][j])c[j]=c[mj]+m[mj][j];//printf(\"j%d\\n\",j);\n      }//小さい方入れる\n    }\n    min=2100000000;\n    for(j=1;j<=n;j++){\n      if(f[j])continue;\n      if(min>c[j]){\n\tmin=c[j];\n\tmj=j;\n      }\n    }//printf(\"mj%d\\n\",mj);\n    f[mj]=1;\n    //for(k=0;k<n;k++)printf(\"%d \",c[k+1]);//printf(\"\\n\");\n  }\n  e-=c[b]+d;//printf(\"%d\\n\",c[b]);\n  for(i=0;i<n;i++)c[i+1]=2100000000;\n  f[b]=2;\n  c[b]=0;\n  mj=b;//for(i=1;i<=n;i++)printf(\"%d \",f[i]);//printf(\"\\n\");\n  for(i=1;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(f[j]==2)continue;\n      if(m[mj][j]){//道あったら\n\tif(c[j]>c[mj]+m[mj][j])c[j]=c[mj]+m[mj][j];\n      }//小さい方入れる\n    }\n    min=2100000000;\n    for(j=1;j<=n;j++){\n      if(f[j]==2)continue;\n      if(min>c[j]){\n\tmin=c[j];\n\tmj=j;\n      }\n    }\n    f[mj]=2;\n    //for(k=0;k<n;k++)printf(\"%d \",c[k+1]);printf(\"\\n\");\n  }\n  printf(\"%d\\n\",e-c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n    int i,n,m,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&k);\nm=k;\n        /*initialize*/\n        memset(dist,11,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(;k>0;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n  \n        {/*warshall-floyd*/\n            int k,i,j;\nfor(;m>0;m--)\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n  \n        {/*query*/\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint start;\n\nint max_prize(int money, int route[20][20], int current, int goal);\n\nint main(void)\n{\n\tint n, m;\n\tint i, j;\n\tint route[20][20] = {0};\n\tint pillar_point;\n\tint money;\n\tint price;\n\t\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\t\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\troute[a - 1][b - 1] = c;\n\t\troute[b - 1][a - 1] = d;\n\t}\n\t\n\tscanf(\"%d\", &start);\n\tscanf(\"%*c%d\", &pillar_point);\n\tscanf(\"%*c%d\", &money);\n\tscanf(\"%*c%d\", &price);\n\tmoney -= price;\n\t\n\tprintf(\"%d\\n\", max_prize(money, route, start, pillar_point));\n\t\n\treturn 0;\n}\n\nint max_prize(int money, int route[20][20], int current, int goal)\n{\n\tint i;\n\tint maxi = 0;\n\t\n\tif (current == goal){\n\t\tif (goal == start){\n\t\t\treturn money;\n\t\t}\n\t\telse {\n\t\t\treturn max_prize(money, route, goal, start);\n\t\t}\n\t}\n\tfor (i = 0; i < 20; i++){\n\t\tif (route[current - 1][i] > 0){\n\t\t\tint tmp_price = route[current - 1][i];\n\t\t\tint tmp_prize;\n\t\t\t\n\t\t\troute[current - 1][i] = 0;\n\t\t\ttmp_prize = max_prize(money - tmp_price, route, i + 1, goal);\n\t\t\troute[current - 1][i] = tmp_price;\n\t\t\t\n\t\t\tif (maxi < tmp_prize){\n\t\t\t\tmaxi = tmp_prize;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn maxi;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?(x):(y))\nint main(){\n\tint i,j,n,m,d[23][23],a,b;\n\tint used[23],v[23],s,g,ans,t,x;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++){v[i]=10000000;used[i]=0;for(j=1;j<n;j++)d[i][j]=10000000;}\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,\",&a,&b);\n\t\tscanf(\"%d,%d\",&d[a][b],&d[b][a]);\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&ans,&t);ans-=t;\n\tv[s]=0;\n\twhile(1){\n\t\tx=-1;\n\t\tfor(i=1;i<=n;i++)if(used[i]==0 && (x==-1 || v[i]<v[x]))x=i;\n\t\tif(x==-1)break;\n\t\tused[x]=1;\n\t\t//printf(\"v[%d]=%d\\n\",x,v[x]);\n\t\tfor(i=1;i<=n;i++)v[i]=min(v[i],v[x]+d[x][i]);\n\t}ans-=v[g];\n\tfor(i=1;i<=n;i++)v[i]=10000000,used[i]=0;\n\tv[g]=0;\n\twhile(1){\n\t\tx=-1;\n\t\tfor(i=1;i<=n;i++)if(used[i]==0 && (x==-1 || v[i]<v[x]))x=i;\n\t\tif(x==-1)break;\n\t\tused[x]=1;\n\t\t//printf(\"v[%d]=%d\\n\",x,v[x]);\n\t\tfor(i=1;i<=n;i++)v[i]=min(v[i],v[x]+d[x][i]);\n\t}\n\tans-=v[s];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;D(S,G){int c[21],f[21]={0},t,T;for(memset(c,1,84),c[S]=0;T=S;)for(f[T]=1,S=i=0;++i<=n;S=f[i]|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]&&(c[i]=t);return c[G];}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);~i--;~i&&(g[x][X]=y,g[X][x]=Y))scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y);exit(!printf(\"%d\\n\",y-Y-D(x,X)-D(X,x)));}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n    int i,n,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&k);\n        /*initialize*/\n        memset(dist,99,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(;k;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n \n        {/*warshall-floyd*/\n            int k,i,j;\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n \n        {/*query*/\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}              "
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0117: A reward for a Carpenter\n// 2017.8.8\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 10000000\n#define MAX 20\nchar visited[MAX + 2];\nint cost[MAX+2][MAX+2], total[MAX + 2];\nint n;\n\nint search(int s, int g);\n\nint main(void)\n{\n\tint m, s, g, V, P;\n\tint a, b, c, d;\n\tint i;\n\n\tmemset(cost, -1, sizeof(cost));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tcost[a][b] = c, cost[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &s, &g, &V, &P);\n\tif (s == g) printf(\"%d\\n\", V - P);\n\telse printf(\"%d\\n\", V - P - search(s, g) - search(g, s));\n\treturn 0;\n}\n\nint search(int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 1; i <= n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (cost[i][j] >= 0 && total[i] + cost[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + cost[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint n,m,s,g,a,t,i,j,k,c,d,ans;\n\tint x[25][25],y[25][25],v[25],f,p,q;\n\tmemset(x,0,sizeof(x));\n\tmemset(y,0,sizeof(y));\n\tmemset(v,-1,sizeof(v));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(k=0;k<m;k++){\n\t\tscanf(\"%d,%d,\",&i,&j);\n\t\tscanf(\"%d,%d\",&x[i][j],&x[j][i]);\n\t\ty[i][j]=x[i][j];\n\t\ty[j][i]=x[j][i];\n\t}\n\tscanf(\"%d,%d,%d,%d\",&s,&g,&a,&t);\n\tv[s]=0;f=1;c=d=0;\n\twhile(f!=n){\n\t\tp=100000;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(v[i]!=-1){\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tif(x[i][j]!=0 && p>v[i]+x[i][j] && v[j]==-1)\n\t\t\t\t\t\tx[c][d]=y[c][d],c=i,d=j,p=v[i]+x[i][j],q=j,x[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv[q]=p;f++;\n\t}\n\tans=a-t-v[g];\n\tmemset(v,-1,sizeof(v));\n\tv[g]=0;f=1;c=d=0;\n\tfor(i=0;i<=n;i++)for(j=0;j<n;j++)x[i][j]=y[i][j];\n\twhile(f!=n){\n\t\tp=100000;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(v[i]!=-1){\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tif(x[i][j]!=0 && p>v[i]+x[i][j] && v[j]==-1)\n\t\t\t\t\t\tx[c][d]=y[c][d],c=i,d=j,p=v[i]+x[i][j],q=j,x[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv[q]=p;f++;\n\t}\n\tans=ans-v[s];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n\tint i,n,k,a,b,A,B,dist[101][101];\n\tscanf(\"%d%d\",&n,&k);\n\t\t/*initialize*/\n\t\tmemset(dist,11,sizeof(dist));\n\t\tfor(i=1;i<=n;i++)dist[i][i]=0;\n\t\tfor(;k;k--){\n\t\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n\t\t\tdist[a][b]=A,dist[b][a]=B;\n\t\t}\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\n\t\t{/*query*/\n\t\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n\t\t\tprintf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n\t\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\nint main(void)\n{\n\tint way[21][21];\n\tint i, j, k;\n\tint n, m;\n\tint sp, ep, p, c;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (i = 1; i <= n; i++){\n\t\tfor (j = 1; j <= n; j++){\n\t\t\tway[i][j] = INT_MAX / 4;\n\t\t}\n\t\tway[i][i] = 0;\n\t}\n\tfor (i = 0; i < m; i++){\n\t\tint f, t, fc, tc;\n\t\tscanf(\"%d,%d,%d,%d\", &f, &t, &fc, &tc);\n\t\tway[f][t] = fc;\n\t\tway[t][f] = tc;\n\t}\n\n\tfor (i = 1; i <= n; i++){\n\t\tfor (j = 1; j <= n; j++){\n\t\t\tfor (k = 1; k <= n; k++){\n\t\t\t\tway[j][k] = fmin(way[j][k], way[j][i] + way[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &sp, &ep, &p, &c);\n\n\tprintf(\"%d %d\\n\", way[sp][ep], way[ep][sp]);\n\n\tp -= way[sp][ep] + way[ep][sp] + c;\n\tprintf(\"%d\\n\", p);\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\n/*void g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } */\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\t//if(r==1)break;\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\tif(r==1)break;\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint CO[100010];\nint R=1,C=1,H[1000010]={0};\nint N[1000010]={-1000};\n//ヒープに入れる\nvoid hin(int a){\n  int i=C++;\n  for(N[R]=a;a<N[H[i/2]];i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//ヒープから最小値を取り出す\nint hout(){\n  int rt=H[1],nt=1,i=0,k=H[--C];\n  while(nt-i){\n    H[i=nt]=k;\n    if(i*2  <C&&N[  k  ]>N[H[i*2  ]])H[i]=H[nt=i*2  ];\n    if(i*2+1<C&&N[H[nt]]>N[H[i*2+1]])H[i]=H[nt=i*2+1];\n  }\n  return rt;\n}\nvoid dijk(int v,int e,int *a,int *to,int *co,int mi){\n  int i,j,id[100010],ta[100010],nt[100010],f[100010]={0};\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++)CO[i]=1000000000;\n  for(i=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  CO[mi]=0;\n  for(i=1;i<v;i++){//printf(\"%d\\n\",mi);\n    f[mi]=1;\n    for(j=ta[mi];j+1;j=nt[j]){\n      if(CO[to[j]]>CO[mi]+co[j])hin(CO[id[R]=to[j]]=CO[mi]+co[j]);\n    }\n    while(f[mi])mi=id[hout()];\n  }\n}\nint main(){\n  int n,m,fr[10000],to[10000],co[10000],a,b,c,d,i;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<m*2;i+=2){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    fr[i]=to[i+1]=a-1;\n    to[i]=fr[i+1]=b-1;\n    co[i]=c;\n    co[i+1]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n  dijk(n,m*2,fr,to,co,a-1);\n  c-=d+CO[b-1];\n  //for(i=0;i<n;i++)printf(\"%d \",CO[i]);printf(\"\\n\");\n  dijk(n,m*2,fr,to,co,b-1);\n  printf(\"%d\\n\",c-CO[a-1]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\nint min(int a,int b){return a<b?a:b;}\nint main(void)\n{\n  int n,m,mat[20][20],i,j,k,a,b,c,d;\n  scanf(\"%d%d\",&n,&m);\n  rep(i,n)rep(j,n)mat[i][j]=i-j?1<<21:0;\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  rep(i,n)rep(j,n)rep(k,n)mat[j][k]=min(mat[j][k],mat[j][i]+mat[i][k]);\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--,b--;\n  printf(\"%d\\n\",c-mat[a][b]-mat[b][a]-d);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,min=200001,d[21][21]={0};\nint u(int t[21],int g,int h,int m){\n  int i,j;\n  t[g]=1;\n  for(i=1;i<=n;i++){\n    if(d[g][i]!=0){\n      if(t[i]==0){\n\th+=d[g][i];\n\tif(i==m){\n\t  if(min>h)min=h;\n\t}\n\telse \tmin=u(t,i,h,m);\n\th-=d[g][i];\n      }\n    }\n  }\n  t[g]=0;\n  return min;\n}   \nint main(){\n  int a,b,c,e,x1,x2,y1,y2,h,i;\n  scanf(\"%d\\n%d\",&n,&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&e);\n    d[a][b]=c;\n    d[b][a]=e;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  int t[21]={0};\n  y1-=u(t,x1,0,x2);\n  min=200001;\n  for(i=0;i<21;i++){\n    t[i]=0;\n  }\n  y1-=y2;\n  y1-=u(t,x2,0,x1);\n  printf(\"%d\\n\",y1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[21][21]={0};\n  int n,l,i,j,r;\n  int a,b,e,d;\n  int c[21][2]={0};\n  int q[21]={0};\n  scanf(\"%d\\n%d\",&n,&l);\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  e-=d;\n  q[0]=a;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=a){\n\tq[r++]=j;\n\tif(c[j][0]==0)c[j][0]=c[q[i]][0]+m[q[i]][j];\n\telse if(c[j][0]>c[q[i]][0]+m[q[i]][j]){\n\t  c[j][0]=c[q[i]][0]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  // for(i=0;i<n;i++)printf(\"%d \",c[i+1][0]);\n  e-=c[b][0];\n  q[0]=b;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=b){\n\tq[r++]=j;\n\tif(c[j][1]==0)c[j][1]=c[q[i]][1]+m[q[i]][j];\n\telse if(c[j][1]>c[q[i]][1]+m[q[i]][j]){\n\t  c[j][1]=c[q[i]][1]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  e-=c[a][1];\n  printf(\"%d\\n\",e);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define PMAX 100\n#define TMAX 21\n#define INF 1001\n\nvoid initary( int table[TMAX][TMAX] )\n{\n\tfor ( int i = 0 ; i < TMAX ; i++ ) {\n\t\tfor ( int j = 0 ; j < TMAX ; j++ ) {\n\t\t\ttable[i][j] = ( int ) INF;\n\t\t}\n\t}\t\n}\n\nint main()\n{\n\tint n = 0, m = 0, i = 0, s = 0, g = 0, V = 0, p = 0;\n\tint path[TMAX][TMAX];\n\tint a = 0, b = 0;\n\n\tinitary( path );\n\tscanf( \"%d\", &n );\n\tif ( n > 20 )  { return 0; }\n\tscanf( \"%d\", &m );\n\tif ( m > 100 ) { return 0; }\n\n\twhile ( i < m ) {\n\t\tscanf( \"%d,%d,\", &a, &b );\n\t\tscanf( \"%d,%d\", &path[a-1][b-1], &path[b-1][a-1] );\n\t\ti++;\n\t}\n\tscanf( \"%d,%d,%d,%d\", &s, &g, &V, &p );\n\n\t/*\n\tfor ( int j = 0 ; j < n ; j++ ) {\n\t\tfor ( int k = 0 ; k < n ; k++ ) {\n\t\t\tprintf( \"%4d \", path[j][k] );\n\t\t}\n\t\tprintf( \"\\n\" );\n\t}\n\t*/\n\n\t// ワーシャルフロイド\n\tfor ( int j = 0 ; j < n ; j++ ) {\n\t\tfor ( int k = 0 ; k < n ; k++ ) {\n\t\t\tfor ( int l = 0 ; l < n ; l++ ) {\n\t\t\t\tif ( path[j][k]+path[l][j] > path[l][k] ) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\tpath[l][k] = path[j][k] + path[l][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// printf( \"GO:%2d RET:%2d\\n\", path[s-1][g-1], path[g-1][s-1]);\n\tprintf( \"%d\\n\", V - ( path[s-1][g-1]+path[g-1][s-1]+p ) );\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define INFTY 1<<21\n#define rep(i,n) for(i=0;i<n;i++)\nint mat[20][20];\nint dijkstra(int s,int g,int n)\n{\n  int cost[20],id,i,c;\n  char used[20]={0};\n  memset(cost,0x5f,sizeof(cost));cost[s]=0;\n  for(;id=-1;){\n    rep(i,n)if(!used[i]&&(id==-1||cost[i]<cost[id]))id=i;\n    if(id<0)break;\n    used[id]=1;\n    rep(i,n){\n      c=cost[id]+mat[id][i];\n      if(cost[i]>c)cost[i]=c;\n    }\n  }\n  return cost[g];\n}\nint main(void)\n{\n  int n,m,a,b,c,d,i;\n  scanf(\"%d%d\",&n,&m);\n  memset(mat,0x5f,sizeof(mat));\n  rep(i,m){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--;b--;\n    mat[a][b]=c;mat[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);a--;b--;\n  printf(\"%d\\n\",c-dijkstra(a,b,n)-dijkstra(b,a,n)-d);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 20\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n\nstatic int n;\nstatic int d[ N ][ N ];\n\nstatic int k_operafan[ N ];\n\nstatic int\ndpFSA (\n  int p,\n  int t,\n  int rebirth\n  )\n{\n  int i;\n\n  if ( p == t ) return ( 0 );\n\n  if ( ~k_operafan[ p ] ) ;\n  else\n  {\n    k_operafan[ p ] = INT_MAX / 2;\n\n    for ( i = 0; i < n; ++i )\n    {\n      int tmp;\n\n      if ( d[ p ][ i ] == -1\n        || ( rebirth != -1\n          && rebirth == i ) ) continue ;\n\n      tmp = dpFSA ( i, t, rebirth ) + d[ p ][ i ];\n      k_operafan[ p ] = MIN( k_operafan[ p ], tmp );\n    }\n  }\n\n  return ( k_operafan[ p ] );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int m, x1, x2, y1, y2;\n  int res;\n\n  scanf ( \"%d %d\", &n, &m );\n  memset ( d, -1, sizeof ( d ) );\n  while ( m-- )\n  {\n    int a, b, c1, c2;\n\n    scanf ( \" %d,%d,%d,%d\", &a, &b, &c1, &c2 );\n    d[ a - 1 ][ b - 1 ] = c1;\n    d[ b - 1 ][ a - 1 ] = c2;\n  }\n  scanf ( \" %d,%d,%d,%d\", &x1, &x2, &y1, &y2 );\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  res  = dpFSA ( x1 - 1, x2 - 1, -1 );\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  res += dpFSA ( x2 - 1, x1 - 1, -1 );\n  printf ( \"%d\\n\", y1 - y2 - res );\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "main(){\n    int i,n,m,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&m);\n        memset(dist,11,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(k=m;k>=0;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n for(k=m;k>=0;k--){\n        {\n            int k,i,j;\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n }\n        {\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,l,a,b,o,h,min,mi;\n  int d[30][30],f[30][2],c[30][2],s[2];\n  scanf(\"%d %d\",&n,&m);\n  for(i=1;i<=n;i++){\n    for(j=1;j<=n;j++)d[i][j]=100000000;\n    c[i][0]=c[i][1]=100000000;\n    f[i][0]=f[i][1]=0;\n  }\n  while(m--){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&o,&h);\n    d[a][b]=o;\n    d[b][a]=h;\n  }\n  scanf(\"%d,%d,%d,%d\",&s[0],&s[1],&h,&o);\n  h-=o;\n  for(l=0;l<2;l++){\n    c[mi=s[l]][l]=0;\n    for(i=0;i<n;i++){\n      f[mi][l]=1;\n      for(j=1;j<=n;j++){\n\tif(f[j][l])continue;\n\tif(c[j][l]>c[mi][l]+d[mi][j])c[j][l]=c[mi][l]+d[mi][j];\n      }\n      min=2100000000;\n      for(j=1;j<=n;j++){//printf(\"%d \",c[j][l]);\n\tif(f[j][l])continue;\n\tif(min>c[j][l])min=c[mi=j][l];\n      }//printf(\"\\n\");\n    }//printf(\"\\n\");\n    h-=c[s[1-l]][l];\n  }\n  printf(\"%d\\n\",h);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n    int i,n,k,a,b,A,B,dist[101][101];\n    scanf(\"%d%d\",&n,&k);\n        /*initialize*/\n        memset(dist,11,sizeof(dist));\n        for(i=1;i<=n;i++)dist[i][i]=0;\n        for(;k;k--){\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            dist[a][b]=A,dist[b][a]=B;\n        }\n \n        {/*warshall-floyd*/\n            int k,i,j;\n            for(k=1;k<=n;k++)\n                for(i=1;i<=n;i++)\n                    for(j=1;j<=n;j++)\n                        if(dist[i][j]>dist[i][k]+dist[k][j])\n                            dist[i][j]=dist[i][k]+dist[k][j];\n        }\n \n        {/*query*/\n            scanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n            printf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n        }\n    exit(0);\n}              "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nint main(){\n  int ta[25]={0};\n  int to[500],ne[500],co[500];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){\n    int u[30];\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;\n    h[u[a]=0]=-M;\n    while(1){\n      for(j=ta[a];j;j=ne[j]){\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];\n\t}\n      }\n      a=h[j=1]%30;\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[21][21]={0};\n  int n,l,i,j,r;\n  int a,b,e,d;\n  int c[21][2]={0};\n  int q[1000]={0};\n  scanf(\"%d\\n%d\",&n,&l);\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  e-=d;\n  q[0]=a;\n  r=1;\n  for(i=0;i<10000;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=a){\n\tq[r++]=j;\n\tif(c[j][0]==0)c[j][0]=c[q[i]][0]+m[q[i]][j];\n\telse if(c[j][0]>c[q[i]][0]+m[q[i]][j]){\n\t  c[j][0]=c[q[i]][0]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  //for(i=0;i<n;i++)printf(\"%d \",c[i+1][0]);\n  e-=c[b][0];\n  q[0]=b;\n  r=1;\n  for(i=0;i<10000;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=b){\n\tq[r++]=j;\n\tif(c[j][1]==0)c[j][1]=c[q[i]][1]+m[q[i]][j];\n\telse if(c[j][1]>c[q[i]][1]+m[q[i]][j]){\n\t  c[j][1]=c[q[i]][1]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  for(i=0;i<n;i++)printf(\"%d \",c[i+1][1]);\n  e-=c[a][1];\n  printf(\"%d\\n\",e);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define INF 10000000\n#define N 21\n\n#define error(s) do{fprintf(stderr , s); exit(-1);}while(0)\n\nint M[N][N],a[N][N],W[N][N],p[N][N];;\n\nvoid floyd(void);\nvoid path(int i, int j,int *y1 );\n\nint main(){\n\tint i,j,n,m,a1,b,c,d,x1,x2,y1,y2;\n\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 1 ; j < N ; j++){\n\t\t\tM[i][j] = 0;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\n\tfor(i = 0 ; i < m ; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a1,&b,&c,&d);\n\t\tM[a1][b] = c;\n\t\tM[b][a1] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tif(i == j){\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tW[i][j] = 0;\n\t\t\t}\n\t\t\telse if(M[i][j] == 0){\n\t\t\t\ta[i][j] = INF;\n\t\t\t\tW[i][j] = INF;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = M[i][j];\n\t\t\t\tW[i][j] = M[i][j];\n\t\t\t}\n\n\t\t\tif(W[i][j] != INF){\n\t\t\t\tp[i][j] = j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i][j] = -1;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfloyd();\n\tpath(x1,x2,&y1);\n\ty1 -= y2;\n\tpath(x2,x1,&y1);\n\n\tprintf(\"%d\\n\",y1);\n\treturn 0;\n}\n\nvoid floyd(void){\n\tint i , j , k ;\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\ta[i][j] = W[i][j];\n\t\t}\n\t}\n\n\tfor(k = 0 ; k < N ; k++){\n\t\tfor(i = 0 ; i < N ; i++){\n\t\t\tfor(j = 0 ; j < N ; j++){\n\t\t\t\tif(a[i][k] + a[k][j] < a[i][j]){\n\t\t\t\t\ta[i][j] = a[i][k] + a[k][j];\n\t\t\t\t\tp[i][j] = p[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid path(int i, int j ,int *y1){\n\tint tmp,k = i;\n\ttmp = k;\n\twhile(p[k][j] != j && p[k][j] != -1){\n\t\tk = p[k][j];\n\t\t*y1 -= M[tmp][k];\n\t\ttmp = k;\n\t}\n\tif(p[k][j] == -1)error(\"No Path\");\n\t*y1 -= M[k][j];\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,a,b,d,e,min,mj,i,j,l,k;\n  int f[21]={0};\n  int m[21][21]={0};\n  int c[21];\n  scanf(\"%d %d\",&n,&l);\n  for(i=0;i<n;i++){\n    c[i+1]=2100000000;\n    for(j=0;j<n;j++)m[i+1][j+1]=-1;\n  }\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  f[a]=1;\n  c[a]=0;\n  mj=a;\n  for(i=1;i<=n;i++){\n    for(j=1;j<=n;j++){\n      if(f[j])continue;//printf(\"j%d\\n\",j);\n      if(m[mj][j]!=-1){//道あったら\n\tif(c[j]>c[mj]+m[mj][j])c[j]=c[mj]+m[mj][j];//printf(\"j%d\\n\",j);\n      }//小さい方入れる\n    }\n    min=2100000000;\n    for(j=1;j<=n;j++){\n      if(f[j])continue;\n      if(min>c[j]){\n\tmin=c[j];\n\tmj=j;\n      }\n    }//printf(\"mj%d\\n\",mj);\n    f[mj]=1;\n    //for(k=0;k<n;k++)printf(\"%d \",c[k+1]);//printf(\"\\n\");\n  }\n  e-=c[b]+d;//printf(\"%d\\n\",c[b]);\n  for(i=0;i<n;i++)c[i+1]=2100000000;\n  f[b]=2;\n  c[b]=0;\n  mj=b;//for(i=1;i<=n;i++)printf(\"%d \",f[i]);//printf(\"\\n\");\n  for(i=1;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(f[j]==2)continue;\n      if(m[mj][j]!=-1){//道あったら\n\tif(c[j]>c[mj]+m[mj][j])c[j]=c[mj]+m[mj][j];\n      }//小さい方入れる\n    }\n    min=2100000000;\n    for(j=1;j<=n;j++){\n      if(f[j]==2)continue;\n      if(min>c[j]){\n\tmin=c[j];\n\tmj=j;\n      }\n    }\n    f[mj]=2;\n    //for(k=0;k<n;k++)printf(\"%d \",c[k+1]);printf(\"\\n\");\n  }\n  printf(\"%d\\n\",e-c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } //*/\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30];//,f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;1;i++){//printf(\"a\\n\");\n      //f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      a=h[j=1]%30;\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }//printf(\"a==%d\\n\",a);\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "n,e[999],*p,*r,d[21];\nB(s){\n\tmemset(d,1,84);\n\td[s]=0;\n\tfor(s=n;--s;){\n\t\tfor(p=e;r-p;p+=4){\n\t\t\td[p[0]]=fmin(d[p[0]],d[p[1]]+p[3]);\n\t\t\td[p[1]]=fmin(d[p[1]],d[p[0]]+p[2]);\n\t\t}\n\t}\n}\nmain(t,s){\n\tscanf(\"%d%*d\",&n);\n\tfor(r=e;~scanf(\"%d,\",r++););\n\tr-=5;\n\tB(r[0]),t=d[s=r[1]],B(s);\n\tn=!printf(\"%d\\n\",r[2]-r[3]-t-d[r[0]]);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nint min(int,int);\nvoid warshall_floyd(void);\n\nint graph[21][21],visit[21][21];\nint V;\n\nint main(void){\n  int i,j,road,a,b,c,d;\n  int x1,x2,y1,y2;\n  for(i=0;i<21;i++){\n    for(j=0;j<21;j++){\n      graph[i][j]=INF;\n      visit[i][j]=0;\n    }\n  }\n  \n  scanf(\"%d\",&V);\n  scanf(\"%d\",&road);\n  for(i=0;i<road;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    graph[a][b]=c;\n    graph[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  warshall_floyd();\n\n    printf(\"%d\\n\",y1-(graph[x1][x2]+graph[x2][x1])-y2);\n\n  return 0;\n}\n\nint min(int x,int y){\n  return (x>y)?y:x;\n}\n\nvoid warshall_floyd(){\n  int i,j,k;\n  for(k=0;k<=V;k++)\n    for(i=0;i<=V;i++)\n      for(j=0;j<=V;j++)\n\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;D(S,G){int c[21],f[21]={0};for(memset(c,1,84),c[S]=0;S;){for(i=n+1;--i;c[i]=c[S]+g[S][i]<?c[i])f[S]=1;for(S=i=0;++i<=n;)S=f[i]|c[i]>c[S]?S:i;}return c[G];}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);~i--;~i&&(g[x][X]=y,g[X][x]=Y))scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y);exit(!printf(\"%d\\n\",y-Y-D(x,X)-D(X,x)));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<memory.h>\nint n, g[21][21];\nint dijkstra(start, goal){\n\tint c[21], f[21]={0}, i, nearest, t;\n\tmemset(c, 1, sizeof(c));\n\tc[start] = 0;\n\twhile(1){\n\t\tnearest=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(!f[i] && (!nearest || c[i]<c[nearest]))\n\t\t\t\tnearest=i;\n\t\t}\n\t\tif(!nearest)\n\t\t\treturn c[goal];\n\t\tf[nearest]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tt=c[nearest]+g[nearest][i];\n\t\t\tif(t<c[i])\n\t\t\t\tc[i]=t;\n\t\t}\n\t}\n}\nint main(){\n\tint m, x1, x2, y1, y2;\n\tint i, c12, c21;\n\tmemset(g, 1, sizeof(g));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0; i < m; i ++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tg[a][b] = c;\n\t\tg[b][a] = d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tc12 = dijkstra(x1, x2);\n\tc21 = dijkstra(x2, x1);\n\tprintf(\"%d\\n\", y1-y2-c12-c21);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;m,x,X,y,Y;D(S,G){int c[21],f[21]={0},d,t;memset(c,1,84);for(c[S]=0;;){for(d=i=0;++i<=n;)d=f[i]||d&&c[i]>=c[d]?d:i;if(!d)return c[G];f[d]=1;for(i=n+1;--i;c[i]=t<c[i]?t:c[i])t=c[d]+g[d][i];}}main(){memset(g,1,1764);scanf(\"%d%d\",&n,&i);for(i++;i--;i&&(g[x][X]=y,g[X][x]=Y))scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y);exit(!printf(\"%d\\n\",y-Y-D(x,X)-D(X,x)));}"
  },
  {
    "language": "C",
    "code": "e[999],*p,*r,*q,d[21];B(s){d[s]=!memset(d,1,84);for(s=*e;--s;)for(p=e+2;r-p;p+=4)q=d+p[1],d[*p]=fmin(d[*p],*q+p[3]),*q=fmin(*q,d[*p]+p[2]);}main(t){for(r=e;~scanf(\"%d,\",r++););r-=5;B(*r),t=d[r[1]],B(r[1]);p=!printf(\"%d\\n\",r[2]-r[3]-t-d[*r]);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[21][21]={0};\n  int n,l,i,j,r;\n  int a,b,e,d;\n  int c[21][2]={0};\n  int q[21]={0};\n  scanf(\"%d\\n%d\",&n,&l);\n  for(i=0;i<l;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n    m[a][b]=e;\n    m[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&e,&d);\n  e-=d;\n  q[0]=a;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=a){\n\tq[r++]=j;\n\tif(c[j][0]==0)c[j][0]=c[q[i]][0]+m[q[i]][j];\n\telse if(c[j][0]>c[q[i]][0]+m[q[i]][j]){\n\t  c[j][0]=c[q[i]][0]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  // for(i=0;i<n;i++)printf(\"%d \",c[i+1][0]);\n  e-=c[b][0];\n  q[0]=b;\n  r=1;\n  for(i=0;i<n;i++){\n    for(j=1;j<=n;j++){\n      if(m[q[i]][j]!=0&&j!=b){\n\tq[r++]=j;\n\tif(c[j][1]==0)c[j][1]=c[q[i]][1]+m[q[i]][j];\n\telse if(c[j][1]>c[q[i]][1]+m[q[i]][j]){\n\t  c[j][1]=c[q[i]][1]+m[q[i]][j];\n\t}\n      }\n    }\n  }\n  e-=c[a][1];\n  printf(\"%d\\n\",e);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 999\n\nint main()\n{\n\tint N,V,graph[20][20],node[20],node2[20],s,t,x,y,i,j,f,g;\n\n\tscanf(\"%d%d\",&V,&N);\n\tfor(i=0;i<V;i++)\n\t{\n\t\tfor(j=0;j<V;j++)\n\t\t\tgraph[i][j]=INF;\n\t\tnode[i]=node2[i]=INF;\n\t}\n\tfor(i=0;i<=N;i++)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\",&s,&t,&x,&y);\n\t\ts--,t--;\n\t\tif(i!=N)\n\t\t{\n\t\t\tgraph[s][t]=x;\n\t\t\tgraph[t][s]=y;\n\t\t}\n\t}\n\tnode[s]=node2[t]=0;\n\twhile(1)\n\t{\n\t\tf=g=0;\n\t\tfor(i=0;i<V;i++)\n\t\t\tfor(j=0;j<V;j++)\n\t\t\t{\n\t\t\t\tif(node[i]!=INF&&graph[i][j]!=INF&&node[j]>node[i]+graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tf=1;\n\t\t\t\t\tnode[j]=node[i]+graph[i][j];\n\t\t\t\t}\n\t\t\t\tif(node2[i]!=INF&&graph[i][j]!=INF&&node2[j]>node2[i]+graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tg=1;\n\t\t\t\t\tnode2[j]=node2[i]+graph[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\tif(!f&&!g)\n\t\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",x-y-node[t]-node2[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<60;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int INF = 1000000000;\n\nint main(void) {\n    int edge[21][21];\n    int n, m, a, b, c, d;\n    int x1, x2, y1, y2;\n    int i, j, k;\n\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n\n    for (i = 1; i <= n; i++)\n        for (j = 1; j <= n; j++)\n            edge[i][j] = INF;\n\n    for (i = 0; i < m; i++) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        edge[a][b] = c;\n        edge[b][a] = d;\n    }\n\n    scanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\n    for (k = 1;  k <= n; k++)\n        for (i = 1; i <= n; i++)\n            for (j = 1; j <= n; j++)\n                if (edge[i][j] > edge[i][k] + edge[k][j])\n                    edge[i][j] = edge[i][k] + edge[k][j];\n\n    printf(\"%d\\n\", y1 - y2 - edge[x1][x2] - edge[x2][x1]);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[500],ne[500],co[500];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};\n    h[0]=-M;\n    r=1;//printf(\"%d\\n\",n);\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 2000000000\nint main(void)\n{\n\tint n,m;\n\tint data[21][21];\n\tint a,b,c,d;\n\tint x,y,x1,y1;\n\tint i,j,k,temp;\n\tint min,p;\n\tint flg[21],leng[21];\n\t\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tdata[i][j]=MAX;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tdata[a][b]=c;\n\t\tdata[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&x,&x1,&y,&y1);\n\ty=y-y1;\n\tfor(k=0;k<2;k++){\n\t\tfor(i=1;i<=n;i++){\n\t\t\tleng[i]=MAX;\n\t\t\tflg[i]=0;\n\t\t}\n\t\tleng[x]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tmin=MAX;\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(flg[j]==0 && leng[j]<min){\n\t\t\t\t\tp=j;\n\t\t\t\t\tmin=leng[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p==x1){\n\t\t\t\ty=y-min;\n\t\t\t}\n\t\t\tflg[p]=1;\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(leng[j]>leng[p]+data[p][j]){\n\t\t\t\t\tleng[j]=leng[p]+data[p][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttemp=x;\n\t\tx=x1;\n\t\tx1=temp;\n\t}\n\tprintf(\"%d\\n\",y);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define NODE (20)\n#define INF (100000000)\n\nint U[NODE];\nint dist[NODE];\nint prev[NODE];\nint cost[NODE][NODE];\nint V;\n\nvoid dijkstra(int s)\n{\n\tint i, j;\n\tint v;\n\t\n\tdist[s] = 0;\n\tprev[s] = 0;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tU[i] = 1;\n\t}\n\t\n\tfor (i = 0; i < V; i++){\n\t\tv = -1;\n\t\t\n\t\tfor (j = 0; j < V; j++){\n\t\t\tif (U[j] == 1 && (v == -1 || dist[v] > dist[j])){\n\t\t\t\tv = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tU[v] = 0;\n\t\t\n\t\tfor (j = 0; j < V; j++){\n\t\t\tif ((dist[j] > dist[v] + cost[v][j]) && U[j] == 1){\n\t\t\t\tdist[j] = dist[v] + cost[v][j];\n\t\t\t\tprev[j] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint i, j;\n\tint n;\n\tint from, to, m, mm, sum;\n    \n\tscanf(\"%d\", &V);\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 0; i < V; i++){\n\t    for (j = 0; j < V; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tdist[i] = INF;\n\t}\n\t\n\twhile (n-- != 0){\n\t\tscanf(\"%d,%d,%d,%d\", &from, &to, &m, &mm);\n\t\tcost[from - 1][to - 1] = m;\n        cost[to - 1][from - 1] = mm;\n\t}\n\tscanf(\"%d,%d,%d,%d\", &from, &to, &m, &mm);\n\tdijkstra(from - 1);\n\tsum = dist[to - 1];\n    \n    for (i = 0; i < V; i++){\n        dist[i] = INF;\n    }\n    dijkstra(to - 1);\n    sum += dist[from - 1];\n    \n\tprintf(\"%d\\n\", m - mm - sum);\n    \n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nint min(int,int);\nvoid warshall_floyd(void);\n\nint graph[21][21];\nint V;\n\nint main(void){\n  int i,j,road,a,b,c,d;\n  int x1,x2,y1,y2;\n  for(i=0;i<21;i++){\n    for(j=0;j<21;j++){\n      graph[i][j]=INF;\n    }\n  }\n  \n  scanf(\"%d\",&V);\n  scanf(\"%d\",&road);\n  for(i=0;i<road;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    graph[a][b]=c;\n    graph[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  warshall_floyd();\n\n    printf(\"%d\\n\",y1-graph[x1][x2]-graph[x2][x1]-y2);\n\n  return 0;\n}\n\nint min(int x,int y){\n  return (x>y)?y:x;\n}\n\nvoid warshall_floyd(){\n  int i,j,k;\n  for(k=0;k<=V;k++)\n    for(i=0;i<=V;i++)\n      for(j=0;j<=V;j++)\n\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=0;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n  } //*/\nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  //for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};//printf(\"%d\\n\",n);\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      //f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      a%=n;\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*n+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*n+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      //while(f[a%10]){//printf(\"a==%d\\n\",a);\n      a=h[j=1];\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }//printf(\"a==%d\\n\",a);\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int INF = 1000000000;\n\nint main(void)\n{\n\tint edge[21][21];\n\tint n, m, a, b, c, d;\n\tint x1, x2, y1, y2;\n\tint i, j, k;\n\t\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\t\n\tfor (i = 0; i <= n; i++){\n\t\tfor (j = 0; j <= n; j++){\n\t\t\tedge[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tedge[a][b] = c;\n\t\tedge[b][a] = d;\n\t}\n\t \n\tscanf(\"%d,%d,%d,%d\", &x1, &x2, &y1, &y2);\n\t\n\tfor (k = 1;  k <= n; k++){\n\t\tfor (i = 1; i <= n; i++){\n\t\t\tfor (j = 1; j <= n; j++){\n\t\t\t\t\n\t\t\t\tif (edge[i][j] > edge[i][k] + edge[k][j]){\n\t\t\t\t\tedge[i][j] = edge[i][k] + edge[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", y1 - y2 - edge[x1][x2] - edge[x2][x1]);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 0\n\nint main(void)\n{\n\tint N, V, graph[20][20], node[20], node2[20], s, t, x, y,i, j, f, g;\n\t\n\tscanf(\"%d%d\", &V, &N);\n\tfor (i = 0; i < V; i++)\n\t{\n\t\tfor (j = 0; j < V; j++)\n\t\t\tgraph[i][j] = INF;\n\t\tnode[i] = node2[i] = INF;\n\t}\n\tfor (i = 0; i <= N; i++)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\", &s, &t, &x, &y);\n\t\ts--;\n\t\tt--;\n\t\tif (i != N)\n\t\t{\n\t\t\tgraph[s][t] = x;\n\t\t\tgraph[t][s] = y;\n\t\t}\n\t}\n\tnode[s] = node2[t] = 0;\n\twhile (1)\n\t{\n\t\tf = g = 0;\n\t\tfor (i = 0; i < V; i++)\n\t\t\tfor (j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tif (node[i] != INF && graph[i][j] != INF && node[j] > node[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tf = 1;\n\t\t\t\t\tnode[j] = node[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t\tif (node2[i] != INF && graph[i][j] != INF && node2[j] > node2[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tg = 1;\n\t\t\t\t\tnode2[j] = node2[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f && !g)\n\t\t\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", x - y - node[t] - node2[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[1000],ne[1000],co[1000];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};\n    r=1;//printf(\"%d\\n\",n);\n    for(i=0;i<n;i++)u[i]=h[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[600]={-M};\nint main(){\n  int ta[25]={0};\n  int to[500],ne[500],co[500];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){\n    int u[30];\n    for(i=r=1;i<6000;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;\n    h[u[a]=0]=-M;\n    while(1){\n      for(j=ta[a];j;j=ne[j]){\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];\n\t}\n      }\n      a=h[j=1]%30;\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,m,l,x,y,build[1001][2],assign[1001],assign2[1001],prev[1001][1001];\ndouble route[11][1001][1001];\n\nvoid backtrack(int from,int to){\n\tint z=prev[from][to];\n\n\tif(from==to)return;\n\tif(z==from){\n\t\tprintf(\"%d \",assign[from]);\n\t\treturn;\n\t}\n\tbacktrack(from,z);\n\tbacktrack(z,to);\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)*n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d\",&assign[i],&build[i][0],&build[i][1]);\n\t\t\tassign2[assign[i]]=i;\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tl=(build[i][0]-build[j][0])*(build[i][0]-build[j][0])+(build[i][1]-build[j][1])*(build[i][1]-build[j][1]);\n\t\t\t\tif(l<=2500){\n\t\t\t\t\troute[0][i][j]=sqrt((double)l);\n\t\t\t\t\troute[0][j][i]=sqrt((double)l);\n\t\t\t\t\tprev[i][j]=i;\n\t\t\t\t\tprev[j][i]=j;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\troute[0][i][j]=999999999;\n\t\t\t\t\troute[0][j][i]=999999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(l=1;pow(2.0,l)<n-1;l++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\troute[l][i][j]=route[l-1][i][j];\n\t\t\t\t\tfor(k=0;k<n-1;k++){\n\t\t\t\t\t\tif(route[l][i][j]>route[l-1][i][k]+route[l-1][k][j]){\n\t\t\t\t\t\t\troute[l][i][j]=route[l-1][i][k]+route[l-1][k][j];\n\t\t\t\t\t\t\tprev[i][j]=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tl--;\n\n\t\tfor(scanf(\"%d\",&m);m>0;m--){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tx=assign2[x];\n\t\t\ty=assign2[y];\n\t\t\tif(x==y){\n\t\t\t\tprintf(\"%d\\n\",assign[y]);\n\t\t\t}\n\t\t\telse if(route[l][x][y]<999999999){\n\t\t\t\tbacktrack(x,y);\n\t\t\t\tprintf(\"%d\\n\",assign[y]);\n\t\t\t}\n\t\t\telse printf(\"NA\\n\");\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[30][30],n;\nint f(int mi,int t){//printf(\"%d %d\",\n  int i,j,c[30],u[30]={0};\n  for(i=0;i<30;i++)c[i]=1e8;\n  c[mi]=0;\n  for(i=0;i<n;i++){\n    for(j=u[mi]=1;j<=n;j++){\n      if(c[j]>c[mi]+d[mi][j])c[j]=c[mi]+d[mi][j];\n    }\n    for(mi=1;u[mi];mi++);\n    for(j=mi;j<=n;j++){\n      if(u[j]==0&&c[mi]>c[j])mi=j;\n    }\n  }\n  return c[t];\n}\nint main(){\n  int m,i,j,a,b;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<900;i++)d[i/30][i%30]=1e8;\n  while(m--){\n    scanf(\"%d,%d,\",&i,&j);\n    scanf(\"%d,%d\",&d[i][j],&d[j][i]);\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&i,&j);\n  printf(\"%d\\n\",i-f(b,a)-f(a,b)-j);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1\n\nint main(void)\n{\n\tint N, V, graph[20][20], node[20], node2[20], s, t, x, y,i, j, f, g;\n\t\n\tscanf(\"%d%d\", &V, &N);\n\tfor (i = 0; i < V; i++)\n\t{\n\t\tfor (j = 0; j < V; j++)\n\t\t\tgraph[i][j] = INF;\n\t\tnode[i] = node2[i] = INF;\n\t}\n\tfor (i = 0; i <= N; i++)\n\t{\n\t\tscanf(\"%d,%d,%d,%d\", &s, &t, &x, &y);\n\t\ts--;\n\t\tt--;\n\t\tif (i != N)\n\t\t{\n\t\t\tgraph[s][t] = x;\n\t\t\tgraph[t][s] = y;\n\t\t}\n\t}\n\tnode[s] = node2[t] = 0;\n\twhile (1)\n\t{\n\t\tf = g = 0;\n\t\tfor (i = 0; i < V; i++)\n\t\t\tfor (j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tif (node[i] != INF && graph[i][j] != INF && node[j] > node[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tf = 1;\n\t\t\t\t\tnode[j] = node[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t\tif (node2[i] != INF && graph[i][j] != INF && node2[j] > node2[i] + graph[i][j])\n\t\t\t\t{\n\t\t\t\t\tg = 1;\n\t\t\t\t\tnode2[j] = node2[i] + graph[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f && !g)\n\t\t\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", x - y - node[t] - node2[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n#define min(a, b) a<b?a:b\n\nint road[20][20];\n\nint main(void)\n{\n    int i, j, k, n, m, a, b, c, d, cost, money;\n    scanf(\"%d %d\", &n, &m);\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            road[i][j] = INF;\n        }\n    }\n    for (i = 0; i < m; i++) {\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        road[a-1][b-1] = c;\n        road[b-1][a-1] = d;\n    }\n    scanf(\"%d,%d,%d,%d\", &a, &b, &money, &cost);\n    for (k = 0; k < n; k++) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\", money - cost - road[a-1][b-1] - road[b-1][a-1]);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "g[24][21],*p;x,X,y,Y;m,i,j,c;main(n){for(memset(g,scanf(\"%d%d\",&n,&m),2e3);scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y),m--;g[X][x]=Y)g[x][X]=y;for(m=++n;--m;)for(i=n;--i;)for(j=n,p=g[i];--j;p[j]=p[j]<c?p[j]:c)c=p[m]+g[m][j];exit(!printf(\"%d\\n\",y-Y-g[x][X]-g[X][x]));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<memory.h>\nint n, g[21][21];\n#define min(x,y)((x)<(y)?(x):(y))\nvoid floyd(){\n\tint i,j,k;\n\tfor(k=1;k<=n;k++){\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint m, x1, x2, y1, y2;\n\tint i;\n\tmemset(g, 1, sizeof(g));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0; i < m; i ++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tg[a][b] = c;\n\t\tg[b][a] = d;\n\t}\n\tfloyd();\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tprintf(\"%d \\n\", y1-y2-g[x1][x2]-g[x2][x1]);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n\tint i,n,k,a,b,A,B,dist[101][101];\n\tscanf(\"%d%d\",&n,&k);\n\t\t/*initialize*/\n\t\tmemset(dist,11,sizeof(dist));\n\t\tfor(i=1;i<=n;i++)dist[i][i]=0;\n\t\tfor(;k;k--){\n\t\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n\t\t\tdist[a][b]=A,dist[b][a]=B;\n\t\t}\n\t\t\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\t\t\n\t\t{/*query*/\n\t\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&A,&B);\n\t\t\tprintf(\"%d\\n\",A-B-dist[a][b]-dist[b][a]);\n\t\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nint min(int,int);\nvoid warshall_floyd(void);\n\nint graph[21][21];\nint V;\n\nint main(void){\n  int i,j,road,a,b,c,d;\n  int x1,x2,y1,y2;\n  for(i=0;i<21;i++)\n    for(j=0;j<21;j++)\n      graph[i][j]=INF;\n  \n  scanf(\"%d\",&V);\n  scanf(\"%d\",&road);\n  for(i=0;i<road;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    graph[a][b]=c;\n    graph[b][a]=d;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n  warshall_floyd();\n\n    printf(\"%d\\n\",y1-graph[x1][x2]-graph[x2][x1]-y2);\n\n  return 0;\n}\n\nint min(int x,int y){\n  return (x>y)?y:x;\n}\n\nvoid warshall_floyd(){\n  int i,j,k;\n  for(k=0;k<=V;k++)\n    for(i=0;i<=V;i++)\n      for(j=0;j<=V;j++)\n\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[60]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[400],ne[400],co[400];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};\n    h[0]=-M;\n    r=1;//printf(\"%d\\n\",n);\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n     }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[400],ne[400],co[400];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};\n    h[0]=-M;\n    r=1;//printf(\"%d\\n\",n);\n    for(i=0;i<n;i++)u[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n     }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 100000\nint main(){\n\tint map, load[21][21], i, j, k, a, b, c, d, manyload;\n\tint money;\n\tscanf(\"%d\", &map);\n\tfor(i = 1; i <= map; i++){\n\t\tfor(j = 1; j <= map; j++) load[i][j] = MAX;\n\t}\n\tscanf(\"%d\", &manyload);\n\tfor(i = 0; i < manyload; i++){\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\tload[a][b] = c;\n\t\tload[b][a] = d;\n\t}\n\tfor(i = 1; i <= map; i++){\n\t\tfor(j = 1; j <= map; j++){\n\t\t\tfor(k = 1; k <= map; k++){\n\t\t\t\tif(load[j][k] > load[j][i] + load[i][k]) load[j][k] = load[j][i] + load[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\tprintf(\"%d\\n\", c - d - load[a][b] - load[b][a]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,min=200001,d[21][21]={0};\nint u(int t[21],int g,int h,int m){\n  int i,j;\n  t[g]=1;\n  for(i=1;i<=n;i++){\n    if(d[g][i]!=0){\n      if(t[i]==0){\n\th+=d[g][i];\n\tif(i==m){\n\t  if(min>h)min=h;\n\t}\n\telse \tmin=u(t,i,h,m);\n\th-=d[g][i];\n      }\n    }\n  }\n  t[g]=0;\n  return min;\n}   \nint main(){\n  int a,b,c,e,x1,x2,y1,y2,h,i;\n  scanf(\"%d\\n%d\",&n,&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&e);\n    d[a][b]=c;\n    d[b][a]=e;\n  }\n  scanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n  int t[21]={0};\n  y1-=u(t,x1,0,x2);\n  min=200001;\n  y1-=y2;\n  y1-=u(t,x2,0,x1);\n  printf(\"%d\\n\",y1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint start;\n\nint max_prize(int money, int route[20][20], int current, int goal);\n\nint main(void)\n{\n\tint n, m;\n\tint i, j;\n\tint route[20][20];\n\tint pillar_point;\n\tint money;\n\tint price;\n\t\n\tfor (i = 0; i < 20; i++){\n\t\tfor (j = 0; j < 20; j++){\n\t\t\troute[i][j] = -1;\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\t\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\troute[a - 1][b - 1] = c;\n\t\troute[b - 1][a - 1] = d;\n\t}\n\t\n\tscanf(\"%d\", &start);\n\tscanf(\"%*c%d\", &pillar_point);\n\tscanf(\"%*c%d\", &money);\n\tscanf(\"%*c%d\", &price);\n\t\n\tprintf(\"%d\\n\", max_prize(money - price, route, start, pillar_point));\n\t\n\treturn 0;\n}\n\nint max_prize(int money, int route[20][20], int current, int goal)\n{\n\tint i;\n\tint maxi = 0;\n\t\n\tif (current == goal){\n\t\tif (goal == start){\n\t\t\treturn money;\n\t\t}\n\t\telse {\n\t\t\treturn max_prize(money, route, goal, start);\n\t\t}\n\t}\n\tfor (i = 0; i < 20; i++){\n\t\tif (route[current - 1][i] > -1){\n\t\t\tint tmp_price = route[current - 1][i];\n\t\t\tint tmp_prize;\n\t\t\t\n\t\t\troute[current - 1][i] = -1;\n\t\t\ttmp_prize = max_prize(money - tmp_price, route, i + 1, goal);\n\t\t\troute[current - 1][i] = tmp_price;\n\t\t\t\n\t\t\tif (maxi < tmp_prize){\n\t\t\t\tmaxi = tmp_prize;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn maxi;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint zMIN(int a,int b){return a*b?MIN(a,b):a+b;}\nint d[30][30],n,min,i,j;\nint f(int s,int t){\n  int f[50]={0};\n  int c[50]={0};\n  for(i=0;i<n;i++){\n    f[s]=1;\n    for(j=1;j<=n;j++){\n      if(d[s][j]==0)continue;\n      c[j]=zMIN(c[j],c[s]+d[s][j]);\n    }\n    min=210000000;\n    for(j=1;j<=n;j++){\n      if(f[j]==0&&c[j]&&min>c[j])min=c[s=j];\n    }\n  }\n  return c[t];\n}\nint main(){\n  int m,a,b,c;\n  scanf(\"%d %d\",&n,&m);\n  while(m--){\n    scanf(\"%d,%d,\",&a,&b);\n    scanf(\"%d,%d\",&d[a][b],&d[b][a]);\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&m,&c);\n  printf(\"%d\\n\",m-c-f(a,b)-f(b,a));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,g[21][21],i;x,X;c[21],t,T,f;D(S){for(memset(c,1,84),f=c[S]=0;T=S;)for(f|=1<<T,S=i=0;++i<=n;S=f&1<<i|c[i]>c[S]?S:i)t=c[T]+g[T][i],t<c[i]?c[i]=t:0;}main(y,Y){for(memset(g,scanf(\"%d%d\",&n,&i),1764);scanf(\"%d,%d,%d,%d\",&x,&X,&y,&Y),~i--?g[g[x][X]=y,X][x]=Y:0;);D(x),y-=c[X],D(X);exit(!printf(\"%d\\n\",y-Y-c[x]));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 20\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n\nstatic int d[ N ][ N ];\nstatic int e[ N ][ N ];\nstatic int n;\n\nstatic int k_operafan[ N ];\n\nstatic int\ndpFSA (\n  int p,\n  int t\n  )\n{\n  int i;\n\n  if ( p == t ) return ( 0 );\n\n  if ( ~k_operafan[ p ] ) ;\n  else\n  {\n    k_operafan[ p ] = INT_MAX >> 1;\n\n    for ( i = 0; i < n; ++i )\n    {\n      int tmp = d[ p ][ i ];\n\n      if ( d[ p ][ i ] == -1 ) continue ;\n\n      d[ p ][ i ] = -1;\n      tmp += dpFSA ( i, t );\n      k_operafan[ p ] = MIN( k_operafan[ p ], tmp );\n    }\n  }\n\n  return ( k_operafan[ p ] );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int m, x1, x2, y1, y2;\n  int res;\n\n  scanf ( \"%d %d\", &n, &m );\n  memset ( e, -1, sizeof ( e ) );\n  while ( m-- )\n  {\n    int a, b, c1, c2;\n\n    scanf ( \" %d,%d,%d,%d\", &a, &b, &c1, &c2 );\n    e[ a - 1 ][ b - 1 ] = c1;\n    e[ b - 1 ][ a - 1 ] = c2;\n  }\n  scanf ( \" %d,%d,%d,%d\", &x1, &x2, &y1, &y2 );\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  memcpy ( d, e, sizeof ( d ) );\n  res  = dpFSA ( x1 - 1, x2 - 1 );\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  memcpy ( d, e, sizeof ( d ) );\n  res += dpFSA ( x2 - 1, x1 - 1 );\n\n  printf ( \"%d\\n\", y1 - y2 - res );\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint map_size;\n\tint map[20][20];\n\tint road_num;\n\tint a,b,c,d;\n\tint start,goal,money,cost;\n\tint i,j,k;\n\tscanf(\"%d\",&map_size);\n\tfor(a=0;a<map_size;a++) {\n\t\tfor(b=0;b<map_size;b++) {\n\t\t\tmap[a][b]=0x20000000;\n\t\t}\n\t\tmap[a][a]=0;\n\t}\n\tscanf(\"%d\",&road_num);\n\tfor(i=0;i<road_num;i++) {\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\ta--;b--;\n\t\tmap[a][b]=c;\n\t\tmap[b][a]=d;\n\t}\n\tscanf(\"%d,%d,%d,%d\",&start,&goal,&money,&cost);\n\tstart--;goal--;\n\tfor(k=0;k<map_size;k++) {\n\t\tfor(i=0;i<map_size;i++) {\n\t\t\tfor(j=0;j<map_size;j++) {\n\t\t\t\tif(map[i][k]+map[k][j]<map[i][j]) {\n\t\t\t\t\tmap[i][j]=map[i][k]+map[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",money-cost-map[start][goal]-map[goal][start]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[600]={-M};\nint main(){\n  int ta[25]={0};\n  int to[500],ne[500],co[500];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){\n    int u[30];\n    for(i=r=1;i<600;i++)h[i]=M;\n    for(i=0;i<n;i++)u[i]=M;\n    h[u[a]=0]=-M;\n    while(1){\n      for(j=ta[a];j;j=ne[j]){\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];\n\t  for(k=r++;h[k/2]>u[to[j]]*30+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*30+to[j];\n\t}\n      }\n      a=h[j=1]%30;\n      d=h[--r];\n      for(h[r]=M;d>h[j];j=mi){\n\th[j]=h[mi=j*2];\n\tif(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n      }\n      if(r==1)break;\n      h[j/2]=d;\n    }\n    c-=u[b];\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid f(int t[][21],int mem[],int c,int e,int g){\n  int i;\n  if(c==e){\n    if(mem[e]==-1||mem[e]>g)\n      mem[e]=g;\n  }else if(mem[c]==-1||mem[c]>g){\n    mem[c]=g;\n    for(i=1;i<21;i++){\n      if(t[c][i])\n\tf(t,mem,i,e,g+t[c][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i;\n  int t[21][21],mem[21],n,m,b,e,c,d;\n  int t1,t2,t3,t4;\n  memset(t,0,sizeof(t));\n  scanf(\"%d%d\",&n,&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d,%d\",&t1,&t2,&t3,&t4);\n    t[t1][t2]=t3;\n    t[t2][t1]=t4;\n  }\n  scanf(\"%d,%d,%d,%d\",&b,&e,&c,&d);\n  c-=d;\n  memset(mem,-1,sizeof(mem));\n  f(t,mem,b,e,0);\n  c-=mem[e];\n  memset(mem,-1,sizeof(mem));\n  f(t,mem,e,b,0);\n  printf(\"%d\\n\",c-mem[b]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#include<limits.h>\n\n\nint min( int a ,int b )\n{\n\treturn a > b ? b : a ;\n}\n\n\nvoid in( int move[][ 200 ] ,int next[][ 200 ] ,int *ans ,int m )\n{\n\tint now ,nex ;\n\tint go ,back ;\n\n\tint i ,j ;\n\tfor( i = 0 ; i < m ; ++i )\n\t{\n\t\tscanf( \"%d,%d,%d,%d\" ,&now ,&nex ,&go ,&back ) ;\n\n\n\t\t++next[ now ][ 0 ] ;\n\t\t++next[ nex ][ 0 ] ;\n\n\t\tnext[ now ][ next[ now ][ 0 ] ] =\tnex ;\n\t\tnext[ nex ][ next[ nex ][ 0 ] ] =\tnow ;\n\n\n\t\tmove[ now ][ nex ] = go ;\n\t\tmove[ nex ][ now ] = back ;\n/*\n\t\tgo_k[ now ][ nex ] = go ;\n\n\t\tback_k[ nex ][ now ] = back ;\n*/\n\t}\n}\n\n\nint next[ 200 ][ 200 ] ;\n\nint move[ 200 ][ 200 ] ;\n\nbool came[ 200 ][ 200 ] ;\n\n\nint n ,m ;\n\nint st ,end ;\n\nvoid search( int *ans ,int kale[][ 200 ] ,int now )\n{\n\tint i ;\n\tfor( i = 1 ; i <= next[ now ][ 0 ] ; ++i )\n\t{\n\t\tif( next[ now ][ i ] != st && came[ now ][ i ] == false )\n\t\t{\n\t\t\tcame[ now ][ i ] = true ;\n\n\t\t\tans[ next[ now ][ i ] ] = min( ans[ now ] + kale[ now ][ next[ now ][ i ] ] ,ans[ next[ now ][ i ] ] ) ;\n\t\t\n\t\t\tif( next[ now ][ i ] != end )\n\t\t\t{\n\t\t\t\tsearch( ans ,kale ,next[ now ][ i ] ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid init( int *ans ,int n )\n{\n\twhile( n )\n\t{\n\t\tans[ n-- ] = INT_MAX ;\n\t}\n}\n\t\n\n\nint main()\n{\n\tint kale ,stick ;\n\n\tint ans[ 20 + 1 ] ;\n\n\n\tscanf( \"%d\" ,&n ) ;\n\n\tinit( ans ,n ) ;\n\n\n\tscanf( \"%d\" ,&m ) ;\n\n\tin( move ,next ,ans ,m ) ;\n\n\n\tscanf( \"%d,%d,%d,%d\" ,&st ,&end ,&kale ,&stick ) ;\n\n\tans[ st ] = 0 ;\n\t\n\tsearch( ans ,move ,st ) ;\n\n\tstick += ans[ end ] ;\n\n\tinit( ans ,n ) ;\n\n\n\tst += end ;\n\tend = st - end ;\n\tst -= end ;\n\n\n\tans[ st ] = 0 ;\n\n\tmemset( came ,0 ,sizeof came ) ;\n\n\tsearch( ans ,move ,st ) ;\n\n\n\tprintf( \"%d\\n\" ,kale - ( stick + ans[ end ] ) ) ;\n\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint r,h[6000]={-M};\nvoid g(){\n  int i,j=0;\n  for(i=1;i<=r;i++){\n    if(i==1<<j){\n      printf(\"\\n\");\n      j++;\n    }\n    printf(\"%d \",h[i]);\n  }\n} \nint main(){\n  int ta[25]={0};\n  int to[500],ne[500],co[500];\n  int a,b,c,d,e,i,j,k,l,n,m,mi;\n  //int h[60]={-M};\n  for(i=r=1;i<60;i++)h[i]=M;\n  scanf(\"%d %d\",&n,&m);\n  n++;\n  for(i=1;i<=m*2;i++){\n    scanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n    ne[i]=ta[a];\n    to[i]=b;\n    co[i]=c;\n    ta[a]=i++;\n    ne[i]=ta[b];\n    to[i]=a;\n    co[i]=d;\n    ta[b]=i;\n  }\n  scanf(\"%d,%d,%d,%d\",&e,&b,&c,&d);\n  c-=d;\n  a=e;\n  for(l=0;l<2;l++){//printf(\"%d %d %d\\n\",a,b,r);\n    int u[30],f[30]={0};\n    r=1;//printf(\"%d\\n\",n);\n    for(i=0;i<n;i++)u[i]=h[i]=M;//printf(\"%d\\n\",a);\n    u[a]=0;//printf(\"s%d\\n\",h[0]);//g();printf(\"\\n\");\n    h[0]=-M;\n    /*for(i=1;i<n;i++){printf(\"%d:\\n\",i);\n      for(j=ta[i];j;j=ne[j])printf(\"%d \",to[j]);printf(\"\\n\");\n      }*/\n    for(i=1;i<n;i++){//printf(\"a\\n\");\n      f[a%=10]=1;//printf(\"%d:\",a);//printf(\"f2%d:\",f[2]);//printf(\"\\n\");\n      for(j=ta[a];j;j=ne[j]){//printf(\"%d \",to[j]);\n\tif(u[to[j]]>u[a]+co[j]){\n\t  u[to[j]]=u[a]+co[j];//printf(\"u%d \",u[to[j]]);\n\t  for(k=r++;h[k/2]>u[to[j]]*10+to[j];k/=2)h[k]=h[k/2];\n\t  h[k]=u[to[j]]*10+to[j];//printf(\"h%d k%d \",h[k],k);\n\t}\n      }//printf(\"\\n\");g();printf(\"\\n\");\n      while(f[a%10]){//printf(\"a==%d\\n\",a);\n\ta=h[j=1];\n\td=h[--r];\n\tfor(h[r]=M;d>h[j];j=mi){\n\t  h[j]=h[mi=j*2];\n\t  if(h[j]>h[j*2+1])h[j]=h[mi=j*2+1];\n\t}//printf(\"a==%d\\n\",a);\n\th[j/2]=d;\n      }//g();printf(\"\\n\");\n      //printf(\"c%d\\n\",c);\n    }\n    c-=u[b];//printf(\"b%d\\n\",c);\n    a=b;\n    b=e;\n  }\n  printf(\"%d\\n\",c);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nint min(int,int);\nvoid warshall_floyd(void);\n\nint graph[21][21];\nint V;\n\nint main(void){\nint i,j,road,a,b,c,d;\nint x1,x2,y1,y2;\nfor(i=0;i<21;i++)\nfor(j=0;j<21;j++)\ngraph[i][j]=INF;\n\nscanf(\"%d\",&V);\nscanf(\"%d\",&road);\nfor(i=0;i<road;i++){\nscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\ngraph[a][b]=c;\ngraph[b][a]=d;\n}\nscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\nwarshall_floyd();\n\nprintf(\"%d\\n\",y1-graph[x1][x2]-graph[x2][x1]-y2);\n\nreturn 0;\n}\n\nint min(int x,int y){\nreturn (x>y)?y:x;\n}\n\nvoid warshall_floyd(){\nint i,j,k;\nfor(k=0;k<=V;k++)\nfor(i=0;i<=V;i++)\nfor(j=0;j<=V;j++)\ngraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 100000\n#define DIJKSTRA_MAX_EDGE 400000\n\ntypedef struct {\n\tint from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tint node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(int node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(int from,int to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(int from,int to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to]) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint main(void) {\n\tint n,m;\n\tint x1,x2,y1,y2;\n\tint i;\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tdijkstra_init();\n\tfor(i=0;i<m;i++) {\n\t\tint a,b,c,d;\n\t\tscanf(\"%d,%d,%d,%d\",&a,&b,&c,&d);\n\t\tdijkstra_addedge(a,b,c);\n\t\tdijkstra_addedge(b,a,d);\n\t}\n\tdijkstra_setup();\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\tprintf(\"%d\\n\",y1-y2-dijkstra_search(x1,x2)-dijkstra_search(x2,x1));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint start;\n\nint max_prize(int money, int route[20][20], int current, int goal);\n\nint main(void)\n{\n\tint n, m;\n\tint i, j;\n\tint route[20][20];\n\tint pillar_point;\n\tint money;\n\tint price;\n\t\n\tfor (i = 0; i < 20; i++){\n\t\tfor (j = 0; j < 20; j++){\n\t\t\troute[i][j] = -1;\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; i++){\n\t\tint a, b, c, d;\n\t\t\n\t\tscanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n\t\troute[a - 1][b - 1] = c;\n\t\troute[b - 1][a - 1] = d;\n\t}\n\t\n\tscanf(\"%d\", &start);\n\tscanf(\"%*c%d\", &pillar_point);\n\tscanf(\"%*c%d\", &money);\n\tscanf(\"%*c%d\", &price);\n\t\n\tprintf(\"%d\\n\", max_prize(money - price, route, start, pillar_point));\n\t\n\treturn 0;\n}\n\nint max_prize(int money, int route[20][20], int current, int goal)\n{\n\tint i;\n\tint maxi = 0;\n\t\n\tif (current == goal){\n\t\tif (goal == start){\n\t\t\treturn money;\n\t\t}\n\t\telse {\n\t\t\treturn max_prize(money, route, goal, start);\n\t\t}\n\t}\n\tfor (i = 0; i < 20; i++){\n\t\tif (route[current - 1][i] > -1){\n\t\t\tint tmp_price = route[current - 1][i];\n\t\t\tint tmp_prize;\n\t\t\t\n\t\t\troute[current - 1][i] = -1;\n\t\t\ttmp_prize = max_prize(money - tmp_price, route, i + 1, goal);\n\t\t\troute[current - 1][i] = tmp_price;\n\t\t\t\n\t\t\tif (maxi < tmp_prize){\n\t\t\t\tmaxi = tmp_prize;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn maxi;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 32\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n\nstatic int n;\nstatic int d[ N ][ N ];\n\nstatic int k_operafan[ N ];\n\nstatic int\ndpFSA (\n  int p,\n  int t,\n  int rebirth\n  )\n{\n  int i;\n\n  if ( p == t ) return ( 0 );\n\n  if ( ~k_operafan[ p ] ) ;\n  else\n  {\n    k_operafan[ p ] = INT_MAX / 2;\n\n    for ( i = 0; i < n; ++i )\n    {\n      int tmp;\n\n      if ( d[ p ][ i ] == -1\n        || ( rebirth != -1\n          && rebirth == i ) ) continue ;\n\n      tmp = dpFSA ( i, t, rebirth ) + d[ p ][ i ];\n      k_operafan[ p ] = MIN( k_operafan[ p ], tmp );\n    }\n  }\n\n  return ( k_operafan[ p ] );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int m, x1, x2, y1, y2;\n  int res;\n\n  scanf ( \"%d %d\", &n, &m );\n  memset ( d, -1, sizeof ( d ) );\n  while ( m-- )\n  {\n    int a, b, c1, c2;\n\n    scanf ( \" %d,%d,%d,%d\", &a, &b, &c1, &c2 );\n    d[ a - 1 ][ b - 1 ] = c1;\n    d[ b - 1 ][ a - 1 ] = c2;\n  }\n  scanf ( \" %d,%d,%d,%d\", &x1, &x2, &y1, &y2 );\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  res  = dpFSA ( x1 - 1, x2 - 1, -1 );\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  res += dpFSA ( x2 - 1, x1 - 1, -1 );\n  printf ( \"%d\\n\", y1 - y2 - res );\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000000000\nint MIN(int a,int b){return a<b?a:b;}\nint d[30][30],n,min,i,j;\nint f(int s,int t){\n  int f[50]={0};\n  int c[50]={0};\n  for(i=0;i<50;i++)c[i]=M;\n  for(i=c[s]=0;i<n;i++){\n    for(j=f[s]=1;j<=n;j++)c[j]=MIN(c[j],c[s]+d[s][j]);\n    min=M;\n    for(j=1;j<=n;j++){\n      if(f[j]==0&&min>c[j])min=c[s=j];\n    }\n  }\n  return c[t];\n}\nint main(){\n  int m,a,b,c;\n  for(a=0;a<30*30;a++)d[a/30][a%30]=M;\n  scanf(\"%d %d\",&n,&m);\n  while(m--){\n    scanf(\"%d,%d,\",&a,&b);\n    scanf(\"%d,%d\",&d[a][b],&d[b][a]);\n  }\n  scanf(\"%d,%d,%d,%d\",&a,&b,&m,&c);\n  printf(\"%d\\n\",m-c-f(a,b)-f(b,a));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define INF 10000000\n#define N 21\n\n#define error(s) do{fprintf(stderr , s); exit(-1);}while(0)\n\nint M[N][N],a[N][N],W[N][N],p[N][N];;\n\nvoid floyd(void);\nvoid path(int i, int j);\n\nint main(){\n\tint i,j,n,m,a1,b,c,d,x1,x2,y1,y2;\n\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 1 ; j < N ; j++){\n\t\t\tM[i][j] = 0;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\n\tfor(i = 0 ; i < m ; i++){\n\t\tscanf(\"%d,%d,%d,%d\",&a1,&b,&c,&d);\n\t\tM[a1][b] = c;\n\t\tM[b][a1] = d;\n\t}\n\n\tscanf(\"%d,%d,%d,%d\",&x1,&x2,&y1,&y2);\n\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tif(i == j){\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tW[i][j] = 0;\n\t\t\t}\n\t\t\telse if(M[i][j] == 0){\n\t\t\t\ta[i][j] = INF;\n\t\t\t\tW[i][j] = INF;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = M[i][j];\n\t\t\t\tW[i][j] = M[i][j];\n\t\t\t}\n\n\t\t\tif(W[i][j] != INF){\n\t\t\t\tp[i][j] = j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i][j] = -1;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfloyd();\n\tpath(x1,x2,&y1);\n\ty1 -= y2;\n\tpath(x2,x1,&y1);\n\n\tprintf(\"%d\\n\",y1);\n\treturn 0;\n}\n\nvoid floyd(void){\n\tint i , j , k ;\n\tfor(i = 0 ; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\ta[i][j] = W[i][j];\n\t\t}\n\t}\n\n\tfor(k = 0 ; k < N ; k++){\n\t\tfor(i = 0 ; i < N ; i++){\n\t\t\tfor(j = 0 ; j < N ; j++){\n\t\t\t\tif(a[i][k] + a[k][j] < a[i][j]){\n\t\t\t\t\ta[i][j] = a[i][k] + a[k][j];\n\t\t\t\t\tp[i][j] = p[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid path(int i, int j ,int *y1){\n\tint tmp,k = i;\n\ttmp = k;\n\twhile(p[k][j] != j && p[k][j] != -1){\n\t\tk = p[k][j];\n\t\t*y1 -= M[tmp][k];\n\t\ttmp = k;\n\t}\n\tif(p[k][j] == -1)error(\"No Path\");\n\t*y1 -= M[k][j];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic PriorityQueue <State> pq=new PriorityQueue<>();\n\t\n\tstatic class State implements Comparable<State>{\n\t\tint a, cost;\n\t\tState(int a, int cost){\n\t\t\tthis.a=a;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.cost-s.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint n=sc.nextInt();\n\t\t\tint m=sc.nextInt();\n\t\t\tint s, g, V, P;\n\t\t\tint[] v1=new int[n+1];\n\t\t\tint[] v2=new int[n+1];\n\t\t\tint[][] dist1=new int[n+1][n+1];\n\t\t\tint[][] dist2=new int[n+1][n+1];\n\t\t\tint INF=100000000;\n\t\t\tArrays.fill(v1, INF);\n\t\t\tArrays.fill(v2, INF);\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\t\tdist1[i][j]=INF;\n\t\t\t\t\tdist2[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tString str=sc.next();\n\t\t\t\tString[] token=str.split(\",\");\n\t\t\t\tint a=Integer.parseInt(token[0]);\n\t\t\t\tint b=Integer.parseInt(token[1]);\n\t\t\t\tint c=Integer.parseInt(token[2]);\n\t\t\t\tint d=Integer.parseInt(token[3]);\n\t\t\t\tdist1[a][b]=dist2[a][b]=c;\n\t\t\t\tdist1[b][a]=dist2[b][a]=d;\n\t\t\t}\n\t\t\tString str=sc.next();\n\t\t\tString[] token=str.split(\",\");\n\t\t\ts=Integer.parseInt(token[0]);\n\t\t\tg=Integer.parseInt(token[1]);\n\t\t\tV=Integer.parseInt(token[2]);\n\t\t\tP=Integer.parseInt(token[3]);\n\t\t\tpq.add(new State(s, 0));\n\t\t\twhile(! pq.isEmpty()) {\n\t\t\t\tState state=pq.poll();\n\t\t\t\tif(v1[state.a]!=INF) continue;\n\t\t\t\tv1[state.a]=state.cost;\n\t\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\t\tif(dist1[state.a][i]!=INF) {\n\t\t\t\t\t\tpq.add(new State(i, state.cost+dist1[state.a][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpq.clear();\n\t\t\tpq.add(new State(g, 0));\n\t\t\twhile(! pq.isEmpty()) {\n\t\t\t\tState state=pq.poll();\n\t\t\t\tif(v2[state.a]!=INF) continue;\n\t\t\t\tv2[state.a]=state.cost;\n\t\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\t\tif(dist2[state.a][i]!=INF) {\n\t\t\t\t\t\tpq.add(new State(i, state.cost+dist2[state.a][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(V-P-(v1[g]+v2[s]));\n\t\t\t\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint M = 100000;\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[][] graph = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(graph[i], M);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString[] input = sc.next().split(\",\");\n\t\t\tint s = Integer.valueOf(input[0]);\n\t\t\tint t = Integer.valueOf(input[1]);\n\t\t\tgraph[s][t] = Integer.valueOf(input[2]);\n\t\t\tgraph[t][s] = Integer.valueOf(input[3]);\n\t\t}\n\t\tString[] input = sc.next().split(\",\");\n\t\tint[] go = { Integer.valueOf(input[0]), Integer.valueOf(input[1]) };\n\t\tint get = Integer.valueOf(input[2]) - Integer.valueOf(input[3]);\n\t\tfor (int I = 0; I < 2; I++) {\n\t\t\tint start = go[I];\n\t\t\tint goal = go[I ^ 1];\n\t\t\tint[] len = new int[n + 1];\n\t\t\tboolean[] v = new boolean[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tlen[i] = M;\n\t\t\t}\n\t\t\tlen[start] = 0;\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tint min = M;\n\t\t\t\tint p = 0;\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tif (!v[j] && len[j] < min) {\n\t\t\t\t\t\tp = j;\n\t\t\t\t\t\tmin = len[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p] = true;\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tif (len[p] + graph[p][j] < len[j]) {\n\t\t\t\t\t\tlen[j] = len[p] + graph[p][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tget -= len[goal];\n\t\t}\n\t\tSystem.out.println(get);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\n\t\tint[][] num = new int[n + 1][n + 1];\n\t\tfor (int[] t : num) {\n\t\t\tArrays.fill(t, -1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint b = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint c = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint d = Integer.valueOf(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\n\t\t}\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint q = Integer.parseInt(tokenizer.nextToken());\n\t\tint r = Integer.parseInt(tokenizer.nextToken());\n\t\tint ans = Integer.parseInt(tokenizer.nextToken())\n\t\t\t\t- Integer.parseInt(tokenizer.nextToken());\n\t\tint qs = getYen(q, r, num);\n\t\tint rs = getYen(r, q, num);\n\t\tans = ans - qs - rs;\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int getYen(int q, int r, int[][] num) {\n\t\tint[] cost = new int[num.length];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tcost[q] = 0;\n\t\tdeque.push(q);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tfor (int i = 0; i < deque.size(); i++) {\n\t\t\t\tint p = deque.pop();\n\t\t\t\tfor (int j = 1; j < num.length; j++) {\n\t\t\t\t\tif (num[p][j] != -1 && num[p][j] + cost[p] < cost[j]) {\n\t\t\t\t\t\tdeque.push(j);\n\t\t\t\t\t\tcost[j] = num[p][j] + cost[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost[r];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\n\t\tint[][] num = new int[n + 1][n + 1];\n\t\tfor (int[] t : num) {\n\t\t\tArrays.fill(t, -1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint b = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint c = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint d = Integer.valueOf(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\n\t\t}\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint q = Integer.parseInt(tokenizer.nextToken());\n\t\tint r = Integer.parseInt(tokenizer.nextToken());\n\t\tint ans = Integer.parseInt(tokenizer.nextToken())\n\t\t\t\t- Integer.parseInt(tokenizer.nextToken());\n\t\tint qs = getYen(q, r, num);\n\t\tint rs = getYen(r, q, num);\n\t\tans = ans - qs - rs;\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int getYen(int q, int r, int[][] num) {\n\t\tint[] cost = new int[num.length];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tcost[q] = 0;\n\t\tgetYen(q, num, cost);\n\t\treturn cost[r];\n\t}\n\n\tpublic static void getYen(int q, int[][] num, int[] cost) {\n\t\tfor (int j = 1; j < num.length; j++) {\n\t\t\tif (num[q][j] != -1 && num[q][j] + cost[q] < cost[j]) {\n\t\t\t\tcost[j] = num[q][j] + cost[q];\n\t\t\t\tgetYen(j, num, cost);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint[] cost = new int[n + 1];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\n\t\tint[][] num = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint b = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint c = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint d = Integer.valueOf(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint q = Integer.parseInt(tokenizer.nextToken());\n\t\tint r = Integer.parseInt(tokenizer.nextToken());\n\t\tint ans = Integer.parseInt(tokenizer.nextToken())\n\t\t\t\t- Integer.parseInt(tokenizer.nextToken());\n\t\tans = ans - getYen(q, r, num) - getYen(r, q, num);\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int getYen(int q, int r, int[][] num) {\n\t\tint[] cost = new int[num.length];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tDeque<Integer> deque = new ArrayDeque<>();\n\t\tcost[q] = 0;\n\t\tdeque.push(q);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tfor (int i = 0; i < deque.size(); i++) {\n\t\t\t\tint p = deque.pop();\n\t\t\t\tfor (int j = 1; j < num.length; j++) {\n\t\t\t\t\tif (num[p][j] != 0 && num[p][j] + cost[p] < cost[j]) {\n\t\t\t\t\t\tdeque.push(j);\n\t\t\t\t\t\tcost[j] = num[p][j] + cost[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost[r];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\"\\\\D+\");\n\t\t\n\t\tfinal int towns = sc.nextInt();\n\t\tfinal int paths = sc.nextInt();\n\t\t\n\t\tint[][] relates = new int[towns][towns];\n\t\tfor(int[] tmp:relates){\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\ttmp[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < paths; i++){\n\t\t\tfinal int from = sc.nextInt();\n\t\t\tfinal int to = sc.nextInt();\n\t\t\tfinal int go = sc.nextInt();\n\t\t\tfinal int back = sc.nextInt();\n\t\t\trelates[from-1][to-1] = go;\n\t\t\trelates[to-1][from-1] = back;\n\t\t}\n\t\t\n\t\tfinal int start = sc.nextInt();\n\t\tfinal int end = sc.nextInt();\n\t\tfinal int price = sc.nextInt();\n\t\tfinal int cost = sc.nextInt();\n\t\t\n\t\tint first_cost = search(start,end,relates,towns);\n\t\tint second_cost = search(end,start,relates,towns);\n\t\t\n\t\tSystem.out.println(price - cost - first_cost - second_cost);\n\t}\n\t\n\tprivate static int search(final int start,final int end,int[][] relates,final int towns){\n\t\tint arrived = 1 << start;\n\t\t\n\t\tint[] costs = new int[towns];\n\t\tfor(int i=0; i<towns; i++){\n\t\t\tcosts[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tcosts[start-1] = 0;\n\t\t\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.add(start);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\t\n\t\t\tif((arrived & (1 << cur)) == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\tif(relates[cur-1][i] != 0){\n\t\t\t\t\tif(costs[i] > (costs[cur-1]+relates[cur-1][i])){\n\t\t\t\t\t\tqueue.add(i+1);\n\t\t\t\t\t\tcosts[i] = costs[cur-1]+relates[cur-1][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tarrived |= 1 << cur;\n\t\t}\n\t\t\n\t\treturn costs[end-1];\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tint[][] cost;\n\tboolean[] visit;\n\tint[] dist;\n\tint n;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tcost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tArrays.fill(cost[i], 1000000);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0])-1;\n\t\t\t\tint b = Integer.parseInt(str[1])-1;\n\t\t\t\tcost[a][b] = Integer.parseInt(str[2]);\n\t\t\t\tcost[b][a] = Integer.parseInt(str[3]);\n\t\t\t}\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tint[] x = {Integer.parseInt(str[0])-1,Integer.parseInt(str[1])-1};\n\t\t\tint reward = Integer.parseInt(str[2]) - Integer.parseInt(str[3]);\n\t\t\tfor(int i = 0;i < 2;i++){\n\t\t\t\tvisit = new boolean[n];\n\t\t\t\tdist = new int[n];\n\t\t\t\tArrays.fill(dist,1000000);\n\t\t\t\tArrays.fill(visit,false);\n\t\t\t\tdijkstra(x[i]);\n\t\t\t\treward -= dist[x[(i+1)%2]];\n\t\t\t}\n\t\t\tSystem.out.println(reward);\n\t\t}\n\t}\n\tpublic void dijkstra(int start){\n\t\tdist[start] = 0;\n\t\twhile(true){\n\t\t\tint min = 1000000;\n\t\t\tint next = -1;\n\t\t\tfor(int u = 0;u < n;u++){\n\t\t\t\tif(visit[u]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdist[u] = Math.min(dist[u],dist[start] + cost[start][u]);\n\t\t\t\tif(dist[u] < min){\n\t\t\t\t\tmin = dist[u];\n\t\t\t\t\tnext = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[start] = true;\n\t\t\tstart = next;\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\"\\\\D+\");\n\t\t\n\t\tfinal int towns = sc.nextInt();\n\t\tfinal int paths = sc.nextInt();\n\t\t\n\t\tint[][] relates = new int[towns][towns];\n\t\tfor(int[] tmp:relates){\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\ttmp[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < paths; i++){\n\t\t\tfinal int from = sc.nextInt();\n\t\t\tfinal int to = sc.nextInt();\n\t\t\tfinal int go = sc.nextInt();\n\t\t\tfinal int back = sc.nextInt();\n\t\t\trelates[from-1][to-1] = go;\n\t\t\trelates[to-1][from-1] = back;\n\t\t}\n\t\t\n\t\tfinal int start = sc.nextInt();\n\t\tfinal int end = sc.nextInt();\n\t\tfinal int price = sc.nextInt();\n\t\tfinal int cost = sc.nextInt();\n\t\t\n\t\tint first_cost = search(start,end,relates,towns);\n\t\tint second_cost = search(end,start,relates,towns);\n\t\t\n\t\tSystem.out.println(price - cost - first_cost - second_cost);\n\t}\n\t\n\tprivate static int search(final int start,final int end,int[][] relates,final int towns){\n\t\t\n\t\tint[] costs = new int[towns];\n\t\tfor(int i=0; i<towns; i++){\n\t\t\tcosts[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tcosts[start-1] = 0;\n\t\t\n\t\tSet<Integer> un_used = new HashSet<Integer>(); \n\t\tfor(int i = 0; i < towns; i++){\n\t\t\tun_used.add(i);\n\t\t}\n\t\t\n\t\t\n\t\twhile(!un_used.isEmpty()){\n\t\t\tint cur = -1, cur_cost = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int i : un_used){\n\t\t\t\tif(cur_cost > costs[i]){\n\t\t\t\t\tcur = i;\n\t\t\t\t\tcur_cost = costs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tun_used.remove(cur);\n\t\t\t\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\tif(relates[cur][i] != -1){\n\t\t\t\t\tif(costs[i] > (costs[cur]+relates[cur][i])){\n\t\t\t\t\t\tcosts[i] = costs[cur]+relates[cur][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn costs[end-1];\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b;int[][]p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=new Integer(z[0])-1;b=new Integer(z[1])-1;p[a][b]=new Integer(z[2]);p[b][a]=new Integer(z[3]);}z=s.next().split(\",\");System.out.println(new Integer(z[2])-new Integer(z[3])-f(a=new Integer(z[0])-1,b=new Integer(z[1])-1,p,n)-f(b,a,p,n));}static int f(int a,int b,int[][]g,int n){LinkedList<int[]> q=new LinkedList<int[]>();q.add(new int[]{a,0});int c=0,i;for(int[]v=new int[n];!q.isEmpty();){int[]p=q.poll();if(p[0]==b){c=p[1];break;}v[p[0]]=1;for(i=0;i<n;++i)if(v[i]<1&&p[0]!=i&&g[p[0]][i]>0)q.add(new int[]{i,p[1]+g[p[0]][i]});Collections.sort(q,new Comparator<int[]>(){public int compare(int[]x,int[]y){return x[1]-y[1];}});}return c;}}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tfinal int INF = 1000000001;\n\t\n\tpublic int search(int[][] graph, int start, int goal){\n\t\tint[] cost = new int[graph.length];\n\t\tfor(int i = 0; i < cost.length; i++){\n\t\t\tif( i == start ){\n\t\t\t\tcost[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcost[i] = INF;\n\t\t}\n\t\t\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tset.add(start);\n\t\twhile( !set.contains(goal) ){\n\t\t\tint min_a = 0;\n\t\t\tint min_b = 1;\n\t\t\tfor(Integer x : set){\n\t\t\t\tfor(int i = 1; i < cost.length; i++){\n\t\t\t\t\tif( cost[i] < INF || x == i ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif( graph[x][i] + cost[x] < graph[min_a][min_b] + cost[min_a] ){\n\t\t\t\t\t\tmin_a = x;\n\t\t\t\t\t\tmin_b = i;\n\t\t//\t\t\t\tSystem.out.println(\"reviewed  min_a = \" + min_a + \", min_b = \" + min_b);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tcost[min_b] = graph[min_a][min_b] + cost[min_a];\n\t\t\tset.add(min_b);\t\t\t\n\t\t}\n\t\treturn cost[goal];\n\t}\n\tpublic void solve() throws IOException{\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[][] graph = new int[n+1][n+1];\n\t\tfor(int i = 0; i < graph.length; i++){\n\t\t\tfor(int j = 0; j < graph[0].length; j++){\n\t\t\t\tif( i == j ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgraph[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tString[][] temp = new String[m+1][];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\ttemp[i] = nextToken().split(\",\");\n\t\t\tint a = Integer.parseInt(temp[i][0]);\n\t\t\tint b = Integer.parseInt(temp[i][1]);\n\t\t\tgraph[a][b] = Integer.parseInt(temp[i][2]);\n\t\t\tgraph[b][a] = Integer.parseInt(temp[i][3]);\n\t\t}\n\t/*\tSystem.out.println();\n\t\tfor(int[] x : graph){\n\t\t\tfor(int y : x){\n\t\t\t\tSystem.out.print(y + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}*/\n\t\ttemp[m] = nextToken().split(\",\");\n\t\tint start = Integer.parseInt(temp[m][0]);\n\t\tint goal = Integer.parseInt(temp[m][1]);\n\t\tint reward = Integer.parseInt(temp[m][2]);\n\t\tint cost = Integer.parseInt(temp[m][3]);\n\t\tint ans = reward - cost - search(graph, start, goal) - search(graph, goal, start);\n\t\tSystem.out.println(ans);\n\t}\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m;\n\tLinkedList<E>[] edges;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\t\n\t\tedges = new LinkedList[n];\n\t\tfor(int i=0;i<n;i++) edges[i] = new LinkedList<E>();\n\t\t\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tString[] strs = sc.next().split(\",\");\n\t\t\tint[] vals = new int[4];\n\t\t\t\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tvals[j] = Integer.parseInt(strs[j]);\n\t\t\t}\n\t\t\t\n\t\t\tedges[vals[0]-1].add(new E(vals[1]-1, vals[2]));\n\t\t\tedges[vals[1]-1].add(new E(vals[0]-1, vals[3]));\n\t\t}\n\t\t\n\t\tString[] strs = sc.next().split(\",\");\n\t\tint[] vals = new int[4];\n\t\t\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tvals[j] = Integer.parseInt(strs[j]);\n\t\t}\n\t\tint val = dijkstra(vals[0]-1, vals[1]-1) + dijkstra(vals[1]-1, vals[0]-1);\n\t\tSystem.out.println( (vals[2] - vals[3] - val) );\n\t}\n\t\n\tint dijkstra(int s, int g) {\n\t\tint d[] = new int[n];\n\t\tfill(d, INF);\n\t\td[s] = 0;\n\t\tPriorityQueue<E> que = new PriorityQueue<E>();\n\t\tque.add(new E(s, 0));\n\t\t\n\t\tfor(;;) {\n\t\t\tE now = que.poll();\n\t\t\t\n\t\t\tif(now.to == g) return now.cost;\n\t\t\tif(now.cost != d[now.to]) continue;\n\t\t\tfor(E edge: edges[now.to] ) if( d[edge.to] > d[now.to] + edge.cost ){\n\t\t\t\tque.add(new E(edge.to, d[now.to]+edge.cost));\n\t\t\t\td[edge.to] = d[now.to]+edge.cost;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E>{\n\t\tint to, cost;\n\t\tE(int to, int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn cost - o.cost;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\n\t\tint[][] num = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint b = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint c = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint d = Integer.valueOf(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\n\t\t}\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint q = Integer.parseInt(tokenizer.nextToken());\n\t\tint r = Integer.parseInt(tokenizer.nextToken());\n\t\tint ans = Integer.parseInt(tokenizer.nextToken())\n\t\t\t\t- Integer.parseInt(tokenizer.nextToken());\n\t\tint qs = getYen(q, r, num);\n\t\tint rs = getYen(r, q, num);\n\t\tans = ans - qs - rs;\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int getYen(int q, int r, int[][] num) {\n\t\tint[] cost = new int[num.length];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tcost[q] = 0;\n\t\tdeque.push(q);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tfor (int i = 0; i < deque.size(); i++) {\n\t\t\t\tint p = deque.pop();\n\t\t\t\tfor (int j = 1; j < num.length; j++) {\n\t\t\t\t\tif (num[p][j] != 0 && num[p][j] + cost[p] < cost[j]) {\n\t\t\t\t\t\tdeque.push(j);\n\t\t\t\t\t\tcost[j] = num[p][j] + cost[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost[r];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include<iostream>\nusing namespace std;\n\nstatic const int INF = 1<<21;\nint n, m, a, b, c, d, s, g, v, p;\nint mat[21][21];\n\nvoid floyd(){\n    for(int k = 1; k <= n; k++){\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                mat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n\n    for(int i = 0; i < 21; i++){\n        for(int j = 0; j < 21; j++){\n            mat[i][j] = INF;\n        }\n    }\n\n    for(int i = 0; i < m; i++){\n        scanf(\"%d,%d,%d,%d\", &a, &b, &c, &d);\n        mat[a][b] = c;\n        mat[b][a] = d;\n    }\n    \n    scanf(\"%d,%d,%d,%d\", &s, &g, &v, &p);\n\n    floyd();\n\n    printf(\"%d\\n\", v-(mat[s][g]+mat[g][s]+p));\n\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tenum Color {\n\t\tWhite, Gray, Black\n\t}\n\n\tstatic void setEdge(List<ArrayList<int[]>> edge, String input) {\n\t\tString[] str = input.split(\",\");\n\t\tint from = Integer.parseInt(str[0]);\n\t\tint to = Integer.parseInt(str[1]);\n\t\tint cost1 = Integer.parseInt(str[2]);\n\t\tint cost2 = Integer.parseInt(str[3]);\n\t\tedge.get(from - 1).add(new int[] { to - 1, cost1 });\n\t\tedge.get(to - 1).add(new int[] { from - 1, cost2 });\n\t}\n\n\tstatic int[] bfs(List<ArrayList<int[]>> edge, int s) {\n\t\tint[] dist = new int[edge.size()];\n\t\tColor[] color = new Color[edge.size()];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tdist[i] = Integer.MAX_VALUE;\n\t\t\tcolor[i] = Color.White;\n\t\t}\n\t\tcolor[s] = Color.Gray;\n\t\tdist[s] = 0;\n\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\tq.add(s);\n\n\t\twhile (! q.isEmpty()) {\n\t\t\tint from = q.poll();\n\t\t\t\tfor(int[] e : edge.get(from)){\n\t\t\t\t\tint to = e[0];\n\t\t\t\t\tint cost = e[1];\n\t\t\t\t\tint total = dist[from] + cost;\n\t\t\t\t\tdist[to] = (total < dist[to])? total : dist[to];\n\t\t\t\t\tif(color[to] == Color.White){\n\t\t\t\t\t\tcolor[to] = Color.Gray;\n\t\t\t\t\t\tq.add(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolor[from] = Color.Black;\n\t\t}\n\t\treturn dist;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint city = s.nextInt();\n\t\tint numEdge = s.nextInt();\n\t\tList<ArrayList<int[]>> edge = new ArrayList<ArrayList<int[]>>();\n\t\tfor(int i = 0; i < city; i++){\n\t\t\tedge.add(new ArrayList<int[]>());\n\t\t}\n\t\tfor (int i = 0; i < numEdge; i++) {\n\t\t\tsetEdge(edge, s.next());\n\t\t}\n\t\tString[] input = s.next().split(\",\");\n\t\tint start = Integer.parseInt(input[0]);\n\t\tint dest = Integer.parseInt(input[1]);\n\t\tint money = Integer.parseInt(input[2]);\n\t\tint price = Integer.parseInt(input[3]);\n\t\tSystem.out.println(money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1]);\n\t\ts.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import static java.lang.Integer.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b;int[][] p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=valueOf(z[0])-1;b=valueOf(z[1])-1;p[a][b]=valueOf(z[2]);p[b][a]=valueOf(z[3]);}z=s.next().split(\",\");System.out.println(valueOf(z[2])-valueOf(z[3])-f(a=valueOf(z[0])-1,b=valueOf(z[1])-1,p,n)-f(b,a,p,n));}static int f(int a,int b,int[][]g,int n){if(a==b)return 0;int c=MAX_VALUE,i=0;for(;i<n;++i)if(v[i]<1&&g[a][i]>0){v[i]=1;c=Math.min(c,f(i,b,g,n)+g[a][b]);v[i]=0;}return c;}static int[]v;}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n \n \npublic class Main {\n\tprivate static  BufferedReader\tbr  = null;\n\tprivate\tstatic\tint[][]\t\t\tmap = null;\n\tprivate\tstatic\tint\t\t\t\tstp = 0;\n\tprivate\tstatic\tint\t\t\t\tedp = 0;\n\tprivate\tstatic\tint\t\t\t\tmon = 0;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n \n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tparseParam();\n\t\tSystem.out.println(mon - dijkstra(stp, edp) - dijkstra(edp, stp));\n\t}\n\n\tprivate static int dijkstra(int start, int end) {\n\t\tint[]       cost = new int[map.length];\n\t\tboolean[]   used = new boolean[map.length];\n \n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tcost[start] = 0;\n \n\t\twhile(true) {\n\t\t\tint cur = -1;\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (!used[n] && (cur == -1 || cost[n] < cost[cur])) {\n\t\t\t\t\tcur = n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cur == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[cur]  = true;\n\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[cur][n] != -1) {\n\t\t\t\t\tint\tcc = (cost[cur] == Integer.MAX_VALUE) ? cost[cur] : cost[cur] + map[cur][n];\n\t\t\t\t\tcost[n] = Math.min(cost[n], cc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn cost[end];\n\t}\n \n\tprivate static void parseParam() {\n\t\tint\tl = parseNum();\n\n\t\tif (l > 0) {\n\t\t\tint\tp = parseNum();\n\n\t\t\tmap = new int[l][l];\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tArrays.fill(map[i], -1);\n\t\t\t}\n\n\t\t\twhile (p-- >= 0) {\n\t\t\t\tString\t\tstdin = parseStdin();\n\t\t\t\tString[]\tlines = stdin.split(\",\");\n\t\t\t\tint[]\t\tdatas = {\n\t\t\t\t\tInteger.parseInt(lines[0]),\n\t\t\t\t\tInteger.parseInt(lines[1]),\n\t\t\t\t\tInteger.parseInt(lines[2]),\n\t\t\t\t\tInteger.parseInt(lines[3]),\n\t\t\t\t};\n\n\t\t\t\tif (p >= 0) {\n\t\t\t\t\tmap[datas[0]-1][datas[1]-1] = datas[2];\n\t\t\t\t\tmap[datas[1]-1][datas[0]-1] = datas[3];\n\t\t\t\t} else {\n\t\t\t\t\tstp = datas[0] - 1;\n\t\t\t\t\tedp = datas[1] - 1;\n\t\t\t\t\tmon = datas[2] - datas[3];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    private static int parseNum() {\n        int     num   = 0;\n        String  strIn = null;\n \n        if ((strIn = parseStdin()) != null) {\n            num = Integer.parseInt(strIn);\n        }\n         \n        return num;\n    }\n \n    private static String parseStdin() {\n        String  strNum = null;\n \n        try {\n            String line = br.readLine();\n            if (line != null) {\n                if (!line.isEmpty()) {\n                    strNum = line;\n                }\n            }\n        }\n        catch (IOException e) {}\n \n        return strNum;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * A Reward for a Carpenter\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tGraph graph = main.new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tgraph.addEdges(br.readLine());\n\t\t\t}\n\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \",\");\n\t\t\tint s = Integer.parseInt(st.nextToken());// start\n\t\t\tint g = Integer.parseInt(st.nextToken());// goal\n\t\t\tint b = Integer.parseInt(st.nextToken());// budget\n\t\t\tint p = Integer.parseInt(st.nextToken());// pillar\n\n\t\t\t//\n\t\t\tint way, back;\n\t\t\tway = graph.dijkstra(s, g);\n\t\t\tback = graph.dijkstra(g, s);\n\n\t\t\tSystem.out.println(b - p - way - back);\n\n\t\t}\n\t}\n\n\tclass Graph {\n\n\t\tint length;\n\t\tint[][] adjacency;\n\n\t\tGraph(int n) {\n\t\t\tlength = n + 1;\n\t\t\tadjacency = new int[length][length];\n\t\t\tfor (int i = 1; i < length; ++i) {\n\t\t\t\tfor (int j = 1; j < length; ++j) {\n\t\t\t\t\tadjacency[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid addEdges(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info, \",\");\n\t\t\tint a, b, c, d;\n\t\t\ta = Integer.parseInt(st.nextToken());\n\t\t\tb = Integer.parseInt(st.nextToken());\n\t\t\tc = Integer.parseInt(st.nextToken());\n\t\t\td = Integer.parseInt(st.nextToken());\n\n\t\t\tadjacency[a][b] = c;\n\t\t\tadjacency[b][a] = d;\n\n\t\t}\n\n\t\tint dijkstra(int start, int goal) {\n\n\t\t\tboolean[] checked = new boolean[length];\n\t\t\tint[] total = new int[length];\n\t\t\tint next;\n\n\t\t\tfor (int i = 1; i < length; ++i) {\n\t\t\t\ttotal[i] = Integer.MAX_VALUE;\n\t\t\t}\n\n\t\t\ttotal[start] = 0;\n\t\t\tnext = start;\n\t\t\twhile (next != -1) {\n\n\t\t\t\tint s = next;\n\t\t\t\tchecked[s] = true;\n\n\t\t\t\tfor (int g = 1; g < length; ++g) {\n\t\t\t\t\tif (adjacency[s][g] != -1) {\n\t\t\t\t\t\tif (total[g] > total[s] + adjacency[s][g]) {\n\t\t\t\t\t\t\ttotal[g] = total[s] + adjacency[s][g];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint min = Integer.MAX_VALUE, idx = -1;\n\t\t\t\tfor (int g = 1; g < length; ++g) {\n\t\t\t\t\tif (!checked[g] && min > total[g]) {\n\t\t\t\t\t\tmin = total[g];\n\t\t\t\t\t\tidx = g;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnext = idx;\n\t\t\t}\n\n\t\t\treturn total[goal];\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint[] cost = new int[n + 1];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\n\t\tint[][] num = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint b = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint c = Integer.valueOf(tokenizer.nextToken());\n\t\t\tint d = Integer.valueOf(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\n\t\t}\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint q = Integer.parseInt(tokenizer.nextToken());\n\t\tint r = Integer.parseInt(tokenizer.nextToken());\n\t\tint ans = Integer.parseInt(tokenizer.nextToken())\n\t\t\t\t- Integer.parseInt(tokenizer.nextToken());\n\t\tans = ans - getYen(q, r, num) - getYen(r, q, num);\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static int getYen(int q, int r, int[][] num) {\n\t\tint[] cost = new int[num.length];\n\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tcost[q] = 0;\n\t\tdeque.push(q);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tfor (int i = 0; i < deque.size(); i++) {\n\t\t\t\tint p = deque.pop();\n\t\t\t\tfor (int j = 1; j < num.length; j++) {\n\t\t\t\t\tif (num[p][j] != 0 && num[p][j] + cost[p] < cost[j]) {\n\t\t\t\t\t\tdeque.push(j);\n\t\t\t\t\t\tcost[j] = num[p][j] + cost[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost[r];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tDijkstra dk = new Dijkstra(n);\n\t\tfor (int i = 0;i<m;++i) {\n\t\t\tString[] route = sc.next().split(\",\");\n\t\t\tdk.addRoute(Integer.parseInt(route[0]),Integer.parseInt(route[1]),Integer.parseInt(route[2]));\n\t\t\tdk.addRoute(Integer.parseInt(route[1]),Integer.parseInt(route[0]),Integer.parseInt(route[3]));\n \t\t}\n\t\tString[] str = sc.next().split(\",\");\n\t\tSystem.out.println(dk.solve(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]),Integer.parseInt(str[3])));\n\t\t\n\t}\n\t\n\tstatic class Dijkstra {\n\t\tint[][] route;\n\t\tint cityNum;\n\t\tpublic Dijkstra (int n) {\n\t\t\tcityNum = n;\n\t\t\troute = new int[cityNum+1][cityNum+1];\n\t\t\tfor (int[] r : route) {\n\t\t\t\tArrays.fill(r, -1);\n\t\t\t}\n\t\t}\n\t\tpublic void addRoute(int from, int to, int cost) {\n\t\t\troute[from][to] = cost;\n\t\t}\n\t\tpublic int solve (int start, int goal, int money, int pay) {\n\t\t\tmoney = money - solve(start,goal);\n\t\t\tmoney = money - pay;\n\t\t\tmoney = money - solve(goal,start);\n\t\t\treturn money;\n\t\t}\n\t\tpublic int solve(int start, int goal) {\n\t\t\t\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(cityNum+1,new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] i1, int[] i2) {\n\t\t\t\t\treturn i1[1] - i2[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tboolean[] b = new boolean[cityNum+1];\n\t\t\tArrays.fill(b,false);\n\t\t\tint[] d = new int[cityNum+1];\n\t\t\tArrays.fill(d, Integer.MAX_VALUE);\n\t\t\t\n\t\t\tq.add(new int[]{start,0});\n\t\t\t\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint[] r = q.poll();\n\t\t\t\tint pos = r[0];\n\t\t\t\tint cost = r[1];\n\t\t\t\t\n\t\t\t\tif (pos == goal) {\n\t\t\t\t\treturn cost;\n\t\t\t\t}\n\t\t\t\tb[pos] = true;\n\t\t\t\td[pos] = cost;\n\t\t\t\t\n\t\t\t\tfor (int i=1;i<=cityNum;++i) {\n\t\t\t\t\tif (route[pos][i]+cost < d[i] && route[pos][i]!=-1) {\n\t\t\t\t\t\tq.remove(new int[]{i,d[i]});\n\t\t\t\t\t\td[i] = route[pos][i]+cost;\n\t\t\t\t\t\tq.add(new int[]{i,d[i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tString[] s = sc.next().split(\",\");\n\t\t\tint a = Integer.valueOf(s[0]) - 1;\n\t\t\tint b = Integer.valueOf(s[1]) - 1;\n\t\t\tint c = Integer.valueOf(s[2]);\n\t\t\tint d = Integer.valueOf(s[3]);\n\t\t\tg.addEdge(a, b, c);\n\t\t\tg.addEdge(b, a, d);\n\t\t}\n\t\tString[] s = sc.next().split(\",\");\n\t\tint x1 = Integer.valueOf(s[0]) - 1;\n\t\tint x2 = Integer.valueOf(s[1]) - 1;\n\t\tint y1 = Integer.valueOf(s[2]);\n\t\tint y2  = Integer.valueOf(s[3]);\n\t\tSystem.out.println(y1-y2-g.minDistDijkstra(x1)[x2]-g.minDistDijkstra(x2)[x1]);\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic int min;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint[][] num = new int[n + 1][n + 1];\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint b = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint c = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\t\t}\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint a = Integer.parseInt(tokenizer.nextToken());\n\t\tint b = Integer.parseInt(tokenizer.nextToken());\n\t\tint c = Integer.parseInt(tokenizer.nextToken());\n\t\tint d = Integer.parseInt(tokenizer.nextToken());\n\t\tmin = Integer.MAX_VALUE;\n\t\tint q = c-d;\n\t\tgetYen(a, 0, b, num, n, 0, a);\n\t\tq-=min;\n\t\tmin = Integer.MAX_VALUE;\n\t\tgetYen(b, 0, a, num, n, 0, b);\n\t\tq-=min;\n\t\tSystem.out.println(q);\n\t}\n\n\tpublic static void getYen(int a, int x, int b, int[][] num, int n, int yen,\n\t\t\tint g) {\n\t\tif (a == b) {\n\t\t\tmin = Math.min(min, yen);\n\t\t\treturn;\n\t\t}\n\t\tif (a == g && yen != 0 || yen > min) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (num[a][i] != 0 && i != x) {\n\t\t\t\tgetYen(i, a, b, num, n, yen + num[a][i], g);\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\n\tvoid run(){\n\t\tsc.useDelimiter(\"[,]|(\\\\s)+\");\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tLinkedList<E>[] es=new LinkedList[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tes[i]=new LinkedList<E>();\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint u=sc.nextInt()-1;\n\t\t\tint v=sc.nextInt()-1;\n\t\t\tint cost1=sc.nextInt();\n\t\t\tint cost2=sc.nextInt();\n\t\t\tes[u].add(new E(v, cost1));\n\t\t\tes[v].add(new E(u, cost2));\n\t\t}\n\n\t\tint s=sc.nextInt()-1;\n\t\tint g=sc.nextInt()-1;\n\t\tint m1=sc.nextInt();\n\t\tint m2=sc.nextInt();\n\n\t\tint ans=m1-m2-(dijkstra(es, s, g)+dijkstra(es, g, s));\n\t\tprintln(\"\"+ans);\n\t}\n\n\tint dijkstra(LinkedList<E>[] es, int s, int g){\n\t\tint n=es.length;\n\t\tint[] d=new int[n];\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\n\t\tArrays.fill(d, INF);\n\t\td[s]=0;\n\t\tque.offer(new P(s, 0));\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(d[p.v]<p.d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// debug(p);\n\t\t\tfor(E e : es[p.v]){\n\t\t\t\t// debug(\"\\t\"+e.to);\n\t\t\t\tif(d[e.to]>d[p.v]+e.cost){\n\t\t\t\t\td[e.to]=d[p.v]+e.cost;\n\t\t\t\t\tque.offer(new P(e.to, d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(d);\n\t\t}\n\t\t// debug();\n\t\treturn d[g];\n\t}\n\n\tclass E{\n\t\tint to, cost;\n\n\t\tE(int to, int cost){\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint v, d;\n\n\t\tP(int v, int d){\n\t\t\tthis.v=v;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn v+\",\"+d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Pair implements Comparable<Pair> {\n\n    final int cost;\n    final int to;\n\n    Pair( int cost, int to ) {\n\tthis.cost = cost;\n\tthis.to = to;\n    }\n\n    public int compareTo( Pair p ) {\n\treturn cost - p.cost;\n    }    \n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\n\tfinal int n = Integer.parseInt( stdin.nextLine() );\n\tfinal int m = Integer.parseInt( stdin.nextLine() );\n\tList< List<Pair> > map = new ArrayList< List<Pair> >();\n\tfor ( int i = 0; i <= n; i++ ) {\n\t    map.add( new ArrayList<Pair>() );\n\t}\n\tfor ( int i = 0; i < m; i++ ) {\n\t    String[] input = stdin.nextLine().trim().split( \",\" );\n\t    final int from = Integer.parseInt( input[ 0 ] );\n\t    final int to = Integer.parseInt( input[ 1 ] );\n\t    final int cost = Integer.parseInt( input[ 2 ] );\n\t    final int revCost = Integer.parseInt( input[ 3 ] );\n\t    map.get( from ).add( new Pair( cost, to ) );\n\t    map.get( to ).add( new Pair( revCost, from ) );\n\t}\n\tString[] input = stdin.nextLine().split( \",\" );\n\tint x1 = Integer.parseInt( input[ 0 ] );\n\tint x2 = Integer.parseInt( input[ 1 ] );\n\tint y1 = Integer.parseInt( input[ 2 ] );\n\tint y2 = Integer.parseInt( input[ 3 ] );\n\tSystem.out.println( y1 - y2 - dijkstra( x1, x2, map ) - dijkstra( x2, x1, map ) );\n    }\n\n    static int dijkstra( int start, int end, List< List< Pair > > map ) {\n\tint[] minDist = new int[ map.size() ];\n\tArrays.fill( minDist, 10000000 );\n\tminDist[ start ] = 0;\n\t\n\tPriorityQueue<Pair> que = new PriorityQueue<Pair>();\n\tque.add( new Pair( 0, start ) );\n\t\n\twhile ( !que.isEmpty() ) {\n\t    Pair p = que.poll();\n\t    if ( minDist[ p.to ] < p.cost ) {\n\t\tcontinue;\n\t    }\n\t    if ( p.to == end ) {\n\t\treturn p.cost;\n\t    }\n\t    for ( Pair edge : map.get( p.to ) ){\n\t\tque.add( new Pair( p.cost + edge.cost, edge.to ) );\n\t\tminDist[ edge.to ] = min( minDist[ edge.to ], p.cost + edge.cost );\n\t    }\n\t}\n\treturn -1;\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\tint[][] map = new int[n+1][n+1];\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tString[] s = sc.next().split(\",\");\n\t\t\tint a=Integer.parseInt(s[0]), b=Integer.parseInt(s[1]);\n\t\t\tmap[a][b] = Integer.parseInt(s[2]);\n\t\t\tmap[b][a] = Integer.parseInt(s[3]);\n\t\t}\n\n\t\tString[] s = sc.next().split(\",\");\n\t\tint x1=Integer.parseInt(s[0]), x2=Integer.parseInt(s[1]);\n\t\tint ans = Integer.parseInt(s[2]) - Integer.parseInt(s[3]);\n\n\t\tans -= minCost(x1,x2,map);\n\t\tans -= minCost(x2,x1,map);\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int minCost(int s,int g,int[][] map){\n\t\tQueue<State> open = new PriorityQueue<State>();\n\t\tSet<State> closed = new HashSet<State>();\n\n\t\tState st = new State(0,s);\n\t\topen.add(st);\n\n\t\tState ans = null;\n\t\twhile(!open.isEmpty()){\n\t\t\tst = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tclosed.add(st);\n\t\t\tif(st.n == g){\n\t\t\t\tans = st;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topen.addAll(st.nexts(map));\n\t\t}\n\n\t\treturn ans.cost;\n\t}\n\n\tstatic class State implements Comparable<State>{\n\t\tint cost, n;\n\n\t\tState(int cost,int n){\n\t\t\tthis.cost = cost;\n\t\t\tthis.n = n;\n\t\t}\n\n\t\tList<State> nexts(int[][] map){\n\t\t\tList<State> sts = new ArrayList<State>();\n\t\t\tfor(int i=1;i<map.length;i++){\n\t\t\t\tif(n == i) continue;\n\t\t\t\tif(map[n][i] > 0) sts.add(new State(cost+map[n][i],i));\n\t\t\t}\n\t\t\treturn sts;\n\t\t}\n\n\t\tpublic int compareTo(State st){\n\t\t\treturn cost - st.cost;\n\t\t}\n\n\t\tpublic boolean equals(Object o){\n\t\t\tState st = (State)o;\n\t\t\treturn this.n == st.n;\n\t\t}\n\n\t\tpublic int hashCode(){\n\t\t\treturn this.n;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tint[][] cost;\n\tboolean[] visit;\n\tint[] dist;\n\tint n;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tn = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tcost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tArrays.fill(cost[i], 1000000);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0])-1;\n\t\t\t\tint b = Integer.parseInt(str[1])-1;\n\t\t\t\tcost[a][b] = Integer.parseInt(str[2]);\n\t\t\t\tcost[b][a] = Integer.parseInt(str[3]);\n\t\t\t}\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tint[] x = {Integer.parseInt(str[0])-1,Integer.parseInt(str[1])-1};\n\t\t\tint reward = Integer.parseInt(str[2]) - Integer.parseInt(str[3]);\n\t\t\tfor(int i = 0;i < 2;i++){\n\t\t\t\tvisit = new boolean[n];\n\t\t\t\tdist = new int[n];\n\t\t\t\tArrays.fill(dist,1000000);\n\t\t\t\tArrays.fill(visit,false);\n\t\t\t\tdijkstra(x[i]);\n\t\t\t\treward -= dist[x[(i+1)%2]];\n\t\t\t}\n\t\t\tSystem.out.println(reward);\n\t\t}\n\t}\n\tpublic void dijkstra(int start){\n\t\tdist[start] = 0;\n\t\twhile(true){\n\t\t\tint min = 1000000;\n\t\t\tint next = -1;\n\t\t\tfor(int u = 0;u < n;u++){\n\t\t\t\tif(visit[u]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdist[u] = Math.min(dist[u],dist[start] + cost[start][u]);\n\t\t\t\tif(dist[u] < min){\n\t\t\t\t\tmin = dist[u];\n\t\t\t\t\tnext = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[start] = true;\n\t\t\tstart = next;\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic int count = 0;\n\t\n\n\tstatic int cost[][] = new int[22][22];\n\tstatic int d[] = new int[22];\n\tstatic boolean used[] = new boolean[22];\n\tstatic int V;\n\tstatic int INF = 2 << 28;\n\t\n\tpublic static void main(String[] args) {\n\t\tV = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tfor(int i = 0; i < 21; i++) {\n\t\t\tArrays.fill(cost[i], INF);\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\tint[] xx = new int[4];\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\txx[j] = Integer.parseInt(tmp[j]);\n\t\t\t}\n\t\t\t\n\t\t\tcost[xx[0]-1][xx[1]-1] = xx[2];\n\t\t\tcost[xx[1]-1][xx[0]-1] = xx[3];\n\t\t}\n\t\tString[] tmp = sc.next().split(\",\");\n\t\tint[] xx = new int[4];\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\txx[j] = Integer.parseInt(tmp[j]);\n\t\t}\n\t\t\n\t\tdijkstra(xx[0]-1);\n\t\tint a1 = d[xx[1]-1];\n\t\tdijkstra(xx[1]-1);\n\t\tint a2 = d[xx[0]-1];\n\t\tout.println((xx[2] - a1 - a2 - xx[3]));\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic void dijkstra(int s) {\n\t\tArrays.fill(d, INF);\n\t\tArrays.fill(used, false);\n\t\td[s] = 0;\n\t\t\n\t\twhile(true) {\n\t\t\tint v = -1;\n\t\t\t\n\t\t\tfor(int u = 0; u < V; u++) {\n\t\t\t\tif(!used[u] && ( v == -1 || d[u] < d[v])) v = u;\n\t\t\t\t\n\t\t\t}\n\t\t\tif( v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tfor(int u = 0; u < V; u++) {\n\t\t\t\td[u] = Math.min(d[u],d[v] + cost[v][u]);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\t\tPair(int a, int b) {\n\t\t\tfirst = a;\n\t\t\tsecond = b;\n\t\t}\n\t}\n\t\n\tstatic class Edge {\n\t\tint to;\n\t\tint cost;\n\t\tEdge(int a, int b) {\n\t\t\tto = a;\n\t\t\tcost = b;\n\t\t}\n\t}\n\n}\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n,m,s,g,money,pillar;\n\tstatic int[][] edge;\n\tstatic int[][] min;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tn=cin.nextInt();\n\t\tm=cin.nextInt();\n\t\tedge=new int[n+1][n+1];\n\t\tmin=new int[n+1][2];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tmin[i][0]=min[i][1]=1<<30;\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tArrays.fill(edge[i], 1<<30);\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tString[] s = cin.next().split(\",\");\n\t\t\t\n\t\t\tint a=Integer.parseInt(s[0]);\n\t\t\tint b=Integer.parseInt(s[1]);\n\t\t\tint c=Integer.parseInt(s[2]);\n\t\t\tint d=Integer.parseInt(s[3]);\n\t\t\tedge[a][b]=c;\n\t\t\tedge[b][a]=d;\n\t\t}\n\t\tString[] ss = cin.next().split(\",\");\n\t\ts=Integer.parseInt(ss[0]);\n\t\tg=Integer.parseInt(ss[1]);\n\t\tmoney=Integer.parseInt(ss[2])-Integer.parseInt(ss[3]);\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(100,new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a,int [] b){\n\t\t\t\treturn a[1]-b[1];\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{s,0});\n\t\tmin[s][0]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[now][i]!=1<<30){\n\t\t\t\t\tif(min[i][0]>cost+edge[now][i]){\n\t\t\t\t\t\tmin[i][0]=cost+edge[now][i];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][0]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tq.add(new int[]{g,0});\n\t\tmin[g][1]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n//\t\t\tSystem.out.println(now+\" \"+cost);\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[now][i]!=1<<30){\n\t\t\t\t\tif(min[i][1]>cost+edge[now][i]){\n\t\t\t\t\t\tmin[i][1]=cost+edge[now][i];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][1]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(money-min[g][0]-min[s][1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\t\n\t\tint n = Integer.valueOf(reader.readLine());\n\t\tint m = Integer.valueOf(reader.readLine());\n\t\t\n\t\tint cost[][] = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){ Arrays.fill(cost[i], 1 << 29); }\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString str[] = reader.readLine().split(\",\");\n\t\t\tint a = Integer.valueOf(str[0]) - 1;\n\t\t\tint b = Integer.valueOf(str[1]) - 1;\n\t\t\tcost[a][b] = Integer.valueOf(str[2]);\n\t\t\tcost[b][a] = Integer.valueOf(str[3]);\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString str[] = reader.readLine().split(\",\");\n\t\tint a = Integer.valueOf(str[0]) - 1;\n\t\tint b = Integer.valueOf(str[1]) - 1;\n\t\tint c = Integer.valueOf(str[2]);\n\t\tint d = Integer.valueOf(str[3]);\n\t\tSystem.out.println(c - d - cost[a][b] - cost[b][a]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import static java.lang.Integer.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b,h=MAX_VALUE;int[][] p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=valueOf(z[0])-1;b=valueOf(z[1])-1;p[a][b]=valueOf(z[2]);p[b][a]=valueOf(z[3]);}z=s.next().split(\",\");v=new int[n];System.out.println(valueOf(z[2])-valueOf(z[3])-f(a=valueOf(z[0])-1,b=valueOf(z[1])-1,p,n,h)-f(b,a,p,n,h));}static int f(int a,int b,int[][]g,int n,int m){if(a==b)return 0;int c=MAX_VALUE,i=0;for(;i<n;++i)if(v[i]<1&&g[a][i]>0){v[i]=1;c=Math.min(c,f(i,b,g,n,c)+g[a][b]);v[i]=0;if(c>m)return c;}return c;}static int[]v;}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\n\tvoid run(){\n\t\tsc.useDelimiter(\"[,]|(\\\\s)+\");\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\tLinkedList<E>[] es=new LinkedList[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tes[i]=new LinkedList<E>();\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint u=sc.nextInt()-1;\n\t\t\tint v=sc.nextInt()-1;\n\t\t\tint cost1=sc.nextInt();\n\t\t\tint cost2=sc.nextInt();\n\t\t\tes[u].add(new E(v, cost1));\n\t\t\tes[v].add(new E(u, cost2));\n\t\t}\n\n\t\tint s=sc.nextInt()-1;\n\t\tint g=sc.nextInt()-1;\n\t\tint m1=sc.nextInt();\n\t\tint m2=sc.nextInt();\n\n\t\tint ans=m1-m2-(dijkstra(es, s, g)+dijkstra(es, g, s));\n\t\tprintln(\"\"+ans);\n\t}\n\n\tint dijkstra(LinkedList<E>[] es, int s, int g){\n\t\tint n=es.length;\n\t\tint[] d=new int[n];\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\n\t\tArrays.fill(d, INF);\n\t\td[s]=0;\n\t\tque.offer(new P(s, 0));\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(d[p.v]<p.d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// debug(p);\n\t\t\tfor(E e : es[p.v]){\n\t\t\t\t// debug(\"\\t\"+e.to);\n\t\t\t\tif(d[e.to]>d[p.v]+e.cost){\n\t\t\t\t\td[e.to]=d[p.v]+e.cost;\n\t\t\t\t\tque.offer(new P(e.to, d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(d);\n\t\t}\n\t\t// debug();\n\t\treturn d[g];\n\t}\n\n\tclass E{\n\t\tint to, cost;\n\n\t\tE(int to, int cost){\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint v, d;\n\n\t\tP(int v, int d){\n\t\t\tthis.v=v;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn v+\",\"+d;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\t\n\t\tint n = Integer.valueOf(reader.readLine());\n\t\tint m = Integer.valueOf(reader.readLine());\n\t\tint map[][] = new int[n][n], now, cost = 0;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a[] = app.splitter(reader.readLine().toString());\n\t\t\tmap[a[0] - 1][a[1] - 1] = a[2];\n\t\t\tmap[a[1] - 1][a[0] - 1] = a[3];\n\t\t}\n\t\tint a[] = app.splitter(reader.readLine());\n\t\t\n\t\tcost = a[2];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tArrayDeque<int[]> que = new ArrayDeque<int[]>();\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tvisit[a[i] - 1] = true;\n\t\t\tque.addLast(new int[]{a[i] - 1, cost});\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tnow = que.getFirst()[0];\n\t\t\t\tcost = que.getFirst()[1];\n\t\t\t\tque.removeFirst();\n\t\t\t\t\n\t\t\t\tif(now == a[i == 0 ? 1 : 0]) break;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < map[now].length; j++){\n\t\t\t\t\tif(map[now][j] > 0 && !visit[j]){\n\t\t\t\t\t\tcost -= map[now][j];\n\t\t\t\t\t\tque.addLast(new int[]{j, cost});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cost - a[3]);\n\t\treader.close();\n\t}\n\t\n\tpublic int[] splitter(String source){\n\t\tString str[] = source.split(\",\");\n\t\tint array[] = new int[str.length];\n\t\tfor(int i = 0; i < str.length; i++){\n\t\t\tarray[i] = Integer.valueOf(str[i]);\n\t\t}\n\t\treturn array;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int city_number, way_number;\n\tstatic int[][] way;\n\tstatic int[] Array = new int[4];\n\tstatic int start, goal, reward, cost;\n\tstatic final int INF = 10000000;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\tread();\n\t\tslove();\n\t}\n\tstatic boolean read(){\n\t\tcity_number = sc.nextInt();\n\t\tway_number = sc.nextInt();\n\t\tway = new int[city_number+1][city_number+1];\n\t\t\n\t\tfor (int i = 0; i <= city_number; i++) {\n\t\t\tArrays.fill(way[i], INF);\n\t\t\tway[i][i] = 0;\n\t\t}\n\t\t\n\t\tsc.nextLine();\n\n\t\tString line;\n\t\tfor(int i = 1; i < way_number + 1; i++){\n\t\t\tint a, b, c, d;\n\t\t\tline = sc.nextLine();\n\t\t\tString[] ss = line.split(\",\");\n\t\t\ta = Integer.parseInt(ss[0].trim());\n\t\t\tb = Integer.parseInt(ss[1].trim());\n\t\t\tc = Integer.parseInt(ss[2].trim());\n\t\t\td = Integer.parseInt(ss[3].trim());\n\n\t\t\tway[a][b] = c;\n\t\t\tway[b][a] = d;\n\t\t}\n\t\t\n\t\tline = sc.nextLine();\n\t\tString[] aa = line.split(\",\");\n\t\tstart = Integer.parseInt(aa[0]);\n\t\tgoal = Integer.parseInt(aa[1]);\n\t\treward = Integer.parseInt(aa[2]);\n\t\tcost = Integer.parseInt(aa[3]);\n\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tfor (int t = 1; t <= city_number; t++) {\n\t\t\tfor (int u = 1; u <= city_number; u++) {\n\t\t\t\tfor (int v = 1; v <= city_number; v++) {\n\t\t\t\t\tway[u][v] = Math.min(way[u][v], way[u][t] + way[t][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor (int u = 1; u <= city_number; u++) {\n\t\t\tfor (int v = 1; v <= city_number; v++) {\n\t\t\t\tSystem.out.print(way[u][v] + \"     \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\tint s = Array[0], g = Array[1], wage = Array[2], f = Array[3]; \n\t\tSystem.out.println(reward - cost - way[start][goal] - way[goal][start]);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * A Reward for a Carpenter\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tGraph graph = main.new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tgraph.addEdges(br.readLine());\n\t\t\t}\n\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine(), \",\");\n\t\t\tint s = Integer.parseInt(st.nextToken());// start\n\t\t\tint g = Integer.parseInt(st.nextToken());// goal\n\t\t\tint b = Integer.parseInt(st.nextToken());// budget\n\t\t\tint p = Integer.parseInt(st.nextToken());// pillar\n\n\t\t\t//\n\t\t\tint way, back;\n\t\t\tway = graph.dijkstra(s, g);\n\t\t\tback = graph.dijkstra(g, s);\n\n\t\t\tSystem.out.println(b - p - way - back);\n\n\t\t}\n\t}\n\n\tclass Graph {\n\n\t\tfinal int INFINITY = Integer.MAX_VALUE;\n\t\tfinal int UNREACHABLE = -1;\n\n\t\tint length;\n\t\tint[][] adjacency;\n\n\t\tGraph(int n) {\n\t\t\tlength = n + 1;\n\t\t\tadjacency = new int[length][length];\n\t\t\tfor (int i = 1; i < length; ++i) {\n\t\t\t\tfor (int j = 1; j < length; ++j) {\n\t\t\t\t\tadjacency[i][j] = UNREACHABLE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid addEdges(String info) {\n\t\t\tStringTokenizer st = new StringTokenizer(info, \",\");\n\t\t\tint a, b, c, d;\n\t\t\ta = Integer.parseInt(st.nextToken());\n\t\t\tb = Integer.parseInt(st.nextToken());\n\t\t\tc = Integer.parseInt(st.nextToken());\n\t\t\td = Integer.parseInt(st.nextToken());\n\n\t\t\tadjacency[a][b] = c;\n\t\t\tadjacency[b][a] = d;\n\n\t\t}\n\n\t\tint dijkstra(int start, int goal) {\n\n\t\t\tboolean[] checked = new boolean[length];\n\t\t\tint[] total = new int[length];\n\t\t\tint next;\n\n\t\t\tfor (int i = 1; i < length; ++i) {\n\t\t\t\ttotal[i] = INFINITY;\n\t\t\t}\n\n\t\t\ttotal[start] = 0;\n\t\t\tnext = start;\n\t\t\twhile (next != UNREACHABLE) {\n\n\t\t\t\tint s = next;\n\t\t\t\tchecked[s] = true;\n\n\t\t\t\tfor (int g = 1; g < length; ++g) {\n\t\t\t\t\tif (adjacency[s][g] != UNREACHABLE) {\n\t\t\t\t\t\tif (total[g] > total[s] + adjacency[s][g]) {\n\t\t\t\t\t\t\ttotal[g] = total[s] + adjacency[s][g];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint min = INFINITY, idx = UNREACHABLE;\n\t\t\t\tfor (int g = 1; g < length; ++g) {\n\t\t\t\t\tif (!checked[g] && min > total[g]) {\n\t\t\t\t\t\tmin = total[g];\n\t\t\t\t\t\tidx = g;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnext = idx;\n\t\t\t}\n\n\t\t\treturn total[goal];\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,m=s.nextInt(),i=1,j,t;int[] p=new int[n*n];Arrays.fill(p,9999999);for(;i<n;++i)p[i*n+i]=0;for(;m-->0;){z=s.next().split(\",\");i=new Integer(z[0]);j=new Integer(z[1]);p[i*n+j]=new Integer(z[2]);p[j*n+i]=new Integer(z[3]);}for(t=1;t<n;++t)for(i=1;i<n;++i)for(j=1;j<n;++j)if(p[i*n+j]>(m=p[i*n+t]+p[t*n+j]))p[i*n+j]=m;z=s.next().split(\",\");i=new Integer(z[0]);j=new Integer(z[1]);System.out.println(new Integer(z[2])-new Integer(z[3])-p[i*n+j]-p[j*n+i]);}}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\npublic class Main {\n\tint N,M,s,g,V,P;\n\tArrayList<Integer>[] graph;\n\tint[][] cost;\n\n\tprivate class P implements Comparable<P>{\n\t\tint first,second;\n\t\tpublic P(int first,int second){\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\tpublic int compareTo(P p){\n\t\t\tif(this.first == p.first){\n\t\t\t\treturn this.second - p.second;\n\t\t\t}\n\t\t\treturn this.first - p.first;\n\t\t}\n\n\t}\n\n\tpublic int dijkstra(int s,int t){\n\t\tint[] dis = new int[N];\n\t\tArrays.fill(dis, (int)1e9 + 7);\n\t\tPriorityQueue<P> pq = new PriorityQueue<P>();\n\t\tpq.add(new P(0,s));\n\t\tdis[s] = 0;\n\t\twhile(pq.size() > 0){\n\t\t\tP p = pq.poll();\n\t\t\tif(dis[p.second] < p.first)continue;\n\t\t\tdis[p.second] = p.first;\n\t\t\tfor(int next : graph[p.second]){\n\t\t\t\tif(dis[next] > p.first + cost[p.second][next]){\n\t\t\t\t\tpq.add(new P(p.first + cost[p.second][next],next));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[t];\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tcost = new int[N][N];\n\t\tgraph = new ArrayList[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tString[] line = next().split(\",\");\n\t\t\tint a = Integer.parseInt(line[0]) - 1;\n\t\t\tint b = Integer.parseInt(line[1]) - 1;\n\t\t\tint c = Integer.parseInt(line[2]);\n\t\t\tint d = Integer.parseInt(line[3]);\n\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = d;\n\n\t\t\tgraph[a].add(b);\n\t\t\tgraph[b].add(a);\n\t\t}\n\n\t\tString[] line = next().split(\",\");\n\t\ts = Integer.parseInt(line[0]) - 1;\n\t\tg = Integer.parseInt(line[1]) - 1;\n\t\tV = Integer.parseInt(line[2]);\n\t\tP = Integer.parseInt(line[3]);\n\n\t\tint go = dijkstra(s,g);\n\t\tint back = dijkstra(g,s);\n\n\t\tout.println(V - go - back - P);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tint[] cost = new int[n+1];\n\t\t\tfor(int i=0;i<n+1;i++) cost[i] = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tint[] a = new int[m+1];\n\t\t\tint[] b = new int[m+1];\n\t\t\tint[] c = new int[m+1];\n\t\t\tint[] d = new int[m+1];\t\n\t\t\t\n\t\t\tArrayDeque<Integer> que = new ArrayDeque<Integer>();\n\n\t\t\tfor(int i=0;i<m+1;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\ta[i] = Integer.valueOf(s[0]);\n\t\t\t\tb[i] = Integer.valueOf(s[1]);\n\t\t\t\tc[i] = Integer.valueOf(s[2]);\n\t\t\t\td[i] = Integer.valueOf(s[3]);\n\t\t\t}\n\t\t\tint ans = c[m] - d[m];\n\t\t\tint z, p;\n\t\t\tint q = a[m];\n\t\t\tint r = b[m];\n\t\t\t\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tif(k==1){\n\t\t\t\t\tq = b[m];\n\t\t\t\t\tr = a[m];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.offer(q);\n\t\t\t\tcost[q] = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\tz = que.size();\n\t\t\t\t\tif(z==0) break;\n\t\t\t\t\tfor(int i=0;i<z;i++){\n\t\t\t\t\t\tp = que.poll();\n\t\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\t\tif(a[j]==p && cost[p]+c[j]<cost[b[j]]){\n\t\t\t\t\t\t\t\tque.offer(b[j]);\n\t\t\t\t\t\t\t\tcost[b[j]] = cost[p]+c[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(b[j]==p && cost[p]+d[j]<cost[a[j]]){\n\t\t\t\t\t\t\t\tque.offer(a[j]);\n\t\t\t\t\t\t\t\tcost[a[j]] = cost[p]+d[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans -= cost[r];\n\t\t\t\t\n\t\t\t\tif(k==0){\n\t\t\t\t\tfor(int i=0;i<n+1;i++) cost[i] = Integer.MAX_VALUE;\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint m = Integer.parseInt(br.readLine());\n\n\t\tint[][] matrix = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(matrix[i], Integer.MAX_VALUE);\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\",\");\n\t\t\tint a = Integer.parseInt(tmpArray[0])-1;\n\t\t\tint b = Integer.parseInt(tmpArray[1])-1;\n\t\t\tint c = Integer.parseInt(tmpArray[2]);\n\t\t\tint d = Integer.parseInt(tmpArray[3]);\n\n\t\t\tmatrix[a][b] = c;\n\t\t\tmatrix[b][a] = d;\n\t\t\t//System.out.println(i);\n\t\t}\n//\n//\t\tfor(int i = 0; i < n ; i++){\n//\t\t\tfor(int j = 0; j < n; j++){\n//\t\t\t\tSystem.out.print(matrix[i][j]+\" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\n\t\t//System.out.println(\"read\");\n\t\t//System.out.println(br.readLine());\n\t\tString[] tmpArray = br.readLine().split(\",\");\n\t\tint start = Integer.parseInt(tmpArray[0])-1;\n\t\tint goal = Integer.parseInt(tmpArray[1])-1;\n\t\tint reward = Integer.parseInt(tmpArray[2]);\n\t\tint pay = Integer.parseInt(tmpArray[3]);\n\n\t\t//System.out.println(\"test\");\n\t\tint[] go = singleSourceShortestDense(matrix, start);\n\t\tint[] back = singleSourceShortestDense(matrix, goal);\n\t\t//System.out.printf(\"%d %d %d %d\\n\", start, goal, reward, pay);\n//\n//\t\tfor(int i = 0; i < n ; i++){\n//\t\t\tSystem.out.println(\"go[\"+i+\"] = \" +go[i] + \" back[\"+i+\"] = \"+ back[i]);\n//\t\t}\n\n\t\tSystem.out.println(reward - go[goal] - back[start] - pay);\n\n\t}\n\n\tstatic int[] singleSourceShortestDense(int[][] matrix, int s){\n        int n = matrix[0].length;\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        boolean[] visited = new boolean[n];\n        Arrays.fill(visited, false);\n\n        dist[s] = 0;\n\n        while(true){\n        \t//System.out.println(\"IN SSD\");\n            int u = -1;\n            int sd = Integer.MAX_VALUE;\n\n            for(int i = 0; i < n ; i++){\n                if(!visited[i] && dist[i] < sd){\n                    sd = dist[i];\n                    u = i;\n                }\n            }\n\n            if(u == -1){\n                break;\n            }\n\n            visited[u] = true;\n            for(int v = 0; v < n ; v++){\n            \t//System.out.println(\"v = \"+v);\n                int w = matrix[u][v];\n                if(v == u) continue;\n\n                long newLen = dist[u];\n                newLen += w;\n                //System.out.println(\"NEWLEN \"+newLen);\n                if(newLen < dist[v]){\n                    dist[v] = (int)newLen;\n                }\n            }\n\n        }\n\n        return dist;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n\npublic class Main {\n\t\n\tint d[];\n\tboolean used[];\n\tint g[][];\n\tfinal int INF = 1 << 28;\n\t\n\tint die(int s, int e, int n){\n\t\tused = new boolean[n];\n\t\td = new int[n];\n\t\tfor(int j=0; j<n; ++j){ d[j] = INF; }\n\t\t\n\t\td[s] = 0;\n\t\twhile(true){\n\t\t\tint u = -1;\n\t\t\tfor(int v=0; v<n; ++v){\n\t\t\t\tif(!used[v] && (u==-1 || d[v] < d[u])){\n\t\t\t\t\tu = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u==-1){ break; }\n\t\t\tused[u] = true;\n\t\t\tfor(int v=0; v<n; ++v){\n\t\t\t\tif(d[v] > d[u] + g[u][v]){\n\t\t\t\t\td[v] = d[u] + g[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn d[e];\n\t}\n\t\n\tvoid io(){\n\t\tjava.util.Scanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()){\n\t\t\tfinal int n = Integer.parseInt(sc.nextLine())+1;\n\t\t\tg = new int[n][n];\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\t\tg[i][j] = i==j ? 0 : INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal int m = Integer.parseInt(sc.nextLine());\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tString str[] = sc.nextLine().split(\",\");\n\t\t\t\tint data[] = new int[str.length];\n\t\t\t\tfor(int j=0; j<str.length; ++j){\n\t\t\t\t\tString str2[] = (str[j] + \" \").split(\" \");\n\t\t\t\t\tdata[j] = Integer.parseInt(str2[0]);\n\t\t\t\t}\n\t\t\t\tfinal int a = data[0];\n\t\t\t\tfinal int b = data[1];\n\t\t\t\tfinal int c = data[2];\n\t\t\t\tfinal int d = data[3];\n\t\t\t\t\n\t\t\t\tg[a][b] = c;\n\t\t\t\tg[b][a] = d;\n\t\t\t}\n\t\t\tString str[] = sc.nextLine().split(\",\");\n\t\t\tint data[] = new int[str.length];\n\t\t\tfor(int j=0; j<str.length; ++j){\n\t\t\t\tdata[j] = Integer.parseInt(str[j]);\n\t\t\t}\n\t\t\tfinal int x1 = data[0];\n\t\t\tfinal int x2 = data[1];\n\t\t\tfinal int y1 = data[2];\n\t\t\tfinal int y2 = data[3];\n\t\t\t\n\t\t\tSystem.out.println(y1 - y2 - (die(x1, x2, n) + die(x2, x1, n)));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tint Dijkstra(int[][] cost, int s, int g) {\n\n\t\tint[] tc = new int[cost.length];\n\n\t\tArrays.fill(tc, Integer.MAX_VALUE);\n\n\t\ttc[s] = 0;\n\n\t\tboolean[] visited = new boolean[cost.length];\n\n\t\tfor (;!visited[g];) {\n\n\t\t\tint min = Integer.MAX_VALUE;\n\n\t\t\tint v = 0;\n\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\n\t\t\t\tif (visited[i])\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (min > tc[i]) {\n\n\t\t\t\t\tv = i;\n\n\t\t\t\t\tmin = tc[i];\n\n\t\t\t\t}\n\n\t\t\t}\n\n//\t\t\tSystem.out.println(v+\" \"+tc[v]);\n\n\t\t\tvisited[v] = true;\n\n\t\t\tfor (int k = 0; k < cost.length; k++) {\n\n\t\t\t\tif (cost[v][k] != Integer.MAX_VALUE)\n\n\t\t\t\t\ttc[k] = Math.min(tc[v] + cost[v][k], tc[k]);\n\n//\t\t\t\tSystem.out.println(\" \"+tc[k]);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn tc[g];\n\n\t}\n\n\n\n\tvoid run(){\n\n\t\tint n = sc.nextInt();\n\n\t\tint m = sc.nextInt();\n\n\t\tint cost[][] = new int[n][n];\n\n\t\tfor(int i =0 ; i < n;i++){\n\n\t\t\tArrays.fill(cost[i],Integer.MAX_VALUE);\n\n\t\t}\n\n\t\tfor(int i = 0 ; i < m ; i++){\n\n\t\t\tString buffer = sc.next();\n\n\t\t\tScanner in = new Scanner(buffer.replace(',', ' '));\n\n\t\t\tint a = in.nextInt()-1;\n\n\t\t\tint b = in.nextInt()-1;\n\n\t\t\tint c = in.nextInt();\n\n\t\t\tint d = in.nextInt();\n\n\t\t\tcost[a][b] = c;\n\n\t\t\tcost[b][a] = d;\n\n\t\t}\n\n\t\tString buffer = sc.next();\n\n\t\tScanner in = new Scanner(buffer.replace(',', ' '));\n\n\t\tint s = in.nextInt()-1;\n\n\t\tint g = in.nextInt()-1;\n\n\t\tint zzz = in.nextInt();\n\n\t\tint zz = in.nextInt();\n\n\t\tint r = zzz - zz;\n\n\t\tSystem.out.println(r-Dijkstra(cost,s,g)-Dijkstra(cost,g,s));\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//A reward for a Carpentor\npublic class Main {\n\n\tpublic static int n;\n\tpublic static int m;\n\n\tpublic static int[] dist;\n\tpublic static int[][] cost;\n\n\tpublic static int dijkstra(int s, int t){\n\t\tdist = new int[n+1];\n\t\tArrays.fill(dist, Integer.MAX_VALUE);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn dist[o1]-dist[o2];\n\t\t\t}\n\t\t});\n\t\tq.add(s);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v == t)return dist[t];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(cost[v][i]!=Integer.MAX_VALUE){\n\t\t\t\t\tint w = dist[v]+cost[v][i];\n\t\t\t\t\tif(w<dist[i]){\n\t\t\t\t\t\tdist[i] = w;\n\t\t\t\t\t\tq.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tsc.nextLine();\n\t\tcost = new int[n+1][n+1];\n\t\tfor(int[] a:cost)Arrays.fill(a, Integer.MAX_VALUE);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tString[] s = sc.nextLine().split(\",\");\n\t\t\tint a = Integer.parseInt(s[0]);\n\t\t\tint b = Integer.parseInt(s[1]);\n\t\t\tint c = Integer.parseInt(s[2]);\n\t\t\tint d = Integer.parseInt(s[3]);\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = d;\n\t\t}\n\t\tString[] s = sc.nextLine().split(\",\");\n\t\tint a = Integer.parseInt(s[0]);\n\t\tint b = Integer.parseInt(s[1]);\n\t\tint c = Integer.parseInt(s[2]);\n\t\tint d = Integer.parseInt(s[3]);\n\t\tSystem.out.println(c-d-dijkstra(a, b)-dijkstra(b, a));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic void setEdge(List<ArrayList<int[]>> edge, String input) {\n\t\tString[] str = input.split(\",\");\n\t\tint from = Integer.parseInt(str[0]);\n\t\tint to = Integer.parseInt(str[1]);\n\t\tint cost1 = Integer.parseInt(str[2]);\n\t\tint cost2 = Integer.parseInt(str[3]);\n\t\tedge.get(from - 1).add(new int[] { to - 1, cost1 });\n\t\tedge.get(to - 1).add(new int[] { from - 1, cost2 });\n\t}\n\t\n\tstatic int[][] floydwarshall(List<ArrayList<int[]>> edge){\n\t\tint[][] dist = new int[edge.size()][edge.size()];\n\t\t/* 初期化 */\n\t\tfor(int i = 0; i < edge.size(); i++){\n\t\t\tfor(int j = 0; j < edge.size(); j++){\n\t\t\t\tdist[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tdist[i][i] = 0;\n\t\t\t/*　隣接している接点についてコスト計算 */\n\t\t\tfor(int[] e : edge.get(i)){\n\t\t\t\tdist[i][e[0]] = e[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* 中継地点となる節点について繰り返す */\n\t\tfor(int k = 0; k < edge.size(); k++){\n\t\t\tfor(int i = 0; i < edge.size(); i++){\n\t\t\t\t/* 2節点が隣接していない場合は処理しない */\n\t\t\t\tif(dist[i][k] == Integer.MAX_VALUE){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < edge.size(); j++){\n\t\t\t\t\tlong newLength = dist[i][k];\n\t\t\t\t\t/* \n\t\t\t\t\t * どの節点と隣接しているかは考慮せず、\n\t\t\t\t\t * 単にコスト計算と更新処理を行う\n\t\t\t\t\t */\n\t\t\t\t\tnewLength += dist[k][j];\n\t\t\t\t\tif(newLength < dist[i][j]){\n\t\t\t\t\t\tdist[i][j] = (int)newLength;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint city = s.nextInt();\n\t\tint numEdge = s.nextInt();\n\t\tList<ArrayList<int[]>> edge = new ArrayList<ArrayList<int[]>>();\n\t\tfor(int i = 0; i < city; i++){\n\t\t\tedge.add(new ArrayList<int[]>());\n\t\t}\n\t\tfor (int i = 0; i < numEdge; i++) {\n\t\t\tsetEdge(edge, s.next());\n\t\t}\n\t\tString[] input = s.next().split(\",\");\n\t\tint start = Integer.parseInt(input[0]);\n\t\tint dest = Integer.parseInt(input[1]);\n\t\tint money = Integer.parseInt(input[2]);\n\t\tint price = Integer.parseInt(input[3]);\n\n\t\tint[][] dist = floydwarshall(edge);\n\t\tSystem.out.println(money - price - dist[start - 1][dest - 1] - dist[dest - 1][start - 1]);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import static java.lang.Integer.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b;int[][] p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=valueOf(z[0])-1;b=valueOf(z[1])-1;p[a][b]=valueOf(z[2]);p[b][a]=valueOf(z[3]);}z=s.next().split(\",\");System.out.println(valueOf(z[2])-valueOf(z[3])-f(a=valueOf(z[0])-1,b=valueOf(z[1])-1,p,n)-f(b,a,p,n));}static int f(int a,int b,int[][]g,int n){LinkedList<int[]>q=new LinkedList<int[]>();int[]v={a,0};q.add(v);int c=MAX_VALUE,i,t,k,l;for(v=new int[n];!q.isEmpty();){k=q.peek()[0];l=q.poll()[1];if(k==b&&c>l){c=l;continue;}v[k]=1;for(i=0;i<n;++i)if(v[i]<1&&k!=i&&(t=g[k][i])>0)q.add(new int[]{i,l+t});Collections.sort(q,new Comparator<int[]>(){public int compare(int[]x,int[]y){return x[1]-y[1];}});}return c;}}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic int min;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint[][] num = new int[n + 1][n + 1];\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\t\tint a = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint b = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint c = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken());\n\t\t\tnum[a][b] = c;\n\t\t\tnum[b][a] = d;\n\t\t}\n\t\tStringTokenizer tokenizer = new StringTokenizer(scanner.next(), \",\");\n\t\tint a = Integer.parseInt(tokenizer.nextToken());\n\t\tint b = Integer.parseInt(tokenizer.nextToken());\n\t\tint c = Integer.parseInt(tokenizer.nextToken());\n\t\tint d = Integer.parseInt(tokenizer.nextToken());\n\t\tmin = Integer.MAX_VALUE;\n\t\tint q = c-d;\n\t/*\tgetYen(a, 0, b, num, n, 0, a);\n\t\tq-=min;\n\t\tmin = Integer.MAX_VALUE;\n\t\tgetYen(b, 0, a, num, n, 0, b);\n\t\tq-=min;*/\n\t\tSystem.out.println(q);\n\t}\n\n\tpublic static void getYen(int a, int x, int b, int[][] num, int n, int yen,\n\t\t\tint g) {\n\t\tif (a == b) {\n\t\t\tmin = Math.min(min, yen);\n\t\t\treturn;\n\t\t}\n\t\tif (a == g && yen != 0 || yen > min) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (num[a][i] != 0 && i != x) {\n\t\t\t\tgetYen(i, a, b, num, n, yen + num[a][i], g);\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tint[][] cost;\n\tboolean[] visit;\n\tint[] dist;\n\tint n;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tcost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tArrays.fill(cost[i], 1000000);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0])-1;\n\t\t\t\tint b = Integer.parseInt(str[1])-1;\n\t\t\t\tcost[a][b] = Integer.parseInt(str[2]);\n\t\t\t\tcost[b][a] = Integer.parseInt(str[3]);\n\t\t\t}\n\t\t\tString[] str = scan.next().split(\",\");\n\t\t\tint[] x = {Integer.parseInt(str[0])-1,Integer.parseInt(str[1])-1};\n\t\t\tint reward = Integer.parseInt(str[2]) - Integer.parseInt(str[3]);\n\t\t\tfor(int i = 0;i < 2;i++){\n\t\t\t\tvisit = new boolean[n];\n\t\t\t\tdist = new int[n];\n\t\t\t\tArrays.fill(dist,1000000);\n\t\t\t\tArrays.fill(visit,false);\n\t\t\t\tdijkstra(x[i]);\n\t\t\t\treward -= dist[x[(i+1)%2]];\n\t\t\t}\n\t\t\tSystem.out.println(reward);\n\t\t}\n\t}\n\tpublic void dijkstra(int start){\n\t\tdist[start] = 0;\n\t\twhile(true){\n\t\t\tint min = 1000000;\n\t\t\tint next = -1;\n\t\t\tfor(int u = 0;u < n;u++){\n\t\t\t\tif(visit[u]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdist[u] = Math.min(dist[u],dist[start] + cost[start][u]);\n\t\t\t\tif(dist[u] < min){\n\t\t\t\t\tmin = dist[u];\n\t\t\t\t\tnext = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[start] = true;\n\t\t\tstart = next;\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* A reward a Carpenter */\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString line = in.readLine();\t\t\n\t\tint n = Integer.parseInt(line);\n\t\tnode[] nodes1 = new node[n];\n\t\tnode[] nodes2 = new node[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnodes1[i] = new node();\n\t\t\tnodes2[i] = new node();\n\t\t}\n\n\t\tline = in.readLine();\n\t\tint m = Integer.parseInt(line);\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] dst = line.trim().split(\",\");\n\t\t\tint from = Integer.parseInt(dst[0])-1;\n\t\t\tint to = Integer.parseInt(dst[1])-1;\n\t\t\tint fee1 = Integer.parseInt(dst[2]);\n\t\t\tint fee2 = Integer.parseInt(dst[3]);\n\t\t\t\n\t\t\tnodes1[from].add_edge(to, fee1);\n\t\t\tnodes1[to].add_edge(from, fee2);\n\t\t\tnodes2[from].add_edge(to, fee1);\n\t\t\tnodes2[to].add_edge(from, fee2);\n\t\t}\n\n\t\tline = in.readLine();\n\t\tString dst[] = line.split(\",\");\n\t\tint start = Integer.parseInt(dst[0])-1;\n\t\tint goal  = Integer.parseInt(dst[1])-1;\n\t\tint money = Integer.parseInt(dst[2]);\n\t\tint cost  = Integer.parseInt(dst[3]);\n\t\t\n\t\tint min_cost_to = get_min_cost(nodes1, start, goal);\n\t\tint min_cost_from = get_min_cost(nodes2, goal, start);\n\t\t\n\t\tint reward = money - cost - min_cost_to - min_cost_from;\n\t\tSystem.out.println(reward);\n\t}\n\t\n\tpublic int get_min_cost(node[] nodes, int s, int g){\n\t\tnodes[s].cost = 0;\n\t\twhile(true){\n\t\t\tnode done = null;\t\t\t\n\t\t\tfor(int i=0; i<nodes.length; i++){\n\t\t\t\tif(nodes[i].visited == true || nodes[i].cost < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(done == null || nodes[i].cost < done.cost){\n\t\t\t\t\tdone = nodes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(done == null){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdone.visited = true;\n\t\t\t\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\treturn nodes[g].cost;\n\t}\t\n}\n\nclass node{\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tint cost;\n\tboolean visited;\n\t\n\tpublic node(){\n\t\tcost = -1;\n\t\tthis.visited =false;\n\t\tedge_to = new ArrayList<Integer>();\n\t\tedge_cost = new ArrayList<Integer>();\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tedge_to.add(to);\n\t\tedge_cost.add(cost);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\t/*\n\t * 問題URL : https://onlinejudge.u-aizu.ac.jp/#/problems/0117\n\t */\n\n\tprivate static final int INFINITY = Integer.MAX_VALUE/2;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//入力\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tint K[][] = new int[N][N];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tK[i][j] = INFINITY;\n\t\t\t}\n\t\t}\n\t\tint m = Integer.parseInt(br.readLine());\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tString str[] = br.readLine().trim().split(\",\");\n\t\t\tint a = Integer.parseInt(str[0])-1;\n\t\t\tint b = Integer.parseInt(str[1])-1;\n\t\t\tK[a][b] = Integer.parseInt(str[2]);\n\t\t\tK[b][a] = Integer.parseInt(str[3]);\n\t\t}\n\t\tString str[] = br.readLine().split(\",\");\n\t\tint start = Integer.parseInt(str[0])-1;\n\t\tint goal = Integer.parseInt(str[1])-1;\n\t\tint V = Integer.parseInt(str[2]);\n\t\tint P = Integer.parseInt(str[3]);\n\n\t\t//Floyd-Warshall法\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tif(K[i][j] > K[i][k] +K[k][j]) {//Integer.MAX_VALUEを使っているとここでオーバーフローを起こしておかしくなる\n\t\t\t\t\t\tK[i][j] = K[i][k] +K[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//出力\n\t\tSystem.out.println(V -P -K[start][goal] -K[goal][start]);\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, m, x1, x2, y1, y2;\n    static int[][] edge;\n    public static void main(String[] args) {\n        while(read()){\n            solve();\n        }\n    }\n\n    static boolean read(){\n        if(!sc.hasNext())return false;\n        n = sc.nextInt();\n        m = sc.nextInt();\n        edge = new int[m+1][m+1];\n        for(int a[] : edge)Arrays.fill(a, 1 << 29);\n        String[] input = new String[4];\n        for(int i = 0; i < m; i++){\n            input = sc.next().split(\",\");\n            edge[Integer.parseInt(input[0])][Integer.parseInt(input[1])] = Integer.parseInt(input[2]);\n            edge[Integer.parseInt(input[1])][Integer.parseInt(input[0])] = Integer.parseInt(input[3]);\n        }\n        input = sc.next().split(\",\");\n        x1 = Integer.parseInt(input[0]);\n        x2 = Integer.parseInt(input[1]);\n        y1 = Integer.parseInt(input[2]);\n        y2 = Integer.parseInt(input[3]);\n        return true;\n    }\n\n    static void solve(){\n        for(int k = 0; k < m; k++){\n            for(int i = 0; i < m; i++){\n                for(int j = 0; j < m; j++){\n                    edge[i][j] = Math.min(edge[i][j], edge[i][k] + edge[k][j]);\n                }\n            }\n        }\n        System.out.println(y1-y2-edge[x1][x2]-edge[x2][x1]);\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint m=in.nextInt();\n\t\t\tint M=1000000;\n\t\t\tint road[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(road[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troad[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString s[]=in.next().split(\",\");\n\t\t\t\troad[Integer.valueOf(s[0])][Integer.valueOf(s[1])]=Integer.valueOf(s[2]);\n\t\t\t\troad[Integer.valueOf(s[1])][Integer.valueOf(s[0])]=Integer.valueOf(s[3]);\n\t\t\t}\n\t\t\tString va[]=in.next().split(\",\");\n\t\t\tint s=Integer.valueOf(va[0]);\n\t\t\tint t=Integer.valueOf(va[1]);\n\t\t\tint give=Integer.valueOf(va[2]);\n\t\t\tint cost=Integer.valueOf(va[3]);\n\t\t\tint ans=give-cost;\n\t\t\tint start=0;\n\t\t\tint goal=0;\n\t\t\tfor(int I=0;I<2;I++)\n\t\t\t{\n\t\t\t\tint p=0;\n\t\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\t\tint v[] = new int[n+1];// decision flag\n\t\t\t\tif(I==0)\n\t\t\t\t{\n\t\t\t\t\tstart =s;\n\t\t\t\t\tgoal=t;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstart=t;\n\t\t\t\t\tgoal=s;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tleng[k]=M;\n\t\t\t\t\tv[k]=0;\n\t\t\t\t}\n\t\t\t\tleng[start]=0;\n\t\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\t{\n\t\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp=k;\n\t\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\t\tfor(int k=0;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\t{\n\t\t\t\t\t\tif((leng[p]+road[p][k])<leng[k])\n\t\t\t\t\t\t\tleng[k]=leng[p]+road[p][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans-=leng[goal];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint number;\n\t\tint degree;\n\t\tVertex neighbor[];\n\t\tEdge edge[];\n\t\tint cost;\n\t\tboolean mark;\n\n\t\tVertex (int number, int n, int m) {\n\t\t\tthis.number = number;\n\t\t\tthis.degree = 0;\n\t\t\tneighbor = new Vertex[n];\n\t\t\tedge = new Edge[m];\n\t\t\tthis.cost = Integer.MAX_VALUE;\n\t\t\tthis.mark = false;\n\t\t}\n\n\t\tpublic void remake(Vertex v, Edge e) {\n\t\t\tneighbor[degree] = v;\n\t\t\tedge[degree] = e;\n\t\t\tthis.degree++;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString s = \"\";\n\t\t\tfor (int i = 0; i < degree; i++) {\n\t\t\t\ts += (neighbor[i].number + 1) + \" \";\n\t\t\t\tif (edge[i].v1 == this) {\n\t\t\t\t\ts += edge[i].costFromV1 + \" \";\n\t\t\t\t} else {\n\t\t\t\t\ts += edge[i].costFromV2 + \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint number;\n\t\tVertex v1, v2;\n\t\tint costFromV1;\n\t\tint costFromV2;\n\n\t\tEdge (int number, Vertex v1, Vertex v2, int costFromV1, int costFromV2) {\n\t\t\tthis.number = number;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.costFromV1 = costFromV1;\n\t\t\tthis.costFromV2 = costFromV2;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tVertex vertex[];\n\t\tEdge edge[];\n\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tvertex = new Vertex[n];\n\t\tedge = new Edge[m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvertex[i] = new Vertex(i, n, m);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s[] = sc.next().split(\",\");\n\t\t\tint a = Integer.valueOf(s[0]) - 1;\n\t\t\tint b = Integer.valueOf(s[1]) - 1;\n\t\t\tint c = Integer.valueOf(s[2]);\n\t\t\tint d = Integer.valueOf(s[3]);\n\t\t\tedge[i] = new Edge(i, vertex[a], vertex[b], c, d);\n\t\t\tvertex[a].remake(vertex[b], edge[i]);\n\t\t\tvertex[b].remake(vertex[a], edge[i]);\n\t\t}\n\t\tString s[] = sc.next().split(\",\");\n\t\tint a = Integer.valueOf(s[0]) - 1;\n\t\tint b = Integer.valueOf(s[1]) - 1;\n\t\tint c = Integer.valueOf(s[2]);\n\t\tint d = Integer.valueOf(s[3]);\n\t\tint total = c;\n\t\ttotal -= minimumWay(vertex, edge, a, b);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvertex[i].cost = Integer.MAX_VALUE;\n\t\t\tvertex[i].mark = false;\n\t\t}\n\t\ttotal -= d;\n\t\ttotal -= minimumWay(vertex, edge, b, a);\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static int minimumWay(Vertex v[], Edge e[], int start, int goal) {\n\t\tint n = v.length;\n\t\tint index = start;\n\t\tint minIndex;\n\n\t\tv[start].cost = 0;\n\t\twhile (!v[goal].mark) {\n\t\t\tv[index].mark = true;\n\t\t\tfor (int i = 0; i < v[index].degree; i++) {\n\t\t\t\tVertex v1 = v[index].neighbor[i];\n\t\t\t\tEdge e1 = v[index].edge[i];\n\t\t\t\tif (!v1.mark) {\n\t\t\t\t\tif (e1.v1 == v[index]) {\n\t\t\t\t\t\tif (v[index].cost + e1.costFromV1 < v1.cost) {\n\t\t\t\t\t\t\tv1.cost = v[index].cost + e1.costFromV1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (v[index].cost + e1.costFromV2 < v1.cost) {\n\t\t\t\t\t\t\tv1.cost = v[index].cost + e1.costFromV2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tminIndex = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!v[i].mark && (minIndex == -1 || v[i].cost < v[minIndex].cost)) {\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex = minIndex;\n\t\t}\n\t\treturn v[goal].cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main {\n\n    public static int INF=1<<28;\n\n\n    void warshall_floyd(int[][] d){\n\t\tfinal int V=d.length;\n\t    for(int k=0;k<V;k++)\n\t    \tfor(int i=0;i<V;i++)for(int j=0;j<V;j++)\n\t    \t\tif(d[i][j]>d[i][k] + d[k][j]){\n\t    \t\t\td[i][j]=d[i][k] + d[k][j];\n\t    \t\t}\n\t}\n\n\n    public void run() {\n    \tint N=sc.nextInt(),M=sc.nextInt();\n\n    \tint[][] ds=new int[N][N];\n    \tfor(int i=0;i<N;i++)Arrays.fill(ds[i],INF);\n    \tfor(int i=0;i<N;i++)ds[i][i]=0;\n\n    \tPattern p=Pattern.compile(\"(\\\\d*),(\\\\d*),(\\\\d*),(\\\\d*)\");\n\n    \tfor(int i=0;i<M;i++){\n    \t\tMatcher m=p.matcher(sc.next().trim());m.find();\n    \t\tint f=Integer.parseInt(m.group(1))-1,\n    \t    \tt=Integer.parseInt(m.group(2))-1,\n    \t    \ta=Integer.parseInt(m.group(3)),\n        \t\tb=Integer.parseInt(m.group(4));\n    \t\tds[f][t]=a;ds[t][f]=b;\n    \t}\n\n\t\tMatcher m=p.matcher(sc.next().trim());m.find();\n\t\tint f=Integer.parseInt(m.group(1))-1,\n    \t    \tt=Integer.parseInt(m.group(2))-1,\n    \t    \ty1=Integer.parseInt(m.group(3)),\n        \t\ty2=Integer.parseInt(m.group(4));\n\n    \twarshall_floyd(ds);\n\t\tln(y1-y2-ds[f][t]-ds[t][f]);\n    }\n\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\n\t//output lib\n\tstatic final String br = System.getProperty(\"line.separator\");\n\tstatic final String[] asep = new String[] { \"\", \" \", br, br + br };\n\n\tstatic String str(Boolean o) {\n\t\treturn o ? \"YES\" : \"NO\";\n\t}\n\n\t//\tstatic String str(Double o){\n\t//\t\treturn String.format(\"%.8f\",o);\n\t//\t}\n\tstatic <K, V> String str(Map<K, V> map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (Entry<K, V> set : map.entrySet()) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic <E> String str(Collection<E> list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (E e : list) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o) {\n\t\tint depth = _getArrayDepth(o);\n\t\tif (depth > 0)\n\t\t\treturn _strArray(o, depth);\n\t\tClass<?> c = o.getClass();\n\t\tif (c.equals(Boolean.class))\n\t\t\treturn str((Boolean) o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\n\tstatic int _getArrayDepth(Object o) {\n\t\tif (!o.getClass().isArray() || Array.getLength(o) == 0)\n\t\t\treturn 0;\n\t\treturn 1 + _getArrayDepth(Array.get(o, 0));\n\t}\n\n\tstatic String _strArray(Object o, int depth) {\n\t\tif (depth == 0)\n\t\t\treturn str(o);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0, len = Array.getLength(o); i < len; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tsb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o, i), depth - 1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic void pr(Object... os) {\n\t\tboolean isFirst = true;\n\t\tfor (Object o : os) {\n\t\t\tif (!isFirst)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst = false;\n\t\t}\n\t}\n\n\tstatic void ln() {\n\t\tout.println();\n\t}\n\n\tstatic void ln(Object... os) {\n\t\tfor (Object o : os) {\n\t\t\tpr(o);\n\t\t\tln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\"\\\\D+\");\n\t\t\n\t\tfinal int towns = sc.nextInt();\n\t\tfinal int paths = sc.nextInt();\n\t\t\n\t\tint[][] relates = new int[towns][towns];\n\t\tfor(int[] tmp:relates){\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\ttmp[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < paths; i++){\n\t\t\tfinal int from = sc.nextInt();\n\t\t\tfinal int to = sc.nextInt();\n\t\t\tfinal int go = sc.nextInt();\n\t\t\tfinal int back = sc.nextInt();\n\t\t\trelates[from-1][to-1] = go;\n\t\t\trelates[to-1][from-1] = back;\n\t\t}\n\t\t\n\t\tfinal int start = sc.nextInt();\n\t\tfinal int end = sc.nextInt();\n\t\tfinal int price = sc.nextInt();\n\t\tfinal int cost = sc.nextInt();\n\t\t\n\t\tint first_cost = search(start,end,relates,towns);\n\t\tint second_cost = search(end,start,relates,towns);\n\t\t\n\t\tSystem.out.println(price - cost - first_cost - second_cost);\n\t}\n\t\n\tprivate static int search(final int start,final int end,int[][] relates,final int towns){\n\t\t\n\t\tint[] costs = new int[towns];\n\t\tfor(int i=0; i<towns; i++){\n\t\t\tcosts[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tcosts[start-1] = 0;\n\t\t\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.add(start);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\t\n\t\t\tfor(int i = 0; i < towns; i++){\n\t\t\t\tif(relates[cur-1][i] != 0){\n\t\t\t\t\tif(costs[i] > (costs[cur-1]+relates[cur-1][i])){\n\t\t\t\t\t\tqueue.add(i+1);\n\t\t\t\t\t\tcosts[i] = costs[cur-1]+relates[cur-1][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn costs[end-1];\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\tint[][] map = new int[n+1][n+1];\n\n\t\tfor(int[] tmp : map) Arrays.fill(tmp,-1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tString[] s = sc.next().split(\",\");\n\t\t\tint a=Integer.parseInt(s[0]), b=Integer.parseInt(s[1]);\n\t\t\tmap[a][b] = Integer.parseInt(s[2]);\n\t\t\tmap[b][a] = Integer.parseInt(s[3]);\n\t\t}\n\n\t\tString[] s = sc.next().split(\",\");\n\t\tint x1=Integer.parseInt(s[0]), x2=Integer.parseInt(s[1]);\n\t\tint ans = Integer.parseInt(s[2]) - Integer.parseInt(s[3]);\n\n\t\tans -= minCost(x1,x2,map);\n\t\tans -= minCost(x2,x1,map);\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int minCost(int s,int g,int[][] map){\n\t\tQueue<State> open = new PriorityQueue<State>();\n\t\tSet<State> closed = new HashSet<State>();\n\n\t\tState st = new State(0,s);\n\t\topen.add(st);\n\n\t\tState ans = null;\n\t\twhile(!open.isEmpty()){\n\t\t\tst = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tclosed.add(st);\n\t\t\tif(st.n == g){\n\t\t\t\tans = st;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topen.addAll(st.nexts(map));\n\t\t}\n\n\t\treturn ans.cost;\n\t}\n\n\tstatic class State implements Comparable<State>{\n\t\tint cost, n;\n\n\t\tState(int cost,int n){\n\t\t\tthis.cost = cost;\n\t\t\tthis.n = n;\n\t\t}\n\n\t\tList<State> nexts(int[][] map){\n\t\t\tList<State> sts = new ArrayList<State>();\n\t\t\tfor(int i=1;i<map.length;i++){\n\t\t\t\tif(n == i) continue;\n\t\t\t\tif(map[n][i] >= 0) sts.add(new State(cost+map[n][i],i));\n\t\t\t}\n\t\t\treturn sts;\n\t\t}\n\n\t\tpublic int compareTo(State st){\n\t\t\treturn cost - st.cost;\n\t\t}\n\n\t\tpublic boolean equals(Object o){\n\t\t\tState st = (State)o;\n\t\t\treturn this.n == st.n;\n\t\t}\n\n\t\tpublic int hashCode(){\n\t\t\treturn this.n;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[][] cost;\n\tstatic short[] d;\n\tstatic final short INF = Short.MAX_VALUE/4;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tbyte n = scan.nextByte();\n\t\tcost = new short[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td = new short[n];\n\t\tshort m = scan.nextShort();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString[] line = scan.next().split(\",\");\n\t\t\tcost[Integer.parseInt(line[0])-1][Integer.parseInt(line[1])-1] = Short.parseShort(line[2]);\n\t\t\tcost[Integer.parseInt(line[1])-1][Integer.parseInt(line[0])-1] = Short.parseShort(line[3]);\n\t\t}\n\t\tString[] line = scan.next().split(\",\");\n\t\tbyte[] s = new byte[]{(byte)(Integer.parseInt(line[0])-1),(byte)(Integer.parseInt(line[1])-1)};\n\t\tint money = Integer.parseInt(line[2])-Integer.parseInt(line[3]);\n\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tfor (int i = 0; i < n; i++) d[i] = INF;\n\t\t\td[s[j]] = 0;\n\t\t\twhile (true) {\n\t\t\t\tbyte v = -1;\n\t\t\t\tfor (byte i = 0; i < n; i++) {\n\t\t\t\t\tif (!used[i] && (v == -1 || d[i] < d[v]))\n\t\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\tif (v == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tused[v] = true;\n\t\t\t\tfor (byte i = 0; i < n; i++) {\n\t\t\t\t\td[i] = (short) Math.min(d[i], d[v] + cost[v][i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmoney-=d[s[1-j]];\n\t\t}\n\n\t\tSystem.out.println(money);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint INF = 1 << 24;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tpass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tString [] input = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(input[0]) - 1;\n\t\t\t\tint b = Integer.parseInt(input[1]) - 1;\n\t\t\t\tint cost1 = Integer.parseInt(input[2]);\n\t\t\t\tint cost2 = Integer.parseInt(input[3]);\n\t\t\t\tpass[a][b] = cost1;\n\t\t\t\tpass[b][a] = cost2;\n\t\t\t}\n\t\t\tString [] lastinput = sc.next().split(\",\");\n\t\t\tint from = Integer.parseInt(lastinput[0]) - 1;\n\t\t\tint to = Integer.parseInt(lastinput[1]) - 1;\n\t\t\tint money = Integer.parseInt(lastinput[2]);\n\t\t\tint h = Integer.parseInt(lastinput[3]);\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tpass[i][k] = Math.min(pass[i][k], pass[i][j] + pass[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = money - (pass[from][to] + pass[to][from] + h);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t//int[][] d = new int[n][n]; \n\t\tint m = sc.nextInt();\n\t\tint[][] road = new int[m][4];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString s = sc.next();\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\troad[i][j] = Integer.parseInt(ss[j]);\n\t\t\t}\n\t\t}\n\t\tint[] input = new int[4];\n\t\tString s = sc.next();\n\t\tString[] ss = s.split(\",\");\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tinput[j] = Integer.parseInt(ss[j]);\n\t\t}\n\t\tint start = input[0];\n\t\tint goal = input[1];\n\t\t//startからgoalの最短距離を求める\n\t\t//startからの距離\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//道を見ていく\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\tint sum = d[goal - 1];\n\t\t\n\t\t//今度はゴールからスタートまでの最短距離\n\t\tstart = input[1];\n\t\tgoal = input[0];\n\t\tArrays.fill(d, INF);\n\t\td[start - 1] = 0;\n\t\twhile(true){\n\t\t\tboolean bChange = false;\n\t\t\t//道を見ていく\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = road[i][0];\n\t\t\t\tint to = road[i][1];\n\t\t\t\tint cost = road[i][2];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfrom = road[i][1];\n\t\t\t\tto = road[i][0];\n\t\t\t\tcost = road[i][3];\n\t\t\t\tif(d[from - 1] != INF && d[from - 1] + cost < d[to - 1]){\n\t\t\t\t\td[to - 1] = d[from - 1] + cost;\n\t\t\t\t\tbChange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//print(d);\n\t\t\tif(bChange == false) break;\n\t\t}\n\t\t//System.out.println(d[goal - 1]);\n\t\tsum += d[goal - 1];\n\t\t\n\t\tSystem.out.println(input[2] - input[3] - sum);\n\t\t\n\t}\n\t\n\tpublic static void print(int[] d){\n\t\tfor(int a : d){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tint INF = 1 << 28;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint fee[][] = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.fill(fee[i], INF);\n\t\t\tfee[i][i] = 0;\n\t\t}\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tint c = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tfee[a][b] = c;\n\t\t\tfee[b][a] = d;\n\t\t}\n\t\t// }\n\t\t// 最終行は、x1, x2, y1, y2（整数;半角カンマ区切り）\n\t\t// x1：大工の出発する町の番号\n\t\t// x2：柱のある山里の番号\n\t\t// y1：殿様から大工が受け取ったお金\n\t\t// y2：柱の代金\n\t\tint x1 = sc.nextInt() - 1;\n\t\tint x2 = sc.nextInt() - 1;\n\t\tint y1 = sc.nextInt();\n\t\tint y2 = sc.nextInt();\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfee[i][j] = Math.min(fee[i][j], fee[i][k] + fee[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = y1 - (y2 + fee[x1][x2] + fee[x2][x1]);\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tenum Color {\n\t\tWhite, Gray, Black\n\t}\n\n\tstatic void setEdge(List<ArrayList<int[]>> edge, String input) {\n\t\tString[] str = input.split(\",\");\n\t\tint from = Integer.parseInt(str[0]);\n\t\tint to = Integer.parseInt(str[1]);\n\t\tint cost1 = Integer.parseInt(str[2]);\n\t\tint cost2 = Integer.parseInt(str[3]);\n\t\tedge.get(from - 1).add(new int[] { to - 1, cost1 });\n\t\tedge.get(to - 1).add(new int[] { from - 1, cost2 });\n\t}\n\n\tstatic int[] bfs(List<ArrayList<int[]>> edge, int s) {\n\t\tint[] dist = new int[edge.size()];\n\t\tColor[] color = new Color[edge.size()];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tdist[i] = Integer.MAX_VALUE;\n\t\t\tcolor[i] = Color.White;\n\t\t}\n\t\tcolor[s] = Color.Gray;\n\t\tdist[s] = 0;\n\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\tq.add(s);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tint from = q.poll();\n\t\t\t\tfor(int[] e : edge.get(from)){\n\t\t\t\t\tint to = e[0];\n\t\t\t\t\tint cost = e[1];\n\t\t\t\t\tint total = dist[from] + cost;\n\t\t\t\t\tdist[to] = (total < dist[to])? total : dist[to];\n\t\t\t\t\tif(color[to] == Color.White){\n\t\t\t\t\t\tcolor[to] = Color.Gray;\n\t\t\t\t\t\tq.add(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolor[from] = Color.Black;\n\t\t}\n\t\treturn dist;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint city = s.nextInt();\n\t\tint numEdge = s.nextInt();\n\t\tList<ArrayList<int[]>> edge = new ArrayList<ArrayList<int[]>>();\n\t\tfor(int i = 0; i < city; i++){\n\t\t\tedge.add(new ArrayList<int[]>());\n\t\t}\n\t\tfor (int i = 0; i < numEdge; i++) {\n\t\t\tsetEdge(edge, s.next());\n\t\t}\n\t\tString[] input = s.next().split(\",\");\n\t\tint start = Integer.parseInt(input[0]);\n\t\tint dest = Integer.parseInt(input[1]);\n\t\tint money = Integer.parseInt(input[2]);\n\t\tint price = Integer.parseInt(input[3]);\n\t\tSystem.out.println(money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1]);\n\t\ts.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\t\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\t\t\n\t\tnew AOJ0117();\n\t}\n\t\n\tclass AOJ0117{\n\t\tint cost[][]; //コスト\n\t\tint d[];//頂点sからの最短距離\n\t\tboolean used[];//素手に使用されたかのフラグ\n\t\tint V;//頂点数\n\t\tint INF;\n\t\t\n\t\tvoid dijkstra(int s){\n\t\t\t//list = new int[V];前の頂点を保存したいとき\n\t\t\td = new int[V+1];\n\t\t\tused = new boolean[V+1];\n\t\t\tArrays.fill(d,INF);\n\t\t\tArrays.fill(used, false);\n\t\t\td[s] = 0;\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0;u<=V;u++){//まだ使われていない頂点のうち最小のものを探す\n\t\t\t\t\tif(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n\t\t\t\t}\n\t\t\t\tif(v==-1)break;\n\t\t\t\tused[v]=true;\n\t\t\t\tfor(int u=0;u<=V;u++){\n\t\t\t\t\td[u] = Math.min(d[u],d[v]+cost[v][u]);\n//\t\t\t\t\tif(d[u]>d[v]+cost[v][u]){   前の頂点を保存したい時は更新された時に\n//\t\t\t\t\t\td[u]=d[v]+cost[v][u];\n//\t\t\t\t\t\tlist[u] = v;\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic AOJ0117() {\n\t\t\tINF = Integer.MAX_VALUE/2;\n\t\t\tV = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tcost = new int[V+1][V+1];//[from][to]\n\t\t\tfor(int i=0;i<=V;i++)Arrays.fill(cost[i],Integer.MAX_VALUE/2);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString input[] = in.next().split(\",\");\n\t\t\t\tcost[Integer.parseInt(input[0])][Integer.parseInt(input[1])] = Integer.parseInt(input[2]);\n\t\t\t\tcost[Integer.parseInt(input[1])][Integer.parseInt(input[0])] = Integer.parseInt(input[3]);\n\t\t\t}\n\t\t\tString input[] = in.next().split(\",\");\n\t\t\tint start = Integer.parseInt(input[0]),goal = Integer.parseInt(input[1]);\n\t\t\tint money = Integer.parseInt(input[2]),hasira = Integer.parseInt(input[3]);\n\t\t\tdijkstra(start);\n\t\t\tint result = d[goal];\n\t\t\tdijkstra(goal);\n\t\t\tresult += d[start];\n\t\t\tSystem.out.println(money-(result+hasira));\n\t\t}\n\t}\n\t\n\n\tclass AOJ2503{\n\t\tint MAX = 0;\n\t\tpublic AOJ2503() {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\n\t\t\tint[][] cost = new int[n][n];\n\n\t\t\tint[] dp = new int[n];\n\t\t\tfor(int i=0;i<n*n;i++){\n\t\t\t\tcost[i/n][i%n]=MAX;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = in.nextInt();\n\t\t\t\tint b = in.nextInt();\n\t\t\t\tcost[a][b]=in.nextInt();\n\t\t\t}\t\n\t\t\t//\t\t\tTODO 一番大きいパスを0のポイントからn-1のポイントまでの\n\n\t\t\tfor(int s=1;s<n;s++){\n\t\t\t\tfor(int i=0;i<=s;i++){\n\t\t\t\t\tif(cost[i][s]==MAX)continue;\n\t\t\t\t\tdp[s]=Math.max(dp[s],dp[i]+cost[i][s]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int s=0;s<n;s++)for(int i=0;i<n;i++){\n\t\t\t\tif(cost[s][i]==MAX)continue;\n\t\t\t\tdp[i]=Math.max(dp[s]+cost[s][i],dp[i]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)System.out.print(dp[i]+\" \");\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(dp[n-1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n,m;\n\tint[][] map;\n\tint cost;\n\tint expense;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm= sc.nextInt();\n\t\tmap = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfill(map[i], INF);\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tString[] str = sc.next().split(\",\");\n\t\t\tint a = Integer.parseInt(str[0])-1;\n\t\t\tint b = Integer.parseInt(str[1])-1;\n\t\t\tint c = Integer.parseInt(str[2]);\n\t\t\tint d = Integer.parseInt(str[3]);\n\t\t\tmap[a][b] = c;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\twf();\n\t\tString[] str = sc.next().split(\",\");\n\t\tint f = Integer.parseInt(str[0])-1;\n\t\tint t = Integer.parseInt(str[1])-1;\n\t\tcost = Integer.parseInt(str[2]);\n\t\texpense = Integer.parseInt(str[3]);\n\t\t\n\t\tSystem.out.println(cost - expense - map[f][t] - map[t][f]);\n\t}\n\t\n\tvoid wf() {\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++){\n\t\t\tmap[i][k] = min(map[i][k], map[i][j] + map[j][k]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt(), b = s.nextInt();\n        int[][] g = new int[a][a];\n        for (int i = 0; i < a; i++) {\n            Arrays.fill(g[i], 99999999);\n        }\n        for (int i = 0; i < b; i++) {\n            String[] l = s.next().split(\",\");\n            int c = Integer.parseInt(l[0]) - 1, d = Integer.parseInt(l[1]) - 1, e = Integer.parseInt(l[2]), f = Integer.parseInt(l[3]);\n            g[c][d] = e;\n            g[d][c] = f;\n        }\n        String[] l = s.next().split(\",\");\n        int c = Integer.parseInt(l[0]) - 1, d = Integer.parseInt(l[1]) - 1, e = Integer.parseInt(l[2]), f = Integer.parseInt(l[3]);\n        for (int i = 0; i < a; i++)\n            for (int j = 0; j < a; j++)\n                for (int k = 0; k < a; k++)\n                    if (g[j][k] > g[j][i] + g[i][k])\n                        g[j][k] = g[j][i] + g[i][k];\n        System.out.println(e - f - g[c][d] - g[d][c]);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n,m,s,g,money,pillar;\n\tstatic int[][][] edge;\n\tstatic int[][] min;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tn=cin.nextInt();\n\t\tm=cin.nextInt();\n\t\tedge=new int[n+1][n+1][2];\n\t\tmin=new int[n+1][2];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tmin[i][0]=min[i][1]=1<<30;\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tedge[i][j][0]=edge[i][j][1]=1<<30;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tString[] s = cin.next().split(\",\");\n\t\t\t\n\t\t\tint a=Integer.parseInt(s[0]);\n\t\t\tint b=Integer.parseInt(s[1]);\n\t\t\tint c=Integer.parseInt(s[2]);\n\t\t\tint d=Integer.parseInt(s[3]);\n\t\t\tedge[a][b][0]=c;\n\t\t\tedge[b][a][0]=c;\n\t\t\tedge[b][a][1]=d;\n\t\t\tedge[a][b][1]=d;\n\t\t}\n\t\tString[] ss = cin.next().split(\",\");\n\t\ts=Integer.parseInt(ss[0]);\n\t\tg=Integer.parseInt(ss[1]);\n\t\tmoney=Integer.parseInt(ss[2])-Integer.parseInt(ss[3]);\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(100,new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a,int [] b){\n\t\t\t\treturn a[1]-b[1];\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{s,0});\n\t\tmin[s][0]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[now][i][0]!=1<<30){\n\t\t\t\t\tif(min[i][0]>cost+edge[now][i][0]){\n\t\t\t\t\t\tmin[i][0]=cost+edge[now][i][0];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][0]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tq.add(new int[]{g,0});\n\t\tmin[g][1]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n//\t\t\tSystem.out.println(now+\" \"+cost);\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[i][now][1]!=1<<30){\n\t\t\t\t\tif(min[i][1]>cost+edge[i][now][1]){\n\t\t\t\t\t\tmin[i][1]=cost+edge[i][now][1];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][1]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(min[g][0]);\n//\t\tSystem.out.println(min[s][1]);\n\t\tSystem.out.println(money-min[g][0]-min[s][1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int n,m,s,g,money,pillar;\n\tstatic int[][][] edge;\n\tstatic int[][] min;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tn=cin.nextInt();\n\t\tm=cin.nextInt();\n\t\tedge=new int[n+1][n+1][2];\n\t\tmin=new int[n+1][2];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tmin[i][0]=min[i][1]=1<<30;\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tString[] s = cin.next().split(\",\");\n\t\t\t\n\t\t\tint a=Integer.parseInt(s[0]);\n\t\t\tint b=Integer.parseInt(s[1]);\n\t\t\tint c=Integer.parseInt(s[2]);\n\t\t\tint d=Integer.parseInt(s[3]);\n\t\t\tedge[a][b][0]=c;\n\t\t\tedge[b][a][0]=c;\n\t\t\tedge[b][a][1]=d;\n\t\t\tedge[a][b][1]=d;\n\t\t}\n\t\tString[] ss = cin.next().split(\",\");\n\t\ts=Integer.parseInt(ss[0]);\n\t\tg=Integer.parseInt(ss[1]);\n\t\tmoney=Integer.parseInt(ss[2])-Integer.parseInt(ss[3]);\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(100,new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a,int [] b){\n\t\t\t\treturn a[1]-b[1];\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{s,0});\n\t\tmin[s][0]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[now][i][0]!=0){\n\t\t\t\t\tif(min[i][0]>cost+edge[now][i][0]){\n\t\t\t\t\t\tmin[i][0]=cost+edge[now][i][0];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][0]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tq.add(new int[]{g,0});\n\t\tmin[g][1]=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] p = q.poll();\n\t\t\tint now=p[0];\n\t\t\tint cost=p[1];\n//\t\t\tSystem.out.println(now+\" \"+cost);\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(edge[i][now][1]!=0){\n\t\t\t\t\tif(min[i][1]>cost+edge[i][now][1]){\n\t\t\t\t\t\tmin[i][1]=cost+edge[i][now][1];\n\t\t\t\t\t\tq.add(new int[]{i,min[i][1]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(min[g][0]);\n//\t\tSystem.out.println(min[s][1]);\n\t\tSystem.out.println(money-min[g][0]-min[s][1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        \n        int[][] cost = new int[n+1][n+1];\n        \n        for(int i=0;i<=n;i++){\n            Arrays.fill(cost[i], 10000);\n        }\n        \n        for(int i=0;i<m;i++){\n            String[] str = sc.next().split(\",\");\n            cost[Integer.parseInt(str[0])][Integer.parseInt(str[1])]\n                    =Integer.parseInt(str[2]);\n            cost[Integer.parseInt(str[1])][Integer.parseInt(str[0])]\n                    =Integer.parseInt(str[3]);\n        }\n        \n        String[] str = sc.next().split(\",\");\n        int s = Integer.parseInt(str[0]);\n        int g = Integer.parseInt(str[1]);\n        int salary = Integer.parseInt(str[2]);  //殿様ァ！\n        int daikin = Integer.parseInt(str[3]);  //柱の代金\n        \n        \n        for(int k=1;k<=n;k++){            \n            for(int i=0;i<=n;i++){\n                for(int j=0;j<=n;j++){\n                    if(cost[i][j] >cost[i][k]+cost[k][j]){\n                        cost[i][j] = cost[i][k]+cost[k][j];\n                    }\n                }\n            }\n        }\n        \n        System.out.println(salary-daikin-cost[s][g]-cost[g][s]);\n        \n    }\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import static java.lang.Integer.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b,h=MAX_VALUE;int[][] p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=valueOf(z[0])-1;b=valueOf(z[1])-1;p[a][b]=valueOf(z[2]);p[b][a]=valueOf(z[3]);}z=s.next().split(\",\");v=new int[n];System.out.println(valueOf(z[2])-valueOf(z[3])-f(a=valueOf(z[0])-1,b=valueOf(z[1])-1,p,n,h)-f(b,a,p,n,h));}static int f(int a,int b,int[][]g,int n,int m){if(a==b)return 0;int c=MAX_VALUE,i=0;for(;i<n;++i)if(v[i]<1&&g[a][i]>0){v[i]=1;c=Math.min(c,f(i,b,g,n,c)+g[a][b]);v[i]=0;if(c>m)return MAX_VALUE;}return c;}static int[]v;}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import static java.lang.Integer.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt(),m=s.nextInt(),a,b;int[][] p=new int[n][n];for(;m-->0;){z=s.next().split(\",\");a=valueOf(z[0])-1;b=valueOf(z[1])-1;p[a][b]=valueOf(z[2]);p[b][a]=valueOf(z[3]);}z=s.next().split(\",\");System.out.println(valueOf(z[2])-valueOf(z[3])-f(a=valueOf(z[0])-1,b=valueOf(z[1])-1,p,n)-f(b,a,p,n));}static int f(int a,int b,int[][]g,int n){if(a==b)return 0;int c=MAX_VALUE,i=0;for(;i<n;++i)if(v[i]<1&&g[a][i]>0){v[i]=1;c=Math.min(c,f(i,b,g,n)+g[a][b]);v[i]=0;}return c;}static int[]v;}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Node\n    {\n        internal List<Edge> routes;\n\n        public Node()\n        {\n            routes = new List<Edge>();\n        }\n    }\n\n    class Edge : IComparable\n    {\n        internal int target;\n        internal int cost;\n\n        public Edge(int target, int cost)\n        {\n            this.target = target;\n            this.cost = cost;\n        }\n\n        public int CompareTo(object obj)\n        {\n            Edge temp = obj as Edge;\n            return temp.cost - cost;    // Reverse\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int m = int.Parse(Console.ReadLine());\n\n            Node[] nodeList = new Node[n + 1];\n            for (int i = 0; i <= n; i++) nodeList[i] = new Node();\n\n            string[] input;\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split(',');\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                nodeList[a].routes.Add(new Edge(b, c));\n                nodeList[b].routes.Add(new Edge(a, d));\n            }\n\n            input = Console.ReadLine().Split(',');\n            int s = int.Parse(input[0]);\n            int g = int.Parse(input[1]);\n            int V = int.Parse(input[2]);\n            int P = int.Parse(input[3]);\n\n            int forward = Dijkstra(nodeList, s, g);\n            int backward = Dijkstra(nodeList, g, s);\n\n            Console.WriteLine(V - P - forward - backward);\n        }\n\n        static int Dijkstra(Node[] nodeList, int start, int target)\n        {\n            PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\n            int n = nodeList.Length;\n\n            int[] costs = Enumerable.Repeat(int.MaxValue, n).ToArray();\n            bool[] visited = new bool[n];\n\n            costs[start] = 0;\n            pq.Enqueue(new Edge(start, 0));\n\n            while (pq.Count() > 0)\n            {\n                Edge f = pq.Dequeue();\n                int u = f.target;\n                visited[u] = true;\n\n                if (costs[u] < f.cost) continue;\n\n                for (int j = 0; j < nodeList[u].routes.Count; j++)\n                {\n                    int v = nodeList[u].routes[j].target;\n\n                    if (visited[v] == true) continue;\n\n                    if (costs[v] > costs[u] + nodeList[u].routes[j].cost)\n                    {\n                        costs[v] = costs[u] + nodeList[u].routes[j].cost;\n                        pq.Enqueue(new Edge(v, costs[v]));\n                    }\n                }\n            }\n            return costs[target];\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count()\n        {\n            return size;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\n\nnamespace ConsoleApplication1 {\n\n    \n\n    class ClassMain {\n\n        //[n+1 , n+1]\n        static int[,] path = new int[0, 0];\n        \n        \n        static int dijik(int n , int start, int end) {\n            int[] cost = Enumerable.Repeat(int.MaxValue, n + 1).ToArray();\n            bool[] visited = new bool[n + 1];\n            cost[start] = 0;\n\n            while (true) {\n                //min cost check. \n                int selected = -1;\n                int minCos = int.MaxValue;\n                for (int i = 1; i <= n; i++) {\n                    if (visited[i]) { continue; }\n                    if (minCos > cost[i]) { selected = i; minCos = cost[i]; }\n                }\n                if (selected == -1 || selected ==end) { break; }\n                visited[selected]=true;\n\n                //cost reload\n                for (int i = 1; i <= n; i++) {\n                    if (path[selected, i] >= 0) {\n                        cost[i] = Math.Min(cost[i], cost[selected] + path[selected, i]);\n                    }\n                }\n            }\n            return cost[end];\n        }\n\n\n        public static void Main(String[] args) {\n           string line;\n           while ((line = Console.ReadLine()) != null) {\n                //int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                //int n = ints[0];\n                int n = int.Parse(line);                \n                if (n == 0) { break; }\n               path=new int[n+1,n+1];\n               for (int i = 0; i < n + 1; i++) for (int j = 0; j < n + 1; j++) {\n                   path[i, j] = -1;    \n               }\n                int m = int.Parse(Console.ReadLine());\n                for (int i = 0; i < m; i++) {\n                    int[] ints = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n                    path[ints[0], ints[1]] = ints[2];\n                    path[ints[1], ints[0]] = ints[3];\n                }\n\n                int[] ints2 = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n                int ikicost = dijik(n, ints2[0], ints2[1]);\n                int kaericost = dijik(n, ints2[1], ints2[0]); \n               \n               Console.WriteLine(ints2[2]-ints2[3]-ikicost-kaericost);\n               break;\n            }\n        }\n\n    }\n\n    \n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var e = int.Parse(Console.ReadLine().Trim());\n        var dp = new int[n, n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (i == j) dp[i, j] = 0;\n                else dp[i, j] = C.INF;\n        for (int i = 0; i < e; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(',');\n            var a = Array.ConvertAll(line2, int.Parse);\n            dp[a[0]-1, a[1]-1] = a[2];\n            dp[a[1]-1, a[0]-1] = a[3];\n        }\n        goWarshall(dp);\n        string[] line3 = Console.ReadLine().Trim().Split(',');\n        var b = Array.ConvertAll(line3, int.Parse);\n        var ret = b[2] - b[3] - dp[b[0] - 1, b[1] - 1] - dp[b[1] - 1, b[0] - 1];\n        Console.WriteLine(ret);\n    }\n    public static void goWarshall(int[,] dp)\n    {\n        var n = dp.GetLength(0);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                        dp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ.Volume1\n{\n    public class RewardForCarpenter\n    {\n        private static int n;\n        private static int[,] cost;\n\n        private class Town\n        {\n            public int Cost { get; set; }\n            public bool Confirm { get; set; }\n        }\n\n        public static int Main()\n        {\n            n = int.Parse(Console.ReadLine());\n            // ??????????????????????????????\n            // ???????????????????????¢???????????§n+1?????§??¨?????????\n            // cost[1,2]???1??????2???????????????\n            cost = new int[n + 1, n + 1];\n            // ??????????????????????????¨???????????´??????-1\n            for(int i = 0; i <= n; i++)\n            {\n                for(int j = 0; j <= n; j++) { cost[i, j] = -1; }\n            }\n\n            int m = int.Parse(Console.ReadLine());\n            for(int i = 0; i < m; i++)\n            {\n                var input = Console.ReadLine().Split(',');\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n                cost[a, b] = c;\n                cost[b, a] = d;\n            }\n\n            var data = Console.ReadLine().Split(',');\n            int start = int.Parse(data[0]);\n            int goal = int.Parse(data[1]);\n            int capital = int.Parse(data[2]);\n            int material = int.Parse(data[3]);\n\n            // ???????????????????????§????????¢?´¢\n            // ??????\n            int c_go = Calc(start, goal);\n            // ????????????????????????????????????\n            capital = capital - c_go - material;\n\n            // ??????\n            int c_ret = Calc(goal, start);\n\n            // ??±??¬????±????\n            capital -= c_ret;\n\n            Console.WriteLine(capital);\n            return 0;\n        }\n\n        // ???????????????????????§??????????¨??????????\n        private static int Calc(int s, int g)\n        {\n\n            var t = new Town[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                t[i] = new Town();\n                t[i].Cost = int.MaxValue;\n                t[i].Confirm = false;\n            }\n\n            t[s].Cost = 0;\n            t[s].Confirm = true;\n            int no = s;\n            while (true)\n            {\n                int min = int.MaxValue;\n                for(int i = 1; i <= n; i++)\n                {\n                    if (cost[no, i] >= 0)\n                    {\n                        if (!t[i].Confirm) { t[i].Cost = Math.Min(t[i].Cost, t[no].Cost + cost[no, i]); }\n                    }\n                    if (!t[i].Confirm) { min = Math.Min(min, t[i].Cost); }\n                }\n\n                for(int i = 1; i <= n; i++)\n                {\n                    if(!t[i].Confirm && t[i].Cost == min) { no = i;break; }\n                }\n                t[no].Confirm = true;\n                if(no == g) { break; }\n            }\n\n            return t[g].Cost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nclass aoj\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int m = int.Parse(Console.ReadLine());\n        int[,] go = new int[n, n];\n        int[,] back = new int[n, n];\n        int[,] go2 = new int[n, n];\n        int[] a;\n        int[] b = new int[n];\n        bool[,] d = new bool[n, n];\n        int c, v, p, e, f;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                go[i, j] = 10000;\n                back[i, j] = 10000;\n                go2[i, j] = 10000;\n            }\n            b[i] = 10000;\n        }\n        for(int i = 0; i < m; i++)\n        {\n            a = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n            go2[a[0]-1, a[1]-1] = a[2];\n            go2[a[1]-1, a[0]-1] = a[3];\n        }\n        a = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n        b[a[0] - 1] = 0;\n        c = a[1]-1;\n        v = a[2];\n        p = a[3];\n        for(int i = 0; i < n; i++)\n                go[a[0]-1, i] = go2[a[0]-1, i];\n        while (b[c] == 10000)\n        {\n            int sum = 10000;\n            for(int i = 0; i < n; i++)\n            {\n                for(int j = 0; j < n; j++) { if (sum > go[i, j] && d[i, j] == false) sum = go[i, j]; }\n            }\n            for(int i = 0; i < n; i++)\n            {\n                for(int j = 0; j < n; j++)\n                {\n                    if (go[i,j]==sum&&d[i,j]==false)\n                    {\n                        if (b[i] + sum < b[j]) b[j] = b[i] + sum;\n                        d[i, j] = true;\n                        for (int z = 0; z < n; z++)\n                            go[j, z] = go2[j, z];\n                    }\n                }\n            }\n        }\n        e = b[c];\n        for (int i = 0; i < n; i++)\n        {\n            b[i] = 10000;\n            for (int j = 0; j < n; j++)\n                d[i, j] = false;\n        }\n        b[c] = 0;\n        for (int i = 0; i < n; i++)\n            back[c, i] = go2[c, i];\n        while (b[a[0]-1] == 10000)\n        {\n            int sum = 10000;\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++) { if (sum > back[i, j] && d[i, j] == false) sum = go[i, j]; }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (back[i, j] == sum && d[i, j] == false)\n                    {\n                        if (b[i] + sum < b[j]) b[j] = b[i] + sum;\n                        d[i, j] = true;\n                        for (int z = 0; z < n; z++)\n                            back[j, z] = go2[j, z];\n                    }\n                }\n            }\n        }\n        f = b[a[0]-1];\n        Console.WriteLine(v - p - e - f);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Edge : IComparable\n    {\n        internal int target;\n        internal int cost;\n\n        public Edge(int target, int cost)\n        {\n            this.target = target;\n            this.cost = cost;\n        }\n\n        public int CompareTo(object obj)\n        {\n            Edge temp = obj as Edge;\n            return temp.cost - cost;    // Reverse\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int m = int.Parse(Console.ReadLine());\n\n            Dictionary<int, List<Edge>> nodeList = new Dictionary<int, List<Edge>>();\n            for (int i = 0; i <= n; i++) nodeList.Add(i, new List<Edge>());\n\n            string[] input;\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split(',');\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n\n                nodeList[a].Add(new Edge(b, c));\n                nodeList[b].Add(new Edge(a, d));\n            }\n\n            input = Console.ReadLine().Split(',');\n            int s = int.Parse(input[0]);\n            int g = int.Parse(input[1]);\n            int V = int.Parse(input[2]);\n            int P = int.Parse(input[3]);\n\n            int forward = Dijkstra(nodeList, s, g);\n            int backward = Dijkstra(nodeList, g, s);\n\n            Console.WriteLine(V - P - forward - backward);\n        }\n\n        static int Dijkstra(Dictionary<int, List<Edge>> nodeList, int start, int target)\n        {\n            PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\n            int n = nodeList.Count;\n\n            int[] costs = Enumerable.Repeat(int.MaxValue, n).ToArray();\n            bool[] visited = new bool[n];\n\n            costs[start] = 0;\n            pq.Enqueue(new Edge(start, 0));\n\n            while (pq.Count > 0)\n            {\n                Edge cur = pq.Dequeue();\n                visited[cur.target] = true;\n\n                if (costs[cur.target] < cur.cost) continue;\n\n                for (int j = 0; j < nodeList[cur.target].Count; j++)\n                {\n                    Edge next = nodeList[cur.target][j];\n\n                    if (visited[next.target] == true) continue;\n\n                    if (costs[next.target] > costs[cur.target] + next.cost)\n                    {\n                        costs[next.target] = costs[cur.target] + next.cost;\n                        pq.Enqueue(new Edge(next.target, costs[next.target]));\n                    }\n                }\n            }\n            return costs[target];\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public int Count { get { return size; } }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AOJ.Codes\n{\n    //問題の名称...  0117:   A reward for a Carpenter\n    //問題文のURL... http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117&lang=jp\n    //所要時間... AAA\n    //学んだこと... AAA\n    //教室内の大まかな着席位置... {左，中央，右} x {前，中央，奥}\n\n    class _0117_aReward_foraCarpenter\n    {\n        static void Main(string[] args)\n        {\n            //読み込み\n            var n = int.Parse(Console.ReadLine());\n            var m = int.Parse(Console.ReadLine());\n\n            //読み込み\n            var M = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    M[i, j] = int.MaxValue;\n\n            //読み込み＆マッピング\n            //端が（１，１）なのに注意\n            for (int i = 0; i < m; i++)\n            {\n                var abcd = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n                var a = abcd[0]; //街i\n                var b = abcd[1]; //街j\n                M[a - 1, b - 1] = abcd[2]; //i→j\n                M[b - 1, a - 1] = abcd[3]; //j→i\n            }\n\n            //読み込み\n            var sgVP = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n            var s = sgVP[0]; //自分の街\n            var g = sgVP[1]; //柱のある町\n            var V = sgVP[2]; //褒美\n            var P = sgVP[3]; //柱の代金\n\n\n            //計算 - 距離\n            for (int k = 0; k < n; k++)\n            {\n                var newM = (int[,])M.Clone();\n                for (int i = 0; i < n; i++)\n                    for (int j = 0; j < n; j++)\n                        //どちらか∞ならスキップ。じゃなかったら大きかったら実行。\n                        if ((M[i, k] != int.MaxValue && M[k, j] != int.MaxValue) && M[i, j] > M[i, k] + M[k, j])\n                            newM[i, j] = M[i, k] + M[k, j];\n                M = newM;\n            }\n\n            //計算 - おかね\n            var ans = V - (M[s - 1, g - 1] + M[g - 1, s - 1] + P);\n\n\n            //出力\n            Console.WriteLine(ans);\n            Console.ReadLine();\n\n        }\n\n\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Text;\nclass P\n{\n    static int n;\n    static void Main()\n    {\n        n = int.Parse(Console.ReadLine());\n        int m = int.Parse(Console.ReadLine());\n        int[][] k = new int[n][];\n        for (int i = 0; i < n; i++)\n        {\n            k[i] = new int[n];\n            for (int j = 0; j < n; j++)\n            {\n                if (i == j)\n                {\n                    k[i][j] = 0;\n                    continue;\n                }\n                k[i][j] = int.MaxValue / 50;\n            }\n        }\n        string[] str;\n        for (int i = 0; i < m; i++)\n        {\n            str = Console.ReadLine().Split(',');\n            int a, b, c, d;\n            a = int.Parse(str[0]);\n            b = int.Parse(str[1]);\n            c = int.Parse(str[2]);\n            d = int.Parse(str[3]);\n            k[a - 1][b - 1] = c;\n            k[b - 1][a - 1] = d;\n        }\n        str = Console.ReadLine().Split(',');\n        int s, g, v, p;\n        s = int.Parse(str[0]);\n        g = int.Parse(str[1]);\n        v = int.Parse(str[2]);\n        p = int.Parse(str[3]);\n        FloydWarshall(ref k);\n        Console.WriteLine(v - p - k[s - 1][g - 1] - k[g - 1][s - 1]);\n    }\n    static void FloydWarshall(ref int[][] K)\n    {\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (K[i][j] > K[i][k] + K[k][j])\n                        K[i][j] = K[i][k] + K[k][j];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class C\n{\n    public const int INF = 999999999;\n}\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\npublic struct Edge\n{\n    public int to { get; set; }\n    public int d { get; set; }\n}\npublic class Node : IComparable\n{\n    public int id { get; set; }\n    public int d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Node)obj;\n        if (this.d > x.d) return 1;\n        else if (this.d == x.d) return 0;\n        else return -1;\n    }\n}\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var pq = new PriorityQueue<Node>(n + 100000, 0);\n        var e = int.Parse(Console.ReadLine().Trim());\n        var a = new List<Edge>[n];\n        for (int i = 0; i < n; i++) a[i] = new List<Edge>();\n        for (int i = 0; i < e; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(',');\n            var s = int.Parse(line2[0]);\n            var t = int.Parse(line2[1]);\n            var d = int.Parse(line2[2]);\n            var d2 = int.Parse(line2[3]);\n            a[s-1].Add(new Edge { to = t-1, d = d });\n            a[t-1].Add(new Edge { to = s-1, d = d2 });\n        }\n        var mind = new int[n];\n        for (int i = 0; i < n; i++) mind[i] = C.INF;\n        string[] line3 = Console.ReadLine().Trim().Split(',');\n        var r = int.Parse(line3[0])-1;\n        var r2 = int.Parse(line3[1]) - 1;\n        goDijk(pq, a, r, n, mind);\n        var ret1 = mind[r2];\n        for (int i = 0; i < n; i++) mind[i] = C.INF;\n        goDijk(pq, a, r2, n, mind);\n        var ret2 = mind[r];\n        Console.WriteLine(int.Parse(line3[2]) - int.Parse(line3[3]) - ret1 - ret2);\n    }\n    public static void goDijk(PriorityQueue<Node> pq, List<Edge>[] aa, int r, int n, int[] mind)\n    {\n        pq.Push(new Node { id = r, d = 0 });\n        while (pq.Count() > 0)\n        {\n            var targ = pq.Pop();\n            var nowd = targ.d;\n            var nowid = targ.id;\n            if (mind[nowid] < nowd) continue;\n            mind[nowid] = nowd;\n            foreach (var x in aa[nowid])\n                if (nowd + x.d < mind[x.to])\n                    pq.Push(new Node { id = x.to, d = nowd + x.d });\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0117\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = RInt();\n            int m = RInt();\n\n            Graph gh1 = new Graph();\n            Graph gh2 = new Graph();\n            for (int i = 0 ; i < m ; i++)\n            {\n                int[] items = RIntAr(',');\n                gh1.SetGraph(items[0], items[1], items[2]);\n                gh1.SetGraph(items[1], items[0], items[3]);\n\n                gh2.SetGraph(items[0], items[1], items[2]);\n                gh2.SetGraph(items[1], items[0], items[3]);\n            }\n\n            int[] items2 = RIntAr(',');\n            int s = items2[0]; int g = items2[1]; int v = items2[2]; int p = items2[3];\n\n            gh1.Dijkstra(s);\n            gh2.Dijkstra(g);\n            int go = gh1.Adj[g].Distance;\n            int back = gh2.Adj[s].Distance;\n\n            Console.WriteLine(v - (p + go + back));\n\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public class Graph\n    {\n        public class Node\n        {\n            public List<KeyValuePair<int, int>> Vertex { get; internal set; }\n            public int D { get; internal set; }\n            public int F { get; internal set; }\n            public bool IsVisited { get; internal set; }\n            public int Group { get; internal set; }\n            public int Depth { get; internal set; }\n            public int Distance { get; internal set; }\n\n            public Node(List<int> v)\n            {\n                Vertex = v.Select(x => new KeyValuePair<int, int>(x, -1)).ToList();\n                Depth = -1;\n                Group = -1;\n                Distance = int.MaxValue;\n            }\n\n            public Node(List<KeyValuePair<int, int>> v)\n            {\n                Vertex = v;\n                Depth = -1;\n                Group = -1;\n                Distance = int.MaxValue;\n            }\n\n        }\n\n        public Dictionary<int, Node> Adj { get; set; }\n        public int Count { get { return Adj.Count; } }\n\n        public Graph()\n        {\n            Adj = new Dictionary<int, Node>();\n        }\n\n        public void AddVertex(int index, int v)\n        {\n            if (!Adj[index].Vertex.Contains(new KeyValuePair<int, int>(v, -1)))\n            {\n                Adj[index].Vertex.Add(new KeyValuePair<int, int>(v, -1));\n            }\n        }\n\n\n        /// <summary>\n        /// 指定した頂点をセットする\n        /// </summary>\n        /// <param name=\"index\">頂点u</param>\n        /// <param name=\"item\">頂点uに接続する頂点</param>\n        public void SetGraph(int index, int[] item)\n        {\n            if (item == null)\n            {\n                Adj.Add(index, new Node(new List<int>()));\n            }\n            else\n            {\n                Adj.Add(index, new Node(item.ToList()));\n            }\n        }\n\n        public void SetGraph(int index, List<KeyValuePair<int, int>> item)\n        {\n            if (item == null)\n            {\n                Adj.Add(index, new Node(new List<int>()));\n            }\n            else\n            {\n                Adj.Add(index, new Node(item));\n            }\n        }\n\n        public void SetGraph(int index, int v, int c)\n        {\n            if (!Adj.ContainsKey(index))\n            {\n                SetGraph(index);\n            }\n            Adj[index].Vertex.Add(new KeyValuePair<int, int>(v, c));\n        }\n\n        public void SetGraph(int index)\n        {\n            if (!Adj.ContainsKey(index))\n            {\n                Adj.Add(index, new Node(new List<KeyValuePair<int, int>>()));\n            }\n        }\n\n\n        /// <summary>\n        /// 行列を0で初期化する\n        /// </summary>\n        public void Clear() { Adj.Clear(); }\n\n        /// <summary>\n        /// 深さ優先探索\n        /// </summary>\n        private int Time = 0;\n        public void DFS(int v)\n        {\n            Adj[v].D = ++Time;\n            Adj[v].IsVisited = true;\n            foreach (KeyValuePair<int, int> vertex in Adj[v].Vertex)\n            {\n                if (!Adj[vertex.Key].IsVisited) DFS(vertex.Key);\n            }\n            Adj[v].F = ++Time;\n        }\n\n        /// <summary>\n        /// 訪問済フラグをクリアする\n        /// </summary>\n        private void InitVisitFlag()\n        {\n            foreach (KeyValuePair<int, Node> item in Adj) item.Value.IsVisited = false;\n        }\n\n        /// <summary>\n        /// 幅優先探索\n        /// </summary>\n        /// <param name=\"v\"></param>\n        public void BFS(int v)\n        {\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[v].Depth = 0;\n            Adj[v].IsVisited = true;\n            que.Enqueue(Adj[v]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (!Adj[vertex.Key].IsVisited)\n                    {\n                        Adj[vertex.Key].IsVisited = true;\n                        Adj[vertex.Key].Depth = node.Depth + 1;\n                        que.Enqueue(Adj[vertex.Key]);\n\n                    }\n                }\n            }\n\n        }\n\n        /// <summary>\n        /// 頂点間の最小頂点数を返す\n        /// </summary>\n        /// <param name=\"start\">始点</param>\n        /// <param name=\"end\">終点</param>\n        /// <returns>\n        /// 始点と終点の距離\n        /// 始点と終点が連結されていない場合は-1を返す\n        /// </returns>\n        public int GetDistance(int start, int end)\n        {\n            InitVisitFlag();\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[start].IsVisited = true;\n            Adj[start].Depth = 0;\n\n            if (start == end) return Adj[start].Depth;\n            que.Enqueue(Adj[start]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (!Adj[vertex.Key].IsVisited)\n                    {\n                        Adj[vertex.Key].IsVisited = true;\n                        Adj[vertex.Key].Depth = node.Depth + 1;\n\n                        if (vertex.Key == end) return Adj[vertex.Key].Depth;\n                        que.Enqueue(Adj[vertex.Key]);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        /// <summary>\n        /// 連結である頂点に同一のグループ番号をセットする\n        /// </summary>\n        public void SetGroup()\n        {\n            int group = 0;\n            foreach (KeyValuePair<int, Node> item in Adj)\n            {\n                if (item.Value.Group < 0)\n                {\n                    _SetGroup(item.Key, group);\n                }\n                group++;\n            }\n        }\n\n        private void _SetGroup(int key, int group)\n        {\n\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[key].Group = group;\n            que.Enqueue(Adj[key]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (Adj[vertex.Key].Group < 0)\n                    {\n                        Adj[vertex.Key].Group = group;\n                        que.Enqueue(Adj[vertex.Key]);\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 最小全域木のコストを求める（プリム法）\n        /// </summary>\n        /// <returns></returns>\n        class Edge : IComparable<Edge>\n        {\n            public int NextV { get; set; }\n            public int Cost { get; set; }\n\n            public Edge(int nextV, int cost)\n            {\n                NextV = nextV;\n                Cost = cost;\n            }\n\n            public int CompareTo(Edge other)\n            {\n                return -1 * Cost.CompareTo(other.Cost);\n            }\n        }\n        public int Prim()\n        {\n            PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n            int totalCost = 0;\n            pq.Enqueue(new Edge(Adj.First().Key, 0));\n\n            while (pq.Count > 0)\n            {\n                Edge e = pq.Dequeue();\n                if (!Adj[e.NextV].IsVisited)\n                {\n                    Adj[e.NextV].IsVisited = true;\n                    totalCost += e.Cost;\n                    foreach (KeyValuePair<int, int> vertex in Adj[e.NextV].Vertex)\n                    {\n                        pq.Enqueue(new Edge(vertex.Key, vertex.Value));\n                    }\n                }\n\n            }\n\n            return totalCost;\n\n        }\n\n        /// <summary>\n        /// 始点からの距離をセットする（ダイクストラ法）\n        /// </summary>\n        /// <param name=\"s\">始点</param>\n        class Candidate : IComparable<Candidate>\n        {\n            public int V { get; set; }\n            public int Distance { get; set; }\n\n            public Candidate(int v, int d) { Distance = d; V = v; }\n            public int CompareTo(Candidate other) { return -1 * Distance.CompareTo(other.Distance); }\n        }\n        public void Dijkstra(int s)\n        {\n            Adj[s].Distance = 0;\n            PriorityQueue<Candidate> pq = new PriorityQueue<Candidate>();\n            pq.Enqueue(new Candidate(s, Adj[s].Distance));\n\n            while (pq.Count > 0)\n            {\n\n                Candidate c = pq.Dequeue();\n                int v = c.V;\n                int d = c.Distance;\n\n                if (Adj[v].Distance < c.Distance) continue;\n\n                foreach (KeyValuePair<int, int> nextV in Adj[v].Vertex)\n                {\n                    if (Adj[nextV.Key].Distance > Adj[v].Distance + nextV.Value)\n                    {\n                        Adj[nextV.Key].Distance = Adj[v].Distance + nextV.Value;\n                        pq.Enqueue(new Candidate(nextV.Key, Adj[nextV.Key].Distance));\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    public class PriorityQueue<T> where T : IComparable<T>\n\n    {\n\n        private List<T> Buffer { get; set; }\n\n        public int Count { get { return Buffer.Count; } }\n\n        public PriorityQueue() { Buffer = new List<T>(); }\n        public PriorityQueue(int capacity) { Buffer = new List<T>(capacity); }\n\n\n        /// <summary>\n        /// ヒープ化されている配列リストに新しい要素を追加する。\n        /// </summary>\n        public void Enqueue(T item)\n        {\n            int n = Buffer.Count;\n            Buffer.Add(item);\n\n            while (n != 0)\n            {\n                int i = (n - 1) / 2;\n                if (Buffer[n].CompareTo(Buffer[i]) > 0)\n                {\n                    T tmp = Buffer[n]; Buffer[n] = Buffer[i]; Buffer[i] = tmp;\n                }\n                n = i;\n            }\n        }\n\n        /// <summary>\n        /// ヒープから最大値を取り出し、削除する。\n        /// </summary>\n        public T Dequeue()\n        {\n            T ret = Buffer[0];\n            int n = Buffer.Count - 1;\n            Buffer[0] = Buffer[n];\n            Buffer.RemoveAt(n);\n\n            for (int i = 0, j ; (j = 2 * i + 1) < n ;)\n            {\n                if ((j != n - 1) && (Buffer[j].CompareTo(Buffer[j + 1]) < 0))\n                    j++;\n                if (Buffer[i].CompareTo(Buffer[j]) < 0)\n                {\n                    T tmp = Buffer[j]; Buffer[j] = Buffer[i]; Buffer[i] = tmp;\n                }\n                i = j;\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// ヒープから最大値を参照する。\n        /// </summary>\n        public T Peek()\n        {\n            if (Count == 0) throw new InvalidOperationException();\n            return this.Buffer[0];\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ.Volume1\n{\n    public class RewardForCarpenter\n    {\n        private static int n;\n        private static int[,] cost;\n\n        private class Town\n        {\n            public int No { get; set; }\n            public int Cost { get; set; }\n            public bool Confirm { get; set; }\n        }\n\n        public static int Main()\n        {\n            n = int.Parse(Console.ReadLine());\n            // ??????????????????????????????\n            // ???????????????????????¢???????????§n+1?????§??¨?????????\n            // cost[1,2]???1??????2???????????????\n            cost = new int[n + 1, n + 1];\n            // ??????????????????????????¨???????????´??????-1\n            for(int i = 0; i <= n; i++)\n            {\n                for(int j = 0; j <= n; j++) { cost[i, j] = -1; }\n            }\n\n            int m = int.Parse(Console.ReadLine());\n            for(int i = 0; i < m; i++)\n            {\n                var input = Console.ReadLine().Split(',');\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                int c = int.Parse(input[2]);\n                int d = int.Parse(input[3]);\n                cost[a, b] = c;\n                cost[b, a] = d;\n            }\n\n            var data = Console.ReadLine().Split(',');\n            int start = int.Parse(data[0]);\n            int goal = int.Parse(data[1]);\n            int capital = int.Parse(data[2]);\n            int material = int.Parse(data[3]);\n\n            // ???????????????????????§????????¢?´¢\n            // ??????\n            int c_go = Calc(start, goal);\n            // ????????????????????????????????????\n            capital = capital - c_go - material;\n\n            // ??????\n            int c_ret = Calc(goal, start);\n\n            // ??±??¬????±????\n            capital -= c_ret;\n\n            Console.WriteLine(capital);\n            return 0;\n        }\n\n        // ???????????????????????§??????????¨??????????\n        private static int Calc(int s, int g)\n        {\n            var t = new List<Town>();\n            for(int i = 1; i <= n; i++)\n            {\n                var tn = new Town();\n                tn.No = i;\n                tn.Cost = int.MaxValue;\n                tn.Confirm = false;\n                t.Add(tn);\n            }\n\n            var tmp = t.First(x => x.No == s);\n            tmp.Cost = 0;\n            tmp.Confirm = true;\n            while (true)\n            {\n                for(int i = 1; i <= n; i++)\n                {\n                    if (cost[tmp.No, i] >= 0)\n                    {\n                        var to = t.First(x => x.No == i);\n                        if (!to.Confirm) { to.Cost = Math.Min(to.Cost, tmp.Cost + cost[tmp.No, i]); }\n                    }\n                }\n\n                tmp = t.Where(x => !x.Confirm).OrderBy(y => y.Cost).First();\n                tmp.Confirm = true;\n                if(tmp.No == g) { break; }\n            }\n\n            return tmp.Cost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nclass aoj\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int m = int.Parse(Console.ReadLine());\n        int[,] go = new int[n, n];\n        int[,] back = new int[n, n];\n        int[,] go2 = new int[n, n];\n        int[] a;\n        int[] b = new int[n];\n        bool[,] d = new bool[n, n];\n        int c, v, p, e, f;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                go[i, j] = 10000;\n                back[i, j] = 10000;\n                go2[i, j] = 10000;\n            }\n            b[i] = 10000;\n        }\n        for(int i = 0; i < m; i++)\n        {\n            a = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n            go2[a[0]-1, a[1]-1] = a[2];\n            go2[a[1]-1, a[0]-1] = a[3];\n        }\n        a = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n        b[a[0] - 1] = 0;\n        c = a[1]-1;\n        v = a[2];\n        p = a[3];\n        for(int i = 0; i < n; i++)\n                go[a[0]-1, i] = go2[a[0]-1, i];\n        while (b[c] == 10000)\n        {\n            int sum = 10000;\n            for(int i = 0; i < n; i++)\n            {\n                for(int j = 0; j < n; j++){if (sum > go[i, j] + b[i] && d[i, j] == false)sum = go[i, j] + b[i];}\n            }\n            for(int i = 0; i < n; i++)\n            {\n                for(int j = 0; j < n; j++)\n                {\n                    if (go[i,j] + b[i] == sum && d[i,j] == false)\n                    {\n                        if (b[i] + sum < b[j]) b[j] =  sum;\n                        d[i, j] = true;\n                        for (int z = 0; z < n; z++)\n                            go[j, z] = go2[j, z];\n                    }\n                }\n            }\n        }\n        e = b[c];\n        for (int i = 0; i < n; i++)\n        {\n            b[i] = 10000;\n            for (int j = 0; j < n; j++)\n                d[i, j] = false;\n        }\n        b[c] = 0;\n        for (int i = 0; i < n; i++)\n            back[c, i] = go2[c, i];\n        while (b[a[0]-1] == 10000)\n        {\n            int sum = 10000;\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++) { if (sum > back[i, j] + b[i] && d[i, j] == false) sum = go[i, j] + b[i]; }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (back[i, j] + b[i] == sum && d[i, j] == false)\n                    {\n                        if (b[i] + sum < b[j]) b[j] = sum;\n                        d[i, j] = true;\n                        for (int z = 0; z < n; z++)\n                            back[j, z] = go2[j, z];\n                    }\n                }\n            }\n        }\n        f = b[a[0]-1];\n        int g = p + e + f;\n        Console.WriteLine(v - g);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\n\nnamespace ConsoleApplication1 {\n\n    \n\n    class ClassMain {\n\n        //[n+1 , n+1]\n        static int[,] path = new int[0, 0];\n        \n        \n        static int dijik(int n , int start, int end) {\n            int[] cost = Enumerable.Repeat(int.MaxValue, n + 1).ToArray();\n            bool[] visited = new bool[n + 1];\n            cost[start] = 0;\n\n            while (true) {\n                //min cost check. \n                int selected = -1;\n                int minCos = int.MaxValue;\n                for (int i = 1; i <= n; i++) {\n                    if (visited[i]) { continue; }\n                    if (minCos > cost[i]) { selected = i; minCos = cost[i]; }\n                }\n                if (selected == -1 || selected ==end) { break; }\n                visited[selected]=true;\n\n                //cost reload\n                for (int i = 1; i <= n; i++) {\n                    if (path[selected, i] != 0) {\n                        cost[i] = Math.Min(cost[i], cost[selected] + path[selected, i]);\n                    }\n                }\n            }\n            return cost[end];\n        }\n\n\n        public static void Main(String[] args) {\n           string line;\n           while ((line = Console.ReadLine()) != null) {\n                //int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                //int n = ints[0];\n                int n = int.Parse(line);                \n                if (n == 0) { break; }\n               path=new int[n+1,n+1];\n                int m = int.Parse(Console.ReadLine());\n                for (int i = 0; i < m; i++) {\n                    int[] ints = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n                    path[ints[0], ints[1]] = ints[2];\n                    path[ints[1], ints[0]] = ints[3];\n                }\n\n                int[] ints2 = Console.ReadLine().Split(',').Select(int.Parse).ToArray();\n                int ikicost = dijik(n, ints2[0], ints2[1]);\n                int kaericost = dijik(n, ints2[1], ints2[0]); \n               \n               Console.WriteLine(ints2[2]-ints2[3]-ikicost-kaericost);\n               break;\n            }\n        }\n\n    }\n\n    \n\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function warshall(){\n   for(var k=0;k<n;k++){\n      for(var i=0;i<n;i++){\n         for(var j=0;j<n;j++){\n            C[i][j]=Math.min(C[i][j], C[i][k]+C[k][j]);\n         }\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar n=Arr.shift()-0;\nvar m=Arr.shift()-0;\nvar C=[];\nfor(var i=0;i<n;i++){\n   C[i]=[];\n   for(var j=0;j<n;j++){\n      C[i][j]=(i===j)?0:Infinity;\n   }\n}\nfor(var i=0;i<m;i++){\n   var A=(Arr.shift()).split(\",\").map(Number);\n   C[A[0]-1][A[1]-1]=A[2];\n   C[A[1]-1][A[0]-1]=A[3];\n}\nwarshall();\nvar last=(Arr.shift()).split(\",\").map(Number);\nvar cost=C[last[0]-1][last[1]-1]+C[last[1]-1][last[0]-1]+last[3];\nconsole.log(last[2]-cost);"
  },
  {
    "language": "Ruby",
    "code": "def dijkstra s, g\n\tcurrent, cost, close, open = s, 0, {s=>0}, {}\n\twhile true\n\t\t@arr[current].each{|to, c| open[to] = cost + c if !close[to] && (!open[to] || open[to] > cost + c)}\n\t\tmin = nil\n\t\topen.to_a.each{|to, c| min = [to, c] if min.nil? || min[1] > c}\n\t\tcurrent, cost = min\n\t\topen.delete(current)\n\t\tclose[current] = cost\n        break if current == g\n\tend\n\tclose[g]\nend\n\nn = gets.to_i\nm = gets.to_i\n@arr = Array.new(n + 1){[]}\nm.times{\n    a, b, c, d = gets.chomp.split(',').map(&:to_i)\n    @arr[a] << [b, c]\n    @arr[b] << [a, d]\n}\ns, g, v, p = gets.chomp.split(',').map(&:to_i)\nputs v - p - dijkstra(s, g) - dijkstra(g, s)\n\n"
  },
  {
    "language": "Ruby",
    "code": "\ndef get_path(current, goal, edges, path)\n  next_edges = edges.select{ |e| e[0,2].include?(current) }\n  next_nodes = next_edges.map{ |e| e[0,2].select{|x| x!=current}.first }\n\n\n  next_nodes.map do |n|\n    if n == goal\n      path + [n]\n    elsif path.include?(n)\n      nil\n    else\n      get_path(n, goal, edges, path + [n])\n    end\n  end\nend\n\ndef cost_of_paths(start, goal, edges, edges_cost)\n  paths = []\n  i = 0\n\n  get_path(start, goal, edges, [start]).flatten.each do |x|\n    if x.nil?\n      i += 1\n      next\n    elsif x == goal\n      paths[i] << x\n      i += 1\n    elsif paths[i].nil?\n      paths[i] = [x]\n    else\n      paths[i] << x\n    end\n  end\n\n  a = paths.compact.map do |path|\n    cost = 0\n    path.each.with_index do |x,i|\n      cost += edges_cost[[path[i], path[i+1]]] unless i == path.size-1\n    end\n    cost\n  end\n  a.min\nend\n\nn = gets.to_i\nm = gets.to_i\n\nedges = []\nedges_cost = {}\n\nm.times do\n  a, b, c, d = gets.chomp.split(',').map(&:to_i)\n  edges << [a, b, c, d]\n  edges_cost[[a,b]] = c\n  edges_cost[[b,a]] = d\nend\n\nstart, goal, money, tree_cost = gets.chomp.split(',').map(&:to_i)\n\ntotal_cost = cost_of_paths(start, goal, edges, edges_cost) + cost_of_paths(goal, start, edges, edges_cost) + tree_cost\n\np money - total_cost"
  },
  {
    "language": "Ruby",
    "code": "# Node\nclass Node\n  attr_accessor :id, :edges, :cost, :done\n\n  def initialize(id, edges = [], cost = nil, done = false)\n    @id, @edges, @cost, @done = id, edges, cost, done\n  end\nend\n\n# Edge\nclass Edge\n  attr_accessor :to, :cost\n\n  def initialize(to, cost)\n    @to, @cost = to, cost\n  end\nend\n\n# Dijkstra\nclass Dijkstra\n  attr_accessor :nodes\n\n  def initialize(data)\n    @nodes = {}\n    data.each do |id, edges|\n      edges.map! { |edge| Edge.new(*edge) }\n      @nodes[id] = Node.new(id, edges)\n    end\n  end\n\n  def start(start_id)\n    @nodes.each do |id, node|\n      node.done = false\n      node.cost = node.id == start_id ? 0 : -1\n    end\n\n    loop do\n      done_node = nil\n      @nodes.each do |id, node|\n        next if node.done || node.cost < 0\n        done_node = node if done_node.nil? || node.cost < done_node.cost\n      end\n      break if done_node.nil?\n      done_node.done = true\n      done_node.edges.each do |edge|\n        node = @nodes[edge.to]\n        cost = done_node.cost + edge.cost\n        node.cost = cost if node.cost < 0 || cost < node.cost\n      end\n    end\n  end\nend\n\ndata1, data2 = {}, {}\n\nn = gets.chomp.to_i\nm = gets.chomp.to_i\n\nm.times do\n  a1, b1, c1, d1 = gets.chomp.split(',').map(&:to_i)\n  data1[a1] ||= []\n  data1[b1] ||= []\n  data1[a1] << [b1, c1]\n  data1[b1] << [a1, d1]\n  data2[a1] ||= []\n  data2[b1] ||= []\n  data2[a1] << [b1, c1]\n  data2[b1] << [a1, d1]\nend\n\nx1, x2, y1, y2 = gets.chomp.split(',').map(&:to_i)\n\ndijkstra1 = Dijkstra.new(data1)\ndijkstra2 = Dijkstra.new(data2)\n\ndijkstra1.start(x1)\ndijkstra2.start(x2)\n\nforward_path_cost = dijkstra1.nodes[x2].cost\nbackward_path_cost = dijkstra2.nodes[x1].cost\n\nputs y1 - y2 - forward_path_cost - backward_path_cost"
  },
  {
    "language": "Ruby",
    "code": "def e;eval\"[#{gets}]\";end\ngets\nh=(0..21).map{{}};gets.to_i.times{a,b,c,d=e;h[a][b]=c;h[b][a]=d}\n*s,z,c=e\ns.map{|x|d=[x]\nt={x=>0}\n(o=p=q=1e5;d.map{|i|h[i].map{|k,v|t[k]||q>v&&(o,p,q=i,k,v)}};t[p]=t[o]+q;d<<p)until w=t[*s-[x]]\nz-=w}\np z-c"
  },
  {
    "language": "Ruby",
    "code": "towns = Hash.new([])\nn = $<.gets.to_i\n(m = $<.gets.to_i).times do\n  a, b, c, d = $<.gets.split(\",\").map(&:to_i)\n  towns[a] += [[b, c]]\n  towns[b] += [[a, d]]\nend\ns, g, v, p = $<.gets.split(\",\").map(&:to_i)\n\ntravel = ->(start, goal) {\n  minimum = Float::INFINITY\n  walk = ->(town, visited, cost = 0) {\n    if town == goal\n      minimum = [minimum, cost].min\n    else\n      towns[town].each do |nxt, c|\n        walk.(nxt, visited + [nxt], cost + c) unless visited.include?(nxt)\n      end\n    end\n  }\n  walk.(start, [start])\n  minimum\n}\n\nv -= travel.(s, g)\nv -= travel.(g, s)\nputs v - p\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef calc_cost(s, g, n, edges)\n  q = Set.new (0...n)\n  max_cost = 1000 * n\n  costs = (0...n).map{max_cost}\n  costs[s] = 0\n\n  while ! q.empty?\n    u = q.to_a.min{|a, b| costs[a] <=> costs[b]}\n    q.delete(u)\n\n    for v in (0...n)\n      e = edges[u][v]\n      next if e.nil?\n\n      c = costs[u] + e\n      costs[v] = c if costs[v] > c\n    end\n  end\n\n  return costs[g]\nend\n\nn = gets.chomp.to_i\nm = gets.chomp.to_i\n\nedges = (0...n).map{[]}\n\nm.times.each do\n  n0, n1, c1, c2 = gets.chomp.split(\",\").map{|s| s.to_i}\n  n0 -= 1\n  n1 -= 1\n  edges[n0][n1] = c1\n  edges[n1][n0] = c2\nend\n\nst, gl, rev, pr = gets.chomp.split(\",\").map{|s| s.to_i}\nst -= 1\ngl -= 1\n\nc0 = calc_cost(st, gl, n, edges)\nc1 = calc_cost(gl, st, n, edges)\nputs rev - (pr + c0 + c1)"
  },
  {
    "language": "Ruby",
    "code": "Max = 1000000\n\ndef dijkstraDG graph, start\n  #初期化\n  dist = Array.new(graph.size, Max)\n  visited = Array.new(graph.size, false)\n  dist[start] = 0\n  \n  loop do\n    #未訪問節点でコスト最少の点を決定\n    u = -1\n    sd = Max\n    (0...graph.size).each do |i|\n        if ! visited[i] && dist[i] < sd\n          sd = dist[i]\n          u = i\n      end\n    end\n    break if u == -1\n    \n    #未訪問節点から隣接節点へのコストが最少であれば更新する\n    visited[u] = true\n    graph[u].each do |p|\n      v = p[0]\n      w = p[1]\n      newLength = dist[u] + w\n      if(newLength < dist[v])\n        dist[v] = newLength\n      end\n    end\n  end\n  dist\nend\n\nn = $stdin.gets.to_i\nm = $stdin.gets.to_i\n\nGraph = Array.new(n).map{Array.new}\n\nm.times do |t|\n  a,b,c,d = $stdin.gets.chomp.split(\",\").map(&:to_i)\n  Graph[a - 1] << [b - 1,c]\n  Graph[b - 1] << [a - 1,d]\nend\n\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\noutward = dijkstraDG(Graph, start - 1)\nhomeward = dijkstraDG(Graph, dest - 1)\np money - price - outward[dest - 1] - homeward[start - 1]"
  },
  {
    "language": "Ruby",
    "code": "White = -1\nGray = 0\nBlack = 1\nMax = 100000\n\ndef bfs(edge, s)\n  dist = Array.new(edge.size).fill(Max)\n  color = Array.new(edge.size).fill(White)\n  color[s] = Gray\n  dist[s] = 0\n  q = Queue.new\n  q.push s\n\n  while !(q.empty?)\n    from = q.pop\n    edge[from].each do |e|\n      to = e[0]\n      cost = e[1]\n      total = dist[from] + cost\n      dist[to] = (total < dist[to])? total : dist[to]\n      #ノードが未訪問の場合のみ、訪問キューに追加\n      if color[to] == White\n        color[to] = Gray\n        q.push to\n      end\n    end\n    color[from] = Black\n  end\n  dist\nend\n\ndef set(edge, data)\n  edge[data[0] - 1] << [data[1] - 1, data[2]]\n  edge[data[1] - 1] << [data[0] - 1, data[3]]\n  edge\nend\n\nedge = Array.new($stdin.gets.to_i).map{Array.new}\n$stdin.gets.to_i.times do\n  edge = set(edge, $stdin.gets.chomp.split(\",\").map(&:to_i))\nend\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\np (money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1])"
  },
  {
    "language": "Ruby",
    "code": "White = -1\nGray = 0\nBlack = 1\nMax = 100000\n\ndef bfs(edge, s)\n  dist = Array.new(edge.size).fill(Max)\n  color = Array.new(edge.size).fill(White)\n  color[s] = Gray\n  dist[s] = 0\n  q = Queue.new\n  q.push s\n\n  while !(q.empty?) do\n    from = q.pop\n    edge[from].each{|e|\n      to = e[0]\n      cost = e[1]\n      dist[to] = ((total = dist[from] + cost) < dist[to])? total : dist[to]\n      #ノードが未訪問の場合のみ、訪問キューに追加\n      if color[to] == White\n        color[to] = Gray\n        q.push to\n      end\n    }\n    color[from] = Black\n  end\n  dist\nend\n\ndef set(edge, data)\n  edge[data[0] - 1] << [data[1] - 1, data[2]]\n  edge[data[1] - 1] << [data[0] - 1, data[3]]\n  edge\nend\n\nedge = Array.new($stdin.gets.to_i).map{Array.new}\n$stdin.gets.to_i.times do\n  edge = set(edge, $stdin.gets.chomp.split(\",\").map(&:to_i))\nend\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\np (money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1])"
  },
  {
    "language": "Ruby",
    "code": "def e;eval\"[#{gets}]\";end\ngets\nh=(0..21).map{{}};gets.to_i.times{a,b,c,d=e;h[a][b]=c;h[b][a]=d}\n*s,z,c=e\ns.map{|x|d=[x]\nt={x=>0}\n(p=q=1e5;d.map{|i|h[i].map{|k,v|t[k]||q>(o=t[i]+v)&&(p,q=k,o)}};t[p]=q;d<<p)until w=t[*s-[x]]\nz-=w}\np z-c"
  },
  {
    "language": "Ruby",
    "code": "class Route\n#    rt: List, rt= [[x1, x2, y1], [x1, x3, y2],...]     x1->x2 cost y1\n  def initialize(nMachi, rt)\n    @nMachi=nMachi\n    @rt = rt.dup\n  end\n\n  def solve(start, dest)\n    goal =dest\n    aux(start, [], 0, goal)\n  end\n\n  def aux(start, visit, sum, goal) # search route from start\n    if start== goal then\n      return sum\n    else\n      rt1=@rt.select{|from,to,cost| from==start and !visit.index(to)}\n      rst= rt1.map{|from,to,cost|\n        aux(to, visit+[start], sum+cost, goal)\n      }\n      return rst.select{|x| x}.min\n    end\n  end\n\nend\n\ndef main()\n  if true then\n    fh=STDIN\n  else\n    fh=open(\"in1_0117.txt\", \"r\")\n  end\n\n  nMachi=fh.gets.chomp.to_i\n  nKaido=fh.gets.chomp.to_i\n\n  rt = []\n  0.upto(nKaido-1){|i|\n    x1,x2,y1,y2=fh.gets.chomp.split(/,/).map{|x|x.to_i}\n    rt.push [x1, x2, y1]\n    rt.push [x2, x1, y2]\n  }\n  start,dest,moto,hashira=fh.gets.chomp.split(/,/).map{|x|x.to_i}\n\n  r=Route.new(nMachi,rt)\n  go=r.solve(start,dest)\n  ret=r.solve(dest,start)\n  reward = moto - go - ret - hashira\n  puts reward\nend\n\nif __FILE__ == $0 then\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\nm=gets.to_i\n\narray=Array.new(n)\n  n.times{|t|\n  array[t]=Array.new(n, 100000000)\n}\nm.times{\n  a,b,c,d=gets.split(\",\").map{|e|e.to_i}\n  array[a-1][b-1]=c\n  array[b-1][a-1]=d\n}\n\n#k,i,j=0,0,0\nfor k in 0..n-1 do\n  for i in 0..n-1 do\n    for j in 0..n-1 do \n      array[i][j]=array[i][k]+array[k][j] if array[i][j]>array[i][k]+array[k][j]\n      j+=1\n    end\n    i+=1\n  end\n  k+=1\nend\nx1,x2,y1,y2=gets.split(\",\").map{|e|e.to_i}\n\n#array.each{|e|p e}\n\np y1-y2-array[x1-1][x2-1]-array[x2-1][x1-1]"
  },
  {
    "language": "Ruby",
    "code": "def set edge, data\n  edge[data[0] - 1] << [data[1] - 1, data[2]]\n  edge[data[1] - 1] << [data[0] - 1, data[3]]\n  edge\nend\n\nWhite = -1\nGray = 0\nBlack = 1\nMax = 100000\ndef bfs edge, s\n  dist = Array.new(edge.size).fill(Max)\n  color = Array.new(edge.size).fill(White)\n  color[s] = Gray\n  dist[s] = 0\n  q = Queue.new\n  q.push s\n\n  while !(q.empty?) do\n    from = q.pop\n    edge[from].each do |e|\n      to = e[0]\n      cost = e[1]\n      dist[to] = ((total = dist[from] + cost) < dist[to])? total : dist[to]\n      if color[to] == White\n        color[to] = Gray\n        q.push to\n      end\n    end\n    color[from] = Black\n  end\n  dist\nend\n\nedge = Array.new($stdin.gets.to_i).map{Array.new}\n$stdin.gets.to_i.times do\n  edge = set edge, $stdin.gets.chomp.split(\",\").map(&:to_i)\nend\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\np (money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1])"
  },
  {
    "language": "Ruby",
    "code": "\ndef get_path(current, goal, edges, path)\n  next_edges = edges.select{ |e| e[0,2].include?(current) }\n  next_nodes = next_edges.map{ |e| e[0,2].select{|x| x!=current}.first }\n\n  next_nodes.map do |n|\n    if n == goal\n      path + [n]\n    elsif path.include?(n)\n      nil\n    else\n      get_path(n, goal, edges, path + [n])\n    end\n  end\nend\n\ndef construct_paths(start, goal, edges, edges_cost)\n  paths = []\n  i = 0\n\n  get_path(start, goal, edges, [start]).flatten.each do |x|\n    if x.nil?\n      i += 1\n      next\n    elsif x == goal\n      paths[i] << x\n      i += 1\n    elsif paths[i].nil?\n      paths[i] = [x]\n    else\n      paths[i] << x\n    end\n  end\n  paths.compact\nend\n\ndef cost_of_paths(start, goal, edges, edges_cost)\n  costs = get_path(start, goal, edges, edges_cost).map do |path|\n    cost = 0\n    path.each.with_index { |x,i|cost += edges_cost[[path[i], path[i+1]]] unless i == path.size-1 }\n    cost\n  end\n  costs.min\nend\n\nif __FILE__ == $0\n  n = gets.to_i\n  m = gets.to_i\n\n  edges = []\n  edges_cost = {}\n\n  m.times do\n    a, b, c, d = gets.chomp.split(',').map(&:to_i)\n    edges << [a, b, c, d]\n    edges_cost[[a,b]] = c\n    edges_cost[[b,a]] = d\n  end\n\n  start, goal, money, tree_cost = gets.chomp.split(',').map(&:to_i)\n\n  total_cost = tree_cost + cost_of_paths(start, goal, edges, edges_cost) + cost_of_paths(goal, start, edges, edges_cost)\n\n  p money - total_cost\nend"
  },
  {
    "language": "Ruby",
    "code": "def set(edge, data)\n  edge[data[0] - 1] << [data[1] - 1, data[2]]\n  edge[data[1] - 1] << [data[0] - 1, data[3]]\n  edge\nend\n\nWhite = -1\nGray = 0\nBlack = 1\nMax = 100000\ndef bfs(edge, s)\n  dist = Array.new(edge.size).fill(Max)\n  color = Array.new(edge.size).fill(White)\n  color[s] = Gray\n  dist[s] = 0\n  q = Queue.new\n  q.push s\n\n  while !(q.empty?) do\n    from = q.pop\n    edge[from].each do |e|\n      to = e[0]\n      cost = e[1]\n      dist[to] = ((total = dist[from] + cost) < dist[to])? total : dist[to]\n      #ノードが未訪問の場合のみ、訪問キューに追加\n      if color[to] == White\n        color[to] = Gray\n        q.push to\n      end\n    end\n    color[from] = Black\n  end\n  dist\nend\n\nedge = Array.new($stdin.gets.to_i).map{Array.new}\n$stdin.gets.to_i.times do\n  edge = set(edge, $stdin.gets.chomp.split(\",\").map(&:to_i))\nend\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\np (money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1])"
  },
  {
    "language": "Ruby",
    "code": "def set edge, data\n  edge[data[0] - 1] << [data[1] - 1, data[2]]\n  edge[data[1] - 1] << [data[0] - 1, data[3]]\n  edge\nend\n\nWhite = -1\nGray = 0\nBlack = 1\nMAX = 100000\ndef bfs edge, s\n  dist = Array.new(edge.size).fill(MAX)\n  color = Array.new(edge.size).fill(White)\n  color[s] = Gray\n  dist[s] = 0\n  q = Queue.new\n  q.push s\n\n  while ! q.empty? do\n    from = q.pop\n    edge[from].each do |e|\n      to = e[0]\n      cost = e[1]\n      dist[to] =  (total = dist[from] + cost) < dist[to] ? total : dist[to]\n      if color[to] == White\n        color[to] = Gray\n        q.push to\n      end\n    end\n    color[from] = Black\n  end\n  dist\nend\n\nedge = Array.new($stdin.gets.to_i).map{Array.new}\n$stdin.gets.to_i.times do\n  edge = set edge, $stdin.gets.chomp.split(\",\").map(&:to_i)\nend\nstart, dest, money, price = $stdin.gets.chomp.split(\",\").map(&:to_i)\n\np money - price - bfs(edge, start - 1)[dest - 1] - bfs(edge, dest - 1)[start - 1]"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nm = gets.to_i\nes = []\nm.times do\n  a, b, c, d = gets.split(?,).map(&:to_i)\n  es << [a-1, b-1, c]\n  es << [b-1, a-1, d]\nend\ns, g, v, p = gets.split(?,).map(&:to_i)\ns, g = s-1, g-1\nbf = lambda do |s, g|\n  cs = Array.new n\n  cs[s] = 0\n  (n-1).times do\n    es.each do |a, b, c|\n      if cs[a] && (!cs[b] || cs[a] + c < cs[b])\n        cs[b] = cs[a] + c\n      end\n    end\n  end\n  cs[g]\nend\np v - (p + bf[s, g] + bf[g, s])"
  },
  {
    "language": "Ruby",
    "code": "\ndef get_path(current, goal, edges, path)\n  next_edges = edges.select{ |e| e[0,2].include?(current) }\n  next_nodes = next_edges.map{ |e| e[0,2].select{|x| x!=current}.first }\n\n  next_nodes.map do |n|\n    if n == goal\n      path + [n]\n    elsif path.include?(n)\n      nil\n    else\n      get_path(n, goal, edges, path + [n])\n    end\n  end\nend\n\ndef construct_paths(start, goal, edges, edges_cost)\n  paths = []\n  i = 0\n\n  get_path(start, goal, edges, [start]).flatten.each do |x|\n    if x.nil?\n      i += 1\n      next\n    elsif x == goal\n      paths[i] << x\n      i += 1\n    elsif paths[i].nil?\n      paths[i] = [x]\n    else\n      paths[i] << x\n    end\n  end\n  paths.compact\nend\n\ndef cost_of_paths(start, goal, edges, edges_cost)\n  costs = construct_paths(start, goal, edges, edges_cost).map do |path|\n    cost = 0\n    path.each.with_index { |x,i|cost += edges_cost[[path[i], path[i+1]]] unless i == path.size-1 }\n    cost\n  end\n  costs.min\nend\n\nif __FILE__ == $0\n  n = gets.to_i\n  m = gets.to_i\n\n  edges = []\n  edges_cost = {}\n\n  m.times do\n    a, b, c, d = gets.chomp.split(',').map(&:to_i)\n    edges << [a, b, c, d]\n    edges_cost[[a,b]] = c\n    edges_cost[[b,a]] = d\n  end\n\n  start, goal, money, tree_cost = gets.chomp.split(',').map(&:to_i)\n\n  total_cost = tree_cost + cost_of_paths(start, goal, edges, edges_cost) + cost_of_paths(goal, start, edges, edges_cost)\n\n  p money - total_cost\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n\nm = gets.to_i\nroads = (1..m).map {\n    i, j, c1, c2 = gets.split(\",\").map(&:to_i)\n    [i-1, j-1, c1, c2] \n}\n\ns, t, given, price = gets.split(\",\").map(&:to_i)\ns -= 1\nt -= 1\n\ncost = [Float::INFINITY] * n \ncost[s] = 0 \n(n-1).times {\n    roads.each{|i, j, c1, c2|\n        cost[j] = [cost[j], cost[i] + c1].min\n        cost[i] = [cost[i], cost[j] + c2].min\n    }   \n}\noutward_cost = cost[t]\n\ncost = [Float::INFINITY] * n \ncost[t] = 0 \n(n-1).times {\n    roads.each{|i, j, c1, c2|\n        cost[j] = [cost[j], cost[i] + c1].min\n        cost[i] = [cost[i], cost[j] + c2].min\n    }   \n}\nhomeward_cost = cost[s]\n\np given - outward_cost - price - homeward_cost"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj0200_in.txt', \"r\");\n\n$inf = 100000000;\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via_c = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via_c < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via_c;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\n//変数の初期化\n$cost = array();\n\n//ファイル読み込み\n$n = trim(fgets($file_handle));\n\n//ワーシャルフロイド準備。\nfor ($i=1; $i<=$n; ++$i){\n\tfor ($j=1; $j<=$n; ++$j){\n\t\tif ($i === $j){\n\t\t\t$cost[$i][$i] = 0;\n\t\t} else {\n\t\t\t$cost[$i][$j] = $inf;\n\t\t}\n\t}\n}\n\n$m = trim(fgets($file_handle));\nfor ($i=1; $i<=$m; ++$i){\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(',', $info);\n\t$a1 = $explode[0]; $b1 = $explode[1]; $c1 = $explode[2]; $d1 = $explode[3];\n\t$cost[$a1][$b1] = $c1; $cost[$b1][$a1] = $d1;\n}\n$info2 = trim(fgets($file_handle));\n$explode = explode(',', $info);\n$start = $explode[0]; $goal = $explode[1]; $y1 = $explode[2]; $y2 = $explode[3];\n\n\n//探索\n$res = warshall_floyd($cost);\n\n//収支計算\n$income = $y1;\n$expense = $res[$start][$goal] +$res[$goal][$start] + $y2;\n$output = $income - $expense;\n\n//出力\necho $output;\necho PHP_EOL;\n\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n$n=trim(fgets(STDIN));\n$m=trim(fgets(STDIN));\n$cost=[];\nfor ($i=0; $i < $m; $i++) {\n        list($a,$b,$c,$d)=explode(',',trim(fgets(STDIN)));\n        $a--;$b--;\n        $cost[$a][$b]=$c;\n        $cost[$b][$a]=$d;\n}\nlist($x1,$x2,$y1,$y2)=explode(',',trim(fgets(STDIN)));\n$x1--;$x2--;\n\n$y1-=$y2;\n\n$que=new SplPriorityQueue();\n$que->insert($x1,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x1]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x2) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x2];\n\n$que=new SplPriorityQueue();\n$que->insert($x2,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x2]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x1) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x1];\n\necho $y1.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj0200_in.txt', \"r\");\n\n$inf = 100000000;\n\nfunction warshall_floyd($cost) {\n\tglobal $m;\n\n\tfor ($i = 1; $i <= $m; ++$i) {\n\t    for ($j = 1; $j <= $m; ++$j) {\n\t        for ($k = 1; $k <= $m; ++$k) {\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via_c = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via_c < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via_c;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\n//変数の初期化\n$cost = array();\n\n//ファイル読み込み\n$n = trim(fgets($file_handle));\n\n//ワーシャルフロイド準備。\nfor ($i=1; $i<=$n; ++$i){\n\tfor ($j=1; $j<=$n; ++$j){\n\t\tif ($i === $j){\n\t\t\t$cost[$i][$i] = 0;\n\t\t} else {\n\t\t\t$cost[$i][$j] = $inf;\n\t\t}\n\t}\n}\n\n$m = trim(fgets($file_handle));\nfor ($i=1; $i<=$m; ++$i){\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(',', $info);\n\t$a1 = $explode[0]; $b1 = $explode[1]; $c1 = $explode[2]; $d1 = $explode[3];\n\t$cost[$a1][$b1] = $c1; $cost[$b1][$a1] = $d1;\n}\n$info2 = trim(fgets($file_handle));\n$explode = explode(',', $info);\n$start = $explode[0]; $goal = $explode[1]; $y1 = $explode[2]; $y2 = $explode[3];\n\n\n//探索\n$res = warshall_floyd($cost);\n\n//収支計算\n$income = $y1;\n$expense = $res[$start][$goal] +$res[$goal][$start] + $y2;\n$output = $income - $expense;\n\n//出力\necho $output;\necho PHP_EOL;\n\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass PQ extends SplPriorityQueue\n{\n        public function compare($priority1, $priority2)\n        {\n                if ($priority1 === $priority2) return 0;\n                return $priority1 > $priority2 ? -1 : 1;\n        }\n}\n\n$n=trim(fgets(STDIN));\n$m=trim(fgets(STDIN));\n$cost=[];\nfor ($i=0; $i < $m; $i++) {\n        list($a,$b,$c,$d)=explode(',',trim(fgets(STDIN)));\n        $a--;$b--;\n        $cost[$a][$b]=$c;\n        $cost[$b][$a]=$d;\n}\nlist($x1,$x2,$y1,$y2)=explode(',',trim(fgets(STDIN)));\n$x1--;$x2--;\n\n$y1-=$y2;\n\n$que=new PQ();\n$que->insert($x1,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x1]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x2) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x2];\n\n$que=new PQ();\n$que->insert($x2,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x2]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x1) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x1];\n\necho $y1.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass PQ extends SplPriorityQueue\n{\n        public function compare($priority1, $priority2)\n        {\n                if ($priority1 === $priority2) return 0;\n                return $priority1 < $priority2 ? -1 : 1;\n        }\n}\n\n$n=trim(fgets(STDIN));\n$m=trim(fgets(STDIN));\n$cost=[];\nfor ($i=0; $i < $m; $i++) {\n        list($a,$b,$c,$d)=explode(',',trim(fgets(STDIN)));\n        $a--;$b--;\n        $cost[$a][$b]=$c;\n        $cost[$b][$a]=$d;\n}\nlist($x1,$x2,$y1,$y2)=explode(',',trim(fgets(STDIN)));\n$x1--;$x2--;\n\n$y1-=$y2;\n\n$que=new PQ();\n$que->insert($x1,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x1]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x2) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x2];\n\n$que=new PQ();\n$que->insert($x2,0);\n\n$expense=array_fill(0,$n,PHP_INT_MAX/6);\n$expense[$x2]=0;\n\nwhile($que->count()){\n        $now=$que->extract();\n        if ($now===$x1) {\n                break;\n        }\n        foreach ($cost[$now] as $next => $v) {\n                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {\n                        $expense[$next]=$expense[$now]+$cost[$now][$next];\n                        $que->insert($next,$expense[$next]);\n                }\n        }\n}\n\n$y1-=$expense[$x1];\n\necho $y1.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj0117_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via_c = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via_c < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via_c;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\n//変数の初期化\n\n\n//ファイル読み込み\n$n = trim(fgets($file_handle));\n\n//ワーシャルフロイド準備。\nfor ($i=1; $i<=$n; ++$i){\n\tfor ($j=1; $j<=$n; ++$j){\n\t\tif ($i === $j){\n\t\t\t$cost[$i][$i] = 0;\n\t\t} else {\n\t\t\t$cost[$i][$j] = INF;\n\t\t}\n\t}\n}\n\n$m = trim(fgets($file_handle));\nfor ($i=1; $i<=$m; ++$i){\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(',', $info);\n\t$a1 = $explode[0]; $b1 = $explode[1]; $c1 = $explode[2]; $d1 = $explode[3];\n\t$cost[$a1][$b1] = $c1; $cost[$b1][$a1] = $d1;\n}\n$info2 = trim(fgets($file_handle));\n$explode = explode(',', $info2);\n$start = $explode[0]; $goal = $explode[1]; $y1 = $explode[2]; $y2 = $explode[3];\n\n\n//探索\n$res = warshall_floyd($cost);\n\n//収支計算\n$income = $y1;\n$expense = $res[$start][$goal] + $res[$goal][$start] + $y2;\n$output = $income - $expense;\n\n\n//出力\necho $output;\necho PHP_EOL;\n\n\nfclose($file_handle);"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\tint m = to!int(readln().strip());\n\tint[20][20] g;\n\tforeach(i; 0..20) {\n\t\tforeach(j; 0..20) {\n\t\t\tg[i][j] = int.max/100;\n\t\t}\n\t}\n\tforeach(i; 0..m) {\n\t\tauto s = map!(a => to!int(a))(readln().strip().split(\",\"));\n\t\tint a = s[0]-1;\n\t\tint b = s[1]-1;\n\t\tint c = s[2];\n\t\tint d = s[3];\n\t\tg[a][b] = c;\n\t\tg[b][a] = d;\n\t}\n\tauto s = map!(a => to!int(a))(readln().strip().split(\",\"));\n\tint x1 = s[0]-1;\n\tint x2 = s[1]-1;\n\tint y1 = s[2];\n\tint y2 = s[3];\n\tforeach(k; 0..n) {\n\t\tforeach(i; 0..n) {\n\t\t\tforeach(j; 0..n) {\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\twriteln(y1-y2-g[x1][x2]-g[x2][x1]);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int n = readln().chomp().to!int;\n    int m = readln().chomp().to!int;\n    int[21][21] map;\n    for(int i=0;i<21;i++){\n\tfor(int j=0;j<21;j++){\n\t    map[i][j] = 100000;\n\t}\n    }\n    for(int i=0;i<m;i++){\n\tauto s = readln().chomp().split(',').to!(int[]);\n\tmap[s[0]][s[1]] = s[2];\n\tmap[s[1]][s[0]] = s[3];\n    }\n    auto s = readln().chomp().split(',').to!(int[]);\n    int pos = s[0];\n    int goal = s[1];\n    int mon = s[2];\n    int pr = s[3];\n    bool flg = true;\n\n    while(flg){\n\tfor(int i=1;i<=n;i++){\n\t    for(int j=1;j<=n;j++){\n\t\tflg = false;\n\t\tfor(int k=1;k<=n;k++){\n\t\t    if(map[i][j] > map[i][k] + map[k][j]){\n\t\t\tmap[i][j] = map[i][k] + map[k][j];\n\t\t\tflg = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    writeln( mon - pr - map[pos][goal] - map[goal][pos]);\n\n\n}"
  },
  {
    "language": "D",
    "code": "module AOJ_Volume0117;\n\nimport std.stdio,std.string,std.conv,std.algorithm;\n\nint main()\n{\n\tint n,m;\n\tint cost[21][21];\n\tforeach(i;0..21)\n\t{\n\t\tforeach(j;0..21)\n\t\t{\n\t\t\tcost[i][j] = 100000;\n\t\t}\n\t}\n\n\tn = readln.chomp.to!int;\n\tm = readln.chomp.to!int;\n\n\tforeach(i;0..m)\n\t{\n\t\tstring[] s = readln.chomp.split(\",\");\n\t\tint a = s[0].to!int;\n\t\tint b = s[1].to!int;\n\t\tint c = s[2].to!int;\n\t\tint d = s[3].to!int;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\n\tforeach(k;1..n+1)\n\t{\n\t\tforeach(i;1..n+1)\n\t\t{\n\t\t\tforeach(j;1..n+1)\n\t\t\t{\n\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstring[] s = readln.chomp.split(\",\");\n\tint x1 = s[0].to!int;\n\tint x2 = s[1].to!int;\n\tint y1 = s[2].to!int;\n\tint y2 = s[3].to!int;\n\tint ans = y1 - y2;\n\tans -= cost[x1][x2] + cost[x2][x1];\n\tans.writeln;\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\n\nconst int V = 21;\nint cost[V][V]; // cost[from][to]\n\nvoid main(){\n\tint n ,m, a, b, c, d;\n\tfor (int i = 0; i < V; i++) {\n\t\tcost[i] = 999999999;\n\t\tcost[i][i] = 0;\n\t}\n\treadf(\"%d\\n\", &n);\n\treadf(\"%d\\n\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\treadf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d);\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = d;\n\t}\n\twarshall_floyd();\n\treadf(\"%d,%d,%d,%d\\n\", &a, &b, &c, &d);\n\twriteln(c - d - cost[a][b] - cost[b][a]);\n}\n\nvoid warshall_floyd(){\n\tfor (int k = 0; k < V; k++)\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}"
  },
  {
    "language": "Python",
    "code": "class Graph():\n\n    from collections import namedtuple\n    __Pair = namedtuple(\"Pair\", \"cost point\")\n\n    def __init__(self, townCount):\n        self.__townCount = townCount\n        self.__adjacencyList = [[] for _ in range(townCount)]\n\n    def GetPath(self, beginPoint, endPoint, cost):\n        item = self.__Pair(cost, endPoint)\n        self.__adjacencyList[beginPoint].append(item)\n\n    def Dijkstra(self, beginPoint):\n\n        from sys import maxsize as MaxValue\n        from queue import PriorityQueue\n        stateTable = {\"NotVisited\": 0, \"Stay\": 1, \"Visited\": 2}\n\n        # 初期化\n        pq = PriorityQueue()\n        costTable = [MaxValue for _ in range(self.__townCount)]\n        visitState = [stateTable[\"NotVisited\"]\n                      for _ in range(self.__townCount)]\n\n        # 処理\n        costTable[beginPoint] = 0\n        pq.put_nowait(self.__Pair(0, beginPoint))\n\n        while not pq.empty():\n\n            minItem = pq.get_nowait()\n            minPoint, minCost = minItem.point, minItem.cost\n\n            visitState[minPoint] = stateTable[\"Visited\"]\n\n            if minCost <= costTable[minPoint]:\n\n                for cost, point in self.__adjacencyList[minPoint]:\n                    if visitState[point] != stateTable[\"Visited\"]:\n\n                        if costTable[minPoint] + cost < costTable[point]:\n                            costTable[point] = costTable[minPoint] + cost\n                            visitState[point] = stateTable[\"Stay\"]\n                            pq.put_nowait(self.__Pair(costTable[point], point))\n\n        return costTable\n\n\n# main process\ntownCount = int(input())\nwayCount = int(input())\n\ngraph = Graph(townCount)\n\nfor lp in range(wayCount):\n    begin, end, cost1, cost2 = [int(item) for item in input().split(\",\")]\n    begin -= 1\n    end -= 1\n    graph.GetPath(begin, end, cost1)\n    graph.GetPath(end, begin, cost2)\n\n\nbeginPoint, endPoint, budget, pillarCost = [\n    int(item) for item in input().split(\",\")]\n\nbeginPoint -= 1\nendPoint -= 1\n\nleaveCost = graph.Dijkstra(beginPoint)\nreturnCost = graph.Dijkstra(endPoint)\n\nresult = budget - pillarCost - leaveCost[endPoint] - returnCost[beginPoint]\n\nprint(result)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nfrom collections import defaultdict\n\nn = int(input())\nm = int(input())\n\n# Map\nM = defaultdict(list)\n\nfor i in range(m):\n    a, b, c, d = list(map(int, input().split(',')))\n    a -= 1\n    b -= 1\n    M[a].append((b, c))\n    M[b].append((a, d))\n\ns, g, V, P = list(map(int, input().split(',')))\ns -= 1\ng -= 1\n\ndef min_dist(Q, dists):\n    min_v = float('inf')\n    min_i = None\n\n    for i in Q:\n        if dists[i] < min_v:\n            min_v = dists[i]\n            min_i = i\n    return min_v, min_i\n\ndef dijkstra(i, j, M):\n    \"\"\"return cost from i to j\"\"\"\n\n    n = len(M)\n    dists = [float('inf')] * n\n    dists[i] = 0\n\n    Q = [i for i in range(n)]\n    while Q:\n        min_dist_index = min_dist(Q, dists)[1]\n        Q.remove(min_dist_index)\n\n        for idx, cost in M[min_dist_index]:\n            if dists[idx] > dists[min_dist_index] + cost:\n                dists[idx] = dists[min_dist_index] + cost\n    return dists[j]\n\nres0 = dijkstra(s, g, M)\nres1 = dijkstra(g, s, M)\n\nprint(V - P - res0 - res1)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nm=int(input())\nl=[]\nfor i in range(m):\n  l1=list(map(int,input().split(\",\")))\n  l.append(l1)\ns,g,v,p=map(int,input().split(\",\"))\nlistl=[[100000 for i in range(n+1)] for i in range(n+1)]\nfor i in l:\n  listl[i[0]][i[1]]=i[2]\n  listl[i[1]][i[0]]=i[3]\nfor i in range(1,n+1):\n  for j in range(1,n+1):\n    for k in range(1,n+1):\n      if listl[j][k]>listl[j][i]+listl[i][k]:\n        listl[j][k]=listl[j][i]+listl[i][k]\nprint(v-p-(listl[s][g]+listl[g][s]))\n"
  },
  {
    "language": "Python",
    "code": "# The question itself is not diffifult, but the website only \n# tested my code with two cases, so I am not sure whether the \n# \"accepted\" is trustworthy.\n\n# Note: math.inf > math.inf -> False\n\nimport math\nV = int(input())\nE = int(input())\nfees = [[math.inf] * V for i in range(V)]\nfor i in range(V): \n\tfees[i][i] = 0\nfor i in range(E):\n\ta, b, c, d = map(int, input().split(','))\n\tfees[a-1][b-1] = c\n\tfees[b-1][a-1] = d\nstart, end, funding, cost = map(int, input().split(','))\nfor i in range(V):\n\tfor j in range(V):\n\t\tfor k in range(V):\n\t\t\tif (fees[j][k] > fees[j][i] + fees[i][k]):\n\t\t\t\tfees[j][k] = fees[j][i] + fees[i][k]\nif (fees[start-1][end-1]==math.inf or fees[end-1][start-1]==math.inf):\n\tprint(0)\nelse:\n\tprint(funding-cost-fees[start-1][end-1]-fees[end-1][start-1])"
  },
  {
    "language": "Python",
    "code": "V = int(input())\nE = int(input())\ndist = [[float('inf')] * V for _ in range(V)]\nfor i in range(V): dist[i][i] = 0\nfor _ in range(E):\n    a, b, c, d = map(int, input().split(','))\n    dist[a-1][b-1], dist[b-1][a-1] = c, d\nfr, to, money, cost = map(int, input().split(','))\nfor k in range(V):\n    for i in range(V):\n        for j in range(V):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\nprint(money-cost-dist[fr-1][to-1]-dist[to-1][fr-1])"
  },
  {
    "language": "Python",
    "code": "\nmachi_number = input()\nroad_number = input()\nmapp = [[10000 for j in range(machi_number)] for i in range(machi_number)]\n\n\nfor i in range(road_number):\n\ta,b,c,d =map(int, raw_input().split(\",\"))\n\taa = a-1\n\tbb = b-1\n\tmapp[aa][bb] = c\n\tmapp[bb][aa] = d\nfor i in range(machi_number):\n\tmapp[i][i] = 0\n\nfor k in range(machi_number):\n\tfor i in range(machi_number):\n\t\tfor j in range(machi_number):\n\t\t\tif mapp[i][j] > (mapp[i][k] + mapp[k][j]):\n\t\t\t\tmapp[i][j] = mapp[i][k] + mapp[k][j]\n\nx1,x2,y1,y2 = map(int, raw_input().split(\",\"))\nprint y1 - y2 - mapp[x1-1][x2-1] - mapp[x2-1][x1-1]"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\nINF = 10 ** 20\n\nn = int(input())\nm = int(input())\n\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b, c, d = map(int, input().split(\",\"))\n    a, b = a - 1, b - 1\n    edges[a].append((b, c))\n    edges[b].append((a, d))\ns, g, v, p = map(int, input().split(\",\"))\ns, g = s - 1, g - 1\n\n\ndef dij(s, g):\n    que = [(0, s)]\n    costs = [INF for _ in range(n)]\n    costs[s] = 0\n    while que:\n        cost, num = pop(que)\n        if num == g:\n            return cost\n        for edge in edges[num]:\n            to, fee = edge\n            if costs[to] > cost + fee:\n                costs[to] = cost + fee\n                push(que, (cost + fee, to))\n\nprint(v - p - dij(s, g) - dij(g, s))\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0117 A reward for a Carpenter\n# Python3 2018.6.21 bal4u\n\nINF = 0x7fffffff\n\nimport heapq\ndef dijkstra(V, to, start, goal):\n\tdist = [INF]*V\n\tQ = []\n\tdist[start] = 0\n\theapq.heappush(Q, (0, start))\n\twhile len(Q):\n\t\tt, s = heapq.heappop(Q)\n\t\tif s == goal: break\n\t\tif dist[s] < t: continue\n\t\tfor i in to[s]:\n\t\t\te, cost = i\n\t\t\tnt = t + cost\n\t\t\tif dist[e] > nt:\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\treturn dist[goal]\n\nn = int(input())+1\nto = [[] for i in range(n)]\nfor i in range(int(input())):\n\ta, b, c, d = list(map(int, input().split(',')))\n\tto[a].append((b, c))\n\tto[b].append((a, d))\ns, g, V, P = list(map(int, input().split(',')))\nif s == g: print(V-P)\nelse: print(V-P - dijkstra(n, to, s, g) - dijkstra(n, to, g, s))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\n\nroads = [[float('inf') for _ in range(n)] for _ in range(n)]\n\nfor _ in range(m):\n    a,b,c,d = map(int, input().split(','))\n    roads[a-1][b-1] = c\n    roads[b-1][a-1] = d\n\ns,g,V,P = map(int, input().split(','))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if roads[i][j] > roads[i][k] + roads[k][j]:\n                roads[i][j] = roads[i][k] + roads[k][j]\n\nprint(V-P-roads[s-1][g-1]-roads[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "inf = 0x101010\ndef solve(start,goal):\n\tcost = [inf]*n\n\tvisited = [False]*n\n\tcost[start] = 0\n\twhile 1:\n\t\tmin = inf\n\t\tnext = -1\n\t\tvisited[start] = True\n\t\tfor i in range(n):\n\t\t\tif visited[i]: continue\n\t\t\tif graph[start][i]:\n\t\t\t\td = cost[start] + graph[start][i]\n\t\t\t\tif d < cost[i]:\n\t\t\t\t\tcost[i] = d\n\t\t\tif min > cost[i]:\n\t\t\t\tmin = cost[i]\n\t\t\t\tnext = i\n\t\tstart = next\n\t\tif next == -1: break\n\treturn cost[goal]\n\nn = input()\nm = input()\ngraph = [[0]*n for i in range(n)]\nfor i in range(m):\n\ta,b,c,d = map(int,raw_input().split(\",\"))\n\tgraph[a-1][b-1] = c\n\tgraph[b-1][a-1] = d\nx1,x2,y1,y2 = map(int,raw_input().split(\",\"))\nprint y1-y2-solve(x1-1,x2-1)-solve(x2-1,x1-1)"
  },
  {
    "language": "Python",
    "code": "def f(x1, x2):\n  W=[[i,1000] for i in range(n)]\n  W[x1]=[x1,0]\n  W[x2]=[x2,2000]\n  G = range(n); G=G[x2:]+G[:x2]\n  while 1:\n    A = sorted([W[e] for e in G], key=lambda x: x[1])\n    p1, w1 = A[0]\n    G.remove(p1)\n    if p1==x2: break\n    for p2, w2 in A[1:]:\n      way=(p1, p2)\n      if way in cost:\n        W[p2] = [p2, min([w2, w1 + cost[(p1,p2)]])]\n  return w1\n\ndef g(): return map(int, raw_input().split(\",\"))\n\nn=int(raw_input())\nm=int(raw_input())\ncost={}\nfor _ in [0]*m:\n  a,b,c,d=g()\n  a-=1\n  b-=1\n  cost[(a,b)]=c\n  cost[(b,a)]=d\nx1,x2,y1,y2=g()\nx1-=1\nx2-=1\nprint y1-y2-f(x1,x2)-f(x2,x1)"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef discomfort(dic, n):\n    global expenses, c\n    if expenses != None and sum(p_res) >= expenses:\n        return\n    if n == c:\n        if n == g_n:\n            c = s_n\n            discomfort(l_dic, g_n)\n            c = g_n\n            return\n        else:\n            expenses = sum(p_res)\n            Pirates.append(r-(sum(p_res)+p))\n            return\n    for v in dic[n]:\n        c_l_dic = copy.deepcopy(dic)\n        c_l_dic[n].remove(v)\n        c_l_dic[v].remove(n)\n        p_res.append(p_dic[(n,v)])\n        load.append(v)\n        discomfort(c_l_dic, v)\n        del p_res[-1]\n        del load[-1]\n\nif __name__ == '__main__':\n    t_c = int(raw_input())\n    \n    l_dic = {}\n    p_dic = {}\n    for i in range(input()):\n        n1, n2, p1, p2 = map(int, raw_input().split(','))\n        if not n1 in l_dic:\n            l_dic[n1] = [n2]\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        else:\n            l_dic[n1].append(n2)\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        p_dic[(n1,n2)] = p1\n        p_dic[(n2,n1)] = p2\n    \n    s_n, g_n, r, p = map(int, raw_input().split(','))\n    c = g_n\n    Pirates = []\n    p_res = []\n    load = [s_n]\n    expenses = None\n    discomfort(l_dic, s_n)\n    print sorted(Pirates)[-1]"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\ndef solve(graph,start,goal,numnodes):\n    que = []\n    heappush(que,(0,start-1))\n    mindists = [float(\"inf\")]*numnodes\n    while que:\n        ccost,cnode = heappop(que)\n        if mindists[cnode] < ccost: continue\n        for nnode,mcost in graph[cnode]:\n            tcost = ccost+mcost\n            if mindists[nnode] > tcost:\n                mindists[nnode] = tcost\n                heappush(que,(tcost,nnode))\n    return mindists[goal-1]\nn = int(input())\nm = int(input())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    a,b,c,d = map(int,input().split(\",\"))\n    graph[a-1].append((b-1,c))\n    graph[b-1].append((a-1,d))\ns,g,V,P = map(int, input().split(\",\"))\nV -= solve(graph,s,g,n)\nV -= P\nV -= solve(graph,g,s,n)\nprint(V)\n"
  },
  {
    "language": "Python",
    "code": "inf=200000\nn=int(input())\nm=int(input())\nadj=[[inf]*(n+1) for i in range(n+1)]\nfor i in range(m):\n  a,b,c,d=map(int,input().split(sep=','))\n  adj[a][b]=c\n  adj[b][a]=d\ns,g,v,p=map(int,input().split(sep=','))\nfor k in range(1,n+1):\n  for i in range(1,n+1):\n    for j in range(1,n+1):\n      adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j])\nans=v-p\nans-=adj[s][g]\nans-=adj[g][s]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra(start,goal,graph):\n\n    INF = 2 << 20\n    node_num = len(graph) \n    visited = [False] * node_num\n    costs = [INF] * node_num\n    pq = []\n    costs[start] = 0\n    heapq.heappush(pq, [0,start])\n    while not len(pq) == 0:\n\n        cur_cost,cur_node = heapq.heappop(pq)\n        if visited[cur_node]:\n            continue\n        if all(visited[1:]):\n            break\n        visited[cur_node] = True\n        costs[cur_node] = cur_cost\n        for i in xrange(node_num):\n            if not visited[i]:\n                heapq.heappush(pq,[graph[cur_node][i] + costs[cur_node],i])\n    return costs[goal]\n\nn = input()\nm = input()\nINF = 2 << 20\ngraph = [[INF] * (n+1) for _ in xrange(n+1)]\nfor _ in xrange(m):\n    a,b,c,d = map(int,raw_input().split(\",\"))\n    graph[a][b] = c\n    graph[b][a] = d\nhome,shop,reward,price = map(int,raw_input().split(\",\"))\ncost = dijkstra(home,shop,graph) + dijkstra(shop,home,graph)\nprint reward - price - cost"
  },
  {
    "language": "Python",
    "code": "def f(x1, x2):\n  W=[[i,1000] for i in range(n)]\n  W[x1]=[x1,0]\n  W[x2]=[x2,2000]\n  G = range(n)\n  while 1:\n    A = sorted([W[e] for e in G], key=lambda x: x[1])\n    p1, w1 = A[0]\n    G.remove(p1)\n    if p1==x2: break\n    for p2, w2 in A[1:]:\n      way=(p1, p2)\n      if way in cost:\n        W[p2] = [p2, min([w2, w1 + cost[way]])]\n  return w1\n\ndef g(): return map(int, raw_input().split(\",\"))\n\nn=int(raw_input())\nm=int(raw_input())\ncost={}\nfor _ in [0]*m:\n  a,b,c,d=g()\n  a-=1\n  b-=1\n  cost[(a,b)]=c\n  cost[(b,a)]=d\nx1,x2,y1,y2=g()\nx1-=1\nx2-=1\nprint y1-y2-f(x1,x2)-f(x2,x1)"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef discomfort(dic, n):\n    global expenses\n    if expenses != None and sum(p_res) >= expenses:\n        return\n    if n == s_n and g_n in load:\n        expenses = sum(p_res)\n        Pirates.append(r-(sum(p_res)+p))\n        return\n    for v in dic[n]:\n        c_l_dic = copy.deepcopy(dic)\n        c_l_dic[n].remove(v)\n        c_l_dic[v].remove(n)\n        p_res.append(p_dic[(n,v)])\n        load.append(v)\n        discomfort(c_l_dic, v)\n        del p_res[-1]\n        del load[-1]\n\nif __name__ == '__main__':\n    t_c = int(raw_input())\n    \n    l_dic = {}\n    p_dic = {}\n    for i in range(input()):\n        n1, n2, p1, p2 = map(int, raw_input().split(','))\n        if not n1 in l_dic:\n            l_dic[n1] = [n2]\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        else:\n            l_dic[n1].append(n2)\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        p_dic[(n1,n2)] = p1\n        p_dic[(n2,n1)] = p2\n    \n    s_n, g_n, r, p = map(int, raw_input().split(','))\n    p_res = []\n    load = [s_n]\n    expenses = None\n    Pirates = []\n    discomfort(l_dic, s_n)\n    print sorted(Pirates)[-1]"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\n\ndp = [[float('inf') for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    dp[i][i] = 0\n\nfor _ in range(m):\n    a, b, c, d = map(int, input().split(','))\n    dp[a - 1][b - 1] = c\n    dp[b - 1][a - 1] = d\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\ns, g, v, p = map(int, input().split(','))\n\nprint(v - p - dp[s-1][g-1] - dp[g-1][s-1])\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef warshallFloyd(V, dp):\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\n\ndef main(args):\n    n = int(input())\n    m = int(input())\n    dp = [[float('inf')]*(n+1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][i] = 0\n    for _ in range(m):\n        a, b, c, d = [int(x) for x in input().split(',')]\n        dp[a][b] = c\n        dp[b][a] = d\n    s, g, V, P = [int(x) for x in input().split(',')]\n    # print(dp)\n    warshallFloyd(n+1, dp)\n    # print(dp)\n\n    print(V - dp[s][g] - dp[g][s] - P)\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0117: A reward for a Carpenter\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n# -----------------------------------------------------------------------\n# Defining directed graph class: \n# -----------------------------------------------------------------------\n\nclass DirectedGraph:\n    \"\"\"An DirectedGraph g contains a dictionary (g.neighbor_dict) which\n    maps node identifiers (keys) to lists of neighboring nodes (values).\n    g.neighbor_dict[node] returns a list [node2, node3, node4] of neighbors.\n    Node identifiers can be any non-mutable Python type (e.g., integers,\n    tuples, strings, but not lists).\"\"\"\n\n    def __init__(self):\n        \"\"\" UndirectedGraph() creates an empty graph g.\n        g.neighbor_dict starts as an empty dictionary.  When nodes are\n        added, the corresponding values need to be inserted into lists.\"\"\"\n        self.neighbor_dict = {}\n        self.explored_dict = {}\n\n \n    def HasNode(self, node):\n        \"\"\"Does not use the dict.keys() method, which would generate a \n        new list of all nodes each time this is called.\"\"\"\n        return node in self.neighbor_dict\n\n    def AddNode(self, node):\n        \"\"\" Uses HasNode(node) to determine if node has already been added.\n            Optional argument position is for later drawing. Positions are\n            in range [0.0, 1.0] and represent fractions of drawing window size.\n            Color is also for drawing.\n        \"\"\"\n        if( self.HasNode(node) ):\n            return\n        self.neighbor_dict[node] = []\n        self.explored_dict[node] = False\n        \n    def AddEdge(self, node1, node2, length):\n        \"\"\"\n    Add node1 and node2 to network first if necessary.\n    Adds new edge node1 -> node2 with length 'length'\n    \"\"\"\n        if( not self.HasNode(node1) ):\n            self.AddNode(node1)\n        if( not self.HasNode(node2) ):\n            self.AddNode(node2)\n        neighbors = self.neighbor_dict[node1]\n        neighbors.append((node2, length))\n        self.neighbor_dict[node1] = neighbors\n\n\n    def GetExplored(self, node):\n        \"\"\" Get explorationn status of node \"\"\"\n        return self.explored_dict[node]\n        \n\n    def GetNextUnexploredNeighbor(self, node):\n        \"\"\" Get a neighbor node which is still unexplored. If none exists,\n            return -1 \"\"\"\n        for neighbor in self.GetNeighbors(node):\n            if( not self.GetExplored(neighbor) ):\n                return neighbor\n        return -1\n        \n    def SetExplored(self, node, value):\n        \"\"\" Mark node as explored \"\"\"\n        self.explored_dict[node] = value\n        \n    def GetNodes(self):\n        \"\"\"g.GetNodes() returns all nodes (keys) in neighbor_dict\"\"\"\n        return self.neighbor_dict.keys()\n\n    def GetNeighbors(self, node):\n        \"\"\"g.GetNeighbors(node) returns a copy of the list of neighbors of\n        the specified node.  A copy is returned (using the [:] operator) so\n        that the user does not inadvertently change the neighbor list.\"\"\"\n        result = []\n        for neighbor in self.neighbor_dict[node]:\n            result.append(neighbor[0])\n        return result\n\n\n    def GetEdgeLength(self, node1, node2):\n        \"\"\" Get length of edge from node1 to node2 \"\"\"\n        result = 9999999999999999\n        neighbors = self.neighbor_dict[node1]\n        #print neighbors\n        for neighbor in neighbors:\n            if( neighbor[0] == node2 ):\n                return neighbor[1]\n        return result\n\n    \n    def GetNumExploredNodes(self):\n        \"\"\" Return number of explored nodes \"\"\"\n        num = 0\n        for key, value in self.explored_dict.items():\n            if( value ): num += 1\n        return num\n\n    \n    #def GetPosition(self, node):\n    #    \"\"\" Returns drawing position of node\n    #    \"\"\"\n    #    return self.positions[node]\n    \n    #def SetColor(self, node, color):\n    #    \"\"\" Returns color of node\n    #    \"\"\"\n    #    self.colors[node] = color\n    \n    #def GetColor(self, node):\n    #    \"\"\" Returns color of node\n    #    \"\"\"\n    #    return self.colors[node]\n    \n    def GetDegree(self, node):\n        \"\"\" Returns degree of node, i.e. number of edges connected to it\n        \"\"\"\n        return len(self.GetNeighbors(node))\n    \n    def GetOrderedDegrees(self):\n        \"\"\" Returns list of nodes, ordered by degree\n        \"\"\"\n        result = []\n        nodes = self.GetNodes()\n        for node in nodes:\n            result.append((node, self.GetDegree(node)))\n        return sorted(result, key=lambda result: result[1], reverse=True)\n\n    def GetAllEdges(self):\n        \"\"\" Returns list of all edges\n        \"\"\"\n        result = []\n        nodes = self.GetNodes()\n        for node in nodes:\n            neighbors = self.GetNeighbors(node)\n            for neighbor in neighbors:\n                result.append((node, neighbor))\n        return result\n\n\ndef dijkstra(graph, s):\n    \"\"\" Implement 'naive' Dijktstra's algorithm (no heaps) for graph 'graph'\n        and start vertex s \"\"\"\n    n = len(graph.GetNodes())\n    #print \"Dijkstra: # nodes =\", n\n    X = [s]      # vertices processed so far\n    A = {}      # computed shortest path distances\n    A[s] = 0    # distance of start vertex to itself\n\n    # main loop:\n    while( len(A) < n ):\n        dijkstra_greedy = 999999999999999999999\n        v_star = -1\n        w_star = -1\n        for v in X:\n            for w in graph.GetNeighbors(v):\n                if( w not in X ):\n                    current_dist = A[v] + graph.GetEdgeLength(v, w)\n                    if( current_dist < dijkstra_greedy ):\n                        v_star = v\n                        w_star = w\n                        dijkstra_greedy = current_dist\n        X.append(w_star)\n        A[w_star] = dijkstra_greedy\n    # set default distances for unvisited nodes:\n    for node in graph.GetNodes():\n        if( node not in A.keys() ):\n            A[node] = 1000000\n    return A                \n\nG = DirectedGraph()\nn = int(input())\nfor city in range(1, n + 1):\n    G.AddNode(city)\nm = int(input())\nfor road in range(m):\n    city1, city2, cost1, cost2 = [int(_) for _ in input().split(',')]\n    G.AddEdge(city1, city2, cost1)\n    G.AddEdge(city2, city1, cost2)\nsource, target, money, price = [int(_) for _ in input().split(',')]\nd = dijkstra(G, source)\ncost1 = d[target]\nd = dijkstra(G, target)\ncost2 = d[source]\nprint(money - price - cost1 - cost2)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\nmat = [[float(\"inf\")]*n for _ in [0]*n]\nfor a,b,c,d in((map(int, input().split(\",\"))) for _ in [0]*m):\n    mat[a-1][b-1] = c\n    mat[b-1][a-1] = d\ns,g,v,p = map(int, input().split(\",\"))\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = min(mat[i][j], mat[i][k]+mat[k][j])\nprint(v-p-mat[s-1][g-1]-mat[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef discomfort(dic, n):\n    global expenses\n    if expenses != None and sum(p_res) >= expenses:\n        return\n    if n == s_n and g_n in load:\n        expenses = sum(p_res)\n        Pirates.append(r-(sum(p_res)+p))\n        return\n    for v in dic[n]:\n        p_res.append(p_dic[(n,v)])\n        c_l_dic = copy.deepcopy(dic)\n        c_l_dic[n].remove(v)\n        c_l_dic[v].remove(n)\n        load.append(v)\n        discomfort(c_l_dic, v)\n        del p_res[-1]\n        del load[-1]\n\nif __name__ == '__main__':\n    t_c = int(raw_input())\n    \n    l_dic = {}\n    p_dic = {}\n    for i in range(input()):\n        n1, n2, p1, p2 = map(int, raw_input().split(','))\n        if not n1 in l_dic:\n            l_dic[n1] = [n2]\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        else:\n            l_dic[n1].append(n2)\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        p_dic[(n1,n2)] = p1\n        p_dic[(n2,n1)] = p2\n    \n    s_n, g_n, r, p = map(int, raw_input().split(','))\n    p_res = []\n    load = [2]\n    expenses = None\n    Pirates = []\n    discomfort(l_dic, s_n)\n    print sorted(Pirates)[-1]"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\ninf = 1001001001\nroute = [[inf for _ in range(n)] for __ in range(n)]\nfor _ in range(m):\n    a, b, c, d = map(int, input().split(','))\n    route[a-1][b-1] = c\n    route[b-1][a-1] = d\ns, g, V, P = map(int, input().split(','))\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if route[i][j] > route[i][k] + route[k][j]:\n                route[i][j] = route[i][k] + route[k][j]\nprint(int(V - P - route[s-1][g-1] - route[g-1][s-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "# The question itself is not diffifult, but the website only \n# tested my code with two cases, so I am not sure whether the \n# \"accepted\" is trustworthy.\n\n# Note: math.inf > math.inf -> False\n\nimport math\nV = int(input())\nE = int(input())\nfees = [[math.inf] * V for i in range(V)]\nfor i in range(V): \n\tfees[i][i] = 0\nfor i in range(E):\n\ta, b, c, d = map(int, input().split(','))\n\tfees[a-1][b-1] = c\n\tfees[b-1][a-1] = d\nstart, end, funding, cost = map(int, input().split(','))\nfor i in range(V):\n\tfor j in range(V):\n\t\tfor k in range(V):\n\t\t\tif (fees[j][k] > fees[j][i] + fees[i][k]):\n\t\t\t\tfees[j][k] = fees[j][i] + fees[i][k]\nif (fees[start-1][end-1]==math.inf or fees[end-1][start-1]==math.inf):\n\tprint(0)\nelse:\n\tprint(funding-cost-fees[start-1][end-1]-fees[end-1][start-1])"
  },
  {
    "language": "Python",
    "code": "http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117\n\nINF = 1e12\n\n\ndef dijkstra(graph, source):\n    lg = len(graph)\n    unused = list(range(lg))\n    d = [INF] * (lg)\n    d[source] = 0\n\n    while unused:\n        v = min(unused, key=lambda u: d[u])\n        unused.remove(v)\n        for u in range(n + 1):\n            d[u] = min(d[u], d[v] + graph[v][u])\n\n    return d\n\nn = int(input())\nm = int(input())\n\ncost = [[INF] * (n + 1) for i in range(n + 1)]\nfor i in range(m):\n    ai, bi, ci, di = map(int, input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = map(int, input().split(','))\n\nd_go = dijkstra(cost, x1)[x2]\nd_back = dijkstra(cost, x2)[x1]\n\nprint(y1 - y2 - d_go - d_back)"
  },
  {
    "language": "Python",
    "code": "def floyd(P,m):\n    for k in range(m):\n        for i in range(m):\n            for j in range(m):\n                P[i][j]=min(P[i][j],P[i][k]+P[k][j])\n\nn=input()\nm=input()\nINF=1e10\nC=[[INF]*n for i in range(n)]\nfor i in range(n):\n    C[i][i]=0\nfor i in range(m):\n    a1,b1,c1,d1=map(int,raw_input().split(\",\"))\n    C[a1-1][b1-1]=c1\n    C[b1-1][a1-1]=d1\nfloyd(C,n)\nx1,x2,y1,y2=map(int,raw_input().split(\",\"))\nprint y1-y2-C[x1-1][x2-1]-C[x2-1][x1-1]"
  },
  {
    "language": "Python",
    "code": "#dijkstra\n\nfrom heapq import heappop as pop\nfrom heapq import heappush as push\n\nINF = 10 ** 20\n\nn = int(input())\nm = int(input())\n\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n  a, b, c, d = map(int, input().split(\",\"))\n  a, b = a - 1, b - 1\n  edges[a].append((b, c))\n  edges[b].append((a, d))\n\ns, g, v, p = map(int, input().split(\",\"))\ns, g = s - 1, g - 1\n\ndef dij(s, g):\n  que = [(0, s)]\n  costs = [INF for _ in range(n)]\n  costs[s] = 0\n  \n  while que:\n    cost, num = pop(que)\n    if num == g:\n      return cost\n    for edge in edges[num]:\n      to, fee = edge\n      if costs[to] > cost + fee:\n        costs[to] = cost + fee\n        push(que, (cost + fee, to))\n\nprint(v - p - dij(s, g) - dij(g, s))\n"
  },
  {
    "language": "Python",
    "code": "n= int(input())\nm=int(input())\ninf=1001001001\ndata =[[inf]*n for i in range(n)]\n\nfor i in range(m):\n    a,b,c,d= map(int,input().split(\",\"))\n    data[a-1][b-1]= c\n    data[b-1][a-1]= d\ns,g,V,P = map(int,input().split(\",\"))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if data[i][j]>data[i][k]+data[k][j]:\n                data[i][j]= data[i][k]+data[k][j]\n                \nprint(V-P-data[s-1][g-1]-data[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0117 A reward for a Carpenter\n# Python3 2018.6.21 bal4u\n\nINF = 0x7fffffff\n\nimport heapq\ndef dijkstra(V, to, start, goal):\n\tdist = [INF]*V\n\tQ = []\n\tdist[start] = 0\n\theapq.heappush(Q, (0, start))\n\twhile len(Q):\n\t\tt, s = heapq.heappop(Q)\n\t\tif s == goal: break\n\t\tif dist[s] < t: continue\n\t\tfor i in to[s]:\n\t\t\te, cost = i\n\t\t\tnt = t + cost\n\t\t\tif dist[e] > nt:\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\treturn dist[goal]\n\nn = int(input())+1\nto = [[] for i in range(n)]\nfor i in range(int(input())):\n\ta, b, c, d = list(map(int, input().split(',')))\n\tto[a].append((b, c))\n\tto[b].append((a, d))\ns, g, V, P = list(map(int, input().split(',')))\nif s == g: print(V-P)\nelse: print(V-P - dijkstra(n, to, s, g) - dijkstra(n, to, g, s))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    N = int(input())\n    M = int(input())\n    dist = [[INF]*N for _ in range(N)]\n    for _ in range(M):\n        a,b,c,d = map(int,input().split(','))\n        a -= 1\n        b -= 1\n        dist[a][b] = c\n        dist[b][a] = d\n    s,g,v,p = map(int,input().split(','))\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dist[i][j] = min(dist[i][k] + dist[k][j],dist[i][j])\n    s -= 1\n    g -= 1\n    ans = v - dist[s][g] - dist[g][s] - p\n    print(ans)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef discomfort(dic, n):\n    global Pirates, expenses, c\n    if expenses != None and sum(p_res) >= expenses:\n        return\n    if n == c:\n        if n == g_n:\n            c = s_n\n            discomfort(l_dic, g_n)\n            c = g_n\n            return\n        else:\n            expenses = sum(p_res)\n            Pirates = r-(sum(p_res)+p)\n            return\n    for v in dic[n]:\n        c_l_dic = copy.deepcopy(dic)\n        c_l_dic[n].remove(v)\n        c_l_dic[v].remove(n)\n        p_res.append(p_dic[(n,v)])\n        load.append(v)\n        discomfort(c_l_dic, v)\n        del p_res[-1]\n        del load[-1]\n\nif __name__ == '__main__':\n    t_c = int(raw_input())\n    \n    l_dic = {}\n    p_dic = {}\n    for i in range(input()):\n        n1, n2, p1, p2 = map(int, raw_input().split(','))\n        if not n1 in l_dic:\n            l_dic[n1] = [n2]\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        else:\n            l_dic[n1].append(n2)\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        p_dic[(n1,n2)] = p1\n        p_dic[(n2,n1)] = p2\n    \n    s_n, g_n, r, p = map(int, raw_input().split(','))\n    c = g_n\n    Pirates = 0\n    p_res = []\n    load = [s_n]\n    expenses = None\n    discomfort(l_dic, s_n)\n    print Pirates"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\ncost = []\nfor i in range(n):\n    t = [float('inf')]*n\n    t[i] = 0\n    cost.append(t)\nfor i in range(m):\n    s = input()\n    s += ','\n    L = []\n    z = ''\n    for j in range(len(s)):\n        if s[j] != ',':\n            z += s[j]\n        else:\n            L.append(int(z))\n            z = ''\n    a,b,c,d = L[0],L[1],L[2],L[3]\n    cost[a-1][b-1] = c\n    cost[b-1][a-1] = d\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if cost[i][j] > cost[i][k]+cost[k][j]:\n                cost[i][j] = cost[i][k]+cost[k][j]\ns = input()\ns += ','\nL = []\nz = ''\nfor j in range(len(s)):\n    if s[j] != ',':\n        z += s[j]\n    else:\n        L.append(int(z))\n        z = ''\ns,g,v,p = L[0],L[1],L[2],L[3]\nprint(v-p-cost[s-1][g-1]-cost[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ndef solve():\n    N = int(input())\n    M = int(input())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b, c, d = map(int, input().split(\",\"))\n        G[a-1].append((b-1, c))\n        G[b-1].append((a-1, d))\n    s, g, V, P = map(int, input().split(\",\"))\n    INF = 10**18\n    def calc(s, g):\n        dist = [INF]*N\n        dist[s] = 0\n        que = [(0, s)]\n        while que:\n            cost, v = heappop(que)\n            if dist[v] < cost:\n                continue\n            for w, d in G[v]:\n                if cost + d < dist[w]:\n                    dist[w] = cost + d\n                    heappush(que, (cost + d, w))\n        return dist[g]\n    s -= 1; g -= 1\n    print(max(0, V - (calc(s, g) + calc(g, s)) - P))\nsolve()\n\n"
  },
  {
    "language": "Python",
    "code": "INF = 1000000\n\n\ndef bellman_ford(graph, source):\n    lg = len(graph)\n    unused = list(range(lg))\n    d = [INF] * (lg)\n    d[source] = 0\n\n    while unused:\n        v = min(unused, key=lambda u: d[u])\n        unused.remove(v)\n        for u in range(n + 1):\n            d[u] = min(d[u], d[v] + graph[v][u])\n\n    return d\n\nn = int(input())\nm = int(input())\n\ncost = [[INF] * (n + 1) for i in range(n + 1)]\nfor i in range(m):\n    ai, bi, ci, di = map(int, input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = map(int, input().split(','))\n\nd_go = bellman_ford(cost, x1)[x2]\nd_back = bellman_ford(cost, x2)[x1]\n\nprint(y1 - y2 - d_go - d_back)"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra(start,goal,graph):\n\n    INF = 2 << 20\n    node_num = len(graph) \n    visited = [False] * node_num\n    costs = [INF] * node_num\n    pq = []\n    costs[start] = 0\n    #print costs[start]\n    heapq.heappush(pq, [0,start])\n    \n    while not len(pq) == 0:\n        cur_cost,cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n        if all(visited[1:]):\n            break\n\n        #print cur_cost,cur_node\n\n        visited[cur_node] = True\n        costs[cur_node] = cur_cost\n        #print costs\n        \n        for i in xrange(node_num):\n            if not visited[i]:\n                heapq.heappush(pq,[graph[cur_node][i] + costs[cur_node],i])\n    return costs[goal]\n\nn = input()\nm = input()\nINF = 2 << 20\ngraph = [[INF] * (n+1) for _ in xrange(n+1)]\nfor _ in xrange(m):\n    a,b,c,d = map(int,raw_input().split(\",\"))\n    #graph[from][to] = cost\n    graph[a][b] = c\n    graph[b][a] = d\nhome,shop,reward,price = map(int,raw_input().split(\",\"))\ngraph[home][home] = 0\ncost = dijkstra(home,shop,graph)\ngraph[home][home] = INF\ngraph[shop][shop] = 0\ncost += dijkstra(shop,home,graph)\nprint reward - price - cost"
  },
  {
    "language": "Python",
    "code": "class Highway(object):\n    def __init__(self, a = 0, b = 0, c = 0, d = 0):\n        if isinstance(a,list):\n            d = a[3]\n            c = a[2]\n            b = a[1]\n            a = a[0]\n        self.root = [int(a),int(b)]\n        self.atob = int(c)\n        self.btoa = int(d)\n\n    def getRoot(self):\n        return self.root\n\n    def hasTown(self, n):\n        if (self.root[0] is n) or (self.root[1] is n):\n            return True\n        else:\n            return False\n\n    def getNextAndCost(self, n):\n        if self.root[0] is n:\n            return [self.root[1], self.atob]\n        elif self.root[1] is n:\n            return [self.root[0], self.btoa]\n        else:\n            return [-1,-1]\n\n\nclass Town(object):\n    def __init__(self, town = -1, highwayList = []):\n        self.town = town\n        self.path = []\n        self.cost = -1\n        self.done = False\n\n        for n in highwayList:\n            if n.hasTown(town):\n                self.path.append(n.getNextAndCost(town))\n\n    def __str__(self):\n        text = \"Town: \" + str(self.town) + \"\\nCost: \" + str(self.cost) + \"\\n\"\n        \n        for i in self.path:\n            text += \"\\tNext: \" + str(i[0]) + \" | Cost: \" + str(i[1]) + \"\\n\" \n        return  text\n\n    def getTown(self):\n        return self.town\n\n    def getPath(self):\n        return self.path\n\n    def hasDone(self):\n        return self.done\n\n    def reset(self):\n        self.cost = -1\n        self.done = False\n\n    def setCost(self, cost):\n        self.cost = cost\n\n    def getCost(self):\n        return self.cost\n\n    def decision(self):\n        self.done = True\n\n        \nclass Towns(object):\n    def __init__(self, townN = 0, highway = []):\n        self.townList = []\n        for i in xrange(townN):\n            self.townList.append(Town(i+1, highwayList))\n        \n    def __str__(self):\n        text = \"\"\n        for town in self.townList:\n            text += str(town) \n        return text\n\n    def getTown(self, n):\n        for town in self.townList:\n            if town.getTown() is n:\n                return town\n        return Town()\n\n    def resetAll(self):\n        for t in self.townList:\n            t.reset()\n\n    def trace(self, start, goal):\n        self.resetAll()\n        self.getTown(start).setCost(0)\n        while True:\n            doneTown = Town()\n            for town in self.townList:\n                if town.hasDone() or town.getCost() < 0:\n                    continue\n                if doneTown.getTown() == -1 or town.getCost() < doneTown.getCost():\n                    doneTown = town\n\n            if doneTown.getTown() == -1:\n                break\n            \n            doneTown.decision()\n            for p in doneTown.getPath():\n                to = p[0]\n\n                cost = doneTown.getCost() + p[1]\n                if self.getTown(to).getCost() < 0 or cost < self.getTown(to).getCost():\n                    self.getTown(to).setCost(cost)\n\n        return self.getTown(goal).getCost()\n\ntownN = int(raw_input())\nhighwayN = int(raw_input())\nhighwayList = []\n\nfor i in xrange(highwayN):\n    tmp = [int(h) for h in raw_input().split(\",\")]\n    highwayList.append(Highway(tmp))\n\ncarpenter = [int(n) for n in raw_input().split(\",\")]\n\ntowns = Towns(townN,highwayList)\n\ncost = towns.trace(carpenter[0], carpenter[1]) + towns.trace(carpenter[1], carpenter[0])\n\nprint carpenter[2] - carpenter[3] -cost"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\nMap = [[1001]*n for _ in range(n)]\nfor _ in range(m):\n    a,b,c,d = map(int,input().split(\",\"))\n    Map[a-1][b-1] = c\n    Map[b-1][a-1] = d\ns,g,V,P = map(int,input().split(\",\"))\n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if Map[i][j] > Map[i][k]+Map[k][j]:\n                Map[i][j] = Map[i][k]+Map[k][j]\n\nprint(V-P-Map[s-1][g-1]-Map[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117\nAC\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\ndef warshallFloyd(V, dp):\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                if dp[i][k] + dp[k][j] < dp[i][j]:\n                    dp[i][j] = dp[i][k] + dp[k][j]\n\n\ndef main(args):\n    n = int(input())\n    m = int(input())\n    dp = [[float('inf')]*(n) for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n    for _ in range(m):\n        a, b, c, d = [int(x) for x in input().split(',')]\n        dp[a-1][b-1] = c\n        dp[b-1][a-1] = d\n    s, g, V, P = [int(x) for x in input().split(',')]\n\n    warshallFloyd(n, dp)\n\n    print(V - dp[s-1][g-1] - dp[g-1][s-1] - P)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def f(x1, x2):\n  W = [[i, 1001] for i in range(n)]\n  W[x1] = [x1, 0]\n  W[x2] = [x2, 2000]\n  G = range(n)\n  while 1:\n    A = sorted([W[e] for e in G], key = lambda x:x[1])\n    p1, w1 = A[0]\n    G.remove(p1)\n    if p1 == x2: break\n    for p2, w2 in A[1:]:\n      way=(p1, p2)\n      if way in cost:\n        W[p2] = [p2, min([w2, w1+cost[way]])]\n  return W[x2][1]\ndef g(): return map(int, raw_input().split(\",\"))\n\nn = int(raw_input())\nm = int(raw_input())\ncost = {}\nfor _ in [0] * m:\n  a, b, c, d = g()\n  cost[(a-1, b-1)] = c\n  cost[(b-1, a-1)] = d\nx1, x2, y1, y2 = g()\nx1 -= 1\nx2 -= 1\nprint y1-y2-f(x1,x2)-f(x2,x1)"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra(start,goal,graph):\n\n    INF = 2 << 20\n    node_num = len(graph) \n    visited = [False] * node_num\n    costs = [INF] * node_num\n    pq = []\n    costs[start] = 0\n    #print costs[start]\n    heapq.heappush(pq, [0,start])\n    \n    while not len(pq) == 0:\n        cur_cost,cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n        if all(visited[1:]):\n            break\n\n        #print cur_cost,cur_node\n\n        visited[cur_node] = True\n        costs[cur_node] = cur_cost\n        #print costs\n        \n        for i in xrange(node_num):\n            if not visited[i]:\n                heapq.heappush(pq,[graph[cur_node][i] + costs[cur_node],i])\n    return costs[goal]\n\nn = input()\nm = input()\nINF = 2 << 20\ngraph = [[INF] * (n+1) for _ in xrange(n+1)]\nfor _ in xrange(m):\n    a,b,c,d = map(int,raw_input().split(\",\"))\n    #graph[from][to] = cost\n    graph[a][b] = c\n    graph[b][a] = d\nhome,shop,reward,price = map(int,raw_input().split(\",\"))\ncost = dijkstra(home,shop,graph) + dijkstra(shop,home,graph)\nprint reward - price - cost"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef discomfort(dic, n):\n    global expenses\n    if expenses != None and sum(p_res) >= expenses:\n        return\n    if n == s_n and g_n in load:\n        expenses = sum(p_res)\n        Pirates.append(r-(sum(p_res)+p))\n        return\n    for v in dic[n]:\n        p_res.append(p_dic[(n,v)])\n        c_l_dic = copy.deepcopy(dic)\n        c_l_dic[n].remove(v)\n        c_l_dic[v].remove(n)\n        load.append(v)\n        discomfort(c_l_dic, v)\n        del p_res[-1]\n        del load[-1]\n\nif __name__ == '__main__':\n    l_dic = {}\n    p_dic = {}\n    for line in open('s.txt').readlines():\n        n1, n2, p1, p2 = map(int, line.rstrip().split(','))\n        if not n1 in l_dic:\n            l_dic[n1] = [n2]\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        else:\n            l_dic[n1].append(n2)\n            if not n2 in l_dic:\n                l_dic[n2] = [n1]\n            else:\n                l_dic[n2].append(n1)\n        p_dic[(n1,n2)] = p1\n        p_dic[(n2,n1)] = p2\n    \n    s_n, g_n, r, p = map(int, raw_input().split(','))\n    p_res = []\n    load = [2]\n    expenses = None\n    Pirates = []\n    discomfort(l_dic, s_n)\n    print sorted(Pirates)[-1]"
  },
  {
    "language": "Python",
    "code": "import sys\nn = int(input())\nm = int(input())\ncost = [[float(\"inf\")] * n for _ in range(n)]\nfor _ in range(m):\n    a, b, c, d = map(int, sys.stdin.readline().split(\",\"))\n    cost[a - 1][b - 1] = c\n    cost[b - 1][a - 1] = d\ns, g, V, P = map(int, sys.stdin.readline().split(\",\"))\n\nfor k in range(n):\n    for i in range(n):\n        c_ik = cost[i][k]\n        for j, (c_kj, c_ij) in enumerate(zip(cost[k], cost[i])):\n            temp = c_ik + c_kj\n            if c_ij > temp:\n                cost[i][j] = temp\n\nprint(V - P - cost[s - 1][g - 1] - cost[g - 1][s - 1])\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\ncost=[[float('inf')]*n for _ in range(n)]\nm=int(input())\nfor _ in range(m):\n    a,b,c,d=map(int,input().split(','))\n    cost[a-1][b-1]=c\n    cost[b-1][a-1]=d\ns,g,V,P=map(int,input().split(','))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if cost[i][j] > cost[i][k] + cost[k][j]:\n                cost[i][j] = cost[i][k] + cost[k][j]\n\nprint(V-P-cost[s-1][g-1]-cost[g-1][s-1])\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\nK = [[float('inf') for i in range(n)] for j in range(n)]\n#print(K)\nfor i in range(m):\n    a,b,c,d = map(int,input().split(','))\n    #print(a,b,c,d)\n    K[a-1][b-1] = c\n    K[b-1][a-1] = d\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if K[i][j] > K[i][k]+K[k][j]:\n                K[i][j] = K[i][k]+K[k][j]\n    #print(K)\ns,g,V,P = map(int,input().split(','))\nprint(V-P-K[s-1][g-1]-K[g-1][s-1])\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0117 A reward for a Carpenter\n# Python3 2018.6.21 bal4u\n\nINF = 0x7fffffff\n\nimport heapq\ndef dijkstra(V, to, start, goal):\n\tdist = [INF]*V\n\tQ = []\n\tdist[start] = 0\n\theapq.heappush(Q, (0, start))\n\twhile len(Q):\n\t\tt, s = heapq.heappop(Q)\n\t\tif s == goal: break\n\t\tif dist[s] <= t: continue\n\t\tfor i in to[s]:\n\t\t\te, cost = i\n\t\t\tnt = t + cost\n\t\t\tif dist[e] > nt:\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\treturn dist[goal]\n\nn = int(input())+1\nto = [[] for i in range(n)]\nfor i in range(int(input())):\n\ta, b, c, d = list(map(int, input().split(',')))\n\tto[a].append((b, c))\n\tto[b].append((a, d))\ns, g, V, P = list(map(int, input().split(',')))\nif s == g: print(V-P)\nelse: print(V-P - dijkstra(n, to, s, g) - dijkstra(n, to, g, s))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef dijkstra(nodes, start, goal, matrix):\n  defnode = [False] * (nodes+1)\n  cost = [sys.maxint] * (nodes+1)\n  cost[start] = 0\n  node = start\n  while True:\n    defnode[node] = True\n    for i in xrange(1, nodes+1):\n      if defnode[i]:\n        continue\n      if matrix[node][i] == sys.maxint:\n        continue\n      cost[i] = min(cost[i], cost[node]+matrix[node][i])\n    minnode = sys.maxint\n    mincost = sys.maxint\n    for i in xrange(1, nodes+1):\n      if defnode[i]:\n        continue\n      if cost[i] < mincost:\n        minnode = i\n        mincost = cost[i]\n    if minnode == goal:\n      return cost[goal]\n    node = minnode\n\nn = int(raw_input())\nm = int(raw_input())\nmatrix = [[sys.maxint]*(n+1) for i in xrange(n+1)]\nfor i in xrange(m):\n  a, b, c, d = map(int, raw_input().split(\",\"))\n  matrix[a][b] = c\n  matrix[b][a] = d\ns, g, V, P = map(int, raw_input().split(\",\"))\nanswer = V - P - dijkstra(n, s, g, matrix) - dijkstra(n, g, s, matrix)\nprint answer"
  },
  {
    "language": "Python",
    "code": "INF = 10000000\n\nn = int(input())\nm = int(input())\n\ntable = [[-1 for i in range(n)] for j in range(n)]\nvisited = [False for i in range(n)]\ncost = [INF for i in range(n)]\n\nfor l in range(m):\n    a,b,c,d = [int(i) for i in input().split(\",\")]\n    table[a-1][b-1] = c\n    table[b-1][a-1] = d\n\ns,g,V,P = [int(i) for i in input().split(\",\")]\n\nvisited[s-1] = True\ncost[s-1] = 0\ncnt = n-1\nwhile cnt > 0:\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if table[i][j] > 0 and visited[j] == False:\n                    cost[j] = cost[i] + min(table[i][j], cost[j])\n                    visited[j] = True\n                    cnt -= 1\n\nans = cost[g-1]\n\nfor i in range(n):\n    cost[i] = INF\n    visited[i] = False\n\nvisited[g-1] = True\ncost[g-1] = 0\ncnt = n-1\n\nwhile cnt > 0:\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if table[i][j] > 0 and visited[j] == False:\n                    cost[j] = cost[i] + min(table[i][j], cost[j])\n                    visited[j] = True\n                    cnt -= 1\n\nans += cost[s-1]\n\nprint(V-P-ans)\n"
  },
  {
    "language": "Python",
    "code": "INF = 1e12\n\n\ndef dijkstra(graph, source):\n    lg = len(graph)\n    unused = list(range(lg))\n    d = [INF] * (lg)\n    d[source] = 0\n\n    while unused:\n        v = min(unused, key=lambda u: d[u])\n        unused.remove(v)\n        for u in range(n + 1):\n            d[u] = min(d[u], d[v] + graph[v][u])\n\n    return d\n\nn = int(input())\nm = int(input())\n\ncost = [[INF] * (n + 1) for i in range(n + 1)]\nfor i in range(m):\n    ai, bi, ci, di = map(int, input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = map(int, input().split(','))\n\nd_go = dijkstra(cost, x1)[x2]\nd_back = dijkstra(cost, x2)[x1]\n\nprint(y1 - y2 - d_go - d_back)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn = int(input())\nm = int(input())\nroad = np.full((n, n), np.inf)\nfor i in range(m):\n    r_in = list(map(int, input().split(\",\")))\n    road[r_in[0]-1, r_in[1]-1] = r_in[2]\n    road[r_in[1]-1, r_in[0]-1] = r_in[3]\ns, g, v, p = map(int, input().split(\",\"))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                road[i, j] = 0\n            else:\n                road[i, j] = min(road[i, j], road[i, k] + road[k, j])\n\nreward = int(v - road[s-1, g-1] - road[g-1, s-1] - p)\nprint(reward)"
  },
  {
    "language": "Python",
    "code": "inf = 0x101010\ndef solve(start,goal):\n\tcost = [inf]*n\n\tvisited = [False]*n\n\tcost[start] = 0\n\twhile 1:\n\t\tmin = inf\n\t\tnext = -1\n\t\tvisited[start] = True\n\t\tfor i in range(n):\n\t\t\tif visited[i]: continue\n\t\t\tif graph[start][i] > -1:\n\t\t\t\td = cost[start] + graph[start][i]\n\t\t\t\tif d < cost[i]:\n\t\t\t\t\tcost[i] = d\n\t\t\tif min > cost[i]:\n\t\t\t\tmin = cost[i]\n\t\t\t\tnext = i\n\t\tstart = next\n\t\tif next == -1: break\n\treturn cost[goal]\n\nn = input()\nm = input()\ngraph = [[-1]*n for i in range(n)]\nfor i in range(m):\n\ta,b,c,d = map(int,raw_input().split(\",\"))\n\tgraph[a-1][b-1] = c\n\tgraph[b-1][a-1] = d\nx1,x2,y1,y2 = map(int,raw_input().split(\",\"))\nprint y1-y2-solve(x1-1,x2-1)-solve(x2-1,x1-1)"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra(start,goal,graph):\n\n    INF = 2 << 20\n    node_num = len(graph) \n    visited = [False] * node_num\n    costs = [INF] * node_num\n    pq = []\n    costs[start] = 0\n    heapq.heappush(pq, [0,start])\n    while not len(pq) == 0:\n\n        cur_cost,cur_node = heapq.heappop(pq)\n        if visited[cur_node]:\n            continue\n        visited[cur_node] = True\n        costs[cur_node] = cur_cost\n        for i in xrange(node_num):\n            if not visited[i]:\n                heapq.heappush(pq,[graph[cur_node][i] + costs[cur_node],i])\n    return costs[goal]\n\nn = input()\nm = input()\nINF = 2 << 20\ngraph = [[INF] * (n+1) for _ in xrange(n+1)]\nfor _ in xrange(m):\n    a,b,c,d = map(int,raw_input().split(\",\"))\n    graph[a][b] = c\n    graph[b][a] = d\nhome,shop,reward,price = map(int,raw_input().split(\",\"))\ncost = dijkstra(home,shop,graph) + dijkstra(shop,home,graph)\nprint reward - price - cost"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = int(input())\nK = [[10**9 for one in range(32)] for two in range(32)]\nfor three in range(m):\n    a,b,c,d = map(int,input().split(\",\"))\n    K[a][b] = c\n    K[b][a] = d\n\nfor k in range(1,n+1):\n    for j in range(1,n+1):\n        for i in range(1,n+1):\n            if K[i][j] > K[i][k] + K[k][j]:\n                K[i][j] = K[i][k] + K[k][j]\n\ns,g,V,P = map(int,input().split(\",\"))\nprint(V-P-K[s][g]-K[g][s])\n"
  },
  {
    "language": "Python",
    "code": "def f(x1, x2):\n  W=[[i,1000] for i in range(n)]\n  W[x1]=[x1,0]\n  W[x2]=[x2,2000]\n  G = range(n)\n  while 1:\n    A = sorted([W[e] for e in G], key=lambda x: x[1])\n    p1, w1 = A[0]\n    G.remove(p1)\n    if p1==x2: break\n    for p2, w2 in A[1:]:\n      way=(p1, p2)\n      if way in cost: W[p2] = [p2, min([w2, w1+cost[way]])]\n  return W[x2][1]\n\ndef g(): return map(int, raw_input().split(\",\"))\n\nn=int(raw_input())\nm=int(raw_input())\ncost={}\nfor _ in [0]*m:\n  a,b,c,d=g()\n  a-=1\n  b-=1\n  cost[(a,b)]=c\n  cost[(b,a)]=d\nx1,x2,y1,y2=g()\nx1-=1\nx2-=1\nprint y1-y2-f(x1,x2)-f(x2,x1)"
  },
  {
    "language": "Python",
    "code": "INF = 1000000\n\nn = int(input())\nm = int(input())\ncost = [[INF] * (n + 1) for i in range(n + 1)]\n\nfor i in range(m):\n    ai, bi, ci, di = (int(s) for s in input().split(','))\n    cost[ai][bi] = ci\n    cost[bi][ai] = di\n\nx1, x2, y1, y2 = (int(s) for s in input().split(','))\n\nfor k in range(1, n + 1):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if cost[i][j] > cost[i][k] + cost[k][j]:\n                cost[i][j] = cost[i][k] + cost[k][j]\n\nprint(y1 - y2 - cost[x1][x2] - cost[x2][x1])"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn = int(input())\nm = int(input())\nroad = np.full((n, n), np.inf)\nfor i in range(m):\n    r_in = list(map(int, input().split(\",\")))\n    road[r_in[0]-1, r_in[1]-1] = r_in[2]\n    road[r_in[1]-1, r_in[0]-1] = r_in[3]\ns, g, v, p = map(int, input().split(\",\"))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                road[i, j] = 0\n            else:\n                road[i, j] = min(road[i, j], road[i, k] + road[k, j])\n\nreward = int(v - road[s-1, g-1] - road[g-1, s-1] - p)\nprint(reward)"
  },
  {
    "language": "Python",
    "code": "def f(x1, x2):\n  W = [[i, 1001] for i in range(n)]\n  W[x1] = [x1, 0]\n  W[x2] = [x2, 2000]\n  i=0\n  while 1:\n    A = sorted(W, key = lambda x:x[1])\n    p1, w1 = A[i]\n    if p1 == x2: break\n    for p2, w2 in A[i + 1:]:\n      way=(p1, p2)\n      if way in cost:\n        tmp = w1 + cost[way]\n        W[p2] = [p2, min([w2, tmp])]\n    i += 1\n  return W[x2][1]\n\nn = int(raw_input())\nm = int(raw_input())\ncost = {}\nfor _ in [0] * m:\n  a, b, c, d = map(int, raw_input().split(\",\"))\n  cost[(a-1, b-1)] = c\n  cost[(b-1, a-1)] = d\nx1, x2, y1, y2 = map(int, raw_input().split(\",\"))\nx1 -= 1\nx2 -= 1\nprint y1 - y2 - f(x1, x2) - f(x2, x1)"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef dijkstra(start,goal,graph):\n\n    INF = 2 << 20\n    node_num = len(graph) \n    visited = [False] * node_num\n    costs = [INF] * node_num\n    pq = []\n    costs[start] = 0\n    #print costs[start]\n    heapq.heappush(pq, [0,start])\n    \n    while not len(pq) == 0:\n        cur_cost,cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n        if all(visited[1:]):\n            break\n\n        #print cur_cost,cur_node\n\n        visited[cur_node] = True\n        cost = INF\n        for i in xrange(node_num):\n            cost = min(graph[i][cur_node] + costs[i], cost)\n        costs[cur_node] = cost\n        #print costs\n        \n        for i in xrange(node_num):\n            if not visited[i]:\n                heapq.heappush(pq,[graph[cur_node][i],i])\n    return costs[goal]\n\nn = input()\nm = input()\nINF = 2 << 20\ngraph = [[INF] * (n+1) for _ in xrange(n+1)]\nfor _ in xrange(m):\n    a,b,c,d = map(int,raw_input().split(\",\"))\n    #graph[from][to] = cost\n    graph[a][b] = c\n    graph[b][a] = d\nhome,shop,reward,price = map(int,raw_input().split(\",\"))\ngraph[home][home] = 0\ncost = dijkstra(home,shop,graph)\ngraph[home][home] = INF\ngraph[shop][shop] = 0\ncost += dijkstra(shop,home,graph)\nprint reward - price - cost"
  },
  {
    "language": "Python",
    "code": "INF = 10000000\n\nn = int(input())\nm = int(input())\n\ntable = [[INF for i in range(n)] for j in range(n)]\n\nfor l in range(m):\n    a,b,c,d = [int(i) for i in input().split(\",\")]\n    table[a-1][b-1] = c\n    table[b-1][a-1] = d\ns,g,V,P = [int(i) for i in input().split(\",\")]\n\nvisited = [False for i in range(n)]\ncost = [INF for i in range(n)]\n\ncost[s-1] = 0\n\nwhile True:\n    v = -1\n    for i in range(n):\n        if visited[i] == False and (v == -1 or cost[i] < cost[v]):\n            v = i\n    if v == -1:\n        break\n    visited[v] = True\n    for i in range(n):\n        cost[i] = min(cost[i], cost[v] + table[v][i])\n\nans = cost[g-1]\n\nvisited = [False for i in range(n)]\ncost = [INF for i in range(n)]\n\ncost[g-1] = 0\n\nwhile True:\n    v = -1\n    for i in range(n):\n        if visited[i] == False and (v == -1 or cost[i] < cost[v]):\n            v = i\n    if v == -1:\n        break\n    visited[v] = True\n    for i in range(n):\n        cost[i] = min(cost[i], cost[v] + table[v][i])\n\nans += cost[s-1]\n\nprint(V-P-ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input().strip())\nM = int(input().strip())\nInf = 1001001001\nK = [[Inf for j in range(N)] for i in range(N)]\nfor _ in range(M):\n    a,b,c,d = map(int,input().strip().split(\",\"))\n    K[a-1][b-1] = c\n    K[b-1][a-1] = d\nS,G,V,P = map(int,input().strip().split(\",\"))\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if K[i][j] > K[i][k] + K[k][j]:\n                K[i][j] = K[i][k] + K[k][j]\nR = V - P - K[S-1][G-1] - K[G-1][S-1]\nprint(R)\n"
  },
  {
    "language": "Python",
    "code": "'''\n大工の褒美\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0117&lang=jp\n'''\n\ntown_num = int(input()) # (<= 20)\nroad_num = int(input()) # (<= 100)\n\ncosts = [[100000]*town_num for _ in range(town_num)]\n\n# [a, b, c, d] a から b まで c, 逆は d の交通費がかかる\nfor a, b, c, d in [list(map(int, input().split(','))) for _ in range(road_num)]:\n    costs[a-1][b-1] = c\n    costs[b-1][a-1] = d\n\ns, g, v, p = map(int, input().split(','))\n\n# Floyd Warshall\nfor k in range(town_num):\n    for i in range(town_num):\n        for j in range(town_num):\n            if costs[i][j] > costs[i][k] + costs[k][j]:\n                costs[i][j] = costs[i][k] + costs[k][j]\n\nprint(v - p - costs[s-1][g-1] - costs[g-1][s-1])\n\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main(){\n  let n: usize = read();\n  let m: usize = read();\n\n  let mut dm: Vec<Vec<u32>> = vec![vec![std::u32::MAX / 4;n];n];\n  \n  for _ in 0 .. m {\n    let abcd: Vec<u32> = read_vec();\n    let a = (abcd[0] - 1) as usize;\n    let b = (abcd[1] - 1) as usize;\n    let c = abcd[2];\n    let d = abcd[3];\n    dm[a][b] = c;\n    dm[b][a] = d;\n  }\n\n  let sgvp: Vec<u32> = read_vec();\n  let s = (sgvp[0] - 1) as usize;\n  let g = (sgvp[1] - 1) as usize;\n  let v = sgvp[2];\n  let p = sgvp[3];\n  \n  for k in 0 .. n {\n    for i in 0 .. n {\n      for j in 0 .. n {\n        dm[i][j] = cmp::min(dm[i][j], dm[i][k] + dm[k][j]);\n      }\n    }\n  }\n\n  let ans: u32 = v - p - dm[s][g] - dm[g][s];\n  \n  println!(\"{}\", ans);\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().split(',').map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]