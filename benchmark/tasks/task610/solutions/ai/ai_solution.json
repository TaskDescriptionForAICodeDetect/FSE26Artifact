[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint parent[MAX_N];\nint rank[MAX_N];\nlong long diff_value[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x) {\n        int root = find(parent[x]);\n        diff_value[x] += diff_value[parent[x]];\n        parent[x] = root;\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y, long long z) {\n    int root_x = find(x);\n    int root_y = find(y);\n    \n    if (root_x == root_y) return;\n    \n    if (rank[root_x] < rank[root_y]) {\n        parent[root_x] = root_y;\n        diff_value[root_x] = z - diff_value[x] + diff_value[y];\n    } else {\n        parent[root_y] = root_x;\n        diff_value[root_y] = -z - diff_value[y] + diff_value[x];\n        \n        if (rank[root_x] == rank[root_y]) {\n            rank[root_x]++;\n        }\n    }\n}\n\nlong long get_diff(int x, int y) {\n    int root_x = find(x);\n    int root_y = find(y);\n    \n    if (root_x != root_y) return -1000000000000LL;\n    \n    return diff_value[x] - diff_value[y];\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n        diff_value[i] = 0;\n    }\n    \n    while (q--) {\n        char type[10];\n        scanf(\"%s\", type);\n        \n        if (strcmp(type, \"relate\") == 0) {\n            int x, y;\n            long long z;\n            scanf(\"%d %d %lld\", &x, &y, &z);\n            unite(x, y, z);\n        } else {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            long long result = get_diff(x, y);\n            \n            if (result == -1000000000000LL) {\n                printf(\"UNKNOWN\\n\");\n            } else {\n                printf(\"%lld\\n\", result);\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int parent;\n    int diff;\n} Node;\n\nNode *nodes;\n\nint find(int x) {\n    if (nodes[x].parent != x) {\n        int orig_parent = nodes[x].parent;\n        nodes[x].parent = find(nodes[x].parent);\n        nodes[x].diff += nodes[orig_parent].diff;\n    }\n    return nodes[x].parent;\n}\n\nvoid relate(int x, int y, int z) {\n    int root_x = find(x);\n    int root_y = find(y);\n    if (root_x != root_y) {\n        nodes[root_y].parent = root_x;\n        nodes[root_y].diff = nodes[x].diff + z - nodes[y].diff;\n    }\n}\n\nint diff(int x, int y) {\n    if (find(x) != find(y)) {\n        return -1;\n    }\n    return nodes[y].diff - nodes[x].diff;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    nodes = (Node *)malloc(n * sizeof(Node));\n    for (int i = 0; i < n; i++) {\n        nodes[i].parent = i;\n        nodes[i].diff = 0;\n    }\n    while (q--) {\n        char type;\n        scanf(\" %c\", &type);\n        if (type == 'r') {\n            int x, y, z;\n            scanf(\"%d %d %d\", &x, &y, &z);\n            relate(x, y, z);\n        } else {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            int res = diff(x, y);\n            if (res == -1) {\n                printf(\"?\\n\");\n            } else {\n                printf(\"%d\\n\", res);\n            }\n        }\n    }\n    free(nodes);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct UnionFind {\n    unordered_map<int, int> parent;\n    unordered_map<int, int> weight;\n\n    int find(int x) {\n        if (parent.find(x) == parent.end()) {\n            parent[x] = x;\n            weight[x] = 0;\n            return x;\n        }\n        if (parent[x] != x) {\n            int orig_parent = parent[x];\n            parent[x] = find(parent[x]);\n            weight[x] += weight[orig_parent];\n        }\n        return parent[x];\n    }\n\n    bool unite(int x, int y, int z) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return weight[y] - weight[x] == z;\n        }\n        parent[rootY] = rootX;\n        weight[rootY] = weight[x] + z - weight[y];\n        return true;\n    }\n\n    int diff(int x, int y) {\n        if (find(x) != find(y)) {\n            return INT_MAX;\n        }\n        return weight[y] - weight[x];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    UnionFind uf;\n    int q;\n    cin >> q;\n    while (q--) {\n        string cmd;\n        cin >> cmd;\n        if (cmd == \"relate\") {\n            int x, y, z;\n            cin >> x >> y >> z;\n            if (!uf.unite(x, y, z)) {\n                cout << \"Error: Inconsistent relation\" << endl;\n            }\n        } else if (cmd == \"diff\") {\n            int x, y;\n            cin >> x >> y;\n            int res = uf.diff(x, y);\n            if (res == INT_MAX) {\n                cout << \"?\" << endl;\n            } else {\n                cout << res << endl;\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private long[] weight;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        weight = new long[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            weight[x] += weight[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y, long z) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return weight[y] - weight[x] == z;\n        }\n        parent[rootY] = rootX;\n        weight[rootY] = weight[x] + z - weight[y];\n        return true;\n    }\n\n    public long diff(int x, int y) {\n        if (find(x) != find(y)) {\n            return Long.MIN_VALUE;\n        }\n        return weight[y] - weight[x];\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int q = scanner.nextInt();\n        UnionFind uf = new UnionFind(n);\n\n        for (int i = 0; i < q; i++) {\n            String type = scanner.next();\n            if (type.equals(\"relate\")) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                long z = scanner.nextLong();\n                uf.union(x, y, z);\n            } else if (type.equals(\"diff\")) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                long res = uf.diff(x, y);\n                if (res == Long.MIN_VALUE) {\n                    System.out.println(\"?\");\n                } else {\n                    System.out.println(res);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:19:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private int[] parent;\n    private int[] rank;\n    private int[] diff;\n\n    public Solution(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        diff = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n            diff[i] = 0;\n        }\n    }\n\n    private int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            diff[x] += diff[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    private void union(int x, int y, int delta) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n            diff[rootX] = delta - diff[x] + diff[y];\n        } else {\n            parent[rootY] = rootX;\n            diff[rootY] = -delta - diff[y] + diff[x];\n            \n            if (rank[rootX] == rank[rootY]) {\n                rank[rootX]++;\n            }\n        }\n    }\n\n    public void relate(int x, int y, int z) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX != rootY) {\n            union(x, y, z);\n        }\n    }\n\n    public int diff(int x, int y) {\n        if (find(x) != find(y)) {\n            return Integer.MAX_VALUE;\n        }\n        return diff[y] - diff[x];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Solution solution = new Solution(n);\n\n        int q = scanner.nextInt();\n        for (int i = 0; i < q; i++) {\n            String query = scanner.next();\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n\n            if (query.equals(\"relate\")) {\n                int z = scanner.nextInt();\n                solution.relate(x, y, z);\n            } else {\n                int result = solution.diff(x, y);\n                System.out.println(result == Integer.MAX_VALUE ? \"UNKNOWN\" : result);\n            }\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:19:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cmath>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    vector<int> diff;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        diff.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            diff[x] += diff[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y, int delta) {\n        int root_x = find(x);\n        int root_y = find(y);\n\n        if (root_x == root_y) return;\n\n        if (rank[root_x] < rank[root_y]) {\n            swap(root_x, root_y);\n            swap(x, y);\n            delta = -delta;\n        }\n\n        parent[root_y] = root_x;\n        diff[root_y] = delta - diff[y] + diff[x];\n\n        if (rank[root_x] == rank[root_y]) {\n            rank[root_x]++;\n        }\n    }\n\n    int getDiff(int x, int y) {\n        if (find(x) != find(y)) return INT_MIN;\n        return diff[y] - diff[x];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    DisjointSet ds(n);\n\n    while (q--) {\n        char type;\n        cin >> type;\n\n        if (type == 'r') {\n            int x, y, z;\n            cin >> x >> y >> z;\n            ds.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            int result = ds.getDiff(x, y);\n            if (result == INT_MIN) {\n                cout << \"NaN\\n\";\n            } else {\n                cout << result << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class DifferenceFinder:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.difference = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            root = self.find(self.parent[x])\n            self.difference[x] += self.difference[self.parent[x]]\n            self.parent[x] = root\n        return self.parent[x]\n\n    def unite(self, x, y, diff):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n            self.difference[root_x] = self.difference[y] - self.difference[x] + diff\n    \n    def diff(self, x, y):\n        if self.find(x) == self.find(y):\n            return self.difference[y] - self.difference[x]\n        else:\n            return None  # No defined relation between x and y.\n\ndef process_queries(n, queries):\n    df = DifferenceFinder(n)\n    results = []\n    \n    for query in queries:\n        if query[0] == \"relate\":\n            _, x, y, z = query\n            df.unite(x, y, z)\n        elif query[0] == \"diff\":\n            _, x, y = query\n            diff_result = df.diff(x, y)\n            if diff_result is not None:\n                results.append(diff_result)\n            else:\n                results.append(\"undefined\")\n    \n    return results\n\n# Example usage:\n# n = 5\n# queries = [\n#     (\"relate\", 0, 1, 3),\n#     (\"relate\", 1, 2, 2),\n#     (\"diff\", 0, 2),\n#     (\"diff\", 2, 0),\n#     (\"diff\", 0, 3)\n# ]\n# print(process_queries(n, queries))",
    "timestamp": "2025-08-13 09:56:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // length of sequence A\n        int m = scanner.nextInt(); // number of queries\n\n        // We use a map to store differences between elements based on relate queries\n        Map<Integer, Integer> diffMap = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            String queryType = scanner.next();\n            if (queryType.equals(\"relate\")) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int z = scanner.nextInt();\n\n                // Calculate the known difference between x and y\n                int diff = diffMap.getOrDefault(y, 0) - diffMap.getOrDefault(x, 0) + z;\n\n                // Store the difference for y\n                diffMap.put(y, diff);\n\n            } else if (queryType.equals(\"diff\")) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n\n                // Calculate and output the difference between a_y and a_x\n                int result = diffMap.getOrDefault(y, 0) - diffMap.getOrDefault(x, 0);\n                System.out.println(result);\n            }\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 09:56:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 1000\n#define INF 1000000000\n\nint parent[MAXN];\nint diff[MAXN];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        diff[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        int root = find(parent[x]);\n        diff[x] += diff[parent[x]];\n        parent[x] = root;\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y, int z) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootY] = rootX;\n        diff[rootY] = diff[x] + z - diff[y];\n    }\n}\n\nint getDifference(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        return INF; // indicates not directly relatable\n    }\n    return diff[y] - diff[x];\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    init(n);\n    for (int i = 0; i < q; i++) {\n        char query_type[10];\n        int x, y, z;\n        scanf(\"%s\", query_type);\n        if (query_type[0] == 'r') {\n            scanf(\"%d %d %d\", &x, &y, &z);\n            union_sets(x, y, z);\n        } else if (query_type[0] == 'd') {\n            scanf(\"%d %d\", &x, &y);\n            int result = getDifference(x, y);\n            if (result == INF) {\n                printf(\"Not connected\\n\");\n            } else {\n                printf(\"%d\\n\", result);\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 09:56:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.diff = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            root = self.find(self.parent[x])\n            self.diff[x] += self.diff[self.parent[x]]\n            self.parent[x] = root\n        return self.parent[x]\n\n    def union(self, x, y, z):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] < self.rank[root_y]:\n            root_x, root_y = root_y, root_x\n            x, y = y, x\n            z = -z\n        \n        self.parent[root_y] = root_x\n        \n        if self.rank[root_x] == self.rank[root_y]:\n            self.rank[root_x] += 1\n        \n        self.diff[root_y] = z + self.diff[x] - self.diff[y]\n        \n        return True\n\n    def query(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x != root_y:\n            return None\n        \n        return self.diff[y] - self.diff[x]\n\ndef solve(n, queries):\n    uf = UnionFind(n)\n    results = []\n    \n    for query in queries:\n        if query[0] == 'relate':\n            _, x, y, z = query\n            uf.union(x, y, z)\n        else:\n            _, x, y = query\n            diff = uf.query(x, y)\n            results.append(diff if diff is not None else \"UNKNOWN\")\n    \n    return results",
    "timestamp": "2025-08-13 09:57:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom sys import stdin\nsys.setrecursionlimit(1 << 25)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    q = int(data[idx])\n    idx += 1\n    \n    parent = [i for i in range(n)]\n    weight = [0] * n  # weight[i] is the value from parent[i] to i (i.e., parent[i] + weight[i] = i)\n    \n    def find(u):\n        if parent[u] != u:\n            orig_parent = parent[u]\n            parent[u] = find(parent[u])\n            weight[u] += weight[orig_parent]\n        return parent[u]\n    \n    for _ in range(q):\n        query = data[idx]\n        idx += 1\n        if query == 'relate':\n            x = int(data[idx])\n            idx += 1\n            y = int(data[idx])\n            idx += 1\n            z = int(data[idx])\n            idx += 1\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                parent[root_y] = root_x\n                weight[root_y] = weight[x] + z - weight[y]\n        elif query == 'diff':\n            x = int(data[idx])\n            idx += 1\n            y = int(data[idx])\n            idx += 1\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                print(\"?\")\n            else:\n                print(weight[y] - weight[x])\n    \nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 09:57:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass DifferenceCalculator {\nprivate:\n    vector<int> parent;\n    vector<int> diff;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            int orig_parent = parent[x];\n            parent[x] = find(parent[x]);\n            diff[x] += diff[orig_parent];\n        }\n        return parent[x];\n    }\n\n    void union_relate(int x, int y, int z) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n            diff[rootY] = diff[x] + z - diff[y];\n        }\n    }\n\npublic:\n    DifferenceCalculator(int n) {\n        parent.resize(n);\n        diff.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    void relate(int x, int y, int z) {\n        union_relate(x, y, z);\n    }\n\n    int diff_query(int x, int y) {\n        if (find(x) != find(y)) {\n            return 0; // Or some error value as they are not connected\n        }\n        return diff[y] - diff[x];\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    DifferenceCalculator calc(n);\n\n    for (int i = 0; i < q; ++i) {\n        string type;\n        cin >> type;\n        if (type == \"relate\") {\n            int x, y, z;\n            cin >> x >> y >> z;\n            calc.relate(x, y, z);\n        } else if (type == \"diff\") {\n            int x, y;\n            cin >> x >> y;\n            cout << calc.diff_query(x, y) << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:56:07"
  }
]