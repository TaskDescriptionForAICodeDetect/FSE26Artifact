[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\nconst int INF = 1e9;\nconst int MOD = 1000000007;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct potential_Unionfind{\n    vector<int> parents;\n    vector<int> weights;\n    int m;\n    potential_Unionfind(int n):parents(n,-1){\n        m = n;\n        weights.resize(n);\n    }\n\n    int find(int x){\n        if(parents[x] < 0) return x;\n        else{\n            int p = find(parents[x]);\n            weights[x] += weights[parents[x]];\n            return parents[x] = p;\n        }\n    }\n\n    //weight[y] - weights[x] = wとなるようにuniteする。\n    bool unite(int x,int y,int w){\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;//もうすでに繋がれている頂点ならfalseを返す\n        if(parents[x] > parents[y]) {swap(x,y); w = -w;}\n        parents[x] += parents[y];\n        parents[y] = x;\n        weights[y] = w;\n        return true;\n    }\n\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n\n    //weightsは各頂点から根までの距離\n    int weight(int x){\n        find(x);\n        return weights[x];\n    }\n\n    //まずsame(x,y)で繋がっているかわからないと正しい答えは出てこない\n    int diff(int x,int y){\n         return weight(y) - weight(x);\n    }\n\n\n};\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    potential_Unionfind uf(n);\n    rep(i,q){\n        int c;\n        cin >> c;\n        if(c==0){\n            int x,y,z;\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        }else{\n            int x,y;\n            cin >> x >> y;\n            int ans = uf.diff(x,y);\n            if(!uf.same(x,y)) cout << '?' << endl;\n            else cout << uf.diff(x,y) << endl;\n        }\n    }\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\n\nstruct weight_unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu,dif;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tdif.resize(N+1,0);\n\t\t\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\tif(par[x]==x) return x;\n\t\tint r=root(par[x]);\n\t\tdif[x]+=dif[par[x]];\n\t\tpar[x]=r;\n\t\treturn r;\n\t}\n\t\n\tint poten(int x){\n\t\troot(x);\n\t\treturn dif[x];\n\t}\n\t\n\tint diff(int x,int y){//po[y]-po[x]\n\t\treturn poten(y)-poten(x);\n\t}\n\t\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\t\n\t\n\t\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y,int val){\n\t\t//矛盾がないかsameとdiffから確認してから使う！！\n\t\t//po[x]+val=po[y]\n\t\tint px=poten(x),py=poten(y);\n\t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t \tif(x==y) return;\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tval=py-px-val;\n\t\t\tpar[x]=y;\n\t\t\tdif[x]=val;\n\t\t\tkosuu[y]=yy+xx;\n\t\t}\n\t \telse {\n\t \t\tval=val+px-py;\n\t\t\tpar[y]=x;\n\t \t\tdif[y]=val;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t}\n\t\treturn;\n\t}\n};\n\n weight_unionfind ss;\nsigned main(){\n\n\t\t\t  cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,k;\n\tcin>>n>>k;\n\tss.shoki(n+100);\n\tfor(int j=0;j<k;j++){\n\t\tint t;\n\t\tcin>>t;\n\t\tif(t){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(!ss.same(x,y)){\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<ss.diff(x,y)<<endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tif(!ss.same(x,y)){\n\t\t\t\tss.unite(x,y,z);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass UnionFind {\n\npublic:\n    vector<int> par;\n    vector<int> rank;\n    vector<int> relative_diff;\n    \n    UnionFind( int n ) {\n\tpar.resize( n );\n\trank.resize( n );\n\trelative_diff.resize( n );\n\tfor ( int i=0; i<n; ++i ) par[i] = i;\n    }\n\n    int Root( int x ) {\n\n\tif ( x == par[x] ) return x;\n\n\tint r = Root( par[x] );\n\trelative_diff[x] += relative_diff[par[x]];\n\tpar[x] = r;\n\treturn r;\n    }\n    \n    bool IsSame( int x, int y ) {\n\treturn Root( x ) == Root( y );\n    }\n\n    void Merge( int x, int y, int w ) {\n\n\tw += TotalDiff( x );\n\tw -= TotalDiff( y );\t\n\t\n\tx = Root( x );\n\ty = Root( y );\n\n\tif ( x == y ) return;\n\n\tif ( rank[x] < rank[y] ) {//yの方が深い\n\t    relative_diff[x] = -w;\n\t    par[x] = y;//xをyのグループのルートにつなぐ\n\t}\n\telse {//xの方が深いか 同じ深さ\n\t    relative_diff[y] = w;\n\t    par[y] = x;//yをxのグループのルートにつなぐ\n\t    if ( rank[x] == rank[y] ) ++rank[x];\n\t}\n\t\n    }\n\n    int TotalDiff( int x ) {\n\tRoot( x );\n\treturn relative_diff[x];\n    }\n    \n    int Diff( int x, int y ) {\n\treturn TotalDiff( y ) - TotalDiff( x );\n    }\n};\n\nint main() {\n\n    int n, l;\n    cin >> n >> l;\n    \n    UnionFind un(n);\n\n    for ( int i=0; i<l; ++i ) {\n\tint type, a, b;\n\tcin >> type >> a >> b;\n\tif ( type == 0 ) {\n\t    int w;\n\t    cin >> w;\n\t    un.Merge( a, b, w );\n\t}\n\telse {\n\t    if ( un.IsSame( a, b ) )\n\t\tcout << un.Diff( a, b ) << endl;\n\t    else\n\t\tcout << \"?\" << endl;\n\t}\n    }\n\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_1_B\n//重み付きUnion Find木\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=int64_t;\n#define FOR(i,a,b) for(int64_t i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//重み付きUnion Find木\ntemplate<class T>\nstruct wuf_tree {\n    std::vector<int> parent;\n    std::vector<T> diff_weight;\n    int __size;\n    wuf_tree(int size_, T sum_unity=T()) : parent(size_, -1), diff_weight(size_,sum_unity), __size(size_) {}\n    void unite(int x, int y, T w) {\n        w += weight(x);\n        w -= weight(y);\n        if ((x = find(x)) != (y = find(y))) {\n            if (parent[y] < parent[x]) { std::swap(x, y); w=-w; }\n            parent[x] += parent[y];\n            parent[y] = x;\n            diff_weight[y] = w;\n            __size--;\n        }\n    }\n    bool is_same(int x, int y) { return find(x) == find(y); }\n    int find(int x) {\n        if (parent[x]<0) return x;\n        int r = find(parent[x]);\n        diff_weight[x] += diff_weight[parent[x]];\n        return parent[x] = r;\n    }\n    int size(int x) { return -parent[find(x)]; }\n    int size() const { return __size; }\n    T weight(int x) { find(x); return diff_weight[x]; }\n    T diff(int x, int y) { return weight(y) - weight(x); }\n};\n\nint main() {\n#if LOCAL&01\n    std::ifstream in(\"./input.txt\"); //input.txt\n    std::cin.rdbuf(in.rdbuf());\n#else\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n#endif\n    ll n,q; cin>>n>>q;\n    wuf_tree<ll> wuft(n);\n    REP(i,q){\n        ll a; cin>>a;\n        if(a==0){\n            ll x,y,z; cin>>x>>y>>z;\n            wuft.unite(x,y,z);\n        }else{\n            ll x,y; cin>>x>>y;\n            if(wuft.is_same(x,y)){\n                cout<<wuft.diff(x,y)<<endl;\n            }else{\n                cout<<\"?\"<<endl;\n            }\n\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/datastructure/potentialunionfind.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B\"\n#define CXX \"g++\"\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\n#line 1 \"test/datastructure/../../library/datastructure/unionfindpotential.cpp\"\ntemplate <class Abel>\nstruct UnionFindPotential {\n    vector<int> parent, rank;\n    vector<Abel> diff_weight;\n\n    UnionFindPotential(int n = 1, Abel SUM_UNITY = 0)\n        : parent(n + 1), rank(n + 1, 0), diff_weight(n + 1, SUM_UNITY) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    int root(int x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            int r = root(parent[x]);\n            diff_weight[x] += diff_weight[parent[x]];\n            return parent[x] = r;\n        }\n    }\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    bool isSame(int x, int y) { return root(x) == root(y); }\n    bool unite(int x, int y, Abel w) {\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (rank[x] < rank[y])\n            swap(x, y), w = -w;\n        if (rank[x] == rank[y])\n            ++rank[x];\n        parent[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    Abel diff(int x, int y) { return weight(y) - weight(x); }\n};\n#line 9 \"test/datastructure/potentialunionfind.test.cpp\"\n\nint main() {\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    UnionFindPotential<lint> uf(n);\n    for (int i = 0; i < q; ++i) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (uf.isSame(x, y))\n                cout << uf.diff(x, y) << \"\\n\";\n            else\n                cout << \"?\"\n                     << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T> \nstruct WeightedUnionFind{\n  int n;\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n//END CUT HERE\nsigned AOJ_1330(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    WeightedUnionFind<Int> u(n,0);\n    for(int i=0;i<m;i++){\n      int a,b;\n      char c;\n      cin>>c>>a>>b;\n      a--;b--;\n      if(c=='!'){\n\tInt w;\n\tcin>>w;\n\tu.unite(a,b,w);\n      }else{\n\tif(!u.same(a,b)) cout<<\"UNKNOWN\"<<endl;\n\telse cout<<u.diff(a,b)<<endl;\n      }\n    }\n  }\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n*/\n\nsigned DSL_1_B(){\n  Int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<Int> wuf(n,0);\n  \n  for(Int i=0;i<q;i++){\n    Int t,x,y,z;\n    cin>>t>>x>>y;\n    //cout<<t<<\":\"<<x<<\" \"<<y<<endl;\n    if(t){\n      if(wuf.same(x,y)) cout<<wuf.diff(x,y)<<endl;\n      else cout<<\"?\"<<endl;\n    }else{\n      cin>>z;\n      wuf.unite(x,y,z);\n    }\n  }\n}\n/*\n  verified on 2018/04/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B&lang=jp\n*/\n\nsigned main(){\n  //AOJ_1330();\n  DSL_1_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\ntemplate<typename T>\nstruct weightedUF{\n\tint n;\n\tvector<int>parent,rank;\n\tvector<T>dweight;\n\tweightedUF(int n_=0,T defvalue=0):n(n_),parent(n_),rank(n_,0),dweight(n_,defvalue)\n\t{\n\t\tfor(int i=0;i<n;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\tif(parent[a]==a)return a;\n\t\telse\n\t\t{\n\t\t\tint ar=find(parent[a]);\n\t\t\tdweight[a]+=dweight[parent[a]];\n\t\t\treturn parent[a]=ar;\n\t\t}\n\t}\n\tT weight(int a)\n\t{\n\t\tfind(a);\n\t\treturn dweight[a];\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b,int w)\n\t{\n\t\tw+=weight(a);w-=weight(b);\n\t\ta=find(a);b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\tdweight[a]=-w;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tdweight[b]=w;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n\tT diff(int a,int b)\n\t{\n\t\treturn weight(b)-weight(a);\n\t}\n};\nmain()\n{\n\tint n,q;cin>>n>>q;\n\tweightedUF<int>P(n);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint c;cin>>c;\n\t\tif(c==0)\n\t\t{\n\t\t\tint x,y,w;cin>>x>>y>>w;P.unite(x,y,w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tif(P.same(x,y))cout<<P.diff(x,y)<<endl;\n\t\t\telse cout<<'?'<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tvoid unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tz += Weight[y] - Weight[x];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = z;\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = -z;\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tbool cost(int x, int y, long long &t){ // if same(x, y) return a[y] - a[x]\n\t\tif(!same(x, y)) return false;\n\t\treturn (t = Weight[x] - Weight[y]);\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y;\n\t\t\tlong long z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tlong long tmp;\n\t\t\tif(wuf.cost(x, y, tmp)) cout << tmp << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint arr[100000], value[100000];\n\nint find(int x){\n\tif (arr[x] == x)return x;\n\telse {\n\t\tint fx = arr[x];\n\t\tarr[x] = find(arr[x]);\n\t\tvalue[x] += value[fx];\n\t\treturn arr[x];\n\t}\n\treturn arr[x] == x ? x : arr[x] = find(arr[x]);\n}\n\nvoid relate(int a, int b, int c)\n{\n\tint fa = find(a), fb = find(b);\n\tif (fa != fb){\n\t\tvalue[fa] = c + value[b] - value[a];\n\t\tarr[fa] = fb;\n\t}\n}\n\nint main()\n{\n\tint n, q, ch, a, b, c;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 0; i < n; ++i)arr[i] = i;\n\t\n\twhile (q--){\n\t\tscanf(\"%d\", &ch);\n\t\tif (ch){\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (find(a) == find(b))cout << value[a] - value[b] << endl;\n\t\t\telse printf(\"?\\n\");\n\t\t}else{\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\trelate(a, b, c);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T>\nstruct WeightedUnionFind{\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n\n  WeightedUnionFind(){}\n  WeightedUnionFind(int n,T d):\n    d(d),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n\n  int find(int x){\n    if(x==p[x]) return x;\n    int t=find(p[x]);\n    ws[x]+=ws[p[x]];\n    return p[x]=t;\n  }\n\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n//END CUT HERE\n\nsigned DSL_1_B(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<int> wuf(n,0);\n\n  for(int i=0;i<q;i++){\n    int t,x,y,z;\n    cin>>t>>x>>y;\n    if(t){\n      if(wuf.same(x,y)) cout<<wuf.diff(x,y)<<\"\\n\";\n      else cout<<\"?\\n\";\n    }else{\n      cin>>z;\n      wuf.unite(x,y,z);\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2019/09/08\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B&lang=jp\n*/\n\nsigned main(){\n  DSL_1_B();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int NIL = -1;\nconst int MAX = 1 << 21;\n\nstruct Node {\n\tint node, weight, parent;\n};\n\nNode forests[100010];\nint height[100010];\n\nint findSet(int x) {\n\tvector<int>tree;\n\tint sum, i;\n\twhile (forests[x].parent != forests[x].node) {\n\t\ttree.push_back(x);\n\t\tx = forests[x].parent;\n\t}\n\tfor (vector<int>::iterator it = tree.begin(); it != tree.end(); it++) {\n\t\tsum = 0;\n\t\ti = *it;\n\t\twhile (forests[i].parent != i) {\n\t\t\tsum += forests[i].weight;\n\t\t\ti = forests[i].parent;\n\t\t}\n\t\tforests[*it].parent = x;\n\t\tforests[*it].weight = sum;\n\t}\n\treturn x;\n}\n\nvoid unite(int x, int y, int z)\n{\n\tint X, Y;\n\tX = findSet(x);\n\tY = findSet(y);\n\tif (height[X] > height[Y]) {\n\t\tforests[Y].parent = X;\n\t\tforests[Y].weight = -forests[y].weight + forests[x].weight + z;\n\t}\n\telse if (height[X] < height[Y]) {\n\t\tforests[X].parent = Y;\n\t\tforests[X].weight = -forests[x].weight + forests[y].weight - z;\n\t}\n\telse {\n\t\tforests[Y].parent = X;\n\t\tforests[Y].weight = -forests[y].weight + forests[x].weight + z;\n\t\theight[X]++;\n\t}\n}\n\nint main(void)\n{\n\tint n, q, com, x, y, z, X, Y;\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tforests[i].node = i;\n\t\tforests[i].weight = 0;\n\t\tforests[i].parent = i;\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> com;\n\t\tif (com) {\n\t\t\tcin >> x >> y;\n\t\t\tX = findSet(x);\n\t\t\tY = findSet(y);\n\t\t\tif (X == Y)\n\t\t\t\tcout << forests[y].weight - forests[x].weight << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> x >> y >> z;\n\t\t\tX = findSet(x);\n\t\t\tY = findSet(y);\n\t\t\tif (X == Y)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tunite(x, y, z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n \nvector<int> p,rank,cost;\n \n \nint find(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = find(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n \nvoid connect(int x, int y, int z) {\n    int rootx = find(x), rooty = find(y);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n\nvoid Set(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n \nint main() {\n    int n,q,com,x,y,z;\n    scanf(\"%d %d\", &n, &q);\n    for(int i=0; i<n; i++) Set(i);\n    for(int i=0; i<q; i++) {\n        scanf(\"%d %d %d\", &com, &x, &y);\n        if(com == 1) {\n            if(find(x) == find(y)) \n            {\n                cout << cost[y]-cost[x] << endl;\n            }\n            else {\n                cout << '?' << endl;\n            }\n        }\n        else {\n            \n        scanf(\"%d\", &z);\n            connect(x,y,z);\n    }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\nusing namespace std;\ntemplate<class A> struct UnionFind {\n       vector<int> p;\n       vector<int> rank;\n       vector<A> diff_weight;\n       UnionFind(int n = 1, A UNITY = 0) {\n              init(n, UNITY);\n       }\n       void init(int n = 1, A UNITY = 0) {\n              p.resize(n); rank.resize(n); diff_weight.resize(n);\n              for (int i = 0; i < n; ++i) p[i] = i, rank[i] = 0, diff_weight[i] = UNITY;\n       }\n       int root(int x) {\n              if (p[x] == x) {\n                     return x;\n              }\n              else {\n                     int r = root(p[x]);\n                     diff_weight[x] += diff_weight[p[x]];\n                     return p[x] = r;\n              }\n       }\n       A weight(int x) {\n              root(x);\n              return diff_weight[x];\n       }\n       bool same(int x, int y) {\n              return root(x) == root(y);\n       }\n       bool unite(int x, int y, A w) {\n              w += weight(x); w -= weight(y);\n              x = root(x); y = root(y);\n              if (x == y) return false;\n              if (rank[x] < rank[y]) swap(x, y), w = -w;\n              if (rank[x] == rank[y]) ++rank[x];\n              p[y] = x;\n              diff_weight[y] = w;\n              return true;\n       }\n       A diff(int x, int y) {\n              return weight(y) - weight(x);\n       }\n};\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  UnionFind<int> uf(N);\n  for (int i = 0; i < M; ++i) {\n     int a, b, c, d;\n     cin >> a;\n     if (a == 0) {\n      cin >> b >> c >> d;\n       uf.unite(b, c, d);\n     }\n   else {\n   cin >> b >> c;\n   if (!uf.same(b, c)) cout << \"?\" << endl;\n    else cout << uf.diff(b, c) << endl;\n   }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n\ntemplate<class T>\nstruct WeightedUnionFind {\nprivate:\n    vector<int> par, rank;\n    vector<T> diff_weight;\n    \npublic:\n    WeightedUnionFind() {}\n    WeightedUnionFind(int n, T def = 0) {\n        par.resize(n, -1);\n        rank.resize(n, 0);\n        diff_weight.resize(n, def);\n    }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n    \n    T weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    \n    bool is_same(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y, T w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    \n    T diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    ll n, q;\n    cin >> n >> q;\n    WeightedUnionFind<ll> wuf(n);\n    rep(i, q) {\n        ll t;\n        cin >> t;\n        if (t == 0) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            wuf.merge(x, y, z);\n        }\n        else {\n            ll x, y;\n            cin >> x >> y;\n            if (wuf.root(x) == wuf.root(y)) {\n                cout << wuf.diff(x, y) << endl;\n            }\n            else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n  vector<int> parent;\n  vector< ll > dist;\n  UnionFind(int x=1){\n    parent.clear();\n    parent.resize(x,-1);\n    dist.clear();\n    dist.resize(x,0);\n  }\n  int find(int x){\n    if(parent[x]<0)return x;\n    int r=find(parent[x]);\n    dist[x]+=dist[ parent[x] ];\n    return parent[x]=r;    \n  }\n  ll depth(int x){\n    find(x);\n    return dist[x];\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int size(int x){\n    return -parent[find(x)];\n  }\n  void unite(int x,int y,ll k=0){\n    k+=depth(y);\n    k-=depth(x);\n    k*=-1;\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size(x)<size(y)){\n      swap(x,y);\n      k*=-1;\n    }\n    parent[x]+=parent[y];\n    parent[y]=x;\n    dist[y]=k;\n  }\n};\n\n\n\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  UnionFind T(n);\n  for(int i=0;i<q;i++){\n    int type,x,y;\n    scanf(\"%d %d %d\",&type,&x,&y);\n    if(type==0){\n      int a;\n      scanf(\"%d\",&a);\n      T.unite(x,y,a);\n    }else{\n      \n      if(!T.same(x,y)){\n        printf(\"?\\n\");\n      }else{\n        printf(\"%lld\\n\",T.depth(x)-T.depth(y));\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id] = { a, data[id].second + d };\n\t\t}\n\t\tall[a].insert(all[a].end(), all[b].begin(), all[b].end());\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#include <vector>\ntemplate<class T>struct UnionFind {\n  vector<int> parent, sz;\n  vector<T> _diff;\n  UnionFind(int n) {\n    parent.resize(n, -1);\n    sz.resize(n, 1);\n    _diff.resize(n, 0); // 親との差\n  }\n  int root(int x) {\n    if (parent[x] == -1)\n      return x;\n    int r = root(parent[x]);\n    _diff[x] += _diff[parent[x]];\n    return parent[x] = r;\n  }\n  T weight(int x) {\n    root(x);\n    return _diff[x];\n  }\n  void merge(int x, int y, T w) {\n    // weight(x) = weight(y) + w;\n    // yが親\n    if (root(x) == root(y))\n      return;\n    T d = weight(y) - weight(x) + w;\n    x = root(x); y = root(y);\n    parent[x] = y;\n    sz[y] += sz[x];\n    _diff[x] = d;\n    return;\n  }\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sz[root(x)];\n  }\n};\n\n#define in(v) v; cin >> v;\nvoid ins() {}\ntemplate<class T,class... Rest>void ins(T& v,Rest&... rest){cin>>v;ins(rest...);}\n#define rep(i,n) for(int i=0,_i=(n);i<_i;++i)\n\nint main() {\n  int n, q; cin >> n >> q;\n  UnionFind<int> T(n);\n\n  rep(i, q) {\n    int com, x, y;\n    ins(com, x, y);\n    if (com == 0) {\n      int in(z);\n      T.merge(y, x, z);\n    } else if (com == 1) {\n      if (T.same(x, y))\n        cout << T.diff(x, y) << endl;\n      else\n        cout << \"?\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate<class T> inline bool chmax(T& a, T b) {if (a<b) {a=b; return true;} return false;}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a>b) {a=b; return true;} return false;}\n#define DEBUG_VLL(vec) REP(i, vec.size()) cerr<<vec[i]<<(i==vec.size()-1?'\\n':' ');\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\n\ntemplate < typename T >\nstruct WeightedUnionFind {\n    vector<int> p, size, height;\n    vector<T> diff_weight;\n\n    WeightedUnionFind(){}\n    WeightedUnionFind(int n) {\n        size.resize(n, 1);\n        height.resize(n, 1);\n        diff_weight.resize(n, 0);\n        p.resize(n);\n        for (int i=0; i<n; i++) p[i] = i;\n    }\n\n    int root(int i) {\n        // iの親を求めるついでに差分の累積もとる\n        if (p[i] == i) return i;\n        else {\n            int r = root(p[i]);\n            diff_weight[i] += diff_weight[p[i]];\n            return p[i] = r;\n        }\n    }\n\n    T weight(int i) {\n        // iの重みを取得する\n        root(i);  // 経路圧縮\n        return diff_weight[i];\n    }\n\n    T diff(int i, int j) {\n        if (root(i) != root(j)) return HIGHINF;\n        // iとjの重みの差分をとる\n        return weight(j) - weight(i);\n    }\n\n    bool same(int i, int j) {\n        // iとjが同じグループかどうかを判別する\n        return root(i) == root(j);\n    }\n\n    void unite(int i, int j, T w) {\n        // iとjを併合する, wは重みの差weight[j]-weight[i]\n        // rootとの間に辺をつなぐので単純にwで増減じゃダメ\n        w += weight(i); w -= weight(j);\n        int pi=root(i), pj=root(j);\n        if (pi == pj) return;\n        if (height[pi] < height[pj]) {\n            w = -w;\n            p[pi] = pj;\n            size[pj] += size[pi];\n            diff_weight[pi] = w;\n        } else {\n            p[pj] = pi;\n            size[pi] += size[pj];\n            diff_weight[pj] = w;\n            if (height[pi] == height[pj]) height[pi]++;\n        }\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<ll> uni(n);\n    int com, x, y;\n    ll z;\n    for (int i=0; i<q; i++) {\n        cin >> com;\n        if (com == 0) {\n            cin >> x >> y >> z;\n            uni.unite(y, x, z);\n        } else {\n            cin >> x >> y;\n            if (!uni.same(x, y)) cout << \"?\\n\";\n            else cout << uni.diff(y, x) << '\\n';\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include <numeric>\n#include<map>\n \n \n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 1e13\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n \ntypedef long long int ll;\n#define MOD 1000000007\n\n\nstruct Potential_UnionFind{\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff_weight;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        REP(i,n){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x,int y) {\n        return root(x) == root(y);\n    }\n\n    void merge(int x, int y,int w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n    }\n\n    int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nPotential_UnionFind PUF;\n\nint main(){\n\n    int n,q;\n    cin >> n >> q;\n    PUF.init(n);\n    \n    REP(i,q){\n\n        int num,x,y,z;\n        cin >> num;\n        if(!num){\n            //mergeする\n            cin >> x >> y >> z;\n            PUF.merge(x,y,z);     \n\n        }else{\n            //diffを求める\n\n            cin >> x >> y;\n            if(!PUF.issame(x,y)){\n                cout << \"?\" << endl;\n            }else{\n                cout << PUF.diff(x,y) << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAX 100002\n\nint p[MAX];\nint diff_w[MAX];\nint r[MAX];\n\nint root(int x){\n    if(p[x]==x)return x;\n    int r = root(p[x]);\n    diff_w[x] += diff_w[p[x]];\n    return p[x] = r;\n}\n\nvoid diff(int x,int y){\n  if(root(x)==root(y))cout<<diff_w[y] - diff_w[x]<<endl;\n  else cout<<\"?\"<<endl;\n}\nbool same(int x,int y){\n  return root(x)==root(y);\n}\nvoid Union(int x,int y){\n  p[x]=y;\n}\n\nvoid merge(int x,int y,int w){\n  int rx = root(x);\n  int ry = root(y);\n  w = w + diff_w[x] - diff_w[y];\n  if(r[rx]<r[ry]) {\n    swap(rx,ry);\n    w = -w;\n  }\n  r[rx]+=r[ry];\n  p[ry] = rx;\n  diff_w[ry] = w;\n  //cout<<\"w:\"<<w<<endl;\n}\n\nint main(){\n  int n,q,x,y,z,rx,ry,flag;\n  cin>>n>>q;\n  for(int i=0;i<n+1;i++){\n    p[i] = i;\n    r[i] = 1;\n  }\n  for(int i=0;i<q;i++){\n    cin>>flag>>x>>y;\n    if(flag==1){\n      diff(x,y);\n    }\n    else{\n      cin>>z;\n      merge(x,y,z);\n    }\n  }\n  //for(int i=0;i<n+1;i++)cout<<i<<\" root:\"<<p[i]<<\" diff_w:\"<<diff_w[i]<<\" rank:\"<<r[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass DisjointSet {\npublic:\n\tvector<int> p, r, w;\n\t\n\tDisjointSet(){}\n\tDisjointSet(int size){\n\t\tfor(int i=0;i<size;i++){\n\t\t\tmakeSet(i);\n\t\t}\n\t}\n\t\n\tvoid makeSet(int x){\n\t\tp.push_back(x);\n\t\tr.push_back(0);\n\t\tw.push_back(0);\n\t}\n\t\n\tvoid relate(int x, int y, int z){\n\t\tlink(find(x),find(y),z-w[x]+w[y]);\n\t}\n\t\n\tvoid link(int x, int y, int cost){\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\tw[x]+=cost;\n\t\t} else {\n\t\t\tp[y]=x;\n\t\t\tw[y]-=cost;\n\t\t\tif(r[x]==r[y]){\n\t\t\t\tr[y]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x)==find(y);\n\t}\n\t\n\tint sum(int x){\n\t\tint sum=0;\n\t\tint cur=x;\n\t\twhile(cur!=p[cur]){\n\t\t\tsum+=w[cur];\n\t\t\tcur=p[cur];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tint find(int x){\n\t\tif(x!=p[x]){\n\t\t\tint tmp=find(p[x]);\n\t\t\tw[x]+=w[tmp];\n\t\t\tx=tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tDisjointSet ds(n);\n\tfor(int i=0;i<q;i++){\n\t\tint c, x, y, z;\n\t\tcin >> c >> x >> y;\n\t\tif (c == 0) {\n\t\t\tcin >> z;\n\t\t\tds.relate(x, y, z);\n\t\t} else {\n\t\t\tif (!ds.same(x, y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t} else {\n\t\t\t\tint sumX = ds.sum(x);\n\t\t\t\tint sumY = ds.sum(y);\n\t\t\t\tcout << sumX - sumY << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// (weighted) UnionFind\nclass UnionFind {\n    public:\n        UnionFind(int n) : mPar(n), mRnk(n,0), mWeight(n,0) {\n            for(int i = 0; i < n; ++i) mPar[i] = i;\n        }\n\n        int find(int x){\n            if(mPar[x]==x) return x;\n            int r = find(mPar[x]); // 経路圧縮\n            mWeight[x] += mWeight[mPar[x]]; // 一つ上の親からの累積和\n            return mPar[x] = r;\n        }\n\n        bool same(int x,int y){\n            return find(x) == find(y);\n        }\n\n        int diff(int x, int y){\n            return mWeight[y] - mWeight[x];\n        }\n\n        void unite(int x,int y, int w = 0){\n            w += mWeight[x]; w -= mWeight[y]; // calc weight first\n            x = find(x);\n            y = find(y);\n            if(x==y) return;\n            if(mRnk[x] < mRnk[y]) swap(x,y), w = -w;\n            mPar[y] = x;\n            mWeight[y] = w;\n            if(mRnk[x] == mRnk[y]) ++mRnk[x];\n        }\n\n    private:\n        vector<int> mPar, mRnk, mWeight;\n};\n\nint main(){\n    int n,q,c,x,y,z;\n    cin >> n >> q;\n    UnionFind uf(n);\n    for(int i = 0; i < q; ++i){\n        cin >> c;\n        if(c==0){\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        } else {\n            cin >> x >> y;\n            if(uf.same(x,y)) cout << uf.diff(x,y) << '\\n';\n            else cout << '?' << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, N) for (int i = 0; i < (int)N; i++)\n\nclass UnionFindTree {\n  struct edge {\n    int node;\n    int distance;\n  };\n  vector<edge> root;\n  vector<int> rank;\n\n  edge findRoot(int x) {\n    if(x != root[x].node) {\n      edge e = findRoot(root[x].node);\n      root[x] = edge{e.node, e.distance + root[x].distance};\n    }\n    return root[x];\n  }\n\npublic:\n\n  UnionFindTree(int size) {\n    rank = vector<int>(size, 0);\n    root = vector<edge>(size, edge{});\n    for(int i = 0; i < size; i++) root[i] = edge{i,0};\n  }\n\n  void relate(int x, int y, int z) {\n    edge ex = findRoot(x);\n    edge ey = findRoot(y);\n    if(ex.node == ey.node)return;\n\n    int d = z + ey.distance - ex.distance;\n    if(rank[ex.node] < rank[ey.node]) {\n      root[ex.node] = edge{ey.node, d};\n    } else {\n      root[ey.node] = edge{ex.node, -d};\n      if(rank[ex.node] == rank[ey.node]) rank[ex.node]++;\n    }\n  }\n\n  string difference(int x, int y) {\n    edge ex = findRoot(x);\n    edge ey = findRoot(y);\n    if(ex.node == ey.node) {\n      return to_string(ex.distance - ey.distance);\n    } else {\n      return \"?\";\n    };\n  }\n};\n\nint main () {\n  int n, q;\n  cin >> n >> q;\n  UnionFindTree uft(n);\n\n  rep(i,q) {\n    int c, x, y, z;\n    cin >> c;\n    if(c == 0) {\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n      continue;\n    }\n    cin >> x >> y;\n    cout << uft.difference(x, y) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int INF = 1e10;\n\nclass WUF{\npublic:\n  \n  int n;\n  vector<int> p, rank, w;\n  \n  WUF(){};\n  WUF(int n):n(n),p(n),rank(n,0),w(n,0){ for(int i=0;i<n;i++) p[i] = i; };\n  \n  typedef pair<int,int> P;\n  \n  P find(int x){\n    if( x != p[x] ){\n      P r = find(p[x]);\n      p[x] = r.first;\n      w[x] += r.second;\n      return P( p[x], w[x] );\n    }\n    return P( p[x], 0 );\n  }\n  \n  void unite(int x, int y, int z){ // w[y] - w[x] = z\n    P r1 = find(x);\n    P r2 = find(y);\n    x = r1.first;\n    y = r2.first;\n    int Wx = r1.second;\n    int Wy = r2.second;\n    if( rank[x] > rank[y] ){\n      p[y] = x;\n      w[y] = Wx - Wy + z;\n    }\n    else{\n      p[x] = y;\n      w[x] = Wy - Wx - z;\n      if(rank[x]==rank[y]) rank[y]++;\n    }\n\n  }\n  \n  int diff(int x, int y){\n    if( find(x).first != find(y).first ) return INF;\n    return w[y] - w[x];\n  }\n  \n};\n\nsigned main(){\n  \n  int n, q;\n  cin>>n>>q;\n  \n  WUF wuf(n);\n  \n  while(q--){\n    \n    int flg;\n    cin>>flg;\n\n    if( flg == 0 ){\n      \n      int x, y, z;\n      cin>>x>>y>>z;\n      \n      wuf.unite(x,y,z);\n      \n    }\n    else{\n      \n      int x, y;\n      cin>>x>>y;\n      \n      int ans = wuf.diff(x,y);\n\n      if( ans == INF ) cout<<\"?\"<<endl;\n      else cout<<ans<<endl;\n      \n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> struct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n  vector<T> diff_w;\n\n  UnionFind(int n = 1, T e = 0)\n      : par(n), rank(n), diff_w(n) {\n    init(n, e);\n  }\n\n  void init(int n, T e) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_w[i] = e;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    } else {\n      diff_w[x] += diff_w[par[x]];\n      return par[x] = root(par[x]);\n    }\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  T weight(int x) {\n    root(x);\n    return diff_w[x];\n  }\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n  bool unite(int x, int y, T w = 0) {\n    w -= weight(y) - weight(x);  // normalization\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w = negate<T>()(w);\n    }\n    par[y] = x;\n    diff_w[y] = w;\n    if (rank[x] == rank[y]) ++rank[x];\n    return true;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  UnionFind<int> uf(n);\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int x, y; cin >> x >> y;\n      cout << ( (uf.same(x, y)) ? to_string(uf.diff(x, y)) : \"?\" ) << endl;\n    } else {\n      int x, y, z; cin >> x >> y >> z;\n      uf.unite(x, y, z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n#define INF 1000000000007\n#define MOD 1000000007\n#define ARRAY_MAX 3005\n\n\n//重み付きUnion-Find\nstruct Potential_UnionFind{\n\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff_weight;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        REP(i,n){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(int x) {//親を探す\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x,int y) {\n        return root(x) == root(y);\n    }\n\n    void merge(int x, int y,int w) {\n\n        int rx = root(x);\n        int ry = root(y);\n        \n        if(rank[rx] < rank[ry]){\n            diff_weight[rx] = -w - weight(x) + weight(y);\n            par[rx] = ry;\n        }else{\n            diff_weight[ry] = w + weight(x) - weight(y);\n            par[ry] = rx;\n            if(rank[rx] == rank[ry]){\n                rank[rx]++;\n            }\n        }\n    }\n\n    int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n\n    Potential_UnionFind tree;\n    int n,q;\n    cin >> n >> q;\n    tree.init(n);\n    for(int i = 0;i < q;i++){\n\n        int a,b,c,d;\n        cin >> a;\n        if(a == 0){\n            cin >> b >> c >> d;\n            tree.merge(b,c,d);\n        }else{\n            cin >> b >> c;\n            if(tree.issame(b,c)){\n                cout << tree.diff(b,c) << endl;\n            }else{\n                cout << \"?\" << endl;\n            }\n        }\n\n\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto x:v)cerr<<x<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define EPS 1e-9\ntypedef long long ll;\n\nstruct WeightedUnionFind{\n  vector<long long> data;\n  vector<long long> dif;\n  void boot(long long n){\n    for(long long i = 0;i < n;i++)data.push_back(-1);\n    for(long long i = 0;i < n;i++)dif.push_back(0);\n    return;\n  }\n  long long root(long long x){\n    if(data[x] < 0)return x;\n    long long r = root(data[x]);\n    dif[x] += dif[data[x]];\n    return data[x] = root(data[x]);\n  }\n  long long weight(long long x){\n    root(x);\n    return dif[x];\n  }\n  bool same(long long x,long long y){\n    return root(x) == root(y);\n  }\n  void unite(long long x,long long y,long long w){\n    if(!same(x,y)){\n      w += weight(x);\n      w -= weight(y);\n      x = root(x);\n      y = root(y);\n      if(data[x] < data[y]){\n        data[x] += data[y];\n        data[y] = x;\n        dif[y] = w;\n      }\n      else{\n        data[y] += data[x];\n        data[x] = y;\n        dif[x] = -w;\n      }\n    }\n    return;\n  }\n  long long getsize(long long x){\n    return -data[root(x)];\n  }\n  long long diff(long long x,long long y){\n    return dif[y] - dif[x];\n  }\n};\n\nsigned main(){\n  int n,q;\n  cin >> n >> q;\n  WeightedUnionFind UF;\n  UF.boot(n);\n  int query,x,y,z;\n  FOR(i,0,q){\n    cin >> query;\n    if(query == 0){\n      cin >> x >> y >> z;\n      UF.unite(x,y,z);\n    }\n    else{\n      cin >> x >> y;\n      if(!UF.same(x,y))cout << \"?\" << endl;\n      else cout << UF.diff(x,y) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntemplate<typename X>\nstruct WUFT{\n  vector<int> par;//親\n  vector<int> rank;//木の深さ\n  vector<int> size;//木の大きさ\n  vector<X> diff_weight;//差分重み\n  int n;\n\n  WUFT(int _n){\n    n = _n;\n    par.resize(n);\n    rank.resize(n,0);\n    size.resize(n,1);\n    diff_weight.resize(n,0);\n    rep(i,n) par[i] = i;\n  }\n\n  //xの根を返す,差分重みを更新\n  int find(int x){\n    if(par[x] == x) return x;\n    else{\n      int r = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]]; //累積和\n      return par[x] = r;\n    }\n  }\n\n  X weight(int x){\n    find(x);\n    return diff_weight[x];\n  }\n\n  X diff(int x,int y){\n    return weight(y) - weight(x);\n  }\n  \n  //x,yを距離wで併合\n  bool unite(int x,int y,X w){\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if(x == y) return false;\n\n    if(rank[x] < rank[y]){ // x(の根)をy(の根)の下にくっつける\n      par[x] = y;\n      size[y] += size[x];\n      diff_weight[x] = -w;\n    }\n    else{ // y(の根)をx(の根)の下にくっつける\n      par[y] = x;\n      size[x] += size[y];\n      diff_weight[y] = w;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    return true;\n  }\n\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n\n  int usize(int x){\n    return size[find(x)];\n  }\n};\nint main()\n{\n  int n,q;cin >> n >> q;\n  vector<int> c(q),x(q),y(q),z(q);\n  rep(i,q){\n    cin >> c[i];\n    if(c[i]==0) cin >> x[i] >> y[i] >> z[i];\n    else cin >> x[i] >> y[i];\n  }\n\n  WUFT<int> wuf(n);\n  rep(i,q){\n    if(c[i]==0) wuf.unite(x[i],y[i],z[i]);\n    else{\n      if(wuf.same(x[i],y[i])) cout << wuf.diff(x[i],y[i]) << \"\\n\";\n      else cout << \"?\" << \"\\n\";\n    }\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <vector>\ntemplate <typename T>\nclass Option {\n\tOption() {};\n\tvirtual void make_vtbl() {};\npublic:\n\tstruct Some :Option<T> {\n\t\tT value;\n\t\tSome(const T &val) :value{ val } {};\n\t};\n\tstruct NilClass :Option<T> {\n\t\tNilClass() {};\n\t};\n\tstatic Option<int>::NilClass Nil() {\n\t\tstatic Option<int>::NilClass nil = NilClass();\n\t\treturn nil;\n\t};\n};\nclass Weighted_union_find_tree {\n\tstruct Pair {\n\t\tWeighted_union_find_tree *ptr;\n\t\tint differ;\n\t};\n\tWeighted_union_find_tree *_parent{ nullptr };\n\tint _diff{ 0 };\n\tPair parent() {\n\t\tif (_parent == nullptr)\n\t\t\treturn Pair{ this, 0 };\n\t\telse\n\t\t{\n\t\t\tauto prev = _parent->parent();\n\t\t\t_parent = prev.ptr;\n\t\t\t_diff += prev.differ;\n\t\t\treturn Pair{ _parent, _diff };\n\t\t}\n\t};\npublic:\n\tvoid set_relate(Weighted_union_find_tree &greater, int weight) {\n\t\tif (is_related(greater)) return;\n\t\tauto other_pos = greater.parent();\n\t\tother_pos.ptr->_parent = this;\n\t\tother_pos.ptr->_diff = weight - other_pos.differ;\n\t};\n\tbool is_related(Weighted_union_find_tree &other) {\n\t\treturn parent().ptr == other.parent().ptr;\n\t};\n\tstd::shared_ptr<Option<int>> diff(Weighted_union_find_tree &other) {\n\t\tif (!is_related(other)) return std::make_shared<Option<int>::NilClass>(Option<int>::Nil());\n\t\tauto pos = parent();\n\t\tauto other_pos = other.parent();\n\t\treturn std::make_shared<Option<int>::Some>(Option<int>::Some(other_pos.differ - pos.differ));\n\t};\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tstd::vector<Weighted_union_find_tree> uft(n);\n\tint query, x, y, z;\n\tfor (auto i = 0; i < q; ++i) {\n\t\tstd::cin >> query;\n\t\tswitch (query) {\n\t\tcase 0: std::cin >> x >> y >> z;\n\t\t\tuft[x].set_relate(uft[y], z); break;\n\t\tdefault: std::cin >> x >> y;\n\t\t\tauto opt = std::dynamic_pointer_cast<Option<int>::Some>(uft[x].diff(uft[y]));\n\t\t\tif (opt == nullptr) {\n\t\t\t\tstd::cout << '?' << std::endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << opt->value << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nclass UnionFind{\nprivate:\n    vector<int> data;\n    vector<int> diff_weight;\npublic:\n    UnionFind(int size) : data(size,-1), diff_weight(size, 0){}\n    int root(int x){\n        if(data[x] < 0){\n            return x;\n        }else{\n            diff_weight[x] += diff_weight[data[x]];\n            return data[x] = root(data[x]);\n        }\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    bool connect(int x,int y, int w){\n\n        w += weight(x);w -= weight(y);\n        x = root(x);y = root(y);\n        if(x != y){\n            if(data[x] < data[y]){\n                data[x] += data[y];data[y] = x;\n                diff_weight[y] = w;\n            }else{\n                data[y] += data[x];data[x] = y;\n                diff_weight[x] = -w;\n            }\n        }\n        return x != y;\n    }\n    bool check(int x,int y){\n        return root(x) == root(y);\n    }\n    int Size(int x){\n        return -data[x];\n    }\n    int diff(int a, int b){\n        return weight(b) - weight(a);\n    }\n};\n\nint main(){\n   int N,q;cin >> N >> q;\n   UnionFind Uni(N);\n   for(int a = 0;a < q;a++){\n       int x;cin >> x;\n       if(x == 0){\n           int d,e,f;cin >> d >> e >> f;\n           Uni.connect(d,e,f);\n       }else{\n           int d,e;cin >> d >> e;\n           if(Uni.check(d,e))cout<<Uni.diff(d,e)<<endl;\n           else cout<<\"?\"<<endl;\n       }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tvoid unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tz += Weight[x] - Weight[y];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = -z;\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = z;\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tbool cost(int x, int y, long long &t){ // if same(x, y) return a[y] - a[x]\n\t\tif(!same(x, y)) return false;\n\t\treturn (t = Weight[y] - Weight[x]);\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y;\n\t\t\tlong long z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tlong long tmp;\n\t\t\tif(wuf.cost(x, y, tmp)) cout << tmp << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst long long LINF = 1e18;\n#define dump(x)  cout << 'x' << ' = ' << (x) << ` `;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOREACH(x,a) for(auto& (x) : (a) )\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll, ll> P;\n\n// ここからライブラリ //\n\n\nclass weighted_union_find_tree {\nprivate:\n    vector<ll> par;\n    vector<ll> ran;\n    vector<ll> m_size;\n    vector<ll> diff_weght;\npublic:\n    weighted_union_find_tree(int n);\n    int find(int x);\n    ll weight(int x);\n    ll diff(int x, int y);\n    bool unite(int x, int y, int w);\n    bool same(int x, int y);\n    ll size(int x);\n};\n\nweighted_union_find_tree::weighted_union_find_tree(int n){\n    par.resize(n);\n    iota(par.begin(), par.end(), 0);\n    ran.resize(n, 0);\n    diff_weght.resize(n, 0);\n    m_size.resize(n, 1);\n};\n\nint weighted_union_find_tree::find(int x) {\n    if (par[x] == x) return x;\n    else {\n        int r = find(par[x]);\n        diff_weght[x] += diff_weght[par[x]];\n        return par[x] = r;\n    }\n};\n\nll weighted_union_find_tree::weight(int x) {\n    find(x);\n    return diff_weght[x];\n}\n\nll weighted_union_find_tree::diff(int x, int y) {\n    return weight(y)-weight(x);\n}\n\nbool weighted_union_find_tree::unite(int x, int y, int w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    if (x == y) return false;\n    if (ran[x] < ran[y]) swap(x,y), w *= -1;\n    par[y] = x;\n    m_size[x] += m_size[y];\n    diff_weght[y] = w;\n    if (ran[x]==ran[y]) ran[x]++;\n    return true;\n};\n\nll weighted_union_find_tree::size(int x) {\n    return m_size[find(x)];\n}\n\nbool weighted_union_find_tree::same(int x, int y) {\n    return (find(x) == find(y));\n};\n// ここまでライブラリ //\n\nint main(int argc, char const *argv[]) {\n    int n, q;\n    cin >> n >> q;\n    weighted_union_find_tree wuf(n);\n    REP(i,q) {\n        int c;\n        cin >> c;\n        if (!c) {\n            int x,y,z;\n            cin >> x >> y >> z;\n            wuf.unite(x,y,z);\n        }\n        else {\n            int x,y;\n            cin >> x >> y;\n            if (wuf.same(x,y)) {\n                cout << wuf.diff(x,y) << endl;\n            }\n            else cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <typename T>\nclass Nullable {\n\tT* _value{ nullptr };\n\tNullable() {};\n\tNullable(T *own_ptr) :_value{ own_ptr } {}\npublic:\n\t~Nullable() { delete _value; }\n\tstatic Nullable make_nullable(const T &value) {\n\t\treturn Nullable(new T(value));\n\t}\n\tstatic Nullable make_null() {\n\t\treturn Nullable();\n\t}\n\tconst T &value() const {\n\t\treturn *_value;\n\t}\n\tbool operator==(const void *ptr) const {\n\t\treturn _value == ptr;\n\t}\n};\ntemplate<typename T>\nbool operator==(const void *ptr, Nullable<T> &nullable) {\n\treturn nullable == ptr;\n}\nclass Weighted_union_find_tree {\n\tstruct Pair {\n\t\tWeighted_union_find_tree *ptr;\n\t\tint differ;\n\t};\n\tWeighted_union_find_tree *_parent{ nullptr };\n\tint _diff{ 0 };\n\tPair parent() {\n\t\tif (_parent == nullptr)\n\t\t\treturn Pair{ this, 0 };\n\t\telse\n\t\t{\n\t\t\tauto prev = _parent->parent();\n\t\t\t_parent = prev.ptr;\n\t\t\t_diff += prev.differ;\n\t\t\treturn Pair{ _parent, _diff };\n\t\t}\n\t};\npublic:\n\tvoid set_relate(Weighted_union_find_tree &greater, int weight) {\n\t\tif (is_related(greater)) return;\n\t\tauto other_pos = greater.parent();\n\t\tother_pos.ptr->_parent = this;\n\t\tother_pos.ptr->_diff = weight - other_pos.differ;\n\t};\n\tbool is_related(Weighted_union_find_tree &other) {\n\t\treturn parent().ptr == other.parent().ptr;\n\t};\n\tNullable<int> diff(Weighted_union_find_tree &other) {\n\t\tif (!is_related(other)) return Nullable<int>::make_null();\n\t\tauto pos = parent();\n\t\tauto other_pos = other.parent();\n\t\treturn Nullable<int>::make_nullable(other_pos.differ - pos.differ);\n\t};\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tstd::vector<Weighted_union_find_tree> uft(n);\n\tint query, x, y, z;\n\tfor (auto i = 0; i < q; ++i) {\n\t\tstd::cin >> query;\n\t\tswitch (query) {\n\t\tcase 0: std::cin >> x >> y >> z;\n\t\t\tuft[x].set_relate(uft[y], z); break;\n\t\tdefault: std::cin >> x >> y;\n\t\t\tauto nullable = uft[x].diff(uft[y]);\n\t\t\tif (nullable == nullptr) {\n\t\t\t\tstd::cout << '?' << std::endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << nullable.value() << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\nusing ll=long long;\nusing ull=unsigned long long;\nusing pii=pair<int,int>;\n\n#define INF LONG_MAX\n#define MOD 1000000007\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.end(),a.begin()\n\nstruct weightUF{\n  vector<int>par,rank;\n  vector<ll>diff_weight;\n\n  weightUF(int n){\n    par.resize(n);\n    rank.resize(n,0);\n    diff_weight.resize(n,0);\n    for(int i=0;i<n;i++)par[i]=i;\n  }\n  int root(int x){\n    if(par[x]==x)return x;\n    else{\n      int r=root(par[x]);\n      diff_weight[x]+=diff_weight[par[x]];\n      return par[x]=r;\n    }\n  }\n  ll weight(int x){\n    root(x);\n    return diff_weight[x];\n  }\n  bool is_same(int x,int y){\n    return root(x)==root(y);\n  }\n  bool unite(int x,int y,ll w){\n    w+=weight(x);\n    w-=weight(y);\n    x=root(x);\n    y=root(y);\n    if(x==y)return false;\n    if(rank[x]<rank[y])swap(x,y),w=-w;\n    if(rank[x]==rank[y])++rank[x];\n    par[y]=x;\n    diff_weight[y]=w;\n    return true;\n  }\n  ll diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,q; cin>>n>>q;\n  weightUF uf(n);\n  for(int i=0;i<q;i++){\n    int query;\n    cin>>query;\n    if(query==0){\n      int x,y,z;\n      cin>>x>>y>>z;\n      uf.unite(x,y,z);\n    }\n    else{\n      int x,y;\n      cin>>x>>y;\n      ll res=uf.diff(x,y);\n      if(uf.is_same(x,y))cout<<res<<endl;\n      else cout<<'?'<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <conio.h>\nusing namespace std;\n\n#define DEBUG 0\n\nint getParent(int x, int weight);\nvoid unite(int x, int y, int z);\nint diff(int x, int y);\nbool isSame(int x, int y);\n\nint n, q;\n\nvector<int> numbers;\nvector<int> weights;\nvector<int> num_rank;\n\nint main() {\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnumbers.push_back(i);\n\t\tweights.push_back(0);\n\t\tnum_rank.push_back(0);\n\t}\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\n\t\tcin >> com >> x >> y;\n\n\t\tswitch(com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\tunite(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (isSame(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\n\t\t}\n\n#if DEBUG == 1\n\n\t\tif (com == 0)\n\t\t\tcout << \"unite\" << \" : \";\n\t\telse\n\t\t\tcout << \"     \" << \" : \";\n\t\tcout << x << \" \" << y << \" \" << z << endl;\n\n\t\tfor(int i = 0; i < n; ++i) \n\t\t\tcout << i << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << numbers[i] << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << weights[i] << \" \";\n\n\t\tcout << endl << endl;\n\t\tgetch();  \n#endif\n\t}\n\n\n\treturn 0;\n}\n\n\nint getParent(int x) {\n\n\tif (numbers[x]!= x) {\n\t\tint r = getParent(numbers[x]);\n\n#if DEBUG == 1\n\t\tcout << \"root weights = \" << weights[numbers[x]] << endl;\n#endif\n\t\t\n\t\tweights[x] += weights[numbers[x]];\n\t\tnumbers[x] = r;\n\t}\n\t\n\treturn numbers[x];\n\n}\n\nvoid unite(int x, int y, int w) {\n\n\n\tint x_p = getParent(numbers[x]);\n\tint y_p = getParent(numbers[y]);\n\n\tw += weights[x];\n\tw -= weights[y];\n\n#if DEBUG == 1\n\tcout << x_p << \"(\" << weights[x_p] << \"), \" << y_p << \"(\" << weights[y_p] << \")\" << endl;\n#endif\n\t/*\n\tif (num_rank[x_p] < num_rank[y_p]) {\n\t\tswap(x_p, y_p);\n\t\tw *= -1;\n\t}\n\tif (num_rank[x_p] == num_rank[y_p])\n\t\t++num_rank[x_p];\n\t*/\n\tnumbers[y_p] = x_p;\n\tweights[y_p] = w;\n\t\n\n}\n\nbool isSame(int x, int y) {\n\n\treturn getParent(x) == getParent(y);\n\n}\n\n\nint diff(int x, int y) {\n\n\tgetParent(x);\n\tgetParent(y);\n\n#if DEBUG == 1\n\tcout << y << \"(\" << weights[y] << \") - \" << x << \"(\" << weights[x] << \")\" << endl;\n#endif\n\t\n\treturn weights[y] - weights[x];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by jal on 2019-10-08.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100001;\nint F[N], W[N];\nstruct Info{\n    int father, weight;\n    Info(int father, int weight):father(father), weight(weight){}\n};\nInfo getInfo(int x){\n    if(x == F[x]){\n        return Info(x, 0);\n    }\n    Info info_x = getInfo(F[x]);\n    F[x] = info_x.father;\n    W[x] += info_x.weight;\n    return Info(F[x], W[x]);\n}\nvoid unite(int x, int y, int z){\n    Info info_x = getInfo(x), info_y = getInfo(y);\n    if(info_x.father == info_y.father)return;\n    F[info_y.father] = info_x.father;\n    W[info_y.father] = W[x] - W[y] + z;\n}\nint main(){\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    for(int i = 0; i < n; i++){\n        F[i] = i;\n    }\n    for(int i = 0; i < q; i++){\n        int com, x, y, z;\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x, &y, &z);\n            unite(x, y, z);\n        }else{\n            scanf(\"%d %d\", &x, &y);\n            Info info_x = getInfo(x), info_y = getInfo(y);\n            if(info_x.father == info_y.father){\n                printf(\"%d\\n\", info_y.weight - info_x.weight);\n            }else{\n                printf(\"?\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      // z -= diffWeight[x];\n      // z += diffWeight[y];\n      z += diffWeight[y] - diffWeight[x];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << abs(getWeight(y)-getWeight(x)) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  for(int i=0 ;  i<n ; ++i){\n    cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 1000001;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] > 1000000) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define rrep(i, n) for(int i=n-1; i>=0; i--)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\ntemplate<class T> void puts(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nstruct WeightedUnionFind {\n    vector<int> par, rank, weight;\n\n    WeightedUnionFind(int n) {\n        par.resize(n);\n        rep(i, n) par[i] = i;\n        rank.resize(n);\n        weight.resize(n);\n    }\n\n    int find(int x) {\n        if (par[x] == x) return x;\n\n        int y = find(par[x]);\n        weight[x] += weight[par[x]];\n        par[x] = y;\n        return y;\n    }\n\n    void relate(int x, int y, int w) {\n        // a[y] = a[x] + w\n        int rx = find(x);\n        int ry = find(y);\n        if (rank[rx] < rank[ry]) {\n            par[rx] = ry;\n            weight[rx] = w - weight[x] + weight[y];\n        } else {\n            par[ry] = rx;\n            weight[ry] = -w - weight[y] + weight[x];\n            if (rank[rx] == rank[ry]) rank[rx]++;\n        }\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int diff(int x, int y) {\n        return weight[x] - weight[y];\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind tree(n);\n\n    int t, x, y, z;\n    vector<string> ans;\n    rep(i, q) {\n        cin >> t;\n        if (t == 0) {\n            cin >> x >> y >> z;\n            tree.relate(x, y, z);\n        } else {\n            cin >> x >> y;\n            if (tree.same(x, y)) {\n                ans.pb(to_string(tree.diff(x, y)));\n            } else {\n                ans.pb(\"?\");\n            }\n        }\n    }\n\n    rep(i, ans.size()) {\n        cout << ans[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\nint *pp[MAX];\n//int rr[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n\tpp[x] = &p[x];\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\tpp[x] = &p[y];\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\tpp[x] = &p[y];\n\t\t//rr[y] = rr[x]+1;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n/*\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\n\nint findRank(int x, int y){\n\tint a = findSet(x);\n\tint b = x;\n\twhile(a != b){\n\t\tif(b == y){\n\t\t\treturn 1;\n\t\t}\n\t\tb = p[b];\n\t}\n\treturn -1;\n}\n\n\nint returnQuery(int x,int y){\n\t\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n\t\n\treturn r[y] - r[x];\n}\n\n*/\nint returnQ(int x){\n\tif(p[x] != *pp[x]){\n\t\treturn r[x] + returnQ(p[x]);\n\t}\n\telse return r[x];\n}\n\n\nint same(int x,int y){\n\tif(*pp[x] == *pp[y]){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tlink(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tcout << returnQ(b) - returnQ(c) << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\nstruct UnionFind{\n\tvl par,dist;\n\tUnionFind(int x){par.assign(x,-1); dist.assign(x,0);}\n\tll find(ll x){return par[x]<0?x:find(par[x]);}\n\tll depth(ll x){return par[x]<0?0:depth(par[x])+dist[x];}\n\tbool same(ll x,ll y){return find(x)==find(y);}\n\tll size(ll x){return -par[find(x)];}\n\tll diff(ll x,ll y){return same(x,y)?depth(x)-depth(y):LINF;}\n\tvoid unite(ll x,ll y,ll k=0){\n\t\tk+=depth(y); k-=depth(x); k=-k;\n\t\tx=find(x); y=find(y);\n\t\tif(x==y)return;\n\t\tif(size(x)<size(y)){swap(x,y);k=-k;}\n\t\tpar[x]+=par[y]; par[y]=x; dist[y]=k;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m;\n\tcin>>n>>m;\n\t\n\tUnionFind uf(n);\n\trep(i,m){\n\t\tint t,a,b;\n\t\tcin>>t>>a>>b;\n\t\tif(t==0){\n\t\t\tint c; cin>>c;\n\t\t\tuf.unite(a,b,c);\n\t\t}else{\n\t\t\tll v=uf.diff(a,b);\n\t\t\ttf(v==LINF,\"?\",v);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nconst int inf = 1e9;\nconst ll linf = 1e18;\n\ntemplate<typename T = int>\nclass WeightedUnionFind\n{\npublic:\n    WeightedUnionFind(int n = 0, T unity = 0) : m_data(n, -1), m_weight(n, unity), m_count(n) {}\n\n    int find(int x)\n    {\n        if (m_data[x] < 0) return x;\n\n        int root = find(m_data[x]);\n        m_weight[x] += m_weight[m_data[x]];\n        return m_data[x] = root;\n    }\n\n    T weight(int x)\n    {\n        find(x);\n        return m_weight[x];\n    }\n\n    bool unite(int x, int y, T w)\n    {\n        w += weight(x), w -= weight(y);\n        x = find(x), y = find(y);\n        if (x == y) return false;\n\n        if (m_data[x] > m_data[y]) {\n            swap(x, y);\n            w = -w;\n        }\n        m_data[x] += m_data[y];\n        m_data[y] = x;\n        m_weight[y] = w;\n        m_count--;\n        return true;\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n\n    T diff(int x, int y) { return weight(y) - weight(x); }\n\n    int size(int x) { return -m_data[find(x)]; }\n\n    int count(void) const { return m_count; }\n\nprivate:\n    vector<int> m_data;\n    vector<T>   m_weight;\n    int m_count; \n};\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<int> uf(n);\n    for (int i = 0; i < q; i++) {\n        int p; cin >> p;\n        if (!p) {\n            int x, y, z; cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        } else {\n            int x, y; cin >> x >> y;\n            if (uf.same(x, y)) cout << uf.diff(x, y) << endl;\n            else cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// (weighted) UnionFind\nclass UnionFind {\n    public:\n        UnionFind(int n) : mPar(n), mRnk(n,0), mWeight(n,0) {\n            for(int i = 0; i < n; ++i) mPar[i] = i;\n        }\n\n        int find(int x){\n            if(mPar[x]==x) return x;\n            mWeight[x] += mWeight[mPar[x]]; // 一つ上の親からの累積和\n            return mPar[x] = find(mPar[x]);\n        }\n\n        bool same(int x,int y){\n            return find(x) == find(y);\n        }\n\n        int diff(int x, int y){\n            return mWeight[y] - mWeight[x];\n        }\n\n        void unite(int x,int y, int w = 0){\n            w += mWeight[x]; w -= mWeight[y]; // calc weight first\n            x = find(x);\n            y = find(y);\n            if(x==y) return;\n            if(mRnk[x] < mRnk[y]) swap(x,y), w = -w;\n            mPar[y] = x;\n            mWeight[y] = w;\n            if(mRnk[x] == mRnk[y]) ++mRnk[x];\n        }\n\n    private:\n        vector<int> mPar, mRnk, mWeight;\n};\n\nint main(){\n    int n,q,c,x,y,z;\n    cin >> n >> q;\n    UnionFind uf(n);\n    for(int i = 0; i < q; ++i){\n        cin >> c;\n        if(c==0){\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        } else {\n            cin >> x >> y;\n            if(uf.same(x,y)) cout << uf.diff(x,y) << '\\n';\n            else cout << '?' << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\n//int rr[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tbool f = false;\n\t\tint i;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(p[i] == y && i != y){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"ここ1\" << endl;\n\t\tif(f){\n\t\t\tif(r[i] <= z){\n\t\t\t\tp[x] = i;\n\t\t\t\tp[i] = y;\n\t\t\t\tr[x] = z-r[i];\n\t\t\t\tr[i] = z;\n\t\t\t\t//rr[i] = rr[x]+1;\n\t\t\t\t//rr[y] = rr[i]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i] = x;\n\t\t\t\tr[i] = r[i]-z;\n\t\t\t\tp[x] = y;\n\t\t\t\tr[x] = z;\n\t\t\t\t//rr[y] = rr[x]+1;\n\t\t\t\t//rr[i] = rr[y]+1;\n\t\t\t}\n\t\t\t//cout << \"ここ2\" << endl;\n\t\t}\n\t\telse{\n\t\t\tp[x] = y;\n\t\t\tr[x] = z;\t//r[]でdiffの判定の役割をなす\n\t\t\t//rr[y] = rr[x] + 1;\n\t\t}\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\t//rr[y] = rr[x]+1;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint findRank(int x, int y){\n\tint a = findSet(x);\n\tint b = x;\n\twhile(a != b){\n\t\tif(p[b] == y){\n\t\t\treturn 1;\n\t\t}\n\t\tb = p[x];\n\t}\n\treturn -1;\n}\n\nint returnQuery(int x,int y){\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n}\n//diffの合計を求める式\n\nvoid uni(int x,int y, int z){\n\tlink(x, y, z);\n}\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tuni(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\t//cout << \"ここ\" << endl;\n\t\t\t\tif(findRank(b,c) == 1){\n\t\t\t\t\tcout << returnQuery(b,c) << endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << -1*returnQuery(c,b) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define DEBUG 0\n\nint getParent(int x, int weight);\nvoid unite(int x, int y, int z);\nint diff(int x, int y);\nbool isSame(int x, int y);\n\nint n, q;\n\nvector<int> numbers;\nvector<int> weights;\nvector<int> num_rank;\n\nint main() {\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnumbers.push_back(i);\n\t\tweights.push_back(0);\n\t\tnum_rank.push_back(0);\n\t}\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\n\t\tcin >> com >> x >> y;\n\n\t\tswitch(com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\tunite(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (isSame(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\n\t\t}\n\n#if DEBUG == 1\n\n\t\tif (com == 0)\n\t\t\tcout << \"unite\" << \" : \";\n\t\telse\n\t\t\tcout << \"     \" << \" : \";\n\t\tcout << x << \" \" << y << \" \" << z << endl;\n\n\t\tfor(int i = 0; i < n; ++i) \n\t\t\tcout << i << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << numbers[i] << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << weights[i] << \" \";\n\n\t\tcout << endl << endl;\n\n#endif\n\t}\n\n\n\treturn 0;\n}\n\n\nint getParent(int x) {\n\n\tif (numbers[x]!= x) {\n\t\tint r = getParent(numbers[x]);\n\n\t\tnumbers[x] = r;\n\t}\n\t\n\treturn numbers[x];\n\n}\n\nvoid unite(int x, int y, int w) {\n\n\n\tint x_p = getParent(numbers[x]);\n\tint y_p = getParent(numbers[y]);\n\n\tw += weights[x];\n\tw -= weights[y];\n\n#if DEBUG == 1\n\tcout << x_p << \"(\" << weights[x_p] << \"), \" << y_p << \"(\" << weights[y_p] << \")\" << endl;\n#endif\n\n\tif (num_rank[x_p] < num_rank[y_p]) {\n\t\tswap(x_p, y_p);\n\t\tw *= -1;\n\t}\n\tif (num_rank[x_p] == num_rank[y_p])\n\t\t++num_rank[x_p];\n\n\tnumbers[y_p] = x_p;\n\tweights[y_p] = w;\n\t\n\n}\n\nbool isSame(int x, int y) {\n\n\treturn getParent(x) == getParent(y);\n\n}\n\n\nint diff(int x, int y) {\n\n\tgetParent(x);\n\tgetParent(y);\n\n#if DEBUG == 1\n\tcout << y << \"(\" << weights[y] << \") - \" << x << \"(\" << weights[x] << \")\" << endl;\n#endif\n\t\n\treturn weights[y] + weights[x];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Weighted_Union_Find {\n    std::vector<int> par;\n    std::vector<int> rank;\n    std::vector<long long> wdiff;\n    //初期化\n    void init( int n ) {\n        par.resize( n );\n        rank.resize( n );\n        wdiff.resize( n );\n        for ( int i = 0; i < n; ++i ) {\n            par[ i ] = i;\n            rank[ i ] = 0;\n            wdiff[ i ] = 0;\n        }\n    }\n    \n    //木の根を探す\n    int find( int s ) {\n        if ( par[ s ] == s ) {\n            return s;\n        }\n        int r = find(par[ s ]);\n        wdiff[s] += wdiff[par[s]];\n        return par[s] = r;\n    }\n    \n    long long weight(int x) {\n        find(x); // 経路圧縮\n        return wdiff[x];\n    }\n\n    long long diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n\n    //結合\n    bool unite( int x, int y, long long w ) {\n        w += weight(x);\n        w -= weight(y);\n        x = find( x );\n        y = find( y );\n        if ( x == y ) {\n            return false;\n        }\n        if ( rank[ x ] < rank[ y ] ) {\n            std::swap(x, y);\n            w = -w;\n        }\n        if ( rank[x] == rank[y] ) ++rank[x];\n        par[y] = x;\n        wdiff[y] = w;\n        return true;\n    }\n    \n    //二つの数の根が同じかどうか\n    bool same( int x, int y ) {\n        return find( x ) == find( y );\n    }\n    \n    //サイズを返す\n    unsigned int size() {\n        return par.size();\n    }\n};\n\nusing namespace std;\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    Weighted_Union_Find wuf;\n    wuf.init(n);\n    while(q--){\n        int query;\n        cin >> query;\n        if(query){\n            int x, y;\n            cin >> x >> y;\n            if(!wuf.same(x, y)){\n                cout << \"?\\n\";\n            }else{\n                cout << wuf.diff(x, y) << \"\\n\";\n            }\n        }else{\n            int x, y, z;\n            cin >> x >> y >> z;\n            wuf.unite(x, y, z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nclass UnionFind {\n    private:\n        vector<int> parent;  // 親\n        vector<int> rank;    // 木の深さ\n\n        // 重み付きUnionFindでのみ利用\n        vector<T> diffWeight; // 親ノードとの値の差\n    public:\n        UnionFind(int n);          // n要素で初期化\n        int Find(int x);           // 木の根を返す\n        void Unite(int x, int y);  // xとyの属する集合を併合\n        bool Same(int x, int y);   // xとyが同じ集合に属するか否か\n        \n        // 重み付きUnionFindでのみ利用\n        void Unite(int x, int y, T w);\n        T Weight(int x);      // xの重みを返す\n        T Diff(int x, int y); // xとyの差を返す\n};\n\ntemplate <typename T>\nUnionFind<T>::UnionFind(int n) : parent(n), rank(n), diffWeight(n, 0)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\ntemplate <typename T>\nint UnionFind<T>::Find(int x) {\n    if (parent[x] == x) {\n        return x;\n    } else {\n        diffWeight[x] += diffWeight[parent[x]];\n        return parent[x] = Find(parent[x]);\n    }\n}\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ntemplate <typename T>\nbool UnionFind<T>::Same(int x, int y) { return Find(x) == Find(y); }\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y, T w){\n    w += Weight(x); w -= Weight(y);\n    x = Find(x); y = Find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) swap(x, y), w = -w;\n\n    if(rank[x] == rank[y]) rank[x]++;\n    parent[y] = x;\n\n    diffWeight[y] = w;\n}\n\ntemplate <typename T>\nT UnionFind<T>::Weight(int x){\n    Find(x);\n    return diffWeight[x];\n}\n\ntemplate <typename T>\nT UnionFind<T>::Diff(int x, int y){\n    return Weight(y) - Weight(x);\n}\n\n/*************** using variables ***************/\nint n, q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    UnionFind<LL> uf(n);\n    REP(i, q){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.Unite(x, y, z);\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(uf.Same(x, y)) cout << uf.Diff(x, y) << endl;\n            else cout << '?' << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\n\n// 重み付きUnion-Find\nstruct UnionFind {\n  vector<int> par;\n  vector<int> rnk;\n  vector<int> diff_weight;\n  int n;\n  UnionFind(int n):n(n){\n    par.resize(n);rnk.resize(n);diff_weight.resize(n);\n    for(int i=0; i<n; i++){par[i] = i;rnk[i] = 0;diff_weight[i]=0;}\n  }\n  int find(int x){\n      if(par[x] == x) return x;\n      int r = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n  }\n  // y - x = w\n  bool unite(int x, int y, int w){\n      w += weight(x);\n      w -= weight(y);\n      x = find(x);\n      y = find(y);\n      if(x == y) return false;\n      if(rnk[x] < rnk[y]) swap(x, y), w = -w;\n      if(rnk[x] == rnk[y]) rnk[x]++;\n      par[y] = x;\n      diff_weight[y] = w;\n      return true;\n  }\n  bool isSame(int x, int y){return find(x) == find(y);}\n  int weight(int x){\n    find(x);\n    return diff_weight[x];\n  }\n  int diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n,q;\n  cin>>n>>q;\n  UnionFind UF(100005);\n  FOR(i,0,q){\n    int a;\n    cin>>a;\n    if(a==0){\n      int x,y,z;\n      cin>>x>>y>>z;\n      UF.unite(x,y,z);\n    } else {\n      int x,y;\n      cin >> x >> y;\n      if(UF.isSame(x, y)) cout << UF.diff(x, y) << endl;\n      else cout << \"?\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    if(p[y] != y) {\n        int root = findSet(y);\n        if(cost[y] >= z) {\n            p[x] = root;\n            cost[x] = cost[y] - z;\n            p[y] = x;\n            cost[y] = z;\n        }\n        else{\n            p[root] = x;\n            cost[root] = z - cost[y];\n        }\n    }\n    else {\n        p[y] = x;\n        cost[y] = z;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nclass UnionFind{\nprivate:\n    vector<int> data;\n    vector<LL> diff_weight;\npublic:\n    UnionFind(int size) : data(size,-1), diff_weight(size, 0){}\n    int root(int x){\n        if(data[x] < 0){\n            return x;\n        }else{\n            diff_weight[x] += diff_weight[data[x]];\n            return data[x] = root(data[x]);\n        }\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    bool connect(int x,int y, LL w){\n\n        w += weight(x);w -= weight(y);\n        x = root(x);y = root(y);\n        if(x != y){\n            if(data[x] > data[y])swap(x,y), w = -w;\n            data[x] += data[y];data[y] = x;\n            diff_weight[y] = w;\n        }\n        return x != y;\n    }\n    bool check(int x,int y){\n        return root(x) == root(y);\n    }\n    int Size(int x){\n        return -data[x];\n    }\n    int diff(int a, int b){\n        return weight(b) - weight(a);\n    }\n};\n\nint main(){\n   int N,q;cin >> N >> q;\n   UnionFind Uni(N);\n   for(int a = 0;a < q;a++){\n       int x;cin >> x;\n       if(x == 0){\n           int d,e,f;cin >> d >> e >> f;\n           Uni.connect(d,e,f);\n       }else{\n           int d,e;cin >> d >> e;\n           if(Uni.check(d,e))cout<<Uni.diff(d,e)<<endl;\n           else cout<<\"?\"<<endl;\n       }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int n; cin >> n;\n    UnionFind<int> uf(n);\n\n    int q; cin >> q;\n    rep(i,q){\n        int q_; cin >> q_;\n        if(q_ == 0){\n            int x, y, z; cin >> x >> y >> z;\n            uf.merge(x, y, z);\n        }else{\n            int x, y; cin >> x >> y;\n            if(uf.issame(x, y)){\n                cout << uf.diff(x, y) << endl;\n            }else{\n                cout << '?' << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef long long ll;\ntypedef long long integer;\n//////////////////////////////////////////////////\n// Union-Find with potential\n//https://qiita.com/drken/items/cce6fc5c579051e64fab\n\nstruct Potential_UnionFind {\n    vector<int> par;\n    vector<long long> diff_weight;\n    Potential_UnionFind(int n = 1, long long SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, long long SUM_UNITY = 0) {\n        par.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = -1, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x){\n        if (par[x] < 0) {\n            return x;\n        }else{\n            //path compression\n            int rt = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = root(par[x]);\n        }\n    }\n\n    int size(int x){\n        return -par[root(x)];\n    }\n\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    int diff(int x,int y){\n        return weight(y) - weight(x);\n    }\n\n    bool isConnect(int x,int y){\n        return root(x) == root(y);\n    }\n\n    bool connect(int x , int y, long long w){\n        //weight(y) - weight(x) = w\n        //xとyの差を無理やりwにするために現状の親からのpotentialの差をキャンセルする．\n        w += weight(x); w-= weight(y);\n        x = root(x);\n\t    y = root(y);\n\t\n        if(x==y) return false;\n        \n        //if rank[x] < rank[y]\n        if(par[x] > par[y]){\n            x ^= y;\n            y ^= x;\n            x ^= y;\n            w = -w;\n        }\n        \n        par[x] = par[x] + par[y]; // membersize++\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n};\n\nPotential_UnionFind U(100002);\n\nint main(){\n    int n,q; SCD2(n,q);\n    REP(i,q){\n        int k; SCD(k);\n        if (k == 0){\n            int x,y,z;\n            SCD3(x,y,z);\n            U.connect(x,y,z);\n        }else{\n            int x,y;\n            SCD2(x,y);\n            if (U.isConnect(x,y)){\n                PRINTD(U.diff(x,y));\n            }else{\n                printf(\"?\\n\");\n            }\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {}\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n#ifdef LOCAL\n        *this << \"----- OUTPUT ----- > \";\n#endif\n        *this << x << newl;\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\n\ntemplate <typename Iter>\nvoid dump(Iter s, Iter t) {\n#ifdef LOCAL\n        OUT << \"----- OUTPUT ----- > \";\n#endif\n  if (s == t) OUT << \"\\n\";\n  else {\n    for (; s != t; s++) {\n      OUT << *s << \" \\n\"[next(s, 1) == t];\n    }\n  }\n}\n\n\ntemplate <typename Weight = int>\nclass weighted_union_find {\n  public:\n    /// <param name=\"len\">要素数</param>\n    weighted_union_find(int len, Weight unity = 0) {\n      parent = new int[len];\n      depth = new int[len];\n      diff_weight = new Weight[len];\n      for (int i = 0; i < len; i++) parent[i] = i;\n      memset(depth, 0, len);\n      fill(diff_weight, diff_weight + len, unity);\n    }\n    /// 根を特定、経路を圧縮　あまり外部から使わない\n    int root(int x) {\n      if (parent[x] == x) return x;\n      else {\n        int r = root(parent[x]);\n        diff_weight[x] += diff_weight[parent[x]];\n        return parent[x] = r;\n      }\n      return parent[x] == x ? x :\n             (parent[x] = root(parent[x]));\n    }\n    /// 2つの要素が同じ木に属すると宣言　wはx -> y\n    void unite(int x, int y, Weight w) {\n      // wをroot(x) -> root(y)のものに書き換え\n      w += weight(x);\n      w -= weight(y);\n\n      x = root(x);\n      y = root(y);\n      if (x == y) return;\n      if (depth[x] < depth[y]) swap(x, y), w *= -1;\n      parent[y] = x;\n      if (depth[x] == depth[y]) depth[x]++;\n      diff_weight[y] = w;\n    }\n    /// 同じ木に属するか\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    /// 重みを計算\n    Weight weight(int x) {\n      root(x);\n      return diff_weight[x];\n    }\n    /// x -> y方向のweight差分\n    /// xとyがsameか確認すること\n    Weight diff(int x, int y) {\n      return weight(y) - weight(x);\n    }\n\n  private:\n    int *parent;\n    int *depth;\n    int *diff_weight;\n};\n\n\nint main() {\n  int n, q; IN >> n >> q;\n  weighted_union_find<> uf(n);\n\n  int c, x, y, z;\n  rep(q) {\n    IN >> c >> x >> y;\n    if (c == 0) {\n      IN >> z;\n      uf.unite(x, y, z);\n    } else {\n      OUT(uf.same(x, y) ? to_string(uf.diff(x, y)) : \"?\");\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst long long MOD = 1e9 + 7;\n\ntemplate <typename T>\nstruct WeightedUnionFind{\n    vector<int> par,siz;\n    vector<T> ws;\n\n    WeightedUnionFind(int n) : par(n), siz(n, 1), ws(n, T(0)){\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int root(int x){\n        if(par[x] == x) return x;\n        int t = root(par[x]);\n        ws[x] += ws[par[x]];\n        return par[x] = t;\n    }\n\n    T weight(int x){\n        root(x);\n        return ws[x];\n    }\n\n    void unite(int x, int y, T w){\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(siz[x] < siz[y]){\n            swap(x, y);\n            w = -w;\n        }\n        siz[x] += siz[y];\n        par[y] = x;\n        ws[y] = w;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    int size(int x){\n        return siz[root(x)];\n    }\n\n    T diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n};\n\nsigned main(){\n    int n,Q;\n    cin >> n >> Q;\n    WeightedUnionFind<int> wuf(n);\n    while(Q--){\n        int q;\n        cin >> q;\n        int x,y,z;\n        if(q == 0){\n            cin >> x >> y >> z;\n            wuf.unite(x, y, z);\n        }else{\n            cin >> x >> y;\n            if(!wuf.same(x, y)) cout << \"?\" << endl;\n            else cout << wuf.diff(x, y) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n    int n,q;\n    int x,y,z;\n    int count=0;\n    cin>>n>>q;\n    UnionFind<int> U(n);\n    int info[q];\n    int diff[q];\n    for(int i=0;i<q;i++){\n        cin>>info[i];\n        if(info[i]==0){\n        cin>>x>>y>>z;\n        //--x,--y;\n        //cout<<U.merge(x,y,z)<<endl;\n\n        U.merge(x,y,z);\n        }\n        if(info[i]==1){\n        cin>>x>>y;\n        if(U.diff(x,y)<0)cout<<\"?\"<<endl;\n        else cout<<U.diff(x, y)<<endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass UnionFind{\n\tvector<ll> rank;\n\tvector<ll> diff_weight;\n\tvector<ll> num;\npublic:\n\tvector<ll> par;\n\n\tUnionFind(ll N):par(N),num(N),rank(N),diff_weight(N){\n\t\tfor(ll i=0;i<N;i++){\n\t\t\tpar[i]=i;\n\t\t\tnum[i]=1;\n\t\t\trank[i]=0;\n\t\t\tdiff_weight[i]=0;\n\t\t}\n\t}\n\n\tll root(ll x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}\n\t\tll r = root(par[x]);\n\t\tdiff_weight[x]+=diff_weight[par[x]];\n\t\treturn par[x]=r;\n\t}\n\n\tvoid unite(ll x,ll y){\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\tif (rx == ry) return;\n\t\tif(rank[rx]<rank[ry]) swap(rx,ry);\n\t\tif(rank[rx]==rank[ry]) ++rank[rx];\n\t\tpar[ry] = rx;\n\t\tnum[rx] += num[ry];\n\t}\n\n\tvoid relate(ll x,ll y,ll w){\n\t\tw+=weight(x),w-=weight(y);\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\tif (rx == ry) return;\n\t\tif(rank[rx]<rank[ry]){\n\t\t\tswap(rx,ry);\n\t\t\tw = -w;\n\t\t}\n\t\tif(rank[rx]==rank[ry]) ++rank[rx];\n\t\tpar[ry] = rx;\n\t\tdiff_weight[ry] = w;\n\t\tnum[rx] += num[ry];\n\t}\n\n\tbool same(ll x,ll y){\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\treturn rx == ry;\n\t}\n\n\tll getsize(ll x){\n\t\treturn num[root(x)];\n\t}\n\n\tll weight(ll x){\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tll diff(ll x,ll y){\n\t\treturn weight(y)-weight(x);\n\t}\n};\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tauto N=in(),Q=in();\n\tUnionFind uf(N);\n\n\tREP(i,Q){\n\t\tint q=in();\n\t\tint u=in(),v=in();\n\t\tif(q==1){\n\t\t\tif(uf.same(u,v)){\n\t\t\t\tout(uf.diff(u,v));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tout('?');\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint w=in();\n\t\t\tuf.relate(u,v,w);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst auto gcu = getchar_unlocked;\nconst auto pcu = putchar_unlocked;\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;while(isspace(c)){c=gcu();}\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return n;}\n//_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n//\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _ot _il void out\n#define _ol _il void outl\n_ot(bool b) {pcu('0'+b);}\n_ot(const char *s){while(*s)pcu(*s++);}\n_ot(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_ot(string s){for(char c:s)pcu(c);}\n#endif\n_T _ot(T n){static char buf[20];char *p=buf;if(n<0)pcu('-'),n*=-1;\n\tif(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10; while (p!=buf)pcu(*--p);}\n_ol(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _ot(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _ot(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _ol(T&&... t){out(move(t)...);outl();}\n\nstruct weighted_union_find {\n\tstruct node {int p, r, w;};\n\tstruct P {int p, w;};\n\tvector<node> nodes;\n\tweighted_union_find (int n) : nodes(n) {\n\t\tfor (node &n: nodes)\n\t\t\tn.p = &n - &nodes[0];\n\t}\n\tP find(int x) {\n\t\tnode &n = nodes[x];\n\t\tif (n.p != x) {\n\t\t\tP p = find(n.p);\n\t\t\tn.p = p.p;\n\t\t\tn.w = p.w += n.w;\n\t\t\treturn p;\n\t\t} else\n\t\t\treturn {x, 0};\n\t}\n\tvoid unite(int a, int b, int w) {\n\t\tP ar = find(a), br = find(b);\n\t\tnode &an = nodes[ar.p], &bn = nodes[br.p];\n\t\tw += ar.w - br.w;\n\t\tif (an.r > bn.r) {\n\t\t\tbn.p = ar.p;\n\t\t\tbn.w = w;\n\t\t} else {\n\t\t\tan.p = br.p;\n\t\t\tan.w = -w;\n\t\t\tif (an.r == bn.r)\n\t\t\t\tbn.r++;\n\t\t}\n\t}\n\tvoid diff(int a, int b) {\n\t\tP ar = find(a), br = find(b);\n\t\tif (ar.p == br.p)\n\t\t\toutl(find(b).w - find(a).w);\n\t\telse\n\t\t\toutl(\"?\");\n\t}\n};\n\nint main() {\n\tweighted_union_find u(in());\n\tfor (int q = in(); q; q--) {\n\t\tif (in()) {\n\t\t\tint x = in();\n\t\t\tu.diff(x, in());\n\t\t} else {\n\t\t\tint x = in(), y = in();\n\t\t\tu.unite(x, y, in());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\ntemplate< typename T >\nstruct WeightedUnionFind {\n  vector< int > data;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz) : data(sz, -1), ws(sz) {}\n\n  int find(int k) {\n    if(data[k] < 0) return k;\n    auto par = find(data[k]);\n    ws[k] += ws[data[k]];\n    return data[k] = par;\n  }\n\n  T weight(int t) {\n    find(t);\n    return ws[t];\n  }\n\n  bool unite(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) {\n      swap(x, y);\n      w *= -1;\n    }\n    data[x] += data[y];\n    data[y] = x;\n    ws[y] = w;\n    return true;\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<int> uf(n);\n  while(q--){\n    int t;\n    cin>>t;\n    if(t==0){\n      int x,y,z;\n      cin>>x>>y>>z;\n      uf.unite(x,y,z);\n    }else{\n      int x,y;\n      cin>>x>>y;\n      if(uf.find(x)==uf.find(y))\n        cout<<uf.diff(x,y)<<endl;\n      else\n        cout<<'?'<<endl;\n    }\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n\ntemplate<class Abel>\nstruct wUnionFind {\n    vector<int> par;\n    vector<Abel> diff_weight;\n    wUnionFind(int n):par(n, -1), diff_weight(n) {}\n    int root(int x) {\n        if(par[x] < 0) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n    bool unite(int x, int y, Abel w) { //weight(y) - weight(x) = w となるようにする\n        w += weight(x)-weight(y);\n        x = root(x); y = root(y);\n        if(x == y) {\n            assert(diff(x, y) == w);\n            return false;\n        }\n        if(par[x] > par[y]) swap(x, y), w = -w;\n        par[x] += par[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    bool same(int x, int y) {return root(x) == root(y);}\n    bool size(int x) {return -par[root(x)];}\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    Abel diff(int x, int y) {\n        assert(same(x, y));\n        return weight(y)-weight(x);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    wUnionFind<int> wuft(n);\n    while(q--) {\n        int t;\n        cin >> t;\n        if(t) {\n            int x, y;\n            cin >> x >> y;\n            if(wuft.same(x, y)) {\n                cout << wuft.diff(x, y) << '\\n';\n            } else {\n                cout << '?' << '\\n';\n            }\n        } else {\n            int x, y, z;\n            cin >> x >> y >> z;\n            wuft.unite(x, y, z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nstruct Weighted_Union_Find_Tree {\n\tvector<int>Par, Rank,Diff_Weight;\n\tWeighted_Union_Find_Tree(int n) {\n\t\tPar.resize(n);\n\t\tRank.resize(n);\n\t\tDiff_Weight.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPar[i] = i;\n\t\t\tRank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (Par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tint r = find(Par[x]);\n\t\t\tDiff_Weight[x] += Diff_Weight[Par[x]];//累積和をとる\n\t\t\treturn Par[x] = r;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint weight(int x) {\n\t\tfind(x);//経路圧縮\n\t\treturn Diff_Weight[x];\n\t}\n\n\tint diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\n\t// weight(y) - weight(x) = w となるように merge する\n\tbool merge(int x, int y, int w) {\n\t\t// x と y それぞれについて、 root との重み差分を補正\n\t\tw += weight(x); w -= weight(y);\n\n\t\t// x と y の root へ (x と y が既につながっていたら false を返すようにした)\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\n\t\t// Rank[x] >= Rank[y] となるように x と y を swap (それに合わせて w も符号反転します)\n\t\tif (Rank[x] < Rank[y]) swap(x, y), w = -w;\n\n\t\t// y (のroot) を x (のroot) の下にくっつける \n\t\tif (Rank[x] == Rank[y]) ++Rank[x];\n\t\tPar[y] = x;\n\n\t\t// x が y の親になるので、x と y の差分を diff_weight[y] に記録\n\t\tDiff_Weight[y] = w;\n\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tWeighted_Union_Find_Tree uf(n);\n\tREP(i, q){\n\t\tint num;\n\t\tcin >> num;\n\t\tif (num == 0) {\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tuf.merge(x, y, z);\n\t\t}\n\t\telse {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif (uf.same(x, y)) {\n\t\t\t\tcout << uf.diff(x, y) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      z += diffWeight[x];\n      z -= diffWeight[y];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] < rank[y]){\n         swap(x, y);\n         z = -z;\n      }\n      if(rank[x] == rank[y]) ++ rank[x];\n      p[y]=x;\n      diffWeight[y] = z;\n\n      // if(rank[x] > rank[y]){\n      //   p[y] = x;\n      //   diffWeight[y] = -z;\n      // }else{\n      //   p[x] = y;\n      //   diffWeight[x] = z;\n      //   if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      // }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << abs(getWeight(y)-getWeight(x)) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  // for(int i=0 ;  i<n ; ++i){\n  //   cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\ntemplate < typename T >\nvoid vprint(T &V){\n\tfor(auto v : V){\n    \tcout << v << \" \";\n\t}\n\tcout << endl;\n}\n\nstruct WeightedUnionFind{\n    vector<ll> par;\n    vector<ll> rank;\n    vector<ll> diff_weight;\n\n    WeightedUnionFind(ll sz){\n        init(sz);\n    }\n\n    void init(ll sz){\n        par.resize(sz);\n        rank.resize(sz);\n        diff_weight.resize(sz);\n        FOR(i, 0, sz){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(ll x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            ll r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    ll weight(ll x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool is_same(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(ll x, ll y, ll w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    ll diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N, Q;\n    cin >> N >> Q;\n\n    auto uf = WeightedUnionFind(N);\n\n    while(Q--){\n        ll a; cin >> a;\n        // diff\n        if(a){\n            ll x, y; cin >> x >> y;\n            if(uf.is_same(x, y)){\n                p(uf.diff(x, y));\n            }else{\n                p('?');\n            }\n        }\n        // relate\n        else{\n            ll x, y, z; cin >> x >> y >> z;\n            uf.merge(x, y, z);\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass DisjointSet\n{\n\tpublic:\n\t\tvector<int> rank,p;\n\t\t\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size)\n\t\t{\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\tfor(int i=0; i<size; i++)makeSet(i);\n\t\t}\n\t\t\n\t\tvoid makeSet(int x)\n\t\t{\n\t\t\tp[x]=x;\n\t\t\trank[x]=0;\n\t\t}\n\t\t\n\t\tbool same(int x,int y)\n\t\t{\n\t\t\treturn findSet(x)==findSet(y);\n\t\t}\n\t\t\n\t\tvoid unite(int x,int y)\n\t\t{\n\t\t\tlink(findSet(x),findSet(y));\n\t\t}\n\t\t\n\t\tvoid link(int x,int y)\n\t\t{\n\t\t\tif(rank[x]>rank[y])\n\t\t\t{\n\t\t\t\tp[y]=x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp[x]=y;\n\t\t\t\tif(rank[x]==rank[y])\n\t\t\t\t{\n\t\t\t\t\trank[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint findSet(int x)\n\t\t{\n\t\t\tif(x!=p[x])\n\t\t\t{\n\t\t\t\treturn findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\n\nint main()\n{\n\tint n,a,b,q;\n\t\n\tint t;\n\tcin>>n>>q;\n\t\n\tDisjointSet ds=DisjointSet(n);\n\t\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>t>>a>>b;\n\t\tif(t==0)ds.unite(a,b);\n\t\telse if(t==1)\n\t\t{\n\t\t\tif(ds.same(a,b))cout << 1 <<endl;\n\t\t\telse cout << 0 <<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T> struct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n  vector<T> diff_w;\n\n  UnionFind(int n = 1, T e = 0)\n      : par(n), rank(n), diff_w(n) {\n    init(n, e);\n  }\n\n  void init(int n, T e) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_w[i] = e;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    } else {\n      diff_w[x] += diff_w[par[x]];\n      return par[x] = root(par[x]);\n    }\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  T weight(int x) {\n    root(x);\n    return diff_w[x];\n  }\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n  bool unite(int x, int y, T w = 0) {\n    w -= weight(y) - weight(x);  // normalization\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w = negate<T>()(w);\n    }\n    par[y] = x;\n    diff_w[y] = w;\n    if (rank[x] == rank[y]) ++rank[x];\n    return true;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  UnionFind<ll> uf(n);\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int x, y; cin >> x >> y;\n      cout << ( (uf.same(x, y)) ? to_string(uf.diff(x, y)) : \"?\" ) << endl;\n    } else {\n      int x, y, z; cin >> x >> y >> z;\n      uf.unite(x, y, z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef BODY\n\n[ library: unionfind_potentialized_notmine ]\n\nint solve(){\n\tlint n,q;in(n,q);\n\tUnionFind<lint> t(n);\n\twhile(q--){\n\t\tlint ty,x,y,z;in(ty);\n\t\tif(ty){\n\t\t\tin(x,y);\n\t\t\tif(t.issame(x,y))out(t.diff(x,y));\n\t\t\telse out(\"?\");\n\t\t} else{\n\t\t\tin(x,y,z);\n\t\t\tt.merge(x,y,z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif\n\n//sub-BOF\n\n// laptop\n// author: Tqk\n\n#define _AOJ_\n#define _C_INPUT_\n\n#pragma region template\n\n#pragma region basic\n#define IN_FILE \"./in.txt\"\n//#pragma GCC optimize (\"O3\")\n#pragma warning(disable: 4455 4244 4067 4068 4996)\n#pragma GCC target (\"avx\")\n#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n#define NOMINMAX\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef int64_t lint;\ntypedef long double ld;\ntypedef string cs;\n#define linf 1152921504606846976\n#pragma endregion\n\n#pragma region rep\n#define _vcppunko4(tuple) _getname4 tuple\n#define _getname4(_1,_2,_3,_4,name,...) name\n#define _getname3(_1,_2,_3,name,...) name\n#define _trep2(tuple) _rep2 tuple\n#define _trep3(tuple) _rep3 tuple\n#define _trep4(tuple) _rep4 tuple\n#define _rep1(n) for(lint i=0;i<n;++i)\n#define _rep2(i,n) for(lint i=0;i<n;++i)\n#define _rep3(i,a,b) for(lint i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(lint i=a;i<b;i+=c)\n#define _trrep2(tuple) _rrep2 tuple\n#define _trrep3(tuple) _rrep3 tuple\n#define _trrep4(tuple) _rrep4 tuple\n#define _rrep1(n) for(lint i=n-1;i>=0;--i)\n#define _rrep2(i,n) for(lint i=n-1;i>=0;--i)\n#define _rrep3(i,a,b) for(lint i=b-1;i>=a;--i)\n#define _rrep4(i,a,b,c) for(lint i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rep(...) _vcppunko4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))\n#define per(...) _vcppunko4((__VA_ARGS__,_trrep4,_trrep3,_trrep2,_rrep1))((__VA_ARGS__))\n#define each(c) for(auto &e:c)\n#pragma endregion\n\n#pragma region io\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator>>(istream& is,array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p);\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec);\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p);\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p){ os<<p.first<<\" \"<<p.second;return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec){ os<<vec[0];rep(i,1,vec.size())os<<' '<<vec[i];return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,deque<T>& deq){ os<<deq[0];rep(i,1,deq.size())os<<' '<<deq[i];return os; }\n\n#ifdef __ENV_TQK__\n/*\nifstream infile(IN_FILE);\ntemplate<class T>\nifstream& operator>>(ifstream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nifstream& operator>>(ifstream& is,array<T,size>& vec);\ntemplate<class T,class L>\nifstream& operator>>(ifstream& is,pair<T,L>& p);\ntemplate<class T>\nifstream& operator>>(ifstream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nifstream& operator>>(ifstream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ninline void fin(){}\ntemplate <class Head,class... Tail>\ninline void fin(Head&& head,Tail&&... tail){ infile>>head;fin(move(tail)...); }\n*/\n#include<Windows.h>\nHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\ninline void in(){ SetConsoleTextAttribute(hConsole,10); }\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){\n\tSetConsoleTextAttribute(hConsole,15);\n\tcin>>head;in(move(tail)...);\n}\n#else\ninline void in(){}\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }\n#endif\n\ninline bool out(){ return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool out(T t){ return(cout<<t<<'\\n',0); }\ntemplate <class Head,class... Tail>\ninline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }\ntemplate <class T>\ninline void alloc(T &c,lint s){ rep(c.size())c[i].resize(s); }\n#define alc alloc\n#ifdef __ENV_TQK__\ninline bool deb(){ SetConsoleTextAttribute(hConsole,10); return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool deb(T t){ return(SetConsoleTextAttribute(hConsole,12),cout<<t<<'\\n',SetConsoleTextAttribute(hConsole,10),0); }\ntemplate <class Head,class... Tail>\ninline bool deb(Head head,Tail... tail){\n\tSetConsoleTextAttribute(hConsole,12);\n\tcout<<head<<' ';deb(move(tail)...);return 0;\n}\n#define dsp(ex) sp(ex)\n#define dno(ex) no(ex)\n#define look(v) SetConsoleTextAttribute(hConsole,12),cout<<#v<<\": \",deb(v);\n#else\n#define deb(...) 0\n#define dsp(ex) 0\n#define dno(ex) 0\n#define look(v) 0\n#endif\n\n#pragma endregion\n\n#pragma region TA\n#define lin(...) lint __VA_ARGS__;in(__VA_ARGS__)\n#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define vin(type,name,size) vector<type> name(size);in(name)\n#define tvin(ty1,ty2,name,size,val) vector<ty1>_in_vec(size);vector<ty2>a(size);in(_in_vec);{ty1 e;rep(size)e=_in_vec[i],name[i]=val;}\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define fi e.first\n#define se e.second\n#define YES(c) cout<<((c)?\"YES\\n\":\"NO\\n\"),0\n#define Yes(c) cout<<((c)?\"Yes\\n\":\"No\\n\"),0\n#define POSSIBLE(c) cout<<((c)?\"POSSIBLE\\n\":\"IMPOSSIBLE\\n\"),0\n#define Possible(c) cout<<((c)?\"Possible\\n\":\"Impossible\\n\"),0\n#define o(p) cout<<p<<endl,0\n#define sp(p) cout<<p<<\" \",0\n#define no(p) cout<<p,0\n#define psort(l,r) if(l>r)swap(l,r);\ninline constexpr lint gcd(lint a,lint b){ if(!a||!b)return 0;while(b){ lint c=b;b=a%b;a=c; }return a; }\ntemplate<typename T>\ninline constexpr bool chmin(T &mn,const T &cnt){ if(mn>cnt){ mn=cnt;return 1; } else return 0; }\ntemplate<typename T>\ninline constexpr bool chmax(T &mx,const T &cnt){ if(mx<cnt){ mx=cnt;return 1; } else return 0; }\n#define ve(type) vector<type>\n#define fn(ty1,ty2,ex) [](ty1 l,ty2 r){ return(ex); }\n#define lfn(ex) [](lint l,lint r){ return(ex); }\ntemplate<typename T,class F>\nT fold(vector<T>a,F f,T e=0,lint l=0,lint r=linf){ for(lint i=l;i<r&&i<a.size();++i)e=f(e,a[i]);return e; }\n\n#pragma endregion\n\n#pragma region mint\n#define md_tmp template<uint_fast64_t md=1000000007>\nmd_tmp class modint{\n\tusing u64=uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const lint x=0) noexcept: a((x+md)%md){}\n\tconstexpr u64 &value() noexcept{ return a; }\n\tconstexpr const u64 &value() const noexcept{ return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept{\n\t\treturn modint(*this)+=rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept{\n\t\treturn modint(*this)-=rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept{\n\t\treturn modint(*this)*=rhs;\n\t}\n\tconstexpr modint operator^(const lint rhs) const noexcept{\n\t\treturn modint(*this)^=rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept{\n\t\treturn modint(*this)/=rhs;\n\t}\n\tconstexpr modint &operator+=(const modint rhs) noexcept{\n\t\ta+=rhs.a;\n\t\tif(a>=md)a-=md;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator-=(const modint rhs) noexcept{\n\t\tif(a<rhs.a)a+=md;\n\t\ta-=rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator*=(const modint rhs) noexcept{\n\t\ta=a*rhs.a%md;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator^=(const lint rhs) noexcept{\n\t\tif(!rhs)return *this=1;\n\t\tu64 exp=rhs-1;\n\t\tmodint base=this->a;\n\t\twhile(exp){\n\t\t\tif(exp&1)*this*=base;\n\t\t\tbase*=base;\n\t\t\texp>>=1;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator/=(const modint rhs) noexcept{\n\t\ta=(*this*(rhs^(md-2))).a;\n\t\treturn *this;\n\t}\n};\nusing mint=modint<>;\nmd_tmp istream& operator>>(istream& os,modint<md>& m){\n\tos>>m.a,m.a%=md;\n\treturn os;\n}\nmd_tmp ostream& operator<<(ostream& os,const modint<md>& m){\n\treturn os<<m.a;\n}\nmd_tmp modint<md> ncr(lint n,lint r){//O(r)//use bigncr\n\tif(n<r||n<0||r<0)return modint<md>(0);\n\tmodint<md>ncr_res=1,ncr_div=1;\n\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n\treturn ncr_res/ncr_div;\n}\n//lint ncri(lint n,lint r){//O(r)\n//\tif(n<r||n<0||r<0)return 0;\n//\tlint ncr_res=1,ncr_div=1;\n//\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n//\treturn ncr_res/ncr_div;\n//}\n#ifndef _AOJ_\ninline modint<> operator\"\"m(const unsigned long long n){ return modint<>(n); }\ninline lint operator\"\"z(const unsigned long long n){ return lint(n); }\n#endif\n#pragma endregion\n\n#pragma region P\nclass P{ public:lint f,s; P(lint a,lint b):f(a),s(b){}; P():f(0),s(0){}; };\nistream& operator>>(istream& os,P& p){ os>>p.f>>p.s;return os; }\nconstexpr bool operator<(const P& l,const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }\nconstexpr bool operator>(const P& l,const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }\nconstexpr bool operator<=(const P& l,const P& r){ return!(l.f-r.f?l.f>r.f:l.s>r.s); }\nconstexpr bool operator>=(const P& l,const P& r){ return!(l.f-r.f?l.f<r.f:l.s<r.s); }\n#pragma endregion\n\n#pragma region rec_lambda\n/*\nusage: \n\tauto res=rec([&](auto f,int n...){\n\t\tif(n<2)return n;\n\t\treturn f(n-=2);\n\t})(114514);\n*/\ntemplate<typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif  // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\nstatic inline constexpr decltype(auto)\nrec(F&& f) noexcept{\n\treturn[f = std::forward<F>(f)](auto&&... args) {\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}\n#pragma endregion\n\n#pragma region start\nstruct Start{\n\tStart(){\n#ifndef _C_INPUT_\n\t\tcin.tie(0),cout.tie(0);\n\t\tios::sync_with_stdio(0);\n#endif\n\t\tcout<<fixed<<setprecision(10);\n\t}\n} __start;\n#pragma endregion\n\n#pragma endregion\n\n#pragma region const\n#define MAXN 101010\n#define mod 1000000007\nconst ld pi=3.14159265358979323846;\nconst ld tau=(1.+sqrt(5))/2.;\nP d4[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\nP d8[8]={P(1,0),P(1,1),P(0,1),P(-1,1),P(-1,0),P(-1,-1),P(0,-1),P(1,-1)};\nconst string AUTO_YES = \"yes\";\nconst string AUTO_NO = \"no\";\nint cho(bool c){\n\treturn out((c?AUTO_YES:AUTO_NO));\n}\n#pragma endregion\n\n#pragma region solve\n\n#pragma region lib_unionfind_potentialized_notmine\n\ntemplate<class Abel> struct UnionFind{\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<Abel> diff_weight;\n\n\tUnionFind(int n = 1,Abel SUM_UNITY = 0){\n\t\tinit(n,SUM_UNITY);\n\t}\n\n\tvoid init(int n = 1,Abel SUM_UNITY = 0){\n\t\tpar.resize(n); rank.resize(n); diff_weight.resize(n);\n\t\tfor(int i = 0; i < n; ++i) par[i] = i,rank[i] = 0,diff_weight[i] = SUM_UNITY;\n\t}\n\n\tint root(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t} else{\n\t\t\tint r = root(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\n\tAbel weight(int x){\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tbool issame(int x,int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x,int y,Abel w){\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) return false;\n\t\tif(rank[x] < rank[y]) swap(x,y),w = -w;\n\t\tif(rank[x] == rank[y]) ++rank[x];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\n\tAbel diff(int x,int y){\n\t\treturn weight(y) - weight(x);\n\t}\n};\n\n#pragma endregion\n\nint solve(){\n\tlint n,q;in(n,q);\n\tUnionFind<lint> t(n);\n\twhile(q--){\n\t\tlint ty,x,y,z;in(ty);\n\t\tif(ty){\n\t\t\tin(x,y);\n\t\t\tif(t.issame(x,y))out(t.diff(x,y));\n\t\t\telse out(\"?\");\n\t\t} else{\n\t\t\tin(x,y,z);\n\t\t\tt.merge(x,y,z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#pragma endregion\n\n#pragma region main\n\nint main(){\n\tsolve();\n}\n\n#pragma endregion\n\n//sub-EOF\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 6;\nconst ll LLINF = 1e18 + 1;\n\n//WeightedUnionFind\ntemplate<typename T>\nstruct WeightedUnionFind {\nprivate:\n    vector<int> par;\n    vector<int> rank;\n    vector<T> diff_weight;\npublic:\n    WeightedUnionFind(int n) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = 0;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    T weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    // y - x = w\n    bool unite(int x, int y, T w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    // y - x\n    T diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<ll> wuni(n);\n    REP(i, q) {\n        int p; scanf(\"%d\", &p);\n        if (p == 0) {\n            int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n            wuni.unite(x, y, z);\n        }\n        else {\n            int x, y; scanf(\"%d %d\", &x, &y);\n            if (!wuni.same(x,y)) puts(\"?\");\n            else printf(\"%lld\\n\", wuni.diff(x,y));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); (i)++)\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); (i)--)\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\nusing namespace std;\n\ntemplate<class type> struct WeightedUnionFind{\n  vector<int> par;\n  vector<int> treerank;\n  vector<type> wdiff;\n  \n  WeightedUnionFind(int n){\n    par.resize(n); treerank.resize(n); wdiff.resize(n);\n    rep(i, n) par[i] = i, treerank[i] = 0, wdiff[i] = 0;\n  }\n  \n  int find(int x){\n    if(par[x] == x) return x;\n    int r = find(par[x]);\n    wdiff[x] += wdiff[par[x]];\n    return par[x] = r;\n  }\n  \n  type weight(int x){\n    find(x);\n    return wdiff[x];\n  }\n  \n  void unite(int x, int y, type w){\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(treerank[x] < treerank[y]) swap(x, y), w = -w;\n    if(treerank[x] == treerank[y]) treerank[x]++;\n    par[y] = x;\n    wdiff[y] = w;\n    return;\n  }\n  \n  type diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<int> uf(n);\n    rep(i, q){\n        int c; cin >> c;;\n        if(c){\n            int x, y; cin >> x >> y;\n            if(!uf.same(x, y)) cout << '?' << endl;\n            else cout << uf.diff(x, y) << endl;\n        }\n        else{\n            int x, y, z; cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstruct Node {\n\tint parent;\n\tint dif_to_parent;\n};\n\nint root(Node* nodes, int x)\n{\n\tif (nodes[x].parent == x) return x;\n\telse return root(nodes, nodes[x].parent);\n}\n\nbool isSame(Node* nodes, int x, int y)\n{\n\treturn root(nodes, x) == root(nodes, y);\n}\n\nvoid unite(Node* nodes, int x, int y, int dif)\n{\n\tint x_depth = 0;\n\tint y_depth = 0;\n\twhile (nodes[x].parent != x) {\n\t\tx_depth += nodes[x].dif_to_parent;\n\t\tx = nodes[x].parent;\n\t}\n\twhile (nodes[y].parent != y) {\n\t\ty_depth += nodes[y].dif_to_parent;\n\t\ty = nodes[y].parent;\n\t}\n\tif (x_depth + dif > y_depth) {\n\t\tnodes[y].parent = x;\n\t\tnodes[y].dif_to_parent = x_depth + dif - y_depth;\n\t} else {\n\t\tnodes[x].parent = y;\n\t\tnodes[x].dif_to_parent = y_depth - x_depth - dif;\n\t}\n}\n\nint difference(Node* nodes, int x, int y)\n{\n\tint x_depth = 0;\n\tint y_depth = 0;\n\tint rx = x;\n\tint ry = y;\n\twhile (nodes[rx].parent != rx) {\n\t\tx_depth += nodes[rx].dif_to_parent;\n\t\trx = nodes[rx].parent;\n\t}\n\twhile (nodes[ry].parent != ry) {\n\t\ty_depth += nodes[ry].dif_to_parent;\n\t\try = nodes[ry].parent;\n\t}\n\tnodes[x].parent = rx;\n\tnodes[x].dif_to_parent = x_depth;\n\tnodes[y].parent = ry;\n\tnodes[y].dif_to_parent = y_depth;\n\treturn y_depth - x_depth;\n}\n\nint main()\n{\t\n\tint n, q; std::cin >> n >> q;\n\t\n\tNode* nodes = new Node[n];\n\tfor (int i=0; i<n; i++) {\n\t\tnodes[i].parent = i;\n\t}\n\t\n\tfor (int i=0; i<q; i++) {\n\t\tint op, x, y, z;\n\t\tstd::cin >> op;\n\t\tif (op==0) {\n\t\t\tstd::cin >> x >> y >> z;\n\t\t\tunite(nodes, x, y, z);\n\t\t} else {\n\t\t\tstd::cin >> x >> y;\n\t\t\tif (isSame(nodes, x, y)) std::cout << difference(nodes, x, y) << std::endl;\n\t\t\telse std::cout << \"?\" << std::endl;\n\t\t}\n\t}\n\t\n\tdelete[] nodes;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename T >\nstruct WeightedUnionFind {\n  vector< int > data;\n  vector< T > ws;\n\n  WeightedUnionFind() {}\n\n  WeightedUnionFind(int sz) : data(sz, -1), ws(sz) {}\n\n  int find(int k) {\n    if(data[k] < 0) return k;\n    auto par = find(data[k]);\n    ws[k] += ws[data[k]];\n    return data[k] = par;\n  }\n\n  T weight(int t) {\n    find(t);\n    return ws[t];\n  }\n\n  bool unite(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) {\n      swap(x, y);\n      w *= -1;\n    }\n    data[x] += data[y];\n    data[y] = x;\n    ws[y] = w;\n    return true;\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  WeightedUnionFind< int > tree(N);\n  while(M--) {\n    int A, B, C, D;\n    cin >> A >> B >> C;\n    if(A == 0) {\n      cin >> D;\n      tree.unite(B, C, D);\n    } else {\n      if(tree.find(B) == tree.find(C)) {\n        cout << tree.diff(B, C) << endl;\n      } else {\n        cout << \"?\" << endl;\n      }\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 0;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] == 0) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\n//INSERT ABOVE HERE\n\ntemplate<typename T>\nclass Deque{\npublic:\n  T *val;\n  int sz;\n  int length;\n  int head, tail;\n  \n  Deque(){sz = 0, length = 0, val = new T[0];}\n  Deque(int size, T init = T()){\n    length = 1;\n    while(length < size) length *= 2;\n    val = new T[length];\n    sz = size;\n    head = 0;\n    tail = 0;\n    for(int i=0;i<size;i++) val[tail++] = init;\n  }\n  \n  Deque(const Deque &t){\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n  }\n\n  ~Deque(){\n    delete [] val;\n  }\n  \n  T& operator [] (int i){assert(0 <= i && i < sz);return val[(head + i)%length];}\n  T& operator [] (int i)const{assert(0 <= i && i < sz);return val[(head + i)%length];}\n  int size()const{return sz;}\n  int empty()const{return sz == 0;}\n\n  void increaseMemory(){\n    int length_ = length;\n    \n    length = length * 2;\n    if(length == 0) length = 1;\n    T *val2 = new T[length];\n    for(int i=0;i<sz;i++) val2[i] = val[(head + i)%length_];\n    head = 0;\n    tail = sz;\n    delete [] val;\n    val = val2;\n  };\n  \n  void push_back(T v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n  \n  void push_front(int v){\n    if(sz == length) increaseMemory();\n    sz++;\n    head--;\n    if(head == -1) head = length - 1;\n    val[head] = v;\n  }\n\n  void pop_back(){\n    assert(sz > 0);\n    sz--;\n    tail--;\n    if(tail == -1) tail = length - 1;\n  }\n  \n  void pop_front(){\n    assert(sz > 0);\n    sz--;\n    head++;\n    if(head == length) head = 0;\n  }\n};\ntemplate <typename T>\nusing vector = Deque<T>;\n\nclass WeightedUnionFind{\npublic:\n  int V;\n  vector<int> par, rnk, diff, sz;\n  WeightedUnionFind():V(-1){}\n  WeightedUnionFind(int V):V(V),par(V),rnk(V,0),diff(V,0),sz(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x] == x) return x;\n    int p = find(par[x]);\n    diff[x] = diff[x] + diff[ par[x] ];\n    return par[x] = p;\n  }\n\n  //頂点xは頂点yよりもz大きい\n  void relate(int x,int y,int z){\n    int sx = x, sy = y;\n    x = find(x), y = find(y);\n    if(x == y) assert(getDiff(sx,sy) == z);\n    if(x == y)return;\n    \n    if(rnk[x] < rnk[y]) {\n      par[x] = y;\n      sz[y] += sz[x];\n      diff[x] = z + (-diff[sx] + diff[sy]);\n    }\n    else{\n      par[y] = x;\n      sz[x] += sz[y];\n      diff[y] = -z + (diff[sx] - diff[sy]);\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  int getDiff(int u,int v){\n    assert(same(u,v));\n    return diff[u] - diff[v];\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  int size(int x){return sz[find(x)];}\n  \n};\n\n\nsigned main(){\n  int n;\n  std::cin>>n;\n  WeightedUnionFind wuf(n);\n  \n  int q;\n  std::cin>>q;\n  while(q--){\n    int cmd, x, y, z;\n    std::cin>>cmd >> y >> x;\n    if(cmd == 0){\n      std::cin>>z;\n      wuf.relate(x,y,z);\n    }\n    if(cmd == 1){\n      if(!wuf.same(x, y)) std::cout<<\"?\"<<std::endl;\n      else std::cout<<wuf.getDiff(x, y)<<std::endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\n/**\n * 重み付きUnionFind\n * Abelは重さの型UnionFind<int>とかで\n * 0-indexed\n */\ntemplate<class Abel>\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    /**\n     * 初期化\n     * @param n\n     * @param SUM_UNITY\n     */\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    /**\n     * 大きさnで初期化\n     * @param n\n     * @param SUM_UNITY\n     */\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    /**\n     * 自分の所属しているグループを返す\n     * @param x\n     * @return\n     */\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            int r = find(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    /**\n     * 重み\n     * @param x\n     * @return\n     */\n    Abel weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n\n    /**\n     * xとyが同じグループに所属しているかを返す\n     * @param x\n     * @param y\n     * @return\n     */\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    /**\n     * weight(y) = weight(x) + w となるように x と y を統合\n     * yにxを統合\n     * @param x\n     * @param y\n     * @param w\n     * @return\n     */\n    bool unite(int x, int y, Abel w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    /**\n     * (yの重さ) - (xの重さ)を返す\n     * @param x\n     * @param y\n     * @return\n     */\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    UnionFind<int> uf(n);\n    while (q--) {\n        int cmd;\n        cin >> cmd;\n        if (cmd) {\n            int x, y;\n            cin >> x >> y;\n            if (uf.same(x, y)) {\n                cout << uf.diff(x, y) << endl;\n            } else {\n                cout << \"?\" << endl;\n            }\n        } else {\n            int x, y, z;\n            cin >> x >> y >> z;\n//            cout << uf.unite(x, y, z) << endl;\n            uf.unite(x, y, z);\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nint* pa;\nint* v;\nint n;\nint q;\nqueue<int> qr;\nvoid init(int n) {\n\tpa = new int[n];\n\tv = new int[n];\n\tfor (int i = 0; i < n; ++i) {\n\t\tpa[i] = i;\n\t\tv[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (x != pa[x]) {\n\t\tint p = pa[x];\n\t\tpa[x] = find(pa[x]);\n\t\tv[x] += v[p];\n\t}\n\treturn pa[x];\n}\n\nvoid unite(int x, int y, int z) {\n\tint px = find(x);\n\tint py = find(y);\n\tif (px != py) {\n\t\tpa[px] = py;\n\t\tv[px] = v[y] - v[x] + z;\n\t}\n}\n\nbool check(int x, int y) {\n\tint px = find(x);\n\tint py = find(y);\n\treturn px == py;\n}\n\nint main() {\n\tcin >> n >> q;\n\tinit(n);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint op;\n\t\tcin >> op;\n\t\tif (op == 0) {\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tunite(x, y, z);\n\t\t}\n\t\telse {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif (check(x, y)) {\n\t\t\t\tqr.push(v[x] - v[y]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqr.push(INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!qr.empty())\n\t{\n\t\tint t = qr.front();\n\t\tif (t == INT_MAX)\n\t\t\tcout << \"?\" << endl;\n\t\telse\n\t\t\tcout << t << endl;\n\t\tqr.pop();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\ntypedef long long LL;\n\nconst int N = 1e5 + 1;\n\nint pa[N];\nLL v[N];\n\nvoid init() {\n  for (int i = 0; i < N; ++i) {\n    pa[i] = i;\n    v[i] = 0;\n  }\n}\n\nint find(int x) {\n  if (x != pa[x]) {\n    int p = pa[x];\n    pa[x] = find(pa[x]);\n    v[x] += v[p];\n  }\n  return pa[x];\n}\n\nvoid unite(int x, int y, int z) {\n  int px = find(x);\n  int py = find(y);\n  if (px != py) {\n    pa[px] = py;\n    v[px] = v[y] - v[x] + z;\n  }\n}\n\nbool check(int x, int y) {\n  int px = find(x);\n  int py = find(y);\n  return px == py;\n}\n\nint main() {\n  int n, q;\n  while (std::cin >> n >> q) {\n    init();\n    while (q --) {\n      int op;\n      std::cin >> op;\n      if (op == 0) {\n        int x, y, z;\n        std::cin >> x >> y >> z;\n        unite(x, y, z);\n      } else {\n        int x, y;\n        std::cin >> x >> y;\n        if (check(x, y)) {\n          std::cout << v[x] - v[y] << std::endl;\n        } else {\n          std::cout << \"?\" << std::endl;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <conio.h>\nusing namespace std;\n\n#define DEBUG 0\n\nint getParent(int x, int weight);\nvoid unite(int x, int y, int z);\nint diff(int x, int y);\nbool isSame(int x, int y);\n\nint n, q;\n\nvector<int> numbers;\nvector<int> weights;\nvector<int> num_rank;\n\nint main() {\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnumbers.push_back(i);\n\t\tweights.push_back(0);\n\t\tnum_rank.push_back(0);\n\t}\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\n\t\tcin >> com >> x >> y;\n\n\t\tswitch(com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\tunite(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (isSame(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\n\t\t}\n\n#if DEBUG == 1\n\n\t\tif (com == 0)\n\t\t\tcout << \"unite\" << \" : \";\n\t\telse\n\t\t\tcout << \"     \" << \" : \";\n\t\tcout << x << \" \" << y << \" \" << z << endl;\n\n\t\tfor(int i = 0; i < n; ++i) \n\t\t\tcout << i << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << numbers[i] << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << weights[i] << \" \";\n\n\t\tcout << endl << endl;\n\t\tgetch();  \n#endif\n\t}\n\n\n\treturn 0;\n}\n\n\nint getParent(int x) {\n\n\tif (numbers[x]!= x) {\n\t\tint r = getParent(numbers[x]);\n\n#if DEBUG == 1\n\t\tcout << \"root weights = \" << weights[numbers[x]] << endl;\n#endif\n\t\t\n\t\tweights[x] += weights[numbers[x]];\n\t\tnumbers[x] = r;\n\t}\n\t\n\treturn numbers[x];\n\n}\n\nvoid unite(int x, int y, int w) {\n\n\n\tint x_p = getParent(numbers[x]);\n\tint y_p = getParent(numbers[y]);\n\n\tw += weights[x];\n\tw -= weights[y];\n\n#if DEBUG == 1\n\tcout << x_p << \"(\" << weights[x_p] << \"), \" << y_p << \"(\" << weights[y_p] << \")\" << endl;\n#endif\n\t/*\n\tif (num_rank[x_p] < num_rank[y_p]) {\n\t\tswap(x_p, y_p);\n\t\tw *= -1;\n\t}\n\tif (num_rank[x_p] == num_rank[y_p])\n\t\t++num_rank[x_p];\n\t*/\n\tnumbers[y_p] = x_p;\n\tweights[y_p] = w;\n\t\n\n}\n\nbool isSame(int x, int y) {\n\n\treturn getParent(x) == getParent(y);\n\n}\n\n\nint diff(int x, int y) {\n\n\tgetParent(x);\n\tgetParent(y);\n\n#if DEBUG == 1\n\tcout << y << \"(\" << weights[y] << \") - \" << x << \"(\" << weights[x] << \")\" << endl;\n#endif\n\t\n\treturn weights[y] - weights[x];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n       z -= diffWeight[x];\n       z += diffWeight[y];\n      //z += diffWeight[y] - diffWeight[x];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << getWeight(x)-getWeight(y) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  // for(int i=0 ;  i<n ; ++i){\n  //   cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct WeightedUnionFind{\n  vector< pair<int, long long> > data;\n  WeightedUnionFind(int n) : data(n, pair<int,long long>(-1,0LL)) {}\n  bool unite(int x, int y, long long w){//weight(y)-weight(x) = w;\n    int x_ = find(x), y_ = find(y);\n    if(x_ == y_) return true;\n    if(data[y_].first < data[x_].first){\n      swap(x_,y_);\n      swap(x,y);\n      w *= -1LL;\n    }\n    data[x_].first += data[y_].first;//高さを更新\n    data[y_].first = x_;//親を更新\n    data[y_].second += w + rel_weight(x) - rel_weight(y);\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x].first < 0) return x;\n    int p = find(data[x].first);\n    data[x].second += data[data[x].first].second;\n    data[x].first = p;\n    return data[x].first;\n  }\n  long long rel_weight(int x){\n    return data[x].second;\n  }\n};\n\nint main(){\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind wuf(n);\n  while(q--){\n    int t, x, y, z;\n    cin >> t >> x >> y;\n    if(t){\n      if(wuf.same(x,y)) cout << wuf.rel_weight(y) - wuf.rel_weight(x) << endl;\n      else cout << \"?\" << endl;\n      continue;\n    }\n    cin >> z;\n    wuf.unite(x,y,z);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 100001;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] > 100000) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nclass WeightedUnionFind{\npublic:\n  int n;\n  vector<int> u;\n  vector<Int> weight;\n  WeightedUnionFind(int n = 0):n(n){\n    u = vector<int>(n);\n    weight = vector<Int>(n,0);\n    for(int i = 0;i < n;i++)u[i] = i;\n  }\n  int r(int x){\n    if(u[x] == x)return x;\n    r(u[x]);\n    weight[x] += weight[u[x]];\n    return u[x] = r(u[x]);\n  }\n\n  Int dif(Int x, Int y){\n    if(r(x) != r(y))return INF;\n    return weight[x] - weight[y];\n  }\n\n  //x - y == w\n  bool isOK(int x, int y, Int w){\n    if(r(x) != r(y))return false;\n    return dif(x,y) == 0;\n  }\n\n  int unite(int x, int y, Int w){\n    r(x);\n    r(y);\n    w += weight[y];\n    w -= weight[x];\n    x = r(x);\n    y = r(y);\n    u[x] = y;\n    weight[x] = w;\n  }\n};\n\nInt n, q, com, x, y, z;\nint main(){\n  cin >> n >> q;\n  WeightedUnionFind wuf(n);\n  while(q--){\n    cin >> com;\n    if(com == 0){\n      cin >> x >> y >> z;\n      wuf.unite(y, x, z);\n    }\n    else{\n      cin >> x >> y;\n      if(wuf.r(x) != wuf.r(y))cout << \"?\" << endl;\n      else cout << wuf.weight[y] - wuf.weight[x] << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tvoid unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tz += Weight[y] - Weight[x];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = z;\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = -z;\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tlong long cost(int x, int y){ // call only if same(x, y) == true\n\t\treturn Weight[x] - Weight[y];\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y;\n\t\t\tlong long z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif(wuf.same(x, y)) cout << wuf.cost(x, y) << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MOD 1000000007\n#define INF 1e9\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    UnionFind<int> uf(n);\n    rep(i,q){\n        int t;\n        cin>>t;\n        if(t==0){\n            int x,y,z;\n            cin>>x>>y>>z;\n            uf.merge(x,y,z);\n        }\n        else{\n            int x,y;\n            cin>>x>>y;\n            if(!uf.issame(x,y)) cout<<\"?\"<<endl;\n            else cout<<uf.diff(x,y)<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nclass PotentialUnionFind {\n\nprivate:\n\tvector<int> nums;\n\tvector<int> weights;\n\tvector<int> rank;\n\npublic:\n\tPotentialUnionFind(int n) : weights(vector<int>(n, 0)), rank(vector<int>(n, 0)) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tnums.push_back(i);\n\t\t}\n\n\t}\n\n\tint find(int x) {\n\n\t\tif (nums[x] == x)\n\t\t\treturn x;\n\n\t\tint root = find(nums[x]);\n\t\tweights[x] += weights[nums[x]];\n\t\treturn nums[x] = root;\n\n\t}\n\n\tbool isSame(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unit(int x, int y, int w) {\n\n\t\tint x_root = find(x);\n\t\tint y_root = find(y);\n\n\t\tw += weights[x];\n\t\tw -= weights[y];\n\n\t\tif (rank[x_root] < rank[y_root]) {\n\t\t\tswap(x_root, y_root);\n\t\t\tw *= -1;\n\t\t}\n\t\telse if (rank[x_root] == rank[y_root])\n\t\t\t++rank[x_root];\n\n\t\tnums[y_root] = x_root;\n\t\tweights[y_root] = w;\n\n\t}\n\n\tint diff(int x, int y) {\n\t\treturn weights[y] - weights[x];\n\t}\n\n\n\tvoid print() {\n\n\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tcout << setw(4) << i << \" \";\n\n\t\t}\n\t\tcout << endl;\n\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tcout << setw(4) << nums[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\n\t\tfor (int i = 0; i < weights.size(); ++i) {\n\t\t\tcout << setw(4) << weights[i] << \" \";\n\t\t}\n\t\tcout << endl << endl;\n\t}\n};\n\nint main() {\n\n\tint n, q;\n\n\tcin >> n >> q;\n\n\tPotentialUnionFind tree(n);\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\t\tcin >> com >> x >> y;\n\n\t\tswitch (com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\ttree.unit(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (tree.isSame(x, y))\n\t\t\t\tcout << tree.diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// cout << x << \" \" << y << \" \" << z << endl;\n\t\t// tree.print();\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << \"(\";\n    os << P.first;\n    os << \" , \";\n    os << P.second;\n    os << \")\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n    os<<endl;\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, map<T,S> const&M){\n    for(auto e:M){\n        os<<e;\n    }\n    os<<endl;\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\nstruct WeightedUnionFind{\n    vector<int> parent,rank;\n    vector<int64> weight;\n    WeightedUnionFind(size_t N){\n        parent.resize(N);\n        REP(i,N) parent[i]=i;\n        rank.assign(N,0);\n        weight.assign(N,0);\n    }\n\n    int get_root(int v){\n        if(parent[v]==v) return v;\n        int par = get_root(parent[v]);\n        weight[v] += weight[parent[v]];\n        parent[v] = par;\n        return par;\n    }\n\n    void unite(int x,int y,int64 w){\n        int root_x = get_root(x), root_y = get_root(y);\n        if(root_x == root_y) return;\n        //xの木の高さ < yの木の高さ\n        if(rank[root_x] < rank[root_y]){\n            parent[root_x] = root_y;\n            weight[root_x] = w - weight[x] + weight[y];\n        }else{\n            parent[root_y] = root_x;\n            weight[root_y] = -w - weight[y] + weight[x];\n            //木の高さが同じなら片方\n            if(rank[root_x] == rank[root_y]) rank[root_x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return get_root(x) == get_root(y);\n    }\n\n    // xからyへのコスト\n    int64 diff(int x,int y){\n        return weight[x] - weight[y];\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int N,Q;\n    cin >> N >> Q;\n\n    WeightedUnionFind UF(N);\n    int a,x,y,w;\n    REP(i,Q){\n        cin >> a;\n        if(a){\n            cin >> x >> y;\n            if(UF.same(x,y)) cout << UF.diff(x,y) << bn;\n            else cout << \"?\" << bn;\n        }else{\n            cin >> x >> y >> w;\n            if(not UF.same(x,y)) UF.unite(x,y,w);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\n#define MK make_pair\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T>\nclass weight_uft{\nprivate:\n    typedef pair<ull,T> parent_weight;\n    vector<pair<parent_weight,ull>> uft; //{parent_weight,node}\n    ull size;\n    T err;\npublic:\n    weight_uft(ull size,T err=(T)(1e9)):size(size),err(err){\n        uft.resize(size);\n        for(int i=0;i<size;i++){\n            uft[i]={{i,(T)0},1};\n        }\n    }\n    \n    parent_weight search(ull where){\n        if(uft[where].F.F==where){return uft[where].F;}\n        parent_weight P=search(uft[where].F.F);\n        uft[where].F.F=P.F;\n        uft[where].F.S+=P.S;\n        return uft[where].F;\n    }\n    \n    bool same(ull a,ull b){\n        if(search(a).F==search(b).F){return true;}\n        return false;\n    }\n    \n    T dist(ull from,ull to){\n        if(!same(from,to)){return err;}\n        return search(from).S-search(to).S;\n    }\n    \n    bool add(ull from,ull to,T d){\n        if(same(from,to) && dist(from,to)!=d){return false;}\n        if(same(from,to)){return true;}\n        parent_weight f=search(from);\n        parent_weight t=search(to);\n        if(uft[t.F].S>uft[f.F].S){\n            uft[f.F].F.F=t.F;\n            uft[f.F].F.S=d-f.S+t.S;\n            uft[t.F].S=uft[t.F].S+uft[f.F].S;\n        }\n        else{\n            uft[t.F].F.F=f.F;\n            uft[t.F].F.S=f.S-t.S-d;\n            uft[f.F].S=uft[f.F].S+uft[t.F].S;\n        }\n        return true;\n    }\n};\n\n\n\nint main(){\n    ll n,q;\n    cin>>n>>q;\n    weight_uft<ll> uft(n,E);\n    while(q--){\n        ll c;\n        cin>>c;\n        if(c){\n            ll a,b;\n            cin>>a>>b;\n            if(!uft.same(a,b)){cout<<\"?\"<<endl;}\n            else{cout<<uft.dist(a,b)<<endl;}\n        }\n        else{\n            ll a,b,d;\n            cin>>a>>b>>d;\n            uft.add(a,b,d);\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\tif (flag[x] == -1 && flag[y] == -1) {\n\t\t\t\tset<int>st;\n\n\t\t\t\tst.insert(x);\n\t\t\t\tst.insert(y);\n\t\t\t\t//st.insert({ x,y });\n\n\t\t\t\tnum.push_back(st);\n\t\t\t\tflag[x] = num.size() - 1;\n\t\t\t\tflag[y] = num.size() - 1;\n\t\t\t\t//flag[y] = flag[x] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\telse if (flag[x] != -1 && flag[y] != -1) {\n\t\t\t\t//if (flag[x] == flag[y]) {\n\t\t\t\t\t/*\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}*/\n\t\t\t\t//}\n\t\t\t\t//else if (flag[x] < flag[y]) {\n\t\t\t\t/*\n\t\t\t if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}*/\n\t\t\t\t//else if (flag[x] > flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[y]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[y];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[xx].erase(num[xx].begin(), num[xx].end());\n\n\t\t\t\t//}\n\t\t\n\t\t\t}\n\t\t\telse if (flag[x] != -1) {\n\t\t\t\tnum[flag[x]].insert(y);\n\t\t\t\tflag[y] = flag[x];\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\telse if (flag[y] != -1) {\n\t\t\t\tnum[flag[y]].insert(x);\n\t\t\t\tflag[x] = flag[y];\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass DisjointSet {\npublic:\n\tvector<int> p, r, w;\n\t\n\tDisjointSet(){}\n\tDisjointSet(int size){\n\t\tfor(int i=0;i<size;i++){\n\t\t\tmakeSet(i);\n\t\t}\n\t}\n\t\n\tvoid makeSet(int x){\n\t\tp.push_back(x);\n\t\tr.push_back(0);\n\t\tw.push_back(0);\n\t}\n\t\n\tvoid relate(int x, int y, int z){\n\t\tlink(find(x),find(y),z-w[x]+w[y]);\n\t}\n\t\n\tvoid link(int x, int y, int cost){\n\t\tif(r[x]<r[y]){\n\t\t\tp[y]=x;\n\t\t\tw[y]-=cost;\n\t\t} else {\n\t\t\tp[x]=y;\n\t\t\tw[x]+=cost;\n\t\t\tif(r[x]==r[y]){\n\t\t\t\tr[y]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x)==find(y);\n\t}\n\t\n\tint sum(int x){\n\t\tint sum=0;\n\t\tint cur=x;\n\t\twhile(cur!=p[cur]){\n\t\t\tsum+=w[cur];\n\t\t\tcur=p[cur];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tint find(int x){\n\t\tif(x!=p[x]){\n\t\t\tint tmp=find(p[x]);\n\t\t\tw[x]+=w[p[x]];\n\t\t\tp[x]=tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tDisjointSet ds(n);\n\tfor(int i=0;i<q;i++){\n\t\tint c, x, y, z;\n\t\tcin >> c >> x >> y;\n\t\tif (c == 0) {\n\t\t\tcin >> z;\n\t\t\tds.relate(x, y, z);\n\t\t} else {\n\t\t\tif (!ds.same(x, y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t} else {\n\t\t\t\tint sumX = ds.sum(x);\n\t\t\t\tint sumY = ds.sum(y);\n\t\t\t\tcout << sumX - sumY << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n \nvector<int> p,rank,cost;\n \n \nint find(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = find(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n \nvoid connect(int x, int y, int z) {\n    int rootx = find(x), rooty = find(y);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n\nvoid Set(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n \nint main() {\n    int n,q,com,x,y,z;\n    scanf(\"%d %d\", &n, &q);\n    for(int i=0; i<n; i++) Set(i);\n    for(int i=0; i<q; i++) {\n        scanf(\"%d %d %d\", &com, &x, &y);\n        if(com == 1) {\n            if(find(x) == find(y)) \n            {\n                cout << cost[y]-cost[x] << endl;\n            }\n            else {\n                cout << '?' << endl;\n            }\n        }\n        else {\n            \n        scanf(\"%d\", &z);\n            connect(x,y,z);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nstruct QuickFind {\n    vector<int> i2g;\n    vector< vector<int> > g2i;\n    vector<long long int> weight;\n    int N;\n\n    QuickFind(int N_) {\n        N = N_;\n        i2g.resize(N); g2i.resize(N);\n        weight.resize(N);\n\n        for(int i=0; i<N; i++) {\n            i2g[i] = i;\n            g2i[i] = vector<int>{i};\n        }\n    }\n\n    bool same(int u, int v) {\n        return i2g[u] == i2g[v];\n    }\n\n    long long int query(int u, int v) {\n        assert(same(u, v));\n        return weight[v] - weight[u];\n    }\n\n    void merge(int u, int v, int w) {\n        if(same(u, v)) return;\n        int ru = i2g[u], rv = i2g[v];\n\n        if(g2i[rv].size() > g2i[ru].size()) {\n            swap(ru, rv); swap(u, v);\n            w = -w;\n        }\n\n        long long int prev = weight[v];\n        weight[v] = weight[u] + w;\n\n        for(auto e : g2i[rv]) {\n            i2g[e] = ru;\n            if(e == v) continue;\n            int diff = weight[e] - prev;\n            weight[e] = weight[v] + diff;\n            g2i[ru].push_back(e);\n        }\n\n        g2i[rv].clear();\n    }\n};\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    QuickFind qf(N);\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int u, v, w; cin >> u >> v >> w;\n            qf.merge(u, v, w);\n        }\n        else {\n            int u, v; cin >> u >> v;\n            if(qf.same(u, v)) cout << qf.query(u, v) << endl;\n            else cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\tmap<int, int>mp;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\tmp.insert(pair<int, int>(x, 0));\n\t\t\tmp.insert(pair<int, int>(y, 0));\n\n\t\t\tif (flag[x] == -1 && flag[y] == -1) {\n\t\t\t\tset<int>st;\n\n\t\t\t\tst.insert(x);\n\t\t\t\tst.insert(y);\n\t\t\t\t//st.insert({ x,y });\n\n\t\t\t\tnum.push_back(st);\n\t\t\t\tflag[x] = num.size() - 1;\n\t\t\t\tflag[y] = num.size() - 1;\n\t\t\t\t//flag[y] = flag[x] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\telse if (flag[x] != -1 && flag[y] != -1) {\n\t\t\t\t//if (flag[x] == flag[y]) {\n\t\t\t\t\t/*\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}*/\n\t\t\t\t//}\n\t\t\t\t//else if (flag[x] < flag[y]) {\n\t\t\t\t/*\n\t\t\t if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}*/\n\t\t\t\t//else if (flag[x] > flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[y]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[y];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\tauto itr = mp.find(xx);        // \"xyz\" が設定されているか？\n\t\t\t\t\tif (itr != mp.end()) {\n\t\t\t\t\t\t//設定されている場合の処理\n\t\t\t\t\t\titr++;\n\t\t\t\t\t\tfor (; itr != mp.end(); itr++) {\n\t\t\t\t\t\t\tflag[(*itr).first]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//設定されていない場合の処理\n\t\t\t\t\t}\n\t\t\t\t\t//num[xx].erase(num[xx].begin(), num[xx].end());\n\t\t\t\t\tnum.erase(num.begin() + xx);\n\n\t\t\t\t//}\n\t\t\n\t\t\t}\n\t\t\telse if (flag[x] != -1) {\n\t\t\t\tnum[flag[x]].insert(y);\n\t\t\t\tflag[y] = flag[x];\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\telse if (flag[y] != -1) {\n\t\t\t\tnum[flag[y]].insert(x);\n\t\t\t\tflag[x] = flag[y];\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\tmp.insert(pair<int, int>(x, 0));\n\t\t\tmp.insert(pair<int, int>(y, 0));\n\n\t\t\tif (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \": \" << x << '\\n';\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\n\n#ifndef UNION_FIND_TREE\n#define UNION_FIND_TREE\ntemplate<typename T>\nclass UnionFindTree{\n\tprivate:\n\t\tint N;\n\t\tvector<int> parent, rank, size;\n\t\tvector<T> diff_weight;\n\n\tpublic:\n\t\tvoid init(){\n\t\t\tfor(int i = 0; i < (int) N; i++){\n\t\t\t\tparent[i] = i; rank[i] = 0; size[i] = 1; diff_weight[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tUnionFindTree(int N): N(N), parent(N), rank(N), size(N), diff_weight(N){\n\t\t\tinit();\n\t\t}\n\n\t\tint root(int x){\n\t\t\tif(parent[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else{\n\t\t\t\tint r = root(parent[x]);\n\t\t\t\tdiff_weight[x] += diff_weight[parent[x]];\n\t\t\t\treturn parent[x] = r;\n\t\t\t}\n\t\t}\n\n\t\tT weight(int x){\n\t\t\troot(x);\n\t\t\treturn diff_weight[x];\n\t\t}\n\n\t\tT diff(int x, int y){\n\t\t\treturn weight(y) - weight(x);\n\t\t}\n\n\t\t// weight(y) = weight(x) + w となるようにmergeする\n\t\tbool unite(int x, int y, T w = 0){\n\t\t\tw += weight(x); w -= weight(y);\n\t\t\tx = root(x); y = root(y);\n\t\t\tif(x == y) return weight(y) - weight(x) == w;\n\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tswap(x, y);\n\t\t\t\tw = -w;\n\t\t\t}\n\n\t\t\tparent[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tdiff_weight[y] = w;\n\t\t\treturn true;\n\t\t}\n\n\t\tbool isSame(int x, int y){\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\t\n\t\tint count(int x){\n\t\t\treturn size[root(x)];\n\t\t}\n};\n#endif\n\n\nint main(void){\n\tint n, q;\n\tcin >> n >> q;\n\n\tUnionFindTree<int> ut(n);\n\tvector<string> vec;\n\tfor(int i = 0; i < q; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tif(k){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvec.push_back(ut.isSame(x, y) ? to_string(ut.diff(x, y)) : \"?\");\n\t\t}else{\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tut.unite(x, y, z);\n\t\t}\n\t}\n\n\tfor(auto res: vec) cout << res << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n\nusing namespace std;\n\nvector<int> p, r, weight;\n\nvoid makeSet(int x){\n  p[x] = x;\t\t\t\n  r[x] = 0;\n  weight[x] = 0;\n}\n\nint findSet(int x){\n\n  if(x != p[x])\n    p[x] = findSet(p[x]);\n\n    weight[x] += weight[p[x]];\n\n  return p[x];\n}\n \n\nvoid relate(int x, int y, int z){\n  int rootx = findSet(x), rooty = findSet(y);\n\n  if(r[rooty] < r[rootx]){\n    p[rooty] = rootx;\n    weight[rooty] = z - weight[y] + weight[x];\n  }\n  else{\n    p[rootx] = rooty;\n    weight[rootx] = -z - weight[x] + weight[y];\n    if(r[rootx] == r[rooty]) r[rooty] += 1;\n  }\n\n}\n\n\nint main(){\n\n  int N, Q, com, x, y, z, i;\n\n  cin >> N >> Q;\n\n  p.resize(N);\n  r.resize(N);\n  weight.resize(N);\n\n  for(i=0; i<N; i++) makeSet(i);\n\n  for(i=0; i<Q; i++){\n    cin >> com >> x >> y;\n    if(com == 0){\n      cin >> z;\n      relate(x, y, z);\n    }\n    else if(com == 1){\n      if(findSet(x) == findSet(y)) cout << weight[y] - weight[x] << endl;\n      else cout << '?' << endl;\n    }\n \n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <utility>\n\ntemplate <class Abelian, template <class T> class Container>\nclass potentialized_union_find {\n\tclass node_type;\n\npublic:\n\tusing value_structure = Abelian;\n\tusing value_type = typename value_structure::value_type;\n\tusing container_type = Container<node_type>;\n\tusing size_type = typename container_type::size_type;\n\nprotected:\n\tcontainer_type c;\n\nprivate:\n\tclass node_type {\n\tpublic:\n\t\ttypename potentialized_union_find::size_type parent, size;\n\t\ttypename potentialized_union_find::value_type value;\n\t};\n\tvalue_type potential(size_type x) {\n\t\tvalue_type ret = value_structure::identity();\n\t\twhile (x != c[x].parent) {\n\t\t\tc[x].value = value_structure::operation(c[x].value, c[c[x].parent].value);\n\t\t\tret = value_structure::operation(ret, c[x].value);\n\t\t\tx = c[x].parent = c[c[x].parent].parent;\n\t\t}\n\t\treturn ::std::move(ret);\n\t}\n\npublic:\n\tpotentialized_union_find() : c() {}\n\texplicit potentialized_union_find(const size_type size)\n\t\t: c(size, { 0, 1, value_structure::identity() }) {\n\t\tfor (size_type i = 0; i < size; ++i)\n\t\t\tc[i].parent = i;\n\t}\n\n\tbool empty() const { return c.empty(); }\n\tsize_type size() const { return c.size(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (x != c[x].parent) {\n\t\t\tc[x].value = value_structure::operation(c[x].value, c[c[x].parent].value);\n\t\t\tx = c[x].parent = c[c[x].parent].parent;\n\t\t}\n\t\treturn x;\n\t}\n\tvalue_type diff(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tassert(same(x, y));\n\t\treturn value_structure::operation(potential(y),\n\t\t\tvalue_structure::inverse(potential(x)));\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn c[find(x)].size;\n\t}\n\n\t::std::pair<size_type, size_type> unite(size_type x, size_type y,\n\t\tvalue_type d) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\td = value_structure::operation(value_structure::operation(d, potential(x)),\n\t\t\tvalue_structure::inverse(potential(y)));\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x != y) {\n\t\t\tif (c[x].size < c[y].size) {\n\t\t\t\t::std::swap(x, y);\n\t\t\t\td = value_structure::inverse(d);\n\t\t\t}\n\t\t\tc[x].size += c[y].size;\n\t\t\tc[y].parent = x;\n\t\t\tc[y].value = ::std::move(d);\n\t\t}\n\t\treturn { x, y };\n\t}\n};\n\ntemplate <class T> class plus_abelian {\npublic:\n\tusing value_type = T;\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn x + y;\n\t}\n\tstatic value_type identity() { return value_type(0); }\n\tstatic value_type inverse(const value_type &x) { return -x; }\n\tstatic value_type reverse(const value_type &x) { return x; }\n};\n\n#include<iostream>\n#include<vector>\ntemplate<class T>\nusing vec = ::std::vector<T>;\n\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tpotentialized_union_find<plus_abelian<int>, vec> T(n);\n\twhile (q--) {\n\t\tint t, x, y, z;\n\t\tstd::cin >> t >> x >> y;\n\t\tif (t) {\n\t\t\tif (T.same(x, y))\n\t\t\t\t::std::cout << T.diff(x, y) << ::std::endl;\n\t\t\telse\n\t\t\t\t::std::cout << \"?\" << ::std::endl;\n\t\t}\n\t\telse {\n\t\t\t::std::cin >> z;\n\t\t\tT.unite(x, y, z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RFOR(i,a,b) for(int i=(int)b-1;i>=(int)a;--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n#define debug(x) cerr << #x << \":\" << x << endl;\n#define OK(ok) cout << (ok ? \"Yes\" : \"No\") << endl;\ntypedef long long ll;\n\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail) {\n  cin >> head; CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\nconst int INF = 1e9 + 1;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 1;\n\ntemplate< class Abel > struct UnionFind {\n  vector< int > par;\n  vector< int > rank;\n  vector< Abel > diff_weight;\n  \n  UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(int n = 1, Abel SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n), diff_weight.resize(n);\n    for(int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n  \n  int root(int x) {\n    if (par[x] == x) return x;\n    // 累積和をとる\n    int r = root(par[x]);\n    diff_weight[x] += diff_weight[par[x]];\n    return par[x] = r;\n  }\n\n  Abel weight(int x) {\n    // 経路圧縮をする\n    root(x);\n    return diff_weight[x];\n  }\n\n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n\n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  // weight(x) - weight(y) = wとなるようにmerge\n  bool merge(int x, int y, Abel w) {\n    // xとyそれぞれについてrootとの重み付き補正\n    w += weight(x); w -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    if (rank[x] == rank[y]) {\n      ++rank[x];\n    }\n    par[y] = x;\n\n    // xがyの大和になるので、xとyの差分をdiff_weight[y]に記録\n    diff_weight[y] = w;\n    return true;\n  }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  CIN(N, Q);\n  UnionFind< int > uf(N + 1);\n  \n  REP(qi, Q) {\n    CIN(c);\n    if (c == 0) {\n      // merge\n      CIN(x, y, z);\n      uf.merge(x, y, z);\n    } else {\n      string ans;\n      // judge\n      CIN(x, y);\n      if (!uf.issame(x, y)) {\n\t// 差が判断できないのは親が異なる時\n\tans = \"?\";\n      } else {\n\tans = to_string(uf.diff(x, y));\n      }\n      cout << ans << endl;\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nenum query{\n    RELATE,DIFF\n};\n\ntemplate<unsigned long long SIZE> class unionFind{\n    protected:\n        long long uni[SIZE];\n        long long diff_weight[SIZE];\n    public:\n        unionFind(){\n            for(int i=0;i<SIZE;i++){\n                uni[i]=-1;\n                diff_weight[i]=0;\n            }\n        }\n        unsigned long long root(unsigned long long a){\n            if(a>=SIZE) throw std::range_error(\"与えられたインデックスが木の範囲外です\");\n            if(uni[a]<0) return a;\n            else{\n                unsigned long long r=root(uni[a]);\n                diff_weight[a]+=diff_weight[uni[a]];\n                return uni[a]=r;\n            }\n        }\n        long long weight(unsigned long long a){\n            root(a);\n            return diff_weight[a];\n        }\n        long long diff(unsigned long long a, unsigned long long b){\n            if(isSame(a,b)) return weight(b)-weight(a);\n            else return INT64_MAX;\n        }\n        unsigned long long count(unsigned long long a){\n            return -uni[root(a)];\n        }\n        bool merge(unsigned long long a, unsigned long long b, long long w=1){\n            w+=weight(a);  w-=weight(b);\n            a=root(a);  b=root(b);\n            if(a==b) return false;\n            if(uni[a]>uni[b]){\n                swap(a, b);\n                w=(-w);\n            }\n            uni[a]+=uni[b];\n            uni[b]=a;\n            diff_weight[b]=w;\n            return true;\n        }\n        bool isSame(unsigned long long a,unsigned long long b){\n            return root(a)==root(b);\n        }\n};\n\nint main(){\n    unionFind<100000> uf;\n    int n,q;\n    cin >> n >> q;\n    for(int i=0;i<q;i++){\n        int c,x,y,z;\n        cin >> c;\n        switch(c){\n            case RELATE:\n                cin >> x >> y >> z;\n                uf.merge(x,y,z);\n                break;\n            case DIFF:\n                cin >> x >> y;\n                if(uf.isSame(x,y)){\n                    cout << uf.diff(x,y) << endl;\n                }else{\n                    cout << '?' << endl;\n                }\n        }\n    }    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii; typedef vector<int> vi;\ntypedef long long ll; typedef vector<long long> vll;\nconst int MOD = 1'000'000'007, MOD2 = 1'000'000'009;\nconst int INF = 0x3f3f3f3f; const ll BINF = 0x3f3f3f3f3f3f3f3fLL;\n\nstruct DSU {\n\tint n;\n\tvector<int> p;\n\tDSU(int sz) : n(sz), p(sz) {\n\t\tiota(p.begin(), p.end(), 0);\n\t}\n\tint fi(int x) {return p[x] = p[x] - x ? fi(p[x]) : x;}\n\tinline void un(int u, int v) {p[fi(u)] = p[fi(v)];}\n};\n\nint solve() {\n\tint n, m; cin >> n >> m;\n\tvi op(m), x(m), y(m), z(m);\n\tvector<vector<pii>> g(n);\n\tfor (int i=0;i<m;i++) {\n\t\tcin >> op[i];\n\t\tif (op[i] == 0) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\tg[x[i]].emplace_back(y[i], z[i]);\n\t\t\tg[y[i]].emplace_back(x[i], -z[i]);\n\t\t} else {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t}\n\tvi val(n), vis(n);\n\tconst function<void(int)> dfs = [&g, &val, &vis, &dfs](int u) {\n\t\tfor (auto p : g[u]) {\n\t\t\tint v = p.first;\n\t\t\tif (!vis[v]) {\n\t\t\t\tval[v] = val[u] + p.second;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int i=0;i<n;i++) if (!vis[i]) {\n\t\tval[i] = 0;\n\t\tdfs(i);\n\t}\n\tDSU dsu(n);\n\tfor (int i=0;i<m;i++) {\n\t\tint gx = dsu.fi(x[i]), gy = dsu.fi(y[i]);\n\t\tif (op[i] == 0) {\n\t\t\tif (gx != gy) dsu.un(gx, gy);\n\t\t} else {\n\t\t\tif (gx == gy)\n\t\t\t\tcout << val[y[i]] - val[x[i]] << endl;\n\t\t\telse\n\t\t\t\tcout << '?' << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << (solve() ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    //xの根を求める\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    //xの重みを計算する\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    //x,yを重みwでマージする\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    //xとyの差を計算する\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    int n,q;\n    cin>>n>>q;\n    UnionFind<int> uni(n);\n    for(int qq=0;qq<q;qq++){\n        int a;\n        cin>>a;\n        if(a==0){\n            int x,y,z;\n            cin>>x>>y>>z;\n            uni.merge(x,y,z);\n        }\n        else {\n            int x,y;\n            cin>>x>>y;\n            if(!uni.same(x,y)){\n                cout<<\"?\"<<endl;\n            }\n            else cout<<uni.diff(x,y)<<endl;\n        }\n    }\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nstruct UnionFind{\n  vector<int> p;\n  vector<ll> weight;\n  UnionFind(int n){\n    p.resize(n, -1);\n    weight.resize(n, 0);\n  }\n\n  int find(int x){\n    if(p[x] == -1)return x;\n    else{\n      int r = find(p[x]); \n      weight[x] += weight[p[x]]; \n      return p[x] = r;\n    }\n  }\n\n  ll get_weight(int x){\n    find(x);\n    return weight[x];\n  }\n\n  void unite(int x, int y, ll w){\n    w += get_weight(x); \n    w -= get_weight(y); \n\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    p[y] = x;\n    weight[y] = w;\n  }\n\n  ll diff(int x, int y){\n    return get_weight(y) - get_weight(x);\n  }\n};\n\nint main(){\n  int n, q;\n  cin >> n >> q;\n  UnionFind uf(n);\n  for(int i = 0; i < q; ++i){\n  \tint com, x, y;\n  \tll z;\n  \tcin >> com;\n  \tif(com == 0){\n  \t\tcin >> x >> y >> z;\n  \t\tuf.unite(x, y, z);\n  \t}\n  \telse{\n  \t\tcin >> x >> y;\n  \t\tif(uf.find(x) == uf.find(y)){\n  \t\t\tcout << uf.diff(x, y) << endl;\n  \t\t}\n  \t\telse cout << \"?\" << endl;\n  \t}\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\n#define INF __INT32_MAX__\n#define LINF __LONG_LONG_MAX__\n\nclass UnionFind\n{\n    private:\n        vl parents;\n        vl rank;\n        vl diff_weight;\n\n    public:\n        UnionFind(ll n) {\n            for (ll i = 0; i < n; i++) {\n                parents.push_back(i);\n            }\n            rank.resize(n, 1);\n            diff_weight.resize(n, 0);\n        }\n\n        ll weight(ll a) {\n            root(a);\n            return diff_weight[a];\n        }\n\n        ll diff(ll a, ll b) {\n            return diff_weight[a] - diff_weight[b];\n        }\n\n        ll root(ll a) {\n            if (parents[a] == a) return a;\n            ll r = root(parents[a]);\n\n            diff_weight[a] += diff_weight[parents[a]];\n            parents[a] = r;\n            return r;\n        }\n\n        ll same(ll a, ll b) {\n            return root(a) == root(b);\n        }\n\n        bool unite(ll a, ll b, ll d) {\n            ll ra = root(a);\n            ll rb = root(b);\n            if (ra == rb) return false;\n\n            if (rank[ra] < rank[rb]) {\n                rank[rb] += rank[ra];\n                diff_weight[ra] = d - diff_weight[a] + diff_weight[b];\n                parents[ra] = rb;\n            } else {\n                rank[ra] += rank[rb];\n                diff_weight[rb] = diff_weight[a] - diff_weight[b] - d;\n                parents[rb] = ra;\n            }\n            return false;\n        }\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    UnionFind uni(N);\n    rep(i, Q) {\n        int C, X, Y, Z;\n        cin >> C;\n        if (C == 0) {\n            cin >> X >> Y >> Z;\n            uni.unite(X, Y, Z);\n        } else {\n            cin >> X >> Y;\n            if (uni.same(X, Y)) {\n                cout << (uni.diff(X, Y)) << endl;\n            } else {\n                cout << '?' << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n  int V;\n  vector<int> par, rnk, diff, sz;\n  WeightedUnionFind():V(-1){}\n  WeightedUnionFind(int V):V(V),par(V),rnk(V,0),diff(V,0),sz(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x] == x) return x;\n    int p = find(par[x]);\n    diff[x] = diff[x] + diff[ par[x] ];\n    return par[x] = p;\n  }\n\n  //頂点xは頂点yよりもz大きい\n  void relate(int x,int y,int z){\n    int sx = x, sy = y;\n    x = find(x), y = find(y);\n    if(x == y) assert(getDiff(sx,sy) == z);\n    if(x == y)return;\n    \n    if(rnk[x] < rnk[y]) {\n      par[x] = y;\n      sz[y] += sz[x];\n      diff[x] = z + (-diff[sx] + diff[sy]);\n    }\n    else{\n      par[y] = x;\n      sz[x] += sz[y];\n      diff[y] = -z + (diff[sx] - diff[sy]);\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  int getDiff(int u,int v){\n    assert(same(u,v));\n    return diff[u] - diff[v];\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  int size(int x){return sz[find(x)];}\n  \n};\n\nsigned main(){\n  int n;\n  cin>>n;\n  WeightedUnionFind wuf(n);\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, x, y, z;\n    cin>>cmd >> y >> x;\n    if(cmd == 0){\n      cin>>z;\n      wuf.relate(x,y,z);\n    }\n    if(cmd == 1){\n      if(!wuf.same(x, y)) cout<<\"?\"<<endl;\n      else cout<<wuf.getDiff(x, y)<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\nprivate:\n    vector<map<int, int> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<bool> visit(tree.size(), false);\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(Root(iter->first, target, Sum, visit)){\n                    Sum += iter->second;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool Root(int now, int target, int &Sum, vector<bool> &visit){\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(!visit[iter->first]){\n                    if(Root(iter->first, target, Sum, visit)){\n                        Sum += iter->second;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x][y] = z;\n        tree[y][x] = -z;\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S)){\n            cout << S << endl;\n            tree[x][y] = S;\n            tree[y][x] = -S;\n        }\n        else\n            cout << \"?\" << endl;\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, n, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int n, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y || !(0 <= z && z <= ZMAX))\n                return -1;\n            \n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y)\n                return -1;\n            \n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #include <algorithm>\n#include <stdio.h>\n#include <vector> \n#include <math.h>\nusing namespace std;\n\nvector<int> Parent;\nvector<int> Rank;\nvector<int> DiffW;\n\nint findSet(int x);\n\nint getWeight(int x){\n  findSet(x);\n  return DiffW[x];\n}\n\nint diffWeight(int x, int y){\n  return getWeight(y) - getWeight(x);\n}\n\nvoid makeSet(int x){\n  Parent.push_back(x);\n  Rank.push_back(0);\n  DiffW.push_back(0);\n}\nint findSet(int x){\n  if( x != Parent[x] ){\n    int r = findSet(Parent[x]);\n    DiffW[x] += DiffW[Parent[x]];\n    Parent[x] = r;\n  }\n  return Parent[x];\n}\nvoid link(int x, int y, int w){\n  if( Rank[x] > Rank[y] ){\n    Parent[y] = x;\n    DiffW[y] = w;\n  }else{\n    Parent[x] = y;\n    DiffW[x] = -w;\n    if( Rank[x] == Rank[y] ){\n      Rank[y] = Rank[y] + 1;\n    }\n  }\n}\n\nvoid unite(int x, int y, int w){\n  w += getWeight(x); w-= getWeight(y);  \n  link(findSet(x), findSet(y), w);\n}\n\nint same(int x, int y){\n  if(findSet(x)==findSet(y)){\n    return 1;\n  }\n  return 0;\n}\n\nint main(){\n  int n, q;\n  scanf(\"%d %d\" ,&n ,&q);\n  for( int i = 0 ; i < n ; i++ ){\n    makeSet(i);\n  }\n  for( int i = 0 ; i < q ; i++ ){\n    int com, x, y, z;\n    scanf(\"%d\" ,&com);\n    if(com == 0){ // 0(relate) x y z\n      scanf(\"%d %d %d\" ,&x ,&y ,&z);\n      unite(x, y, z);\n    }else{ // 1(diff) x y\n      scanf(\"%d %d\" ,&x ,&y);\n      if(same(x,y)){\n        int di = diffWeight(x, y);\n        printf(\"%d\\n\" ,di );\n      }else{\n        printf(\"?\\n\");\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nstruct UF{\n UL N;\n vector<pair<UL,LL>> V;\n void init(UL n){\n  N=n; V.resize(N);\n  rep(i,N) V[i]={i,0};\n }\n pair<UL,LL> root(UL a){\n  if(V[a].first==a) return V[a];\n  auto buf=root(V[a].first);\n  buf.second+=V[a].second;\n  return V[a]=buf;\n }\n void unite(UL r,UL s,LL h){\n  auto R=root(r); r=R.first; h+=R.second;\n  R=root(s); s=R.first; h-=R.second;\n  if(r==s) return;\n  V[s]={r,h};\n }\n};\n\nbool PtrCmp(int* l, int* r) {return *l<*r;}\n\nint main() {\n UL N,Q; scanf(\"%u%u\",&N,&Q);\n UF G; G.init(N);\n rep(q,Q){\n  UL c; scanf(\"%u\",&c);\n  if(c==0){\n   UL x,y,h; scanf(\"%u%u%u\",&x,&y,&h);\n   G.unite(x,y,h);\n  }\n  else if(c==1){\n   UL x,y; scanf(\"%u%u\",&x,&y);\n   auto X=G.root(x);\n   auto Y=G.root(y);\n   if(X.first!=Y.first) printf(\"?\\n\");\n   else printf(\"%lld\\n\",Y.second-X.second);\n  }\n }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 0;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0;\n\n  cin >> n >> q;\n  UnionFind uf(n);\n  int judge[q];\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] == 0) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T> struct UnionFind {\n  vector<int> par;\n  vector<int> rank;\n  vector<T> ws;\n\n  UnionFind(int n = 1, T e = 0)\n      : par(n), rank(n), ws(n) {\n    init(n, e);\n  }\n\n  void init(int n, T e) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n      ws[i] = e;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    } else {\n      int r = root(par[x]);\n      ws[x] += ws[par[x]];\n      return par[x] = r;\n    }\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  T weight(int x) {\n    root(x);\n    return ws[x];\n  }\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n  bool unite(int x, int y, T w = 0) {\n    w -= weight(y) - weight(x);\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w = negate<T>()(w);\n    }\n    par[y] = x;\n    ws[y] = w;\n    if (rank[x] == rank[y]) ++rank[x];\n    return true;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  UnionFind<ll> uf(n);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int x, y; cin >> x >> y;\n      cout << ( (uf.same(x, y)) ? to_string(uf.diff(x, y)) : \"?\" ) << endl;\n    } else {\n      int x, y, z; cin >> x >> y >> z;\n      uf.unite(x, y, z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define all(v) v.begin(), v.end()\nusing in = int64_t;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl\n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\nconst double PI=3.14159265358979323846;\nconst in MOD = 1000000007;\nconst in INF=1e18+7;\nconst int inf=1e9+7;\nusing P=pair<int,int>;\nvector<int> dx={0,1,-1,0};\nvector<int> dy={1,0,0,-1};\n\nstruct weighted_union{\n    vector<int> par;\n    vector<int> depth;\n    vector<int> heavy;\n    vector<int> siz;\n\n    weighted_union(int n) : par(n),depth(n,0),heavy(n,0),siz(n,1){\n        rep(i,n) par[i]=i;\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        int parent=find(par[x]);\n        heavy[x] +=heavy[par[x]];\n        return par[x]=parent;\n    }\n    int wei(int x){\n        find(x);\n        return heavy[x];\n    }\n    void unite(int x,int y,int w){//yはxよりw重い\n        w +=wei(x)-wei(y);\n        x=find(x),y=find(y);\n        if(x==y) return;\n        siz[x] +=siz[y];\n        siz[y] =siz[x];\n        if(depth[x]<depth[y]){\n            par[x]=y;\n            heavy[x]=-w;\n        }\n        else{\n            par[y]=x;\n            heavy[y]=w;\n            if(depth[x]==depth[y]) depth[x] ++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return siz[find(x)];\n    }\n    int diff(int x,int y){//w[y]-w[x],比較不可ならinf\n        if(!same(x,y)) return inf;\n        return wei(y)-wei(x);\n    }\n};\n\nint main(){\nios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ncout << fixed << setprecision(10);\n    int n,q;\n    cin>>n>>q;\n    weighted_union wuf(n);\n    int x,y,z;\n    int f;\n    rep(i,q){\n        cin>>f;\n        if(f){\n            cin>>x>>y;\n            z=wuf.diff(x,y);\n            if(z==inf) cout<<'?'<<endl;\n            else cout<<z<<endl;\n        }\n        else{\n            cin>>x>>y>>z;\n            wuf.unite(x,y,z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int error = 1e9;\n\nclass WeightedUnionFind{\n\nprivate:\n    vector<int> rank,p,d;\n\n  public:\n      WeightedUnionFind(){};\n      WeightedUnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        d.resize(size,0);\n        for(int i = 0; i < size; i++){\n          p[i] = i;\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void relate(int x, int y, int z){\n      link(find(x), find(y), d[y] + z - d[x]);\n      find(x);\n      find(y);\n    }\n\n    int find(int x){\n      if(x != p[x]){\n        int par = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = par;\n      }\n      return p[x];\n    }\n\n    int diff(int x, int y){\n      find(x);\n      find(y);\n      if(same(x,y)){\n        return d[x] - d[y];\n      }else{\n        return error;\n      }\n    }\nprivate:\n    void link(int x, int y, int z){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        d[y] = -z;\n      }else{\n        p[x] = y;\n        d[x] = z;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nint main(){\n    int n, q;\n\n    cin >> n >> q;\n    WeightedUnionFind wuf = WeightedUnionFind(n);\n\n    for(int i = 0; i < q; i++){\n      int t, x, y, z;\n      cin >> t;\n      if(t == 0){\n        cin >> x >> y >> z;\n        wuf.relate(x, y, z);\n      }else{\n        cin >> x >> y;\n        int ans = wuf.diff(x, y);\n        if(ans == error)\n          cout << \"?\" << endl;\n        else\n          cout << ans << endl;\n      }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass WeightedUnionFind{\n\nprivate:\n    vector<int> rank,p,d;\n\n  public:\n      WeightedUnionFind(){};\n      WeightedUnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        d.resize(size,0);\n        for(int i = 0; i < size; i++){\n          p[i] = i;\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void relate(int x, int y, int z){\n      link(find(x), find(y), d[y] + z - d[x]);\n      find(x);\n      find(y);\n    }\n\n    int find(int x){\n      if(x != p[x]){\n        int par = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = par;\n      }\n      return p[x];\n    }\n\n    int diff(int x, int y){\n      find(x);\n      find(y);\n      if(same(x,y)){\n        return abs(d[x] - d[y]);\n      }else{\n        return -1;\n      }\n    }\nprivate:\n    void link(int x, int y, int z){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        d[y] = -z;\n      }else{\n        p[x] = y;\n        d[x] = z;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nint main(){\n    int n, q;\n\n    cin >> n >> q;\n    WeightedUnionFind wuf = WeightedUnionFind(n);\n\n    for(int i = 0; i < q; i++){\n      int t, x, y, z;\n      cin >> t;\n      if(t == 0){\n        cin >> x >> y >> z;\n        wuf.relate(x, y, z);\n      }else{\n        cin >> x >> y;\n        int ans = wuf.diff(x, y);\n        if(ans < 0)\n          cout << \"?\" << endl;\n        else\n          cout << ans << endl;\n      }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <sstream>\n\nusing namespace std;\n\nint par[100000];\nint weight_diff[100000];\n\nvoid init(int n){\n  for(int i=0; i<n; i++) par[i] = i;\n}\n \nint root(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    int n = root(par[x]);\n    weight_diff[x] += weight_diff[par[x]];\n    return par[x] = n;\n  }\n}\n\nint weight(int x) {\n  root(x);\n  return weight_diff[x];\n}\n\nint diff(int x, int y) {\n  return weight(y) - weight(x);\n}\n\nbool same(int x, int y){\n  return root(x) == root(y);\n}\n\t\nvoid unite(int x, int y, int w){\n  w += weight(x); w -= weight(y);\n  x = root(x);\n  y = root(y);\n  if(x == y) return;\n  weight_diff[y] = w;\n  par[y] = x;\n}\n\nint main()\n{\n  int n,q;\n  cin >> n >> q;\n  int p, a, b, w;\n  init(n);\n  for(int i=0; i<q; i++){\n    cin >> p;\n    if(p == 0){\n      cin >> a >> b >> w;\n      unite(a, b, w);\n    }\n    else{\n      cin >> a >> b;\n      cout << (same(a, b) ? to_string(diff(a,b)) : \"?\") << endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// I SELL YOU...! \n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<chrono>\n#include<iomanip>\n#include<map>\n#include<set>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll,ll>;\nvoid init_io(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(10);\n}\nclass Wunion_find{\n  int n;\n  vector<int> par,rk,size,diff_w;\n  public:\n  Wunion_find(int max_n){\n    n = max_n+1;\n    for(int i=0;i<=n;i++){\n      par.emplace_back(i);\n      rk.emplace_back(0);\n      size.emplace_back(1);\n      diff_w.emplace_back(0);\n    }\n  }\n  int root(int x){\n    if(par[x]==x){\n      return x;\n    }\n    int r = root(par[x]);\n    diff_w[x] += diff_w[par[x]];\n    return par[x] = r;\n  }\n  void unite(int x,int y,int w){\n    w += weight(x);\n    w -= weight(y);\n    x = root(x);\n    y = root(y);\n    if(x==y) return;\n    if(rk[x]<rk[y]){\n      par[x] = y;\n      size[y] += size[x];\n      diff_w[x] = -w;\n    }else{\n      par[y] = x;\n      if(rk[x]==rk[y]) rk[x]++;\n      size[x] += size[y];\n      diff_w[y] = w;\n    }\n  }\n  bool same(int x,int y){\n    return root(x)==root(y);\n  }\n  int weight(int x){\n    root(x);\n    return diff_w[x];\n  }\n  int diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n  int treesize(int x){\n    return size[root(x)];\n  }\n};\nsigned main(){\n  init_io();\n  ll n,q,x,y,z,p;\n  cin >> n>>q;\n  Wunion_find wuf(n);\n  for(int i=0;i<q;i++){\n    cin >> p;\n    if(p==0){\n      cin >> x >> y >> z;\n      wuf.unite(x,y,z);\n    }else{\n      cin >> x>> y;\n      if(wuf.same(x,y)){\n        cout << wuf.diff(x,y)<<endl;\n      }else{\n        cout <<\"?\\n\";\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\nprivate:\n    vector<map<int, int> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<int> stack;\n        vector<bool> visit(tree.size(), false);\n        int v, t = -1;\n        \n        if(tree[now].find(target) != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        \n        visit[now] = true;\n        stack.push_back(now);\n        \n        while(!stack.empty()){\n            v = stack[stack.size() - 1];\n            stack.pop_back();\n            \n            if(t != -1 && tree[t].find(v) != tree[t].end()){\n                Sum += tree[t][v];\n            }\n            \n            if(v == target)\n                return true;\n            \n            for(map<int, int>::iterator it = tree[v].begin(); it != tree[v].end(); it++){\n                if(!visit[it->first]){\n                    visit[it->first] = true;\n                    stack.push_back(it->first);\n                }\n            }\n            t = v;\n        }\n        \n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x][y] = z;\n        tree[y][x] = -z;\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S)){\n            cout << S << endl;\n            tree[x][y] = S;\n            tree[y][x] = -S;\n        }\n        else\n            cout << \"?\" << endl;\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, n, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int n, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y || !(0 <= z && z <= ZMAX))\n                return -1;\n            \n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y)\n                return -1;\n            \n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id] = { a, data[id].second + d };\n\t\t}\n\t\tcopy(all[b].begin(), all[b].end(), back_inserter(all[a]));\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nstruct UnionFind\n{\n   vector<int> par, myrank;\n   UnionFind(int n) {\n      myrank.resize(n, 0);\n      par.resize(n);\n      for (int i = 0; i < n; i++) par[i] = i;\n   }\n   int root(int x) {\n      if (par[x] == x) return x;\n      return par[x] = root(par[x]);\n   }\n   bool merge(int x, int y) {\n      x = root(x); y = root(y);\n      if (x == y) return false;\n      if (myrank[x] < myrank[y]) swap(x, y);\n      par[y] = x;\n      if(myrank[x] == myrank[y]) myrank[x]++;\n      return true;\n   }\n   bool issame(int x, int y) {\n      return root(x) == root(y);\n   }\n};\ntemplate<typename Abel>\nstruct WeightedUnionFind\n{\n   vector<int> par, myrank;\n   vector<Abel> diff_weight;\n   WeightedUnionFind(int n, Abel SUM_UNITY=0) {\n      par.resize(n); myrank.resize(n, 0); diff_weight.resize(n);\n      for (int i = 0; i < n; i++) { par[i] = i; diff_weight[i] = SUM_UNITY; }\n   }\n   int root(int x) {\n      if (par[x] == x) return x;\n      int r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n   }\n   Abel weight(int x) {\n      root(x);\n      return diff_weight[x];\n   }\n   Abel diff(int x, int y) {\n      return weight(y) - weight(x);\n   }\n   bool merge(int x, int y, Abel w) {\n      w += weight(x); w -= weight(y);\n      x = root(x); y = root(y);\n      if (x == y) return false;\n      if (myrank[x] < myrank[y]) swap(x, y), w = -w;    \n      par[y] = x;\n      if(myrank[x] == myrank[y]) myrank[x]++;\n      diff_weight[y] = w;\n      return true;\n   }\n   bool issame(int x, int y) {\n      return root(x) == root(y);\n   }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), x(q), y(q), z(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> x[i] >> y[i] >> z[i];\n      } else {\n         cin >> x[i] >> y[i];\n      }\n   }\n   WeightedUnionFind<int> wuf(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         wuf.merge(x[i], y[i], z[i]);\n      } else {\n         if (wuf.issame(x[i], y[i])) {\n            cout << wuf.diff(x[i], y[i]) << endl;\n         } else {\n            cout << \"?\" << endl;\n         }\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n//\nstruct WeightUnionFind{\n\t//\n\tvector<int> ran,par,wei;\n\t//\n\tWeightUnionFind(int n){\n\t\tinit(n);\n\t}\n\t//\n\tvoid init(int n){\n\t\tran.resize(n);\n\t\tpar.resize(n);\n\t\twei.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tran[i]=i;\n\t\t\tpar[i]=0;\n\t\t\twei[i]=0;\n\t\t}\n\t}\n\t//\n\tint find(int x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint r=find(par[x]);\n\t\t\twei[x]+=wei[par[x]];\n\t\t\treturn par[x]=r;\n\t\t}\n\t}\n\t//\n\tint weight(int x){\n\t\tfind(x);\n\t\treturn wei[x];\n\t}\n\t//\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\t//\n\tbool unite(int x,int y,int w){\n\t\tw+=weight(x);\n\t\tw-=weight(y);\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y){\n\t\t\treturn false;\n\t\t}else if(ran[x]<ran[y]){\n\t\t\tswap(x,y);\n\t\t\tw=-w;\n\t\t}else if(ran[x]==ran[y]){\n\t\t\tran[x]++;\n\t\t}\n\t\tpar[y]=x;\n\t\twei[y]=w;\n\t\treturn true;\n\t}\n\t//\n\tint diff(int x,int y){\n\t\treturn weight(y)-weight(x);\n\t}\n\t//\n};\n//\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tWeightUnionFind UF(N);\n\twhile(Q--){\n\t\tint C;\n\t\tcin>>C;\n\t\tif(C==1){\n\t\t\tint X,Y;\n\t\t\tcin>>X>>Y;\n\t\t\tif(UF.same(X,Y)){\n\t\t\t\tcout<<UF.diff(X,Y)<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\tint X,Y,Z;\n\t\t\tcin>>X>>Y>>Z;\n\t\t\tUF.unite(X,Y,Z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, n) for (intmax_t i = 0, i##_limit = (n); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline void input(vector<T> &vec) {\n    for (auto &e: vec) {\n        cin >> e;\n    }\n}\n\ntemplate <class T>\ninline void input(vector<vector<T>> &mat) {\n    for (auto &vec: mat) {\n        input(vec);\n    }\n}\n\ninline void print() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void print(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) cout << \" \";\n    print(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &strm, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        strm << e << delim[&e == &vec.back()];\n    }\n    return strm;\n}\n\ntemplate <class T>\ninline vector<T> make_v(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto make_v(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(make_v<T>(initValue, args...))>(sz, make_v<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// WeightedUnionFind {{{\ntemplate <class Abel>\nstruct WeightedUnionFind {\n    vector<int> tree;\n    vector<Abel> diffWeight;\n\n    explicit WeightedUnionFind(const size_t n, Abel SUM_UNITY = 0) :\n        tree(n + 1, -1), diffWeight(n + 1, SUM_UNITY)\n    {}\n\n    size_t size(size_t x) {\n        return -tree[root(x)];\n    }\n\n    size_t root(size_t x) {\n        if (tree[x] < 0) {\n            return x;\n        } else {\n            const size_t r = root(tree[x]);\n            diffWeight[x] += diffWeight[tree[x]];\n            return tree[x] = r;\n        }\n    }\n\n    Abel weight(size_t x) {\n        root(x);\n        return diffWeight[x];\n    }\n\n    Abel diff(size_t x, size_t y) {\n        return weight(y) - weight(x);\n    }\n\n    bool connected(size_t x, size_t y) {\n        return root(x) == root(y);\n    }\n\n    bool unite(size_t x, size_t y, Abel w) {\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        tree[x] += tree[y];\n        tree[y] = x;\n        diffWeight[y] = w;\n        return true;\n    }\n};\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    var(size_t, N, Q);\n\n    WeightedUnionFind<intmax_t> uf(N);\n    while (Q--) {\n        var(size_t, query);\n        if (query == 0) {\n            var(size_t, x, y);\n            var(intmax_t, z);\n            uf.unite(x, y, z);\n        } else {\n            var(size_t, x, y);\n            if (!uf.connected(x, y)) {\n                print('?');\n            } else {\n                print(uf.diff(x, y));\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma region WUF\nstruct WUF {\t\t\t   // 重み付きUnion_Find木\n\tvector<int> par;\t   // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\tvector<int> sz;\t\t   // iを根とする木のサイズ\n\tvector<int> dist_par;  // 親までの距離\n\n\tWUF(int N) : par(N), sz(N), dist_par(N) {\n\t\t//最初は全てが根であるとして初期化\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tpar[i] = i;\n\t\t\tsz[i] = 1;\n\t\t\tdist_par[i] = 0;\n\t\t}\n\t}\n\n\tint root(int x) {  // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif(par[x] == x) return x;\n\t\tint rt = root(par[x]);\t//ここではまだparを更新しない\n\t\tdist_par[x] += dist_par[par[x]];\n\t\treturn par[x] = rt;\n\t}\n\n\t// 2つのデータx, yが属する木が同じならtrueを返す\n\tbool same(int x, int y) { return root(x) == root(y); }\n\n\tint distance(int x, int y) {  // xから見たyまでの距離\n\t\tassert(same(x, y));\n\t\t// errorの確認をしつつここでdist_par[x],dist_par[y]を根までの距離に変換している\n\t\treturn dist_par[x] - dist_par[y];\n\t}\n\n\tbool unite(int x, int y, int dis) {\t   // xとyの木を併合\n\t\tint rx = root(x);\t\t\t\t   // xの根をrx\n\t\tint ry = root(y);\t\t\t\t   // yの根をry\n\t\tif(rx == ry)\t\t\t\t\t   // xとyの根が同じ(=同じ木にある)時はそのまま\n\t\t\treturn distance(x, y) == dis;  //入力が矛盾しているならfalse\n\t\tpar[rx] = ry;\t\t\t\t\t   // xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t\tsz[ry] += sz[rx];\t\t\t\t   //サイズも併合\n\t\tsz[rx] = 0;\t\t\t\t\t\t   //根じゃなくなったらサイズは0になる\n\t\tdist_par[rx] = dist_par[y] - dist_par[x] + dis;\n\t\treturn true;\n\t}\n\n\tint size(int x) { return sz[root(x)]; }\n};\n#pragma endregion\n\nint main() {\n\t// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_1_B\n\tint n, q;\n\tcin >> n >> q;\n\tWUF w(n);\n\tvector<int> ans;\n\tfor(int i = 0; i < q; i++) {\n\t\tint c;\n\t\tcin >> c;\n\t\tif(c) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif(w.same(x, y)) {\n\t\t\t\tcout << (w.distance(x, y)) << \"\\n\";\n\t\t\t} else {\n\t\t\t\tcout << \"?\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tif(!w.unite(x, y, z)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n  vector<int> parent;\n  vector< ll > dist;\n  UnionFind(int x=1){\n    parent.clear();\n    parent.resize(x,-1);\n    dist.clear();\n    dist.resize(x,0);\n  }\n  int find(int x){\n    if(parent[x]<0)return x;\n    int r=find(parent[x]);\n    dist[x]+=dist[ parent[x] ];\n    return parent[x]=r;    \n  }\n  ll depth(int x){\n    find(x);\n    return dist[x];\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int size(int x){\n    return -parent[find(x)];\n  }\n  void unite(int x,int y,ll k=0){\n    k+=depth(y);\n    k-=depth(x);\n    k*=-1;\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size(x)<size(y)){\n      swap(x,y);\n      k*=-1;\n    }\n    parent[x]+=parent[y];\n    parent[y]=x;\n    dist[y]=k;\n  }\n};\n\n\n\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  UnionFind T(n);\n  for(int i=0;i<q;i++){\n    int type,x,y;\n    scanf(\"%d %d %d\",&type,&x,&y);\n    if(type==0){\n      int a;\n      scanf(\"%d\",&a);\n      T.unite(x,y,a);\n    }else{\n      \n      if(!T.same(x,y)){\n        printf(\"?\\n\");\n      }else{\n        printf(\"%lld\\n\",T.depth(x)-T.depth(y));\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n//float inf = std::numeric_limits<float>::infinity();\n#define INF 100000000\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return INF;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0;\n\n  cin >> n >> q;\n  UnionFind uf(n);\n  int judge[q];\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] >= INF) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(int argc,char* argv[]){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n\treturn 1;\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename Q_temp>\nusing smaller_queue = priority_queue <Q_temp, vector<Q_temp>, greater<Q_temp> >;\n\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 4e18;\nconst ll MOD = (ll) (1e9 + 7);\nconst double PI = acos(-1.0);\nconst int limit = 100010;\n\n#define REP(i,m,n) for(ll i = m; i < (ll)(n); ++i)\n#define rep(i,n) REP(i, 0, n)\n#define MP make_pair\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define NP(v) next_permutation(v.begin(),v.end())\n#define debug(x) cout << #x << \":\" << x << endl;\n#define debug2(x) for(auto a : x) cout << a << \" \"; cout << endl;\n#define debug3(x) rep(i, sizeof(x)) cout << x[i] << \" \"; cout << endl;\n\nvector<pii> around = {MP(1, 0), MP(-1, 0), MP(0, 1), MP(0, -1)};\n\n//------------------------------------------------------\n\ntemplate<class Abel = ll> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int N = limit, Abel SUM_UNITY = 0) {\n        init(N, SUM_UNITY);\n    }\n\n    void init(int N = limit, Abel SUM_UNITY = 0) {\n        par.resize(N);\n        rank.resize(N);\n        diff_weight.resize(N);\n        for (int i = 0; i < N; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool unite(int x, int y, Abel w) { //weight[y] = weight[x] + w\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, q;\n    cin >> n >> q;\n    UnionFind<> uf;\n\n    rep(i, q) {\n        ll query;\n        cin >> query;\n        if (query == 0) {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        } else {\n            ll x, y;\n            cin >> x >> y;\n            if (uf.issame(x, y)) cout << uf.diff(x, y) << endl;\n            else cout << \"?\\n\";\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\nusing namespace std;\n#define PB push_back\nconst int N=1e5+10;\nint p[N],val[N];\nstack<int>s[N];\nint find(int n){\n    if(p[n]==n)return n;\n    return p[n]=find(p[n]);\n}\nint main(){\n    int n,q,l,r,temp,a,b;\n    scanf(\"%d%d\",&n,&q);\n    for(int i=0;i<n;i++){\n        p[i]=i;\n        val[i]=0;\n        s[i].push(i);\n    }\n    while(q--){\n        scanf(\"%d%d%d\",&temp,&l,&r);\n        if(temp==1){\n            if(find(l)!=find(r))printf(\"?\\n\");\n            else printf(\"%d\\n\",val[r]-val[l]);\n        }\n        else{\n            scanf(\"%d\",&temp);\n            a=find(l);\n            b=find(r);\n            if(s[a].size()>s[b].size()){\n                p[b]=a;\n                temp+=val[l]-val[r];\n                while(!s[b].empty()){\n                    val[s[b].top()]+=temp;\n                    s[a].push(s[b].top());\n                    s[b].pop();\n                }\n            }\n            else{\n                p[a]=b;\n                temp=val[r]-temp-val[l];\n                while(!s[a].empty()){\n                    val[s[a].top()]+=temp;\n                    s[b].push(s[a].top());\n                    s[a].pop();\n                }\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\nusing namespace std;\nconst int N=1e5+10;\nint p[N],val[N];\nstack<int>s[N];\nint find(int n){\n    if(p[n]==n)return n;\n    return p[n]=find(p[n]);\n}\nint main(){\n    int n,q,l,r,temp,a,b;\n    scanf(\"%d%d\",&n,&q);\n    for(int i=0;i<n;i++){\n        p[i]=i;\n        val[i]=0;\n        s[i].push(i);\n    }\n    while(q--){\n        scanf(\"%d%d%d\",&temp,&l,&r);\n        if(temp==1){\n            if(find(l)!=find(r))printf(\"?\\n\");\n            else printf(\"%d\\n\",val[r]-val[l]);\n        }\n        else{\n            scanf(\"%d\",&temp);\n            a=find(l);\n            b=find(r);\n            if(a==b)continue;\n            if(s[a].size()>s[b].size()){\n                p[b]=a;\n                temp+=val[l]-val[r];\n                while(!s[b].empty()){\n                    val[s[b].top()]+=temp;\n                    s[a].push(s[b].top());\n                    s[b].pop();\n                }\n            }\n            else{\n                p[a]=b;\n                temp=val[r]-temp-val[l];\n                while(!s[a].empty()){\n                    val[s[a].top()]+=temp;\n                    s[b].push(s[a].top());\n                    s[a].pop();\n                }\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nnamespace beet{\n  \n  template<typename T>\n  void swap(T &a,T &b){\n    T x=a;\n    a=b;\n    b=x;\n  }\n\n  const int MAX = 1e5+10;\n  struct UnionFind{\n    int r[MAX],p[MAX],w[MAX];\n    UnionFind(int n){\n      for(int i=0;i<n;i++){\n        r[i]=1;\n        p[i]=i;\n        w[i]=0;\n      }    \n    }\n    int find(int x){\n      if(p[x]==x){\n        return x;\n      }\n      int t=find(p[x]);\n      w[x]+=w[p[x]];\n      return p[x]=t;\n    }\n    int same(int x,int y){\n      return find(x)==find(y);\n    }\n    int weight(int x){\n      find(x);\n      return w[x];\n    }\n    void unite(int x,int y,int d){\n      d+=weight(x);\n      d-=weight(y);\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y),d=-d;\n      r[x]+=r[y];\n      p[y]=x;\n      w[y]=d;\n    }\n    int diff(int x,int y){\n      return weight(y)-weight(x);\n    }\n  };\n}\nusing namespace beet;\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  UnionFind uf(n);\n  while(q--){\n    int t,x,y;\n    scanf(\"%d %d %d\",&t,&x,&y);\n    if(t==0){\n      int z;\n      scanf(\"%d\",&z);\n      uf.unite(x,y,z);\n    }    \n    if(t==1){\n      if(uf.same(x,y)){\n        printf(\"%d\\n\",uf.diff(x,y));\n      }else{\n        puts(\"?\");\n      }\n    }\n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        // cout << \" \" << *t++;\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class Group, template <class> class Container>\nclass potentialized_union_find {\n  protected:\n    class node_type;\n\n  public:\n    using value_structure = Group;\n    using value_type = typename value_structure::value_type;\n    using container_type = Container<node_type>;\n    using size_type = typename container_type::size_type;\n\n  protected:\n    class node_type {\n      public:\n        typename potentialized_union_find::size_type parent;\n        typename potentialized_union_find::size_type size;\n        typename potentialized_union_find::value_type value;\n    };\n\n    container_type tree;\n\n  private:\n    value_type potential(size_type x) {\n        value_type ret = value_structure::identity();\n        while(tree[x].parent != x) {\n            tree[x].value = value_structure::operation(\n                tree[tree[x].parent].value, tree[x].value);\n            ret = value_structure::operation(tree[x].value, ret);\n            x = tree[x].parent = tree[tree[x].parent].parent;\n        }\n        return ::std::move(ret);\n    }\n\n  public:\n    potentialized_union_find() : tree() {}\n    explicit potentialized_union_find(const size_type size)\n        : tree(size, {0, 1, value_structure::identity()}) {\n        for(size_type i = 0; i < size; ++i)\n            tree[i].parent = i;\n    }\n\n    bool empty() const { return tree.empty(); }\n    size_type size() const { return tree.size(); }\n\n    size_type root(size_type x) {\n        assert(x < size());\n        while(tree[x].parent != x) {\n            tree[x].value = value_structure::operation(\n                tree[tree[x].parent].value, tree[x].value);\n            x = tree[x].parent = tree[tree[x].parent].parent;\n        }\n        return x;\n    }\n    bool same(const size_type x, const size_type y) {\n        assert(x < size());\n        assert(y < size());\n        return root(x) == root(y);\n    }\n    size_type size(const size_type x) {\n        assert(x < size());\n        return tree[root(x)].size;\n    }\n\n    value_type diff(size_type x, size_type y) {\n        assert(x < size());\n        assert(y < size());\n        assert(same(x, y));\n        return value_structure::operation(\n            value_structure::inverse(potential(x)), potential(y));\n    }\n\n    ::std::pair<size_type, size_type> unite(size_type x, size_type y,\n                                            value_type w) {\n        // something wrong...\n        assert(x < size());\n        assert(y < size());\n        w = value_structure::operation(\n            value_structure::operation(potential(x), ::std::move(w)),\n            value_structure::inverse(potential(y)));\n        x = root(x);\n        y = root(y);\n        if(x != y) {\n            if(tree[x].size < tree[y].size) {\n                ::std::swap(x, y);\n                w = value_structure::inverse(::std::move(w));\n            }\n            tree[x].size += tree[y].size;\n            tree[y].value = move(w);\n            tree[y].parent = x;\n        }\n        return {x, y};\n    }\n};\n\ntemplate <class T> class plus_abelian {\n  public:\n    using value_type = T;\n    static value_type operation(const value_type &x, const value_type &y) {\n        return x + y;\n    }\n    static value_type identity() { return value_type(0); }\n    static value_type inverse(const value_type &x) { return -x; }\n    static value_type reverse(const value_type &x) { return x; }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    potentialized_union_find<plus_abelian<int>, vec_alias> uf(n);\n\n    int c, x, y, z, t;\n    rep(i, q) {\n        cin >> c >> x >> y;\n        if(c) {\n            if(uf.same(x, y))\n                cout << uf.diff(x, y) << \"\\n\";\n            else\n                cout << \"?\\n\";\n        } else {\n            cin >> z;\n            uf.unite(x, y, z);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    vector<int> data;\n    vector<T> ws;\n    WeightedUnionFind(int sz) : data(sz, -1), ws(sz) { }\n    bool merge(int x, int y, T w) {             // ws(y) = ws(x) + w\n        w += weight(x); w -= weight(y);\n        if ((x = root(x)) == (y = root(y))) return false;\n        if (data[x] > data[y]) swap(x, y), w = -w;\n        data[x] += data[y]; data[y] = x; ws[y] = w;\n        return true;\n    }\n    bool find(int x, int y) { return root(x) == root(y); }\n    T diff(int x, int y) { return weight(y) - weight(x); }\n    T weight(int t) { root(t); return ws[t]; }\n    int root(int k) {\n        if (data[k] < 0) return k;\n        int par = root(data[k]);\n        ws[k] += ws[data[k]];\n        return data[k] = par;\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<int> wuf(n);\n    while (q--) {\n        int com, x, y; cin >> com >> x >> y;\n        if (com == 0) {\n            int z; cin >> z;\n            wuf.merge(x, y, z);\n        } else {\n            if (wuf.find(x, y)) {\n                cout << wuf.diff(x, y) << endl;\n            } else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      z -= diffWeight[x];\n      z += diffWeight[y];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << abs(getWeight(y)-getWeight(x)) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nstruct weighted_unionfind{\n\tvector<int> p;\n\tvector<T> d;\n\tweighted_unionfind(int N){\n\t\tp = vector<int>(N, -1);\n\t\td = vector<T>(N, 0);\n\t}\n\tint root(int x){\n\t\tif (p[x] == -1){\n\t\t\treturn x;\n\t\t} else {\n\t\t\troot(p[x]);\n\t\t\td[x] = d[x] + d[p[x]];\n\t\t\tp[x] = root(p[x]);\n\t\t\treturn p[x];\n\t\t}\n\t}\n\tbool same(int x, int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\treturn x == y;\n\t}\n\tvoid unite(int x, int y, T t){\n\t\troot(x);\n\t\troot(y);\n\t\tt = t + d[y] - d[x];\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x != y){\n\t\t\tp[x] = y;\n\t\t\td[x] = t;\n\t\t}\n\t\treturn;\n\t}\n};\nint main(){\n  int n, q;\n  cin >> n >> q;\n  weighted_unionfind<long long> UF(n);\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 0){\n      int x, y;\n      long long z;\n      cin >> x >> y >> z;\n      if (!UF.same(x, y)){\n        UF.unite(x, y, z);\n      }\n    }\n    if (t == 1){\n      int x, y;\n      cin >> x >> y;\n      if (UF.same(x, y)){\n        cout << UF.d[x] - UF.d[y] << endl;\n      } else {\n        cout << '?' << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] -= Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tvoid unite(int x, int y, int z){ // a[y] - a[x] == z\n\t\tz += Weight[x] - Weight[y];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = -z;\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = z;\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tbool cost(int x, int y, int &t){ // if same(x, y) return a[y] - a[x]\n\t\tif(!same(x, y)) return false;\n\t\treturn (t = Weight[y] - Weight[x]);\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tint tmp;\n\t\t\tif(wuf.cost(x, y, tmp)) cout << tmp << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\nstruct pUF{\n    vector<ll> r, par;\n    pUF(int n):r(n),par(n,-1){};\n\n    int find(int x){\n       if(par[x]<0)\n           return x;\n       int y = find(par[x]);\n       r[x] += r[par[x]];\n       return par[x] = y;\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    \n    ll weight(int x){\n       find(x);\n       return r[x];\n    }\n\n    ll diff(int x,int y){//weigth(y)-weight(x)を出力\n        return weight(y)-weight(x);\n    }\n    \n    bool unite(ll c,int x, int y){//weight(y)-weight(x)=cとなるようにつなぐ\n        c -= weight(y);\n        c += weight(x);\n        x = find(x);\n        y = find(y);\n        if(x!=y){\n           par[y] = x;\n           r[y] = c;\n           return true;\n       }\n       return false;\n    }\n};\nint main(){\n    int n;\n    cin>>n;\n    pUF uf(n);\n    int q;\n    cin>>q;\n    rep(i,q){\n        int t;\n        cin>>t;\n        if(t){\n            int x,y;\n            cin>>x>>y;\n            if(uf.same(x,y))cout<<uf.diff(x,y)<<endl;\n            else cout<<\"?\"<<endl;\n        }\n        else {\n            int x,y,z;\n            cin>>x>>y>>z;\n            uf.unite(z,x,y);\n        }\n    }\n\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MAXN 100000\ntypedef struct Values {\n    int val;\n    int comp;\n} Values;\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    Values a[MAXN];\n    int n;\n    int q;\n    std::cin >> n;\n    std::cin >> q;\n\n    for(int i = 0; i < n; ++i){\n        a[i].val = 0;\n        a[i].comp = i;\n    }\n    for(int i = 0; i < q; ++i){\n        int op;\n        std::cin >> op;\n        if(op == 0){\n            //relate                                                                                                                                                                                                                \n            int id1;\n            int id2;\n            int v;\n            std::cin >> id1 >> id2 >> v;\n            int v1 = 0;\n            int v2 = 0;\n            int i = id1;\n            int j = id2;\n            while(a[i].comp != i){\n                v1 += a[i].val;\n                i = a[i].comp;\n            }\n            while(a[j].comp != j){\n                v2 += a[j].val;\n                j = a[j].comp;\n            }\n            a[j].comp = i;\n            a[j].val = v1 - v2 - v;\n            a[id1].comp = i;\n            a[id1].val = v1;\n            a[id2].comp = i;\n            a[id2].val = v1 - v;\n\n       } else {\n            int id1;\n            int id2;\n            std::cin >> id1 >> id2;\n            int v1 = 0;\n            int v2 = 0;\n            while(a[id1].comp != id1){\n                v1 -= a[id1].val;\n                id1 = a[id1].comp;\n            }\n            while(a[id2].comp != id2){\n                v2 -= a[id2].val;\n                id2 = a[id2].comp;\n            }\n\n            if(id1 != id2) std::cout << \"?\\n\";\n            else std::cout << v2 - v1 << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nstruct weighted_unionfind {  // size:要素数,tree：unionfind木\n    int n;\n    vector<int> tree_root;\n    vector<int> tree_depth;\n    vector<int> tree_weight;\n\n    weighted_unionfind(int temp) {\n        n = temp;\n        tree_root.assign(n, 0);\n        tree_depth.assign(n, 1);\n        tree_weight.assign(n, 0);\n        for (int i = 0; i < n; i++) { tree_root[i] = i; }\n    }\n\n    // rootを探す\n    tuple<int, int> root(int index) {\n        vector<int> temp_list(0);\n        int temp = tree_root[index];\n        int dist = 0;\n        while (index != temp) {\n            temp_list.push_back(index);\n            dist += tree_weight[index];\n            index = temp;\n            temp = tree_root[index];\n        }\n        int dist2 = dist;\n        for (int i : temp_list) {\n            tree_root[i] = index;\n            temp = tree_weight[i];\n            tree_weight[i] = dist2;\n            dist2 -= temp;\n        }\n        return make_tuple(index, dist);\n    }\n    //結合\n    void unite(int index1, int index2, int dist) {\n        int r1, r2, k1, k2;\n        tie(r1, k1) = root(index1);\n        tie(r2, k2) = root(index2);\n        if (r1 != r2) {\n            int d1 = tree_depth[r1];\n            int d2 = tree_depth[r2];\n            if (d1 <= d2) {\n                tree_root[r1] = r2;\n                tree_weight[r1] = dist - k1 + k2;\n                tree_depth[r2] = max(d1 + 1, d2);\n            } else {\n                tree_root[r2] = r1;\n                tree_weight[r2] = -dist + k1 - k2;\n                tree_depth[r1] = max(d2 + 1, d1);\n            }\n        }\n    }\n    //同じか判定\n    tuple<bool, int> same(int index1, int index2) {\n        int r1, r2, k1, k2;\n        tie(r1, k1) = root(index1);\n        tie(r2, k2) = root(index2);\n        if (r1 == r2) {\n            return make_tuple(true, k1 - k2);\n        } else {\n            return make_tuple(false, 0);\n        }\n    }\n    //連結成分の個数\n    int component() {\n        set<int> s;\n        for (int i : tree_root) { s.insert(i); }\n        return (int)s.size();\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, m;\n    INPUT(n, m);\n    weighted_unionfind u(n);\n    for (int i = 0; i < m; i++) {\n        int s, x, y, z;\n        INPUT(s, x, y);\n        if (s == 0) {\n            INPUT(z);\n            u.unite(x, y, z);\n        } else {\n            bool b;\n            int ans;\n            tie(b, ans) = u.same(x, y);\n            if (b) {\n                PRINT(ans);\n            } else {\n                PRINT(\"?\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <utility>\n#include <set>\n#include <map>\n#include <tuple> \n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <list>\nusing namespace  std;\ntypedef pair<long long , long long> P;\ntypedef long long ll;\ntypedef long long lint;\n#define REP(i, n) for(long long (i)=0; (i)<(n); ++i)\n#define FOR(i, a, b) for(long long (i)=(a); (i)<(b); ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\nconst long long MOD = static_cast<long long>(1e9) + 7LL;\nconst long long INF = 1234567891234567890LL;\n\n\nclass UF{\n    public:\n    int N;\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff_weight;\n    UF(int N=1){\n        par.resize(N);\n        diff_weight.resize(N);\n        rank.resize(N);\n        for(int i=0; i<N; i++) par[i] = i, rank[i] = diff_weight[i] = 0;\n    }\n    int root(int x){\n        if(par[x]==x) return x;\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    int diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n    bool isSame(int x, int y){\n        return root(x)==root(y);\n    }\n\n    bool merge(int x, int y, int w=0){\n        w += weight(x);\n        w -= weight(y);\n        int rx = root(x);\n        int ry = root(y);\n        if(rx==ry) return false;\n        if(rank[rx]<rank[ry]) swap(rx, ry), w=-w;\n        if(rank[rx]==rank[ry]) ++rank[rx];\n        par[ry] = rx;\n        diff_weight[ry] = w;\n        return true;\n    }\n};\nsigned main(){\n    int N, q; cin>>N>>q;\n    UF uf(N);\n    for(long long i=0; i<q; i++){\n        int x; cin>>x;\n        if(x==0){\n            int x, y, z;\n            cin>>x>>y>>z;\n            uf.merge(x, y, z);\n        }\n        else{\n            int x, y; cin>>x>>y;\n            if(uf.isSame(x, y)) cout << uf.diff(x, y) << endl;\n            else cout << \"?\" << endl;;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int error = 1e9;\n\nclass WeightedUnionFind{\n\nprivate:\n    vector<int> rank,p,d;\n\n  public:\n      WeightedUnionFind(){};\n      WeightedUnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        d.resize(size,0);\n        for(int i = 0; i < size; i++){\n          p[i] = i;\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void relate(int x, int y, int z){\n      int px = find(x);\n      int py = find(y);\n      link(px, py, d[y] + z - d[x]);\n      find(x);\n      find(y);\n    }\n\n    int find(int x){\n      if(x != p[x]){\n        int par = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = par;\n      }\n      return p[x];\n    }\n\n    int diff(int x, int y){\n      find(x);\n      find(y);\n      if(same(x,y)){\n        return d[x] - d[y];\n      }else{\n        return error;\n      }\n    }\nprivate:\n    void link(int x, int y, int z){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        d[y] = -z;\n      }else{\n        p[x] = y;\n        d[x] = z;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nint main(){\n    int n, q;\n\n    cin >> n >> q;\n    WeightedUnionFind wuf = WeightedUnionFind(n);\n\n    for(int i = 0; i < q; i++){\n      int t, x, y, z;\n      cin >> t;\n      if(t == 0){\n        cin >> x >> y >> z;\n        wuf.relate(x, y, z);\n      }else{\n        cin >> x >> y;\n        int ans = wuf.diff(x, y);\n        if(ans == error)\n          cout << \"?\" << endl;\n        else\n          cout << ans << endl;\n      }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\nconst int N = 1e5 + 10;\nint par[N], cost[N], sz[N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++)\n        par[i] = i, sz[i] = 1;\n}\n\nint find(int x) {\n    int prep = par[x];\n    if (x != par[x]) {\n        par[x] = find(par[x]);\n    }\n    cost[x] += cost[prep];\n    return par[x];\n}\n\n\nvoid unite(int u, int v, int wt) {\n    int par1 = find(u), par2 = find(v);\n\n    if (par1 == par2)\n        return;\n    int c = wt + cost[u] - cost[v];\n    if (sz[par1] >= sz[par2]) {\n        par[par2] = par1;\n        cost[par2] = c;\n        sz[par1] += sz[par2];\n    } else {\n        par[par1] = par2;\n        cost[par1] = -c;\n        sz[par2] += sz[par1];\n    }\n}\n\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n\n    init(n);\n\n    for (int i = 0; i < q; i++) {\n        int type;\n        cin >> type;\n\n        if (type == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n\n            unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n\n            if (find(x) == find(y))\n                cout << cost[y] - cost[x] << endl;\n            else\n                cout << \"?\" << endl;\n        }\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n//#include <limits>\n#include <tuple>\n\nusing namespace std;\nconst int MY_INT_MAX = 2147483647;\n\nclass DisjointSet{\npublic:\n    int seqSize; // number of nodes\n    int* parent; // parent nodes\n    int* rankArr; // rankArr of each node\n    int* weight;\n    DisjointSet(int x);\n    int findSet(int node);\n    tuple<int, int> findSetWithPathCompressAndWeight(int x); // findSet() operation with path compression\n    void unionByRank(int x, int y, int z);\n    bool same(int x, int y); // check whether x and y are in the same set\n    void printSet();\n};\n\nint main()\n{\n//    // import data from a txt file\n//    int n; // number of nodes\n//    int q; // number of queries\n//    int a, b, c, d;\n//    ifstream infile(\"in10.txt\");\n//    infile >> n >> q;\n//    //cout << n << \" \" << q << endl;\n//    DisjointSet mySet(n);\n//    int output[q];\n//    int outIdx = 0;\n//    for (int i = 0; i < q; i++) {\n//        infile >> a;\n//        if (a == 0) { // \"relate(x,y,z)\"\n//            infile >> b >> c >> d;\n//            //cout << a << \" \" <<  b << \" \" << c << \" \" << d << endl;\n//            mySet.unionByRank(b, c, d);\n//            //mySet.printSet();\n//        }\n//        else if (a == 1) { // \"dif(x, y)\"\n//            infile >> b >> c;\n//            //cout << a << \" \" <<  b << \" \" << c << endl;\n//            if (mySet.same(b, c)) { output[outIdx] = mySet.weight[c] - mySet.weight[b]; }\n//            else { output[outIdx] = INT_MAX; }\n//            outIdx += 1;\n//            //mySet.printSet();\n//        }\n//    }\n//    infile.close();\n\n    // import data from command line\n    int n; // number of nodes\n    int q; // number of queries\n    int a, b, c, d;\n    cin >> n >> q;\n    DisjointSet mySet(n);\n    int output[q];\n    int outIdx = 0;\n    for (int i = 0; i < q; i++) {\n        cin >> a;\n        if (a == 0) { // \"relate(x,y,z)\"\n            cin >> b >> c >> d;\n            mySet.unionByRank(b, c, d);\n        }\n        else if (a == 1) { // \"dif(x, y)\"\n            cin >> b >> c;\n            if (mySet.same(b, c)) { output[outIdx] = mySet.weight[c] - mySet.weight[b]; }\n            else { output[outIdx] = MY_INT_MAX; }\n            outIdx += 1;\n        }\n    }\n\n    //print out the output\n    for (int i = 0; i < outIdx; i++) {\n        if (output[i] != MY_INT_MAX) { cout << output[i] << endl; }\n        else { cout << \"?\\n\"; }\n    }\n\n    return 0;\n}\n\nDisjointSet::DisjointSet(int x) {\n    seqSize = x;\n    parent = new int[seqSize];\n    rankArr = new int[seqSize];\n    weight = new int[seqSize];\n    for (int i = 0; i < seqSize; i++) {\n        parent[i] = i;\n        rankArr[i] = 1;\n        weight[i] = 0;\n    }\n}\n\nvoid DisjointSet::printSet() {\n    cout << \"n:\\t\";\n    for (int i = 0; i < this->seqSize; i++) {\n        cout << i << \"\\t\";\n    }\n    cout << endl;\n    cout << \"p:\\t\";\n    for (int i = 0; i < this->seqSize; i++) {\n        cout << this->parent[i] << \"\\t\";\n    }\n    cout << endl;\n    cout << \"w:\\t\";\n    for (int i = 0; i < this->seqSize; i++) {\n        cout << this->weight[i] << \"\\t\";\n    }\n    cout << endl;\n    cout << \"r:\\t\";\n    for (int i = 0; i < this->seqSize; i++) {\n        cout << this->rankArr[i] << \"\\t\";\n    }\n    cout << endl;\n}\n\nint DisjointSet::findSet(int node) {\n    if (parent[node] != node) {\n        return findSet(parent[node]);\n    } else {\n        return parent[node];\n    }\n}\n\n//int DisjointSet::findSetWithPathCompressAndWeight(int x) {\n//    if (parent[x] !=  x) {\n//        weight[x] += weight[parent[x]]; // update weight of node x\n//        parent[x] = findSetWithPathCompressAndWeight(parent[x]);\n//    }\n//    weight[x] += weight[parent[x]]; // update weight of node x\n//    return parent[x];\n//}\n\ntuple<int, int> DisjointSet::findSetWithPathCompressAndWeight(int x) {\n    if (parent[x] !=  x) {\n        int xpar, xpar_wt;\n        //weight[x] += weight[parent[x]];\n        tie(xpar, xpar_wt) = findSetWithPathCompressAndWeight(parent[x]);\n        weight[x] = weight[x] + xpar_wt; // update weight of node x\n        parent[x] = xpar;\n        return make_tuple(parent[x], weight[x]);\n    }\n    else {\n        return make_tuple(parent[x], weight[x]);\n    }\n}\n\n\nvoid DisjointSet::unionByRank(int x, int y, int z) {\n    int xrep, yrep;\n    tie(xrep, ignore) = findSetWithPathCompressAndWeight(x); // representative of node x\n    tie(yrep, ignore) = findSetWithPathCompressAndWeight(y); // representative of node y\n    if (xrep == yrep) {\n        return; // do nothing since x and y are currently in the same set\n    }\n    else if (rankArr[xrep] > rankArr[yrep]) {\n        parent[yrep] = xrep;\n        weight[yrep] = z + weight[x] - weight[y];\n    }\n    else if (rankArr[xrep] < rankArr[yrep]) {\n        parent[xrep] = yrep;\n        weight[xrep] = -z - weight[x] + weight[y];\n    }\n    else {\n        // rankArr[xrep] = rankArr[yrep]\n        parent[xrep] = yrep;\n        weight[xrep] = -z - weight[x] + weight[y];\n        rankArr[yrep] += 1;\n    }\n}\n\nbool DisjointSet::same(int x, int y) {\n    int xrep, yrep;\n    tie(xrep, ignore) = findSetWithPathCompressAndWeight(x);\n    tie(yrep, ignore) = findSetWithPathCompressAndWeight(y);\n    if (xrep == yrep) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\nprivate:\n    vector<map<int, int> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<bool> visit(tree.size(), false);\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(Root(iter->first, target, Sum, visit)){\n                    Sum += iter->second;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool Root(int now, int target, int &Sum, vector<bool> &visit){\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(!visit[iter->first]){\n                    if(Root(iter->first, target, Sum, visit)){\n                        Sum += iter->second;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x][y] = z;\n        tree[y][x] = -z;\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S)){\n            cout << S << endl;\n            tree[x][y] = S;\n            tree[y][x] = -S;\n        }\n        else\n            cout << \"?\" << endl;\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, n, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int n, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y || !(0 <= z && z <= ZMAX))\n                return -1;\n            \n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y)\n                return -1;\n            \n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<typename T>\nclass UnionFind {\npublic:\n  vector<int> par, siz;\n  vector<T> diff_weight;\n    \n  UnionFind(int sz_, T x) {\n    init(sz_, x);\n  }\n  void init(int sz_, T x) {\n    par.resize(sz_);\n    siz.resize(sz_, 1);\n    diff_weight.resize(sz_);\n    rep(i, sz_) par[i] = i, diff_weight[i] = x;\n  }\n\n  int root(int x) { \n    if (par[x] == x) return x;\n    else {\n      int r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n\n  T weight(int x) {\n    root(x);\n    return diff_weight[x];\n  }\n\n  bool merge(int x, int y, T w) {\n    w += weight(x);\n    w -= weight(y);\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (siz[x] < siz[y]) swap(x, y), w = -w;\n    siz[x] += siz[y];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  int size(int x) {\n    return siz[root(x)];\n  }\n\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n, q;\n  cin >> n >> q;\n  UnionFind<int> uf(n, 0);\n  while (q--) {\n    int c, x, y;\n    cin >> c >> x >> y;\n\n    if (c) {\n      if (uf.issame(x, y)) cout << uf.diff(x, y) << '\\n';\n      else cout << \"?\\n\";\n    }\n    else {\n      int z;\n      cin >> z;\n      uf.merge(x, y, z);\n    }\n  }\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#pragma GCC target (\"avx\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define R pair<pair<int, int>, pair<int, int>>\n#define S(i,j,k,l) mkp(mkp(i,j),mkp(k,l))\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define rng(i,s,n) for(int (i) = (s) ; (i) < (n) ; (i)++)\n#define req(n,i) for(int (i) = (n) - 1 ; (i) >= 0 ; (i)--)\n#define range(i,v) for(auto& (i) : v)\n#define mkp make_pair\n#define mem(x,k) memset(x,k,sizeof(x))\n#define vec vector\n#define pb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) lower_bound(all(b),(i))-b.begin()\n#define ssp(i,n) (i==n-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define itn int\n#define pri_que priority_queue\n#define pp(x,y) pb(H{x,y})\n#define ppp(x,y,z) pb(Q(x,y,z))\n#define pppp(x,y,z,w) pb(S(x,y,z,w))\n#define cyes cout<<\"Yes\\n\"\n#define cno cout<<\"No\\n\"\n#define endl \"\\n\"\nconstexpr int mod = 1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr ll inf = 3 * 1e18;\nconstexpr int Inf = 15 * 1e8;\nconst vec<int>dx{ -1,1,0,0 }, dy{ 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(bool g = 0) { H u; ll k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g) u.fs--, u.sc--; return u; }\nvoid printh(H t) { printf(\"%lld %lld\\n\", t.fs, t.sc); }\nbool inarea(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\nll bitcount(ll x) {\n\tint sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n\treturn sum;\n}\nconstexpr int fn_ = 1000005;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll Mod = mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) \n\t\t\tfact_[i] = fact_[i - 1] * i % Mod;\n\t\tcomp_[fn_ - 1] = mod_pow(fact_[fn_ - 1], Mod - 2, Mod);\n\t\tfor (int i = fn_ - 2; i > 0; i--)\n\t\t\tcomp_[i] = comp_[i + 1] * (i + 1) % Mod;\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % Mod * comp_[y] % Mod;\n}\n//--------------------------------------------------------------\nclass WeightedUnionFind {\n\tstatic constexpr int SIZE = 500005;\n\tint par[SIZE], chsiz[SIZE], diffe[SIZE];\n\tint size;\npublic:\n\tvoid init(int n) {\n\t\tsize = n;\n\t\tfor (int i = 0; i <= size; i++) {\n\t\t\tpar[i] = i, chsiz[i] = 1, diffe[i] = 0;\n\t\t}\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\tint r = root(par[x]);\n\t\tdiffe[x] += diffe[par[x]];\n\t\treturn par[x] = r;\n\t}\n\tint weight(int x) {\n\t\troot(x); return diffe[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y, int w = 0) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return;\n\t\tif (chsiz[x] < chsiz[y]) swap(x, y), w = -w;\n\t\tchsiz[x] += chsiz[y];\n\t\tpar[y] = x;\n\t\tdiffe[y] = w;\n\t}\n\tint diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tpair<int, int>operator[](const int x) {\n\t\treturn make_pair(root(x), chsiz[root(x)]);\n\t}\n};\nWeightedUnionFind wuf;\nint n, m;\nsigned main() {\n\tcin >> n >> m;\n\twuf.init(n);\n\trep(i, m) {\n\t\tint u = read();\n\t\tif (u == 0) {\n\t\t\tint l, r, w; cin >> l >> r >> w;\n\t\t\twuf.unite(l, r, w);\n\t\t}\n\t\telse {\n\t\t\tint l, r; cin >> l >> r;\n\t\t\tcout << (wuf.same(l, r) ? to_string(wuf.diff(l, r)) : \"?\") << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct weighted_disjoint_set{\n    vector<pair<int, int>> p;\n    weighted_disjoint_set(int n){\n        p.resize(n);\n        for(int i = 0; i < n; i += 1) p[i] = {i, 0};\n    }\n    pair<int, int> fp(int u){\n        if(u == p[u].first) return p[u];\n        auto ppu = fp(p[u].first);\n        return p[u] = {ppu.first, p[u].second + ppu.second};\n    }\n    //a[u] + w = a[v]\n    void relate(int u, int v, int w){\n        auto pu = fp(u), pv = fp(v);\n        p[pu.first] = {pv.first, pv.second + w - pu.second};\n    }\n    bool diff(int u, int v, int& w){\n        auto pu = fp(u), pv = fp(v);\n        if(pu.first != pv.first) return false;\n        return w = pu.second - pv.second, true;\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    weighted_disjoint_set wds(n);\n    for(int i = 0; i < q; i += 1){\n        int com, u, v, w;\n        cin >> com >> u >> v;\n        if(com){\n            if(not wds.diff(u, v, w)) cout << \"?\\n\";\n            else cout << w << \"\\n\";\n        }\n        else{\n            cin >> w;\n            wds.relate(u, v, w);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 100000\n#define INF 1 << 31\n\nstruct Node \n{\n  int parent;\n  int cost;\n};\n\nint parent[MAX];\nint depth[MAX];\nint cost[MAX];\n\nNode findParent(int child)\n{\n  Node tmp;\n  if (child != parent[child])\n  {\n    tmp = findParent(parent[child]);\n    parent[child] = tmp.parent;\n    cost[child] += tmp.cost;\n  }\n\n  tmp.parent = parent[child];\n  tmp.cost = cost[child];\n\n  return tmp;\n}\n\nvoid relate(int x, int y, int z)\n{\n  Node nodeX = findParent(x);\n  Node nodeY = findParent(y);\n\n  if (nodeX.parent == nodeY.parent) return;\n\n  if (depth[nodeY.parent] > depth[nodeX.parent])\n  {\n    parent[nodeX.parent] = nodeY.parent;\n    cost[nodeX.parent] = nodeY.cost - nodeX.cost - z;\n  }\n  else\n  {\n    parent[nodeY.parent] = nodeX.parent;\n    cost[nodeY.parent] = nodeX.cost - nodeY.cost + z;\n\n    if (depth[nodeX.parent] == depth[nodeY.parent])\n    {\n      depth[nodeX.parent]++;\n    }\n  }\n}\n\nint diff(int x, int y)\n{\n  Node NodeX = findParent(x);\n  Node NodeY = findParent(y);\n\n  if (NodeX.parent != NodeY.parent) return INF;\n\n  return NodeY.cost - NodeX.cost;\n}\n\nint main()\n{\n  int n, q, i, query, x, y, z, ans;\n\n  cin >> n >> q;\n  for (i = 0; i < n; i++) \n  {\n    parent[i] = i;\n    depth[i] = 0;\n    cost[i] = 0;\n  }\n\n  for (i = 0; i < q; i++)\n  {\n    cin >> query;\n    if (query == 0) \n    {\n      cin >> x >> y >> z;\n      relate(x, y, z);\n    }\n    else \n    {\n      cin >> x >> y;\n      ans = diff(x, y);\n      if (ans == INF) cout << \"?\" << endl;\n      else cout << ans << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass WeightedDisjointSet{\npublic:\n    vector<int> p,rank,depth;\n    \n    WeightedDisjointSet();\n    WeightedDisjointSet(int size){\n        // サイズをセットし直す\n        rank.resize(size,0);\n        p.resize(size,0);\n        depth.resize(size,0);\n        for(int i = 0;i < size;++i){\n            makeSet(i);\n        }\n    }\n    \n    // 要素xがただ一つである集合を作る\n    void makeSet(int x){\n        p[x] = x;\n        rank[x] = 0;\n        depth[x] = 0;\n    }\n    \n    // 同じ集合にいるか\n    bool same(int x,int y){\n        return findSet(x) == findSet(y);\n    }\n    \n    void relate(int x, int y, int z){\n        int px = findSet(x);\n        int py = findSet(y);\n        link(px,py,depth[y] + z - depth[x]);\n    }\n    \n    // 要素xが属する集合の代表の要素を求める\n    int findSet(int x){\n        // 自身がルートでない場合\n        if(x != p[x]){\n            // 自身の親をさかのぼる\n            int tmp = findSet(p[x]);\n            depth[x] += depth[p[x]];\n            p[x] = tmp;\n        }\n        return p[x];\n    }\n    \n    void link(int x, int y, int z){\n        if(rank[x] > rank[y]){\n            p[y] = x;\n            depth[y] = -z;\n        }else{\n            p[x] = y;\n            depth[x] = z;\n            if(rank[x] == rank[y]){\n                rank[y]++;\n            }\n        }\n    }\n\n    int diff(int x, int y){\n        return sumDepth(x) - sumDepth(y);\n    }\n    \n    int sumDepth(int x){\n        int sum = 0;\n        int index = x;\n        while(index != p[index]){\n            sum += depth[index];\n            index = p[index];\n        }\n        return sum;\n    }\n};\n\nint main(void){\n    int n,q,c,x,y,z;\n    cin >> n >> q;\n    WeightedDisjointSet wds = WeightedDisjointSet(n);\n    \n    for(int i = 0;i < q;++i){\n        cin >> c >> x >> y;\n        switch(c){\n                // relate\n            case 0:{\n                cin >> z;\n                wds.relate(x, y, z);\n                break;\n            }\n                // diff\n            case 1:{\n                if(!wds.same(x, y)){\n                    cout << \"?\" << endl;\n                }\n                else{\n                    cout << wds.diff(x, y) << endl;\n                }\n                break;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    unsigned int n;\n    T d;\n    vector<int> r, p;\n    vector<T> ws;\n\n    WeightedUnionFind() = default;\n\n    WeightedUnionFind(unsigned int sz, T d_) :\n            n(sz), d(d_), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n    int find(int x) {\n        if (x == p[x]) {\n            return x;\n        } else {\n            int t = find(p[x]);\n            ws[x] += ws[p[x]];\n            return p[x] = t;\n        }\n    }\n\n    T weight(int x) {\n        find(x);\n        return ws[x];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y, T w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (r[x] < r[y]) swap(x, y), w = -w;\n        r[x] += r[y];\n        p[y] = x;\n        ws[y] = w;\n    }\n\n    T diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main() {\n    unsigned int n, q;\n    cin >> n >> q;\n\n    auto wuf = WeightedUnionFind<int>(n, 0);\n\n    for (int i = 0; i < q; ++i) {\n        int op, x, y;\n        cin >> op >> x >> y;\n\n        if (op == 0) {\n            int z;\n            cin >> z;\n            wuf.unite(x, y, z);\n        } else {\n            if (wuf.same(x, y)) {\n                cout << wuf.diff(x, y) << endl;\n            } else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_union_find {\npublic:\n    weighted_union_find(size_t n)\n    :par(n, -1), weight_diff(n, 0) {}\n\n    // weight(y) - weight(x) = w\n    bool unite(int x, int y, T w) {\n        w += weight(x);\n        w -= weight(y);\n\n        if((x = find(x)) == (y = find(y))) {\n            return false;\n        } else {\n            if(par[y] < par[x]) {\n                swap(x, y);\n                w = -w;\n            }\n            par[x] += par[y];\n            par[y] = x;\n            weight_diff[y] = w;\n            return true;\n        }\n    }\n\n    int find(int x) {\n        if(par[x] < 0) {\n            return x;\n        } else {\n            int root = find(par[x]);\n            weight_diff[x] += weight_diff[par[x]];\n            return par[x] = root;\n        }\n    }\n\n    T weight(int x) {\n        find(x);\n        return weight_diff[x];\n    }\n\n    T diff(int x, int y) {\n        return weight_diff[y] - weight_diff[x];\n    }\n\n    int size(int x) {\n        return -par[find(x)];\n    }\n\nprivate:\n    vector<int> par;\n    vector<T> weight_diff;\n};\n\n\nint main() {\n    int n, q; cin >> n >> q;\n    weighted_union_find<int> uf(n);\n\n    while(q--){\n        int k; cin >> k;\n        if(k == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if(uf.find(x) != uf.find(y)) cout << '?' << endl;\n            else cout << uf.diff(x, y) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFindTree{\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> diff;\n  \n  int getRoot(int i){\n    if(parent[i] == i)return i;\n\n    int r = getRoot(parent[i]);\n    diff[i] += diff[parent[i]];\n    return parent[i] = r;\n  }\n\n  int weight(int x){\n    getRoot(x);\n    return diff[x];\n  }\n\npublic:\n  UnionFindTree(int n) : parent(n) , rank(n) , diff(n){\n    for(int i=0; i<n; i++){ parent[i] = i; rank[i] = diff[i] = 0; }\n  }\n\n  void unite(int x, int y, int z){\n\n    z += weight(x); z-= weight(y);\n    \n    x = getRoot(x);\n    y = getRoot(y);\n    \n    if(x == y)return;\n    if(rank[x] < rank[y]) swap(x,y) , z = -z;\n    if(rank[x] == rank[y])rank[x]++;\n    parent[y] = x;\n    diff[y] = z;\n  }\n\n  bool same(int x, int y){\n    return getRoot(x) == getRoot(y);\n  }\n\n  int getDiff(int x, int y){\n    return weight(y) - weight(x);\n  }\n\n};\n  \nint main(){\n\n  int n,q;\n  cin >> n >> q;\n  UnionFindTree uft(n);\n\n  for(int i=0; i<q; i++){\n    int com, x, y, z;\n    cin >> com >> x >> y;\n    if(com == 0){\n      cin >> z;\n      uft.unite(x,y, z);\n    }\n    else{\n      if( uft.same(x,y) ) cout << uft.getDiff(x,y) << endl;\n      else cout << \"?\" << endl; \n\n    }\n  }\n    \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nstruct QuickFind {\n    vector<int> i2g;\n    vector< vector<int> > g2i;\n    vector<long long int> weight;\n    int N;\n\n    QuickFind(int N_) {\n        N = N_;\n        i2g.resize(N); g2i.resize(N);\n        weight.resize(N);\n\n        for(int i=0; i<N; i++) {\n            i2g[i] = i;\n            g2i[i] = vector<int>{i};\n        }\n    }\n\n    bool same(int u, int v) {\n        return i2g[u] == i2g[v];\n    }\n\n    long long int query(int u, int v) {\n        assert(same(u, v));\n        return weight[v] - weight[u];\n    }\n\n    void merge(int u, int v, int w) {\n        if(same(u, v)) return;\n        int ru = i2g[u], rv = i2g[v];\n\n        if(g2i[rv].size() > g2i[ru].size()) {\n            swap(ru, rv); swap(u, v);\n            w = -w;\n        }\n\n        long long int prev = weight[v];\n        weight[v] = weight[u] + w;\n\n        for(auto e : g2i[rv]) {\n            i2g[e] = ru;\n            g2i[ru].push_back(e);\n            if(e == v) continue;\n            int diff = weight[e] - prev;\n            weight[e] = weight[v] + diff;\n        }\n\n        g2i[rv].clear();\n    }\n};\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    QuickFind qf(N);\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int u, v, w; cin >> u >> v >> w;\n            qf.merge(u, v, w);\n        }\n        else {\n            int u, v; cin >> u >> v;\n            if(qf.same(u, v)) cout << qf.query(u, v) << endl;\n            else cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include \"pch.h\"\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <climits>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <fstream>\n#include<unordered_map>\n#include <stack>\n#include <random>\n\ntypedef long long ll;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<long long, long long> Pll;\ntypedef std::pair<double, double> Pdd;\n\n#define rip(i, n, s) for (int i = (s);i < (int)( n ); i++)\n#define mapa make_pair\n#define all(a) a.begin(), a.end()\n#define MM << \" \" <<\n\ntemplate<typename T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate<typename T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<typename T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nvoid vdeb(std::vector<T> &da) {\n    for (int i = 0;i < da.size();i++) {\n        if (i == da.size() - 1) std::cout << da[i];\n        else std::cout << da[i] << ' ';\n    }\n    std::cout << std::endl;\n}\ntemplate<typename T>\nvoid vdeb(std::vector<std::vector<T>> &da) {\n    for (int i = 0;i < da.size();i++) vdeb(da[i]);\n    std::cout << std::endl;\n}\n\nusing namespace std;\n\nstruct UnionFInd{\n    int size;\n    vector<int> par, relate, rank;\n    UnionFInd(int x){\n        size = x;\n        relate = vector<int> (x, 0);\n        rank = vector<int> (x);\n        par = vector<int> (x);\n        rip(i,x,0) par[i] = i;\n    }\n    int root(int x){\n        if(par[x] == x) return x;\n        int ret = root(par[x]);\n        relate[x] += relate[par[x]];\n        return par[x] = ret;\n    }\n    void unite(int x, int y, int z){\n        int X = root(x), Y = root(y);\n        z -= relate[x] - relate[y];\n        if(X == Y) return;\n        if(rank[X] < rank[Y]){\n            relate[X] = z;\n            par[X] = Y;\n        }\n        else{\n            relate[Y] = -z;\n            par[Y] = X;\n        }\n        if(X == Y) rank[Y]++;\n        return;\n    }\n    int diff(int x, int y){\n        return relate[x] - relate[y];\n    }\n    bool check(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    UnionFInd uf(n+1);\n    rip(i,q,0){\n        int c; cin >> c;\n        if(c){\n            int x, y; cin >> x >> y;\n            if(uf.check(x,y))printf(\"%d\\n\", uf.diff(x,y));\n            else printf(\"?\\n\");\n        }\n        else{\n            int x, y, z; cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nclass kin{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void scan(void);\n\tinline kin &operator>(char &);\n\tinline kin &operator>(int &);\n\tinline kin &operator>(long long &);\n\tinline kin &operator>(double &);\n\tinline kin &operator>(long double &);\n\tinline kin &operator>(char *);\n\ttemplate<class T>\n\tinline void get(T *,int);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}in;\n\nclass kout{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void print(void);\n\tinline kout &operator<(char);\n\tinline kout &operator<(int);\n\tinline kout &operator<(long long);\n\tinline kout &operator<(double);\n\tinline kout &operator<(long double);\n\tinline kout &operator<(const char *);\n\ttemplate<class T>\n\tinline void put(T *,int,char,char);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}out;\n\ntemplate<class T>\nclass weighteduf{\npublic:\n\tinline void open(T,int);\n\tinline void close(void);\n\tinline void unite(int,int,T);\n\tinline int same(int,int);\n\tinline T diff(int,int);\n\tinline int size(int);\n\tinline int group(void);\n\tinline weighteduf(T);\n\tinline weighteduf(T,T,int);\nprivate:\n\tint siz;\n\tint *par;\n\tT *dif;\n\tT dum;\n\tint grp;\n\tinline int find(int);\n};\n\nint main(int argc,char **argv){\n\tin.open(stdin,512);\n\tout.open(stdout,512);\n\tin.scan();\n\tint n;\n\tin>n;\n\tweighteduf<int> s(2147483647,0,n);\n\tint q;\n\tin>q;\n\tfor(int i=0;i<q;++i){\n\t\tint c,x,y;\n\t\tin>c>x>y;\n\t\tif(c==0){\n\t\t\tint z;\n\t\t\tin>z;\n\t\t\ts.unite(x,y,z);\n\t\t}\n\t\telse{\n\t\t\tif(!s.same(x,y)) out<'?';\n\t\t\telse out<s.diff(x,y);\n\t\t\tout<'\\n';\n\t\t}\n\t}\n\ts.close();\n\tout.print();\n\tin.close();\n\tout.close();\n\treturn 0;\n}\n\ntemplate<class T>\ninline void weighteduf<T>::open(T id,int siza){\n\tsiz=siza;\n\tpar=new int[siz];\n\tdif=new T[siz];\n\tfor(int i=0;i<siz;++i){\n\t\tpar[i]=-1;\n\t\tdif[i]=id;\n\t}\n\tgrp=siz;\n\treturn;\n}\ntemplate<class T>\ninline void weighteduf<T>::close(void){\n\tsiz=grp=0;\n\tdelete[] par;\n\tdelete[] dif;\n\tpar=dif=nullptr;\n}\ntemplate<class T>\ninline void weighteduf<T>::unite(int ndx,int ndy,T val){\n\tint rx=find(ndx),ry=find(ndy);\n\tif(rx==ry) return;\n\tval+=dif[ndx]-dif[ndy];\n\tif(par[rx]>par[ry]){\n\t\tpar[ry]+=par[rx];\n\t\tpar[rx]=ry;\n\t\tdif[rx]=-val;\n\t}\n\telse{\n\t\tpar[rx]+=par[ry];\n\t\tpar[ry]=rx;\n\t\tdif[ry]=val;\n\t}\n\t--grp;\n\treturn;\n}\ntemplate<class T>\ninline int weighteduf<T>::same(int ndx,int ndy){\n\treturn find(ndx)==find(ndy)?1:0;\n}\ntemplate<class T>\ninline T weighteduf<T>::diff(int ndx,int ndy){\n\tif(!same(ndx,ndy)) return dum;\n\treturn dif[ndy]-dif[ndx];\n}\ntemplate<class T>\ninline int weighteduf<T>::size(int nd){\n\treturn -par[find(nd)];\n}\ntemplate<class T>\ninline int weighteduf<T>::group(void){\n\treturn grp;\n}\ntemplate<class T>\ninline int weighteduf<T>::find(int nd){\n\tif(par[nd]<0) return nd;\n\tint r=find(par[nd]);\n\tdif[nd]+=dif[par[nd]];\n\treturn par[nd]=r;\n}\ntemplate<class T>\ninline weighteduf<T>::weighteduf(T duma){\n\tdum=duma;\n\tsiz=grp=0;\n\tpar=nullptr;\n}\ntemplate<class T>\ninline weighteduf<T>::weighteduf(T duma,T id,int siza){\n\tdum=duma;\n\topen(id,siza);\n}\n\ninline void kin::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kin::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kin::scan(void){\n\tint readsiz=(int)std::fread((void *)buf,(std::size_t)1,(std::size_t)siz,fp);\n\tif(readsiz!=siz) buf[readsiz]='\\x00';\n\tidx=0;\n\treturn;\n}\ninline kin &kin::operator>(char &var){\n\tif(!buf[idx]){\n\t\tvar='\\x00';\n\t\treturn *this;\n\t}\n\tvar=buf[idx];\n\tif(++idx==siz) scan();\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(int &var){\n\tif(!buf[idx]){\n\t\tvar=0;\n\t\treturn *this;\n\t}\n\tint sign=-1;\n\tif(buf[idx]=='-'){\n\t\tsign=1;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10-(int)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long long &var){\n\tif(!buf[idx]){\n\t\tvar=0LL;\n\t\treturn *this;\n\t}\n\tlong long sign=-1LL;\n\tif(buf[idx]=='-'){\n\t\tsign=1LL;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0LL;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10LL-(long long)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0;\n\t\treturn *this;\n\t}\n\tdouble sign=-1.0;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0-(double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tdouble dig=1.0;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(double)(buf[idx]-'0')*(dig/=10.0);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0L;\n\t\treturn *this;\n\t}\n\tlong double sign=-1.0L;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0L;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0L;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0L-(long double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tlong double dig=1.0L;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(long double)(buf[idx]-'0')*(dig/=10.0L);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(char *var){\n\tif(!buf[idx]){\n\t\tvar[0]='\\x00';\n\t\treturn *this;\n\t}\n\tint ptr=0;\n\twhile(buf[idx]>='!'){\n\t\tvar[ptr++]=buf[idx];\n\t\tif(++idx==siz) scan();\n\t}\n\tvar[ptr]='\\x00';\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ntemplate<class T>\ninline void kin::get(T *var,int num){\n\tfor(int i=0;i<num;++i) (*this)>var[i];\n\treturn;\n}\n\ninline void kout::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kout::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kout::print(void){\n\tstd::fwrite((void *)buf,(std::size_t)1,(std::size_t)idx,fp);\n\tidx=0;\n\treturn;\n}\ninline kout &kout::operator<(char val){\n\tbuf[idx]=val;\n\tif(++idx==siz) print();\n\treturn *this;\n}\ninline kout &kout::operator<(int val){\n\tif(val<0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1;\n\tchar dig[10];\n\tint ptr=0;\n\tdo{\n\t\tint tmp=val/10;\n\t\tdig[ptr++]=(char)-(val-tmp*10)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long long val){\n\tif(val<0LL){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1LL;\n\tchar dig[19];\n\tint ptr=0;\n\tdo{\n\t\tlong long tmp=val/10LL;\n\t\tdig[ptr++]=(char)-(val-tmp*10LL)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(double val){\n\tif(val<0.0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0;\n\tdouble dig=1.0;\n\twhile(val/dig<=-10.0) dig*=10.0;\n\tint tmp;\n\twhile(dig>=1.0){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<12;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long double val){\n\tif(val<0.0L){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0L;\n\tlong double dig=1.0L;\n\twhile(val/dig<=-10.0L) dig*=10.0L;\n\tint tmp;\n\twhile(dig>=1.0L){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<16;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(const char *val){\n\tfor(int i=0;val[i];++i){\n\t\tbuf[idx]=val[i];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ntemplate<class T>\ninline void kout::put(T *val,int num,char spc,char end){\n\t--num;\n\tfor(int i=0;i<num;++i) (*this)<val[i]<spc;\n\t(*this)<val[num]<end;\n\treturn;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) v.begin(),v.end()\n#define _GLIBCXX_DEBUG\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\nusing vvd = vector<vd>;\nusing vvvi = vector<vvi>;\nusing vvvll = vector<vvll>;\nusing vvvd = vector<vvd>;\n\nconst double pi=3.141592653589793;\nconst ll MOD=1e9+7;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int n,q;\n    cin>>n>>q;\n    UnionFind<int> uf(n+1);\n    rep(i,q){\n        int a,x,y,z;\n        cin>>a;\n        if (a==1){\n            cin>>x>>y;\n            if (uf.issame(x,y)){\n                cout<<uf.diff(x,y)<<endl;\n            }\n            else{\n                cout<<\"?\"<<endl;\n            }\n        }\n        else{\n            cin>>x>>y>>z;\n            uf.merge(x,y,z);\n        }\n    }\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nnamespace SOLVE {\n\tVI diff; // difference to root\n\tVI parent;\n\n\tvoid update(int x) { // finds the distance of vertex from parent\n\t\tint og = x, ogparent = parent[x];\n\t\tif (ogparent == og) { // x itself is a root\n\t\t\treturn;\n\t\t}\n\t\tif (ogparent == parent[ogparent]) { // x is already a secondary\n\t\t\treturn;\n\t\t}\n\t\tupdate(ogparent); // update the node ahead of it otherwise\n\n\t\tparent[og] = parent[ogparent];\n\t\tdiff[og] += diff[ogparent];\n\t}\n\n\n\tvoid relate(int x, int y, int z) {\n\t\tupdate(x);\n\t\tupdate(y);\n\t\tif (parent[x] != parent[y]) {\n\t\t\tdiff[parent[y]] = z - diff[y];\n\t\t\tparent[parent[y]] = x;\n\t\t}\t\t\n\t}\n\n\tvoid distance(int a, int b) {\n\t\tupdate(a);\n\t\tupdate(b);\n\t\tif (parent[b] != parent[a]) {\n\t\t\tcout << '?' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << diff[b] - diff[a] << endl;\n\t\t}\n\t\treturn;\n\t}\n\n\tvoid main() {\n\t\tint n, q;\n\t\tint a, b, c, d;\n\t\tcin >> n >> q;\n\t\tparent.resize(n);\n\t\tdiff.resize(n, 0);\n\n\t\tREP(i, 0, n) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tREP(i, 0, q) {\n\t\t\tcin >> a;\n\t\t\tif (a == 0) {\n\t\t\t\tcin >> b >> c >> d;\n\t\t\t\trelate(b, c, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> b >> c;\n\t\t\t\tdistance(b, c);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <utility>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nusing ll = long long;\nconstexpr ll INF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\n\nstruct UnionFind {\n    vector<int> par, weight;\n    UnionFind(int n) :par(n,-1), weight(n) {}\n    void unite(int x, int y, int w = 0) {\n        w += get_weight(x); w -= get_weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return;\n        if (par[x] > par[y]) swap(x, y), w = -w;\n        par[x] += par[y];\n        par[y] = x;\n        weight[y] = w;\n        return;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) {\n        if(par[x] < 0) return x;\n        int r = root(par[x]);\n        weight[x] += get_weight(par[x]);\n        return par[x] = r;\n    }\n    int sizeOf(int x) { return -par[root(x)]; }\n    int get_weight(int x) { root(x); return weight[x]; }\n    int diff(int x, int y) { return get_weight(y) - get_weight(x); }\n};\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int N,M;cin>>N>>M;\n    UnionFind uf(N);\n    int L,R,D,A;\n    for(int i=0;i<M;++i){\n        cin>>A>>L>>R;\n        if(A==0){\n            cin>>D;\n            uf.unite(L,R,D);\n        } else {\n            if(uf.same(L,R)){\n                cout << uf.diff(L,R) << '\\n';\n            } else {\n                cout << '?' << '\\n';\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                  友利奈緒ぱわーでACしてくれ！！！！！！！！！！！！\n                  Charlotteまだ見てない人は見ような！！！！！！！\n\n                  ／　 /:／　　　　　　　　　　　 　 ＼:ヽ　＼\n  　　　　　　　 /　　／　　　　　　 　 　 　 　 　 　 　 ＼　　ヽ\n  　　　　　＼__L 彡　　　　　　　　　　　　　　　　　　　 ヽ　　',\n  　　　　　　　ﾌ /　　　/　　/　 /　　　,　　 　 　 　 ヽ　　', 　ｊ\n  　　　　　　　ﾚ　　　 /　　/ 　/　 　 　 　 　 　 　 　 ', 　ヽ　j\n  　　　 　 　 // 　 　 !　/_l＿/__ノ 　　{ ＼}　　　　 　 ',　　',/\n  　　　　　　i ﾊ 　 　 {　从j　ﾊ　i　　　 ',　 ト-､}　 i i　 }　　jj\n  　　　　　　( ﾊ　　　(　 川　ハ ﾊ　 !　 '　ﾊ　 ﾊ　j j　,' 　 八\n  　　　 ＜＿,ｨ∧　　　斗芹ﾃミxハ ﾊ　 ﾚ　} /__ﾚﾚ　/ 　 ∧ ＼　ﾉ\n  　　　 　 　 ∨　＼ 　ゝ　辷:ソ　　 　)　芹ﾚ心ヾレ′　/ ト--　´\n  　　　＼ｰ‐'　ﾉ　　 ＼ゝ　　　　　　 　 　 ゞ:_ソ \"/ 　／ 　ヽ\n  　　　　 　 フ　　　　i八 \" \"　　　,　　　　　　　ム彡　　　　＼\n  　　　　 　/　　/　　j　 ト　　　　　　 　 　 \" \"イト＜　 　 　 ＼＼\n  　　　　 /　　/　　　j　/／ヽ､ 　 ∩　　 　 イ　{ {　　￣ フフへ ＼＼\n  　　　　(　／　　　 ,/ / 　　i　＞――＜ニニニﾆ┐　 〃／: : ヽ　ヽヽ\n  　　　　／　　ィT´/ /┌―　￣￣ /::: , ,)　 　 　 〃／／: : : : : :}　ヽヽ)\n  　　　/ /　 ∧ヾi┌― { {￣　　　 ﾉ:::トﾟ<　 　 　 ∥//: : : : : : : : i　 ﾉ ﾉ\n  . 　　( 人　 {:ヽヾi∨　∧V　　　 /:::/　､ヽ　　　 ∥/: : : : : : : : : :}　/\n  　　　V　( ∧: :＼'∨　∧V　　 ﾉ:::/　 ∧ 〉＿__∥: : : : : :／: : : :ﾚ\n  　　 　 　 /∧: : : : ∨　∧V┬ｲ:::ﾉ　 〈 TT　|　|{{: : : : ／: : : : : ∧　　 ﾉ\n  　　　 　 (　ハ: : : : :∨'T∧Vi　i (　 　 V　!　!　{{: : ／ : : : : : : /　ｰ　ノ\n  　　　　　V　ハ: : : : :∨ﾍ∧V　i ゝゝ　 i／⌒＼{／ : : : : : : : /ｰ― ´\n  　　　　　 ∨　ヽ: : : : :∨ﾍ∧∨i　〉 〉 /　/二　 ): : : : : : : : :/\n\n          (https://seesaawiki.jp/asciiart/d/Charlotte より)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n// #define int ll\n// #define DEBUG 42\ninline void nprint(){}\ntemplate <class Head, class... Tail>\ninline void nprint(Head &&head, Tail &&... tail) {\n    cout << head << endl;\n    nprint(move(tail)...);\n}\n#ifdef DEBUG\n  #define eprint(...) nprint(__VA_ARGS__)\n#else\n  #define eprint(...) if(0==1) cout << 1 << endl;\n#endif\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << endl\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << endl\n#define POSSIBLE(a) cout << (a ? \"POSSIBLE\" : \"IMPOSSIBLE\") << endl\nusing cmp = complex<double>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) REP(i,n+1)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPS(i,n) RREP(i,n+1)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define PERM(c) sort(ALL(c)); for(bool cp = true;cp;cp = next_permutation(ALL(c)))\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconst ll MOD = 1E9+7;\nint dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p){\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\nstruct union_find{\n  vector<long long> data;//そのノードがrootであれば-（集合のサイズ）を表し、そうでなければ親ノードidを示す。\n  vector<long long> diff_weight;\n  union_find(long long size, long long abel_sum_unity = 0)\n  :data(size,-1),diff_weight(size,abel_sum_unity){}//コンストラクタ,size個のノードを作成し、-1で初期化\n  //根を探す,経路圧縮\n  inline long long root(long long a){\n    if(data[a]<0) return a;\n    long long r = root(data[a]);\n    diff_weight[a] += diff_weight[data[a]];\n    return data[a] = r;\n    // return data[a] < 0 ? a : data[a]=root(data[a]),diff_weight[a] += diff_weight[data[a]];\n  }\n  //a,bが同じ集合に属するか調べる\n  inline bool same(long long a,long long b){\n    return root(a) == root(b);\n  }\n  //小さい方の木の根に大きい方の根を上書きする\n  inline bool unite(long long a,long long b, long long w=1){\n    w += weight(a) - weight(b);\n    a = root(a),b = root(b);\n    if(a==b) return false;//根が同じなら終了,uniteが失敗したことを出力\n    if(-data[a]<-data[b]) swap(a,b),w=-w; //-data[a]≥-data[b]となるようにswap\n    //集合サイズの大きい方に小さい方をつける。\n    data[a] += data[b];//集合サイズを統合\n    data[b] = a;//bの親をaにする。\n    diff_weight[b] = w;\n    return true;//unite成功を出力\n  }\n  //aが属する集合のサイズを出力\n  inline long long size(long long a){\n    return -data[root(a)];\n  }\n  //root(a)からaまでの距離を返す。\n  inline long long weight(long long a){\n    root(a);\n    return diff_weight[a];\n  }\n  inline long long diff(long long a,long long b){\n    return weight(b) - weight(a);\n  }\n};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n,q;\n  cin >> n >> q;\n  union_find t(n);\n  REP(i,q){\n    int f,x,y;\n    cin >> f >> x >> y;\n    if(f==0){\n      int z;\n      cin >> z;\n      t.unite(x,y,z);\n    }else{\n      if(!t.same(x,y)) cout << '?' << endl;\n      else cout << t.diff(x,y) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(int argc,char* argv[]){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n\treturn 1;\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define int long long\n#define vec(a,n) vector<int> (a)((n));\n#define Vec(a,n) vector<string> (a)((n));\n#define twovec(a,n,m) vector<vector<int>> a(n,vector<int>(m,0));\n#define Twovec(a,n,m) vector<vector<double>> a(n,vector<double>(m,0));\n#define P pair<int,int>\n#define All(a) (a).begin(),(a).end()\n#define Sort(a) sort(All(a));\n#define Reverse(a) reverse(All(a));\n#define PQ(n) priority_queue<P,vector<P>,greater<P>> (n)\n#define pq(n) priority_queue<int> (n)\n#define print(a) cout << (a) << endl;\n#define printD(a) cout << setprecision(10) << ans << endl;\nusing namespace std;\nint max_int = 1000000007;\nvoid Debug(auto a);\nint nibul(auto a,auto b);\nint nibuu(auto a,auto b);\nvoid input(vector<int>& a,int n);\n\nint n;\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\nstruct UnionFind_w {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n    vector<int> diff_weight;\n    UnionFind_w(int n){ //最初は全てが根であるとして初期化\n        init(n);\n    }\n    void init(int n) {\n        par.resize(n);\n        diff_weight.resize(n);\n        REP(i,n){\n            par[i] = i;\n            diff_weight[i] = 0;\n        }\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        int r = root(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    void unite(int x, int y,int w) { // xとyの木を併合\n        w -= weight(x);\n        w += weight(y);\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n        diff_weight[rx] = w;\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n\n    int diff(int x,int y){\n        return weight(x) - weight(y);\n    }\n};\n\n\nsigned main(){\n    cin >> n;\n    UnionFind_w uf(n);\n    int q;\n    cin >> q;\n    REP(i,q){\n        int a;\n        cin >> a;\n        if(a==0){\n            int x,y,z;\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        }\n        else{\n            int x,y;\n            cin >> x >> y;\n            if(uf.same(x,y)){\n                cout << uf.diff(x,y) << endl;\n            }\n            else{\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n\nvoid Debug(auto a){\n    cout << \"{ \";\n    for(auto b: a){\n        cout << b << \" \";\n    }\n    cout << \"}\" << endl;\n}\nint nibul(auto a,auto b){\n    int x = lower_bound(All(a),b) - a.begin();\n    //key以上の初めてのitr\n    return x;\n}\nint nibuu(auto a,auto b){\n    int x = upper_bound(All(a),b) - a.begin();\n    //key以下の最後のitr\n    return x-1;\n}\n\nvoid input(vector<int>& a,int n){\n    REP(i,n){\n        cin >> a[i];\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nclass UnionFind {\n    private:\n        vector<int> parent;  // 親\n        vector<int> rank;    // 木の深さ\n\n        // 重み付きUnionFindでのみ利用\n        vector<T> diffWeight; // 親ノードとの値の差\n    public:\n        UnionFind(int n);          // n要素で初期化\n        int Find(int x);           // 木の根を返す\n        void Unite(int x, int y);  // xとyの属する集合を併合\n        bool Same(int x, int y);   // xとyが同じ集合に属するか否か\n        \n        // 重み付きUnionFindでのみ利用\n        void Unite(int x, int y, T w);\n        T Weight(int x);      // xの重みを返す\n        T Diff(int x, int y); // xとyの差を返す\n};\n\ntemplate <typename T>\nUnionFind<T>::UnionFind(int n) : parent(n), rank(n), diffWeight(n, 0)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\ntemplate <typename T>\nint UnionFind<T>::Find(int x) {\n    if (parent[x] == x) {\n        return x;\n    } else {\n        diffWeight[x] += diffWeight[parent[x]];\n        return parent[x] = Find(parent[x]);\n    }\n}\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ntemplate <typename T>\nbool UnionFind<T>::Same(int x, int y) { return Find(x) == Find(y); }\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y, T w){\n    w += Weight(x); w -= Weight(y);\n    x = Find(x); y = Find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) swap(x, y), w = -w;\n\n    if(rank[x] == rank[y]) rank[x]++;\n    parent[y] = x;\n\n    diffWeight[y] = w;\n}\n\ntemplate <typename T>\nT UnionFind<T>::Weight(int x){\n    Find(x);\n    return diffWeight[x];\n}\n\ntemplate <typename T>\nT UnionFind<T>::Diff(int x, int y){\n    return Weight(y) - Weight(x);\n}\n\n/*************** using variables ***************/\nint n, q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    UnionFind<int> uf(n);\n    REP(i, q){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.Unite(x, y, z);\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(uf.Same(x, y)) cout << uf.Diff(x, y) << endl;\n            else cout << '?' << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tusing pid = pair<int, T>;\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id] = { a, data[id].second + d };\n\t\t}\n\t\tcopy(all[b].begin(), all[b].end(), back_inserter(all[a]));\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 10000001;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] > 10000000) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\tmap<int, int>mp, mp2;\n\tvector<pair<int, int>>p;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\t//mp.insert(pair<int, int>(x, 0));\n\t\t\t//mp.insert(pair<int, int>(y, 0));\n\n\t\t\t//if (flag[x] == -1 && flag[y] == -1) {\n\t\t\tif ( mp2.count(x) == 0 && mp2.count(y) == 0 ) {\n\t\t\t\tset<int>st;\n\n\t\t\t\tst.insert(x);\n\t\t\t\tst.insert(y);\n\t\t\t\t//st.insert({ x,y });\n\n\t\t\t\tnum.push_back(st);\n\t\t\t\t//flag[x] = num.size() - 1;\n\t\t\t\t//flag[y] = num.size() - 1;\n\n\t\t\t\t//mp.insert(pair<int, int>(num.size() - 1, x));\n\t\t\t\t//mp.insert(pair<int, int>(num.size() - 1, y));\n\t\t\t\tp.push_back(make_pair(num.size() - 1, x));\n\t\t\t\tp.push_back(make_pair(num.size() - 1, y));\n\n\t\t\t\tmp2.insert(pair<int, int>(x, num.size() - 1));\n\t\t\t\tmp2.insert(pair<int, int>(y, num.size() - 1));\n\n\t\t\t\t//flag[y] = flag[x] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\t//else if (flag[x] != -1 && flag[y] != -1) {\n\t\t\telse if (mp2.count(x) != 0 && mp2.count(y) != 0 ){\n\t\t\t\t//if (flag[x] == flag[y]) {\n\t\t\t\t\t/*\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}*/\n\t\t\t\t//}\n\t\t\t\t//else if (flag[x] < flag[y]) {\n\t\t\t\t/*\n\t\t\t if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}*/\n\t\t\t\t//else if (flag[x] > flag[y]) {\n\t\t\t\t\t//int yy = flag[y];\n\t\t\t\t\t//int xx = flag[x];\n\t\t\t\t\tint yy = mp2[y];\n\t\t\t\t\tint xx = mp2[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\t//num[flag[y]].insert(*itr);\n\t\t\t\t\t\tnum[yy].insert(*itr);\n\t\t\t\t\t\t//flag[*itr] = flag[y];\n\t\t\t\t\t\tmp2[*itr] = yy;\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\t//auto itr = mp.find(xx);      \n\t\t\t\t\tsort(p.begin(), p.end(), greater<pair<int,int>>());\n\n\t\t\t\t\tfor (int ii = 0; ii < p.size(); ii++) {\n\t\t\t\t\t\tif (p[ii].first <= x) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//if (p[ii].first > x) {\n\t\t\t\t\t\t\tmp2[p[ii].second]--;\n\t\t\t\t\t\t\tp[ii].first--;\n\t\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\tif (itr != mp.end()) {\n\t\t\t\t\t\t//設定されている場合の処理\n\t\t\t\t\t\t//itr++;\n\t\t\t\t\t\tfor (; itr != mp.end() && (*itr).first > xx; itr++) {\n\t\t\t\t\t\t\tmp2[(*itr).second]--;\n\t\t\t\t\t\t\t//flag[(*itr).second]--;\n\t\t\t\t\t\t\t//(*itr).first = (*itr).first - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//設定されていない場合の処理\n\t\t\t\t\t}*/\n\t\t\t\t\t//num[xx].erase(num[xx].begin(), num[xx].end());\n\t\t\t\t\tnum.erase(num.begin() + xx);\n\n\t\t\t\t//}\n\t\t\n\t\t\t}\n\t\t\t//else if (flag[x] != -1) {\n\t\t\telse if (mp2.count(x) != 0) {\n\t\t\t\t//num[flag[x]].insert(y);\n\t\t\t\tnum[mp2[x]].insert(y);\n\t\t\t\t//flag[y] = flag[x];\n\n\t\t\t\tmp2.insert(pair<int, int>(y, mp2[x]));\n\t\t\t\t//mp.insert(pair<int, int>(mp2[x], y));\n\t\t\t\tp.push_back(make_pair(mp2[x], y));\n\t\t\t\t\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\t//else if (flag[y] != -1) {\n\t\t\telse if (mp2.count(y) != 0) {\n\t\t\t\t//num[flag[y]].insert(x);\n\t\t\t\tnum[mp2[y]].insert(x);\n\t\t\t\t//flag[x] = flag[y];\n\n\t\t\t\tmp2.insert(pair<int, int>(x, mp2[y]));\n\t\t\t\t//mp.insert(pair<int, int>(mp2[y], x));\n\t\t\t\tp.push_back(make_pair(mp2[y], x));\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\t//mp.insert(pair<int, int>(x, 0));\n\t\t\t//mp.insert(pair<int, int>(y, 0));\n\n\t\t\t//if (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\tif (mp2.count(x) != 0 && mp2.count(y) != 0 && mp2[x] == mp2[y]) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF 1001001001\n\nint n;\nvector<int> par, ranks, weight;\n\nvoid init(int n) {\n  ranks.assign(n,0);\n  weight.assign(n,0);\n  par.resize(n);\n  iota(par.begin(), par.end(), 0);\n}\n\nint root(int x) {\n  if (par[x] == x) return x;\n  int rx = root(par[x]);\n  weight[x] += weight[par[x]];\n  return par[x] = rx;\n}\n\nbool isSame(int x, int y) {\n  return root(x) == root(y);\n}\n\nint getWeight(int x) {\n  root(x); // 経路圧縮\n  return weight[x];\n}\n\nint getDiff(int x, int y) {\n  return getWeight(y) - getWeight(x);\n}\n\nbool merge(int x, int y, int w) {\n  int rx = root(x);\n  int ry = root(y);\n  if (rx == ry) return false;\n\n  int rw = w;\n  rw += getWeight(x);\n  rw -= getWeight(y);\n\n  if (ranks[rx] < ranks[ry]) swap(rx,ry), rw = -rw;\n  par[ry] = rx;\n  weight[ry] = rw;\n  if (ranks[rx] == ranks[ry]) ranks[rx]++;\n\n  return true;\n}\n\nint main(int, char**)\n{\n  cin >> n;\n  init(n);\n\n  int q; cin >> q;\n  vector<int> ans;\n  rep(i,q) {\n    int command;\n    cin >> command;\n    if (command == 0) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      merge(x,y,z);\n    } else {\n      int x, y;\n      cin >> x >> y;\n      if (isSame(x,y)) ans.push_back(getDiff(x,y));\n      else ans.push_back(INF);\n    }\n  }\n  for (auto a : ans) \n    if (a!=INF) cout << a << endl;\n    else cout << \"?\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/DSL1B.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B\"\n\n// header file section\n#include <iostream>\n#include <cstdio>\n#include <cfloat>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <algorithm>\n#line 1 \"disjoint_set/weighted_union_find.hpp\"\n\n\n#line 4 \"disjoint_set/weighted_union_find.hpp\"\n\n//===\ntemplate<class Abel>\nstruct WeightedUnionFind {\n    using T = typename Abel::value_type;\n\n    std::vector<int> parent; // [i] = i-th node's parent. if [i] < 0, i-th node is root.\n    std::vector<T> diff_weight; // distance from parent\n    \n    WeightedUnionFind() = default;\n    WeightedUnionFind(int nmemb) {\n        init(nmemb);\n    };\n\n    void init(int nmemb) {\n        parent.resize(nmemb, -1);\n        diff_weight.resize(nmemb, Abel::identity());\n    };\n\n    int root(int x) {\n        if (parent[x] < 0) return x;\n        \n        int p = root(parent[x]);\n        diff_weight[x] = Abel::operation(diff_weight[x], diff_weight[parent[x]]);\n        parent[x] = p;\n\n        return p;\n    };\n\n    // unite x, y; weight(y) - weight(x) = w\n    bool unite(int x, int y, T w) {\n        T wx = weight(x);\n        T wy = weight(y);\n        x = root(x);\n        y = root(y);\n\n        if (x == y) return false;\n        w = Abel::operation(w, wx);\n        w = Abel::operation(w, Abel::inverse(wy));\n        if (size(x) < size(y)) std::swap(x, y), w = Abel::inverse(w);\n\n        parent[x] += parent[y];\n        parent[y] = x;\n        diff_weight[y] = w;\n        \n        return true;\n    };\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    };\n\n    T weight(int x) {\n        root(x);\n        return diff_weight[x];\n    };\n\n    T diff(int x, int y) {\n        return Abel::operation(weight(y),\n                Abel::inverse(weight(x)));\n    };\n\n    int size(int x) {\n        return -parent[root(x)];\n    };\n};\n//===\n\n\n#line 17 \"test/aoj/DSL1B.test.cpp\"\n\nusing namespace std;\nusing llong = long long;\n\nstruct A {\n    using T = llong;\n    using value_type = T;\n\n    static inline T identity() {\n        return 0;\n    };\n\n    static inline T operation(T x, T y) {\n        return x + y;\n    };\n\n    static inline T inverse(T x) {\n        return -x;\n    };\n};\n\nllong n, q;\nllong com, x, y, w;\n\nint main() {\n    cin >> n >> q;\n    WeightedUnionFind<A> uf(n);\n\n    while (q--) {\n        cin >> com;\n\n        if (com == 0) {\n            cin >> x >> y >> w;\n            uf.unite(x, y, w);\n        }\n        else {\n            cin >> x >> y;\n\n            if (uf.same(x, y)) {\n                cout << uf.diff(x, y) << '\\n';\n            }\n            else {\n                cout << \"?\\n\";\n            }\n        }\n    }\n\n    return 0;\n};\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n#define rep(i,a,b) for(int64_t i=(a); i<(b); ++i) // a ≦ i < b \n#define Rrep(i,a,b) for(int64_t i=(a);i>=(b);--i) // reverse repeat. a から b まで減少．\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend() //逆イテレータ\n#define INF 10000000000000\n#define MOD 1000000007LL\n#define RANGE(a,b,c) (a).begin()+(b),(a).begin()+(c) // [b,c) イテレータ\nusing PII = pair<int64_t, int64_t>;\nusing VI = vector<int64_t>;\nusing VVI = vector<VI>;\nusing VS = vector<string>;\nusing VP = vector<PII>;\nusing i64 = int64_t;\ntemplate<typename T> void invec(vector<T> &A){for(T& a : A) cin >> a;} // input vector\n\nstruct weighted_DisjointSet {\n    vector<int> par; //根.連結成分の根にはその成分の要素数を符号反転して保存する．\n    vector<int64_t> diff_weight;\n\n    weighted_DisjointSet(int n) : par(n, -1), diff_weight(n, 0) {} //.0-indexed \n    void init(int n) {par.assign(n, -1);}// 初期化\n\n    int root(int x) {\n        if (par[x] < 0) return x; //根が負なら自身が根．\n        else {\n            int r = root(par[x]);//径路圧縮\n            diff_weight[x] += diff_weight[max(0, par[x])];\n            return par[x] = r; \n        }\n    }\n    \n    // 連結判定\n    bool issame(int x, int y) { return root(x) == root(y); }\n\n    // weight(y) = weight(x) + w . 親x,子y.\n    bool unite(int x, int y, int w) { // 結合が行われればtrue.行われなければfalse.\n        w += weight(x) - weight(y);\n        x = root(x); y = root(y); // 径路圧縮\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y), w = -w; \n        par[x] += par[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    int64_t size(int x){ return -par[root(x)]; }\n\n    int weight(int x){ \n        root(x); // 径路圧縮\n        return diff_weight[x];\n    }\n    int diff(int x, int y){ return weight(y) - weight(x); }\n};\n\nint main() {\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\nint n, q; cin >> n >> q;\nweighted_DisjointSet DS(n);\n\nrep(_, 0, q){\n    int com, x, y, z; cin >> com;\n    if (com) {\n        cin >> x >> y;\n        if (DS.issame(x, y)) cout << DS.diff(x, y) << \"\\n\";\n        else cout << \"?\\n\";\n    }\n    else {\n        cin >> x >> y >> z;\n        DS.unite(x, y, z);\n    }\n}\n\n\n}\n// 書いて考える．場合分け．情報整理．\n// 境界，出力文字列 チェック．行末にスペース入れない．\n// 可読性優先．高速化次点．\n// まずは全探索，分割，次にDP\n// 制限を見る．境界に注意．求めたい量の変域．動かせる量．\n// 偶奇，逆から，ソート，出現回数，出現位置，DP， 余事象，包除\n// データ構造． 問題の特徴量．単調性，二分探索\n// 存在判定：構成方法，入力の特徴\n// gcd, lcm ,素因数分解．\n// 例外を十分に含む一般化．想像力の限界\n// 小さい系から例示\n// 代数的処理．前処理によるクエリ高速化．\n// 始めは過剰に例示・場合分けしてもいい．各場合を確実に対処．\n// 自明な例から処理，除外．\n// 小数のときは，精度の設定する．doubel 変数に数値を入力するときは 123. とする．\n// テストケース作成は数表あり\n// 実行エラー：vector添え字超え．0割り．\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <numeric>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF 10e17 // 4倍しても(4回足しても)long longを溢れない\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rep_r(i,n,m) for(int i=m; i<n; i++)\n#define END cout << endl\n#define MOD 1000000007\n#define pb push_back\n#define sorti(x) sort(x.begin(), x.end())\n#define sortd(x) sort(x.begin(), x.end(), std::greater<int>())\n#define debug(x) std::cerr << (x) << std::endl;\n#define roll(x) for (auto itr : x) { debug(itr); }\n\ntemplate <class T> inline void chmax(T &ans, T t) { if (t > ans) ans = t;}\ntemplate <class T> inline void chmin(T &ans, T t) { if (t < ans) ans = t;}\n\n\ntemplate<class T> \nclass UnionFind {\n  using _Tp = T;\n  using size_type = std::size_t;\npublic:\n  vector<int> par;\n  vector<int> rank;\n  vector<_Tp> diff_weight;\n \n  UnionFind(int n = 1, _Tp SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  const _Tp & operator[] (size_type i) {\n    root(i);\n    return diff_weight[i];\n  }\n \n  void init(int n = 1, _Tp SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n \n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      int r = root(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n \n  _Tp weight(int x) {\n    root(x);\n    return diff_weight[x];\n  }\n \n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n \n  bool merge(int x, int y, _Tp w) {\n    w += weight(x); w -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n \n  _Tp diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n};\n\n\nint main() {\n  int n,q;\n  cin >> n >> q;\n  UnionFind<int> uf(n+1);\n\n  rep(i, q) {\n    int j;\n    cin >> j;\n    int x,y,z;\n    if (j) {\n      cin >> x >> y;\n      if (uf.issame(x,y)) {\n        cout << uf[y] - uf[x] << endl;\n      } else {\n        cout << \"?\" << endl;\n      }\n    } else {\n      cin >> x >> y >> z;\n      uf.merge(x,y,z);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      // z -= diffWeight[x];\n      // z += diffWeight[y];\n      z += diffWeight[y] - diffWeight[x];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << abs(getWeight(y)-getWeight(x)) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  // for(int i=0 ;  i<n ; ++i){\n  //   cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,rank,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    int rootx = findSet(x), rooty = findSet(y);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\n#define MAX_N 200000\n\nusing namespace std;\n\nint par[MAX_N];\nint rnk[MAX_N];\nlong long int diff[MAX_N];\n\n// 初期化\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tdiff[i] = 0;\n\t}\n}\n\n// x の親を返す\nP find(int x){\n\tP p;\n\tif(par[x] == x){\n\t\tp.first = x;\n\t\tp.second = 0;\n\t\treturn p;\n\t}\n\tp = find(par[x]);\n\tdiff[x] += p.second;\n\tp.second = diff[x];\n\tpar[x] = p.first;\n\treturn p;\n}\n\n// x と y を併合する\nvoid unite(int x, int y, int z){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\tif(x_par == y_par){\n\t\treturn;\n\t}\n\t\n\tif(rnk[x_par] < rnk[y_par]){\n\t\tpar[x_par] = y_par;\n\t\tdiff[x_par] = diff[y_par] - px.second + py.second + z;\n\t}else{\n\t\tpar[y_par] = x_par;\n\t\tdiff[y_par] = diff[x_par] + px.second - py.second - z;\n\t\tif(rnk[x_par] == rnk[y_par]){\n\t\t\trnk[x_par]++;\n\t\t}\n\t}\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\treturn (x_par == y_par);\n}\n\nint main(){\n\t\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tinit(n);\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tint num, a, b, c;\n\t\tcin >> num >> a >> b;\n\t\tif(num == 0){\n\t\t\tcin >> c;\n\t\t\tunite(a, b, c);\n\t\t}else{\n\t\t\tif(!same(a, b)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << diff[a] - diff[b] << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << par[j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << diff[j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//重み付きUnion-Find木\n//参考 https://qiita.com/drken/items/cce6fc5c579051e64fab\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_B\n\n#include<iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX_N 500000//頂点の最大数\n\nll par[MAX_N];//親の番号\nll urank[MAX_N];//集合のランク\nll usize[MAX_N];//集合の要素数\nll diff_weight[MAX_N];//親との距離\nll num;//集合の数\n\nvoid init(ll n) {//初期化\n    num = n;\n    rep(i,n) {\n        par[i] = i;\n        urank[i] = 0;\n        usize[i] = 1;\n        diff_weight[i] = 0;\n    }\n}\n\nll find(ll x) {//根の添字を返すと同時に経路圧縮をする\n    if(par[x] == x) {\n        return x;\n    }else {\n        ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];//累積和\n        return par[x] = r;\n    }\n}\n\nbool same(ll x,ll y) {\n    return find(x) == find(y);\n}\n\nll weight(ll x) {//親との距離を求める\n    find(x);\n    return diff_weight[x];\n}\n\nll diff(ll x,ll y) {//xからyに行くときのポテンシャルの増加分\n    return weight(y) - weight(x);\n}\n\nll get_usize(ll x) {//xが属する集合の要素数を返す。\n    return usize[find(x)];\n}\n\nbool unite(ll x,ll y,ll w) {//weight(y) = weight(x) + w (diff(x,y) = w) となるようにxの属する集合とyの属する集合をマージ\n    if(urank[x] < urank[y]) {swap(x,y);w*=-1;}//x(のroot)の下にy(のroot)をつけるので反転\n\n    w += weight(x);w -= weight(y);\n    //x(のroot)の下にy(のroot)をつけるので、w=diff(xのroot,yのroot)となるように\n\n    x = find(x);y = find(y);\n\n    if(x == y) {\n        return diff(x,y) == w;\n    }\n\n    //x(のroot)の下にy(のroot)をつける。\n    if(urank[x] == urank[y]) urank[x]++;\n    par[y] = x;\n\n    diff_weight[y] = w;\n\n    return true;\n}\n\nll num_set() {\n    return num;\n}\n\nll n,q;\nint main() {\n    cin >> n >> q;\n    init(n);\n\n    rep(i,q) {\n        ll c,x,y,z;\n\n        cin >> c;\n        if(c) {\n            cin >> x >> y;\n            if(same(x,y)) cout << diff(x,y) << endl;\n            else cout << '?' << endl;\n        }else {\n            cin >> x >> y >> z;\n            unite(x,y,z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\n#define int long long\n//#define double long double\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\ntypedef pair<int, pii > pip;\ntypedef pair<pii, pii > piipii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define all(vec) vec.begin(), vec.end()\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60)\n#define mod 1000000007\n#define se second\n#define fi first\n\nint N, Q;\n\nint par[100100];\nint rnk[100100];\nint dif[100100];\n\nvoid init(){\n    for(int i = 0; i < N; i++){\n        par[i] = i;\n        rnk[i] = 0;\n        dif[i] = 0;\n    }\n}\n\nint root(int x){\n    if(x == par[x]){\n        return x;\n    }\n    else {\n        int r = root(par[x]);\n        dif[x] += dif[par[x]];\n        return par[x] = r;\n    }\n}\n\nbool same(int x, int y){\n    return (root(x) == root(y));\n}\n\nint weight(int x){\n    root(x);\n    return dif[x];\n}\n\nint diff(int x, int y){\n    return weight(y) - weight(x);\n}\n\nbool unite(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = root(x);\n    y = root(y);\n\n    if(rnk[x] < rnk[y]){\n        swap(x, y);\n        w = -w;\n    }\n    if(rnk[x] == rnk[y]){\n        rnk[x]++;\n    }\n    par[y] = x;\n\n    dif[y] = w;\n\n    return true;\n}\n\nsigned main(){\n    cin >> N >> Q;\n    init();\n    for(int i = 0; i < Q; i++){\n        int c, x, y, z;\n        cin >> c >> x >> y;\n        if(c){\n            if(!same(x, y)){\n                cout << \"?\" << endl;\n            }\n            else cout << diff(x, y) << endl;\n        }\n        else {\n            cin >> z;\n            unite(x, y, z);\n        }\n    }\n    \n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef vector<ld> vd;\ntypedef vector<ll> vll;\ntypedef vector<string> vstr;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<pair<ll, ll>> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i, a, b) for (ll i = (ll)a; i < (ll)b; i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n#define FI first\n#define SE second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define TS to_string\n#define NP next_permutation\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(x) (ll) x.size()\n#define SP(x) setprecision((ll)x)\n\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"Yes\" << endl;}\nvoid no(){ cout << \"No\" << endl;}\n\n//-----------------------------------------\nclass union_find{\n  private:\n    ll N; //要素数\n    ll ER = 1e18; // x,yが同じ集合にない時の重みの差(場合によって編集)\n    vll par; // iの親\n    vll rank; // 木の深さ\n    vll siz; // iの属する集合の要素数\n    vll weig; // iの重さ\n    \n  public:\n    // 要素の初期化\n    union_find(ll n){\n      N = n;\n      par.resize(N); rank.resize(N);\n      siz.resize(N); weig.resize(N);\n      for(ll i=0;i<N;i++){\n        par[i] = i; rank[i] = 0;\n        siz[i] = 1; weig[i] = 0;\n      }\n    }\n\n    // 木の根を求める\n    ll root(ll x){\n      if(par[x] == x) return x;\n      else{\n        ll r = root(par[x]);\n        weig[x] += weig[par[x]];\n        return par[x] = r;\n      }\n    }\n\n    // 根まで辿って根に対する重みを得る\n    ll weight(ll x){\n      root(x);\n      return weig[x];\n    }\n\n    // 木の併合(rank基準) (wはxとyの重みの差 w = w(y) - w(x))\n    void unite(ll x, ll y, ll w = 0){\n      w += (weight(x) - weight(y));\n      x = root(x);\n      y = root(y);\n      if(x == y) return;\n\n      if(rank[x] < rank[y]){\n        par[x] = y;\n        siz[y] += siz[x];\n        w *= -1;\n        weig[x] = w;\n      }\n      else{\n        par[y] = x;\n        siz[x] += siz[y];\n        weig[y] = w;\n        if(rank[x] == rank[y]) rank[x]++;\n      }\n    }\n    // yとxの重みの差 w(y) - w(x)を返す\n    ll diff(ll x, ll y){\n      if(same(x,y)) return weight(y) - weight(x);\n      else return ER; // 同じ集合にない時、ERを返す。\n    }\n\n    // xとyが同じ集合に属するかどうか\n    bool same(ll x, ll y){\n      return root(x) == root(y);\n    }\n\n    // xが木の根であるかどうか\n    bool is_root(ll x){\n      return x == root(x);\n    }\n\n    // xの属する集合の要素数\n    ll size(ll x){\n      return siz[root(x)];\n    }\n\n    // 全体でいくつ集合があるか\n    ll cnt(){\n      ll res = 0;\n      for(ll i=0;i<N;i++) if(i == root(i)) res++;\n      return res;\n    }\n};\n\n\n \n//-----------------------------------------\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  ll n, q;\n  cin >> n >> q;\n  union_find tree(n);\n  REP(i,q){\n    ll com, x, y;\n    cin >> com;\n    if(com){\n      ll x, y;\n      cin >> x >> y;\n      if(tree.diff(x,y)==LINF) cout << \"?\" <<endl;\n      else cout << tree.diff(x,y) <<endl;\n    }\n    else{\n      ll x, y, z;\n      cin >> x >> y >> z;\n      tree.unite(x,y,z);\n    }\n  }\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <map>\nusing namespace std;\n\nmap<int, int> w[100000];\nint kakunin[100000];\n\nint diff(int x, int y, int c){\n    if(x==y)return 0;\n    int ret = INT_MAX;\n    int tmp;\n    map<int,int>::iterator itr;\n    for(itr=w[x].begin();itr!=w[x].end();itr++){\n        if(kakunin[itr->first]==c)continue;\n        kakunin[itr->first]=c;\n        tmp = diff(itr->first,y,c);\n        if(tmp<INT_MAX)ret = itr->second + tmp;\n    }\n    return ret;\n}\n\nint main(){\n    int i,n,q,x,y,z,com;\n    int c=0;\n    memset(kakunin,0,sizeof(int)*100000);\n    scanf(\"%d %d\",&n,&q);\n    for(i=0;i<q;i++){\n        scanf(\"%d\",&com);\n        if(com){\n            scanf(\"%d %d\",&x,&y);\n            c++;\n            int ans = diff(x,y,c);\n            if(ans==INT_MAX)printf(\"?\\n\");\n            else printf(\"%d\\n\",ans);\n        }else{\n            scanf(\"%d %d %d\",&x,&y,&z);\n            w[x][y] = z;\n            w[y][x] = -z;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    if(p[y] != y) {\n        if(cost[y] >= z) {\n            p[x] = p[y];\n            cost[x] = cost[y] - z;\n            p[y] = x;\n            cost[y] = z;\n        }\n        else{\n            p[x] = p[p[y]];\n            p[p[y]] = x;\n            cost[p[y]] = z - cost[y];\n        }\n    }\n    else {\n        p[y] = x;\n        cost[y] = z;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100010\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint n,q;\nint p[MAX],cost[MAX];\n\nvoid init(){\n  FOR(i,0,n){ p[i]=i;cost[i]=0; }\n}\n\npii f(int a){\n  if(p[a]==a)return mp(a,0);\n  pii res=f(p[a]);\n  res.s+=cost[a];\n  p[a]=res.f;\n  cost[a]=res.s;\n  return res;\n}\n\nvoid relate(int a,int b,int c){\n  pii d=f(a),e=f(b);\n  p[d.f]=e.f;\n  cost[d.f]=c-d.s;\n}\n\nvoid diff(int a,int b){\n  pii d=f(a),e=f(b);\n  if(d.f!=e.f)cout<<\"?\"<<endl;\n  else cout<<d.s-e.s<<endl;\n}\n\nint main()\n{\n  cin>>n>>q;\n  init();\n  FOR(i,0,q){\n    int a,b,c,d;\n    cin>>a;\n    if(a==0){\n      cin>>b>>c>>d;\n      relate(b,c,d);\n    }\n    else {\n      cin>>b>>c;\n      diff(b,c);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> s, r, c;\n\nvoid makeSet(int x){\n    s.push_back(x);\n    r.push_back(0);\n    c.push_back(0);\n}\n\nint findSet(int x){\n    int parent = s[x];\n    if(x != s[x]) s[x] = findSet(s[x]);\n    c[x] += c[parent];\n    return s[x];\n}\n\nvoid relate(int x, int y, int z){\n    int rootx = findSet(x);\n    int rooty = findSet(y);\n    if(rootx == rooty) return;\n    z = z + c[x] - c[y];\n\n    if(r[rootx] > r[rooty]){\n        s[rooty] = rootx;\n        c[rooty] = z;\n    }else{\n        s[rootx] = rooty;\n        c[rootx] = -z;\n        if(r[rootx] == r[rooty]){\n            r[rooty] += 1;\n        }\n    }\n}\n\nvoid diff(int x, int y){\n    if(findSet(x) == findSet(y)){\n        cout << c[y] - c[x] << endl;\n    }else{\n        cout << \"?\" << endl;\n    }\n}\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    for(int i = 0; i < n; i++) makeSet(i);\n\n    int com, x, y, z;\n    for(int i = 0; i < q; i++){\n        cin >> com;\n        if(com == 0){\n            cin >> x >> y >> z;\n            relate(x, y, z);\n        }else{\n            cin >> x >> y;\n            diff(x, y);\n        }\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 100010\nint n,q;\n//int p[N],d[N];\nclass UnionFind{\nprivate:\n    int p[N],d[N];\n    int Root(int x){\n\tint a=x,s=0;\n\twhile(a!=p[a])s+=d[a],a=p[a];\n\twhile(x!=a){int t=p[x];p[x]=a,s-=d[x],d[x]+=s,x=t;}\n\treturn a;\n    }\npublic:\n    void Init(){\n\tlol(i,n)p[i]=i,d[i]=0;\n    }\n    void Unite(int a,int b,int c){\n\tint ra=Root(a),rb=Root(b);\n\tp[ra]=rb;\n\td[ra]=c+d[b]-d[a];\n    }\n    int Query(int a,int b){\n\tint ra=Root(a),rb=Root(b);\n\tif(ra!=rb)return mod;\n\treturn d[a]-d[b];\n    }\n};\nint main(){\n    cin>>n>>q;\n    UnionFind uf;uf.Init();\n    while(q--){\n\tint c;cin>>c;\n\tif(c==0){\n\t    int x,y,z;cin>>x>>y>>z;\n\t    uf.Unite(x,y,z);\n\t}\n\tif(c==1){\n\t    int x,y;cin>>x>>y;\n\t    int res=uf.Query(x,y);\n\t    if(res==mod)cout<<\"?\"<<endl;\n\t    else cout<<res<<endl;\n\t}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    if(p[y] != y) {\n        if(cost[y] > z) {\n            p[x] = p[y];\n            cost[x] = cost[y] - z;\n            p[y] = x;\n        }\n        else{\n            p[x] = p[p[y]];\n            p[p[y]] = x;\n            cost[x] = cost[y] - z;\n        }\n    }\n    else {\n        p[y] = x;\n        cost[y] = cost[x] + z;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define dhoom ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);  \ntypedef long long ll;\n#define fi first\n#define se second\n#define sc scanf\n#define pr printf\n#define pb push_back\nconst ll inf = 1e18;\nconst int nax = 2e6 + 7;\nconst ll mod = 1e9 + 7;\nusing namespace std;\nll exp(ll a , ll b){\n\tif(b == 0)\treturn 1;\n\tint x = b % 2 == 0 ?   ((exp(a , b/2)%mod)*(exp(a , b / 2)%mod))%mod :  (a%mod*exp(a , b - 1) % mod)%mod;\n\treturn x;\n}\nint parent[100005], value[100005] , size[100005];\nvoid init(){\n\tfor(int i = 0 ; i <= 100004 ; i++)\n\t{\t\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\nint whoispar(int x){\n\t\tif(parent[x] == x)\n\t\t\treturn x;\n\t\telse{\n\t\t\tint fx = parent[x];\n\t\t\tparent[x] = whoispar(parent[x]);\n\t\t\tvalue[x] += value[fx];\n\t\t\treturn parent[x];\n\t\t} \n\t\treturn parent[x];\n}\n// union by size\nvoid uni(int x , int y , int z){\n\tint parX = whoispar(x);\n\tint parY = whoispar(y);\n\tif(parX != parY){\n\t\tvalue[parX] = z + value[y] - value[x];\n\t\tparent[parX] = parY;\n\t}\n}\nint main(int argc,char ** argv){\n\tdhoom;\n\tint n , q; \n\tcin >> n >> q;\n\tinit();\n\tfor(int i = 0 ; i < q ; i++){\n\t\tint c , l , r , z;\n\t\tcin >> c ;\n\t\tif(c == 0){\n\t\t\tcin >> l >> r >> z;\n\t\t\tuni(l , r , z);\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcin >> l >> r;\n\t\t\tif(whoispar(l) == whoispar(r))\n\t\t\t\tcout << value[l] - value[r]  << endl;\n\t\t\telse \n\t\t\t\tcout << \"?\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    const int V;\n\t// par[x] := xのroot\n\tvector<int> par;\n\t// sz[x] := xを含む集合のサイズ\n\tvector<int> sz;\n    // w[x] := xのrootに対する重み\n    vector<T> w;\n    WeightedUnionFind(const int V) :\n\t\tV(V),\n\t\tpar(vector<int>(V)),\n\t\tsz(vector<int>(V, 1)),\n\t\tw(vector<T>(V))\n\t\t{\n\t\t\tfor(int i = 0; i < V; ++i) par[i] = i;\n\t\t}\n    // w[y] - w[x] = z\n    bool unite(int x, int y, T z) {\n        z = z + weight(x) - weight(y);\n        x = root(x), y = root(y);\n        if(same(x, y)) return false;\n        if(y < x) {\n            swap(x, y);\n            z = -z;\n        }\n        par[y] = x;\n        sz[x] += sz[y];\n        w[y] = z;\n        return true;\n    }\n    int root(int x) {\n    \tif(par[x] == x) return x;\n        root(par[x]); // rootから累積和\n        w[x] += w[par[x]]; // 親の重みを加算する\n    \treturn (par[x] = root(par[x])); // xの親のroot\n    }\n    bool same(int x, int y) {\n    \treturn (root(x) == root(y));\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    T weight(int x) {\n        root(x); // 経路圧縮用\n        return w[x];\n    }\n    T diff(int x, int y) {\n        assert(same(x, y));\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    WeightedUnionFind<int64_t> uf(n);\n    while(q--) {\n        int info, x, y, z; cin >> info >> x >> y;\n        if(info == 0) {\n            cin >> z;\n            uf.unite(x, y, z);\n        } else {\n            if(uf.same(x, y)) {\n                cout << uf.diff(x, y) << '\\n';\n            } else {\n                cout << '?' << '\\n';\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint par[101010];\nint diff[101010];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    int r = find(par[x]);\n    diff[x] += diff[par[x]];\n    return par[x] = r;\n}\n\nint weight(int x) {\n    find(x);\n    return diff[x];\n}\n\nvoid unite(int x, int y, int w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n    par[y] = x;\n    diff[y] = w;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n    }\n    while (q--) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int x, y, w;\n            cin >> x >> y >> w;\n            unite(x, y, w);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (find(x) == find(y)) {\n                cout << weight(y) - weight(x) << endl;\n            } else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////////////////////////////////\n// ポテンシャル付きUnion-Find木(未検証) //\n////////////////////////////////////////\n\n// 0-indexed\nclass UnionFindWithPotential {\nprivate:\n\tstd::vector<int> parent_, size_;\n\tstd::vector<int64_t> potential_delta_;\n\n\t// indexの含まれる木の根のノード番号を返す\n\tint calcRoot(const int index)\n\t{\n\t\tint &parent{parent_[index]};\n\t\tif (parent == index) return index;\n\n\t\tconst int root{calcRoot(parent)};\n\t\tpotential_delta_[index] += potential_delta_[parent];\n\t\tparent = root;\n\t\treturn parent;\n\t}\npublic:\n\tUnionFindWithPotential(const int size)\n\t\t:parent_(size), size_(size, 1), potential_delta_(size)\n\t{\n\t\tfor (int i{}; i < size; i++) parent_[i] = i;\n\t}\n\n\t// index1とindex2の連結判定\n\tbool areConnected(const int index1, const int index2)\n\t{\n\t\treturn calcRoot(index1) == calcRoot(index2);\n\t}\n\n\t// potential(index1) = potential(index2) + weightとなるよう結合\n\tbool unite(const int index1, const int index2, const int64_t weight)\n\t{\n\t\tconst int root1{calcRoot(index1)}, root2{calcRoot(index2)};\n\t\tif (root1 == root2)\n\t\t\treturn potential_delta_[index1] == potential_delta_[index2] + weight;\n\t\tif (size_[root1] <= size_[root2])\n\t\t{\n\t\t\tsize_[root2] += size_[root1];\n\t\t\tpotential_delta_[root1] = (potential_delta_[index2] + weight) - potential_delta_[index1];\n\t\t\tparent_[root1] = root2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsize_[root1] += size_[root2];\n\t\t\tpotential_delta_[root2] = potential_delta_[index1] - (weight + potential_delta_[index2]);\n\t\t\tparent_[root2] = root1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// indexが含まれる木の要素数を返す\n\tint calcSize(const int index)\n\t{\n\t\treturn size_[calcRoot(index)];\n\t}\n\n\t// potential(index1) - potential(index2)を返す\n\t// 根が異なる場合はLLONG_MAXを返す\n\tint64_t calcDiff(const int index1, const int index2)\n\t{\n\t\tif (calcRoot(index1) != calcRoot(index2))\n\t\t\treturn LLONG_MAX;\n\t\treturn potential_delta_[index1] - potential_delta_[index2];\n\t}\n};\n\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tUnionFindWithPotential ufp(n);\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint query, x, y;\n\t\tscanf(\"%d%d%d\", &query, &x, &y);\n\t\tif (query == 0)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tufp.unite(y, x, z);\n\t\t}\n\t\telse if (ufp.areConnected(x, y))\n\t\t\tprintf(\"%lld\\n\", ufp.calcDiff(y, x));\n\t\telse\n\t\t\tputs(\"?\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\nclass Node{\npublic:\n    int parent, rank, weight;\n    Node(int id): parent(id), rank(0), weight(0){}\n};\n\nint find(vector<Node>& nodes, const int& x){\n    if(nodes[x].parent != x){\n        int new_parent = find(nodes, nodes[x].parent);\n        if(new_parent != nodes[x].parent){\n            nodes[x].weight += nodes[nodes[x].parent].weight;\n        }\n        nodes[x].parent = new_parent;\n    }\n    return nodes[x].parent;\n}\nvoid unite(vector<Node>& nodes, const int& x, const int& y, const int& z){\n    int px = find(nodes, x), py = find(nodes, y);\n    int pz = nodes[y].weight - nodes[x].weight + z;\n    if(nodes[px].rank < nodes[py].rank){\n        nodes[px].parent = py;\n        nodes[px].weight = pz;\n    }\n    else if(nodes[py].rank < nodes[px].rank){\n        nodes[py].parent = px;\n        nodes[py].weight = -pz;\n    }\n    else{\n        nodes[py].rank++;\n        nodes[px].parent = py;\n        nodes[px].weight = pz;\n    }\n}\nint main(){\n    int n, q, c, x, y, z; \n    cin >> n >> q;\n    vector<Node> nodes;\n    for(int i = 0; i < n; i++){\n        nodes.push_back(Node(i));\n    }\n    for(int i = 0; i < q; i++){\n        cin >> c;\n        if(c == 0){\n            cin >> x >> y >> z;\n            unite(nodes, x, y, z);\n        }\n        else{\n            cin >> x >> y;\n            int px = find(nodes, x), py = find(nodes, y);\n            if(px != py) cout << \"?\" << endl;\n            else{\n                cout << nodes[x].weight - nodes[y].weight << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    ll n,q;\n    std::cin >> n>>q;\n    \n    UnionFind<ll> uf(n);\n    \n    for (int i = 0; i < q; i++) {\n        ll c;\n        std::cin >> c;\n        if(c==0){\n            ll x,y,z;\n            std::cin >> x>>y>>z;\n            uf.merge(x,y,z);\n        }else{\n            ll x,y;\n            std::cin >> x>>y;\n            if(uf.issame(x,y)){\n                std::cout << uf.diff(x,y) << std::endl;\n            }else{\n                std::cout << \"?\" << std::endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nint height[NUM]; //同じグループに属しているかどうかだけを調べるために使用\nint calc_parent[NUM];\nint relative_weight[NUM]; //自分のボスとの相対的な重さの差を持つ配列\n\nstruct Info{\n\tvoid set(int arg_parent_id,int arg_weight_sum){\n\t\tparent_id = arg_parent_id;\n\t\tweight_sum = arg_weight_sum;\n\t}\n\tint parent_id,weight_sum;\n};\n\nInfo find_parent_and_calc_weight(int id){\n\tif(calc_parent[id] == id){\n\t\tInfo ret;\n\t\tret.set(id,0); //大ボスの相対的重さは必ず0\n\t\treturn ret;\n\t}\n\telse{\n\t\tInfo ret = find_parent_and_calc_weight(calc_parent[id]); //大ボスのidと、自分より上の相対的重さの総和を取得\n\t\tcalc_parent[id] = ret.parent_id;\n\t\trelative_weight[id] += ret.weight_sum; //自分より上の相対的重さを足す\n\t\tret.weight_sum = relative_weight[id];\n\n\t\treturn ret;\n\t}\n}\n\n\n//グループの統合、および相対的重さ木の統合を行う\nvoid unite(int a,int b,int w){\n\n\t//まずは\n\tInfo a_info = find_parent_and_calc_weight(a);\n\tInfo b_info = find_parent_and_calc_weight(b);\n\n\tif(a_info.parent_id == b_info.parent_id)return; //大ボスが同じならreturn\n\n\t//統合処理\n\tif(height[a_info.parent_id] == height[b_info.parent_id]){ //木の高さが同じ場合はaに併合する\n\n\t\trelative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);\n\t\tcalc_parent[b_info.parent_id] = a_info.parent_id;\n\n\t}else if(height[a_info.parent_id] == height[b_info.parent_id]){ //木の高さが高い方に併合する\n\t\trelative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);\n\t\tcalc_parent[b_info.parent_id] = a_info.parent_id;\n\t\theight[a_info.parent_id]++;\n\t}else{\n\n\t\trelative_weight[a_info.parent_id] = (relative_weight[b]-relative_weight[a])-w;\n\t\tcalc_parent[a_info.parent_id] = b_info.parent_id;\n\t}\n}\n\nbool isSame(int a,int b){\n\tInfo left = find_parent_and_calc_weight(a);\n\tInfo right = find_parent_and_calc_weight(b);\n\n\treturn left.parent_id == right.parent_id;\n}\n\nint main(){\n\n\tint N,Q;\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i <= N; i++){\n\t\theight[i] = 0;\n\t\tcalc_parent[i] = i;\n\t\trelative_weight[i] = 0; //初期値は0にしておく\n\t}\n\n\tint command,A,B,value;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%d\",&command);\n\n\t\tif(command == 0){\n\t\t\tscanf(\"%d %d %d\",&A,&B,&value);\n\t\t\tunite(A,B,value);\n\t\t}else{\n\t\t\tscanf(\"%d %d\",&A,&B);\n\t\t\tif(!isSame(A,B)){ //★ここでそれぞれの経路圧縮&weight計算が行われる★\n\t\t\t\tprintf(\"?\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",relative_weight[B]-relative_weight[A]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    int tmp;\n    if(x != p[x]){\n      tmp = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n      p[x] = tmp;\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 10001;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] > 10000) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\nprivate:\n    vector<map<int, int> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<bool> visit(tree.size(), false);\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(Root(iter->first, target, Sum, visit)){\n                    Sum += iter->second;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool Root(int now, int target, int &Sum, vector<bool> &visit){\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(!visit[iter->first]){\n                    if(Root(iter->first, target, Sum, visit)){\n                        Sum += iter->second;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x][y] = z;\n        tree[y][x] = -z;\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S)){\n            cout << S << endl;\n            tree[x][y] = S;\n            tree[y][x] = -S;\n        }\n        else\n            cout << \"?\" << endl;\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, n, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int n, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y || !(0 <= z && z <= ZMAX))\n                return -1;\n            \n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y)\n                return -1;\n            \n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n\n// 重み付きUnionFind\n// Atcoder People on a Line で Verfty\nstruct WeightUnionFind {\n    static const int Max = 101010;\n    int par[Max];\n    int ws[Max];\n\n    void init(int n) {\n        for (int i = 0; i < n; ++i) {\n            par[i] = -1;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] < 0) {\n            return x;\n        }\n        else {\n            int parent = find(par[x]);\n            ws[x] += ws[par[x]];\n            return par[x] = parent;\n        }\n    }\n\n    int weight(int x) {\n        find(x);\n        return ws[x];\n    }\n\n    void unite(int x, int y, int w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (par[y] < par[x]) {\n            int tmp = x;\n            x = y;\n            y = tmp;\n            w = -w;\n        }\n        par[x] += par[y];\n        par[y] = x;\n        ws[y] = w;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int diff(int x, int y) {\n        if (!same(x, y)) return -1e8;\n        return weight(y) - weight(x);\n    }\n    int size(int x) {\n        return -par[find(x)];\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    WeightUnionFind uf;\n    uf.init(n);\n\n    rep(i, q) {\n        int t, x, y, z;\n        cin >> t >> x >> y;\n        if (t == 0) cin >> z;\n\n        if (t == 0) {\n            uf.unite(x, y, z);\n        }\n        else {\n            if (uf.same(x, y)) {\n                cout << uf.diff(x, y) << endl;\n            }\n            else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\nvector<int> f;//father, f[root]=-sz; \nvector<int> d;//depth or dif, d[x]=x.val-f[x].val;\nint sz[maxn];\nint find(int x){\n    if(f[x]<0)return x;\n    int tmp=find(f[x]);\n    d[x]+=d[f[x]];\n    return f[x]=tmp;\n}\nvoid init(int n=1){f.clear();f.resize(n,-1);d.clear(),d.resize(n,0);}\nint dept(int x){find(x);return d[x];}\nvoid unite(int x,int y,int z=0){//y-x=z\n    z+=dept(x)-dept(y);\n    x=find(x),y=find(y);\n    if(x==y)return;\n    if(f[x]<f[y])swap(x,y),z*=-1;\n    f[x]+=f[y];\n    f[y]=x;\n    d[y]=z;\n}\nint main(){\n    //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,q;\n    cin>>n>>q;\n    init(n);\n    rep(i,1,q){\n        int op,x,y,z;\n        scanf(\"%d\",&op);\n        if(op){\n            scanf(\"%d%d\",&x,&y);\n            if(find(x)!=find(y))cout<<'?'<<endl;\n            else cout<<d[y]-d[x]<<endl;\n        }else{\n            scanf(\"%d%d%d\",&x,&y,&z);\n            unite(x,y,z);\n        }\n    }\n}\n/*\nDSL_1_B\n4 3\n0 1 2 1\n0 2 3 1\n1 1 3\n\n\n5 6\n0 0 2 5\n0 1 2 3\n1 0 1\n1 1 3\n0 1 4 8\n1 0 4\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF = 1LL << 31;\n\nstruct UF{\n  const int N = 1e5+10;\n  vector<int> par;\n  vector<int> depth;\n  vector<int> diff;\n\n  void init(int n){\n    par.resize(n); depth.resize(n); diff.resize(n);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      depth[i] = 0;\n      diff[i] = 0;\n    }\n  }\n\n  //木の根を求める\n  int find(int x){\n    if(par[x] == x){\n      return x;\n    }\n    else {\n      int r = find(par[x]);\n      diff[x] += diff[par[x]];\n      return par[x] = r;\n    }\n  }\n\n  int weight(int x){\n    find(x); //経路圧縮\n    return diff[x];\n  }\n\n  //xとyの属する集合を併合\n  void unite(int x,int y,int w){\n    w += weight(x) - weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]) swap(x,y),w = -w;\n    if(depth[x] == depth[y]) depth[x]++;\n    par[y] = x;\n    diff[y] = w;\n  }\n}uf;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n,q; cin >> n >> q;\n  uf.init(n);\n  vector<int> v;\n  for(int i = 0; i < q; i++){\n    int k,x,y,z; cin >> k;\n    if(k){\n      cin >> x >> y;\n      if(uf.find(x) != uf.find(y)) v.push_back(INF);\n      else v.push_back(uf.weight(y) - uf.weight(x));\n    }\n    else {\n      cin >> x >> y >> z;\n      uf.unite(x,y,z);\n    }\n  }\n\n  for(auto p : v){\n    if(p == INF) cout << '?' << endl;\n    else cout << p << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define DEBUG 0\n\nint getParent(int x, int weight);\nvoid unite(int x, int y, int z);\nint diff(int x, int y);\nbool isSame(int x, int y);\n\nint n, q;\n\nvector<int> numbers;\nvector<int> weights;\nvector<int> num_rank;\n\nint main() {\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnumbers.push_back(i);\n\t\tweights.push_back(0);\n\t\tnum_rank.push_back(0);\n\t}\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\n\t\tcin >> com >> x >> y;\n\n\t\tswitch(com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\tunite(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (isSame(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\n\t\t}\n\n#if DEBUG == 1\n\n\t\tif (com == 0)\n\t\t\tcout << \"unite\" << \" : \";\n\t\telse\n\t\t\tcout << \"     \" << \" : \";\n\t\tcout << x << \" \" << y << \" \" << z << endl;\n\n\t\tfor(int i = 0; i < n; ++i) \n\t\t\tcout << i << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << numbers[i] << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << weights[i] << \" \";\n\n\t\tcout << endl << endl;\n\n#endif\n\t}\n\n\n\treturn 0;\n}\n\n\nint getParent(int x) {\n\n\tif (numbers[x]!= x) {\n\t\tint r = getParent(numbers[x]);\n\n#if DEBUG == 1\n\t\tcout << \"root weights = \" << weights[numbers[x]] << endl;\n#endif\n\t\t\n\t\tweights[x] += weights[numbers[x]];\n\t\tnumbers[x] = r;\n\t}\n\t\n\treturn numbers[x];\n\n}\n\nvoid unite(int x, int y, int w) {\n\n\n\tint x_p = getParent(numbers[x]);\n\tint y_p = getParent(numbers[y]);\n\n\tw += weights[x];\n\tw -= weights[y];\n\n#if DEBUG == 1\n\tcout << x_p << \"(\" << weights[x_p] << \"), \" << y_p << \"(\" << weights[y_p] << \")\" << endl;\n#endif\n\n\tif (num_rank[x_p] < num_rank[y_p]) {\n\t\tswap(x_p, y_p);\n\t\tw *= -1;\n\t}\n\tif (num_rank[x_p] == num_rank[y_p])\n\t\t++num_rank[x_p];\n\n\tnumbers[y_p] = x_p;\n\tweights[y_p] = w;\n\t\n\n}\n\nbool isSame(int x, int y) {\n\n\treturn getParent(x) == getParent(y);\n\n}\n\n\nint diff(int x, int y) {\n\n\tgetParent(x);\n\tgetParent(y);\n\n#if DEBUG == 1\n\tcout << y << \"(\" << weights[y] << \") - \" << x << \"(\" << weights[x] << \")\" << endl;\n#endif\n\t\n\treturn weights[y] - weights[x];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define inf 1000000000\n#define mod 1000000007\nint par[111111],ran[111111],diff_weight[111111];\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i]=i;\n\t\tran[i]=0;\n\t\tdiff_weight[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x)return x;\n\tint r=find(par[x]);\n\tdiff_weight[x]+=diff_weight[par[x]];\n\treturn par[x]=r;\n}\nint weight(int x){\n\tfind(x);\n\treturn diff_weight[x];\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y,int w){\n\tw+=weight(x);\n\tw-=weight(y);\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return;\n\tif(ran[x]<ran[y]){\n\t\tswap(x,y);\n\t\tw*=-1;\n\t}\n\tif(ran[x]==ran[y])ran[x]++;\n\tpar[y]=x;\n\tdiff_weight[y]=w;\n}\nint diff(int x,int y){\n\tif(same(x,y))return weight(y)-weight(x);\n\treturn inf;\n}\nint n,q;\nint x,a,b,c;\nsigned main(){\n\tcin>>n>>q;\n\tinit(n);\n\twhile(q--){\n\t\tcin>>x;\n\t\tif(x==0){\n\t\t\tcin>>a>>b>>c;\n\t\t\tunite(a,b,c);\n\t\t}\n\t\telse{\n\t\t\tcin>>a>>b;\n\t\t\tif(diff(a,b)==inf)puts(\"?\");\n\t\t\telse cout<<diff(a,b)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n       z += diffWeight[x];\n       z -= diffWeight[y];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] < rank[y]){\n         swap(x, y);\n         z = -z;\n      }\n      if(rank[x] == rank[y]) ++rank[x];\n      p[y] = x;\n      diffWeight[y] = z;\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      if(same(x, y)) cout << getWeight(y)-getWeight(x) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass disjoinset {\n\tpublic:\n\t\tvector<int> rank,p,w;\n\tdisjoinset (){}\n\tdisjoinset(int size){\n\trank.resize(size,0);\n\tp.resize(size,0);\n\tw.resize(size,0);\n\tfor(int i=0; i<size;i++)makeSet(i);\n\t}\n\tvoid makeSet(int x){\n\tp[x] = x;\n\trank[x] =0;\n\tw[x] = 0;\n\t}\n\tbool same(int x,int y){\n\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x,int y,int cost){\n\t\tint px = findSet(x);\n\t\tint py = findSet(y);\n\t\tlink(px,py,cost-w[x]+w[y]);\n\t}\n\tvoid link(int x,int y,int cost){\n\t\tif(rank[x] > rank[y]){\n\t\t p[y] = x;\n\t\t w[y] = -cost;\n\t\t}else{\n\t\t p[x] = y;\n\t\t w[x] = cost;\n\t\t if(rank[x]==rank[y] )rank[y]++;\n\t\t}\n\t}\n\n\tint rsum(int x){\n\t\tint sum = 0;\n\t\tint now = x;\n\t\twhile(now!=p[now]){\n\t\t\tsum+=w[now];\n\t\t\tnow=p[now];\n\t\t}\n\t\treturn sum;\n\t}\n\tint findSet(int x){\n\t\tif(x!=p[x]){\n\t\tint tmp = findSet(p[x]);\n\t\tw[x]+=w[p[x]];\n\t\tp[x] = tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n\n};\n \nint main(){\n\tint n,a,b,c,q;\n\tint t;\n\tcin>>n>>q;\n\tdisjoinset ds  = disjoinset(n);\n\tfor(int i=0;i<q;i++){\n\t\tcin>>t;\n\t\tif(t==0){\n\t\tcin>>a>>b>>c;\n\t\t ds.unite(a,b,c);\n\t\t}else if(t==1){\n\t\tcin>>a>>b;\n\t\tif(!ds.same(a,b) ) cout<<'?'<<endl;\n\t\telse {\n\t\t\t//cout<<ds.rsum(a)<<' '<<ds.rsum(b)<<endl;\n\t\t\tcout<<ds.rsum(a)-ds.rsum(b)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\n\ntemplate <typename Value, typename BinaryOp1, typename BinaryOp2>\nclass weighted_union_find_tree\n{\n  int                n;\n  std::vector<int>   prt;\n  std::vector<Value> wt;\n  BinaryOp1          op1;\n  BinaryOp2          op2;\n  Value              id;\n\n  auto op1_eq (Value& x, Value y) const {return x = op1(x, y);}\n  auto op2_eq (Value& x, Value y) const {return x = op2(x, y);}\n  auto inv_eq (Value& x)          const {return x = op2(id, x);}\n  auto inv    (Value& x)          const {return inv_eq(x);}\n\npublic:\n  weighted_union_find_tree\n    (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :\n    n(n), prt(n, -1), wt(n, id), op1(op1), op2(op2), id(id)\n    {}\n\n  bool is_root (int x)        const {return prt.at(x) < 0;}\n  int  size    (int x)              {return -prt.at(find(x));}\n  bool same    (int x, int y)       {return find(x) == find(y);}\n  auto get     (int x)\n  {\n    find(x);\n    return wt.at(x);\n  }\n\n  // x - y\n  auto diff    (int x, int y)\n  {\n    assert(same(x, y));\n    return op2(get(x), get(y));\n  }\n  auto collect     ()         const {return prt;}\n  auto collect_wts ()         const {return wt;}\n\n  // Path compression.\n  int  find    (int x)\n  {\n    if (is_root(x)) return x;\n    else\n    {\n      auto root = find(prt.at(x));\n      op1_eq(wt.at(x), wt.at(prt.at(x)));\n      return prt.at(x) = root;\n    }\n  }\n\n  // Returns `true` if x and y are newly connected.\n  // x is the parent.\n  // x - y = d\n  bool unite   (int x, int y, Value d)\n  {\n    inv_eq(d);\n    op1_eq(d, get(x));\n    op2_eq(d, get(y));\n    if ((x = find(x)) == (y = find(y)))\n    {\n      assert(op2(get(x), get(y)) == d);\n      return false;\n    }\n    if (size(x) < size(y))\n    {\n      std::swap(x, y);\n      inv_eq(d);\n    }\n    prt.at(x) += prt.at(y);\n    prt.at(y) = x;\n    wt.at(y) = d;\n    return true;\n  }\n};\n\ntemplate <typename Value, typename BinaryOp1, typename BinaryOp2>\nauto make_weighted_union_find_tree(int n, BinaryOp1 op1, BinaryOp2 op2, Value id)\n{\n  return weighted_union_find_tree<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);\n}\n\ntemplate <typename T>\nstd::istream& operator>> (std::istream& is, std::vector<T>& v)\n{\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate <typename T>\nstd::ostream& operator<< (std::ostream& os, const std::vector<T>& v)\n{\n  auto n = v.size();\n  os << \"{\";\n  for (size_t i = 0; i < n; i++)\n    os << (i > 0 ? \",\" : \"\") << v[i];\n  return os << \"}\";\n}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, q; std::cin >> n >> q;\n  auto uf = make_weighted_union_find_tree\n  (\n    n,\n    [](auto x, auto y){return x + y;},\n    [](auto x, auto y){return x - y;},\n    0\n  );\n  while (q--)\n  {\n    int c; std::cin >> c;\n    if (c == 0)\n    {\n      int x, y, z;\n      std::cin >> x >> y >> z;\n      uf.unite(y, x, z);\n    }\n    else\n    {\n      int x, y; std::cin >> x >> y;\n      if (uf.same(x, y))\n      {\n        std::cout << uf.diff(y, x) << std::endl;\n      }\n      else\n      {\n        std::cout << \"?\" << std::endl;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <stack>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* constant */\n\nconst int INF = 1 << 30;\nconst int MAX = 1000000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\n\n/* function */\n\nint n,q,com;\nvector<int> parent(MAX);\nvector<int> weight(MAX, 0);\nvector<int> Rank(MAX, 0);\n\nint root(int x){\n    if(x == parent[x]) {\n        return x;\n    }\n    else {\n        int r = root(parent[x]);\n        weight[x] += weight[parent[x]];\n        return parent[x] = r;\n    }\n}\n\nint calc_weight(int v) {\n    root(v);\n    return weight[v];\n}\n\nbool isSame(int x, int y) {\n    return root(x) == root(y);\n}\n\n// weight(y) - weight(x) = z\nbool relate(int x,int y, int z){\n\n    // x, yについてrootと重み差分を補正\n    //cout << \"z : \" << z << '\\n';\n    int w_x = calc_weight(x);\n    int w_y = calc_weight(y);\n    z += calc_weight(x);\n    z -= calc_weight(y);\n    //cout << \"w_x : \" << w_x << '\\n';\n    //cout << \"w_y : \" << w_y << '\\n';\n    //cout << \"z : \" << z << '\\n';\n\n    x = root(x); y = root(y);\n    if (x == y) {\n        return false;\n    }\n    // rank[x] >= rank[y] となるようにx, yをswap\n    if (Rank[x] < Rank[y]) {\n        swap(x, y);\n        z = -z;\n    }\n    // y(root(y)) を x(root(x))の下にくっつける\n    if (Rank[x] == Rank[y]) {\n        Rank[x]++;\n    }\n\n    parent[y] = x;\n    // xがyの親になるので, x yの差分をweight[y]に記録\n    weight[y] = z;\n\n    return true;\n\n}\n\nint diff(int x, int y) {\n    return calc_weight(y) - calc_weight(x);\n}\n\n/* main */\nint main(){\n\n\tscanf(\"%d %d\",&n,&q);\n\n\tfor(int i = 0; i < n; i++){\n        parent[i] = i;\n\t}\n\n    //cout << '\\n';\n\n    int x, y;\n\tfor(int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d\",&com,&x,&y);\n\n\t\tif(com == 1){\n            if (!isSame(x, y)) {\n                cout << '?' << '\\n';\n            }\n            else {\n                cout << diff(x, y) << '\\n';\n            }\n        }\n        else{\n            int z; cin >> z;\n            relate(x, y, z);\n\t\t}\n\n    /*\n        cout << \"weight : \";\n        for (int i = 0; i < n; i++) {\n            int w = weight[i];\n            cout << ' ' << w ;\n        } cout << '\\n';\n        cout << \"parent : \";\n        for (int i = 0; i < n; i++) {\n            int p = parent[i];\n            cout << ' ' << p ;\n        } cout << '\\n';\n        */\n\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nstruct Unionfindw {\n  // tree number\n  vector<int> par;\n  // tree rank\n  vector<int> treerank;\n  // edge weight\n  vector<T> weight;\n  const int inf = 2147483647;\n  // constructor\n  Unionfindw(int n = 1, T initialnum = 0) {\n    stree(n + 1, initialnum);\n  }\n  // make and initialization\n  void stree(int n = 1, T initialnum = 0) {\n    par.assign(n, -1);\n    treerank.assign(n, 0);\n    weight.assign(n, initialnum);\n  }\n  // search root\n  int root(int x) {\n    if(par[x] < 0) return x;\n    int rx = root(par[x]);\n    weight[x] += weight[par[x]];\n    return par[x] = rx;\n  }\n  // is same?\n  bool issame(int x, int y) { return root(x) == root(y); }\n  // calculate weight\n  T calcw(int x) {\n    root(x);\n    return weight[x];\n  }\n  // add\n  // x+w = y\n  // already added, return 0\n  bool uni(int x, int y, T w = 0) {\n    w += calcw(x);\n    w -= calcw(y);\n    x = root(x);\n    y = root(y);\n    if(x == y) return 0;\n    if(treerank[x] > treerank[y]) swap(x, y);\n    if(treerank[x] == treerank[y]) ++treerank[x];\n    par[y] -= size(x);\n    par[x] = y;\n    weight[x] = -w;\n    return 1;\n  }\n\n  int size(int x) { return -par[root(x)]; }\n\n  // calculate difference between x and y (y-x)\n  // if not same tree, return 1\n  T calcdiff(int x, int y) {\n    if(!issame(x, y)) return inf;\n    return calcw(y) - calcw(x);\n  }\n};\n\nlong long n, q;\n\nint main() {\n  cin >> n >> q;\n  Unionfindw<long long> uf(n);\n  for(int i = 0; i < q; ++i) {\n    long long c, x, y, z;\n    cin >> c >> x >> y;\n    if(c) {\n      z = uf.calcdiff(x, y);\n      if(z == uf.inf)\n        cout << \"?\" << endl;\n      else\n        cout << z << endl;\n    }\n    else {\n      cin >> z;\n      uf.uni(x, y, z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#include <time.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\n//const long long MOD = 998244353;\n \nusing namespace std;\n\nclass UF\n{\nprivate:\n    int         num;\n    vector<int> par;\n    vector<int> siz;\n    vector<ll>  wt;   // diff from par\npublic:\n    vector<ll> parval;   // val of root\npublic:\n    UF(int n): num(n) {\n        par.resize(n);\n        siz.resize(n);\n        wt.resize(n);\n        parval.resize(n);\n        int i;\n        for(i=0; i<n; i++) {\n            par[i]=i; siz[i]=1;\n            wt[i]=0;\n            parval[i]=0;\n        }\n    }\n\t\n    int find(int x) {\n        int p=par[x];\n        if(x==p) {\n            return x;\n        }\n        int q=find(p);\n        ll diff=wt[q]-wt[p];\n        wt[x]-=diff;\n        return par[x]=q;\n    }\n\n    bool unite(int x, int y, ll diff) {     // val[y]=val[x]+diff\n        int px=find(x);\n        int py=find(y);\n        ll diff0=wt[y]-wt[x];\n        diff-=diff0;\n\n        x=find(x);\n        y=find(y);\n        if(x==y) {\n            return (wt[y]==wt[x]+diff);\n        }\n        if(siz[x]<siz[y]) {\n            par[x]=y;\n            siz[y]=siz[x]+siz[y];\n            //val[y]=val[x]+val[y];\n            wt[x]=-diff;\n        }\n        else {\n            par[y]=x;\n            siz[x]=siz[x]+siz[y];\n            //val[x]=val[x]+val[y];\n            wt[y]=diff;\n        }\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x)==find(y);\n    }\n\n    int size(int x) {\n        return siz[find(x)];\n    }\n\n    ll GetWt(int x) {\n        int p=find(x);\n        return wt[x];\n    }\n\n    int ngroup() {\n    //int ngroup( int& ans ) {\n        int count=0;\n        int i;\n        for(i=0; i<num; i++) {\n            if(par[i]==i) {\n                count++;\n                //ans += (val[i]? siz[i]: siz[i]-1);\n            }\n        }\n        return count;\n    }\n\n    void print() {\n        int i;\n        printf(\"par: \"); for(i=0; i<num; i++) printf(\"%d \", par[i]); printf(\"\\n\");\n        printf(\"wt:  \"); for(i=0; i<num; i++) printf(\"%lld \", GetWt(i)); printf(\"\\n\");\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    int n,Q;\n    scanf(\"%d%d\", &n, &Q);\n    UF uf(n);\n    int i;\n#ifdef _DEBUG\n    uf.print();\n#endif\n    for(i=0; i<Q; i++) {\n        int flag;\n        scanf(\"%d\", &flag); \n        if(flag==0) {\n            int x,y,z;\n            scanf(\"%d%d%d\", &x, &y, &z); \n            bool ok=uf.unite(x,y,z);\n            // if(ok) printf(\"unite OK\\n\");\n            // else   printf(\"unite NG\\n\");\n        }\n        else {\n            int x,y;\n            scanf(\"%d%d\", &x, &y);\n            if(uf.same(x,y)) {\n                printf(\"%lld\\n\", uf.GetWt(y)-uf.GetWt(x));\n            }\n            else printf(\"?\\n\");\n        }\n#ifdef _DEBUG\n        uf.print();\n#endif\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdlib>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      z -= diffWeight[x];\n      z += diffWeight[y];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      //cout << \"y=\"<< y << \", x=\" << x << endl;\n      //cout << \"weighty=\"<<diffWeight[y] << \", weightx=\" << diffWeight[x] << endl;\n      //if(same(x, y)) cout << (getWeight(y)-getWeight(x)) << endl;\n      if(same(x, y)) cout << abs(diffWeight[y]-diffWeight[x]) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  for(int i=0 ;  i<n ; ++i){\n    //cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint Par[100001];\nll diff_weight[100001];\n\n\nvoid init(int n)\n{\n\tfor(int i = 0;i<n;i++)\n\t{\n\t\tPar[i] = i;\n\t}\n}\n\nint find(int x)\n{\n\tif(Par[x]==x)return x;\n\tint f = find(Par[x]);\n\tdiff_weight[x] += diff_weight[Par[x]];//親全部足す\n\treturn Par[x] = f;\n}\n\nint weight(int x)\n{\n\tfind(x);\n\treturn diff_weight[x];\n}\n\nint diff(int x,int y)\n{\n\tif(find(x)!=find(y))return INT_MIN;\n\treturn weight(y)-weight(x);\n}\n\nvoid unite(int x,int y,int w)//yはxよりw大きくする。\n{\n\tw += weight(x); w-=weight(y);\n\tx = find(x); y = find(y);\n\tif(x==y)return;\n\tPar[y]=x;\n\tdiff_weight[y] = w;\n}\n\n\n\nint main()\n{\n\tint n,q;\n\tcin >> n >> q;\n\t//cin >> n >> q;\n\tinit(n+1);\n\twhile(q--)\n\t{\n\t\tint op;\n\t\tcin >> op;\n\t\tif(op)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tif(diff(x,y)!=INT_MIN)cout<<diff(x,y)<<'\\n';\n\t\t\telse cout<<'?'<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x,y,w;\n\t\t\tcin >> x >> y >> w;\n\t\t\tunite(x,y,w);\n\t\t}\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nstruct QuickFind {\n    vector<int> i2g;\n    vector< vector<int> > g2i;\n    vector<long long int> weight;\n    int N;\n\n    QuickFind(int N_) {\n        N = N_;\n        i2g.resize(N); g2i.resize(N);\n        weight.resize(N);\n\n        for(int i=0; i<N; i++) {\n            i2g[i] = i;\n            g2i[i] = vector<int>{i};\n        }\n    }\n\n    bool same(int u, int v) {\n        return i2g[u] == i2g[v];\n    }\n\n    long long int query(int u, int v) {\n        assert(same(u, v));\n        return weight[v] - weight[u];\n    }\n\n    void merge(int u, int v, int w) {\n        if(same(u, v)) return;\n        int ru = i2g[u], rv = i2g[v];\n\n        if(g2i[rv].size() > g2i[ru].size()) {\n            swap(ru, rv); swap(u, v);\n            w = -w;\n        }\n\n        long long int prev = weight[v];\n        weight[v] = weight[u] + w;\n\n        for(auto e : g2i[rv]) {\n            i2g[e] = ru;\n            g2i[ru].push_back(e);\n            if(e == v) continue;\n            int diff = weight[e] - prev;\n            weight[e] = weight[v] + diff;\n        }\n\n        g2i[rv].clear();\n    }\n};\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    QuickFind qf(N);\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int u, v, w; cin >> u >> v >> w;\n            qf.merge(u, v, w);\n        }\n        else {\n            int u, v; cin >> u >> v;\n            if(qf.same(u, v)) cout << qf.query(u, v) << endl;\n            else cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nstruct WeightedUnionFind {\n    vector<int> par, rank;\n    vector<T> weight;\n\n    WeightedUnionFind(int n) {\n        par.resize(n);\n        for (int i = 0; i < n; i++) par[i] = i;\n        rank.resize(n);\n        weight.resize(n);\n    }\n\n    int find(int x) {\n        if (par[x] == x) return x;\n        int r = find(par[x]);\n        weight[x] += weight[par[x]];\n        return par[x] = r;\n    }\n\n    bool unite(int x, int y, T w) {\n        int rx = find(x), ry = find(y);\n        w += weight[x] - weight[y];\n        x = rx, y = ry;\n        if (x == y) return false;\n\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        weight[y] = w;\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    T diff(int x, int y) {\n        find(x), find(y);\n        return weight[y] - weight[x];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind<int> wuf(n);\n    for (int i = 0; i < q; i++) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            wuf.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (wuf.same(x, y)) cout << wuf.diff(x, y) << '\\n';\n            else cout << \"?\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct edge {\n  int dest;\n  int weight; // = dest minus curr\n};\n\nclass UF {\npublic:\n  vector<edge> v;\n  UF(int n) { v = vector<edge>(n, {-1, 0}); }\n\n  void uf_union(int x, int y, int y_minus_x) {\n    auto x_res = uf_find(x);\n    auto y_res = uf_find(y);\n    int loc_x = x_res.dest;\n    int loc_y = y_res.dest;\n    if (loc_x == loc_y)\n      return;\n    if (v[loc_x].dest <\n        v[loc_y].dest) { // x's set has more elements -- join y to x\n      v[loc_x].dest += v[loc_y].dest;\n      v[loc_y] = {loc_x, x_res.weight - y_res.weight - y_minus_x};\n    } else {\n      v[loc_y].dest += v[loc_x].dest;\n      v[loc_x] = {loc_y, y_res.weight - x_res.weight + y_minus_x};\n    }\n  }\n  void uf_union(int x, int y) { uf_union(x, y, 0); }\n\n  edge uf_find(int x) {\n    if (v[x].dest < 0)\n      return {x, 0};\n    edge tmp = uf_find(v[x].dest);\n    tmp.weight += v[x].weight;\n    v[x] = tmp;\n    return v[x];\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  UF uf(n);\n  int c, x, y;\n  while (cin >> c >> x >> y) {\n    if (c == 0) {\n      int z;\n      cin >> z;\n      uf.uf_union(x, y, z);\n    }\n    if (c == 1) {\n      edge x_res = uf.uf_find(x);\n      edge y_res = uf.uf_find(y);\n      if (x_res.dest != y_res.dest) {\n        cout << \"?\" << endl;\n      } else {\n        cout << x_res.weight - y_res.weight << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n    vector<int> parent;\n    vector<ll> dist;\n    UnionFind(int x = 1){\n        parent.clear(); parent.resize(x,-1);\n        dist.clear(); dist.resize(x,0);\n    }\n    int find(int x){\n        if(parent[x]<0)return x;\n        int r = find(parent[x]);\n        dist[x]+=dist[ parent[x] ];\n        return parent[x]=r;    \n    }\n    ll depth(int x) { find(x); return dist[x]; }\n\n    bool same(int x,int y) { return (find(x) == find(y)); }\n\n    int size(int x) { return -parent[find(x)]; }\n\n    void unite(int x,int y,ll k=0){\n        k+=depth(y);\n        k-=depth(x);\n        k*=-1;\n        x=find(x);\n        y=find(y);\n        if(x==y)return;\n        if(size(x)<size(y)) { swap(x,y); k *= -1;}\n        parent[x]+=parent[y];\n        parent[y]=x;\n        dist[y]=k;\n    }\n};\n\n\nint main(){\n    int n,q; cin >> n >> q;\n    UnionFind T(n);\n    for(int i=0;i<q;i++){\n        int type,x,y;\n        scanf(\"%d %d %d\",&type,&x,&y);\n        if(type==0){\n            int a;\n            scanf(\"%d\",&a);\n            T.unite(x,y,a);\n        }\n        else{\n            if(!T.same(x,y)) printf(\"?\\n\");\n            else printf(\"%lld\\n\",T.depth(x)-T.depth(y));\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n, Abel SUM_UNITY) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n, Abel SUM_UNITY) {\n        par.resize(n+1); rank.resize(n+1); diff_weight.resize(n+1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    UnionFind<int> uf(n,(long long)0);\n    int i;\n    int w,x,y,z;\n    for(i=0; i<q; i++){\n        cin >> w;\n        if(w==0){\n            cin >> x >> y >> z;\n            uf.merge(x,y,z);\n        }else{\n            cin >> x >> y;\n            if(uf.issame(x,y)){\n                cout << uf.diff(x,y) << endl;\n            }else{\n                cout << '?' << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass DisjointSet {\n\npublic:\n\tint size;\n\tvector<int> p, w, r;\n\t\n\tDisjointSet(){}\n\tDisjointSet(int n){\n\t\tsize = n;\n\t\tp.resize(size, 0);\n\t\tr.resize(size, 0);\n\t\tw.resize(size, 0);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tmakeSet(i);\n\t\t}\n\t}\n\n\tvoid makeSet(int x){\n\t\tp[x]=x;\n\t\tr[x]=0;\n\t\tw[x]=0;\t\n\t}\n\t\n\tvoid relate(int x, int y, int z){\n\t\tint xp = findSet(x);\n\t\tint yp = findSet(y);\n\t\tlink(xp, yp, z-w[x]+w[y]);\n\t}\n\n\tvoid link(int x, int y, int cost){\n\t\tif(r[x]>r[y]){\n\t\t\tp[y]=x;\n\t\t\tw[y]-=cost;\n\t\t} else {\n\t\t\tp[x]=y;\n\t\t\tw[x]+=cost;\n\t\t\tif(r[x]==r[y]){\n\t\t\t\tr[y]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn findSet(x)==findSet(y);\n\t}\n\t\n\tint sum(int x){\n\t\tint sum=0;\n\t\tint cur=x;\n\t\twhile(cur!=p[cur]){\n\t\t\tsum+=w[cur];\n\t\t\tcur=p[cur];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tint findSet(int x){\n\t\tif(p[x]!=x){\n\t\t\tint tmp=findSet(p[x]);\n\t\t\tw[x]+=w[p[x]];\n\t\t\tp[x]=tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tDisjointSet ds(n);\n\tfor (int i=0;i<q;i++) {\n\t\tint c, x, y, z;\n\t\tcin >> c >> x >> y;\n\t\tif (c == 0) {\n\t\t\tcin >> z;\n\t\t\tds.relate(x, y, z);\n\t\t} else {\n\t\t\tif (!ds.same(x, y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t} else {\n\t\t\t\tint sumX = ds.sum(x);\n\t\t\t\tint sumY = ds.sum(y);\n\t\t\t\tcout << sumX - sumY << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e5+10;\nint p[N],dst[N];\n\nvoid init(int n)\n{\n    for(int i=0;i<=n;i++) p[i]=i,dst[i]=0;\n}\n\nint fnd(int x)\n{\n    if(p[x]!=x)\n    {\n        int tmp=fnd(p[x]);\n        dst[x]+=dst[p[x]];\n        return p[x]=tmp;\n    }else\n    {\n        dst[x]=0;\n        return x;\n    }\n}\n\nbool same(int x,int y)\n{\n    return fnd(x)==fnd(y);\n}\n\nbool unite(int x,int y,int z)\n{\n    if(same(x,y)) return false;\n\n    int px=fnd(x),py=fnd(y);\n\n    p[px]=py;\n    dst[px]=dst[y]-z-dst[x];\n\n    return true;\n}\n\nint dif(int x,int y)\n{\n    fnd(x),fnd(y);\n\n    return dst[y]-dst[x];\n}\n\nint main()\n{\n    int n,q;\n    cin>>n>>q;\n\n    init(n);\n\n    while(q--)\n    {\n        int op,x,y;\n        cin>>op>>x>>y;\n\n        if(!op)\n        {\n            int z;\n            cin>>z;\n\n            unite(x,y,z);\n        }else\n        {\n            if(same(x,y))\n                cout<<dif(x,y)<<endl;\n            else\n                cout<<\"?\"<<endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <stdio.h>\n#include <vector>\n#define int long long\n#define endre getchar();getchar();return 0\n#define moder 1000000007\n#define inf 1000000000000000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#define P pair<int,int>\n#define all(v) v.begin(),v.end()\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define vecunique(vec) sort(vec.begin(), vec.end());decltype(vec)::iterator result = std::unique(vec.begin(), vec.end());vec.erase(result, vec.end())\nusing namespace std;\n\nclass weight_unionfind {\n\tint par[100005], Rank[100005], diff_weight[100005];\npublic:\n\tweight_unionfind(int x) {\n\t\trep(i, x) {\n\t\t\tpar[i] = i;\n\t\t\tRank[i] = 0;\n\t\t\tdiff_weight[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\tint r = find(par[x]);\n\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\treturn par[x] = r;\n\t}\n\tint weight(int x) {\n\t\tfind(x);\n\t\treturn diff_weight[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y, int w) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return;\n\t\tif (Rank[x] < Rank[y])swap(x, y), w *= -1;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t}\n\tint diff(int x, int y) {\n\t\tif (same(x, y))return weight(y) - weight(x);\n\t\treturn inf;\n\t}\n};\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tstatic weight_unionfind uf(n);\n\trep(i, q) {\n\t\tint a, b, c, d;\n\t\tcin >> a;\n\t\tif (!a) {\n\t\t\tcin >> b >> c >> d;\n\t\t\tuf.unite(b, c, d);\n\t\t}\n\t\telse {\n\t\t\tcin >> b >> c;\n\t\t\tif (uf.diff(b, c) != inf)cout << uf.diff(b, c) << endl;\n\t\t\telse cout << \"?\" << endl;\n\t\t}\n\t}\n\tendre;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n\n#define YES puts(\"YES\")\n#define Yes puts(\"Yes\")\n#define NO  puts(\"NO\")\n#define No  puts(\"No\")\n#define ALL(v) (v).begin(), (v).end()\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n \nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n \n \n#if 1\n//-------------\n// DUMPマクロ\n// https://www.creativ.xyz/dump-cpp-652/\n\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// vector\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    for (T& x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, map<T, U>& map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T>& set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n \n#define DUMPOUT cerr\n \nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&& ... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// http://beet-aizu.hatenablog.com/entry/2018/04/08/145516\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n#endif\n\n\n#define mod 1000000007\ntypedef pair<int, int> P;\n#define INF (1LL<<60)\n\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nvoid solve(){\n    int N, Q;\n    cin >> N >> Q;\n    UnionFind<int> uf(N);\n    \n    while(Q--){\n        int k;\n        cin >> k;\n        if(k==0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.merge(x,y,z);\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(uf.issame(x,y))\n                cout << uf.diff(x,y) << endl;\n            else\n                cout << \"?\" << endl;\n        }\n    }\n    \n}\n\nsigned main(){\n    cout << fixed << setprecision(18);\n    cerr << fixed << setprecision(18);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\ntypedef uint64_t u64;\ntypedef int64_t s64;\ntypedef uint32_t u32;\ntypedef int32_t s32;\ntypedef vector<s32> vs32;\ntypedef vector<u32> vu32;\ntypedef vector<s64> vs64;\ntypedef vector<u64> vu64;\n\nconst double PI=3.14159265358979323846;\n\n#define MAX(x, y) ((x) < (y) ? (y) : (x))\n#define MIN(x, y) ((x) > (y) ? (y) : (x))\n\n#define rep(i, N) for(int i = 0; i < N; ++i)\n\n#define CEIL(x, y) (((x) + (y) - 1) / (y))\n#define MOD 1000000007ULL\n\nclass DisjointSet\n{\npublic:\n    DisjointSet() {}\n    DisjointSet(int n)\n    : p(vs32(n, -1)), w(vs32(n, 0))\n    {}\n    ~DisjointSet() {}\n\n    bool same(int x, int y)\n    {\n        x = parent(x);\n        y = parent(y);\n        return x == y;\n    }\n\n    int diff(int x, int y)\n    {\n        parent(x); parent(y);\n        return w[y] - w[x];\n    }\n\n    void unite(int x, int y, int d)\n    {\n        int rx = parent(x);\n        int ry = parent(y);\n\n        if (rx == ry) return;\n\n        if (p[rx] > p[ry])\n        {\n            swap(rx, ry);\n            swap(x, y);\n            d = -d;\n        }\n        p[rx] += p[ry];\n        p[ry] = rx;\n        w[ry] = w[x] + d - w[y];\n    }\n\n    int parent(int x)\n    {\n        int ret;\n        if (p[x] < 0)\n        {\n            ret = x;\n        }\n        else\n        {\n            ret = parent(p[x]);\n            w[x] += w[p[x]];\n            p[x] = ret;\n        }\n        return ret;\n    }\n\n    vs32 p;\n    vs32 w;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    DisjointSet ds(n);\n    char com;\n    int x, y, d;\n    rep (i, q)\n    {\n        cin >> com;\n        if (com == '0')\n        {\n            cin >> x >> y >> d;\n            ds.unite(x, y, d);\n        }\n        else if (com == '1')\n        {\n            cin >> x >> y;\n            if (!ds.same(x, y))\n            {\n                cout << \"?\\n\";\n            }\n            else\n            {\n                cout << ds.diff(x, y) << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\tif (flag[x] == -1 && flag[y] == -1) {\n\t\t\t\tset<int>st;\n\n\t\t\t\tst.insert(x);\n\t\t\t\tst.insert(y);\n\t\t\t\tnum.push_back(st);\n\t\t\t\tflag[x] = num.size() - 1;\n\t\t\t\tflag[y] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\telse if (flag[x] != -1 && flag[y] != -1) {\n\t\t\t\tif (flag[x] == flag[y]) {\n\t\t\t\t\t/*\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\telse if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\t//  num.erase(num.begin() + yy);\n\t\t\t\t\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}\n\t\t\t\telse if (flag[x] > flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[y]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[y];\n\t\t\t\t\t}\n\n\t\t\t\t\t//  num.erase(num.begin() + xx);\n\t\t\t\t\tnum[xx].erase(num[xx].begin(), num[xx].end());\n\n\t\t\t\t}\n\t\t\n\t\t\t}\n\t\t\telse if (flag[x] != -1) {\n\t\t\t\tnum[flag[x]].insert(y);\n\t\t\t\tflag[y] = flag[x];\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\telse if (flag[y] != -1) {\n\t\t\t\tnum[flag[y]].insert(x);\n\t\t\t\tflag[x] = flag[y];\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RFOR(i,a,b) for(int i=(int)b-1;i>=(int)a;--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n#define debug(x) cerr << #x << \":\" << x << endl;\n#define OK(ok) cout << (ok ? \"Yes\" : \"No\") << endl;\ntypedef long long ll;\n\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail) {\n  cin >> head; CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\nconst int INF = 1e9 + 1;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 1;\n\ntemplate< class Abel > struct UnionFind {\n  vector< int > par;\n  vector< int > rank;\n  vector< Abel > diff_weight;\n  \n  UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(int n = 1, Abel SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n), diff_weight.resize(n);\n    for(int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = SUM_UNITY;\n    }\n  }\n  \n  int root(int x) {\n    if (par[x] == x) return x;\n    // 累積和をとる\n    int r = root(par[x]);\n    diff_weight[x] += diff_weight[par[x]];\n    return par[x] = r;\n  }\n\n  Abel weight(int x) {\n    // 経路圧縮をする\n    root(x);\n    return diff_weight[x];\n  }\n\n  Abel diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n\n  bool issame(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  // weight(x) - weight(y) = wとなるようにmerge\n  bool merge(int x, int y, Abel w) {\n    // xとyそれぞれについてrootとの重み付き補正\n    w += weight(x); w -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w = -w;\n    }\n    if (rank[x] == rank[y]) {\n      ++rank[x];\n    }\n    par[y] = x;\n\n    // xがyの和になるので、xとyの差分をdiff_weight[y]に記録\n    diff_weight[y] = w;\n    return true;\n  }\n\n  // templateですよ！！！\n  \n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  CIN(N, Q);\n  UnionFind< int > uf(N + 1);\n\n  REP(qi, Q) {\n    CIN(c);\n    if (c == 0) {\n      CIN(x, y, w);\n      // merge\n      uf.merge(x, y, w);\n    } else {\n      // judge\n      CIN(x, y);\n      if (!uf.issame(x, y)) {\n\tcout << \"?\" << endl;\n      } else {\n\tcout << uf.diff(x, y) << endl;\n      }\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n// https://qiita.com/drken/items/cce6fc5c579051e64fab\nstruct WeightedUnionFind{\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff;\n\n    WeightedUnionFind(int n){\n        init(n);\n    }\n\n    void init(int n){\n        par.resize(n); rank.resize(n, 0); diff.resize(n, 0);\n        for(int i = 0; i < n; i++)  par[i] = i;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int r = root(par[x]);\n            diff[x] += diff[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    // 単ノードの重み取得\n    int weight(int x){\n        root(x);\n        return diff[x];\n    }\n\n    int dif(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n    bool isSame(int x, int y){\n        return root(x) == root(y);\n    }\n\n    // weight(y) - weight(x) = w となるように merge\n    bool merge(int x, int y, int w){\n        // x が y の親になることを考えると、更新の起点はdiff[y]で、\n        // diff[y] を w + weight(x) - weight(y) にすればよい\n        w += weight(x); w -= weight(y);\n\n        x = root(x); y = root(y);\n        if(x == y)  return false;\n        if(rank[x] < rank[y])   swap(x, y), w = -w;\n        if(rank[x] == rank[y])  rank[x]++;\n        par[y] = x;\n        diff[y] = w;\n        return true;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind uf(n);\n    while(q-- > 0){\n        int a, b, c, d;\n        cin >> a >> b >> c;\n        if(a == 0){\n            cin >> d;\n            uf.merge(b, c, d);\n        }else{\n            if(uf.isSame(b, c)) cout << uf.dif(b, c) << endl;\n            else                cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define rep(i, a) for (int (i) = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int (i) = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int (i) = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int (i) = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n#define lcout(a) cout << a;\n#define lcoutln(a) cout << a << endl;\n#define lcerr(a) cerr << a;\n#define lcerrln(a) cerr << a << endl;\n#else\n#define lcout(a) \n#define lcoutln(a) \n#define lcerr(a) \n#define lcerrln(a) \n#endif\n\nstruct uni_find_weight\n{\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<int> diff_weight;\n\tint sz;\n\tuni_find_weight(int n) {init(n);}\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tdiff_weight.resize(n);\n\t\trep(i, n) par[i] = i, rank[i] = 0, diff_weight[i] = 0;\n\t\tsz = n;\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\tint r = root(par[x]);\n\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\treturn par[x] = r;\n\t}\n\tint weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\tint diff(int x, int y) {return weight(y) - weight(x);}\n\tbool same(int x, int y) {return root(x) == root(y);}\n\tbool unite(int x, int y, int w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) swap(x, y), w = -w;\n\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\tint size() {return sz;}\n};\n\nint main()\n{\n\tint n, q;\n\tcin >> n >> q;\n\tuni_find_weight uf(n);\n\trep(i, q) {\n\t\tCIN(int, t);\n\t\tCIN(int, a);\n\t\tCIN(int, b);\n\t\tif (t == 0) {\n\t\t\tCIN(int, w);\n\t\t\tuf.unite(a, b, w);\n\t\t}\n\t\tif (t == 1) {\n\t\t\tif (!uf.same(a, b)) cout << '?' << endl;\n\t\t\telse {\n\t\t\t\tcout << uf.diff(a, b) << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nstruct WeightedUnionFind_{\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<T> diff_weight;\n  WeightedUnionFind_(int n, T def=0): n(n){\n    par.resize(n);\n    rank.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = def;\n    }\n  }\n  int find(int x){\n    if(par[x] == x)return x;\n    int r = find(par[x]);\n    diff_weight[x] += diff_weight[par[x]];\n    return par[x] = r;\n  }\n  T weight(int x){\n    find(x);\n    return diff_weight[x];\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y, T w){\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if(x == y)return false;\n    if(rank[x] < rank[y])swap(x, y), w = - w;\n    if(rank[x] == rank[y])rank[x]++;\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n  T diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(q);\n  WeightedUnionFind_<ll> wuf(n);\n  rep(i, q){\n    INT(c); INT(x); INT(y);\n    if(c == 1){\n      if(!wuf.same(x, y))cout << \"?\" << endl;\n      else cout << wuf.diff(x, y) << endl;\n    }else{\n      LL(w);\n      wuf.unite(x, y, w);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n\ntemplate <class T>\nclass WeightedUnionFind {\npublic:\n    std::vector<int> par, num;\n    std::vector<T> dist;  // A[par[v]] - A[v] = dist[v]\n\n    explicit WeightedUnionFind(int N)\n        : par(N), num(N, 1), dist(N, 0) {\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        if (par[v] == v) {\n            return v;\n        } else {\n            int p = find(par[v]);\n            dist[v] += dist[par[v]];\n            return par[v] = p;\n        }\n    }\n\n    // A[u] - A[v] = d\n    void unite(int u, int v, T d) {\n        find(u), find(v);\n        d += dist[u];\n        d -= dist[v];\n        u = par[u], v = par[v];\n        if (u == v) return;\n\n        if (num[u] < num[v]) {\n            std::swap(u, v);\n            d = -d;\n        }\n\n        num[u] += num[v];\n        par[v] = u;\n        dist[v] = d;\n    }\n\n    // A[v] - A[u]\n    T diff(int u, int v) {\n        find(u), find(v);\n        return dist[u] - dist[v];\n    }\n\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool ispar(int v) { return v == find(v); }\n    int size(int v) { return num[find(v)]; }\n};\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    int N, Q;\n    std::cin >> N >> Q;\n    WeightedUnionFind<long long> wuf(N);\n    for (int q = 0; q < Q; ++q) {\n        int t, u, v;\n        std::cin >> t >> u >> v;\n        if (t == 0) {\n            long long d;\n            std::cin >> d;\n            wuf.unite(v, u, d);\n        } else {\n            if (!wuf.same(u, v)) {\n                std::cout << \"?\\n\";\n            } else {\n                std::cout << wuf.diff(u, v) << '\\n';\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint S3[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t\tS3[i] = 1;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tint s3 = S2[V2] - V3 -S2[V1];\n\tint s1 = S1[V1];\n\tint s2 = S1[V2];\n\tif(S3[s1] == 1){\n\t\tS3[s1]--;\n\t\tS3[s2]++;\n\t\tS1[V1] = s2;\n\t\tS2[V1] = S2[V1] + s3;\n\t\t//printf(\"Fast1\\n\");\n\t\treturn;\n\t}else{ \n\t\tif(S3[s2] == 1){\n\t\t\tS3[s1]++;\n\t\t\tS3[s2]--;\n\t\t\tS1[V2] = s1;\n\t\t\tS2[V2] = S2[V2]-s3;\n\t\t\t//printf(\"Fast2\\n\");\n\t\t\treturn;\n\t\t}\n\t\n\t}\n\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == s1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS3[s1]--;\n\t\t\tS3[s2]++;\n\t\t\tS1[i] = s2;\n\t\t\tS2[i] = S2[i] + s3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass DisjointSet {\n\npublic:\n\tvector<int> p, w, r;\n\t\n\tDisjointSet(){}\n\tDisjointSet(int size){\n\t\tp.resize(size);\n\t\tr.resize(size);\n\t\tw.resize(size);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tmakeSet(i);\n\t\t}\n\t}\n\t\n\tvoid makeSet(int x){\n\t\tp[x]=x;\n\t\tr[x]=0;\n\t\tw[x]=0;\t\n\t}\n\t\n\tvoid relate(int x, int y, int z){\n\t\tlink(\n\t\t\tfindSet(x),\n\t\t\tfindSet(y),\n\t\t\tz-w[x]+w[y]);\n\t}\n\t\t\n\tvoid link(int x, int y, int cost){\n\t\tif(r[x]>r[y]){\n\t\t\tp[y]=x;\n\t\t\tw[y]-=cost;\n\t\t} else {\n\t\t\tp[x]=y;\n\t\t\tw[x]+=cost;\n\t\t\tif(r[x]==r[y]){\n\t\t\t\tr[y]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn findSet(x)==findSet(y);\n\t}\n\t\n\tint sum(int x){\n\t\tint sum=0;\n\t\tint cur=x;\n\t\twhile(cur!=p[cur]){\n\t\t\tsum+=w[cur];\n\t\t\tcur=p[cur];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tint findSet(int x){\n\t\tif(p[x]!=x){\n\t\t\tint tmp=findSet(p[x]);\n\t\t\tw[x]+=w[p[x]];\n\t\t\tp[x]=tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tDisjointSet ds(n);\n\tfor (int i=0;i<q;i++) {\n\t\tint c, x, y, z;\n\t\tcin >> c >> x >> y;\n\t\tif (c == 0) {\n\t\t\tcin >> z;\n\t\t\tds.relate(x, y, z);\n\t\t} else {\n\t\t\tif (!ds.same(x, y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t} else {\n\t\t\t\tint sumX = ds.sum(x);\n\t\t\t\tint sumY = ds.sum(y);\n\t\t\t\tcout << sumX - sumY << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tusing pid = pair<int, T>;\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id].first = a;\n\t\t\tdata[id].second += d;\n\t\t\tall[a].push_back(id);\n\t\t}\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\nint *pp[MAX];\n\nvoid makeSet(int x){\n\tp[x] = x;\n\tpp[x] = &p[x];\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\tpp[x] = &p[y];\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\tpp[x] = &p[y];\n\t\tlink(y,a,b-z);\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t}\n}\n\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint returnQ(int x){\n\tif(p[x] != *pp[x]){\n\t\treturn r[x] + returnQ(p[x]);\n\t}\n\telse return r[x];\n}\n\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\n/*\nint same(int x,int y){\n\tif(*pp[x] == *pp[y]){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n*/\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tlink(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tcout << returnQ(b) - returnQ(c) << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n49\n50\n51\n52\n53\n#include<iostream>\n#include<vector>\nusing namespace std;\n \nvector<int> p,rank,cost;\n \nvoid makeSet(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n \nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n \nvoid relate(int x, int y, int z) {\n    int rootx = findSet(x), rooty = findSet(y);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n \nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstddef>\n#include <tuple>\n#include <utility>\n#include <vector>\n\ntemplate <class Abelian> class PotentializedUnionFind {\n\npublic:\n  using value_type = Abelian;\n  using size_type = std::size_t;\n  using container_type =\n      std::vector<std::tuple<size_type, value_type, size_type>>;\n\nprotected:\n  container_type c;\n\nprivate:\n  size_type &par(const size_type i) { return std::get<0>(c[i]); }\n  size_type par(const size_type i) const { return std::get<0>(c[i]); }\n  value_type &val(const size_type i) { return std::get<1>(c[i]); }\n  const value_type &val(const size_type i) const { return std::get<1>(c[i]); }\n  size_type &siz(const size_type i) { return std::get<2>(c[i]); }\n  size_type siz(const size_type i) const { return std::get<2>(c[i]); }\n  value_type potential(size_type x) {\n    value_type ret = {};\n    while (x != par(x)) {\n      val(x) = val(x) + val(par(x));\n      ret = ret + val(x);\n      x = par(x) = par(par(x));\n    }\n    return std::move(ret);\n  }\n\npublic:\n  PotentializedUnionFind() : c() {}\n  explicit PotentializedUnionFind(const size_type size)\n      : c(size, std::forward_as_tuple(static_cast<size_type>(0), value_type(),\n                                      static_cast<size_type>(1))) {\n    for (size_type i = 0; i < size; ++i)\n      par(i) = i;\n  }\n\n  size_type size() const { return c.size(); }\n  bool empty() const { return c.empty(); }\n\n  size_type find(size_type x) {\n    assert(x < size());\n    while (x != par(x)) {\n      val(x) = val(x) + val(par(x));\n      x = par(x) = par(par(x));\n    }\n    return x;\n  }\n  value_type diff(const size_type x, const size_type y) {\n    assert(x < size());\n    assert(y < size());\n    assert(same(x, y));\n    return potential(y) + (-potential(x));\n  }\n  bool same(const size_type x, const size_type y) {\n    assert(x < size());\n    assert(y < size());\n    return find(x) == find(y);\n  }\n  size_type size(const size_type x) {\n    assert(x < size());\n    return siz(find(x));\n  }\n\n  bool unite(size_type x, size_type y, value_type d) {\n    assert(x < size());\n    assert(y < size());\n    d = d + potential(x) + (-potential(y));\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return false;\n    if (siz(x) < siz(y))\n      std::swap(x, y), d = -d;\n    siz(x) += siz(y);\n    par(y) = x;\n    val(y) = std::move(d);\n    return true;\n  }\n};\n\n#include<iostream>\n \nint main() {\n    int n, q;\n    std::cin >> n >> q;\n    PotentializedUnionFind<int> T(n);\n    while (q--) {\n        int t, x, y, z;\n        std::cin >> t >> x >> y;\n        if (t) {\n            if (T.same(x, y))\n                std::cout << T.diff(x, y) << std::endl;\n            else\n                std::cout << \"?\" << std::endl;\n        }\n        else {\n            std::cin >> z;\n            T.unite(x, y, z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\nint p[100000], d[100000];\n\nint find(int x) {\n\tif (p[x] == x)\n\t\treturn x;\n\telse {\n\t\tint xp = p[x];\n\t\tp[x] = find(xp);\n\t\td[x] += d[xp];\n\t\treturn p[x];\n\t}\n}\n\nvoid relate(int x, int y, int z) {\n\tint xp = find(x), yp = find(y);\n\n\tif (xp != yp) {\n\t\tp[yp] = xp;\n\t\td[yp] = d[x] + z - d[y];\n\t}\n}\n\nint main()\n{\n\tcin >> n >> q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tp[i] = i;\n\t\td[i] = 0;\n\t}\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint c, x, y, z;\n\n\t\tcin >> c;\n\n\t\tif (c == 0) {\n\t\t\tcin >> x >> y >> z;\n\t\t\trelate(x, y, z);\n\t\t}\n\t\telse {\n\t\t\tcin >> x >> y;\n\t\t\tif (find(x) == find(y))\n\t\t\t\tcout << d[y] - d[x] << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\n//int rr[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tbool f = false;\n\t\tint i;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(p[i] == y && i != y){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"ここ1\" << endl;\n\t\tif(f){\n\t\t\tif(r[i] <= z){\n\t\t\t\tp[x] = i;\n\t\t\t\tp[i] = y;\n\t\t\t\tr[x] = z-r[i];\n\t\t\t\tr[i] = z;\n\t\t\t\t//rr[i] = rr[x]+1;\n\t\t\t\t//rr[y] = rr[i]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i] = x;\n\t\t\t\tr[i] = r[i]-z;\n\t\t\t\tp[x] = y;\n\t\t\t\tr[x] = z;\n\t\t\t\t//rr[y] = rr[x]+1;\n\t\t\t\t//rr[i] = rr[y]+1;\n\t\t\t}\n\t\t\t//cout << \"ここ2\" << endl;\n\t\t}\n\t\telse{\n\t\t\tp[x] = y;\n\t\t\tr[x] = z;\t//r[]でdiffの判定の役割をなす\n\t\t\t//rr[y] = rr[x] + 1;\n\t\t}\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\t//rr[y] = rr[x]+1;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint findRank(int x, int y){\n\tint a = findSet(x);\n\tint b = x;\n\twhile(a != b){\n\t\tif(p[b] == y){\n\t\t\treturn 1;\n\t\t}\n\t\tb = p[b];\n\t\t//cout << \"繰り返し\" <<endl;\n\t}\n\treturn -1;\n}\n\nint returnQuery(int x,int y){\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n}\n//diffの合計を求める式\n\nvoid uni(int x,int y, int z){\n\tlink(x, y, z);\n}\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tuni(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\t//cout << \"ここ\" << endl;\n\t\t\t\tif(findRank(b,c) == 1){\n\t\t\t\t\tcout << returnQuery(b,c) << endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << -1*returnQuery(c,b) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nclass UnionFind{\nprivate:\n    vector<int> data;\n    vector<int> diff_weight;\npublic:\n    UnionFind(int size) : data(size,-1), diff_weight(size, 0){}\n    int root(int x){\n        if(data[x] < 0){\n            return x;\n        }else{\n            diff_weight[x] += diff_weight[data[x]];\n            return data[x] = root(data[x]);\n        }\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    bool connect(int x,int y, int w){\n\n        w += weight(x);w -= weight(y);\n        x = root(x);y = root(y);\n        if(x != y){\n            if(data[x] > data[y])swap(x,y), w = -w;\n            data[x] += data[y];data[y] = x;\n            diff_weight[y] = w;\n        }\n        return x != y;\n    }\n    bool check(int x,int y){\n        return root(x) == root(y);\n    }\n    int Size(int x){\n        return -data[x];\n    }\n    int diff(int a, int b){\n        return weight(b) - weight(a);\n    }\n};\n\nint main(){\n   int N,q;cin >> N >> q;\n   UnionFind Uni(N);\n   for(int a = 0;a < q;a++){\n       int x;cin >> x;\n       if(x == 0){\n           int d,e,f;cin >> d >> e >> f;\n           Uni.connect(d,e,f);\n       }else{\n           int d,e;cin >> d >> e;\n           if(Uni.check(d,e))cout<<Uni.diff(d,e)<<endl;\n           else cout<<\"?\"<<endl;\n       }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nclass WeightedUnionFind{\npublic:\n  int V;\n  vector<int> par, rnk, diff, sz;\n  WeightedUnionFind():V(-1){}\n  WeightedUnionFind(int V):V(V),par(V),rnk(V,0),diff(V,0),sz(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x] == x) return x;\n    int p = find(par[x]);\n    diff[x] = diff[x] + diff[ par[x] ];\n    return par[x] = p;\n  }\n\n  //頂点xは頂点yよりもz大きい\n  void relate(int x,int y,int z){\n    int sx = x, sy = y;\n    x = find(x), y = find(y);\n    if(x == y) assert(getDiff(sx,sy) == z);\n    if(x == y)return;\n    \n    if(rnk[x] < rnk[y]) {\n      par[x] = y;\n      sz[y] += sz[x];\n      diff[x] = z + (-diff[sx] + diff[sy]);\n    }\n    else{\n      par[y] = x;\n      sz[x] += sz[y];\n      diff[y] = -z + (diff[sx] - diff[sy]);\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n  \n  int getDiff(int u,int v){\n    assert(same(u,v));\n    return diff[u] - diff[v];\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  int size(int x){return sz[find(x)];}\n  \n};\n\nsigned main(){\n  int n;\n  cin>>n;\n  WeightedUnionFind wuf(n);\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, x, y, z;\n    cin>>cmd >> y >> x;\n    if(cmd == 0){\n      cin>>z;\n      wuf.relate(x,y,z);\n    }\n    if(cmd == 1){\n      if(!wuf.same(x, y)) cout<<\"?\"<<endl;\n      else cout<<wuf.getDiff(x, y)<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <map>\n#include <queue>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing namespace std;\n\ntemplate<class T>\nconstexpr T INF = ::numeric_limits<T>::max() / 2 - 170;\n\ntemplate <class T>\nclass WeightedUnionFind {\n    vector<int> uni;\n    vector<T> weights;\n    int n;\npublic:\n    explicit WeightedUnionFind(int n, T SUM_UNITY = 0) :\n    uni(static_cast<u32>(n), -1) , n(n), weights(n,  SUM_UNITY){};\n\n    int root(int a) {\n        if (uni[a] < 0) return a;\n        else {\n            int r = root(uni[a]);\n            weights[a] += weights[uni[a]];\n            return (uni[a] = r);\n        }\n    }\n\n    bool unite(int a, int b, T w) {\n        w += weight(a); w -= weight(b);\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b), w = -w;\n        uni[a] += uni[b];\n        uni[b] = a;\n        weights[b] = w;\n        return true;\n    }\n\n    int size(int a){\n        return -uni[root(a)];\n    }\n\n    T weight(T a){\n        root(a);\n        return weights[a];\n    }\n    int diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n};\n\n\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind<ll> u(n);\n    for (int i = 0; i < q; ++i) {\n        int a, x, y;\n        ll w;\n        scanf(\"%d\", &a);\n        if(a) {\n            scanf(\"%d%d\", &x, &y);\n            if(u.root(x) != u.root(y)){\n                printf(\"?\\n\");\n            }else {\n                printf(\"%d\\n\", u.diff(x, y));\n            }\n        }\n        else {\n            scanf(\"%d%d%lld\", &x, &y, &w);\n            u.unite(x, y, w);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstddef>\n#include <utility>\n#include <vector>\n\n\ntemplate <class Abelian> class PotentializedUnionFind {\n\npublic:\n\tusing value_type = Abelian;\n\tusing difference_type = std::ptrdiff_t;\n\tusing container_type = std::vector<std::pair<difference_type, value_type>>;\n\tusing size_type = typename container_type::size_type;\n\nprotected:\n\tcontainer_type c;\n\nprivate:\n\tvalue_type potential(size_type x) {\n\t\tvalue_type ret = {};\n\t\twhile (c[x].first >= static_cast<difference_type>(0)) {\n\t\t\tif (c[static_cast<size_type>(c[x].first)].first >=\n\t\t\t\tstatic_cast<difference_type>(0)) {\n\t\t\t\tc[x].second =\n\t\t\t\t\tc[static_cast<size_type>(c[x].first)].second + c[x].second;\n\t\t\t\tc[x].first = c[static_cast<size_type>(c[x].first)].first;\n\t\t\t}\n\t\t\tret = ret + c[x].second;\n\t\t\tx = static_cast<size_type>(c[x].first);\n\t\t}\n\t\treturn std::move(ret);\n\t}\n\npublic:\n\tPotentializedUnionFind() : c() {}\n\texplicit PotentializedUnionFind(const size_type size)\n\t\t: c(size, std::make_pair(-1, value_type())) {}\n\n\tsize_type size() const { return c.size(); }\n\tbool empty() const { return c.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (c[x].first >= static_cast<difference_type>(0)) {\n\t\t\tif (c[static_cast<size_type>(c[x].first)].first >=\n\t\t\t\tstatic_cast<difference_type>(0)) {\n\t\t\t\tc[x].second =\n\t\t\t\t\tc[static_cast<size_type>(c[x].first)].second + c[x].second;\n\t\t\t\tc[x].first = c[static_cast<size_type>(c[x].first)].first;\n\t\t\t}\n\t\t\tx = static_cast<size_type>(c[x].first);\n\t\t}\n\t\treturn x;\n\t}\n\tvalue_type diff(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn potential(y) + (-potential(x));\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn static_cast<size_type>(-c[find(x)].first);\n\t}\n\n\tbool unite(size_type x, size_type y, value_type d) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\td = d + diff(y, x);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (c[x].first > c[y].first)\n\t\t\tstd::swap(x, y), d = -d;\n\t\tc[x].first += c[y].first;\n\t\tc[y] = std::make_pair(static_cast<difference_type &&>(x), std::move(d));\n\t\treturn true;\n\t}\n};\n\n#include<iostream>\n\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tPotentializedUnionFind<int> T(n);\n\twhile (q--) {\n\t\tint t, x, y, z;\n\t\tstd::cin >> t >> x >> y;\n\t\tif (t) {\n\t\t\tif (T.same(x, y))\n\t\t\t\tstd::cout << T.diff(x, y) << std::endl;\n\t\t\telse\n\t\t\t\tstd::cout << \"?\" << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cin >> z;\n\t\t\tT.unite(x, y, z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct UnionFind_ {\n  vector<int> p;\n  vector<int> r;\n  vector<int> diff_weight;\n\n  UnionFind_(int n = 1){\n    init(n);\n  }\n\n  void init(int n = 1){\n    p.resize(n);\n    r.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; ++i){\n      p[i] = i;\n      r[i] = 0;\n      diff_weight[i] = 0;\n    }\n  }\n\n  int findSet(int x){\n    if(x != p[x]){\n      p[x] = findSet(p[x]);\n      diff_weight[x] += diff_weight[p[x]];\n    }\n    return p[x];\n  }\n\n  bool issame(int x, int y){\n    return findSet(x) == findSet(y);\n  }\n\n  int weight(int x){\n    findSet(x);\n    return diff_weight[x];\n  }\n\n  int diff(int x, int y){\n    if(!issame(x, y)) return 10001;\n    return weight(y) - weight(x);\n  }\n\n  bool merge(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n\n    x = findSet(x);\n    y = findSet(y);\n    if(x == y) return false;\n\n    if(r[x] < r[y]){\n      swap(x, y);\n      w = -w;\n    }\n\n    if(r[x] == r[y]) ++r[x];\n    p[y] = x;\n\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n} UnionFind;\n\n\nint main(){\n  int n, q;\n  int com, x, y, z;\n  int count = 0, judge[100000];\n\n  cin >> n >> q;\n  UnionFind uf(n);\n\n\n  for(int i = 0; i < q; ++i){\n    cin >> com;\n    if(com == 0){\n    cin >> x >> y >> z;\n    uf.merge(x, y, z);\n    }\n\n    else{\n      cin >> x >> y;\n      judge[count++] = uf.diff(x, y);\n    }\n  }\n\n  for(int i = 0; i < count; ++i){\n    if(judge[i] > 10000) cout << \"?\" << endl;\n    else cout << judge[i] << endl;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for (ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\nbool chmin(ll& a, ll b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nbool chmax(ll& a, ll b) {\n    if (b > a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N = 500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\ntemplate <class Abel>\nstruct UnionFind {\n    vector<ll> par;\n    vector<ll> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(ll n = 1, Abel SUM_UNITY = 0) { init(n, SUM_UNITY); }\n\n    void init(ll n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n);\n        rank.resize(n);\n        diff_weight.resize(n);\n        for (ll i = 0; i < n; ++i)\n            par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    ll root(ll x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            ll r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(ll x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool same(ll x, ll y) { return root(x) == root(y); }\n\n    bool merge(ll x, ll y, Abel w) {\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(ll x, ll y) { return weight(y) - weight(x); }\n};\nint main() {\n    cin >> n;\n    cin >> q;\n    UnionFind<ll> U(n,0);\n\n    while (q--) {\n        cin >> x;\n        if (x == 0) {\n            cin >> a >> b >> c;\n            U.merge(a, b, c);\n        }\n        else{\n          cin>>a>>b;\n          if(!U.same(a,b))cout<<\"?\"<<endl;\n          else cout << U.diff(a, b) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<stdio.h>\n#include<fstream>\n#include<stdlib.h>\n#include<math.h> \n#include<queue>\n#include<string.h>\n#include<stack>\n\n\nusing namespace std;\n\n#define INF 1000000000\n#define BL 1\n#define WH 0\n#define GL 2\n\nint par[100001];\nint r[100001];\nint weight[100001];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tweight[i]=0;\n\t\tr[i]=0;\n\t}\n}\n\n\nint root(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}\n\telse {\n\t\tint temp=root(par[x]);\n\t\tweight[x]+=weight[par[x]];\n\t\treturn par[x]=temp;\n\t}\n}\n\nbool same(int x,int y){\n\treturn root(x)==root(y);\n}\n\n\nvoid unite(int x,int y,int w){\n\tpar[x]=root(x);\n\tpar[y]=root(y);\n\tint a=w-(weight[y]-weight[x]);\n\n\t//if(x==y)return;\n\n\tif(r[par[x]]>r[par[y]]){\n\t\tweight[par[y]]=a;\n\t\tpar[par[y]]=par[x];\n\t}\n\telse{\n\t\tweight[par[x]]=-a;\n\t\tpar[par[x]]=par[y];\n\t\tif(r[par[x]]==r[par[y]])r[par[y]]++;\n\t}\n\t/*\n\tx=root(x);\n\ty=root(y);\n\tint a=w-(weight[y]-weight[x]);\n\tif(r[x]>r[y]){\n\t\tweight[y]=a;\n\t\tpar[y]=x;\n\t}\n\telse{\n\t\tweight[x]=-a;\n\t\tpar[x]=y;\n\t\tif(r[x]==r[y])r[y]++;\n\t}\n\t*/\n}\n\nint diff(int x,int y){\n\treturn weight[y]-weight[x];\n}\n\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tint qu;\n\tint x,y,z;\n\tinit(n);\n\tfor(int i=0;i<q;i++){\n\t\tcin>>qu;\n\t\tif(qu==0){\n\t\t\tcin>>x>>y>>z;\n\t\t\tunite(x,y,z);\n\t\t}\n\t\telse if(qu==1){\n\t\t\tcin>>x>>y;\n\t\t\tif(same(x,y)){\n\t\t\t\tcout<<diff(x,y)<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <map>\nusing namespace std;\n\nmap<int, int> w[100000];\nint kakunin[100000];\n\nint diff(int x, int y, int c){\n    if(x==y)return 0;\n    int ret = INT_MAX;\n    int tmp;\n    map<int,int>::iterator itr;\n    for(itr=w[x].begin();itr!=w[x].end();itr++){\n        if(kakunin[itr->first]==c)continue;\n        kakunin[itr->first]=c;\n        tmp = diff(itr->first,y,c);\n        if(tmp<INT_MAX)ret = itr->second + tmp;\n    }\n    return ret;\n}\n\nint main(){\n    int i,n,q,x,y,z,com;\n    int c=0;\n    memset(kakunin,0,sizeof(int)*100000);\n    scanf(\"%d %d\",&n,&q);\n    for(i=0;i<q;i++){\n        scanf(\"%d\",&com);\n        if(com){\n            scanf(\"%d %d\",&x,&y);\n            c++;\n            int ans = diff(x,y,c);\n            if(ans==INT_MAX)printf(\"?\\n\");\n            else printf(\"%d\\n\",ans);\n        }else{\n            scanf(\"%d %d %d\",&x,&y,&z);\n            w[x][y] = z;\n            w[y][x] = -z;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX\n\nusing namespace std;\n\nvector<int> p, r, weight;\n\nvoid makeSet(int x){\n  p[x] = x;\t\t\t\n  r[x] = 0;\n  weight[x] = 0;\n}\n\nint findSet(int x){\n  if(x != p[x]){\n    p[x] = findSet(p[x]);\n    weight[x] += weight[p[x]];\n  }\n\n  return p[x];\n}\n \n\nvoid relate(int x, int y, int z){\n  int rootx = findSet(x), rooty = findSet(y);\n\n  if(r[rooty] < r[rootx]){\n    p[rooty] = rootx;\n    weight[rooty] = z - weight[y] + weight[x];\n  }\n  else{\n    p[rootx] = rooty;\n    weight[rootx] = -z - weight[x] + weight[y];\n    if(r[rootx] == r[rooty]) r[rooty] += 1;\n  }\n\n}\n\n\nint main(){\n\n  int N, Q, com, x, y, z, i;\n\n  cin >> N >> Q;\n\n  p.resize(N);\n  r.resize(N);\n  weight.resize(N);\n\n  for(i=0; i<N; i++) makeSet(i);\n\n  for(i=0; i<Q; i++){\n    cin >> com >> x >> y;\n    if(com == 0){\n      cin >> z;\n      relate(x, y, z);\n    }\n    else if(com == 1){\n      if(findSet(x) == findSet(y)) cout << weight[y] - weight[x] << endl;\n      else cout << '?' << endl;\n    }\n \n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MX = 100005;\nint rnk[MX];\nint w_diff[MX];\nint root[MX];\n\nint find(int x){\n  if (x == root[x]) return x;\n  int r = find(root[x]);\n  w_diff[x] += w_diff[root[x]];\n  return root[x] = r;\n}\n\nint weight(int x){\n    find(x);\n    return w_diff[x];\n}\n\nint diff(int x, int y){\n    return weight(y) - weight(x);\n}\n\nvoid merge(int x, int y, int w){\n    \n    w += weight(x);\n    w -= weight(y);\n\n    x = find(x);\n    y = find(y);\n    \n    if (x == y) return;\n    \n    if(rnk[x] < rnk[y]) swap(x, y),  w = -w;\n    if(rnk[x] == rnk[y]) ++rnk[x];\n    root[y] = x;\n    w_diff[y] = w;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    int n, q;\n    cin >> n >> q;\n    \n    for(int i=0; i<n; i++) {\n        rnk[i]=0;\n        w_diff[i]=0;\n        root[i]=i;\n    }\n \n    for(int i=0; i<q; i++){\n        int c, x, y, z;\n        cin >> c;\n        if(c == 0){\n            cin >> x >> y >> z;\n            merge(x, y, z);\n        }else if (c == 1){\n            cin >> x >> y;\n            if (find(x) != find(y)){\n                cout << \"?\" << endl;\n            }else{\n                cout << diff(x, y) << endl;   \n            }\n        }\n    }\n    cout << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tbool f = false;\n\t\tint i;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(p[i] == y && i != y){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"ここ1\" << endl;\n\t\tif(f){\n\t\t\tif(r[i] <= z){\n\t\t\t\tp[x] = i;\n\t\t\t\tp[i] = y;\n\t\t\t\tr[x] = z-r[i];\n\t\t\t\tr[i] = z;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i] = x;\n\t\t\t\tr[i] = r[i]-z;\n\t\t\t\tp[x] = y;\n\t\t\t\tr[x] = z;\n\t\t\t}\n\t\t\t//cout << \"ここ2\" << endl;\n\t\t}\n\t\telse{\n\t\t\tp[x] = y;\n\t\t\tr[x] = z;\t//r[]でdiffの判定の役割をなす\n\t\t}\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint returnQuery(int x,int y){\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n}\n//diffの合計を求める式\n\nvoid uni(int x,int y, int z){\n\tlink(x, y, z);\n}\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tuni(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//cout << \"ここ\" << endl;\n\t\t\t\tcout << returnQuery(b,c) << endl;\n\t\t\t}\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <vector>\ntemplate <typename T>\nclass Option {\n\tOption() {};\n\tvirtual void make_vtbl() {};\npublic:\n\tstruct Some :Option<T> {\n\t\tT value;\n\t\tSome(const T &val) :value{ val } {}\n\t};\n\tstruct NilClass :Option<T> {\n\t\tNilClass() {}\n\t};\n\tstatic Option<int>::NilClass Nil() {\n\t\tstatic Option<int>::NilClass nil = NilClass();\n\t\treturn nil;\n\t}\n};\nclass Weighted_union_find_tree {\n\tstruct Pair {\n\t\tWeighted_union_find_tree *ptr;\n\t\tint differ;\n\t};\n\tWeighted_union_find_tree *_parent{ nullptr };\n\tint _diff{ 0 };\n\tPair parent() {\n\t\tif (_parent == nullptr)\n\t\t\treturn Pair{ this, 0 };\n\t\telse\n\t\t{\n\t\t\tauto prev = _parent->parent();\n\t\t\t_parent = prev.ptr;\n\t\t\t_diff += prev.differ;\n\t\t\treturn Pair{ _parent, _diff };\n\t\t}\n\t}\npublic:\n\tvoid set_relate(Weighted_union_find_tree &greater, int weight) {\n\t\tif (is_related(greater)) return;\n\t\tauto other_pos = greater.parent();\n\t\tother_pos.ptr->_parent = this;\n\t\tother_pos.ptr->_diff = weight - other_pos.differ;\n\t}\n\tbool is_related(Weighted_union_find_tree &other) {\n\t\treturn parent().ptr == other.parent().ptr;\n\t}\n\tstd::shared_ptr<Option<int>> diff(Weighted_union_find_tree &other) {\n\t\tif (!is_related(other)) return std::make_shared<Option<int>::NilClass>(Option<int>::Nil());\n\t\tauto pos = parent();\n\t\tauto other_pos = other.parent();\n\t\treturn std::make_shared<Option<int>::Some>(Option<int>::Some(other_pos.differ - pos.differ));\n\t}\n};\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tstd::vector<Weighted_union_find_tree> uft(n);\n\tint query, x, y, z;\n\tfor (auto i = 0; i < q; ++i) {\n\t\tstd::cin >> query;\n\t\tswitch (query) {\n\t\tcase 0: std::cin >> x >> y >> z;\n\t\t\tuft[x].set_relate(uft[y], z); break;\n\t\tdefault: std::cin >> x >> y;\n\t\t\tauto opt = std::dynamic_pointer_cast<Option<int>::Some>(uft[x].diff(uft[y]));\n\t\t\tif (opt == nullptr) {\n\t\t\t\tstd::cout << '?' << std::endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << opt->value << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n#define LL              long long\n#define SL(n)           scanf(\"%lld\",&n)\n#define LF              double\n#define SF(n)           scanf(\"%lf\",&n)\n\n#define pb              push_back\n#define ff              first\n#define ss              second\n#define mp              make_pair\n\n#define ON(n,i)         (n|(1<<i))\n#define OFF(n,i)        (n&(~(1<<i)))\n#define CHK(n,i)        (n&(1<<i))\n\n#define SET(arr)        memset( arr , -1 , sizeof arr)\n#define RESET(arr)      memset( arr,0,sizeof arr)\n\n#define srt(v)          sort(v.begin(),v.end())\n#define uniq(v)\t\t\tv.resize(distance(v.begin(),unique(v.begin(),v.end())))\n#define found( s,d )    (s.find(d) != s.end())\n\n#define FOR(i,s,e)      for( LL i = s ; i<=e ; i++ )\n\n#define FILEIN          freopen(\"in.txt\",\"r\",stdin)\n#define FILEOUT         freopen(\"out.txt\",\"w\",stdout)\n\nusing namespace std;\n\n#define lim 100100\n\nstruct dsuNode{\n    LL parent , Distance;\n}Info[lim];\n\nLL ParentOf( LL u ){\n    if( Info[u].parent == u ) return u;\n    LL p = ParentOf( Info[u].parent );\n    Info[u].Distance += Info[ Info[u].parent ].Distance;\n    return Info[u].parent = p;\n}\n\nbool Union( LL u, LL v, LL w ){\n\n    ParentOf(u); ParentOf(v);\n    w = w - Info[u].Distance + Info[v].Distance;\n    u = ParentOf(u);\n    v = ParentOf(v);\n    if( u == v ) return true;\n    Info[u].parent = ParentOf(v);\n    Info[u].Distance = w;\n    return false;\n\n}\n\nint main(){\n    //FILEIN;\n    LL n,m;\n    SL(n); SL(m);\n    FOR(i,1,n){\n        Info[i].parent = i;\n        Info[i].Distance = 0;\n    }\n    while(m--){\n        LL t;\n        SL(t);\n        if(t==0){\n            LL x,y,z;\n            SL(x); SL(y); SL(z);\n            x++,y++;\n            Union(x,y,z);\n        }\n        else{\n            LL x,y;\n            SL(x); SL(y);\n            x++,y++;\n            //cout<<\"DEBUG: \"<<ParentOf(x)<<' '<<ParentOf(y)<<endl;\n            if( ParentOf(x)!=ParentOf(y) ) printf(\"?\\n\");\n            else{\n                ParentOf(x); ParentOf(y);\n                printf(\"%lld\\n\", ( Info[x].Distance - Info[y].Distance ));\n            }\n        }\n    }\n\nreturn 0;}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n#define PB push_back\n#define MP make_pair\n#define all(x) x.begin(),x.end()\n\n//重み付きUnion-Find木(ランク無し)\nstruct UnionFind{\nprivate:\n\tvector<int> parent;\n\tvector<long long> difference;\npublic:\n\tvoid init(int N){ //初期化する O(N)\n\t\tparent.clear();\n\t\tdifference.clear();\n\t\tfor(int i=0; i<N; i++){\n\t\t\tparent.push_back(i);\n\t\t\tdifference.push_back(0);\n\t\t}\n\t}\n\tint root(int a){ //親を返す O(log N)\n\t\tif(parent[a] == a) return a;\n\t\tint r = root(parent[a]);\n\t\tdifference[a] += difference[parent[a]];\n\t\treturn parent[a] = r;\n\t}\n\tvoid unite(int a, int b, long long x){ //木を併合する x=a-b O(log N)\n\t\tint rootA = root(a);\n\t\tint rootB = root(b);\n\t\tif(rootA != rootB){\n\t\t\tx += weight(b);\n\t\t\tx -= weight(a);\n\t\t\tparent[rootA] = rootB;\n\t\t\tdifference[rootA] = x;\n\t\t}\n\t}\n\tbool same(int a, int b){ //属する木が同じかを返す O(log N)\n\t\treturn root(a) == root(b);\n\t}\n\tlong long weight(int a){\n\t\troot(a); //経路圧縮\n\t\treturn difference[a];\n\t}\n\tlong long diff(int a, int b){ //重みの差を返す O(log N)\n\t\treturn weight(a) - weight(b);\n\t}\n};\n\nint main(){\n\t\n\tint N,Q;\n\tcin >> N >> Q;\n\tUnionFind uf;\n\tuf.init(N);\n\tfor(int i=0; i<Q; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tif(c == 0){\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tuf.unite(x,y,z);\n\t\t}\n\t\telse{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tif(uf.same(x,y)) cout << uf.diff(x,y) << endl;\n\t\t\telse cout << \"?\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntemplate <typename Abel=ll> class WeightedUnionFind {\n    public:\n    std::vector<ll> parent;\n    std::vector<ll> sizes;\n    std::vector<Abel> diff_weight;\n    Abel Abel_unit = 0;                 //可換群の単位元 1\n    Abel Abel_plus(Abel a, Abel b){      //可換群の加法 ab\n        return a+b;\n    }\n    Abel Abel_minus(Abel a, Abel b){    //ab^-1\n        return a-b;\n    }\n\n    WeightedUnionFind(ll N) : parent(N), sizes(N, 1), diff_weight(N) {\n        for(ll i=0; i<N; i++){\n            parent[i] = i;\n            diff_weight[i] = Abel_unit;\n        }\n    }\n    ll find(ll x){\n        if(x==parent[x]) return x;\n        ll r = find(parent[x]);\n        diff_weight[x] = Abel_plus(diff_weight[x], diff_weight[parent[x]]);\n        return parent[x]=r;\n    }\n    bool unite(ll x, ll y, Abel w){\n        w = Abel_plus(w, weight(x));\n        w = Abel_minus(w, weight(y));\n        ll x_class = find(x);\n        ll y_class = find(y);\n        if(x_class == y_class) return false;\n        if(sizes[x_class] < sizes[y_class]){\n            std::swap(x_class, y_class);\n            w = Abel_minus(Abel_unit, w);\n        }\n        parent[y_class] = x_class;\n        sizes[x_class] += sizes[y_class];\n        sizes[y_class] = 0;\n        diff_weight[y_class] = w;\n        return true;\n    }\n    bool same(ll x, ll y){\n        return find(x)==find(y);\n    }\n    ll size(ll x){\n        return sizes[find(x)];\n    }\n    Abel weight(ll x){\n        find(x);  // 経路圧縮\n        return diff_weight[x];\n    }\n    Abel diff(ll x, ll y){\n        return Abel_minus(weight(y), weight(x));\n    }\n};\n\n\nint main(){\n    WeightedUnionFind<ll> uf(100005);\n    int n,q, com, x, y, z;\n\n    cin >> n >> q;\n    REP(i,q){\n        cin >> com;\n        if(com==0){\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        }\n        else{\n            cin >> x >> y;\n            if(uf.find(x)==uf.find(y)){\n                cout << uf.diff(x,y) << endl;\n            }\n            else{\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate <typename T>\nstruct WeightedUnionFind{\n  T d;\n  vector<int> r,p;\n  vector<T> ws;\n\n  WeightedUnionFind(){}\n  WeightedUnionFind(int n,T d):\n    d(d),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n\n  int find(int x){\n    if(x==p[x]) return x;\n    int t=find(p[x]);\n    ws[x]+=ws[p[x]];\n    return p[x]=t;\n  }\n\n  T weight(int x){\n    find(x);\n    return ws[x];\n  }\n\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n\n  void unite(int x,int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n\n  T diff(int x,int y){\n    return weight(y)-weight(x);\n  }\n};\n//END CUT HERE\n\nsigned DSL_1_B(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<int> wuf(n,0);\n\n  for(int i=0;i<q;i++){\n    int t,x,y,z;\n    cin>>t>>x>>y;\n    if(t){\n      if(wuf.same(x,y)) cout<<wuf.diff(x,y)<<\"\\n\";\n      else cout<<\"?\\n\";\n    }else{\n      cin>>z;\n      wuf.unite(x,y,z);\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2019/09/08\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B&lang=jp\n*/\n\nsigned main(){\n  DSL_1_B();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <climits>\nusing namespace std;\n\nclass node{\n    int c;\n    int h;\n    node* p;\npublic:\n    node(){c=0;h=0;p=NULL;}\n    void incC(){c++;}\n    void setHP(int height, node* parent){\n        h = height;\n        p = parent;\n    }\n    int getC(){return c;}\n    pair<int,node*> getHP(){\n        if(this->p==NULL)return make_pair(0, this);\n        else{\n            pair<int,node*> tmp = p->getHP();\n            tmp.first += h;\n            return tmp;\n        }\n    }\n};\n\nnode ob[100000];\n\nint diff(int x, int y){\n    pair<int,node*> tmp1 = ob[x].getHP();\n    pair<int,node*> tmp2 = ob[y].getHP();\n    if(tmp1.second != tmp2.second)return INT_MAX;\n    else return tmp2.first - tmp1.first;\n}\n\nvoid relate(int x, int y, int z){\n    pair<int,node*> tmp1 = ob[x].getHP();\n    pair<int,node*> tmp2 = ob[y].getHP();\n    if(tmp1.second == tmp2.second)return;\n    if(tmp1.second->getC() < tmp2.second->getC()){\n        tmp1.second->setHP(tmp2.first - tmp1.first - z, tmp2.second);\n    }else{\n        tmp2.second->setHP(tmp1.first - tmp2.first + z, tmp1.second);\n        if(tmp1.second->getC() == tmp2.second->getC()){\n            tmp1.second->incC();\n        }\n    }\n}\n\nint main(){\n    int i,n,q,com,x,y,z,tmp;\n    scanf(\"%d %d\",&n,&q);\n    for(i=0;i<q;i++){\n        scanf(\"%d\",&com);\n        if(com){\n            scanf(\"%d %d\",&x,&y);\n            int tmp = diff(x,y);\n            if(tmp==INT_MAX)printf(\"?\\n\");\n            else printf(\"%d\\n\",diff(x,y));\n        }else{\n            scanf(\"%d %d %d\",&x,&y,&z);\n            relate(x,y,z);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nstruct weighted_union_find {\n\tlong long N;\t\t\t\t\t// the number of nodes\n\tlong long M;\t\t\t\t\t// the number of trees\n\tstd::vector<long long> parent;\t// parent[i] := the direct parent of i\n\tstd::vector<long long> size;\t// size[i] := the number of nodes in the tree containing i\n\tstd::vector<long long> weight;\t// weight[i] := the weight of the edge from i to parent[i]\n\n\tweighted_union_find(long long n) : N(n), M(n) {\n\t\tparent.resize(n, -1);\n\t\tsize.resize(n, 1);\n\t\tweight.resize(n, 0);\n\t}\n\n\tlong long weight_sum_to_root(long long i) {\n\t\tif (parent[i] == -1) return 0;\n\t\telse return weight[i] + weight_sum_to_root(parent[i]);\n\t}\n\n\tlong long root(long long i) {\n\t\tif (parent[i] == -1) return i;\n\t\tlong long x = root(parent[i]);\n\t\tweight[i] += weight[parent[i]];\n\t\treturn parent[i] = x;\n\t}\n\n\tbool is_united(long long i, long long j) {\n\t\treturn (root(i) == root(j));\n\t}\n\n\tlong long dist(long long i, long long j) {\n\t\tif (!is_united(i, j)) return LLONG_MAX;\n\t\telse return weight_sum_to_root(j) - weight_sum_to_root(i);\n\t}\n\n\t// false : detected confliction\n\tbool unite(long long i, long long j, long long w) {\n\t\tw += weight_sum_to_root(i) - weight_sum_to_root(j);\n\t\ti = root(i); j = root(j);\n\t\tif (i == j) return (w == 0);\n\t\tif (size[i] < size[j]) {\n\t\t\tstd::swap(i, j);\n\t\t\tw *= -1;\n\t\t}\n\t\tparent[j] = i;\n\t\tsize[i] += size[j];\n\t\tweight[j] = w;\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tlong long n, q;\n\tstd::cin >> n >> q;\n\tweighted_union_find uf(n);\n\twhile (q--) {\n\t\tlong long w, x, y;\n\t\tstd::cin >> w >> x >> y;\n\t\tif (w == 0) {\n\t\t\tlong long z;\n\t\t\tstd::cin >> z;\n\t\t\tuf.unite(x, y, z);\n\t\t} else {\n\t\t\tlong long d = uf.dist(x, y);\n\t\t\tif (d == LLONG_MAX) std::cout << \"?\\n\";\n\t\t\telse std::cout << d << '\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define DEBUG 0\n\nint getParent(int x, int weight);\nvoid unite(int x, int y, int z);\nint diff(int x, int y);\nbool isSame(int x, int y);\n\nint n, q;\n\nvector<int> numbers;\nvector<int> weights;\nvector<int> num_rank;\n\nint main() {\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnumbers.push_back(i);\n\t\tweights.push_back(0);\n\t\tnum_rank.push_back(0);\n\t}\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint com, x, y, z;\n\n\t\tcin >> com >> x >> y;\n\n\t\tswitch(com) {\n\n\t\tcase 0:\n\t\t\tcin >> z;\n\t\t\tunite(x, y, z);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (isSame(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t\tbreak;\n\n\n\t\t}\n\n#if DEBUG == 1\n\n\t\tif (com == 0)\n\t\t\tcout << \"unite\" << \" : \";\n\t\telse\n\t\t\tcout << \"     \" << \" : \";\n\t\tcout << x << \" \" << y << \" \" << z << endl;\n\n\t\tfor(int i = 0; i < n; ++i) \n\t\t\tcout << i << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << numbers[i] << \" \";\n\t\tcout << endl;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcout << weights[i] << \" \";\n\n\t\tcout << endl << endl;\n#endif\n\t}\n\n\n\treturn 0;\n}\n\n\nint getParent(int x) {\n\n\tif (numbers[x]!= x) {\n\t\tint r = getParent(numbers[x]);\n\n#if DEBUG == 1\n\t\tcout << \"root weights = \" << weights[numbers[x]] << endl;\n#endif\n\t\t\n\t\tweights[x] += weights[numbers[x]];\n\t\tnumbers[x] = r;\n\t}\n\t\n\treturn numbers[x];\n\n}\n\nvoid unite(int x, int y, int w) {\n\n\n\tint x_p = getParent(numbers[x]);\n\tint y_p = getParent(numbers[y]);\n\n\tw += weights[x];\n\tw -= weights[y];\n\n#if DEBUG == 1\n\tcout << x_p << \"(\" << weights[x_p] << \"), \" << y_p << \"(\" << weights[y_p] << \")\" << endl;\n#endif\n\t/*\n\tif (num_rank[x_p] < num_rank[y_p]) {\n\t\tswap(x_p, y_p);\n\t\tw *= -1;\n\t}\n\tif (num_rank[x_p] == num_rank[y_p])\n\t\t++num_rank[x_p];\n\t*/\n\tnumbers[y_p] = x_p;\n\tweights[y_p] = w;\n\t\n\n}\n\nbool isSame(int x, int y) {\n\n\treturn getParent(x) == getParent(y);\n\n}\n\n\nint diff(int x, int y) {\n\n\tgetParent(x);\n\tgetParent(y);\n\n#if DEBUG == 1\n\tcout << y << \"(\" << weights[y] << \") - \" << x << \"(\" << weights[x] << \")\" << endl;\n#endif\n\t\n\treturn weights[y] - weights[x];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1330\n#include <iostream>\n#include <vector>\n#include <limits>\n#include <numeric>\n//cut begin\ntemplate<typename T>\nstruct PotentializedUnionFind{\nprivate:\n    private:\n    std::vector<int> par;\n    std::vector<int> size;\n    std::vector<T> diff;\npublic:\n    PotentializedUnionFind(int n){\n        par.resize(n);\n        std::iota(par.begin(),par.end(),0);\n        size.resize(n);\n        std::iota(size.begin(),size.end(),0);\n        diff.assign(n,0);\n    }\n\n    int root(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            int r=root(par[x]);\n            diff[x]+=diff[par[x]];\n            return par[x]=r;\n        }\n    }\n\n    T potential(int x){\n        root(x);\n        return diff[x];\n    }\n\n    T potential_diff(int x,int y){\n        return potential(y)-potential(x);\n    }\n\n    bool same(int x,int y){//0-indexed\n        return root(x)==root(y);\n    }\n\n    void unite(int x,int y,T w){//0-indexed,potential(y)-potential(x)=w\n        w+=potential(x);\n        w-=potential(y);\n        \n        x=root(x);\n        y=root(y);\n        if(x==y)return;\n\n        if(size[x]<size[y]){\n            par[x]=y;\n            size[y]+=size[x];\n            diff[x]=-w;\n        }\n        else{\n            par[y]=x;\n            size[x]+=size[y];\n            diff[y]=w;\n        }\n    }\n};\n//cut end\n\nint solve(){\n    int n,m;\n    std::cin>>n>>m;\n    if(n==0&&m==0)return 1;\n    PotentializedUnionFind<long long> pu(n);\n    for (int i = 0; i < m; ++i){\n        char c;\n        std::cin>>c;\n        int x,y,z;\n        std::cin>>x>>y;\n        if(c=='0'){\n            std::cin>>z;\n            pu.unite(x,y,z);\n        }\n        else{\n            if(pu.same(x,y))std::cout<<pu.potential_diff(x,y)<<std::endl;\n            else std::cout<<\"?\"<<std::endl;\n        }\n    }\n    return 0;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nstruct UnionFind//mainより前に置く\n{\n  vector<int> parent;\n  vector<ll> dist;\n  \n  UnionFind(int x = 1)\n  {\n    parent.clear();\n    parent.resize(x,-1);\n    dist.clear();\n    dist.resize(x,0);\n  }\n  \n  int find(int x)\n  {\n    if(parent[x] < 0) return x;//親が確定\n    \n    int r = find(parent[x]);\n    dist[x] += dist[parent[x]];\n    return parent[x] = r; \n  }\n  \n  ll depth(int x)\n  {\n    find(x);\n    return dist[x];\n  }\n  \n  bool same(int x,int y)\n  {\n    return (find(x) == find(y));\n  }\n  \n  int size(int x)\n  {\n    return -parent[find(x)];\n  }\n  \n  void unite(int x, int y, ll k = 0)\n  {\n    k += depth(y);\n    k -= depth(x);\n    k *= -1;\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(size(x) < size(y))\n    {\n      swap(x,y);\n      k *= -1;\n    }\n    parent[x] += parent[y];\n    parent[y] = x;\n    dist[y] = k;\n  }\n};\n \nint main()\n{\n  int n,q;\n  scanf(\"%d %d\",&n,&q);//文字の取得\n  UnionFind T(n);\n  \n  for(int i = 0; i < q; i++)\n  {\n    int type,x,y;\n    scanf(\"%d %d %d\",&type,&x,&y);\n    if(type == 0)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      T.unite(x,y,a);//距離の追加\n    }else\n    {\n      if(!T.same(x,y))\n      {\n        printf(\"?\\n\");//距離が不明\n      }else\n      {\n        printf(\"%lld\\n\",T.depth(x) - T.depth(y));//距離の取得\n      }\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 木の深さでマージ\n#include<unordered_map>\n#include<utility>\ntemplate<typename T> class UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    if(rank_[x] == rank_[y]) ++rank_[x];\n    parent_[y] = x;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) rank_[x] = 1, parent_[x] = x;\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n// 要素数でマージ\n#include<unordered_map>\n#include<utility>\ntemplate<typename T> class UnionFindBySize {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(size_[x] < size_[y]) std::swap(x, y);\n    if(x != y) parent_[y] = x, size_[x] += size_[y];\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) size_[x] = 1, parent_[x] = x;\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n  const int size(const T& x) {\n    return size_[find(x)];\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> size_;\n};\n\n// 省メモリ, 要素数でマージ (x が根 ⇒ p_[x] = -(要素数))\n#include<vector>\n#include<utility>\nclass UnionFindLight {\n public:\n  UnionFindLight(int n) : p_(n, -1) {}\n  void unite(int a, int b) {\n    auto x = find(a), y = find(b);\n    if(x == y) return;\n    if(p_[x] < p_[y]) std::swap(x, y);\n    p_[x] += p_[y];\n    p_[y] = x;\n  }\n  int find(int x) {return p_[x] < 0 ? x : p_[x] = find(p_[x]);}\n  int size(int x) {return -p_[x];}\n private:\n  std::vector<int> p_;\n};\n\n// 重み付き: W はアーベル群\n#include<cassert>\n#include<unordered_map>\n#include<utility>\ntemplate<typename T, typename W> class WeightedUnionFind {\n public:\n  void unite(const T& a, const T& b, const W& w) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y), weight_[y] = weight(b) - weight(a) - w;\n    else                                     weight_[y] = weight(a) - weight(b) + w;\n    if(rank_[x] == rank_[y]) ++rank_[x];\n    parent_[y] = x;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) rank_[x] = 1, parent_[x] = x;\n    if(parent_[x] == x) return x;\n    auto root = find(parent_[x]);\n    weight_[x] += weight_[parent_[x]];\n    return parent_[x] = root;\n  }\n  W weight(const T& x) {\n    find(x);\n    return weight_[x];\n  }\n  W diff(const T& a, const T& b) {\n    assert(find(a) == find(b));\n    return weight(b) - weight(a);\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, W> weight_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<iostream>\nusing namespace std;\nint main() {\n  using LL = long long;\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind<int, LL> UF;\n  for(auto i=0; i<q; ++i) {\n    int c, x, y, z;\n    cin >> c >> x >> y;\n    if(c) {\n      if(UF.find(x) == UF.find(y)) cout << UF.diff(x, y) << endl;\n      else                         cout << \"?\" << endl;\n    } else {\n      cin >> z;\n      UF.unite(x, y, z);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ntemplate <class Abel> class WeightedUnionFind {\n  private:\n    std::vector<int> par;\n    std::vector<int> rank;\n    std::vector<Abel> diff_weight;\n\n  public:\n    WeightedUnionFind(int n, Abel SUM_UNITY = 0) : par(n), rank(n, 0), diff_weight(n, SUM_UNITY) {\n      for(int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    Abel weight(int x) {\n      find(x);\n      return diff_weight[x];\n    }\n\n    int find(int x) {\n      if(x == par[x]) return x;\n\n      int r = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n\n    void unite(int x, int y, Abel w) {\n      w += weight(x);\n      w -= weight(y);\n      x = find(x);\n      y = find(y);\n\n      if(x == y) return;\n      if(rank[x] < rank[y]) {\n        std::swap(x, y);\n        w = -w;\n      }\n      par[y] = x;\n      diff_weight[y] = w;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n\n    bool same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    Abel diff(int x, int y) {\n      return weight(y) - weight(x);\n    }\n};\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind<int> uf(n);\n  rep(i, 0, q) {\n    int c, x, y;\n    cin >> c >> x >> y;\n    if(c == 0) {\n      int z;\n      cin >> z;\n      uf.unite(x, y, z);\n    }\n    else {\n      if(uf.same(x, y)) cout << uf.diff(x, y) << endl;\n      else cout << '?' << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define LF '\\n'\n#define ALL(x) x.begin(), x.end()\n#define iostreamBooster() { cin.tie(nullptr); ios_base::sync_with_stdio(false); }\nusing namespace std;\ntypedef int64_t i64;\ntypedef pair<int,int> pii;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF = 0x3f3f3f3f;\ntemplate<class Itr> void dump(Itr begin, Itr end) { for (;begin != end; ++begin) clog << *begin << LF; }\n\ntemplate<class Abel>\nstruct WeightedUnionFind {\n  vector<int> uni;\n  vector<Abel> dw;\n\n  explicit WeightedUnionFind(int n, const Abel &UNIT = 0)\n    : uni(n+5, -1), dw(n+5, UNIT) {}\n\n  int   size(int x)       { return -uni[root(x)]; }\n  Abel  weight(int x)     { root(x); return dw[x]; }\n  bool  same(int x, int y){ return root(x) == root(y); }\n  Abel  diff(int x, int y){ return weight(y) - weight(x); }\n\n  int root(int x) {\n    if (uni[x] < 0) return x;\n    const int rt = root(uni[x]);\n    dw[x] += dw[uni[x]];\n    return uni[x] = rt;\n  }\n\n  bool unite(int x, int y, Abel w) {\n    w += weight(x) - weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (uni[y] < uni[x]) swap(x,y), w = -w;\n    uni[x] += uni[y]; uni[y] = x; dw[y] = w;\n    return true;\n  }\n};\n\nsigned main()\n{\n  iostreamBooster();\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind<i64> wuf(n);\n\n  while(q--) {\n    int com, x, y, z;\n\n    cin >> com;\n    if (com == 0) {\n      cin >> x >> y >> z;\n      wuf.unite(x, y, z);\n    } else {\n      cin >> x >> y;\n      if (wuf.same(x, y))\n        cout << wuf.diff(x, y) << LF;\n      else {\n        cout << '?' << LF;\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nconst int MOD = 1000000007; \nconst int INF = 1000000000; //1e9\nconst int NIL = -1;\nconst long long LINF = 1000000000000000000; // 1e18\nconst long double EPS = 1E-10;\n\ntemplate<class T, class S> inline bool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S> inline bool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n//Tはアーベル群\ntemplate<class T> class WeightedUnionFind{\n    std::vector<int> par;\n    std::vector<int> rank;\n    std::vector<T> diff_weight;\n\npublic:\n    WeightedUnionFind(){}\n    WeightedUnionFind(int n, T UNITY = 0): par(n), rank(n), diff_weight(n){\n        for(int i(0); i < n; ++i){\n            par[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = UNITY;\n        }\n    }\n\n    void  resize(int n, T UNITY = 0){\n        int m(par.size());\n        par.resize(n);\n        rank.resize(n, 0);\n        diff_weight.resize(n, UNITY);\n        for(int i(m); i < n; ++i) par[i] = i;\n    }\n\n    int find(int x){\n        if(x == par[x]) return x;\n        int r(find(par[x]));\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n\n    T weight(int x){\n        find(x);\n        return diff_weight[x];\n    }\n\n    //weight(y) = weight(x) + w\n    bool unit(int x, int y, T w){\n        w += weight(x); w -= weight(y);\n        x = find(x); y = find(y);\n        if(x == y) return false;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            diff_weight[x] = -w;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) ++rank[x];\n            diff_weight[y] = w;\n        }\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\n\n\n\n\nint main(){\n    int n; std::cin >> n;\n    WeightedUnionFind<int> wuf(n);\n    {\n        int q, op, x, y, z; std::cin >> q;\n        for(int QQ(0); QQ < q; ++QQ){\n            std::cin >> op >> x >> y;\n            if(!op){\n                std::cin >> z;\n                wuf.unit(x, y, z);\n            }else{\n                if(wuf.same(x, y)){\n                    std::cout << wuf.weight(y) - wuf.weight(x) << \"\\n\";\n                }else{\n                    std::cout << \"?\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\n    struct Node{\n        int id;\n        int diff;\n        \n        Node(){}\n        Node(int a, int b){\n            id = a;\n            diff = b;\n        }\n    };\n    \nprivate:\n    vector<list<Node> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<bool> visit(tree.size(), false);\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        for(list<Node>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n            if(Root(iter->id, target, Sum, visit)){\n                Sum += iter->diff;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    bool Root(int now, int target, int &Sum, vector<bool> &visit){\n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        for(list<Node>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n            if(!visit[iter->id]){\n                if(Root(iter->id, target, Sum, visit)){\n                    Sum += iter->diff;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x].emplace_back(y, z);\n        tree[y].emplace_back(x, -z);\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S))\n            cout << S << endl;\n        else\n            cout << \"?\" << endl;\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define eps LDBL_EPSILON\n#define moder 1000000007\n#define int long long\n#define ll long long\n#define INF LLONG_MAX/3\n#define P std::pair<int,int>\n#define prique priority_queue<int,vector<int>,greater<int>>\nusing namespace std;\nint par[100010],ran[100010],dw[100010];\nvoid init(){\n\trep(i,100010){\n\t\tpar[i]=i;\n\t\tran[i]=0;\n\t\tdw[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x)return x;\n\telse{\n\t\tint r=find(par[x]);\n\t\tdw[x]+=dw[par[x]];\n\t\treturn par[x]=r;\n\t}\n}\nint weight(int x){\n\tfind(x);\n\treturn dw[x];\n}\nvoid unite(int x,int y,int w){\n\tw+=weight(x);\n\tw-=weight(y);\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return;\n\tif(ran[x]<ran[y]){\n\t\tpar[x]=y;\n\t\tdw[x]=-w;\n\t}\n\telse{\n\t\tpar[y]=x;\n\t\tdw[y]=w;\n\t\tif(ran[x]==ran[y])ran[x]++;\n\t}\n}\nbool same(int a,int b){\n\treturn find(a)==find(b);\n}\nint diff(int x,int y){\n\treturn weight(y)-weight(x);\n}\nint n,q;\nint com,x,y,z;\nsigned main(){\n\tcin>>n>>q;\n\tinit();\n\trep(i,q){\n\t\tcin>>com;\n\t\tif(com==0){\n\t\t\tcin>>x>>y>>z;\n\t\t\tunite(x,y,z);\n\t\t}\n\t\telse{\n\t\t\tcin>>x>>y;\n\t\t\tif(!same(x,y))cout<<\"?\"<<endl;\n\t\t\telse cout<<diff(x,y)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region templates\n//C\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing i8  = std::int8_t;\nusing i16 = std::int16_t;\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u8  = std::uint8_t;\nusing u16 = std::uint16_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing f32 = float;\nusing f64 = double;\nusing vi32  = std::vector<i32>;\nusing vu32  = std::vector<u32>;\nusing vi64  = std::vector<i64>;\nusing vu64  = std::vector<u64>;\nusing vvi32 = std::vector<vi32>;\nusing vvu32 = std::vector<vu32>;\nusing vvi64 = std::vector<vi64>;\nusing vvu64 = std::vector<vu64>;\nusing pi32  = std::pair<i32,i32>;\nusing pi64  = std::pair<i64,i64>;\n\n#define FOR(i,a,b) for(i64 i=(a), i##_len=(b); i<i##_len; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) for(i64 i=1LL; i<=static_cast<i64>(n); ++i)\n#define RFOR(i,a,b) for(i64 i=(a), i##_len=(b); i>i##_len; --i)\n#define RFORS(i,n) RFOR(i,n,0)\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define CLR(ar,val) memset(ar, val, sizeof(ar))\n#define SZ(obj) (static_cast<i32>(obj.size()))\n#define cauto const auto&\n#define pb push_back\n#define mp make_pair\n\nconst i32 dx[4]={1,0,-1,0};\nconst i32 dy[4]={0,1,0,-1};\nconst i32 INF32 = 0x3F3F3F3F;\nconst i64 INF64 = 0x3F3F3F3F3F3F3F3F;\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nclass range {\nprivate:\n    struct I {\n        i32 x;\n        i32 operator*() { return x; }\n        bool operator!=(I& lhs) { return x<lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i,n;\npublic:\n    explicit range(int n) : i({0}), n({n}) { }\n    range(int i,int n) : i({i}), n({n}) { }\n    I& begin() { return i; }\n    I& end() { return n; }\n};\n\nstruct IoSetup {\n    IoSetup() {\n        std::cin.tie(nullptr);\n        std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(10);\n        std::cerr << std::fixed << std::setprecision(10);\n    }\n}iosetup;/// cin,coutを使うときは iosetup をここにつける\n\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second;return is; }\ntemplate<typename A, typename B> std::ostream &operator<<(std::ostream &os, const std::pair<A, B>& p) { os << p.first << ' ' << p.second;return os; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for(T& in : v) is >> in; return is; }\ntemplate<typename T> std::ostream &operator<<(std::ostream &os, const std::vector<T> &v) { for(i32 i = 0; i < SZ(v); i++) os << v[i] << (i+1 != SZ(v) ? \" \" : \"\"); return os; }\n#pragma endregion\n\n#pragma region UnionFind with Weight\ntemplate<typename T>\nstruct UFwW {\n    vi32 data;\n    std::vector<T> ws;\n\n    UFwW() { }\n\n    explicit UFwW(i32 sz) : data(sz, -1), ws(sz) { }\n\n    i32 find(i32 k) {\n        if (data[k] < 0) return k;\n        auto par = find(data[k]);\n        ws[k] += ws[data[k]];\n        return (data[k] = par);\n    }\n\n    T weight(i32 t) {\n        find(t);\n        return ws[t];\n    }\n\n    bool unite(i32 x, i32 y, T w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x), y = find(y);\n        if (x == y) return (false);\n        if (data[x] > data[y]) {\n            x ^= y ^= x ^= y;\n            w *= -1;\n        }\n        data[x] += data[y];\n        data[y] = x;\n        ws[y] = w;\n        return (true);\n    }\n\n    T diff(i32 x, i32 y) {\n        return (weight(y) - weight(x));\n    }\n};\n#pragma endregion\n\ni32 main(){\n\n    using namespace std;\n    \n    i32 N, M; cin >> N >> M;\n    UFwW<i32> tree(N);\n    while (M--) {\n        i32 A, B, C, D;\n        cin >> A >> B >> C;\n        if (A == 0) {\n            cin >> D;\n            tree.unite(B, C, D);\n        } else {\n            if (tree.find(B) == tree.find(C)) {\n                cout << tree.diff(B, C) << endl;\n            }\n            else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nclass UnionFind {\n    private:\n        vector<int> parent;  // 親\n        vector<int> rank;    // 木の深さ\n\n        // 重み付きUnionFindでのみ利用\n        vector<T> diffWeight; // 親ノードとの値の差\n    public:\n        UnionFind(int n);          // n要素で初期化\n        int Find(int x);           // 木の根を返す\n        void Unite(int x, int y);  // xとyの属する集合を併合\n        bool Same(int x, int y);   // xとyが同じ集合に属するか否か\n        \n        // 重み付きUnionFindでのみ利用\n        void Unite(int x, int y, T w);\n        T Weight(int x);      // xの重みを返す\n        T Diff(int x, int y); // xとyの差を返す\n};\n\ntemplate <typename T>\nUnionFind<T>::UnionFind(int n) : parent(n), rank(n), diffWeight(n, 0)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\ntemplate <typename T>\nint UnionFind<T>::Find(int x) {\n    if (parent[x] == x) {\n        return x;\n    } else {\n        diffWeight[x] += diffWeight[parent[x]];\n        return parent[x] = Find(parent[x]);\n    }\n}\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ntemplate <typename T>\nbool UnionFind<T>::Same(int x, int y) { return Find(x) == Find(y); }\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y, T w){\n    w += Weight(x); w -= Weight(y);\n    x = Find(x); y = Find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) swap(x, y), w = -w;\n\n    if(rank[x] == rank[y]) rank[x]++;\n    parent[y] = x;\n\n    diffWeight[y] = w;\n}\n\ntemplate <typename T>\nT UnionFind<T>::Weight(int x){\n    Find(x);\n    return diffWeight[x];\n}\n\ntemplate <typename T>\nT UnionFind<T>::Diff(int x, int y){\n    return Weight(y) - Weight(x);\n}\n\n/*************** using variables ***************/\nint n, q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    UnionFind<int> uf(n);\n    REP(i, q){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.Unite(x, y, z);\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(uf.Same(x, y)) cout << uf.Diff(x, y) << endl;\n            else cout << '?' << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n//#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e9;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\n\ntemplate<typename Weight>class PotentializedUnionFind{\npublic:\n  vector<int> par,rnk,sz;\n  vector<Weight> difweight;\n  PotentializedUnionFind(int n):\n    par(n,-1),rnk(n,0),sz(n,1),difweight(n,0){}\n\n  int find(int x){\n    if(par[x]<0){return x;}\n    else{\n      int r=find(par[x]);\n      difweight[x]+=difweight[par[x]];\n      return par[x]=r;\n    }\n  }\n  Weight weight(int x){\n    find(x);\n    return difweight[x];\n  }\n  bool same(int x,int y){return find(x)==find(y);}\n\n  bool unite(int x,int y,Weight w){\n    w+=weight(x);w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y)return false;\n    if(rnk[x]<rnk[y])swap(x,y),w=-w;\n    if(rnk[x]==rnk[y])rnk[x]++;\n    par[y]=x;\n    difweight[y]=w;\n    return true;\n  }\n  Weight diff(int x,int y){return weight(y)-weight(x);}\n};\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n  PotentializedUnionFind<int> uf(n);\n  rep(i,q){\n    int t;\n    cin>>t;\n    if(t){\n      int x,y;\n      cin>>x>>y;\n      if(uf.same(x,y)){\n        cout<<uf.diff(x,y)<<endl;\n      }else{\n        cout<<\"?\"<<endl;\n      }\n    }else{\n      int x,y,z;\n      cin>>x>>y>>z;\n      uf.unite(x,y,z);\n    }\n  }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nclass WeightedUnionFind{\npublic:\n  int V;\n  vector<int> par, rnk, diff, sz;\n  WeightedUnionFind():V(-1){}\n  WeightedUnionFind(int V):V(V),par(V),rnk(V,0),diff(V,0),sz(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x] == x) return x;\n    int p = find(par[x]);\n    diff[x] = diff[x] + diff[ par[x] ];\n    return par[x] = p;\n  }\n\n  //頂点xは頂点yよりもz大きい\n  void relate(int x,int y,int z){\n    int sx = x, sy = y;\n    x = find(x), y = find(y);\n    if(x == y) assert(getDiff(x,y) == z);\n    if(x == y)return;\n    \n    if(rnk[x] < rnk[y]) {\n      par[x] = y;\n      sz[y] += sz[x];\n      diff[x] = z + (-diff[sx] + diff[sy]);\n    }\n    else{\n      par[y] = x;\n      sz[x] += sz[y];\n      diff[y] = -z + (diff[sx] - diff[sy]);\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n  \n  int getDiff(int u,int v){\n    assert(same(u,v));\n    return diff[u] - diff[v];\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  int size(int x){return sz[find(x)];}\n  \n};\n\nsigned main(){\n  int n;\n  cin>>n;\n  WeightedUnionFind wuf(n);\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, x, y, z;\n    cin>>cmd >> y >> x;\n    if(cmd == 0){\n      cin>>z;\n      wuf.relate(x,y,z);\n    }\n    if(cmd == 1){\n      if(!wuf.same(x, y)) cout<<\"?\"<<endl;\n      else cout<<wuf.getDiff(x, y)<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author  : 𝒌𝒚𝒐𝒎𝒖𝒌𝒚𝒐𝒎𝒖𝒑𝒖𝒓𝒊𝒏\n *    created : 2020-04-07 20:19:41\n **/\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate <class T>\nusing binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\n  os << '{';\n  size_t n = vec.size();\n  for (size_t i = 0; i < n; ++i) {\n    os << vec[i];\n    if (i != n - 1) os << ',';\n  }\n  os << '}';\n  return os;\n}\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n  return os << '{' << p.first << \" \" << p.second << '}';\n}\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::map<T, U>& mp) {\n  os << '{';\n  for (auto it = mp.begin(); it != mp.end(); ++it) {\n    os << '{' << it->first << ':' << it->second << '}';\n    if (it != --mp.end()) os << ',';\n  }\n  os << '}';\n  return os;\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::set<T>& st) {\n  os << '{';\n  for (auto it = st.begin(); it != st.end(); ++it) {\n    os << *it;\n    if (it != --st.end()) os << ',';\n  }\n  os << '}';\n  return os;\n}\ntemplate <class T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& vec) {\n  size_t n = vec.size();\n  for (size_t i = 0; i < n; ++i) is >> vec[i];\n  return is;\n}\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out() { std::cerr << '\\n'; }\n\ntemplate <class Head, class... Tail>\nvoid debug_out(Head&& head, Tail&&... tail) {\n  std::cerr << head;\n  if (sizeof...(Tail) != 0) std::cerr << \", \";\n  debug_out(std::forward<Tail>(tail)...);\n}\n\nclass UnionFind {\n public:\n  UnionFind(int n, int SUM_UNITY = 0) : n_(n), SUM_UNITY_(SUM_UNITY) {\n    initialize();\n  }\n\n  int root(int x) {\n    assert(0 <= x && x < n_);\n    if (parent_[x] == -1) {\n      return x;\n    } else {\n      int r = root(parent_[x]);\n      diff_weight_[x] += diff_weight_[parent_[x]];\n      return parent_[x] = r;\n    }\n  }\n\n  int weight(int x) {\n    assert(0 <= x && x < n_);\n    root(x);\n    return diff_weight_[x];\n  }\n\n  bool same(int x, int y) {\n    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n    return root(x) == root(y);\n  }\n\n  // y is w larger than x\n  void unite(int x, int y, int w) {\n    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n    w += weight(x);\n    w -= weight(y);\n    x = root(x);\n    y = root(y);\n    if (x == y) return;\n    if (rank_[x] < rank_[y]) {\n      std::swap(x, y);\n      w = -w;\n    }\n    if (rank_[x] == rank_[y]) ++rank_[x];\n    parent_[y] = x;\n    diff_weight_[y] = w;\n    return;\n  }\n\n  int diff(int x, int y) {\n    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n    return weight(y) - weight(x);\n  }\n\n private:\n  const int n_;\n  const int SUM_UNITY_;\n  std::vector<int> parent_;\n  std::vector<int> rank_;\n  std::vector<int> diff_weight_;\n\n  void initialize() {\n    parent_.assign(n_, -1);\n    rank_.assign(n_, 0);\n    diff_weight_.assign(n_, SUM_UNITY_);\n  }\n};\n\nvoid DSL_1_B() {\n  int n, q;\n  cin >> n >> q;\n  UnionFind uf(n);\n  for (int i = 0; i < q; ++i) {\n    int com;\n    cin >> com;\n    if (com == 0) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      uf.unite(x, y, z);\n    } else {\n      int x, y;\n      cin >> x >> y;\n      if (!uf.same(x, y)) {\n        cout << '?' << '\\n';\n      } else {\n        cout << uf.diff(x, y) << '\\n';\n      }\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  DSL_1_B();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n  vector<int> parent;\n  vector<int> dist;\n  UnionFind(int x=1){\n    parent.clear();\n    parent.resize(x,-1);\n    dist.clear();\n    dist.resize(x,0);\n  }\n  int find(int x){\n    if(parent[x]<0)return x;\n    return find(parent[x]);\n  }\n  int depth(int x){\n    if(parent[x]<0)return 0;\n    return depth(parent[x])+dist[x];\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int size(int x){\n    return -parent[find(x)];\n  }\n  void unite(int x,int y,int k=0){\n    k+=depth(y);\n    k-=depth(x);\n    k*=-1;\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size(x)<size(y)){\n      swap(x,y);\n      k*=-1;\n    }\n    parent[x]+=parent[y];\n    parent[y]=x;\n    dist[y]=k;\n  }\n};\n\n\n\n\nint main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  UnionFind T(n);\n  for(int i=0;i<q;i++){\n    int type,x,y;\n    scanf(\"%d %d %d\",&type,&x,&y);\n    if(type==0){\n      int a;\n      scanf(\"%d\",&a);\n      T.unite(x,y,a);\n    }else{\n      \n      if(!T.same(x,y)){\n        printf(\"?\\n\");\n      }else{\n        printf(\"%d\\n\",T.depth(x)-T.depth(y));\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cstdio>\n#include<utility>\n#include<set>\n#include<list>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define REP(i, n) FOR(i, 0, n - 1)\n#define NREP(i, n) FOR(i, 1, n)\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<pii, pii>;\nconst ll dx[4] = { 0,1,0,-1 };\nconst ll dy[4] = { -1, 0, 1,0 };\nconst ll INF = 1e9 + 7;\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nvoid mul(ll a, ll b) {\n\ta = a * b % INF;\n}\ndouble mysqrt(double x) {\n\tdouble l = 0, r = x;\n\tfor (int i = 0; i < 64; ++i) {\n\t\tdouble m = (l + r) / 2.0;\n\t\tif (m*m < x)l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n///////////////////////////////////////\n\ntemplate<class Abel> struct UnionFind {\n\tvector<int> par;\n\tvector<int> rank;\n\tvector<Abel> diff_weight;\n\n\tUnionFind(int n = 1, Abel SUM_UNITY = 0) {\n\t\tinit(n, SUM_UNITY);\n\t}\n\n\tvoid init(int n = 1, Abel SUM_UNITY = 0) {\n\t\tpar.resize(n); rank.resize(n); diff_weight.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tint r = root(par[x]);\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\n\tAbel weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tbool issame(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x, int y, Abel w) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) swap(x, y), w = -w;\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n\n\tAbel diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n};\nint main() {\n\tUnionFind<int> tree(1000100);\n\tint n, q; cin >> n >> q;\n\tREP(i, q) {\n\t\tint x; cin >> x;\n\t\tif (x) {\n\t\t\tint X, Y; cin >> X >> Y;\n\t\t\tif (!tree.issame(X, Y)) {\n\t\t\t\tcout << '?' << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << tree.diff(Y, X) << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint X, Y, Z; cin >> X >> Y >> Z;\n\t\t\ttree.merge(Y,X,Z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <cassert>\n#include <numeric>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_1_B\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nvoid out(const T& v) { std::cout << v; }\ntemplate<typename T>\nvoid out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    std::cout << \"\\n\";\n}\ntemplate<typename T1, typename T2>\nvoid out(const std::pair<T1, T2>& v) { out(v.first), std::cout << ' ', out(v.second); }\ntemplate<typename T, typename... Args>\nvoid out(const T& v, const Args... args) { out(v), std::cout << ' ', out(args...); }\ntemplate<typename... Args>\nvoid outln(const Args... args) { out(args...), std::cout << '\\n'; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { out(args...), std::cout << std::endl; }\n\ntemplate<typename Potential>\nclass pot_unionfind\n{\npublic:\n    using potential_type = Potential;\n    pot_unionfind(const usize v) : sz{v}, rt(v), comp_sz(v, 1), pot(v, potential_type{}) { std::iota(rt.begin(), rt.end(), 0); }\n    usize root_of(const usize a)\n    {\n        assert(a < sz);\n        if (rt[a] == a) { return a; }\n        const usize r = root_of(rt[a]);\n        return pot[a] += pot[rt[a]], rt[a] = r;\n    }\n    void unite(usize a, usize b, potential_type w)  // p[b]-p[a]=w\n    {\n        assert(a < sz), assert(b < sz);\n        if (root_of(a) == root_of(b)) { assert(diff_between(a, b) == w); }\n        w += pot_of(a), w -= pot_of(b), a = root_of(a), b = root_of(b);\n        if (a == b) { return; }\n        if (comp_sz[a] < comp_sz[b]) { std::swap(a, b), w = -w; }\n        comp_sz[a] += comp_sz[b], rt[b] = a, pot[b] = w;\n    }\n    usize size_of(const usize a) { return assert(a < sz), comp_sz[root_of(a)]; }\n    potential_type diff_between(const usize a, const usize b) { return assert(a < sz), assert(b < sz), assert(root_of(a) == root_of(b)), pot[b] - pot[a]; }\n    friend std::ostream& operator<<(std::ostream& os, const pot_unionfind& uf)\n    {\n        os << \"[\";\n        for (usize i = 0; i < uf.rt.size(); i++) { os << uf.rt[i] << (i + 1 == uf.rt.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    potential_type pot_of(const usize a) { return assert(a < sz), root_of(a), pot[a]; }\n    const usize sz;\n    std::vector<usize> rt, comp_sz;\n    std::vector<potential_type> pot;\n};\nint main()\n{\n    const auto n = in<usize>();\n    const auto q = in<usize>();\n    pot_unionfind<int> uf(n);\n    for (usize i = 0; i < q; i++) {\n        const auto c = in<usize>();\n        if (c == 0) {\n            const auto u = in<usize>();\n            const auto v = in<usize>();\n            const auto d = in<ll>();\n            uf.unite(u, v, d);\n        } else {\n            const auto u = in<usize>();\n            const auto v = in<usize>();\n            if (uf.root_of(u) == uf.root_of(v)) {\n                outln(uf.diff_between(u, v));\n            } else {\n                outln(\"?\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(a) sort(a.begin(), a.end())\n#define RSORT(a) sort(a.rbegin(), a.rend())\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define RREP(i, n) for (int i = n; 0 <= i; i--)\n#define FOR(i, start, end) for (int i = start; i < end; i++)\n#define RFOR(i, start, end) for (int i = start; end <= i; i--)\n#define ALL(a) a.begin(), a.end()\n#define MOD(a) a %= 1'000'000'007\n#define INF32 1'050'000'000\n#define INF64 4'000'000'000'000'000'000\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nclass Weighted_UnionFind {\n  public:\n    // 親の番号を格納する。親の場合 -1 になる\n    vector<int> Parent;\n    vector<long long> Weight;\n\n    // 宣言されたとき Parent の値はすべて -1 にする\n    Weighted_UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n        Weight.resize(N);\n    }\n\n    // 与えられた値 x がどの親であるか調べる\n    int root(int x) {\n        if (Parent[x] < 0)\n            return x;\n        int par = root(Parent[x]);\n        Weight[x] += Weight[Parent[x]];\n        return Parent[x] = par;\n    }\n\n    // 木の全体の数を返す\n    int size(int x) { return -Parent[root(x)]; }\n\n    // 引数と親の重さを返す\n    long long weight_to_parent(int x) {\n        root(x);\n        return Weight[x];\n    }\n\n    // 2つの引数を同じ親にする\n    bool update(int x, int y, long long w) {\n        w += weight_to_parent(x);\n        w -= weight_to_parent(y);\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (size(x) < size(y)) {\n            swap(x, y);\n            w *= -1;\n        }\n        Parent[x] += Parent[y];\n        Parent[y] = x;\n        Weight[y] = w;\n        return true;\n    }\n\n    // 引数の親が同じか判定する\n    bool is_same(int x, int y) { return root(x) == root(y); }\n\n    // 引数の差を求める。存在しないしない場合、0 を返す\n    long long diff(int x, int y) {\n        if (!is_same(x, y))\n            return 0;\n        return Weight[y] - Weight[x];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q;\n    cin >> N >> Q;\n    auto uni = Weighted_UnionFind(N);\n    REP(i, Q) {\n        int q, x, y, z;\n        cin >> q >> x >> y;\n\n        if (q == 0) {\n            cin >> z;\n            uni.update(x, y, z);\n        } else {\n            if (uni.is_same(x, y)) {\n                std::cout << uni.diff(x, y) << '\\n';\n            } else {\n                std::cout << '?' << '\\n';\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename T>\nstruct WUF {\n  int n, c;\n  vector<int> p;\n  vector<T> dw;\n  WUF() {}\n  WUF(int n) : n(n), c(n), p(n, -1), dw(n) {}\n  int find(int x) {\n    if (p[x] < 0) return x;\n    int r = find(p[x]);\n    dw[x] += dw[p[x]];\n    return p[x] = r;\n  }\n  int unite(int x, int y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return w == 0;\n    if (p[x] > p[y]) swap(x,y), w = -w;\n    p[x] += p[y];\n    p[y] = x;\n    dw[y] = w;\n    c--;\n    return 1;\n  }\n  T weight(int x) {\n    find(x);\n    return dw[x];\n  }\n  T diff(int x, int y) {\n    assert(same(x, y));\n    return weight(y) - weight(x);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return -p[find(x)];\n  }\n  int count() {\n    return c;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n,q;\n  cin >> n >> q;\n  WUF<int> wuf(n);\n  REP(i,q) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      wuf.unite(x,y,z);\n    } else {\n      int x,y;\n      cin >> x >> y;\n      if (wuf.same(x,y)) cout << wuf.diff(x,y) << endl;\n      else cout << \"?\" << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nconst int MAX_UF = 110000;\nstruct PotentialUnionFind{\n    typedef ll TYPE;\n    const TYPE SUM_UNITY = 0;\n    TYPE par[MAX_UF],rank[MAX_UF];\n    TYPE diff_weight[MAX_UF];\n    int N;\n    PotentialUnionFind(int n = 0):N(n){ for(int i = 0; i < n;i++){ par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY; } }\n    void init(){ for(int i = 0; i < N;i++){ par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY; } }\n    void init(int n){ for(int i = 0; i < n; i++){ par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY; } }\n    \n    TYPE root(TYPE x){\n        if(par[x] == x) return x;\n        else {\n            TYPE r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n    TYPE weight(TYPE x){ root(x); return diff_weight[x]; }\n    bool same(TYPE x,TYPE y){\n        return root(x) == root(y);\n    }\n    bool merge(TYPE x,TYPE y,TYPE w){\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) {swap(x, y); w = -w; }\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x; diff_weight[y] = w;\n        return true;\n    }\n    \n    TYPE diff(TYPE x,TYPE y){ return weight(y) - weight(x); }\n};\n\nvoid solve(){\n    int N,M; cin >> N >> M;\n    PotentialUnionFind PUF(N);\n    for(int i = 0; i < M; i++){\n        int com; cin >> com;\n        if(com == 0){\n            int l,r,d; cin >> l >> r >> d;\n            PUF.merge(r,l,d);\n        }else{\n            int l,r; cin >> l >> r;\n            if(!PUF.same(l,r)){\n                cout << \"?\" << endl;\n            }else{\n                cout << PUF.diff(r,l) << endl;\n            }\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <tuple>\n#include <stdio.h>\n#include <bitset>\n#include <limits.h>\n#include <complex>\n#include <deque>\n#include <iomanip>\n#include <list>\n#include <cstring>\nusing namespace std;\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define chmax(a,b) (a<b ? a=b:0)\n#define chmin(a,b) (a>b ? a=b:0)\n#define en cout << endl //セミコロンつけろ\n//#define MM 1000000000\n//#define MOD MM+7\ntypedef long long ll;\nconst int MM = 1e9;\nconst int MOD = MM+7;\nconst long double PI = acos(-1);\nconst long long INF = 1e15;\nint dx[8] = {-1,0,1,0,-1,-1,1,1};\nint dy[8] = {0,-1,0,1,-1,1,1,-1};\n// 'A' = 65, 'Z' = 90, 'a' = 97, 'z' = 122\n\ntemplate<typename T> //最大公約数\nT GCD(T u,T v){\n    return v ? GCD(v,u%v) : u;\n}\ntemplate<typename T> //最小公倍数\nT LCM(T x,T y){\n    T gc = GCD(x,y);\n    return x*y/gc;\n}\n\nconst int COM_MAX = 500500;\nlong long fac[COM_MAX],finv[COM_MAX],inv[COM_MAX];\nvoid init(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < COM_MAX; i++){\n        fac[i] = fac[i-1]*i%MOD;\n        inv[i] = MOD - inv[MOD%i]*(MOD/i)%MOD;\n        finv[i] = finv[i-1]*inv[i]%MOD;\n    }\n}\nlong long COM(int n,int k){\n    if(n < k || n < 0 || k < 0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n\n// a^n mod を計算する\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// a^{-1} mod を計算する\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\n\nstruct BinaryIndexedTree\n{\n  vector< int > data;\n\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(sz + 1, 0);\n  }\n\n  int Sum(int k)\n  {\n    int sum = 0;\n    for(; k > 0; k -= k & -k) sum += data[k];\n    return sum;\n  }\n\n  void Add(int k, int x)\n  {\n    for(; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n\ntemplate<class T> \nstruct WeightedUnionFind {\n    const T sum = 0;\n    vector<int> par;\n    vector<T> weight;\n    vector<T> diff_weight;\n\n    WeightedUnionFind(int n){\n        par.assign(n, -1), diff_weight.assign(n, sum);\n    }\n\n    int root(int x){\n        if (par[x] < 0) return x;\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n     \n    T function_weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n\n    bool merge(int x,int y,T w = 0){\n        w += function_weight(x); \n        w -= function_weight(y);\n\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]){\n            swap(x,y);\n            w *= -1;\n        }\n        par[x] += par[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    T diff(int x,int y){\n        return function_weight(y) - function_weight(x);\n    }\n\n    T size(int x){\n        return -par[root(x)];\n    }\n};\n\nint main(){\n\tint N, Q; cin >> N >> Q;\n\tWeightedUnionFind<int> uf(N);\n\tvector<int> ans(0);\n\tfor (int i = 0; i < Q; i++){\n\t\tint c, x, y; cin >> c >> x >> y;\n\t\tif (c == 0){\n\t\t\tint z; cin >> z;\n\t\t\tif (!uf.same(x, y)){\n\t\t\t\tuf.merge(x, y, z);\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\tint res;\n\t\t\tif (uf.same(x, y)){\n\t\t\t\tres = uf.diff(x, y);\n\t\t\t} else {\n\t\t\t\tres = MM;\n\t\t\t}\n\t\t\tans.push_back(res);\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tif (ans[i] == MM) cout << '?' << endl;\n\t\telse cout << ans[i] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate <class Z> Z getint() {\n  char c = getchar();\n  bool neg = c == '-';\n  Z res = neg ? 0 : c - '0';\n  while (isdigit(c = getchar())) res = res * 10 + (c - '0');\n  return neg ? -res : res;\n}\ntemplate <class Z> void putint(Z a, char c = '\\n') {\n  if (a < 0) putchar('-'), a = -a;\n  int d[40], i = 0;\n  do d[i++] = a % 10; while (a /= 10);\n  while (i--) putchar('0' + d[i]);\n  putchar(c);\n}\n\ntemplate <class T, class Op, class Inv> struct weighted_dsu {\n  const Op op;\n  const T e;\n  const Inv inv;\n  vector<int> p, sz;\n  vector<T> d;\n  weighted_dsu(int n, Op _op, T _e, Inv _inv) :\n    op(_op), e(_e), inv(_inv), p(n, -1), sz(n, 1), d(n, e) {}\n  pair<int, T> root(int v) const {\n    T a = e;\n    while (p[v] != -1) a = op(a, d[v]), v = p[v];\n    return {v, a};\n  }\n  void unite(int u, int v, T w) {\n    T du, dv;\n    tie(u, du) = root(u), tie(v, dv) = root(v);\n    assert(u != v);\n    if (sz[u] < sz[v]) swap(u, v), swap(du, dv), w = inv(w);\n    p[v] = u;\n    sz[u] += sz[v];\n    d[v] = op(op(du, w), inv(dv));\n  }\n  T diff(int u, int v) const {\n    T du, dv;\n    tie(u, du) = root(u), tie(v, dv) = root(v);\n    assert(u == v);\n    return op(dv, inv(du));\n  }\n  bool same(int u, int v) const { return root(u).first == root(v).first; }\n  int size(int v) const { return sz[root(v).first]; }\n};\ntemplate <class T, class Op, class Inv>\nauto make_weighted_dsu(int n, Op op, T e, Inv inv) {\n  return weighted_dsu<T, Op, Inv>(n, op, e, inv);\n}\n\nint main() {\n  int n = getint<int>();\n  int q = getint<int>();\n  auto wd = make_weighted_dsu(n, plus<int>(), 0, negate<int>());\n  while (q--) {\n    if (getint<int>() == 0) {\n      int u = getint<int>();\n      int v = getint<int>();\n      int w = getint<int>();\n      if (wd.same(u, v)) {\n        assert(wd.diff(u, v) == w);\n      } else {\n        wd.unite(u, v, w);\n      }\n    } else {\n      int u = getint<int>();\n      int v = getint<int>();\n      if (wd.same(u, v)) {\n        putint(wd.diff(u, v));\n      } else {\n        putchar('?');\n        putchar('\\n');\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\nclass Potential_Union_Find{\n  vector<int> par; vector<int> rank; vector<int> diff_weight;\npublic:\n  Potential_Union_Find(int n) {\n    par.assign(n,0); rank.assign(n,0); diff_weight.assign(n,0);\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    } else {\n      int r = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]];\n      return par[x] = r;\n    }\n  }\n  int weight(int x){\n    find(x);\n    return diff_weight[x];\n  }\n  void unite(int x, int y, int w){\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) swap(x,y), w = -w;\n    if(rank[x] == rank[y]) rank[x]++;\n    par[y] = x;\n    diff_weight[y] = w;\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  int diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  Potential_Union_Find puf(n);\n  rep(i,q) {\n    int t;\n    cin >> t;\n    if(t == 0) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      puf.unite(x,y,z);\n    } else {\n      int x, y;\n      cin >> x >> y;\n      if(puf.same(x,y)) cout << puf.diff(x,y) << endl;\n      else cout << \"?\" << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n参考にしたもの\n\nTにできるものはアーベル群(足し算と引き算ができる代数系)\nunitは単位元\n\nUnion-Find.cpp\nhttps://qiita.com/drken/items/cce6fc5c579051e64fab\n*/\n\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include<math.h>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\n\ntemplate<typename T>\nstruct WeightedUnionFind{\n    T unit;\n    vector<int> par;\n    vector<int> es;\n    vector<T> ws;\n    WeightedUnionFind(int N,T unit) : par(N,-1),es(N,0),ws(N,unit),unit(unit) {}\n    \n    //初期化\n    void init(int N){\n        par.assign(N,-1);\n        es.assign(N,0);\n        ws.assign(N,unit);\n    }\n    //rootを探す\n    int find(int x){\n        if(par[x]<0) return x;\n        else{\n            int r=find(par[x]); //先に圧縮\n            ws[x]+=ws[par[x]];\n            return par[x]=r;\n        } \n    }\n    //集合の要素数\n    int usize(int x) {return -par[find(x)];}\n    //集合の辺の数\n    int esize(int x) {return es[find(x)];}\n    //xのrootを0にしたときの重さ 最初に圧縮する\n    T weight(int x){find(x); return ws[x];}\n    //y-x\n    //これをやる前にsameで同じ集合にあるかを確認する\n    T diff(int x,int y){return weight(y)-weight(x);}\n\n    //weight(y)-weight(x)となるようにmergeする\n    //xとyがすでに繋がっていたらfalseを返す weightはそのまま\n    bool unite(int x,int y,T w){\n        w+=weight(x); w-=weight(y);\n        x=find(x);\n        y=find(y);\n        es[x]++;\n        if(x==y) return false;\n\n        if(usize(x)<usize(y)) swap(x,y),w=-w;\n        par[x]+=par[y];\n        es[x]+=es[y];\n        par[y]=x;\n        ws[y]=w;\n        return true;\n    }\n\n    bool same(int x,int y) {return find(x)==find(y);}\n\n};\n\nsigned main(void){\n    int n,q;\n    cin>>n>>q;\n    WeightedUnionFind<ll> uf(n,0LL);\n    while(q--){\n        int a;\n        cin>>a;\n        if(a==0){\n            int x,y,z;\n            cin>>x>>y>>z;\n            uf.unite(x,y,z);\n        }else{\n            int x,y;\n            cin>>x>>y;\n            if(uf.same(x,y)) cout<<uf.diff(x,y)<<endl;\n            else cout<<\"?\"<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvector<int> point;\nvector<int> Rank;\nvector<int> Cost;\n\n\nvoid CreateSet(int x);\nint Find(int x);\nvoid Relate(int x, int y, int z);\nvoid Diff(int x, int y);\nint main() {\n    int n,q;\n    int operation;\n    int x,y,z;\n    cin >> n >> q;\n\n    for (int i = 0; i < n; ++i) {\n        CreateSet(i);\n    }\n\n    for (int j = 0; j < q; ++j) {\n        cin >> operation >> x >> y;\n        if(operation == 0){\n            cin >> z;\n            Relate(x,y,z);\n        }else{\n            Diff(x,y);\n        }\n    }\n    return 0;\n}\nvoid CreateSet(int x){\n    point.push_back(x);\n    Rank.push_back(0);\n    Cost.push_back(0);\n}\nint Find(int x){\n    int prev = point[x];\n    if (x != point[x])\n    {\n        point[x] = Find(point[x]);\n    }\n    Cost[x] += Cost[prev];\n    return point[x];\n}\nvoid Relate(int x, int y, int z){\n    int rootX = Find(x);\n    int rootY = Find(y);\n    if(rootX == rootY){\n        // the same union\n        return;\n    }\n    z = z + Cost[x] - Cost[y];\n\n    if(Rank[rootY] > Rank[rootX]){\n        point[rootX] = rootY;\n        Cost[rootX] = -z;\n        if(Rank[rootX] == Rank[rootY]){\n            Rank[rootY] += 1;\n        }\n    }else{\n        point[rootY] = rootX;\n        Cost[rootY] = z;\n    }\n}\nvoid Diff(int x, int y){\n    if(Find(x) == Find(y)){\n        cout << Cost[y] - Cost[x] << endl;\n    }else{\n        cout << \"?\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//#define int long long\nusing lint=long long;\n\nstruct wUF{\n\tint n;\n\tvector<int>pr;\n\tvector<lint>df;\n\twUF(){};\n\twUF(int n_){\n\t\tn=n_;\n\t\tpr.resize(n,-1);\n\t\tdf.resize(n,0);\n\t};\n\tint root(int x){\n\t\tif(pr[x]<0)return x;\n\t\telse{\n\t\t\t int r=root(pr[x]);\n\t\t\tdf[x]+=df[pr[x]];\n\t\t\treturn pr[x]=r;\n\t\t}\n\t}\n\tvoid unify(int x,int y,lint w){\n\t\tw+=depth(x)-depth(y);\n\t\tx=root(x),y=root(y);\n\t\tif(x==y)return;\n\t\tif(size(x)<size(y)){swap(x,y);w=-w;}\n\t\tpr[x]+=pr[y];\n\t\tpr[y]=x;\n\t\tdf[y]=w;\n\t}\n\tint size(int x){return -pr[root(x)];}\n\tbool same(int x,int y){return root(x)==root(y);}\n\tlint depth(int x){root(x);return df[x];}\n\tlint dist(int x,int y){return depth(y)-depth(x);}\n};\n\nsigned main(){\n\tint n,q;cin>>n>>q;\n\twUF wuf(n);\n\twhile(q--){\n\t\tint c,x,y;\n\t\tlint z;\n\t\tcin>>c>>x>>y;\n\t\tif(c==0){ \n\t\t\tcin>>z;\n\t\t\twuf.unify(x,y,z);\n\t\t}else{\n\t\t\tif(!wuf.same(x,y))cout<<\"?\"<<endl;\n\t\t\telse cout<<wuf.dist(x,y)<<endl;\n\t\t}\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\n#define MAX_N 200000\n\nusing namespace std;\n\nint par[MAX_N];\nint rnk[MAX_N];\nlong long int diff[MAX_N];\n\n// 初期化\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tdiff[i] = 0;\n\t}\n}\n\n// x の親を返す\nP find(int x){\n\tP p;\n\tif(par[x] == x){\n\t\tp.first = x;\n\t\tp.second = 0;\n\t\treturn p;\n\t}\n\tp = find(par[x]);\n\tdiff[x] += p.second;\n\tp.second = diff[x];\n\tpar[x] = p.first;\n\treturn p;\n}\n\n// x と y を併合する\nvoid unite(int x, int y, int z){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\tif(x_par == y_par){\n\t\treturn;\n\t}\n\t\n\tif(rnk[x_par] < rnk[y_par]){\n\t\tpar[x_par] = y_par;\n\t\tdiff[x] = diff[y] + z;\n\t}else{\n\t\tpar[y_par] = x_par;\n\t\tdiff[y] = diff[x] - z;\n\t\tif(rnk[x_par] == rnk[y_par]){\n\t\t\trnk[x_par]++;\n\t\t}\n\t}\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y){\n\tP px = find(x);\n\tP py = find(y);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\treturn (x_par == y_par);\n}\n\nint main(){\n\t\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tinit(n);\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tint num, a, b, c;\n\t\tcin >> num >> a >> b;\n\t\tif(num == 0){\n\t\t\tcin >> c;\n\t\t\tunite(a, b, c);\n\t\t}else{\n\t\t\tif(!same(a, b)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << abs(diff[a] - diff[b]) << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << par[j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << diff[j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX\n\nusing namespace std;\n\n//vector<int> p, r;\nvector<int> p;\n\nvoid makeSet(int x){\n  p[x] = INF;\t\t\t\n  //  r[x] = 0;\n}\n\n//int findSet(int x){\n//  if(x != p[x])p[x] = findSet(p[x]);\n//  return p[x];\n//}\n// \n//void link(int x, int y){\n//  if(r[x] > r[y]) p[y] = x;\n//  else {\n//    p[x] = y;\n//    if(r[x] == r[y]) r[y] = r[y] + 1;\n//  }\n//}\n\n\n\n//void unite(int x, int y){\n//  link(findSet(x), findSet(y));\n//}\nvoid relate(int x, int y, int z){\n  if(p[y]==INF && p[x]==INF){\n    p[y] = z;\n    p[x] = p[y] - z;\n  }\n  else if(p[y]==INF && p[x]!=INF) p[y] = p[x] + z;\n  else if(p[y]!=INF && p[x]==INF) p[x] = p[y] - z;\n\n  // cout << x << p[x] << endl;\n  // cout << y << p[y] << endl;\n\n}\n\n\nvoid diff(int x, int y){\n\n  if(p[x]==INF || p[y]==INF) cout << '?' << endl;\n  else if(p[x]!=INF && p[y]!=INF) cout << p[y] - p[x] << endl;\n\n}\n\n\nint main(){\n\n  int N, Q, com, x, y, z, i;\n\n  cin >> N >> Q;\n\n  p.resize(N);\n  //  r.resize(N);\n\n  for(i=0; i<N; i++) makeSet(i);\n\n  for(i=0; i<Q; i++){\n    cin >> com;\n    if(com == 0){\n      cin >> x >> y >> z;\n      relate(x, y, z);\n    }\n    else if(com == 1){\n      cin >> x >> y;\n      diff(x, y);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <unordered_set>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<ll> > vvll;\ntypedef map<int, int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define itn int\n#define endl '\\n';\n#define fi first\n#define se second\n#define NONVOID [[nodiscard]]\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\n\nclass UnionFind {\npublic:\n    // 親の番号を格納．親だった場合は-(その集合のサイズ)\n    vector<int> Parent;\n    // 重さの差を格納\n    vector<ll> diffWeight;\n\n    UnionFind(const int N) {\n        Parent = vector<int>(N, -1);\n        diffWeight = vector<ll>(N, 0);\n    }\n\n    // Aがどのグループに属しているか調べる\n    int root(const int A) {\n        if (Parent[A] < 0) return A;\n        int Root = root(Parent[A]);\n        diffWeight[A] += diffWeight[Parent[A]];\n        return Parent[A] = Root;\n    }\n\n    // 自分のいるグループの頂点数を調べる\n    int size(const int A) {\n        return -Parent[root(A)];\n    }\n\n    // 自分の重さを調べる\n    ll weight(const int A) {\n        root(A); // 経路圧縮\n        return diffWeight[A];\n    }\n\n    // 重さの差を計算する\n    ll diff(const int A, const int B) {\n        return weight(B) - weight(A);\n    }\n\n    // AとBをくっ付ける\n    bool connect(int A, int B, ll W = 0) {\n        // Wをrootとの重み差分に変更\n        W += weight(A);\n        W -= weight(B);\n\n        // AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n\n        // 大きい方(A)に小さいほう(B)をくっ付ける\n        // 大小が逆だったらひっくり返す\n        if (size(A) < size(B)) {\n            swap(A, B);\n            W = -W;\n        }\n\n        // Aのサイズを更新する\n        Parent[A] += Parent[B];\n        // Bの親をAに変更する\n        Parent[B] = A;\n\n        // AはBの親であることが確定しているのでBにWの重みを充てる\n        diffWeight[B] = W;\n\n        return true;\n    }\n};\n\nint main() {\n    \n    int n,Q;\n    cin>>n>>Q;\n    UnionFind uni(n);\n\n    bool weight = 1;\n\n    if(!weight) {\n        // 普通のUnionFind\n        rep(i,Q){\n            int s,x,y;\n            cin>>s>>x>>y;\n            if(s==0){\n                uni.connect(x,y);\n            } else {\n                fin(uni.root(x)==uni.root(y));\n            }\n        }\n    } else {\n        // 重みつきUnionFind\n        rep(i,Q) {\n            ll q,x,y,z;\n            cin>>q>>x>>y;\n            if(!q){\n                cin>>z;\n                uni.connect(x,y,z);\n            } else {\n                if(uni.root(x)!=uni.root(y))fin('?');\n                else cout << uni.diff(x,y) << endl;\n            }\n        }\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n\n/// ユニオンファインド森。ユニオンファインドが必要な問題が解ける。\nstruct UnionFindForest\n{\n\tvector<pair<int,int>> p;\n\tUnionFindForest(int n) : p(n, { -1, 0 }) { }\n\tpair<int, int> root(int i)\n\t{\n\t\tif (p[i].first < 0) { return { i, 0 }; }\n\t\tauto pw = root(p[i].first);\n\t\treturn p[i] = { pw.first, pw.second + p[i].second };\n\t}\n\tint rootOf(int i) { return root(i).first; }\n\tint weightOf(int i) { return root(i).second; }\n\tint countOf(int i) { return -root(i).first; }\n\n\tbool linked(int a, int b) { return rootOf(a) == rootOf(b); }\n\tbool link(int a, int b, int d)\n\t{\n\t\tint x = rootOf(a), y = rootOf(b);\n\t\tif (x != y)\n\t\t{\n\t\t\tp[x].first += p[y].first;\n\t\t\tp[y].first = x;\n\t\t\tp[y].second = p[a].second + d - p[b].second;\n\t\t}\n\t\treturn x != y;\n\t}\n\n\tint diff(int a, int b) { return weightOf(b) - weightOf(a); }\n};\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tUnionFindForest forest(n);\n\tREP(i, q)\n\t{\n\t\tREAD(int, com, x, y);\n\t\tif (com == 0)\n\t\t{\n\t\t\tREAD(int, z);\n\t\t\tforest.link(x, y, z);\n\t\t}\n\t\tif (com == 1)\n\t\t{\n\t\t\tif (forest.linked(x,y))\n\t\t\t{\n\t\t\t\tWRITE(forest.diff(x, y));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWRITE('?');\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\nusing namespace std;\nconst int N=1e5+10;\nint p[N],val[N];\nstack<int>s[N];\nint find(int n){\n    if(p[n]==n)return n;\n    return p[n]=find(p[n]);\n}\nint main(){\n    int n,q,l,r,temp,a,b;\n    scanf(\"%d%d\",&n,&q);\n    for(int i=0;i<n;i++){\n        p[i]=i;\n        val[i]=0;\n        s[i].push(i);\n    }\n    while(q--){\n        scanf(\"%d%d%d\",&temp,&l,&r);\n        if(temp==1){\n            if(find(l)!=find(r))printf(\"?\\n\");\n            else printf(\"%d\\n\",val[r]-val[l]);\n        }\n        else{\n            scanf(\"%d\",&temp);\n            a=find(l);\n            b=find(r);\n            if(s[a].size()>s[b].size()){\n                p[b]=a;\n                temp+=val[l]-val[r];\n                while(!s[b].empty()){\n                    val[s[b].top()]+=temp;\n                    s[a].push(s[b].top());\n                    s[b].pop();\n                }\n            }\n            else{\n                p[a]=b;\n                temp=val[r]-temp-val[l];\n                while(!s[a].empty()){\n                    val[s[a].top()]+=temp;\n                    s[b].push(s[a].top());\n                    s[a].pop();\n                }\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n// int main() {\n//     cin.tie(0);\n//     ios::sync_with_stdio(false);\n//     cout << fixed << setprecision(10);\n//\n// }\ntemplate<typename A>\nstruct WeightedUnionFind\n{\n    vector<int> par, sz;\n    vector<A> data; // data[x]: diff from root to x\n    WeightedUnionFind(int n, A e=0) :\n        par(n), sz(n, 1), data(n, e) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        int r = root(par[x]);\n        data[x] += data[par[x]];\n        return par[x] = r;\n    }\n    A weight(int x) {\n        root(x);\n        return data[x];\n    }\n    A diff(int x, int y) {\n        // diff from x to y\n        return data[y] - data[x];\n    }\n    void merge(int x, int y, A w) {\n        // merge so that \"diff from x to y\" will be w.\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y), w = -w;\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n        data[y] = w;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n};\nint main() {\n    int N, M;\n    cin >> N >> M;\n    WeightedUnionFind<int> uf(N);\n    while (M--) {\n        int A, B, C, D;\n        cin >> A >> B >> C;\n        if (A == 0) {\n            cin >> D;\n            uf.merge(B, C, D);\n        } else {\n            if (uf.root(B) == uf.root(C)) {\n                cout << uf.diff(B, C) << endl;\n            } else {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//重み付きUnion-Find木\n//参考 https://qiita.com/drken/items/cce6fc5c579051e64fab\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_B\n\n#include<iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX_N 500000//頂点の最大数\n\nll par[MAX_N];//親の番号\nll urank[MAX_N];//集合のランク\nll usize[MAX_N];//集合の要素数\nll diff_weight[MAX_N];//親との距離\nll num;//集合の数\n\nvoid init(ll n) {//初期化\n    num = n;\n    rep(i,n) {\n        par[i] = i;\n        urank[i] = 0;\n        usize[i] = 1;\n        diff_weight[i] = 0;\n    }\n}\n\nll find(ll x) {//根の添字を返すと同時に経路圧縮をする\n    if(par[x] == x) {\n        return x;\n    }else {\n        ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];//累積和\n        return par[x] = r;\n    }\n}\n\nbool same(ll x,ll y) {\n    return find(x) == find(y);\n}\n\nll weight(ll x) {//親との距離を求める\n    find(x);\n    return diff_weight[x];\n}\n\nll diff(ll x,ll y) {//xからyに行くときのポテンシャルの増加分\n    if(!same(x,y)) {\n        return -1;\n    }\n    return weight(y) - weight(x);\n}\n\nll get_usize(ll x) {//xが属する集合の要素数を返す。\n    return usize[find(x)];\n}\n\nbool unite(ll x,ll y,ll w) {//weight(y) = weight(x) + w (diff(x,y) = w) となるようにxの属する集合とyの属する集合をマージ\n    if(urank[x] < urank[y]) swap(x,y);//x(のroot)の下にy(のroot)をつけるので反転\n\n    w += weight(x);w -= weight(y);\n    //x(のroot)の下にy(のroot)をつけるので、w=diff(xのroot,yのroot)となるように\n\n    x = find(x);y = find(y);\n\n    if(x == y) {\n        return diff(x,y) == w;\n    }\n\n    //x(のroot)の下にy(のroot)をつける。\n    if(urank[x] == urank[y]) urank[x]++;\n    par[y] = x;\n\n    diff_weight[y] = w;\n\n    return true;\n}\n\nll num_set() {\n    return num;\n}\n\nll n,q;\nint main() {\n    cin >> n >> q;\n    init(n);\n\n    rep(i,q) {\n        ll c,x,y,z;\n\n        cin >> c;\n        if(c) {\n            cin >> x >> y;\n            ll d = diff(x,y);\n            if(d >= 0) cout << d << endl;\n            else cout << '?' << endl;\n        }else {\n            cin >> x >> y >> z;\n            unite(x,y,z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class Abel>\nclass UnionFind{\n    vector<int> par_, weight_;\npublic:\n    UnionFind(size_t n){\n        par_.assign(n, -1);\n        weight_.assign(n, 0);\n    }\n\n    int root(int x){\n        if (par_[x] < 0) {\n            return x;\n        }else{\n            int res = root(par_[x]);\n            weight_[x] += weight_[par_[x]];\n            return par_[x] = res;\n        }\n    }\n\n    int weight(int x){\n        root(x);\n        return weight_[x];\n    }\n\n    int weight(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n    int size(int x){\n        return -par_[root(x)];\n    }\n\n    bool IsSame(int x, int y){\n        return root(x) == root(y);\n    }\n\n    void Merge(int x, int y, Abel w){\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (IsSame(x, y))\n            return;\n        if (size(x) < size(y)) {\n            w = -w;\n            swap(x, y);\n        }\n        par_[x] += par_[y];\n        par_[y] = x;\n        weight_[y] = w;\n    }\n};\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    UnionFind<int> uf(n);\n    for (int i = 0; i < m; i++) {\n        int q, l, r, d;\n        cin >> q;\n        if (q == 0) {\n            cin >> l >> r >> d;\n            uf.Merge(l, r, d);\n        }else{\n            cin >> l >> r;\n            cout << ((uf.IsSame(l, r)) ? to_string(uf.weight(l, r)) : \"?\") << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(st, itr) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nstruct WeightedUnionFind_{\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<T> diff_weight;\n  WeightedUnionFind_(int n, T def=0): n(n){\n    par.resize(n);\n    rank.resize(n);\n    diff_weight.resize(n);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n      diff_weight[i] = def;\n    }\n  }\n  int find(int x){\n    if(par[x] == x)return x;\n    int r = find(par[x]);\n    diff_weight[x] += diff_weight[par[x]];\n    return par[x] = r;\n  }\n  T weight(int x){\n    find(x);\n    return diff_weight[x];\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y, T w){\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if(x == y)return false;\n    if(rank[x] < rank[y])swap(x, y), w = - w;\n    if(rank[x] == rank[y])rank[x]++;\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n  T diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nusing WeightedUnionFind = WeightedUnionFind_<int>;\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind_<ll> wuf(n);\n  rep(i, q){\n    int c;\n    cin >> c;\n    if(c == 0){\n      int x, y, z;\n      cin >> x >> y >> z;\n      wuf.unite(x, y, z);\n    }else{\n      int x, y;\n      cin >> x >> y;\n      if(wuf.same(x, y))cout << wuf.diff(x, y) << endl;\n      else cout << '?' << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"main.cpp\"\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <utility>\n#include <limits>\n#include <list>\n#line 29 \"main.cpp\"\n\n/* template start */\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n\nusing ll=long long;\n\n#line 2 \"/mnt/c/Users/Imperi/Documents/cp-library/lib/PotentialUnionFind.cpp\"\n\n#line 6 \"/mnt/c/Users/Imperi/Documents/cp-library/lib/PotentialUnionFind.cpp\"\n\ntemplate<typename Group>\nclass PotentialUnionFind{\n  public:\n  using value_t=typename Group::value_t;\n  using size_t=std::size_t;\n  private:\n  size_t group;\n  std::vector<size_t> par,sz;\n  std::vector<value_t> df; //val[par]=val[x]+df[x]\n\n  value_t fold_to_root(size_t x){\n    value_t ret=Group::id;\n    while(par[x]!=x){\n      df[x]=Group::op(df[x],df[par[x]]);\n      par[x]=par[par[x]];\n      ret=Group::op(ret,df[x]);\n      x=par[x];\n    }\n    return ret;\n  }\n\n  public:\n  PotentialUnionFind(size_t n=0):group(n),par(n),sz(n,1),df(n,Group::id){\n    std::iota(par.begin(),par.end(),0);\n  }\n\n  size_t root(size_t x){\n    while(par[x]!=x){\n      df[x]=Group::op(df[x],df[par[x]]);\n      par[x]=par[par[x]];\n      x=par[x];\n    }\n    return x;\n  }\n\n  bool same(size_t a,size_t b){return root(a)==root(b);}\n  size_t size(){return par.size();}\n  size_t groups(){return group;}\n  size_t group_size(size_t x){return sz[root(x)];}\n\n  // unite A=B+value\n  bool unite(size_t a,size_t b,value_t value){\n    size_t aroot=root(a),broot=root(b);\n    if(aroot==broot)return false;\n    group--;\n    if(sz[aroot]<sz[broot]){\n      std::swap(aroot,broot);\n      std::swap(a,b);\n      value=Group::inv(value);\n    }\n    sz[aroot]+=sz[broot];\n    value=Group::op(value,fold_to_root(a));\n    value=Group::op(Group::inv(fold_to_root(b)),value);\n    df[broot]=value;\n    par[broot]=aroot;\n    return true;\n  }\n\n  // return diff  such as A=B+diff\n  value_t diff(size_t a,size_t b){\n    assert(same(a,b));\n    return Group::op(fold_to_root(b),Group::inv(fold_to_root(a)));\n  }\n};\n#line 38 \"main.cpp\"\n\nstruct Group{\n  using value_t=ll;\n  static constexpr value_t id=0;\n  static constexpr value_t op(value_t a,value_t b){\n    return a+b;\n  }\n  static constexpr value_t inv(value_t a){return -a;}\n};\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n,q;\n  std::cin>>n>>q;\n\n  PotentialUnionFind<Group> uni(n);\n\n  while(q--){\n    ll mode;\n    std::cin>>mode;\n    if(mode==0){\n      ll x,y,z;\n      std::cin>>x>>y>>z;\n      if(!uni.same(x,y))uni.unite(y,x,z);\n    }else{\n      ll x,y;\n      std::cin>>x>>y;\n      if(!uni.same(x,y))std::cout<<\"?\\n\";\n      else std::cout<<uni.diff(y,x)<<\"\\n\";\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii; typedef vector<int> vi;\ntypedef long long ll; typedef vector<long long> vll;\nconst int MOD = 1'000'000'007, MOD2 = 1'000'000'009;\nconst int INF = 0x3f3f3f3f; const ll BINF = 0x3f3f3f3f3f3f3f3fLL;\n\nstruct DSU {\n\tint n;\n\tvector<int> p;\n\tDSU(int sz) : n(sz), p(sz) {\n\t\tiota(p.begin(), p.end(), 0);\n\t}\n\tint fi(int x) {return p[x] = p[x] - x ? fi(p[x]) : x;}\n\tinline void un(int u, int v) {p[fi(u)] = p[fi(v)];}\n};\n\nint solve() {\n\tint n, m; cin >> n >> m;\n\tvi op(m), x(m), y(m), z(m);\n\tvector<vector<pii>> g(n);\n\tfor (int i=0;i<m;i++) {\n\t\tcin >> op[i];\n\t\tif (op[i] == 0) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\tg[x[i]].emplace_back(y[i], z[i]);\n\t\t\tg[y[i]].emplace_back(x[i], -z[i]);\n\t\t} else {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t}\n\tvi val(n), vis(n);\n\tconst function<void(int)> dfs = [&g, &val, &vis, &dfs](int u) {\n\t\tfor (auto p : g[u]) {\n\t\t\tint v = p.first;\n\t\t\tif (!vis[v]) {\n\t\t\t\tval[v] = val[u] + p.second;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int i=0;i<n;i++) if (!vis[i]) {\n\t\tval[i] = 0;\n\t\tdfs(i);\n\t}\n\tDSU dsu(n);\n\tfor (int i=0;i<m;i++) {\n\t\tint gx = dsu.fi(x[i]), gy = dsu.fi(y[i]);\n\t\tif (op[i] == 0) {\n\t\t\tif (gx != gy) dsu.un(gx, gy);\n\t\t} else {\n\t\t\tif (gx == gy)\n\t\t\t\tcout << val[y[i]] - val[x[i]] << endl;\n\t\t\telse\n\t\t\t\tcout << '?' << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << (solve() ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass weighted_union_find_tree {\nprivate:\n    size_t *par;\n    ll *dist;\n\npublic:\n    weighted_union_find_tree(size_t n) {\n        par = new size_t[n];\n        dist = new ll[n];\n        for (size_t i = 0; i < n; ++i) {\n            par[i] = i;\n            dist[i] = 0;\n        }\n    }\n\n    ~weighted_union_find_tree() {\n        delete [] par;\n        delete [] dist;\n    }\n\n    size_t find(size_t x) {\n        if (par[x] == x) {\n            return x;\n        }\n        int old_par_x = par[x];\n        ll old_dist_par_x = dist[par[x]];\n        int old_dist_x = dist[x];\n        par[x] = find(par[x]);\n        //printf(\"par[%d] is updated from %d to %d\\n\", x, old_par_x, par[x]);\n        dist[x] += dist[old_par_x]; \n        //printf(\"dist[%d] is updated from %lld to %lld\\n\", x, old_dist_x, dist[x]);\n        return par[x];\n    }\n\n    void relation(size_t x, size_t y, ll d) {\n        if (find(x) == find(y)) {\n            if (dist[y] - dist[x] != d) {\n                cerr << \"contradiction\" << endl;\n                cerr << \"a[\" << y << \"] - a[\" << x << \"] must be \" << dist[y] - dist[x] << \" from previous information.\" << endl;\n                cerr << \"But new information says that it is \" << d << \".\" <<  endl; \n            }\n        } else {\n            if (dist[x] + d > dist[y]) {\n                int old_par_y = par[y];\n                int old_par_par_y = par[par[y]];\n                par[par[y]] = par[x];\n                //printf(\"par[%d] is updated from %d to %d\\n\", old_par_y, old_par_par_y, par[par[y]]);\n                ll old_dist_old_par_y = dist[old_par_y];\n                dist[old_par_y] = dist[x] + d - dist[y];\n                //printf(\"dist[%d] is updated from %lld to %lld\\n\", old_par_y, old_dist_old_par_y, dist[old_par_y]);\n            } else {\n                int old_par_x = par[x];\n                int old_par_par_x = par[par[x]];\n                par[par[x]] = par[y];\n                //printf(\"par[%d] is updated from %d to %d\\n\", old_par_x, old_par_par_x, par[par[x]]);\n                ll old_dist_old_par_x = dist[old_par_x];\n                dist[old_par_x] = dist[y] - d - dist[x];\n                //printf(\"dist[%d] is updated from %lld to %lld\\n\", old_par_x, old_dist_old_par_x, dist[old_par_x]);\n            }\n        }\n    }\n\n    ll difference(size_t x, size_t y) {\n        //printf(\"difference(%d, %d)\\n\", x, y);\n        if (find(x) != find(y)) {\n            // no relation\n            return LLONG_MAX;\n        }\n        //printf(\"par[x] = %d, dist[x] = %d\\n\", par[x], dist[x]);\n        //printf(\"par[y] = %d, dist[y] = %d\\n\", par[y], dist[y]);\n        return dist[y] - dist[x];\n    }\n};\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    weighted_union_find_tree t(n);\n    REP(_, q) {\n        int query_type;\n        cin >> query_type;\n        if (query_type == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            //printf(\"relation query %d %d %d\\n\", x, y, z);\n            t.relation(x, y, z);\n        } else if (query_type == 1) {\n            int x, y;\n            cin >> x >> y;\n            //printf(\"difference query %d %d\\n\", x, y);\n            ll d = t.difference(x, y);\n            if (d != LLONG_MAX) {\n                cout << d << '\\n';\n            } else {\n                cout << \"?\\n\";\n            }\n        }\n        //cout << endl;\n    }\n    cout << flush;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\n// clang-format on\n\ntemplate<typename CommutativeGroup> class WeightedUnionFind {\n  using T = typename CommutativeGroup::value_type;\n  CommutativeGroup g;\n\n  vector<int> tree, rank;\n  vector<T> diffWeight;\n\npublic:\n  WeightedUnionFind(const int &n) : tree(n), rank(n), diffWeight(n, g.id()) { iota(all(tree), 0); }\n\n  int root(const int &x) {\n    if (tree[x] == x) {\n      return x;\n    } else {\n      int r = root(tree[x]);\n      diffWeight[x] += diffWeight[tree[x]];\n      return tree[x] = r;\n    }\n  }\n\n  T weight(const int &x) {\n    root(x);\n    return diffWeight[x];\n  }\n\n  bool same(const int &a, const int &b) { return root(a) == root(b); }\n\n  bool unite(int a, int b, T w) {\n    w = g(w, g(weight(a), g.inv(weight(b))));\n    a = root(a), b = root(b);\n    if (a == b) return false;\n    if (rank[a] < rank[b]) swap(a, b), w = g.inv(w);\n    tree[b] = a;\n    diffWeight[b] = w;\n    if (rank[a] == rank[b]) ++rank[a];\n    return true;\n  }\n\n  T diff(int x, int y) { return g(weight(y), g.inv(weight(x))); }\n};\n\ntemplate<typename T> struct sumGroup {\n  using value_type = T;\n  constexpr value_type id() { return 0; }\n  constexpr value_type operator()(const value_type &a, const value_type &b) { return a + b; }\n  constexpr value_type inv(const value_type &x) { return -x; }\n};\n\nint main() {\n  int n = in();\n  int q = in();\n  WeightedUnionFind<sumGroup<int>> wuf(n);\n  while (q--) {\n    int c = in();\n    if (c) {\n      int x = in();\n      int y = in();\n      if (wuf.same(x, y)) {\n        cout << wuf.diff(x, y) << endl;\n      } else {\n        cout << '?' << endl;\n      }\n    } else {\n      int x, y, z;\n      cin >> x >> y >> z;\n      wuf.unite(x, y, z);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct WeightUnionFind{\n\t//\n\tvector<int> ran,par,wei;\n\t//\n\tWeightUnionFind(int n=1){\n\t\tinit(n);\n\t}\n\t//\n\tvoid init(int n=1){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar.push_back(i);\n\t\t\tran.push_back(0);\n\t\t\twei.push_back(0);\n\t\t}\n\t}\n\t//\n\tint find(int x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint r=find(par[x]);\n\t\t\twei[x]+=wei[par[x]];\n\t\t\treturn par[x]=r;\n\t\t}\n\t}\n\t//\n\tint weight(int x){\n\t\tfind(x);\n\t\treturn wei[x];\n\t}\n\t//\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\t//\n\tbool unite(int x,int y,int w){\n\t\tw+=weight(x);\n\t\tw-=weight(y);\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y){\n\t\t\treturn false;\n\t\t}else if(ran[x]<ran[y]){\n\t\t\tswap(x,y);\n\t\t\tw=-w;\n\t\t}else if(ran[x]==ran[y]){\n\t\t\tran[x]++;\n\t\t}\n\t\tpar[y]=x;\n\t\twei[y]=w;\n\t\treturn true;\n\t}\n\t//\n\tint diff(int x,int y){\n\t\treturn weight(y)-weight(x);\n\t}\n\t//\n};\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tWeightUnionFind UF(N);\n\twhile(Q--){\n\t\tint C;\n\t\tcin>>C;\n\t\tif(C==1){\n\t\t\tint X,Y;\n\t\t\tcin>>X>>Y;\n\t\t\tif(UF.same(X,Y)){\n\t\t\t\tcout<<UF.diff(X,Y)<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\tint X,Y,Z;\n\t\t\tcin>>X>>Y>>Z;\n\t\t\tUF.unite(X,Y,Z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n\nclass union_find\n{\n\tint  _setnum;\n\tvector<int> par, nume, diff_weight;\npublic:\n\tunion_find(){\n\t}\n\t\n\tunion_find(int x){\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tdiff_weight.resize(x);\n\t\tinit();\n\t}\n\t\n\t~union_find(){\n\t\t//\n\t\t\n\t}\n\t\n\tvoid clear(){\n\t\t_setnum = 0;\n\t\tpar.clear();\n\t\tnume.clear();\n\t\tdiff_weight.clear();\n\t}\n\t\n\tvoid init(){\n\t\t_setnum = par.size();\n\t\tfor(int i = 0; i < par.size(); i++){\n\t\t\tpar[i] = i;\n\t\t\tnume[i] = 1;\n\t\t\tdiff_weight[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid resize(int x){\n\t\t\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tdiff_weight.resize(x);\n\t\tinit();\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) {\n\t\t\t\treturn x;\n\t\t} else {\n\t\t\tint p = find(par[x]);\n\t\t\t\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\t\n\t\t\treturn par[x] = p;\n\t\t}\n\t}\n\t\n\t// weight(y) - weight(x) = w\n\tvoid unite(int x, int y, int w){\n\t\t\n\t\tw = -w;\n\t\t\n\t\tw -= weight(x);\n\t\tw += weight(y);\n\t\t\n\t\tx = find(x);\n\t\ty = find(y);\n\t\n\t\tif(x == y)return;\n\t\t\n\t\t_setnum--;\n\t\t\n\t\tif(nume[x] > nume[y]) std::swap(x,y), w = -w;\n\t\t\n\t\tpar[x] = y;\n\t\t\n\t\tnume[y] += nume[x];\n\t\t\n\t\tdiff_weight[x] = w;\n\t}\n\t\n\tint weight(int x){\n\t\tfind(x);\n\t\t\n\t\treturn diff_weight[x];\n\t}\n\t\n\t// find(x) == find(y)\n\tint diff(int x, int y){\n\t\treturn weight(y) - weight(x);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tint numel(int x){\n\t\treturn nume[find(x)];\n\t}\n\t\n\tint size(){\n\t\treturn par.size();\n\t}\n\t\n\tint setnum(){\n\t\treturn _setnum;\n\t}\n};\n\nsigned main(){\n\t\n\tint n, q;\n\tunion_find uf;\n\t\n\tcin>>n>>q;\n\t\n\tuf.resize(n);\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tint num, x, y, z;\n\t\t\n\t\tcin>>num;\n\t\t\n\t\tif(num == 0) {\n\t\t\tcin>>x>>y>>z;\n\t\t\t\n\t\t\tuf.unite(x, y, z);\n\t\t\t\n\t\t} else if(num == 1) {\n\t\t\tcin>>x>>y;\n\t\t\t\n\t\t\tif(uf.same(x, y)) {\n\t\t\t\tcout<<uf.diff(x, y)<<endl;\n\t\t\t} else {\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n\ntemplate<class T>\nstruct potentialized_union_find {\n    using value_type = T;\n    using size_type = std::size_t;\nprivate :\n    size_type _size;\n    std::vector<int> node;\n    std::vector<value_type> potential;\n\npublic :\n    potentialized_union_find (size_type n, const value_type &ie) : \n        _size(n), node(n, -1), potential(n, ie) { }\n\n    size_type root (size_type x) {\n        if (node[x] < 0) return x;\n        int r = root(node[x]);\n        potential[x] += potential[node[x]];\n        return (node[x] = r);\n    }\n\n    value_type weight (size_type x) {\n        root(x);\n        return (potential[x]);\n    }\n\n    bool unite (size_type x, size_type y, value_type p) {\n        p += (weight(x) - weight(y));\n        if ((x = root(x)) == (y = root(y))) return false;\n        if (node[x] > node[y]) {\n            std::swap(x, y);\n            p = -p;\n        }\n        node[x] += node[y];\n        node[y] = x;\n        potential[y] = p;\n        _size--;\n        return true;\n    }\n\n    bool same (size_type x, size_type y) {\n        return (root(x) == root(y));\n    }\n\n    value_type diff (size_type x, size_type y) {\n        assert(same(x, y));\n        return (weight(y) - weight(x));\n    }\n\n    const size_type& size () const noexcept {\n        return (_size);\n    }\n\n    size_type size (size_type x) {\n        return (size_type(-node[root(x)]));\n    }\n\n};\n\n\n#include <iostream>\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\n    std::size_t n;\n    int query;\n    std::cin >> n >> query;\n\n    potentialized_union_find<int> uf(n, 0);\n\n    while (query--) {\n        int type;\n        std::cin >> type;\n        if (type == 0) {\n            std::size_t x, y;\n            int p;\n            std::cin >> x >> y >> p;\n            uf.unite(x, y, p);\n        } else {\n            std::size_t x, y;\n            std::cin >> x >> y;\n            if (uf.same(x, y)) {\n                std::cout << uf.diff(x,y) << '\\n';\n            } else {\n                std::cout << '?' << '\\n';\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> struct WeightedUnionFind {\n    int sz;\n    vector<int> data;\n    vector<T> potential;\n\n    WeightedUnionFind (int sz, T id = 0)\n        : sz(sz), data(sz, -1), potential(sz, id) { }\n\n    // potential[y] = potential[x] + w\n    bool unite (int x, int y, T w) {\n        w += (weight(x) - weight(y));\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (data[x] > data[y]) { swap(x, y); w = -w; }\n        data[x] += data[y];\n        data[y] = x;\n        potential[y]= w;\n        sz--;\n        return true;\n    }\n\n    bool is_same (int x, int y) { return root(x) == root(y); }\n\n    int root (int x) {\n        if (data[x] < 0) return x;\n        int r = root(data[x]);\n        potential[x] += potential[data[x]];\n        return data[x] = r;\n    }\n\n    T weight (int x) { root(x); return potential[x]; }\n\n    T diff (int x, int y) { return weight(y) - weight(x); }\n\n    size_t size () { return (size_t)sz; }\n\n    size_t size (int x) { return (size_t)-data[root(x)]; }\n\n};\n\n\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind<int> uf(n);\n    \n    while (q--) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int x, y, w;\n            cin >> x >> y >> w;\n            uf.unite(y, x, w);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (uf.is_same(x, y)) {\n                cout << uf.diff(y, x) << '\\n';\n            } else {\n                cout << '?' << '\\n';\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n \nvector<int> p,rank,cost;\n \nvoid makeSet(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n \nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n \nvoid relate(int x, int y, int z) {\n    int rootx = findSet(x), rooty = findSet(y);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n \nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct set_type{\n\tint parent;\n\tint dif_with_parent;\n};\n\nset_type find(set_type subsets[], int i){\n\tif(subsets[i].parent != i){\n\t\tset_type parent_set = find(subsets, subsets[i].parent);\n\t\tsubsets[i].dif_with_parent += parent_set.dif_with_parent;\n\t\tsubsets[i].parent = parent_set.parent;\n\t}\n\treturn subsets[i];\n}\n\nvoid unite(set_type subsets[], int x, int y, int dif){\n\tset_type xroot = find(subsets, x);\n\tset_type yroot = find(subsets, y);\n\tint root_dif = subsets[y].dif_with_parent - subsets[x].dif_with_parent + dif; // difference between yroot - xroot\n\tif(root_dif > 0){\n\t\t// yroot will be parent of xroot\n\t\tsubsets[subsets[x].parent].dif_with_parent = root_dif;\n\t\tsubsets[subsets[x].parent].parent = subsets[y].parent;\n\t}else{\n\t\t// xroot will be parent of yroot\n\t\tsubsets[subsets[y].parent].dif_with_parent = -root_dif; \n\t\tsubsets[subsets[y].parent].parent = subsets[x].parent;\n\t}\n}\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tset_type subsets[n];\n\tfor(auto i = 0; i < n; ++i) subsets[i] = {i, 0};\n\tfor(auto i = 0; i < q; ++i){\n\t\tint cmd_type;\n\t\tcin >> cmd_type;\n\t\tif(cmd_type == 0){\n\t\t\tint x, y, dif;\n\t\t\tcin >> x >> y >> dif;\n\t\t\tunite(subsets, x, y, dif);\n\t\t}else if(cmd_type == 1){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfind(subsets, x);\n\t\t\tfind(subsets, y);\n\t\t\tif(subsets[x].parent != subsets[y].parent){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << subsets[x].dif_with_parent - subsets[y].dif_with_parent << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a) for(int i=0; i<int(a); i++)\n#define ALL(x) begin(x), end(x)\n#define VI vector<int>\nusing namespace std;\ntypedef long long LL;\n\nconst int MAX_N=100005;\n\nstruct WeightedUnionFind {\n    int n;\n    int INF = 1e9;\n    vector<int> par, sz, weight;\n\n    WeightedUnionFind() {}\n    WeightedUnionFind(int n_) : n(n_), par(n_, 0), sz(n_, 1), weight(n_, 0) { iota(begin(par), end(par), 0); }\n\n    int find(int x) { \n        if(x==par[x]) return x;\n        int y = find(par[x]);\n        weight[x]+=weight[par[x]];\n        return par[x]=y;\n    }\n\n    void unite(int x, int y, int w) {\n        int px = find(x);\n        int py = find(y);\n        if(px == py) return;\n        if(sz[px] < sz[py]) {\n            swap(px, py);\n            swap(x, y);\n            w = -w;\n        }\n        sz[px] += sz[py];\n        par[py] = px;\n        weight[py] = weight[x] - w - weight[y];            \n    }\n\n    int same(int x, int y) { return find(x) == find(y); }\n\n    int diff(int x, int y) { // x -> y\n        if(same(x, y)) return weight[x]-weight[y];\n        return INF;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind wuf(n);\n\n    while(q--) {\n        int op;\n        cin >> op;\n        if(op == 0) {\n            int x, y, w;\n            cin >> x >> y >> w;\n            wuf.unite(x, y, w);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            int ans = wuf.diff(x,y);\n            if(ans < wuf.INF) cout << ans << endl;\n            else cout << '?' << endl;\n        }\n    }\n\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstddef>\n#include <utility>\n#include <vector>\n\n\ntemplate <class Abelian> class PotentializedUnionFind {\n\npublic:\n\tusing value_type = Abelian;\n\tusing difference_type = std::ptrdiff_t;\n\tusing container_type = std::vector<std::pair<difference_type, value_type>>;\n\tusing const_reference = const value_type &;\n\tusing size_type = typename container_type::size_type;\n\nprotected:\n\tcontainer_type c;\n\nprivate:\n\tvalue_type potential(size_type x) {\n\t\tvalue_type ret = {};\n\t\twhile (c[x].first >= static_cast<difference_type>(0)) {\n\t\t\tif (c[static_cast<size_type>(c[x].first)].first >=\n\t\t\t\tstatic_cast<difference_type>(0)) {\n\t\t\t\tc[x].second =\n\t\t\t\t\tc[static_cast<size_type>(c[x].first)].second + c[x].second;\n\t\t\t\tc[x].first = c[static_cast<size_type>(c[x].first)].first;\n\t\t\t}\n\t\t\tret = ret + c[x].second;\n\t\t\tx = static_cast<size_type>(c[x].first);\n\t\t}\n\t\treturn std::move(ret);\n\t}\n\npublic:\n\tPotentializedUnionFind() : c() {}\n\texplicit PotentializedUnionFind(const size_type size)\n\t\t: c(size, std::make_pair(-1, value_type())) {}\n\n\tsize_type size() const { return c.size(); }\n\tbool empty() const { return c.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (c[x].first >= static_cast<difference_type>(0)) {\n\t\t\tif (c[static_cast<size_type>(c[x].first)].first >=\n\t\t\t\tstatic_cast<difference_type>(0)) {\n\t\t\t\tc[x].second =\n\t\t\t\t\tc[static_cast<size_type>(c[x].first)].second + c[x].second;\n\t\t\t\tc[x].first = c[static_cast<size_type>(c[x].first)].first;\n\t\t\t}\n\t\t\tx = static_cast<size_type>(c[x].first);\n\t\t}\n\t\treturn x;\n\t}\n\tvalue_type diff(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn potential(y) + (-potential(x));\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn static_cast<size_type>(-c[find(x)].first);\n\t}\n\n\tbool unite(size_type x, size_type y, value_type d) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\td = d + diff(y, x);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (c[x].first > c[y].first)\n\t\tstd::swap(x, y), d = -d;\n\t\tc[x].first += c[y].first;\n\t\tc[y] = std::make_pair(static_cast<difference_type &&>(x), std::move(d));\n\t\treturn true;\n\t}\n};\n\n#include<iostream>\n\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tPotentializedUnionFind<int> T(n);\n\twhile (q--) {\n\t\tint t, x, y, z;\n\t\tstd::cin >> t >> x >> y;\n\t\tif (t) {\n\t\t\tif (T.same(x, y))\n\t\t\t\tstd::cout << T.diff(x, y) << std::endl;\n\t\t\telse\n\t\t\t\tstd::cout << \"?\" << std::endl;\n\t\t}\n\t\telse {\n\t\t\tstd::cin >> z;\n\t\t\tT.unite(x, y, z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\n\n#define for_(i,a,b) for(int i = (a);i < (b);i++)\n#define rfor_(i,a,b) for(int i = (b)-1;i >= (a);i--)\n#define rep(i,n) for_(i,0,(n))\n#define rrep(i,n) rfor_(i,0,(n))\n\nclass WUF {\n\tprivate:\n\tvi par;\n\tvi dw;\n\tpublic:\n\tWUF() {}\n\t~WUF() {}\n\tvoid init(int n) {\n\t\tthis->par.resize(n);\n\t\tthis->dw.resize(n);\n\t\tfor(int i=0;i<n;i++)this->par[i] = i, this->dw[i] = 0;\n\t}\n\tint root(int x) {\n\t\tif(this->par[x]==x)return x;\n\t\telse {\n\t\t\tint r = this->root(this->par[x]);\n\t\t\tthis->dw[x] += this->dw[this->par[x]];\n\t\t\treturn this->par[x] = r;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn this->root(x) == this->root(y);\n\t}\n\tint weight(int x) {\n        this->root(x);\n        return this->dw[x];\n    }\n\tint diff(int x, int y) {\n        return this->weight(y) - this->weight(x);\n    }\n\tvoid unite(int x, int y, int z) {\n        z -= this->diff(x, y);\n        x = this->root(x);\n        y = this->root(y);\n\t\tif(x == y)return ;\n        this->par[y] = x;\n        this->dw[y] = z;\n\t}\n};\n\nWUF a;\n\nint main(){\n\tcin.tie(0);\n\t\n\tint n, q;\n\tcin>>n>>q;\n\t\n\ta.init(n);\n\t\n\trep(i, q) {\n\t\tint c, x, y, z;\n\t\tcin>>c>>x>>y;\n\t\tif(c) {\n\t\t\tif(a.same(x, y))cout<<a.diff(x, y)<<endl;\n\t\t\telse cout<<'?'<<endl;\n\t\t} else {\n\t\t\tcin>>z;\n\t\t\ta.unite(x, y, z);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <utility>\n\ntemplate <class Abelian, template <class T> class Container>\nclass potentialized_union_find {\n\tclass node_type;\n\npublic:\n\tusing value_structure = Abelian;\n\tusing value_type = typename value_structure::value_type;\n\tusing container_type = Container<node_type>;\n\tusing size_type = typename container_type::size_type;\n\nprotected:\n\tvalue_structure vfo;\n\tcontainer_type c;\n\nprivate:\n\tclass node_type {\n\tpublic:\n\t\ttypename potentialized_union_find::size_type par, siz;\n\t\ttypename potentialized_union_find::value_type val;\n\t};\n\tvalue_type potential(size_type x) {\n\t\tvalue_type ret = vfo.identity();\n\t\twhile (x != c[x].par) {\n\t\t\tc[x].val = vfo(c[x].val, c[c[x].par].val);\n\t\t\tret = vfo(ret, c[x].val);\n\t\t\tx = c[x].par = c[c[x].par].par;\n\t\t}\n\t\treturn ::std::move(ret);\n\t}\n\npublic:\n\tpotentialized_union_find() : vfo(), c() {}\n\texplicit potentialized_union_find(\n\t\tconst size_type size, const value_structure &x = value_structure())\n\t\t: vfo(x), c(size, { 0, 1, vfo.identity() }) {\n\t\tfor (size_type i = 0; i < size; ++i) {\n\t\t\tc[i].par = i;\n\t\t}\n\t}\n\n\tsize_type size() const { return c.size(); }\n\tbool empty() const { return c.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (x != c[x].par) {\n\t\t\tc[x].val = vfo(c[x].val, c[c[x].par].val);\n\t\t\tx = c[x].par = c[c[x].par].par;\n\t\t}\n\t\treturn x;\n\t}\n\tvalue_type diff(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tassert(same(x, y));\n\t\treturn vfo(potential(y), vfo.inverse(potential(x)));\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn c[find(x)].siz;\n\t}\n\n\t::std::pair<size_type, size_type> unite(size_type x, size_type y,\n\t\tvalue_type d) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\td = vfo(vfo(d, potential(x)), vfo.inverse(potential(y)));\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x != y) {\n\t\t\tif (c[x].siz < c[y].siz) {\n\t\t\t\t::std::swap(x, y);\n\t\t\t\td = vfo.inverse(d);\n\t\t\t}\n\t\t\tc[x].siz += c[y].siz;\n\t\t\tc[y].par = x;\n\t\t\tc[y].val = ::std::move(d);\n\t\t}\n\t\treturn ::std::pair<size_type, size_type>(x, y);\n\t}\n};\n\ntemplate <class T> class plus_abelian {\npublic:\n\tusing value_type = T;\n\tvalue_type operator()(const value_type &x, const value_type &y) const {\n\t\treturn x + y;\n\t}\n\tvalue_type identity() const { return value_type(0); }\n\tvalue_type inverse(const value_type &x) { return -x; }\n\tvalue_type reverse(const value_type &x) const { return x; }\n};\n\n#include<iostream>\n#include<vector>\ntemplate<class T>\nusing vec = ::std::vector<T>;\n\nint main() {\n\tint n, q;\n\tstd::cin >> n >> q;\n\tpotentialized_union_find<plus_abelian<int>, vec> T(n);\n\twhile (q--) {\n\t\tint t, x, y, z;\n\t\tstd::cin >> t >> x >> y;\n\t\tif (t) {\n\t\t\tif (T.same(x, y))\n\t\t\t\t::std::cout << T.diff(x, y) << ::std::endl;\n\t\t\telse\n\t\t\t\t::std::cout << \"?\" << ::std::endl;\n\t\t}\n\t\telse {\n\t\t\t::std::cin >> z;\n\t\t\tT.unite(x, y, z);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<class T>\nstruct WeightUnionFind {\n  vector<int> tree;\n  vector<int> rank;\n  vector<T> diff_weight;\n\n  WeightUnionFind (int size) : tree(size, -1), rank(size, 0), diff_weight(size, 0) {} ;\n\n  int root(int a) {\n    if (tree[a] < 0) return a;\n    int res = root(tree[a]);\n    diff_weight[a] += diff_weight[tree[a]];\n    return tree[a] = res;\n  }\n\n  bool same(int a, int b) {\n    return root(a) == root(b);\n  }\n\n  bool unite(int a, int b, T w) {\n    w += weight(a); w -= weight(b);\n    a = root(a); b = root(b);\n    if (a == b) return false;\n    if (rank[a] < rank[b]) {\n      swap(a, b);\n      w *= -1;\n    }\n    if (rank[a] == rank[b]) ++rank[a];\n    tree[b] = a;\n    diff_weight[b] = w;\n    return true;\n  }\n\n  T weight(int a) {\n    root(a);\n    return diff_weight[a];\n  }\n\n  T diff(int a, int b) {\n    return weight(b) - weight(a);\n  }\n};\n\n#define rep(i, a, n) for(int i = a; i < (n); ++i)\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  \n  WeightUnionFind<int> wuf(n);\n  rep(i, 0, m) {\n    int a, b, c, d;\n    cin >> a >> b >> c;\n    if (a == 0) {\n      cin >> d;\n      wuf.unite(b, c, d);\n    } else {\n      if (wuf.same(b, c)) {\n        cout << wuf.diff(b, c) << endl;\n      } else {\n        cout << \"?\" << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64=int64_t;\nusing namespace std;\n\n#define int long long\n\nstruct wuf{\n  vector<int> d;\n  vector<int> p;\n  wuf(int n):d(n, 0), p(n, -1){};\n  int root(int x){\n    if(p[x] < 0)return x;\n    else{\n      int r = root(p[x]);\n      d[x] += d[p[x]];\n      return p[x] = r;\n    }\n  }\n  bool same(int x, int y){\n    return root(x) == root(y); \n  }\n  bool join(int x, int y, int w){\n    w += weight(x);\n    w -= weight(y);\n    x = root(x);\n    y = root(y);\n    if(x == y)return false;\n    if(p[x] > p[y]){\n      swap(x, y);\n      w = -w;\n    }\n    p[x] += p[y];\n    p[y] = x;\n    d[y] = w;\n    return true;\n  }\n  int weight(int x){\n    root(x);\n    return d[x];\n  }\n  int diff(int x, int y){\n    return weight(y) - weight(x);\n  }\n};\n\nint32_t main() {\n  int n, q;\n  cin >> n >> q;\n  wuf w(n);\n  for(int i=0;i<q;i++){\n    int c;\n    cin >> c;\n    int x, y, z;\n    if(c == 0){\n      cin >> x >> y >> z;\n      w.join(x, y, z);\n    }else{\n      cin >> x >> y;\n      if(w.same(x, y)){\n        cout << w.diff(x, y) << endl;\n      }else{\n        cout << '?' << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n\nusing namespace std;\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\n\n#define MAX_N 110000\n\nint par1[MAX_N], par2[MAX_N];\nint rnk1[MAX_N], rnk2[MAX_N];\nlong long int diff1[MAX_N], diff2[MAX_N];\n\n// 初期化\nvoid init(int n, int par[], int rnk[], long long int diff[]){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t\tdiff[i] = 0;\n\t}\n}\n\n// x の親を返す\nP find(int x, int par[], long long int diff[]){\n\tP p;\n\tif(par[x] == x){\n\t\tp.first = x;\n\t\tp.second = 0;\n\t\treturn p;\n\t}\n\tp = find(par[x], par, diff);\n\tdiff[x] += p.second;\n\tp.second = diff[x];\n\tpar[x] = p.first;\n\treturn p;\n}\n\n// x と y を併合する\nbool unite(int x, int y, int z, int par[], int rnk[], long long int diff[]){\n\tP px = find(x, par, diff);\n\tP py = find(y, par, diff);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\tif(x_par == y_par){\n    if(px.second != py.second + z){\n      return false;\n    }\n\t\treturn true;\n\t}\n\n\tif(rnk[x_par] < rnk[y_par]){\n\t\tpar[x_par] = y_par;\n\t\tdiff[x_par] = diff[y_par] - px.second + py.second + z;\n\t}else{\n\t\tpar[y_par] = x_par;\n\t\tdiff[y_par] = diff[x_par] + px.second - py.second - z;\n\t\tif(rnk[x_par] == rnk[y_par]){\n\t\t\trnk[x_par]++;\n\t\t}\n\t}\n  return true;\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y, int par[], long long int diff[]){\n\tP px = find(x, par, diff);\n\tP py = find(y, par, diff);\n\tint x_par = px.first;\n\tint y_par = py.first;\n\treturn (x_par == y_par);\n}\n\nint main(){\n  init(MAX_N, par1, rnk1, diff1);\n  init(MAX_N, par2, rnk2, diff2);\n  int n, q;\n  cin >> n >> q;\n  for(int loop = 0; loop < q; loop++){\n    int tp;\n    cin >> tp;\n    if(tp == 0){\n      long long int x, y, z;\n      cin >> x >> y >> z;\n      bool ret = unite(x, y, z, par1, rnk1, diff1);\n      if(!ret){\n        return 0;\n      }\n    }else{\n      long long int x, y;\n      cin >> x >> y;\n      if(same(x, y, par1, diff1)){\n        cout << diff1[x] - diff1[y] << endl;\n      }else{\n        cout << \"?\" << endl;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n\n//\n// 重み付きUnion-Find Tree size version\n//\n// verify: AOJ DSL_1_B\n//\ntemplate <typename T>\nstruct WeightedUnionFind {\n    std::vector<int> data;\n    std::vector<T> ws;\n    const int n;\n    WeightedUnionFind(int num) : data(num, -1), ws(num), n(num) {}\n    int find(int k) {\n        assert(0 <= k && k < n);\n        if (data[k] < 0) return k;\n        auto par = find(data[k]);\n        ws[k] += ws[data[k]];\n        return data[k] = par;\n    }\n    T weight(int k) {\n        assert(0 <= k && k < n);\n        find(k);\n        return ws[k];\n    }\n    bool unite(int x, int y, T w) {\n        assert(0 <= x && x < n);\n        assert(0 <= y && y < n);\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        if (data[x] > data[y]) {\n            std::swap(x, y);\n            w *= -1;\n        }\n        data[x] += data[y];\n        data[y] = x;\n        ws[y] = w;\n        return true;\n    }\n    int size(int k) {\n        assert(0 <= k && k < n);\n        return (-data[find(k)]);\n    }\n    T diff(int x, int y) {\n        assert(0 <= x && x < n);\n        assert(0 <= y && y < n);\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n    WeightedUnionFind<int> uf(N);\n    while (M--) {\n        int a, b, c, d;\n        std::cin >> a >> b >> c;\n        if (a == 0) {\n            std::cin >> d;\n            uf.unite(b, c, d);\n        } else {\n            if (uf.find(b) == uf.find(c)) {\n                std::cout << uf.diff(b, c) << std::endl;\n            } else {\n                std::cout << \"?\" << std::endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n  \nclass DisjointSet{\n    public:\n        vector<int> rnk, par, weight;\n          \n        DisjointSet(){}\n        DisjointSet(int size){\n            rnk.resize(size, 0);\n            par.resize(size, 0);\n            weight.resize(size, 0);\n            for(int i = 0; i < size; i++) makeSet(i);\n        }\n  \n        void makeSet(int x){\n            par[x] = x;\n            rnk[x] = 0;\n            weight[x] = 0;\n        }\n  \n        bool same(int x, int y){\n            return find(x) == find(y);\n        }\n  \n        void unite(int x, int y, int z){\n            par[x] = find(x);\n            par[y] = find(y);\n            int add = z - (weight[y] - weight[x]);\n            if(rnk[par[x]] > rnk[par[y]]){\n                weight[par[y]] = add;\n                par[par[y]] = par[x];\n            }else{\n                weight[par[x]] = -add;\n                par[par[x]] = par[y];\n                if(rnk[par[x]] == rnk[par[y]]){\n                \trnk[par[y]]++;\n                }\n            }\n        }\n          \n        int diff(int x, int y){\n            return weight[y] - weight[x];\n        }\n  \n        int find(int x){\n            if(x != par[x]){\n                int t = find(par[x]);\n                weight[x] += weight[par[x]];\n                return par[x] = t;\n            }\n            else return x;\n        }\n};\n  \nint main(){\n    int n, q;\n    cin >> n >> q;\n    DisjointSet UF(n);\n    for(int i = 0; i < q; i++){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            if(UF.same(x, y)) continue;\n            UF.unite(x, y, z);\n            //for(int j = 0; j < n; j++) cout << UF.weight[j] << (j == n - 1 ? '\\n' : ' ');\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(UF.same(x, y)){\n                cout << UF.diff(x, y) << endl;\n            }else{\n                cout << '?' << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\n\nint main(){\n    int n,q;\n    int x,y,z;\n    int count=0;\n    cin>>n>>q;\n    UnionFind<int> U(n);\n    int info;\n    int diff[q];\n    for(int i=0;i<q;i++){\n        cin>>info;\n        if(info==0){\n        cin>>x>>y>>z;\n        U.merge(x,y,z);\n        }\n\n        if(info==1){\n        cin>>x>>y;\n        if(U.issame(x,y)){\n        cout<<U.diff(x, y)<<endl;\n        }\n        else{\n            cout<<\"?\"<<endl;\n        }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\n\nstruct DisjointSet {\n    private:\n        vector<int> par;\n        vector<int> diff_weight;\n        vector<int> rank;\n    \n    public:\n        DisjointSet(int n) {\n            par = vector<int>(n);\n            rep(i, n) par[i] = i;\n            diff_weight = vector<int>(n);\n            rank = vector<int>(n);\n        }\n    \n        int find(int i) {\n            if (par[i] == i) return i;\n            int p = find(par[i]);\n            diff_weight[i] += diff_weight[par[i]];\n            par[i] = p;\n            return p;\n        }\n\n        int weight(int i) {\n            int p = find(i);\n            return diff_weight[i];\n        }\n    \n        bool joint(int i, int j, int w) {\n            w += weight(i); w -= weight(j);\n            int pi = find(i);\n            int pj = find(j);\n            if (pi == pj) return false;\n    \n            if (rank[pi] < rank[pj]) {\n                swap(pi, pj);\n                w = -w;\n            }\n            if (rank[pi] == rank[pj]) rank[pj]++;\n\n            par[pj] = pi;\n            diff_weight[pj] = w;\n            return true;\n        }\n    };\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin>>n>>q;\n    DisjointSet ds(n);\n    rep(i, q) {\n        int c, x, y, z;\n        cin>>c>>x>>y;\n        if (c == 0) {\n            cin>>z;\n            ds.joint(x, y, z);\n        }\n        else {\n            int px = ds.find(x);\n            int py = ds.find(y);\n            if (px != py) cout<<'?'<<endl;\n            else cout<<ds.weight(y) - ds.weight(x)<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    if(p[y] != y) {\n        if(cost[y] >= z) {\n            p[x] = p[y];\n            cost[x] = cost[y] - z;\n            p[y] = x;\n            cost[y] = z;\n        }\n        else{\n            p[p[y]] = x;\n            cost[p[y]] = z - cost[y];\n        }\n    }\n    else {\n        p[y] = x;\n        cost[y] = z;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, class F = std::plus<T>, class F_INV = std::minus<T>, const T I = 0>\nstruct WeightedUnionFindTree {\n    const F op = F(); const F_INV op_inv = F_INV();\n    vector<int> par, rnk; vector<T> wt;\n    void build(int n) { par.assign(n, -1); rnk.assign(n, 0); wt.assign(n, I); }\n    int find(int x) {\n        if (par[x] < 0) return x;\n        int r = find(par[x]);\n        wt[x] = r == par[x] ? wt[x] : op(wt[par[x]], wt[x]);\n        return par[x] = r;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int size(int x) { return -par[find(x)]; }\n    T eval(int x) { find(x); return wt[x]; }\n    T diff(int x, int y) { assert(same(x, y)); return op_inv(wt[y], wt[x]); }\n    bool unite(int x, int y, T d) {\n        d = op_inv(op(wt[x], d), wt[y]);\n        if ((x = find(x)) == (y = find(y))) return 0;\n        rnk[x] = max(rnk[x], rnk[y] + 1);\n        wt[y] = d;\n        par[x] += par[y];\n        par[y] = x;\n        return 1;\n    }\n    bool uniteByRank(int x, int y, T d) {\n        return rnk[find(x)] < rnk[find(y)] ? unite(y, x, op_inv(I, d)) : unite(x, y, d);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> x(q), y(q), z(q, -1);\n    for (int i = 0; i < q; ++i) {\n        int t;\n        cin >> t;\n        if (t == 0) cin >> x[i] >> y[i] >> z[i];\n        else cin >> x[i] >> y[i];\n    }\n\n    WeightedUnionFindTree<int> wuf;\n    wuf.build(n);\n\n    for (int i = 0; i < q; ++i) {\n        if (z[i] != -1) wuf.uniteByRank(x[i], y[i], z[i]);\n        else if (wuf.same(x[i], y[i])) cout << wuf.diff(x[i], y[i]) << endl;\n        else cout << \"?\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tbool unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tint sx = x, sy = y;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return false;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = z + Weight[sy] - Weight[sx];\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = - z - Weight[sy] + Weight[sx];\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tlong long cost(int x, int y){ // call only if same(x, y) == true\n\t\treturn Weight[x] - Weight[y];\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y;\n\t\t\tlong long z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif(wuf.same(x, y)) cout << wuf.cost(x, y) << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n#include <iterator>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\n\nstruct WeightedUnionFind {\n    vector<int> p, s;\n    vector<i64> w;\n    WeightedUnionFind(size_t n) : p(n, -1), s(n, 1), w(n, 0) {}\n    int root(int u) { \n        while (p[u] != -1) u = p[u];\n        return u;\n    }\n    bool same(int u, int v) {\n        return root(u) == root(v);\n    }\n    bool unite(int u, int v, i64 d) {\n        int ru = root(u), rv = root(v);\n        if (ru != rv) {\n            if (s[ru] < s[rv]) {\n                swap(u, v);\n                swap(ru, rv);\n                d = -d;\n            }\n            p[rv] = ru;\n            s[ru] += s[rv];\n            w[rv] = diff_to_root(u) - diff_to_root(v) - d;\n            return true;\n        } else {\n            return diff(u, v).second == d;\n        }\n    }\n    int size(int i) {\n        return s[root(i)];\n    }\n    i64 diff_to_root(int u) {\n        i64 d = 0;\n        for (; p[u] != -1; u = p[u]) d += w[u];\n        return d;\n    }\n    pair<bool, i64> diff(int u, int v) {\n        if (!same(u, v)) return { false, 0 };\n        return { true, diff_to_root(u) - diff_to_root(v) };\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind uf(n);\n    while (q--) {\n        int cmd;\n        cin >> cmd;\n        if (cmd == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            assert(uf.unite(x, y, z));\n        } else {\n            int x, y;\n            cin >> x >> y;\n            auto p = uf.diff(x, y);\n            if (p.first) {\n                cout << p.second << '\\n';\n            } else {\n                cout << \"?\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint f[1000005];\nint v[1000005];\nint find(int x){\n\tif(f[x]==x){\n\t\treturn x;\n\t}else{\n\t\tint fx=f[x];\n\t\tf[x]=find(f[x]);\n\t\tv[x]+=v[fx];\n\t\treturn f[x];\n\t}\n//\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nvoid join(int x,int y,int z){\n\t// x->y z\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy){\n\t\tv[fx]=z+v[y]-v[x];\n\t\tf[fx]=fy;\n\t}\n}\nint main(){\n\tint n,q,t,l,r;\n\tcin>>n>>q;\n\tfor(int i=0;i<=n;i++)f[i]=i;\n\twhile(q--){\n\t\tcin>>t>>l>>r;\n\t\tif(t){\n\t\t\tint fx=find(l);\n\t\t\tint fy=find(r);\n\t\t\tif(fx==fy){\n\t\t\t\tcout<<v[l]-v[r]<<endl;\n\t\t\t}else cout<<\"?\"<<endl;\n\t\t}else{\n\t\t\tint z;cin>>z;\n\t\t\tjoin(l,r,z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tusing pid = pair<int, T>;\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id].first = a;\n\t\t\tdata[id].second += d;\n\t\t}\n\t\tcopy(all[b].begin(), all[b].end(), back_inserter(all[a]));\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // include all standard C++ libraries\n\nusing namespace std;\n\n// Loops\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define _rrep(i,n) rrepi(i,n,0)\n#define rrepi(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)\n#define each(xi, x) for (auto&& xi : x)\n// Note: we can use rep(i,N) or rep(i,from,to)\n\n\n// typedef\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\nusing vi   = vector<int>;\nusing vvi  = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii  = pair<int, int>;\n\n\n// Constants\n\n// Shorter repr for frequently used terms\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\n// Algorithms\n#define all(x) (x).begin(), (x).end()\ntemplate<class T> pair<T, size_t> max(vector<T> &x){ auto it = max_element(all(x)); return mp(*it, it-x.begin()); }\ntemplate<class T> pair<T, size_t> min(vector<T> &x){ auto it = min_element(all(x)); return mp(*it, it-x.begin()); }\ntemplate<class T> inline bool chmax(T &maxval, const T &newval) { if (maxval<newval) { maxval=newval; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &minval, const T &newval) { if (minval>newval) { minval=newval; return 1; } return 0; }\n\n// Utilities\n// Grid world utilities\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n#define inside(H,W,y,x) 0<=(x) && (x)<(W) && 0<=(y) && (y)<(H)\n\ninline int in() {int x; cin >> x; return x;} // read int from cin\ninline  ll IN() {ll x; cin >> x; return x;}  // read ll from cin\n\n// Debug\n#ifdef LOCAL\n  #include \"dump.hpp\"\n  #define debug(x) cerr << #x << \": \" << x << '\\n'\n#else\n  #define dump(...)\n  #define debug(x)\n#endif\n\n// Paste snippets here!!\nstruct PotentialUnionFind {\n  int n;\n  std::vector<int> par;\n  std::vector<int> rank;\nprivate:\n  std::vector<int> diff_w; // diff_w[v] means the difference of weight from its parent\npublic:\n  PotentialUnionFind(int n_) : par(n_), rank(n_,0), diff_w(n_,0), n(n_) { for(int i=0;i<n;++i) par[i] = i; }\n  int root(int x) { int r; return par[x] == x ? x : (r=root(par[x]), diff_w[x]+=diff_w[par[x]], par[x]=r); }\n  bool same(int x, int y) { return root(x)==root(y); }\n  bool unite(int x, int y, int w) {\n    w += weight(x); w-=weight(y);\n    x = root(x); y = root(y);\n    if(x==y) return false;\n    if(rank[x] < rank[y]) swap(x,y), w=-w;\n    if(rank[x]==rank[y]) rank[x]++;\n    par[y] = x; diff_w[y] = w;\n    return true;\n  }\n  int weight(int x){ root(x); return diff_w[x]; }\n  int diff(int x, int y){ return weight(y)-weight(x); }\n};\n// \n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(false);    // Magic for faster cin\n  int n, q; cin>>n>>q;\n  PotentialUnionFind uf(n);\n  int c, x, y, w;\n  rep(i,q){\n    cin>>c;\n    if(c==0){\n      cin>>x>>y>>w;\n      uf.unite(x,y,w);\n    }\n    else {\n      cin>>x>>y;\n      if(!uf.same(x,y)) cout << '?' << endl;\n      else cout << uf.diff(x,y) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n// https://qiita.com/drken/items/cce6fc5c579051e64fab\nstruct WeightedUnionFind{\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff;\n\n    WeightedUnionFind(int n){\n        init(n);\n    }\n\n    void init(int n){\n        par.resize(n); rank.resize(n, 0); diff.resize(n, 0);\n        for(int i = 0; i < n; i++)  par[i] = i;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int r = root(par[x]);\n            diff[x] += diff[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    // 単ノードの重み取得\n    int weight(int x){\n        root(x);\n        return diff[x];\n    }\n\n    int dif(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n    bool isSame(int x, int y){\n        return root(x) == root(y);\n    }\n\n    // weight(y) - weight(x) = w となるように merge\n    bool merge(int x, int y, int w){\n        // x が y の親になることを考えると、更新の起点はdiff[y]で、\n        // diff[y] を w + weight(x) - weight(y) にすればよい\n        w += weight(x); w -= weight(y);\n\n        x = root(x); y = root(y);\n        if(x == y)  return false;\n        if(rank[x] < rank[y])   swap(x, y), w = -w;\n        if(rank[x] == rank[y])  rank[x]++;\n        par[y] = x;\n        diff[y] = w;\n        return true;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    WeightedUnionFind uf(n);\n    while(q-- > 0){\n        int a, b, c, d;\n        cin >> a >> b >> c;\n        if(a == 0){\n            cin >> d;\n            uf.merge(b, c, d);\n        }else{\n            if(uf.isSame(b, c)) cout << uf.dif(b, c) << endl;\n            else                cout << \"?\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Size;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, -1);\n\t\tSize.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == -1) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tbool unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tint sx = x, sy = y;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return false;\n\t\tif(Size[x] < Size[y]){\n\t\t\tParent[x] = y;\n\t\t\tSize[y] += Size[x];\n\t\t\tWeight[x] = z + Weight[sy] - Weight[sx];\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tSize[x] += Size[y];\n\t\t\tWeight[y] = - z - Weight[sy] + Weight[sx];\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool united(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tlong long cost(int x, int y){\n\t\tassert(united(x, y));\n\t\treturn Weight[x] - Weight[y];\n\t}\n};\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\twhile(q--){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif(!wuf.united(x, y)){\n\t\t\t\tcout << \"?\\n\";\n\t\t\t}else{\n\t\t\t\tcout << wuf.cost(x, y) << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t i64;\n\nconstexpr i64 llinf=4611686018427387903LL;\n\ntemplate <class T_>\nclass wdjset{\npublic:\n    i64 n;\n    i64 *par;\n    i64 gr;\n    T_ *w;\n    void make(i64 N){\n        n=gr=N;\n        par=new i64[n]{};\n        w=new T_[n]{};\n        for(i64 i=0;i<n;i++) par[i]=1;\n    }\n    inline i64 find(i64 X){\n        if(par[X]>0) return X;\n        else{\n            i64 r=find(-par[X]);\n            w[X]+=w[-par[X]];\n            return -(par[X]=-r);\n        }\n    }\n    i64 unite(i64 X,i64 Y,T_ W){\n        i64 px=find(X),py=find(Y);\n        if(px==py) return 0;\n        W+=w[X];\n        W-=w[Y];\n        if(par[px]<par[py]){\n            i64 t=px;\n            px=py;\n            py=t;\n            W=-W;\n        }\n        par[px]+=par[py];\n        par[py]=-px;\n        w[py]=W;\n        gr--;\n        return 1;\n    }\n    i64 same(i64 X,i64 Y){\n        return (find(X)==find(Y));\n    }\n    T_ diff(i64 X,i64 Y){\n        if(!same(X,Y)) return (T_)llinf;\n        return w[Y]-w[X];\n    }\n    i64 size(i64 x){\n        return par[find(x)];\n    }\n    void refr(void){\n        delete[] par;\n    }\n};\n\nint main(void){\n    i64 n,q;\n    scanf(\"%lli%lli\",&n,&q);\n    wdjset<i64> s;\n    s.make(n);\n    for(i64 i=0;i<q;i++){\n        i64 t;\n        scanf(\"%lli\",&t);\n        if(t==0){\n            i64 x,y,z;\n            scanf(\"%lli%lli%lli\",&x,&y,&z);\n            s.unite(x,y,z);\n        }\n        else{\n            i64 x,y;\n            scanf(\"%lli%lli\",&x,&y);\n            i64 d=s.diff(x,y);\n            if(d==llinf) printf(\"?\\n\");\n            else printf(\"%lli\\n\",d);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing pii = pair<int, int>;\nusing ull = unsigned long long;\n \n#define NL '\\n'\n#define xx first\n#define yy second\n#define ins insert\n#define mp make_pair\n#define pb push_back\n#define sz(x) x.size()\n#define pi 2.0*acos(0.0)\n#define _ctz(x) __builtin_ctz(x)\n#define _clz(x) __builtin_clz(x)\n#define _pop(x) __builtin_popcount(x)\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(ii,aa,bb) for(ll (ii)=ll(aa);(ii)<(ll)(bb);++(ii))\n#define _fastIO() ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define _runtime() cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\"1\n\n\nconst int N = 1e6+9;\nint n, q, x, y, z, t;\nvector<pii>parent(N);\n\nvoid make_set(int v){ parent[v] = {v,0}; }\n\npii find_set(int v){\n\tif(v != parent[v].xx) {\n\t\tll d = parent[v].yy;\n\t\tparent[v] = find_set(parent[v].xx);\n\t\tparent[v].yy += d;\n\t}\n\treturn parent[v];\n}\n\nvoid union_set(int u, int v, ll w){\n\tpii du = find_set(u);\n\tpii dv = find_set(v);\n\tif(du.xx == dv.xx) return;\n\tif(du.yy >= w + dv.yy) {\n\t\tparent[dv.xx].xx = du.xx;\n\t\tparent[dv.xx].yy = du.yy - (w + dv.yy);\n\t}\n\telse {\n\t\tparent[du.xx].xx = dv.xx;\n\t\tparent[du.xx].yy = (w + dv.yy) - du.yy;\n\t}\n}\n\nint main(){\n\t_fastIO();\n\tcin >> n >> q;\n\tfor(int i = 0; i < n; i++) make_set(i);\n\tfor(int ix = 0; ix < q; ix++) {\n\t\tcin >> t;\n\t\tif(t == 0) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tunion_set(x, y, z);\n\t\t}\n\t\telse{\n\t\t\tcin >> x >> y;\n\t\t\tif(find_set(x).xx == find_set(y).xx) cout << (parent[x].yy - parent[y].yy) << NL;\n\t\t\telse cout << \"?\" << NL;\n\t\t}\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass WeightedUnionFind {\npublic:\n    vector<int> parents, rank, diff_weight;\n\n    WeightedUnionFind(int n) : parents(n), rank(n), diff_weight(n) {\n        for (int i = 0; i < n; i++) {\n            parents[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }        \n    }\n\n    int root(int x) {\n        if (parents[x] == x) { // root\n            return x;\n        } else {\n            int r = root(parents[x]);\n            diff_weight[x] += diff_weight[parents[x]];\n            return parents[x] = r;\n        }\n    }\n\n    bool isSame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool unite(int x, int y, int w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n\n        if (rank[x] < rank[y]) {\n            swap(x, y);\n            w = -w;\n        }\n\n        if (rank[x] == rank[y]) ++rank[x];\n        parents[y] = x;\n\n        diff_weight[y] = w;\n\n        return true;\n    }\n\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(void) {\n\n    int n, q; cin >> n >> q;\n    WeightedUnionFind wuf(n);\n\n    for (int i = 0; i < q; i++) {\n        int type; cin >> type;\n        if (type == 0) {\n            int x, y, z; cin >> x >> y >> z;            \n            wuf.unite(x, y, z);\n        } else if (type == 1) {\n            int x, y; cin >> x >> y;\n            int ans = wuf.diff(x, y);\n            if (ans < 0) {\n                cout << \"?\" << endl;\n            } else {\n                cout << ans << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nstruct weighted_unionfind {\n    vector<int> d;\n    vector<int> diff_weight;\n    weighted_unionfind(int n=0) : d(n, -1), diff_weight(n, 0) {}\n    int find(int x) {\n        if (d[x] < 0) return x;\n        int root = find(d[x]);\n        diff_weight[x] += diff_weight[d[x]];\n        return d[x] = root;\n    }\n    int weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n    int diff(int x, int y) { return diff_weight[y] - diff_weight[x];}\n    // weight(y) - weight(x) = w\n    bool unite(int x, int y, int w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        if (d[x] > d[y]) {\n            swap(x, y);\n            w = -w;\n        }\n        d[x] += d[y];\n        d[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    bool same(int x, int y) { return find(x) == find(y);}\n    int size(int x) { return -d[find(x)];}\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    weighted_unionfind wuf(n);\n    while (q--) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            wuf.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (wuf.same(x, y)) {\n                cout << wuf.diff(x, y) << endl;\n            } else {\n                cout << '?' << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint par[111111];\nint rnk[111111];\nint W[111111];\n\nint root(int x){\n  if(par[x]==x) return x;\n  root(par[x]);\n  W[x]+=W[par[x]];\n  return par[x]=root(par[x]);\n}\n\nint weight(int x){\n  root(x);\n  return W[x];\n}\n\nvoid unite(int x,int y,int w){\n  w+=weight(x);\n  w-=weight(y);\n  x=root(x);\n  y=root(y);\n  if(x==y) return;\n  if(rnk[x]<rnk[y]) swap(x,y), w=-w;\n  rnk[x]+=rnk[y];\n  par[y]=x;\n  W[y]=w;\n}\n\nsigned main(){\n  for(int i=0;i<111111;i++)par[i]=i;\n  int n,m;\n  cin>>n>>m;\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>b>>c;\n    if(a==1){\n      if(root(b)==root(c)){\n        cout<< weight(c) - weight(b) <<endl;\n      }\n      else cout<<\"?\"<<endl;\n    }\n    else{\n      cin>>d;\n      unite(b,c,d);\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass DisjointSet {\npublic:\n\tvector<int> p, r, w;\n\t\n\tDisjointSet(){}\n\tDisjointSet(int size){\n\t\tfor(int i=0;i<size;i++){\n\t\t\tmakeSet(i);\n\t\t}\n\t}\n\t\n\tvoid makeSet(int x){\n\t\tp.push_back(x);\n\t\tr.push_back(0);\n\t\tw.push_back(0);\n\t}\n\t\n\tvoid relate(int x, int y, int z){\n\t\tlink(find(x),find(y),z-w[x]+w[y]);\n\t}\n\t\n\tvoid link(int x, int y, int cost){\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\tw[x]+=cost;\n\t\t} else {\n\t\t\tp[y]=x;\n\t\t\tw[y]-=cost;\n\t\t\tif(r[x]==r[y]){\n\t\t\t\tr[y]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x)==find(y);\n\t}\n\t\n\tint sum(int x){\n\t\tint sum=0;\n\t\tint cur=x;\n\t\twhile(cur!=p[cur]){\n\t\t\tsum+=w[cur];\n\t\t\tcur=p[cur];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tint find(int x){\n\t\tif(x!=p[x]){\n\t\t\tint tmp=find(p[x]);\n\t\t\tw[x]+=w[tmp];\n\t\t\tp[x]=tmp;\n\t\t}\n\t\treturn p[x];\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tDisjointSet ds(n);\n\tfor(int i=0;i<q;i++){\n\t\tint c, x, y, z;\n\t\tcin >> c >> x >> y;\n\t\tif (c == 0) {\n\t\t\tcin >> z;\n\t\t\tds.relate(x, y, z);\n\t\t} else {\n\t\t\tif (!ds.same(x, y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t} else {\n\t\t\t\tint sumX = ds.sum(x);\n\t\t\t\tint sumY = ds.sum(y);\n\t\t\t\tcout << sumX - sumY << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> p,rank,cost;\n\nvoid makeSet(int x) {\n    p.push_back(x);\n    rank.push_back(0);\n    cost.push_back(0);\n}\n\nint findSet(int x) {\n    int prep = p[x];\n    if(x != p[x]) {\n        p[x] = findSet(p[x]);\n    }\n    cost[x] += cost[prep];\n    return p[x];\n}\n\nvoid relate(int x, int y, int z) {\n    int rootx = findSet(p[x]), rooty = findSet(p[y]);\n    if(rootx == rooty) return;\n    z = z + cost[x] - cost[y];\n    if(rank[rooty] < rank[rootx]) {\n        p[rooty] = rootx;\n        cost[rooty] = z;\n    }\n    else {\n        p[rootx] = rooty;\n        cost[rootx] = -z;\n        if(rank[rootx] == rank[rooty]) rank[rooty]+=1;\n    }\n}\n\nint main() {\n    int n,q,com,x,y,z;\n    cin >> n >> q;\n    for(int i=0; i<n; i++) makeSet(i);\n    for(int i=0; i<q; i++) {\n        cin >> com >> x >> y;\n        if(com == 0) {\n            cin >> z;\n            relate(x,y,z);\n        }\n        else {\n            if(findSet(x) == findSet(y)) cout << cost[y]-cost[x] << endl;\n            else cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(int argc,char* argv[]){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n\treturn 1;\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define SIZE 100000\n\nint main(void)\n{\n    int n, q;\n    int com, x, y, z;\n    int rootX, rootY;\n    int diffX, diffY;\n    int parent[SIZE + 1];\n    int parent_diff[SIZE + 1] = {};\n    \n    cin >> n >> q;\n    \n    for(int i = 0; i <= n; ++i)\n    {\n        parent[i] = i;\n    }\n    \n    for(int i = 0; i < q; ++i)\n    {\n        cin >> com;\n        \n        if(com == 0)\n        {\n            cin >> x >> y >> z;\n            \n            diffX = 0;\n            rootX = x;\n            while(parent[rootX] != rootX)\n            {\n                diffX += parent_diff[rootX];\n                rootX = parent[rootX];\n            }\n            diffY = 0;\n            rootY = y;\n            while(parent[rootY] != rootY)\n            {\n                diffY += parent_diff[rootY];\n                rootY = parent[rootY];\n            }\n                \n            if(rootX < rootY)\n            {\n                parent[rootY] = rootX;\n                parent_diff[rootY] = diffX - diffY - z;\n            }\n            else\n            {\n                parent[rootX] = rootY;\n                parent_diff[rootX] = diffY - diffX + z;\n            }\n        }\n        else if(com == 1)\n        {\n            cin >> x >> y;\n            \n            diffX = 0;\n            rootX = x;\n            while(parent[rootX] != rootX)\n            {\n                diffX += parent_diff[rootX];\n                rootX = parent[rootX];\n            }\n            diffY = 0;\n            rootY = y;\n            while(parent[rootY] != rootY)\n            {\n                diffY += parent_diff[rootY];\n                rootY = parent[rootY];\n            }\n            \n            if(rootX == rootY)\n                cout << diffX - diffY << endl;\n            else\n                cout << '?' << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nvrrtll==???>;::::~~~~~~......`.`````````````````````...-?777!_.._?7u,~~~::::;>>??=lllttrrzu\nrtll==??>>;::::~~~~......`.`````````````````` ..J77!`````````...`..._T,~~~~:::;;>??==lttrrv\ntll=??>>;:::~~~~......``````````````````..J7^ ` ``  ` `` .,```````...._4,.~~~::;;>>?===lttr\nl=???>;;::~~~......`````HTSu,.``  `..J7!    `      `` .J\"~N```````````..?&.~~~~::;;>>?==llt\n=??>;;::~~~~.....``````.@????7SJ.?=     `     ` `` .J=....J;  ``````````..h..~~~~::;;>??=ll\n?>>;::~~~~.....````````.D?>>?>?>?8+.``         `.J\"_......_b`     ````````.S_.~~~~::;;>??=l\n>;;::~~~~....``````````.C>??>>>?>>>?8J.`  ```..Y~..........J;  `  ` ``````` G...~~~~::;>??=\n;;::~~~....```````` `..W1>>?>>>>?>>>>>?S,.`.7^.............-N``  `   ``````` 6...~~~~::;>??\n;:~~~~....``````` ..7` d??>>?>?>>?>>?>>1udMgggNNNNggJ.......([          `````.L...~~~~::;>?\n:~~~.....`````` .7`   `K>?>?>>>>>>+ugNMMMB\"\"7<!~~<?7TWMNNa,..w.`  ` `  ` `````,)....~~:::;>\n~~~....``````.J^     ` #>>?>>>?jgMMM9=_................-?TMMa,b` `   `  `  ````(,...~~~~:;;\n~~~....``` .7``   `    @?>>?1uMM#=.........................(TMNa......  ` ``````4....~~~::;\n~~~...`` .=`` `     ` .b>>jgNH\".................`.............?HNmx??17TYY9SA+(..L....~~~::\n~....` ,^``     `   ` .b+dN#^............6..-(,-...`............(HMm+>>>>>?>>????zOM_.~~~::\n.... .=```  `` `   ...JNMM^..........`..._n.(MMN,....`..`.........?MNe<>>?>??>????d^...~~~:\n~...v```` ` ..-Z\"\"!_..(M@_........`........?7MMMMp.................-TNN+?>>>????1d4-..-(Jk9\n..(^`...zY\"!_........(MD..............`......JMMMMp....`..`..`......./MNx>??>>?1d!.h7=~(??=\n(v_`,R_.............(NF..(/..(&,...`..........?MMMM;..................(MMs>>?1&T\"!``....(1=\nt..`` 4,...........(N@....?,(NMNR_.....`..`....(WMM$..`....`..`..`....._HMe7=```````....~_1\n...````.4,........-dM:.....(7MMMNR-.....................`............(.?^ ``  ``````....~~~\n...``````,4,....`.(NF........(MMMMb..`....--................`....(.7!        `  ````....~~:\n..````` ` `.5J_...JMt.........?NMMM[...`.HH5._(J7[...`...`...--?^`          ` `````....~~~:\n...````` `  ` 7a,.dM{....`...../MMMN......(J=`  .>......._(/=             `  ` `````...~~~:\n....```` ``     (4MN{..........._7\"^...(/^    `.C....-(J=`                  ` ` ```....~~~:\n....````` `      JdM[...`...`........`_3..  ..?!..(-7!                  ` ` ``````....~~~::\nr...``````  ` ``(CJMb..............`......__..-(?^                     `  `  `````....~~::;\nJ/...````` `  `,3>+MN-.`..`...`..........._(J=``                     `  ` ```````....~~~::;\n_j,..`.```` ``.5>>?dNb...`......`......_-?'`                            `  `````....~~~::;;\n~~j,..```````.D??>>>MM/....`........(-=`                          `  ` ` ```````...~~~:::;>\n~~~j,...````.E??>??>?MN-.........(J=                            `   ` ` ``````....~~~~::;??\n:~~~?,...``.@>?>?>>??dMN_....-(?^                        `  `    ` `  ````````...~~~~:;;>??\n::~~~?/....K??????>>?>dMN-_(7!                               `  ` ` ````````....~~~:::>>??l\n;:::~~/e.(K==?????????<dM\"!                          `    `   ` ` `` ``````...~~~~:::;>??=l\n*/\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define ok1 printf(\"ok1\\n\")\n#define ok2 printf(\"ok2\\n\")\n#define M LLONG_MAX\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,s,n) for(int i=(s);i<(n);++i)\n#define repr(i,n) for(int i=n-1;i>=0;--i)\n#define REPR(i,s,n) for(int i=(s);i>=(n);--(i))\n#define all(a) (a).begin(),(a).end()\n#define reall(a) (a).rbegin(),(a).rend()\n#define pb emplace_back //emplace_backの方が速いが使い慣れてないため\n#define DOUBLE fixed << setprecision(15)\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define BIT(n,m)(((n)>>(m))&1)\nconst double pi = acos(-1.0);\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<bool> vb;\ntypedef deque<ll> dll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> TLL;\ntypedef vector<P> vP;\ntypedef vector<TLL> vTLL;\nconst ll mod = 1e9 + 7;\n//const ll mod = 998244353;\nll dy[4] = { 1,0,-1,0 };\nll dx[4] = { 0,1,0,-1 };\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const pair<A, B>&p) {\n\tost << \"{\" << p.first << \", \" << p.second << \"} \";\n\treturn ost;\n}\ntemplate<class T>\nostream& operator<<(ostream& ost, const vector<T>&v) {\n\tost << \"{\";\n\tfor (int i = 0; i<v.size(); i++) {\n\t\tif (i)ost << \", \";\n\t\tost << v[i];\n\t}\n\tost << \"} \";\n\treturn ost;\n}\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const map<A, B>&v) {\n\tost << \"{\";\n\tfor (auto p:v) {\n\t\tost << \"{\" << p.first << \", \" << p.second << \"} \";\n\t}\n\tost << \"} \";\n\treturn ost;\n}\nbool out_check(ll a, ll b) { return (0 <= a && a < b); }\nvoid addmod(ll &a, ll &b) { a = (a + b) % mod; }\ndouble pitagoras(ll a, ll b, ll c, ll d) {\n\tdouble dx = a - b, dy = c - d;\n\treturn pow(dx * dx + dy * dy, 0.5);\n}\nll powmod(ll a, ll b) { ll c = 1; while (b > 0) { if (b & 1) { c = a * c%mod; }a = a * a%mod; b >>= 1; }return c; }\nvoid Yes(bool x) { cout << ((x) ? \"Yes\\n\" : \"No\\n\"); }\nvoid YES(bool x) { cout << ((x) ? \"YES\\n\" : \"NO\\n\"); }\nvoid yes(bool x) { cout << ((x) ? \"yes\\n\" : \"no\\n\"); }\nvoid Yay(bool x) { cout << ((x) ? \"Yay!\\n\" : \":(\\n\"); }\nvector<string> DAY = { \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\" };\nll  n, m, d, e, r, l, k, h, Q, ans, ret = M;\nbool flag = false, flag2 = false, flag3 = false;\nstring s, t, u;\n\nclass WeightedUnionFind {\npublic:\n\tint n;\n\tvector<int> u;\n\tvector<long long> weight;\n\tWeightedUnionFind(int n = 0) :n(n) {\n\t\tu = vector<int>(n);\n\t\tweight = vector<long long>(n, 0);\n\t\tfor (int i = 0; i < n; i++)u[i] = i;\n\t}\n\tint r(int x) {\n\t\tif (u[x] == x)return x;\n\t\tr(u[x]);\n\t\tweight[x] += weight[u[x]];\n\t\treturn u[x] = r(u[x]);\n\t}\n\n\tlong long dif(long long x, long long y) {\n\t\tif (r(x) != r(y))return LLONG_MAX;\n\t\treturn weight[x] - weight[y];\n\t}\n\n\t//x - y == w\n\tbool isOK(int x, int y, long long w) {\n\t\tif (r(x) != r(y))return false;\n\t\treturn dif(x, y) == 0;\n\t}\n\n\tvoid unite(int x, int y, long long w) {\n\t\tr(x);\n\t\tr(y);\n\t\tw += weight[y];\n\t\tw -= weight[x];\n\t\tx = r(x);\n\t\ty = r(y);\n\t\tu[x] = y;\n\t\tweight[x] = w;\n\t}\n};\n\n\nint main() {\n\t//cin.tie(0); ios::sync_with_stdio(false);//not intractive\n\tcin >> n >> Q;\n\tWeightedUnionFind tree(n);\n\trep(_, Q) {\n\t\tcin >> d;\n\t\tif (d) {\n\t\t\tll x, y; cin >> x >> y;\n\t\t\tans = tree.dif(x, y);\n\t\t\tif (ans == M) cout << \"?\\n\";\n\t\t\telse cout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tll c, x, y; cin >> c >> x >> y;\n\t\t\ttree.unite(c, x, y);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\nusing LL = long long;\t\tusing VB = vector<bool>;\nusing VI = vector<int>;\t\tusing VL = vector<LL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing VVI = vector<VI>;\t\tusing VVL = vector<VL>;\nusing PII = pair<int, int>;\tusing PLL = pair<LL, LL>;\nusing VP = vector<PII>;\t\tusing VPL = vector<PLL>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n\ntemplate<class T>class UnionFind {\n\tvector<int> par, rank;\n\tvector<T> weight_;\npublic:\n\tUnionFind(int n) :par(n), rank(n, 0), weight_(n, 0) {\n\t\tfor (int i = 0; i < n; ++i)par[i] = i;\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x)return x;\n\t\tint r = root(par[x]);\n\t\tweight_[x] += weight_[par[x]];\n\t\treturn par[x] = r;\n\t}\n\tT weight(int x) {\n\t\troot(x); return weight_[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tbool merge(int x, int y, T w) {\n\t\tw += weight(x); w -= weight(y);\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (rank[x] < rank[y]) { swap(x, y); w = -w; }\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t\tpar[y] = x; weight_[y] = w;\n\t\treturn true;\n\t}\n\tT diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t}\n};\n\nint main() {\n\tint n = in, q = in;\n\tUnionFind<LL> uf(n);\n\trep(i, q) {\n\t\tint op = in;\n\t\tif (op == 0) {\n\t\t\tint x = in, y = in, z = in;\n\t\t\tuf.merge(x, y, z);\n\t\t} else {\n\t\t\tint x = in, y = in;\n\t\t\tif (uf.same(x, y)) {\n\t\t\t\tout(uf.diff(x, y));\n\t\t\t} else {\n\t\t\t\tout('?');\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvector<int> point;\nvector<int> Rank;\nvector<int> Cost;\n\n\nvoid CreateSet(int x);\nint Find(int x);\nvoid Relate(int x, int y, int z);\nvoid Diff(int x, int y);\nint main() {\n    int n,q;\n    int operation;\n    int x,y,z;\n    cin >> n >> q;\n\n    for (int i = 0; i < n; ++i) {\n        CreateSet(i);\n    }\n\n    for (int j = 0; j < q; ++j) {\n        cin >> operation >> x >> y;\n        if(operation == 0){\n            cin >> z;\n            Relate(x,y,z);\n        }else{\n            Diff(x,y);\n        }\n    }\n\n\n    return 0;\n}\nvoid CreateSet(int x){\n    point.push_back(x);\n    Rank.push_back(0);\n    Cost.push_back(0);\n}\nint Find(int x){\n    int prev = point[x];\n    if (x != point[x])\n    {\n        point[x] = Find(point[x]);\n    }\n    Cost[x] = Cost[x] + Cost[prev];\n}\nvoid Relate(int x, int y, int z){\n    int rootX = Find(x);\n    int rootY = Find(y);\n    if(rootX == rootY){\n        // the same union\n        return;\n    }\n    z = z + Cost[x] - Cost[y];\n    \n    if(Rank[rootY] < Rank[rootX]){\n        point[rootY] = rootX;\n        Cost[rootY] = z;\n    }else{\n        point[rootX] = rootY;\n        Cost[rootX] = -z;\n        if(Rank[rootX] == Rank[rootY]){\n            Rank[rootY] += 1;\n        }\n    }\n}\nvoid Diff(int x, int y){\n    if(Find(x) == Find(y)){\n        cout << Cost[y] - Cost[x] << endl;\n    }else{\n        cout << \"?\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T> \nstruct WeightedUnionFind{\n  Int n;\n  T d;\n  vector<Int> r,p;\n  vector<T> ws;\n  WeightedUnionFind(){}\n  WeightedUnionFind(Int sz,T d_):\n    n(sz),d(d_),r(n,1),p(n),ws(n,d){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    if(x==p[x]){\n      return x;\n    }else{\n      Int t=find(p[x]);\n      ws[x]+=ws[p[x]];\n      return p[x]=t;\n    }\n  }\n  T weight(Int x){\n    find(x);\n    return ws[x];\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y,T w){\n    w+=weight(x);\n    w-=weight(y);\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y),w=-w;\n    r[x]+=r[y];\n    p[y]=x;\n    ws[y]=w;\n  }\n  T diff(Int x,Int y){\n    return weight(y)-weight(x);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,q;\n  cin>>n>>q;\n  WeightedUnionFind<Int> wuf(n,0);\n  \n  for(Int i=0;i<q;i++){\n    Int t,x,y,z;\n    cin>>t>>x>>y;\n    //cout<<t<<\":\"<<x<<\" \"<<y<<endl;\n    if(t){\n      if(wuf.same(x,y)) cout<<wuf.diff(x,y)<<endl;\n      else cout<<\"?\"<<endl;\n    }else{\n      cin>>z;\n      wuf.unite(x,y,z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nclass WeightedUnionFind {\n  std::vector<int> par;  // 親の番号\n  std::vector<int> ws;   // 親との重みの差\n\n public:\n  WeightedUnionFind(int n) : par(n, -1), ws(n, 0) {}\n\n  // x の親を返す\n  int find(int x) {\n    if (par[x] < 0) {\n      return x;\n    } else {\n      int parent = find(par[x]);\n      ws[x] += ws[par[x]];\n      return par[x] = parent;\n    }\n  }\n\n  // x の重み(親との相対値)を返す\n  int weight(int x) {\n    find(x);\n    return ws[x];\n  }\n\n  // 頂点 x, y を (xの重み) + w = (yの重み) となるように Unite\n  bool unite(int x, int y, int w) {\n    w += weight(x);\n    w -= weight(y);\n    x = find(x);\n    y = find(y);\n\n    if (x != y) {\n      if (par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n        int tmp = x;\n        x = y;\n        y = tmp;\n        w = -w;\n      }\n      par[x] += par[y];\n      par[y] = x;\n      ws[y] = w;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n\n  void init(int size) {\n    for (int i = 0; i < size; i++) {\n      par[i] = -1;\n      ws[i] = 0;\n    }\n  }\n};\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFind uf(n);\n  for (int i = 0; i < q; i++) {\n    int id;\n    cin >> id;\n    if (id) {\n      int x, y;\n      cin >> x >> y;\n      if (uf.same(x, y)) {\n        cout << -uf.weight(x) + uf.weight(y) << endl;\n      } else {\n        cout << \"?\" << endl;\n      }\n    } else {\n      int x, y, z;\n      cin >> x >> y >> z;\n      uf.unite(x, y, z);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//重み付きUnion-Find木\n//参考 https://qiita.com/drken/items/cce6fc5c579051e64fab\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_B\n\n#include<iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX_N 500000//頂点の最大数\n\nll par[MAX_N];//親の番号\nll urank[MAX_N];//集合のランク\nll usize[MAX_N];//集合の要素数\nll diff_weight[MAX_N];//親との距離\nll num;//集合の数\n\nvoid init(ll n) {//初期化\n    num = n;\n    rep(i,n) {\n        par[i] = i;\n        urank[i] = 0;\n        usize[i] = 1;\n        diff_weight[i] = 0;\n    }\n}\n\nll find(ll x) {//根の添字を返すと同時に経路圧縮をする\n    if(par[x] == x) {\n        return x;\n    }else {\n        ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];//累積和\n        return par[x] = r;\n    }\n}\n\nbool same(ll x,ll y) {\n    return find(x) == find(y);\n}\n\nll weight(ll x) {//親との距離を求める\n    find(x);\n    return diff_weight[x];\n}\n\nll diff(ll x,ll y) {//xからyに行くときのポテンシャルの増加分\n    return weight(y) - weight(x);\n}\n\nll get_usize(ll x) {//xが属する集合の要素数を返す。\n    return usize[find(x)];\n}\n\nbool unite(ll x,ll y,ll w) {//weight(y) = weight(x) + w (diff(x,y) = w) となるようにxの属する集合とyの属する集合をマージ\n    if(urank[x] < urank[y]) swap(x,y);//x(のroot)の下にy(のroot)をつけるので反転\n\n    w += weight(x);w -= weight(y);\n    //x(のroot)の下にy(のroot)をつけるので、w=diff(xのroot,yのroot)となるように\n\n    x = find(x);y = find(y);\n\n    if(x == y) {\n        return diff(x,y) == w;\n    }\n\n    //x(のroot)の下にy(のroot)をつける。\n    if(urank[x] == urank[y]) urank[x]++;\n    par[y] = x;\n\n    diff_weight[y] = w;\n\n    return true;\n}\n\nll num_set() {\n    return num;\n}\n\nll n,q;\nint main() {\n    cin >> n >> q;\n    init(n);\n\n    rep(i,q) {\n        ll c,x,y,z;\n\n        cin >> c;\n        if(c) {\n            cin >> x >> y;\n            if(same(x,y)) cout << diff(x,y) << endl;\n            else cout << '?' << endl;\n        }else {\n            cin >> x >> y >> z;\n            unite(x,y,z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::max;\nusing std::endl;\n\ntemplate <typename T>\nclass Vector {\n  private:\n  unsigned int end;\n  unsigned int alloc;\n  public:\n  T* A;\n  Vector(): end(0), alloc(1), A((T *)malloc(sizeof(T))){}\n  // Vector(){\n  //   end = 0;\n  //   alloc = 1;\n  //   A = (T *)malloc(sizeof(T));\n  // }\n  Vector(const unsigned int initial_size){\n    end = initial_size;\n    alloc = max((unsigned int)1, initial_size);\n    A = (T *)malloc(sizeof(T) * initial_size);\n  }\n  Vector(const Vector &other){\n    end = other.end;\n    alloc = other.alloc;\n    A = (T *)malloc(sizeof(T) * alloc);\n    memcpy(A, other.A, sizeof(T) * alloc);\n  }\n  Vector &operator=(const Vector &other){\n    if(this != &other){\n      end = other.end;\n      alloc = other.alloc;\n      A = (T *)malloc(sizeof(T) * alloc);\n      memcpy(A, other.A, sizeof(T) * alloc);\n    }\n    return *this;\n  }\n  unsigned int size()const{\n    return end;\n  }\n  void push_back(T v){\n    if(end < alloc){\n    }else{\n      if(alloc == 0 || A == NULL){\n        A = (T *)malloc(sizeof(T));\n        alloc++;\n      }else{\n      unsigned int nalloc = alloc * 2;\n      T* nA = (T *)malloc(sizeof(T) * nalloc);\n      memcpy(nA, A, sizeof(T) * end);\n      free(A);\n      A = nA;\n      alloc = nalloc;\n      }\n    }\n    A[end] = v;\n    end++;\n  }\n  void pop_back(){\n    if(end == 0) return;\n    end--;\n  }\n  T &operator[](const unsigned int idx)const{\n    return A[idx];\n  }\n  ~Vector(){\n    free(A);\n  }\n};\n\nclass WUnionFind {\n  public:\n  Vector<int> par;\n  Vector<int> rank;\n  Vector<int> dw;\n\n  WUnionFind(int size): par(size), rank(size), dw(size){\n    for(int i = 0; i < size; i++){\n      par[i] = i;\n      rank[i] = 0;\n      dw[i] = 0;\n    }\n  }\n\n  int root(int x){\n    if(par[x] == x) return x;\n    int tmp = root(par[x]);\n    dw[x] += dw[par[x]];\n    return par[x] = tmp;\n  }\n\n  int weight(int x){\n    root(x);\n    return dw[x];\n  }\n\n  void unite(int x, int y, int w){\n    int xroot = root(x);\n    int yroot = root(y);\n    w += weight(x); w -= weight(y);\n    if(rank[xroot] < rank[yroot]){\n      par[xroot] = yroot;\n      dw[xroot] = -w;\n    }else{\n      par[yroot] = xroot;\n      dw[yroot] = w;\n      if(rank[xroot] == rank[yroot]){\n        rank[yroot]++;\n      }\n    }\n  }\n};\n\n\nint main(void){\n  int n, q; cin >> n >> q;\n  WUnionFind wuf(n);\n  \n  for(int i = 0; i < q; i++){\n    int op, x, y, z;\n    cin >> op;\n    if(op == 0){\n      cin >> x >> y >> z;\n      wuf.unite(x, y, z);\n    }else{\n      cin >> x >> y;\n      if(wuf.root(x) != wuf.root(y)){\n        cout << \"?\" << endl;\n      }else{\n        cout << wuf.dw[y] - wuf.dw[x] << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct WeightUnionFind{\n\t//\n\tvector<int> ran,par,wei;\n\t//\n\tWeightUnionFind(int n){\n\t\tinit(n);\n\t}\n\t//\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar.push_back(i);\n\t\t\tran.push_back(0);\n\t\t\twei.push_back(0);\n\t\t}\n\t}\n\t//\n\tint find(int x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\tint r=find(par[x]);\n\t\t\twei[x]+=wei[par[x]];\n\t\t\treturn par[x]=r;\n\t\t}\n\t}\n\t//\n\tint weight(int x){\n\t\tfind(x);\n\t\treturn wei[x];\n\t}\n\t//\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\t//\n\tbool unite(int x,int y,int w){\n\t\tw+=weight(x);\n\t\tw-=weight(y);\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y){\n\t\t\treturn false;\n\t\t}else if(ran[x]<ran[y]){\n\t\t\tswap(x,y);\n\t\t\tw=-w;\n\t\t}else if(ran[x]==ran[y]){\n\t\t\tran[x]++;\n\t\t}\n\t\tpar[y]=x;\n\t\twei[y]=w;\n\t\treturn true;\n\t}\n\t//\n\tint diff(int x,int y){\n\t\treturn weight(y)-weight(x);\n\t}\n\t//\n};\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tWeightUnionFind UF(N);\n\twhile(Q--){\n\t\tint C;\n\t\tcin>>C;\n\t\tif(C==1){\n\t\t\tint X,Y;\n\t\t\tcin>>X>>Y;\n\t\t\tif(UF.same(X,Y)){\n\t\t\t\tcout<<UF.diff(X,Y)<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"?\"<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\tint X,Y,Z;\n\t\t\tcin>>X>>Y>>Z;\n\t\t\tUF.unite(X,Y,Z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nclass weighted_union_find{\n    public:\n        int n;\n        vector<T> p, w, rank;\n\n        weighted_union_find(int n)\n            : n(n), p(n+1, -1), w(n+1), rank(n+1) {}\n\n        int find(int v){\n            if(p[v] == -1){\n                return v;\n            }\n            int r = find(p[v]);\n            w[v] += w[p[v]];\n            return p[v] = r;\n        }\n\n        int weight(int v){\n            find(v);\n            return w[v];\n        }\n\n        int diff(int u, int v){\n            return weight(v) - weight(u);\n        }\n\n        void unite(int u, int v, int ww){\n            ww = ww + weight(u) - weight(v);\n            u = find(u);\n            v = find(v);\n\n            if(u == v){\n                return;\n            }\n\n            if(rank[u] < rank[v]){\n                swap(u, v);\n                ww = -ww;\n            }\n\n            if(rank[u] == rank[v]){\n                rank[u]++;\n            }\n\n            p[v] = u;\n            w[v] = ww;\n        }\n};\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> p(n, -1);\n\n    weighted_union_find<int> uf(n);\n    rep(i, q){\n        int com, x, y;\n        cin >> com >> x >> y;\n\n        if(com == 0){\n            int w;\n            cin >> w;\n            uf.unite(x, y, w);\n        }\n\n        if(com == 1){\n            if(uf.find(x) != uf.find(y)){\n                cout << \"?\" << endl;\n                continue;\n            }\n            cout << uf.diff(x, y) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <stdexcept>\n\ntemplate <class Weight>\nclass potentialized_union_find {\n  std::vector<intmax_t> tree;\n  std::vector<Weight> cost;\n\npublic:\n  potentialized_union_find(size_t n): tree(n, -1), cost(n) {}\n\n  size_t find(size_t v) {\n    if (tree[v] < 0) return v;\n\n    size_t r = find(tree[v]);\n    cost[v] += cost[tree[v]];\n    return (tree[v] = r);\n  }\n\n  bool unite(size_t u, size_t v, Weight w) {\n    size_t ru = find(u);\n    size_t rv = find(v);\n    if (ru == rv) {\n      if (cost[u]-cost[v] != w) throw std::logic_error(\"inconsistent potentials\");\n      return false;\n    }\n\n    w -= cost[u]-cost[v];\n    if (-tree[ru] >= -tree[rv]) {\n      std::swap(ru, rv);\n      std::swap(u, v);\n      w = -w;\n    }\n    tree[rv] += tree[ru];\n    tree[ru] = rv;\n    cost[ru] = w;\n    return true;\n  }\n\n  bool connected(size_t u, size_t v) {\n    return (find(u) == find(v));\n  }\n\n  Weight potential(size_t u, size_t v) {\n    if (!connected(u, v)) throw std::logic_error(\"an indefinite potential\");\n    return cost[u]-cost[v];\n  }\n\n  size_t size(size_t v) {\n    return -tree[find(v)];\n  }\n};\n\nint main() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n\n  potentialized_union_find<intmax_t> uf(n);\n  for (size_t i = 0; i < q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      // relate(x, y, z)\n      size_t x, y;\n      intmax_t z;\n      scanf(\"%zu %zu %jd\", &x, &y, &z);\n      uf.unite(x, y, z);\n    } else if (t == 1) {\n      // diff(x, y);\n      size_t x, y;\n      scanf(\"%zu %zu\", &x, &y);\n      try {\n        printf(\"%jd\\n\", uf.potential(x, y));\n      } catch (std::logic_error) {\n        puts(\"?\");\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind {\n    vector<int> parent;\n    vector< ll > dist;\n    UnionFind(int x = 1) {\n        parent.resize(x, -1);\n        dist.resize(x, 0);\n    }\n    int find(int x) {\n        if (parent[x] < 0) return x;\n        int r = find(parent[x]);\n        dist[x] += dist[parent[x]];\n        return parent[x] = r;\n    }\n    ll depth(int x) {\n        find(x);\n        return dist[x];\n    }\n    bool same(int x, int y) {\n        return (find(x) == find(y));\n    }\n    void unite(int x, int y, ll k = 0) {\n        k += depth(y);\n        k -= depth(x);\n        k *= -1;\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        parent[y] = x;\n        dist[y] = k;\n    }\n};\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    UnionFind T(n);\n    for (int i = 0; i < q; i++) {\n        int type, x, y;\n        scanf(\"%d %d %d\", &type, &x, &y);\n        if (type == 0) {\n            int a;\n            scanf(\"%d\", &a);\n            T.unite(x, y, a);\n        }\n        else \n            if (!T.same(x, y)) printf(\"?\\n\");\n            else printf(\"%lld\\n\", T.depth(x) - T.depth(y));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\ntemplate<typename T>\nstruct WeightedUnionFind {\n    T d;\n    vector<int> r, p;\n    vector<T> ws;\n\n    WeightedUnionFind() {}\n\n    WeightedUnionFind(int n, T d) :\n            d(d), r(n, 1), p(n), ws(n, d) { iota(p.begin(), p.end(), 0); }\n\n    int find(int x) {\n        if (x == p[x]) return x;\n        int t = find(p[x]);\n        ws[x] += ws[p[x]];\n        return p[x] = t;\n    }\n\n    T weight(int x) {\n        find(x);\n        return ws[x];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    void unite(int x, int y, T w) {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (r[x] < r[y]) swap(x, y), w = -w;\n        r[x] += r[y];\n        p[y] = x;\n        ws[y] = w;\n    }\n\n    T diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    WeightedUnionFind<int> uf(n, 0);\n\n    rep(i, q) {\n        int query;\n        cin >> query;\n        if (query == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (uf.same(x, y)) {\n                cout << uf.diff(x, y) << endl;\n            } else {\n                cout << '?' << endl;\n            }\n        }\n    }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstddef>\n#include <tuple>\n#include <utility>\n#include <vector>\n\ntemplate <class Abelian> class PotentializedUnionFind {\n\npublic:\n  using value_type = Abelian;\n  using size_type = std::size_t;\n  using container_type =\n      std::vector<std::tuple<size_type, value_type, size_type>>;\n\nprotected:\n  container_type c;\n\nprivate:\n  size_type &par(const size_type i) { return std::get<0>(c[i]); }\n  value_type &val(const size_type i) { return std::get<1>(c[i]); }\n  size_type &siz(const size_type i) { return std::get<2>(c[i]); }\n  value_type potential(size_type x) {\n    value_type ret = {};\n    while (x != par(x)) {\n      val(x) = val(x) + val(par(x));\n      ret = ret + val(x);\n      x = par(x) = par(par(x));\n    }\n    return std::move(ret);\n  }\n\npublic:\n  PotentializedUnionFind() : c() {}\n  explicit PotentializedUnionFind(const size_type size)\n      : c(size, std::forward_as_tuple(static_cast<size_type>(0), value_type(),\n                                      static_cast<size_type>(1))) {\n    for (size_type i = 0; i < size; ++i)\n      par(i) = i;\n  }\n\n  size_type size() const { return c.size(); }\n  bool empty() const { return c.empty(); }\n\n  size_type find(size_type x) {\n    assert(x < size());\n    while (x != par(x)) {\n      val(x) = val(x) + val(par(x));\n      x = par(x) = par(par(x));\n    }\n    return x;\n  }\n  value_type diff(const size_type x, const size_type y) {\n    assert(x < size());\n    assert(y < size());\n    assert(same(x, y));\n    return potential(y) + (-potential(x));\n  }\n  bool same(const size_type x, const size_type y) {\n    assert(x < size());\n    assert(y < size());\n    return find(x) == find(y);\n  }\n  size_type size(const size_type x) {\n    assert(x < size());\n    return siz(find(x));\n  }\n\n  bool unite(size_type x, size_type y, value_type d) {\n    assert(x < size());\n    assert(y < size());\n    d = d + potential(x) + (-potential(y));\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return false;\n    if (siz(x) < siz(y))\n      std::swap(x, y), d = -d;\n    siz(x) += siz(y);\n    par(y) = x;\n    val(y) = std::move(d);\n    return true;\n  }\n};\n\n#include<iostream>\n  \nint main() {\n    int n, q;\n    std::cin >> n >> q;\n    PotentializedUnionFind<int> T(n);\n    while (q--) {\n        int t, x, y, z;\n        std::cin >> t >> x >> y;\n        if (t) {\n            if (T.same(x, y))\n                std::cout << T.diff(x, y) << std::endl;\n            else\n                std::cout << \"?\" << std::endl;\n        }\n        else {\n            std::cin >> z;\n            T.unite(x, y, z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nstruct UFweight\n{\n    int i;\n    vector<int> par;\n    vector<int> size;\n    vector<int> rank;\n    vector<ll> diff_weight;\n    UFweight(int n, ll sum_unity = 0){\n        par.resize(n);  rank.resize(n); size.resize(n); diff_weight.resize(n);\n        for(i = 0;i < n;++i){\n            par.at(i) = i;\n            rank.at(i) = 0;\n            size.at(i) = 1;\n            diff_weight.at(i) = sum_unity;\n        }\n    }\n    \n    int root(int x){\n        if(par.at(x) == x){\n            return x;\n        }else{\n            int r = root(par.at(x));\n            diff_weight.at(x) += diff_weight.at(par.at(x));\n            return par.at(x) = r;\n        }\n    }\n    \n    ll weight(int x){\n        root(x);\n        return diff_weight.at(x);\n    }\n    \n    ll get_diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n    \n    // weight(y) - weight(x) = wとなるようにmerge\n    bool merge(int x, int y, ll w){\n        w += weight(x); w -= weight(y);\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry){\n            ll weight_diff = get_diff(rx, ry);\n            if(weight_diff == w) return true;\n            else return false;\n        }\n        \n        if(rank.at(rx) < rank.at(ry)){\n            swap(rx,ry);\n            w *= -1;\n        }\n        if(rank.at(rx) == rank.at(ry)) ++rank.at(rx);\n        par.at(ry) = rx;\n        diff_weight.at(ry) = w;\n        size.at(rx) += size.at(ry);\n        \n        return true;\n    }\n    \n    bool same(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n    \n    int get_size(int x){\n        return size.at(root(x));\n    }\n};\n\nint main()\n{\n    ll i,j;\n    ll n,q;\n    cin >> n >> q;\n    UFweight uf(n);\n    for(i = 0;i < q;++i){\n        ll com;\n        cin >> com;\n        if(com == 0){\n            ll x,y,z;\n            cin >> x >> y >> z;\n            uf.merge(x, y, z);\n        }else{\n            ll x, y;\n            cin >> x >> y;\n            if(uf.same(x, y)){\n                cout << uf.get_diff(x, y) << endl;\n            }else{\n                cout << '?' << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass UnionFindTrees{\n  public:\n    vector<int> rank, p, diffWeight;\n\n    UnionFindTrees(){}\n    UnionFindTrees(int size){\n      rank.resize(size, 0);\n      p.resize(size, 0);\n      diffWeight.resize(size, 0);\n      for(int i=0 ; i<size ; ++i) makeSet(i);\n    }\n    ~UnionFindTrees(){}\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n      diffWeight[x] = 0;\n    }\n\n    void relate(int x, int y, int z){\n      z -= diffWeight[x];\n      z += diffWeight[y];\n\n      x = findSet(x);\n      y = findSet(y);\n\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        diffWeight[y] = -z;\n      }else{\n        p[x] = y;\n        diffWeight[x] = z;\n        if(rank[x] == rank[y]) rank[y] = rank[y]+1;\n      }\n    }\n\n    bool same(int x, int y){\n      return findSet(x) == findSet(y);\n    }\n\n    int findSet(int x){\n      if(x != p[x]){\n        p[x] = findSet(p[x]);\n        diffWeight[x] += diffWeight[p[x]];\n      }\n      return p[x];\n    }\n\n    int getWeight(int x){\n      findSet(x);\n      return diffWeight[x];\n    }\n\n    void diff(int x, int y){\n      //cout << \"y=\"<< y << \", x=\" << x << endl;\n      //cout << \"weighty=\"<<diffWeight[y] << \", weightx=\" << diffWeight[x] << endl;\n      //if(same(x, y)) cout << (getWeight(y)-getWeight(x)) << endl;\n      if(same(x, y)) cout << abs(diffWeight[y]-diffWeight[x]) << endl;\n      else cout << \"?\" << endl;\n    }\n};\n\nint main(){\n  int n=0, q=0;\n  int com=0, x=0, y=0, z=0;\n\n  cin >> n >> q;\n  UnionFindTrees uft = UnionFindTrees(n);\n\n  for(int i=0 ; i<q ; ++i){\n    cin >> com;\n\n    if(com == 0){\n      cin >> x >> y >> z;\n      uft.relate(x, y, z);\n    }\n    else if (com == 1){\n      cin >> x >> y;\n      uft.diff(x, y);\n    }\n  }//---- end of for ----\n  for(int i=0 ;  i<n ; ++i){\n    //cout << \"i=\" << i << \", \" << uft.p[i] << \", \" << uft.rank[i]<< \", \" << uft.diffWeight[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass disjoint_set {\n  public:\n  vector<int> rank, prt, ptl;\n  disjoint_set (int size) {\n    rank.resize(size);\n    prt.resize(size);\n    ptl.resize(size);\n    for (int i = 0; i < size; i++) {\n      prt[i] = i;\n      rank[i] = 0;\n      ptl[i] = 0;\n    }\n  }\n  int find (int x) {\n    if (x == prt[x]){\n      return x;\n    } else {\n      int r = find(prt[x]);\n      ptl[x] += ptl[prt[x]];\n      return prt[x] = r;\n    }\n  }\n  bool is_equiv (int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite (int x, int y, int w) {\n    if (find(x) == find(y)) {\n      return false;\n    }\n    w += ptl[x];\n    w -= ptl[y];\n    x = find(x);\n    y = find(y);\n    if (rank[x] < rank[y]) {\n      swap(x, y);\n      w *= -1;\n    }\n    prt[y] = x;\n    ptl[y] = w;\n    if (rank[x] == rank[y]) {\n      rank[x]++;\n    }\n    return true;\n  }\n  int diff (int x, int y) {\n    find(x);\n    find(y);\n    return ptl[y] - ptl[x];\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  disjoint_set djs(n);\n  while (q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      djs.unite(x, y, z);\n    } else {\n      int x, y;\n      cin >> x >> y;\n      if (!djs.is_equiv(x, y)) {\n        cout << \"?\" << '\\n';\n      } else {\n        cout << djs.diff(x, y) << '\\n';\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\ntemplate<typename T>\nclass WeightedUnionFind {\n    int N;\n    vector<int> par;\n    vector<int> rank;\n    vector<int> size;\n    vector<T> weight;\n\npublic:\n    explicit WeightedUnionFind(int n) : N(n + 1) {\n        par.resize(n + 1);\n        rank.resize(n + 1, 0);\n        weight.resize(n + 1, 0);\n        size.resize(n + 1, 1);\n        for (int i = 0; i < n + 1; ++i) {\n            par[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) return x;\n        int y = find(par[x]);\n        weight[x] += weight[par[x]];\n        par[x] = y;\n        return y;\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    T get_weight(int x) {\n        find(x);\n        return weight[x];\n    }\n\n    /**\n     * x -> y の重みの差分\n     */\n    T diff(int x, int y) {\n        return get_weight(y) - get_weight(x);\n    }\n\n    /**\n     * get_weight(y) - get_weight(x) = w となるように結合\n     * @return true:　結合成功, false: すでに結合済み\n     */\n    bool unit(int x, int y, T w) {\n        w += get_weight(x);\n        w -= get_weight(y);\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        // 木の高さの低い方から高い方へ繋げる\n        if (rank[x] < rank[y]) swap(x, y), w = -w;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        weight[y] = w;\n        size[x] += size[y];\n        return true;\n    }\n};\n\nvoid Main() {\n    ll N, Q;\n    cin >> N >> Q;\n    WeightedUnionFind<ll> weightedUnionFind(N);\n    rep(q, Q) {\n        int query;\n        cin >> query;\n        if (query) {\n            int x, y;\n            cin >> x >> y;\n            if (weightedUnionFind.is_same(x, y)) {\n                cout << weightedUnionFind.diff(x, y) << '\\n';\n            } else {\n                cout << \"?\" << '\\n';\n            }\n        } else {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            weightedUnionFind.unit(x, y, z);\n        }\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename Abel>\nstruct WeightedUnionFind{\n    int num;\n    vector<int> par,rank;\n    vector<Abel> diff_weight;\n    WeightedUnionFind(int n,Abel id=0):\n        num(n),par(n),rank(n,1),diff_weight(n,Abel(0)){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        if (x==par[x]) return x;\n        int t=root(par[x]);\n        diff_weight[x]+=diff_weight[par[x]];\n        return par[x]=t;\n    }\n    bool merge(int x,int y,Abel w){\n        w+=weight(x),w-=weight(y);\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y),w=-w;\n        par[y]=x;\n        rank[x]+=rank[y];\n        diff_weight[y]=w;\n        --num;\n        return true;\n    }\n    Abel weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    Abel diff(int x,int y){return weight(y)-weight(x);}\n    bool same(int x,int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n};\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_B\n\nvoid DSL_1_B(){\n    int n,q; cin >> n >> q;\n    WeightedUnionFind<int> uf(n);\n    for (;q--;){\n        int c,x,y,z; cin >> c >> x >> y;\n        if (!c){\n            cin >> z;\n            uf.merge(x,y,z);\n        } else {\n            if (uf.same(x,y)) cout << uf.diff(x,y) << '\\n';\n            else cout << '?' << '\\n';\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    DSL_1_B();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\nstruct pUF{\n    vector<ll> r, par;\n    pUF(int n):r(n),par(n,-1){};\n\n    int find(int x){\n       if(par[x]<0)\n           return x;\n       int y = find(par[x]);\n       r[x] += r[par[x]];\n       return par[x] = y;\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    \n    ll weight(int x){\n       find(x);\n       return r[x];\n    }\n\n    ll diff(int x,int y){//weigth(y)-weight(x)を出力\n        return weight(y)-weight(x);\n    }\n    \n    bool unite(ll c,int x, int y){//weight(y)-weight(x)=cとなるようにつなぐ\n        c -= weight(y);\n        c += weight(x);\n        x = find(x);\n        y = find(y);\n        if(x!=y){\n           par[y] = x;\n           r[y] = c;\n           return true;\n       }\n       return false;\n    }\n};\nint main(){\n    int n;\n    cin>>n;\n    pUF uf(n);\n    int q;\n    cin>>q;\n    rep(i,q){\n        int t;\n        cin>>t;\n        if(t){\n            int x,y;\n            cin>>x>>y;\n            cout<<endl;\n            if(uf.same(x,y))cout<<uf.diff(x,y)<<endl;\n            else cout<<\"?\"<<endl;\n        }\n        else {\n            int x,y,z;\n            cin>>x>>y>>z;\n            uf.unite(z,x,y);\n        }\n    }\n\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<cinttypes>\n#include<algorithm>\n#include<numeric>\nclass union_find {\n//\tstd::vector <T>;\npublic:\n\tusing value_type = std::int32_t;\nprivate:\n\tstd::vector<value_type> parent_, size_;\n\n\tstd::vector<value_type> weight_;\n\npublic:\n\tunion_find()\n\t\t:parent_{}, size_{}, weight_{} {}\n\n\tunion_find(unsigned int n)\n\t\t: parent_{}, size_{}, weight_{}{\n\t\t\n\t/*\n\t\tdata.resize(n);\n\t\tfor (int i{}; i < data.size(); ++i)\n\t\t\tdata[i] = i;\n\t*/\n\t\tparent_.resize(n);\n\t\tstd::iota(std::begin(parent_), std::end(parent_), 0);\n\n\t\tsize_.resize(n, 1);\n\t\tweight_.resize(n, 0);\n\t}\n\n\tauto root(value_type  x)->decltype(parent_)::value_type {\n\t\t//auto x = static_cast<const std::uint32_t>(index);\n\t\tif (parent_[x] == x)\n\t\t\treturn x;\n\t\telse {\n\t\t\tauto r = root(parent_[x]);\n\n\t\t\tweight_[x] += weight_[ parent_[x] ];\n\n\t\t\treturn parent_[x] = r;\n\t\t}\n\t}\n\n\tauto size(value_type  x) {\n\t\treturn size_[root(x)];\n\t}\n\n\tauto unite(value_type  t, value_type s) {\n//\t\tstd::cout << \"unite:\";\n\t\tauto x = root(t);\n\t\tauto y = root(s);\n//\t\tstd::cout << x << \" \" << y << \" \";\n\t\tif ( x == y )\n\t\t\treturn;\n\n\t\tauto sx = size(x);\n\t\tauto sy = size(y);\n\n\t\tif (sx < sy)\n\t\t\tstd::swap(x, y);\n\n\t\tif (sx == sy)\n\t\t\t\t++size_[ x ];\n\n\t\t\tparent_[x] = y;\n\n\t}\n\n\tauto same(value_type  t, value_type  s){\n\t\treturn \n\t\t\troot(t) == root(s);\n\t}\n\n\t\n\tauto weight(value_type  x) {\n\t\troot(x);\n\t\treturn \n\t\t\tthis->weight_[x];\n\t}\n\n\tauto relate(value_type  t, value_type  s, value_type  weight_v) {\n\n\t\tauto rt = root(t);\n\t\tauto rs = root(s);\n\t\tif (rt == rs)\n\t\t\treturn;\n\n\n\t\tweight_v += weight(t);//\n\t\tweight_v -= weight(s);\n\n\t\tauto st = size(rt);\n\t\tauto ss = size(rs);\n\n\t\tif (st < ss) {\n\t\t\tstd::swap(st, ss);\n\t\t\tstd::swap(rt, rs);\n\t\t\tweight_v *= -1;\n\t\t}\n\n\t\tif (st == ss)\n\t\t\t++size_[rt];\n\t\t\n\t\tparent_[rs] = rt;\n\t\tweight_[rs] += weight_v;\n\t\tsize_[rt] += ss;\n\t\t\n\n\t}\n\n\tauto diff(value_type  t, value_type  s)->decltype(weight_)::value_type{\n//\t\tif (!this->same(t, s))\n//\t\t\treturn -1;\n//\t\telse\n\t\t\treturn weight_[s] - weight_[t];\n\t}\n\n};\n\nint main() {\n\tstd::uint32_t n, q;\n\tstd::cin >> n >> q;\n\tunion_find uf{ n };\n\n\tfor (std::uint32_t i{}; i < q; ++i) {\n\t\tint c, x, y;\n\t\tstd::cin >> c >> x >> y;\n\n\t\tif (c == 0) {\n\t\t\tdecltype(n) w;\n\t\t\tstd::cin >> w;\n//\t\t\tuf.unite(x, y);\n\t\t\tuf.relate(x, y, w);\n//\t\t\tstd::cout <<(uf.same(x, y) ? \"yes\" : \"no\" )<< \"\\n\";\n//\t\t\tstd::cout << uf.root(x) << \" \" << uf.root(y) << \"\\n\";\n//\t\t\tstd::cout <<\"size: \"<< uf.size(x) << \" \" << uf.size(y) << \"\\n\";\n//\t\t\tstd::cout << w << \" \" << uf.weight(x) << \" \" << uf.weight(y) << \"\\n\";\n\t\t}\n\t\telse {\n//\t\t\tstd::cout <<( uf.same(x, y) ? 1 : 0 )<< \"\\n\";\n//\t\t\tstd::cout <<\"wght : \" <<uf.weight(x) << \" \" << uf.weight(y) << \"\\n\";\n//\t\t\tauto res = uf.diff(x, y);\n\t\t\tif (uf.same(x,y))\n\t\t\t\tstd::cout << uf.diff(x, y) << \"\\n\";\n\t\t\telse\n\t\t\t\tstd::cout << \"?\\n\";\n\t\t\t\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <boost/optional.hpp>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\n#define REP(i, n) for(int i = 0, i##_MACRO = (n); i < i##_MACRO; i++)\n#define RANGE(i, a, b) for(int i = (a), i##_MACRO = (b); i < i##_MACRO; i++)\n#define EACH(e, a) for(auto&& e : a)\n#define ALL(a) (a).begin(), (a).end()\n#define AALL(a, n) (a), ((a) + (n))\n#define FILL(a, n) memset((a), n, sizeof(a))\n#define FILLZ(a) FILL(a, 0)\n#define MODNUM (static_cast<int>(1e9 + 7))\n#define MOD(x) ((x) % MODNUM)\n\nusing namespace std;\n\nusing ll = long long;\nusing VI = vector<int>;\nusing VI2D = vector<vector<int>>;\n\nconst int INF = 2e9;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\ninline int toInt(string s) {\n\tint v;\n\tistringstream sin(s);\n\tsin >> v;\n\treturn v;\n}\n\ntemplate <typename T = int>\nclass WeightedUnionFind {\n\tstd::vector<size_t> parents;\n\tstd::vector<size_t> rank;\n\tstd::vector<T> diff_weight;\n\tT identity;\n\n\tpublic:\n\tWeightedUnionFind(size_t size, T id = static_cast<T>(0))\n\t\t: parents(size), rank(size, 0), diff_weight(size, id), identity(id) {\n\t\tstd::iota(this->parents.begin(), this->parents.end(), 0);\n\t}\n\n\tbool merge(size_t a, size_t b, T w) {\n\t\tsize_t ar = this->root(a);\n\t\tsize_t br = this->root(b);\n\t\tT dw = w + weight(a) - weight(b);\n\t\tif(ar == br) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this->rank[ar] < this->rank[br]) {\n\t\t\tstd::swap(ar, br);\n\t\t\tdw = -dw;\n\t\t}\n\t\tif(this->rank[ar] == this->rank[br]) {\n\t\t\tthis->rank[ar]++;\n\t\t}\n\t\tthis->diff_weight[br] = dw;\n\t\tthis->parents[br] = ar;\n\t\treturn true;\n\t}\n\tbool unite(size_t a, size_t b, T w) { return this->merge(a, b, w); }\n\n\tbool is_same(size_t a, size_t b) { return this->root(a) == this->root(b); }\n\tbool is_union(size_t a, size_t b) { return this->is_same(a, b); }\n\n\tboost::optional<T> diff(size_t a, size_t b) {\n\t\tif(!this->is_same(a, b)) {\n\t\t\treturn boost::none;\n\t\t}\n\t\treturn boost::optional<T>(this->weight(b) - this->weight(a));\n\t}\n\n\tprivate:\n\tsize_t root(int n) {\n\t\tif(this->parents[n] == n) {\n\t\t\treturn n;\n\t\t}\n\n\t\tsize_t r = this->root(this->parents[n]);\n\t\tthis->diff_weight[n] += this->diff_weight[this->parents[n]];\n\t\tthis->parents[n] = r;\n\t\treturn r;\n\t}\n\n\tT weight(size_t n) {\n\t\troot(n);\n\t\treturn this->diff_weight[n];\n\t}\n};\n\nint main() {\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\tVI s(n);\n\tVI com(q);\n\tVI x(q);\n\tVI y(q);\n\tVI z(q);\n\tREP(i, q) {\n\t\tscanf(\"%d\", &com[i]);\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tif(!com[i]) {\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t}\n\t}\n\n\tWeightedUnionFind<int> wuf(n);\n\tREP(i, q) {\n\t\tif(com[i]) {\n\t\t\tif(const boost::optional<int> d = wuf.diff(x[i], y[i])) {\n\t\t\t\tprintf(\"%d\\n\", *d);\n\t\t\t} else {\n\t\t\t\tputs(\"?\");\n\t\t\t}\n\t\t} else {\n\t\t\twuf.merge(x[i], y[i], z[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nclass UnionFind{\nprivate:\n    vector<int> data;\n    vector<LL> diff_weight;\npublic:\n    UnionFind(int size) : data(size,-1), diff_weight(size, 0){}\n    int root(int x){\n        if(data[x] < 0){\n            return x;\n        }else{\n            root(data[x]);\n            diff_weight[x] += diff_weight[data[x]];\n            return data[x] = root(data[x]);\n        }\n    }\n    int weight(int x){\n        root(x);\n        return diff_weight[x];\n    }\n    bool connect(int x,int y, LL w){\n\n        w += weight(x);w -= weight(y);\n        x = root(x);y = root(y);\n        if(x != y){\n            if(data[x] > data[y])swap(x,y), w = -w;\n            data[x] += data[y];data[y] = x;\n            diff_weight[y] = w;\n        }\n        return x != y;\n    }\n    bool check(int x,int y){\n        return root(x) == root(y);\n    }\n    int Size(int x){\n        return -data[x];\n    }\n    int diff(int a, int b){\n        return weight(b) - weight(a);\n    }\n};\n\nint main(){\n   int N,q;cin >> N >> q;\n   UnionFind Uni(N);\n   for(int a = 0;a < q;a++){\n       int x;cin >> x;\n       if(x == 0){\n           int d,e,f;cin >> d >> e >> f;\n           Uni.connect(d,e,f);\n       }else{\n           int d,e;cin >> d >> e;\n           if(Uni.check(d,e))cout<<Uni.diff(d,e)<<endl;\n           else cout<<\"?\"<<endl;\n       }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass WeightedUnionFind {\npublic:\n    vector<int> parents, rank, diff_weight;\n\n    WeightedUnionFind(int n) : parents(n), rank(n), diff_weight(n) {\n        for (int i = 0; i < n; i++) {\n            parents[i] = i;\n            rank[i] = 0;\n            diff_weight[i] = 0;\n        }        \n    }\n\n    int root(int x) {\n        if (parents[x] == x) { // root\n            return x;\n        } else {\n            int r = root(parents[x]);\n            diff_weight[x] += diff_weight[parents[x]];\n            return parents[x] = r;\n        }\n    }\n\n    bool isSame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool unite(int x, int y, int w) {\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if (x == y) return false;\n\n        if (rank[x] < rank[y]) {\n            swap(x, y);\n            w = -w;\n        }\n\n        if (rank[x] == rank[y]) ++rank[x];\n        parents[y] = x;\n\n        diff_weight[y] = w;\n\n        return true;\n    }\n\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main(void) {\n\n    int n, q; cin >> n >> q;\n    WeightedUnionFind wuf(n);\n\n    for (int i = 0; i < q; i++) {\n        int type; cin >> type;\n        if (type == 0) {\n            int x, y, z; cin >> x >> y >> z;            \n            wuf.unite(x, y, z);\n        } else if (type == 1) {\n            int x, y; cin >> x >> y;\n            if (!wuf.isSame(x, y)) cout << \"?\" << endl;\n            else cout << wuf.diff(x, y) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for (ll(i) = (m); (i) < (n); ++(i))\n#define REP(i, n) FOR(i, n, 0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1e15;\n\nclass UnionFind\n{\n  public:\n    UnionFind(int n)\n        : mN(n)\n    {\n        REP(i, n)\n        {\n            mNodeTbl.push_back(i);\n            mWaightTbl.push_back(0);\n        }\n    }\n\n    int find(int x)\n    {\n        if (x == mNodeTbl[x])\n            return x;\n\n        int par = mNodeTbl[x];\n        mNodeTbl[x] = find(mNodeTbl[x]);\n        mWaightTbl[x] += mWaightTbl[par];\n        return mNodeTbl[x];\n    }\n    bool same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    ll waight(int x)\n    {\n        int y = find(x);\n        return mWaightTbl[x] - mWaightTbl[y];\n    }\n\n    //! y bigger than x\n    void unit(int x, int y, ll w)\n    {\n        int ox = x, oy = y;\n        x = find(x);\n        y = find(y);\n        ll wx = mWaightTbl[ox];\n        ll wy = mWaightTbl[oy];\n        if (x == y)\n            return;\n        w = w + wx - wy;\n        if (w < 0)\n        {\n            //! xにyをつなぐ\n            mNodeTbl[y] = x;\n            mWaightTbl[y] = mWaightTbl[x] - abs(w);\n        }\n        else\n        {\n            //! yにxをつなぐ\n            mNodeTbl[x] = y;\n            mWaightTbl[x] = mWaightTbl[y] - abs(w);\n        }\n    }\n\n  private:\n    int mN;\n    vector<int> mNodeTbl;\n    vector<ll> mWaightTbl;\n};\n\nint main()\n{\n    ll N, Q;\n    cin >> N >> Q;\n    UnionFind uf(N);\n    REP(i, Q)\n    {\n        int c;\n        cin >> c;\n        if (c == 0)\n        {\n            ll x, y, z;\n            cin >> x >> y >> z;\n            uf.unit(x, y, z);\n        }\n        else if (c == 1)\n        {\n            ll x, y;\n            cin >> x >> y;\n            if (uf.same(x, y))\n                cout << uf.waight(y) - uf.waight(x) << endl;\n            else\n                cout << '?' << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\nusing lint = int64_t;\n\nstruct WeightedUnionFind {\n    vector<int> par, wei;\n    WeightedUnionFind (int N) : par(N, -1), wei(N, 0) {}\n    int root(int x) {\n        if (par[x] < 0) {\n            return x;\n        } else {\n            int rx = root(par[x]);\n            wei[x] += wei[par[x]];\n            return par[x] = rx;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int weight(int x) {\n        root(x);\n        return wei[x];\n    }\n    int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    bool unite(int x, int y, int w) {\n        int rx = root(x);\n        int ry = root(y);\n        if (rx == ry) return diff(x, y) == w;\n        w += wei[x];\n        w -= wei[y];\n        if (par[rx] > par[ry]) {\n            swap(rx, ry);\n            w = -w;\n        }\n        par[rx] += par[ry];\n        par[ry] = rx;\n        wei[ry] = w;\n        return true;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    WeightedUnionFind WUF(n);\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int num;\n        cin >> num;\n        if (num == 0) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            WUF.unite(x, y, z);\n        } else {\n            int x, y;\n            cin >> x >> y;\n            if (WUF.same(x, y)) cout << WUF.diff(x, y) << \"\\n\";\n            else cout << \"?\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nclass DisjointSet {\nprivate:\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sz;\t// 要素の個数\n  int set_sz;\t\t\t// 集合の個数\npublic:\n  DisjointSet() : set_sz(0) {}\n  DisjointSet(int n) { init(n); }\n  void init(int n) {\n    par.resize(n); rank.resize(n, 0); sz.resize(n, 1); set_sz = n;\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int set_size() { return set_sz; }\n  int size(int v) { return sz[root(v)]; }\n  int root(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return;\n    if (rank[x] < rank[y])\n      par[x] = y;\n    else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n    sz[x] += sz[y];\n    sz[y] = sz[x];\n    set_sz--;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  friend ostream& operator<<(ostream& o, const DisjointSet& ds) {\n    o << \"\\nparent : \" << ds.par << \"\\nrank : \" << ds.rank << \"\\nsize : \" << ds.sz << \"\\nsize of set : \" << ds.set_sz << '\\n';\n    return o;\n  }\n};\n\ntemplate<typename T>\nclass WeightedDisjointSet {\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sz;\n  vector<T> potential;\n  int set_sz;\npublic:\n  WeightedDisjointSet() {}\n  WeightedDisjointSet(int n, const T& unit = 0) {\n    init(n, unit);\n  }\n  void init(int n, const T& unit = 0) {\n    par.resize(n); rank.resize(n, 0); sz.resize(n, 1); potential.resize(n, unit); set_sz = n;\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int set_size() const { return set_sz; }\n  int size(int v) { return sz[root(v)]; }\n  int root(int x) {\n    if (par[x] == x) return x;\n    else {\n      int r = root(par[x]);\n      potential[x] += potential[par[x]];\n      return par[x] = r;\n    }\n  }\n  T weight(int x) {\n    root(x);\n    return potential[x];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  bool unite(int x, int y, T d) {\n    d += weight(x); d -= weight(y);\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), d = -d;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    potential[y] = d;\n    sz[x] += sz[y];\n    sz[y] = sz[x];\n    set_sz--;\n    return true;\n  }\n  T diff(int x, int y) {\n    return weight(y) - weight(x);\n  }\n  friend ostream& operator<<(ostream& o, const WeightedDisjointSet& ds) {\n    o << \"\\npotential : \" << ds.potential << \"\\nparent : \" << ds.par << \"\\nrank : \" << ds.rank << \"\\nsize : \" << ds.sz << \"\\nsize of set : \" << ds.set_sz << '\\n';\n    return o;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n, q;\n  cin >> n >> q;\n  WeightedDisjointSet<int> ds(n);\n  rep(_, q) {\n    int t, x, y, d;\n    cin >> t >> x >> y;\n    switch (t) {\n    case 0:\n      cin >> d;\n      ds.unite(x, y, d);\n      break;\n    case 1:\n      cout << (ds.same(x, y) ? to_string(ds.diff(x, y)) : \"?\") << '\\n';\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Weighted-Union-Find木\n//参考 https://qiita.com/drken/items/cce6fc5c579051e64fab\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_B\n\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate <typename T>\nstruct Weighted_Union_Find {\n\n  vector<T> par;//親の番号\n  vector<T> urank;//集合のランク\n  vector<T> usize;//集合の要素数\n  vector<T> diff_weight;//親との距離\n  T num;//集合の数\n\n  Weighted_Union_Find() {\n    init(100000);\n  }\n\n  Weighted_Union_Find(T n) {\n    init(n);\n  }\n\n  void init(T n) {//0〜n-1までの要素を初期化 最初はバラバラ\n    par.clear();urank.clear();usize.clear();diff_weight.clear();\n    par.resize(n);urank.resize(n);usize.resize(n);diff_weight.resize(n);\n    num = n;\n    rep(i,n) {\n      par[i] = i;\n      urank[i] = (T)0;\n      usize[i] = (T)1;\n      diff_weight[i] = (T)0;\n    }\n  }\n\n  T find(T x) {//根の添字を返すと同時に経路圧縮をする\n    if(par[x] == x) {\n      return x;\n    } else {\n      T r = find(par[x]);\n      diff_weight[x] += diff_weight[par[x]];//累積和\n      return par[x] = r;\n    }\n  }\n\n  T get_usize(T x) {//xが属する集合の要素数を返す。\n    return usize[find(x)];\n  }\n\n  bool unite(T x,T y,T w) {//weight(y) = weight(x) + w (diff(x,y) = w) となるようにxの属する集合とyの属する集合をマージ\n    if(urank[x] < urank[y]) {swap(x,y);w*=-1;}//x(のroot)の下にy(のroot)をつけるので反転\n\n    w += weight(x);w -= weight(y);\n    //x(のroot)の下にy(のroot)をつけるので、w=diff(xのroot,yのroot)となるように\n\n    x = find(x);//xの親\n    y = find(y);//yの親\n    if(x == y) { \n      return diff(x,y) == w;//falseの時矛盾が生じている\n    }\n\n    //x(のroot)の下にy(のroot)をつける。\n    usize[x] = usize[x] + usize[y];\n    num--;\n    if(urank[x] == urank[y]) urank[x]++;\n    par[y] = x;\n\n    diff_weight[y] = w;\n\n    return true;\n  }\n\n  bool same(T x,T y) {//同じ集合に属するかを判定する\n    return find(x) == find(y);\n  }\n\n  T weight(T x) {//親との距離を求める\n    find(x);\n    return diff_weight[x];\n  }\n\n  T diff(T x,T y) {//xからyに行くときのポテンシャルの増加分 same関数で一緒かどうか調べてから使う\n    return weight(y) - weight(x);\n  }\n\n  T num_set() {//集合の数(木の数)を返す。\n    return num;\n  }\n};\n\nusing ll = long long;\n\nll n,q;\n\nint main() {\n    cin >> n >> q;\n    Weighted_Union_Find<ll> wuf(n);\n\n    rep(i,q) {\n      ll com,x,y,z;\n      cin >> com;\n      if(com) {\n        cin >> x >> y;\n          if(wuf.same(x,y))cout << wuf.diff(x,y) << endl;\n          else cout << \"?\" << endl;\n      }else {\n        cin >> x >> y >> z;;\n        wuf.unite(x,y,z);\n      }\n  }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {}, rr[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tbool f = false;\n\t\tint i;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(p[i] == y && i != y){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"ここ1\" << endl;\n\t\tif(f){\n\t\t\tif(r[i] <= z){\n\t\t\t\tp[x] = i;\n\t\t\t\tp[i] = y;\n\t\t\t\tr[x] = z-r[i];\n\t\t\t\tr[i] = z;\n\t\t\t\trr[i] = rr[x]+1;\n\t\t\t\trr[y] = rr[i]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i] = x;\n\t\t\t\tr[i] = r[i]-z;\n\t\t\t\tp[x] = y;\n\t\t\t\tr[x] = z;\n\t\t\t\trr[y] = rr[x]+1;\n\t\t\t\trr[i] = rr[y]+1;\n\t\t\t}\n\t\t\t//cout << \"ここ2\" << endl;\n\t\t}\n\t\telse{\n\t\t\tp[x] = y;\n\t\t\tr[x] = z;\t//r[]でdiffの判定の役割をなす\n\t\t\trr[y] = rr[x] + 1;\n\t\t}\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\trr[y] = rr[x]+1;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint returnQuery(int x,int y){\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n}\n//diffの合計を求める式\n\nvoid uni(int x,int y, int z){\n\tlink(x, y, z);\n}\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tuni(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//cout << \"ここ\" << endl;\n\t\t\t\tif(rr[b] >= rr[c]){\n\t\t\t\t\tcout << returnQuery(b,c) << endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << -1*returnQuery(c,b) << endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind{\npublic:\n\tvector<int> Parent;\n\tvector<int> Rank;\n\tvector<long long> Weight;\n\tWeightedUnionFind(int n){\n\t\t++n;\n\t\tParent.resize(n, 0);\n\t\tRank.resize(n, 0);\n\t\tWeight.resize(n, 0);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tParent[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(Parent[x] == x) return x;\n\t\tint pastparent = Parent[x];\n\t\tParent[x] = find(Parent[x]);\n\t\tWeight[x] += Weight[pastparent];\n\t\treturn Parent[x];\n\t}\n\n\tvoid unite(int x, int y, long long z){ // a[y] - a[x] == z\n\t\tz += Weight[y] - Weight[x];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(Rank[x] < Rank[y]){\n\t\t\tParent[x] = y;\n\t\t\tWeight[x] = z;\n\t\t}else{\n\t\t\tParent[y] = x;\n\t\t\tWeight[y] = -z;\n\t\t\tif(Rank[x] == Rank[y]) ++Rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tlong long cost(int x, int y){ // call if only same(x, y) == true\n\t\tfind(x); find(y);\n\t\treturn Weight[x] - Weight[y];\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tWeightedUnionFind wuf(n);\n\tfor(int i=0; i<q; ++i){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 0){\n\t\t\tint x, y;\n\t\t\tlong long z;\n\t\t\tcin >> x >> y >> z;\n\t\t\twuf.unite(x, y, z);\n\t\t}else{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif(wuf.same(x, y)) cout << wuf.cost(x, y) << \"\\n\";\n\t\t\telse cout << \"?\\n\";\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAX 100002\n\nint p[MAX];\nint diff_w[MAX];\nint r[MAX];\n\nint root(int x){\n    if(p[x]==x)return x;\n    int r = root(p[x]);\n    diff_w[x] += diff_w[p[x]];\n    return p[x] = r;\n}\n\nvoid diff(int x,int y){\n  if(root(x)==root(y))cout<<diff_w[y] - diff_w[x]<<endl;\n  else cout<<\"?\"<<endl;\n}\nbool same(int x,int y){\n  return root(x)==root(y);\n}\nvoid Union(int x,int y){\n  p[x]=y;\n}\n\nvoid merge(int x,int y,int w){\n  int rx = root(x);\n  int ry = root(y);\n  w = w + diff_w[x] - diff_w[y];\n  if(r[rx]<r[ry]) {\n    swap(rx,ry);\n    w = -w;\n  }\n  r[rx]+=r[ry];\n  p[ry] = rx;\n  diff_w[ry] = w;\n}\n\nint main(){\n  int n,q,x,y,z,rx,ry,flag;\n  cin>>n>>q;\n  for(int i=0;i<n+1;i++){\n    p[i] = i;\n    r[i] = 1;\n  }\n  for(int i=0;i<q;i++){\n    cin>>flag>>x>>y;\n    if(flag==1){\n      diff(x,y);\n    }\n    else{\n      cin>>z;\n      merge(x,y,z);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\nusing VB = vector<bool>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\nusing PII = std::pair<int, int>;\nusing PLL = std::pair<ll, ll>;\nusing TI3 = std::tuple<int, int, int>;\nusing TI4 = std::tuple<int, int, int, int>;\nusing TL3 = std::tuple<ll, ll, ll>;\nusing TL4 = std::tuple<ll, ll, ll, ll>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define rep3(i, s, n, d) for (int i = (s); i < (int)(n); i += (d))\n#define allpt(v) (v).begin(), (v).end()\n#define allpt_c(v) (v).cbegin(), (v).cend()\n#define allpt_r(v) (v).rbegin(), (v).rend()\n\nconst int mod1 = 1e9 + 7, mod2 = 998244353, mod3 = 1e9 + 9;\nconst int mod = mod1;\nconst ll inf = 1e18;\n\nconst string wsp = \" \";\nconst string tb = \"\\t\";\nconst string rt = \"\\n\";\n\ntemplate <typename T>\nvoid show1dvec(const vector<T> &v)\n{\n    if (v.size() == 0)\n        return;\n    int n = v.size() - 1;\n    rep(i, n) cout << v[i] << wsp;\n    cout << v[n] << rt;\n\n    return;\n}\n\ntemplate <typename T>\nvoid show2dvec(const vector<vector<T>> &v)\n{\n    int n = v.size();\n    rep(i, n) show1dvec(v[i]);\n}\n\ntemplate <typename T, typename S>\nvoid show1dpair(const vector<pair<T, S>> &v)\n{\n    int n = v.size();\n    rep(i, n) cout << v[i].first << wsp << v[i].second << rt;\n    return;\n}\n\ntemplate <typename T, typename S>\nvoid pairzip(const vector<pair<T, S>> &v, vector<T> &t, vector<T> &s)\n{\n    int n = v.size();\n    rep(i, n)\n    {\n        t.push_back(v[i].first);\n        s.push_back(v[i].second);\n    }\n    return;\n}\n\ntemplate <typename T>\nvoid maxvec(vector<T> &v)\n{\n    T s = v[0];\n    int n = v.size();\n    rep(i, n - 1)\n    {\n        if (s > v[i + 1])\n        {\n            v[i + 1] = s;\n        }\n        s = v[i + 1];\n    }\n}\n\ntemplate <typename T, typename S>\nbool myfind(T t, S s)\n{\n    return find(t.cbegin(), t.cend(), s) != t.cend();\n}\n\nbool check(int y, int x, int h, int w)\n{\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\ntemplate <typename T>\nvector<T> cumsum(const vector<T> &v)\n{\n    T s = 0;\n    vector<T> ret;\n\n    rep(i, v.size())\n    {\n        s += v[i];\n        s %= mod;\n        ret.emplace_back(s);\n    }\n    return ret;\n}\n\nbool iskadomatsu(int a, int b, int c)\n{\n    return (a != b && b != c && c != a) && ((a > b && b < c) || (a < b && b > c));\n}\n\nVS split(string s, char c)\n{\n    VS ret;\n    string part;\n    s += c;\n    rep(i, s.length())\n    {\n        if (s[i] == c)\n        {\n            ret.emplace_back(part);\n            part = \"\";\n        }\n        else if (s[i] != c)\n        {\n            part += s[i];\n        }\n    }\n    return ret;\n}\n\nstring removezero(string &s)\n{\n    string ret;\n    for (auto z : s)\n        if (z != '0')\n            ret += z;\n    return ret;\n}\n\nll sumdigit(ll x)\n{\n    ll ans{0};\n    while (x > 0)\n    {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ntemplate <typename T, typename S, typename R>\nll pow_mod(T p, S q, R mod = 1ll)\n{\n    ll ret = 1, r = p;\n    while (q)\n    {\n        if (q % 2)\n            ret *= r, ret %= mod;\n        r = (r * r) % mod, q /= 2;\n    }\n    return ret % mod;\n}\n\nvoid make_frac_tables(VL &frac_list, VL &frac_inv_list)\n{\n    rep(i, frac_list.size() - 1)\n    {\n        frac_list[i + 1] *= frac_list[i] * (i + 1);\n        frac_list[i + 1] %= mod;\n        frac_inv_list[i + 1] *= frac_inv_list[i] * pow_mod(i + 1, mod - 2, mod);\n        frac_inv_list[i + 1] %= mod;\n    }\n}\n\nll comb(int a, int b, const VL &frac_list, const VL &frac_inv_list)\n{\n    if (a < b)\n        return 0;\n    ll ret = frac_list[a];\n    ret *= frac_inv_list[b];\n    ret %= mod;\n    ret *= frac_inv_list[a - b];\n    ret %= mod;\n    return ret;\n}\n\nclass Unionfind\n{\n    vector<int> p;\n    vector<int> diff;\n    VVI children;\n\npublic:\n    int find(int x);\n    void unite(int x, int y, int d);\n    bool isunion(int x, int y);\n    Unionfind(int n);\n    void showdiff(int x, int y);\n};\n\nUnionfind::Unionfind(int n)\n{\n    children.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        p.emplace_back(i);\n        diff.emplace_back(0);\n        children[i].emplace_back(i);\n    }\n}\nint Unionfind::find(int x)\n{\n    while (p[x] != x)\n    {\n        p[x] = p[p[x]];\n        x = p[x];\n    }\n    return x;\n}\n\nvoid Unionfind::unite(int x, int y, int d)\n{\n    int px, py, bigtree, smalltree, dx, dy;\n    px = Unionfind::find(x);\n    py = Unionfind::find(y);\n    if (px == py) return;\n    dx = diff[x] - diff[px];\n    dy = diff[y] - diff[py];\n    bigtree = (children[px].size() >= children[py].size() ? px : py);\n    smalltree = (bigtree == px ? py : px);\n    p[smalltree] = bigtree;\n    for (int z : children[smalltree])\n    {\n        children[bigtree].emplace_back(z);\n        if (px == bigtree)\n            diff[z] += d - dy + dx;\n        else\n            diff[z] -= d - dy + dx;\n    }\n    children[smalltree].clear();\n}\n\nbool Unionfind::isunion(int x, int y)\n{\n    return Unionfind::find(x) == Unionfind::find(y);\n}\n\nvoid Unionfind::showdiff(int x, int y)\n{\n    int px, py;\n    px = Unionfind::find(x);\n    py = Unionfind::find(y);\n    if (px != py)\n        cout << \"?\" << rt;\n    else\n        cout << diff[y] - diff[x] << rt;\n}\n\n\nint main()\n{\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, q, op, a, b, d;\n    cin >> n >> q;\n    Unionfind un(n + 1);\n    rep(i, q)\n    {\n        cin >> op;\n        if (op == 0)\n        {\n            cin >> a >> b >> d;\n            un.unite(a, b, d);\n        }\n        else if (op == 1)\n        {\n            cin >> a >> b;\n            un.showdiff(a, b);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct WeightedUnionFind{\n  vector< pair<int, long long> > data;\n  WeightedUnionFind(int n) : data(n, pair<int,long long>(-1,0LL)) {}\n  bool unite(int x, int y, long long w){\n    int x_ = find(x), y_ = find(y);\n    if(x_ == y_) return true;\n    if(data[y_].first < data[x_].first){\n      swap(x_,y_); swap(x,y);\n      w *= -1LL;\n    }\n    data[x_].first += data[y_].first;\n    data[y_].first = x_;\n    data[y_].second += w + rel_weight(x) - rel_weight(y);\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x].first < 0) return x;\n    int p = find(data[x].first);\n    data[x].second += data[data[x].first].second;\n    data[x].first = p;\n    return data[x].first;\n  }\n  long long rel_weight(int x){\n    return data[x].second;\n  }\n};\nint main(){\n  int n, q;cin >> n >> q;\n  WeightedUnionFind wuf(n);\n  while(q--){\n    int t, x, y, z;cin >> t >> x >> y;\n    if(t){\n      if(wuf.same(x,y)) cout << wuf.rel_weight(y) - wuf.rel_weight(x) << endl;\n      else cout << \"?\" << endl;\n      continue;\n    }\n    cin >> z;\n    wuf.unite(x,y,z);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MX = 100005;\nint rnk[MX];\nint w_diff[MX];\nint root[MX];\n\nint find(int x){\n  if (x == root[x]) return x;\n  int r = find(root[x]);\n  w_diff[x] += w_diff[root[x]];\n  return root[x] = r;\n}\n\nint weight(int x){\n    find(x);\n    return w_diff[x];\n}\n\nint diff(int x, int y){\n    return weight(y) - weight(x);\n}\n\nvoid merge(int x, int y, int w){\n    \n    w += weight(x);\n    w -= weight(y);\n\n    x = find(x);\n    y = find(y);\n    \n    if (x == y) return;\n    \n    if(rnk[x] < rnk[y]) swap(x, y),  w = -w;\n    if(rnk[x] == rnk[y]) ++rnk[x];\n    root[y] = x;\n    w_diff[y] = w;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, q;\n    cin >> n >> q;\n    \n    for(int i=0; i<MX; i++) {\n        rnk[i]=0;\n        w_diff[i]=0;\n        root[i]=i;\n    }\n \n    for(int i=0; i<q; i++){\n        int c, x, y, z;\n        cin >> c;\n        if(c == 0){\n            cin >> x >> y >> z;\n            merge(x, y, z);\n        }else if (c == 1){\n            cin >> x >> y;\n            if (find(x) != find(y)){\n                cout << \"?\" << endl;\n            }else{\n                cout << diff(x, y) << endl;   \n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct WUF {\n\tint par[100000];\n\tint w[100000];\n\t//int rank[100000];\n\t\n\tWUF() {\n\t\tfor (int i = 0; i < 100000; i++) {\n\t\t\tpar[i] = i;\n\t\t\tw[i] = 0;\n\t\t\t//rank[i] = 0;\n\t\t}\n\t}\n\t\n\tP root(int x) {\t//(root, rootまでの距離)\n\t\tif (par[x] == x) {\n\t\t\treturn P(x, 0);\n\t\t}\n\t\tP res = root(par[x]);\n\t\tpar[x] = res.first;\n\t\tw[x] += res.second;\n\t\treturn P(par[x], w[x]);\n\t}\n\t\n\tvoid unit(int x, int y, int c) {\n\t\tP res1 = root(x);\n\t\tP res2 = root(y);\n\t\tint rt1 = res1.first;\n\t\tint rt2 = res2.first;\n\t\t\n\t\tif (rt1 == rt2) return;\n\t\t//if (rank[rt1] < rank[rt2]) {\n\t\t\tpar[rt1] = rt2;\n\t\t\tw[rt1] = c + res2.second - res1.second;\n\t\t//}\n\t\t/*else {\n\t\t\tif (rank[rt1] == rank[rt2]) { rank[rt1]++; }\n\t\t\tpar[rt2] = rt1;\n\t\t\tw[rt2] = -c + res1.second - res2.second;\n\t\t}*/\n\t}\n\t\n\tbool same(int x, int y) {\n\t\treturn root(x).first == root(y).first;\n\t}\n};\n\nWUF wuf;\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tint type;\n\t\tcin >> type;\n\t\t\n\t\tif (type == 0) {\n\t\t\tint x, y, c;\n\t\t\tcin >> x >> y >> c;\n\t\t\twuf.unit(x, y, c);\n\t\t}\n\t\telse {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tif (wuf.same(x, y) == false) {\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cx = wuf.root(x).second;\n\t\t\t\tint cy = wuf.root(y).second;\n\t\t\t\tcout << cx - cy << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class T>\nclass WeightedUnionFind\n{\n    vector<int> par;\n    vector<T> dist;\n\npublic:\n    WeightedUnionFind(int n) : par(n, -1), dist(n, 0) {}\n\n    int root(int x)\n    {\n        if (par[x] < 0)\n            return x;\n        else\n        {\n            //rootから降りて足していく\n            int r = root(par[x]);\n            //親までの累積和は計算し終わっている\n            dist[x] += dist[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    //d[y] = d[x] + w\n    bool merge(int x, int y, T w)\n    {\n        //par[y] = x\n        w += weight(x) - weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (par[x] > par[y])\n        {\n            w = -w;\n            swap(x, y);\n        }\n        par[x] += par[y];\n        par[y] = x;\n        dist[y] = w;\n        return true;\n    }\n\n    T weight(int x)\n    {\n        root(x);\n        return dist[x];\n    }\n\n    T dis(int x, int y) { return weight(y) - weight(x); }\n\n    int size(int x) { return -par[root(x)]; }\n};\n\nint main(void)\n{\n    int n, q, c;\n    cin >> n >> q;\n    WeightedUnionFind<long> wuf(n);\n    while (q--)\n    {\n        cin >> c;\n        if (c)\n        {\n            int x, y;\n            cin >> x >> y;\n            if (wuf.root(x) == wuf.root(y))\n            {\n                cout << wuf.dis(x, y) << '\\n';\n            }\n            else\n            {\n                cout << \"?\\n\";\n            }\n        }\n        else\n        {\n            int x, y;\n            long z;\n            cin >> x >> y >> z;\n            wuf.merge(x, y, z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Weighted Union Find Trees\n\n#include <iostream>\n\nusing namespace std;\n\nint n, q;\n\nint fat[100000];\nint dis[100000];\n\nint find(int u) {\n\tif (fat[u] == u)\n\t\treturn u;\n\tint g = find(fat[u]);\n\tdis[u] += dis[fat[u]];\n\tfat[u] = g;\n\treturn g;\n}\n\nvoid relate(int x, int y, int z) {\n\tint u = find(x);\n\tint v = find(y);\n\tfat[u] = v;\n\tdis[u] = z - dis[x] + dis[y];\n}\n\nbool check(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\treturn x == y;\n}\n\nint diff(int x, int y) {\n\tfind(x);\n\tfind(y);\n\treturn dis[x] - dis[y];\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i)\n\t\tfat[i] = i, dis[i] = 0;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint k, x, y, z;\n\t\tcin >> k >> x >> y;\n\t\tif (k == 0)\n\t\t\tcin >> z, relate(x, y, z);\n\t\telse {\n\t\t\tif (check(x, y))\n\t\t\t\tcout << diff(x, y) << endl;\n\t\t\telse\n\t\t\t\tcout << \"?\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \n#define M_PI       3.14159265358979323846\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \nclass WeightedUnionFind{\npublic:\n    vector <int> par; \n    vector <int> siz;\n    vector <ll> diff_weight; /* 頂点間の重みの差 */\n\n    WeightedUnionFind(int sz_): par(sz_), siz(sz_, 1LL), diff_weight(sz_, 0LL){\n        for(int i=0; i<sz_; i++) par[i] = i;\n    }\n\n    void init(int sz_){\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        diff_weight.resize(sz_);\n        for(int i=0; i<sz_; i++) par[i] = i, diff_weight[i] = 0;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    ll weight(ll x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y){\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, ll w){\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if(x == y) return false;\n\n        if (siz[x] < siz[y]) swap(x, y), w = -w;\n        siz[x] += siz[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    ll diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n};\n \nll modPow(ll x, ll n, ll mod = MOD){\n    if(n <= 0) return 1;\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n \n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n\n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n\n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      data[k] %= MOD;\n    }\n  }\n\n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n\n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n\n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n\n\n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n\n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n\n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\n\nstruct Dice {\n    const int UP = 0;\n    const int FRONT = 1;\n    const int RIGHT = 2;\n    const int LEFT = 3;\n    const int BACK = 4;\n    const int DOWN = 5;\n\n    vector<int> d;\n\n    Dice(vector<int> v, int N = 6){\n        d.resize(N);\n        for(int i=0; i<N; i++){\n            d[i] = v[i];\n        }\n    }\n\n    void rotate(char s){\n        vector<int> tmp = d;\n        if(s == 'S'){\n            d[0] = tmp[4];\n            d[1] = tmp[0];\n            d[5] = tmp[1];\n            d[4] = tmp[5];\n        }\n\n        if(s == 'E'){\n            d[0] = tmp[3];\n            d[2] = tmp[0];\n            d[5] = tmp[2];\n            d[3] = tmp[5];\n        }\n\n        if(s == 'W'){\n            d[0] = tmp[2];\n            d[3] = tmp[0];\n            d[5] = tmp[3];\n            d[2] = tmp[5];\n        }\n\n        if(s == 'N'){\n            d[0] = tmp[1];\n            d[1] = tmp[5];\n            d[5] = tmp[4];\n            d[4] = tmp[0];\n        }\n    }\n\n    void spin(){\n        vector<int> tmp = d;\n        d[1] = tmp[2];\n        d[2] = tmp[4];\n        d[4] = tmp[3];\n        d[3] = tmp[1];\n    }\n    \n\n    int operator[](const int &k)\n    {\n        return d[k];\n    }\n\n    bool issame(Dice &d2){\n        bool res = true;\n\n        for(int i=0; i<6; i++){\n            if(d[i] != d2[i]) res = false;\n        }\n\n        return res;\n    }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(15);\n\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n\n    WeightedUnionFind uf(N+10);\n    REP(i,Q){\n        int p, a, b; scanf(\"%d\", &p);\n        ll w;\n        if(p == 0){\n            scanf(\"%d %d %lld\", &a, &b, &w);\n            uf.merge(a, b, w);\n        }else{\n            scanf(\"%d %d\", &a, &b);\n            if(uf.issame(a, b)){\n                cout << uf.diff(a, b) << endl;\n            }else{\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\tif (flag[x] == -1 && flag[y] == -1) {\n\t\t\t\tset<int>st;\n\n\t\t\t\tst.insert(x);\n\t\t\t\tst.insert(y);\n\t\t\t\tnum.push_back(st);\n\t\t\t\tflag[x] = num.size() - 1;\n\t\t\t\tflag[y] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\telse if (flag[x] != -1 && flag[y] != -1) {\n\t\t\t\tif (flag[x] == flag[y]) {\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\tint sa = atai[y] - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\t//  num.erase(num.begin() + yy);\n\t\t\t\t\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}\n\t\t\t\telse if (flag[x] > flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\tint sa = atai[y] - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[y]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[y];\n\t\t\t\t\t}\n\n\t\t\t\t\t//  num.erase(num.begin() + xx);\n\t\t\t\t\tnum[xx].erase(num[xx].begin(), num[xx].end());\n\n\t\t\t\t}\n\t\t\n\t\t\t}\n\t\t\telse if (flag[x] != -1) {\n\t\t\t\tnum[flag[x]].insert(y);\n\t\t\t\tflag[y] = flag[x];\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\telse if (flag[y] != -1) {\n\t\t\t\tnum[flag[y]].insert(x);\n\t\t\t\tflag[x] = flag[y];\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(a,b) for(long long a = 0;a < b;++a)\npair<int,int> union_find[2000000];\npair<int,int> union_check(int a){\n    if(union_find[a].first == a) return make_pair(a,0);\n    pair<int,int> hoge = union_check(union_find[a].first);\n    union_find[a].second += hoge.second;\n    union_find[a].first = hoge.first;\n    return union_find[a];\n}\npair<int,int> union_merge(int a,int b,int c){\n    pair<int,int> next_a = union_check(a);\n    pair<int,int> next_b = union_check(b);\n    if(next_a.first != next_b.first){\n        union_find[next_a.first] = make_pair(b,c - next_a.second);\n    }\n}\nint main(){\n    int n,query;\n    cin >> n >> query;\n    REP(i,n){\n        union_find[i] = make_pair(i,0);\n    }\n    REP(i,query){\n        int a;\n        cin >> a;\n        if(a == 0){\n            //relate\n            int a,b,c;\n            cin >> a >> b >> c;\n            union_merge(a,b,c);\n        }else{\n            //diff\n            int a,b;\n            cin >> a >> b;\n            if(union_check(a).first != union_check(b).first){\n                cout << \"?\" << endl;\n            }else{\n                cout << union_find[a].second - union_find[b].second << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Abel> struct UnionFind {\n\tvector<int> par;\n\tvector<int> size;\n\tvector<int> rank;\n\tvector<Abel> diff_weight;\n\n\tUnionFind(int n) {\n\t\tinit(n);\n\t}\n\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\tsize.assign(n,1);\n\t\trank.resize(n);\n\t\tdiff_weight.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i; \n\t}\n\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t} else { \n\t\t\tint r = root(par[x]);\n\t\t\tsize[x] = size[r];\n\t\t\tdiff_weight[x] += diff_weight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\t\n\tint scale(int x) {\n\t\treturn size[root(x)];\n\t}\n\n\tAbel weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t} \n\n\tAbel diff(int x, int y) {\n\t\treturn weight(y) - weight(x);\n\t} \n\n\tbool is_same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tbool merge(int x, int y, Abel w = 0) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) {\n\t\t\tswap(x,y);\n\t\t\tw = -w;\n\t\t}\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\tsize[x] += size[y];\n\t\tpar[y] = x;\n\t\tdiff_weight[y] = w;\n\t\treturn true;\n\t}\n};\n \n\nint main(){\n\tint n,q; cin >> n >> q;\n\tUnionFind<int> uf(n);\n\trep(i,q){\n\t\tint x,y,z,t; cin >> t;\n\t\tif(t){\n\t\t\tcin >> x >> y;\n\t\t\tif(uf.is_same(x,y)) cout << uf.diff(x,y) << endl;\n\t\t\telse cout << \"?\\n\";\n\t\t}else{\n\t\t\tcin >> x >> y >> z;\n\t\t\tuf.merge(x,y,z);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <map>\n#include <iomanip>\n#include <math.h> \n#include <stack>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <tuple>\n#include <cctype>\n#include <ctype.h>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint i, j, k;\n\tint n, q, query;\n\tvector<set<int>>num;\t\t\t// 集合をどんどん追加していく\n\tvector<int>flag(100005, -1);\t// 何番目の集合に入っているか\n\tvector<int>atai(100005, -1);\t// 実際の値は何か\n\tvector<string>ans;\n\n\n\tcin >> n >> q;\n\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tint x, y, z;\n\n\t\tif (query == 0) {\n\t\t\tcin >> x >> y >> z;\n\n\t\t\tif (flag[x] == -1 && flag[y] == -1) {\n\t\t\t\tset<int>st;\n\n\t\t\t\t//st.insert(x);\n\t\t\t\t//st.insert(y);\n\t\t\t\tst.insert({ x,y });\n\n\t\t\t\tnum.push_back(st);\n\t\t\t\t//flag[x] = num.size() - 1;\n\t\t\t\t//flag[y] = num.size() - 1;\n\t\t\t\tflag[y] = flag[x] = num.size() - 1;\n\t\t\t\tatai[x] = 0;\n\t\t\t\tatai[y] = z;\n\t\t\t}\n\t\t\telse if (flag[x] != -1 && flag[y] != -1) {\n\t\t\t\t//if (flag[x] == flag[y]) {\n\t\t\t\t\t/*\n\t\t\t\t\tif (atai[y] - atai[x] == z) {\n\t\t\t\t\t\tcout << \"zは合っている\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"zは間違っている\" << endl;\n\t\t\t\t\t}*/\n\t\t\t\t//}\n\t\t\t\t//else if (flag[x] < flag[y]) {\n\t\t\t\t/*\n\t\t\t if (flag[x] < flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[y]].begin(); itr != num[flag[y]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[yy].begin(); itr != num[yy].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[x]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[x];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[yy].erase(num[yy].begin(), num[yy].end());\n\n\t\t\t\t}*/\n\t\t\t\t//else if (flag[x] > flag[y]) {\n\t\t\t\t\tint yy = flag[y];\n\t\t\t\t\tint xx = flag[x];\n\t\t\t\t\t//int sa = atai[y] - atai[x];\n\t\t\t\t\tint sa = (atai[y] - z) - atai[x];\n\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tatai[(*itr)] += sa;\n\t\t\t\t\t}\n\t\t\t\t\t//for (auto itr = num[flag[x]].begin(); itr != num[flag[x]].end(); ++itr) {\n\t\t\t\t\tfor (auto itr = num[xx].begin(); itr != num[xx].end(); ++itr) {\n\t\t\t\t\t\tnum[flag[y]].insert(*itr);\n\t\t\t\t\t\tflag[*itr] = flag[y];\n\t\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t//\tnum[xx].erase(num[xx].begin(), num[xx].end());\n\n\t\t\t\t//}\n\t\t\n\t\t\t}\n\t\t\telse if (flag[x] != -1) {\n\t\t\t\tnum[flag[x]].insert(y);\n\t\t\t\tflag[y] = flag[x];\n\n\t\t\t\tatai[y] = atai[x] + z;\n\t\t\t}\n\t\t\telse if (flag[y] != -1) {\n\t\t\t\tnum[flag[y]].insert(x);\n\t\t\t\tflag[x] = flag[y];\n\n\t\t\t\tatai[x] = atai[y] - z;\n\t\t\t}\n\t\t}\n\t\telse if (query == 1) {\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif (flag[x] == flag[y] && flag[x] != -1) {\n\t\t\t\t//cout << 1 << endl;\n\t\t\t\t//ans.push_back(1);\n\t\t\t\tans.push_back(to_string(atai[y] - atai[x]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << 0 << endl;\n\t\t\t\t//ans.push_back(0);\n\t\t\t\tans.push_back(\"?\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\n#define DATA_MAX 100000\n#define QUERY_MAX 200000\n#define ZMAX 10000\n\nclass UnionFind{\nprivate:\n    vector<map<int, int> > tree;\n    \n    bool Root(int now, int target, int &Sum){\n        vector<bool> visit(tree.size(), false);\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(Root(iter->first, target, Sum, visit)){\n                    Sum += iter->second;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool Root(int now, int target, int &Sum, vector<bool> &visit){\n        map<int, int>::iterator it;\n        \n        visit[now] = true;\n        if(now == target)\n            return true;\n        \n        it = tree[now].find(target);\n        if(it != tree[now].end()){\n            Sum += tree[now][target];\n            return true;\n        }\n        else{\n            for(map<int, int>::iterator iter = tree[now].begin(); iter != tree[now].end(); iter++){\n                if(!visit[iter->first]){\n                    if(Root(iter->first, target, Sum, visit)){\n                        Sum += iter->second;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \npublic:\n    UnionFind(){}\n    \n    UnionFind(int n){\n        tree.resize(n);\n    }\n    \n    ~UnionFind(){\n        tree.clear();\n        tree.shrink_to_fit();\n    }\n    \n    void set(int x, int y, int z){\n        tree[x][y] = z;\n        tree[y][x] = -z;\n    }\n    \n    void get(int x, int y){\n        int S = 0;\n        \n        if(Root(x, y, S)){\n            //cout << S << endl;\n            tree[x][y] = S;\n            tree[y][x] = -S;\n        }\n        /*else\n            cout << \"?\" << endl;*/\n    }\n    \n};\n\nint ReadQuery(UnionFind*, int, int);\n\nint main(){\n    UnionFind *uf;\n    int n, q;\n    \n    cin >> n >> q;\n    if(!((2 <= n && n <= DATA_MAX) && (1 <= q && q <= QUERY_MAX)))\n        return -1;\n    \n    uf = new UnionFind(n);\n    if(ReadQuery(uf, n, q) == -1)\n        return -1;\n    \n    delete uf;\n    \n    return 0;\n}\n\nint ReadQuery(UnionFind *uf, int n, int q){\n    int com, x, y, z;\n    \n    for(int i = 0; i < q; i++){\n        cin >> com;\n        \n        if(com == 0){\n            cin >> x >> y >> z;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y || !(0 <= z && z <= ZMAX))\n                return -1;\n            \n            uf->set(x, y, z);\n        }\n        else if(com == 1){\n            cin >> x >> y;\n            if(!(0 <= x && x < n) || !(0 <= y && y < n) || x == y)\n                return -1;\n            \n            uf->get(x, y);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PUTS(x) cout << (x) << endl;\n#define rep(i, n) for (int i = 0, i##_len = (int)(n); i < i##_len; i++)\n#define MP make_pair\n#define F first\n#define S second\n\nstruct Node {\n    int parentIndex;\n    int diffFromParent;\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    auto nodes = vector<Node>(n, Node{-1, 0});\n\n    // Union-Find で根ノートを見つけながら指し直す。返値は (根のインデックス，根からの距離)\n    function<pair<int, int>(int)> root = [&](int index) {\n        auto &node = nodes[index];\n        if (node.parentIndex == -1) { // これが根ノードの場合\n            return MP(index, 0);\n        } else { // 親ノードがある場合\n            auto p = root(node.parentIndex);\n            auto rootIndex = p.F; // 親ノードの根のインデックス\n            auto diffFromRoot = p.S; // 根からの距離\n            node.parentIndex = rootIndex; // このノードの親ノードを根ノードに差し替え\n            node.diffFromParent = diffFromRoot + node.diffFromParent; // 根からの距離をセット\n            return MP(rootIndex, node.diffFromParent);\n        }\n    };\n\n    rep(i, q) {\n        int q;\n        cin >> q;\n        if (q == 0) { // 新たな関係が与えられたとき\n            int x, y, z;\n            cin >> x >> y >> z;\n            auto rx = root(x); // xの属する木の根のインデックス，根からの距離\n            auto ry = root(y); // yの属する木の根のインデックス，根からの距離\n            if (rx.F != ry.F) { // xとyが異なる木に属するとき\n                nodes[ry.F].parentIndex = rx.F; // yの属する木の根を，xの属する木の根の直属の子とする\n                nodes[ry.F].diffFromParent = nodes[x].diffFromParent + z - nodes[y].diffFromParent; // 新しく張った辺の重みを回り込んで計算\n            }\n        } else {\n            int x, y;\n            cin >> x >> y;\n            auto rx = root(x);\n            auto ry = root(y);\n            if (rx.F == ry.F) { // xとyが同じ木に属するとき\n                PUTS(nodes[y].diffFromParent - nodes[x].diffFromParent); // 根からの距離の差を報告\n            } else {\n                puts(\"?\");\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntemplate <typename T>\nclass UnionFind {\n    private:\n        vector<int> parent;  // 親\n        vector<int> rank;    // 木の深さ\n\n        // 重み付きUnionFindでのみ利用\n        vector<T> diffWeight; // 親ノードとの値の差\n    public:\n        UnionFind(int n);          // n要素で初期化\n        int Find(int x);           // 木の根を返す\n        void Unite(int x, int y);  // xとyの属する集合を併合\n        bool Same(int x, int y);   // xとyが同じ集合に属するか否か\n        \n        // 重み付きUnionFindでのみ利用\n        void Unite(int x, int y, T w);\n        T Weight(int x);      // xの重みを返す\n        T Diff(int x, int y); // xとyの差を返す\n};\n\ntemplate <typename T>\nUnionFind<T>::UnionFind(int n) : parent(n), rank(n), diffWeight(n, 0)\n{\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\ntemplate <typename T>\nint UnionFind<T>::Find(int x) {\n    if (parent[x] == x) {\n        return x;\n    } else {\n        int r = Find(parent[x]);\n        diffWeight[x] += diffWeight[parent[x]];\n        return parent[x] = r;\n    }\n}\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ntemplate <typename T>\nbool UnionFind<T>::Same(int x, int y) { return Find(x) == Find(y); }\n\ntemplate <typename T>\nvoid UnionFind<T>::Unite(int x, int y, T w){\n    w += Weight(x); w -= Weight(y);\n    x = Find(x); y = Find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) swap(x, y), w = -w;\n\n    if(rank[x] == rank[y]) rank[x]++;\n    parent[y] = x;\n\n    diffWeight[y] = w;\n}\n\ntemplate <typename T>\nT UnionFind<T>::Weight(int x){\n    Find(x);\n    return diffWeight[x];\n}\n\ntemplate <typename T>\nT UnionFind<T>::Diff(int x, int y){\n    return Weight(y) - Weight(x);\n}\n\n/*************** using variables ***************/\nint n, q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    UnionFind<int> uf(n);\n    REP(i, q){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.Unite(x, y, z);\n        }else{\n            int x, y;\n            cin >> x >> y;\n            if(uf.Same(x, y)) cout << uf.Diff(x, y) << endl;\n            else cout << '?' << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<list>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<stack>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\n#define lint long long\n#define REP(i, x, n) for(int i = x ; i < n ; i++)\n#define rep(i, n) REP(i, 0, n)\n#define repr(i, n) for(int i = n - 1 ; i >= 0 ; i--)\n#define SORT(c) sort((c).begin(), (c).end())\n#define SORT_INV(c) sort((c).begin(), (c).end(), greater<int>())\n#define IINF (int)(1e9+10)\n#define LLINF (lint)(1e18+10)\n\nstruct weightedUnionFind{\n\n    vector<int> par, rank, wei;\n\n    void init(int n){\n        par.resize(n);\n        rank.resize(n, 0);\n        wei.resize(n, 0);\n        rep(i, n){\n            par[i] = i;\n        }\n        return;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int r = root(par[x]);\n            wei[x] += wei[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    void unite(int x, int y, int w){\n        w = -w;\n        w += weight(x);\n        w -= weight(y);\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry){\n            return;\n        }\n        if(rank[rx] < rank[ry]){\n            swap(rx, ry);\n            w = -w;\n        }\n        if(rank[rx] == rank[ry]){\n            rank[rx]++;\n        }\n        par[ry] = rx;\n        wei[ry] = w;\n        return;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    int weight(int x){\n        root(x);\n        return wei[x];\n    }\n\n    int diff(int x, int y){\n        return weight(x) - weight(y);\n    }\n\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    weightedUnionFind wuf;\n    wuf.init(n);\n    rep(i, q){\n        int query;\n        cin >> query;\n        if(query == 0){\n            int x, y, z;\n            cin >> x >> y >> z;\n            wuf.unite(x, y, z);\n        }else if(query == 1){\n            int x, y;\n            cin >> x >> y;\n            if(wuf.same(x, y)){\n                cout << wuf.diff(x, y) << endl;\n            }else{\n                cout << \"?\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 100001\n\nint n,q;\nint p[MAX] = {}, r[MAX] = {};\n//int rr[MAX] = {};\n\nvoid makeSet(int x){\n\tp[x] = x;\n}\n\nvoid link(int x,int y,int z){\n\tif(p[x] == x){\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t}\n\telse if(p[x] != x && z <= r[x]){\n\t\tint a = p[x];\n\t\tint b = r[x];\n\t\tp[x] = y;\n\t\tr[x] = z;\n\t\t//rr[y] = rr[x]+1;\n\t\tlink(y,a,b-z);\n\n\t\t//cout << \"ここ3\" << endl;\n\t}\n\telse if(p[x] != x && z > r[x]){\n\t\tlink(p[x],y,z-r[x]);\n\t\t//cout << \"ここ4\" << endl;\n\t}\n}\n\nint findSet(int x){\n\tint a = p[x];\n\tif(x != p[x]){\n\t\ta = findSet(p[x]);\n\t}\n\treturn a;\n}\n\nint findRank(int x, int y){\n\tint a = findSet(x);\n\tint b = x;\n\twhile(a != b){\n\t\tif(b == y){\n\t\t\treturn 1;\n\t\t}\n\t\tb = p[b];\n\t}\n\treturn -1;\n}\n\nint returnQuery(int x,int y){\n\tint ans = r[x];\n\tif(p[x] != y){\n\t\treturn ans + returnQuery(p[x],y);\n\t}\n\telse return r[x];\n}\n\nint returnQ(int x){\n\tint ans = r[x];\n\tif(p[x] != findSet(x)){\n\t\treturn ans + returnQ(p[x]);\n\t}\n\telse return ans;\n}\n\nvoid uni(int x,int y, int z){\n\tlink(x, y, z);\n}\n\nint same(int x,int y){\n\tif(findSet(x) == findSet(y)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i = 0;i < n;i++){\n\t\tmakeSet(i);\n\t}\n\n\tint a,b,c,d;\n\tfor(int i = 0;i < q;i++){\n\t\tcin >> a;\n\t\tif(a == 0){\n\t\t\tcin >> b >> c >> d;\n\t\t\tuni(b,c,d);\n\t\t}\n\t\telse if(a == 1){\n\t\t\tcin >> b >> c;\n\t\t\tif(same(b,c) == 0){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tcout << returnQ(b) - returnQ(c) << endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n/*\n\tfor(int i = 0;i < n;i++){\n\t\tcout << i << \" \" << p[i] << \" \" << r[i] << endl;\n\t}\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntemplate<class Abel> struct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<Abel> diff_weight;\n\n    UnionFind(int n = 1, Abel SUM_UNITY = 0) {\n        init(n, SUM_UNITY);\n    }\n\n    void init(int n = 1, Abel SUM_UNITY = 0) {\n        par.resize(n); rank.resize(n); diff_weight.resize(n);\n        for(int i = 0; i < n; ++i) {\n            par[i] = i; rank[i] = 0; diff_weight[i] = SUM_UNITY;\n        }\n    }\n\n    int find(int x) {\n        if(par[x] == x) return x;\n        else {\n            int r = find(par[x]);\n            diff_weight[x] += diff_weight[par[x]];  // 累積和を取る\n            return par[x] = r;\n        }\n    }\n\n    Abel weight(int x) {\n        find(x);\n        return diff_weight[x];\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    bool unite(int x, int y, Abel w) {\n        w += weight(x); w -= weight(y); // xとyそれぞれについて、rootとの重み差分を補正\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y]) swap(x, y), w = -w;   // rank[x] >= rank[y]になるようにswap\n        if(rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        diff_weight[y] = w; // xがyの親になるので、xとyの差分をdiff_weight[y]に記録\n        return true;\n    }\n\n    // 重みを取得する\n    Abel diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    UnionFind<int> uf(n);\n    for(int i = 0; i < q; ++i) {\n        int c, x, y, z;\n        cin >> c >> x >> y;\n        if(c) {\n            if(uf.same(x, y)) cout << uf.diff(x, y) << endl;\n            else cout << \"?\" << endl;\n        }else {\n            cin >> z;\n            uf.unite(x, y, z);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass WeightedUnionFind{\n\nprivate:\n    vector<int> rank,p,d;\n\n  public:\n      WeightedUnionFind(){};\n      WeightedUnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        d.resize(size,0);\n        for(int i = 0; i < size; i++){\n          p[i] = i;\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void relate(int x, int y, int z){\n      link(find(x), find(y), d[y] + z - d[x]);\n      find(x);\n      find(y);\n    }\n\n    int find(int x){\n      if(x != p[x]){\n        int par = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = par;\n      }\n      return p[x];\n    }\n\n    int diff(int x, int y){\n      find(x);\n      find(y);\n      if(same(x,y)){\n        int ret = d[x] - d[y];\n        if(ret < 0) ret *= -1;\n        return ret;\n      }else{\n        return -1;\n      }\n    }\nprivate:\n    void link(int x, int y, int z){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n        d[y] = -z;\n      }else{\n        p[x] = y;\n        d[x] = z;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nint main(){\n    int n, q;\n\n    cin >> n >> q;\n    WeightedUnionFind wuf = WeightedUnionFind(n);\n\n    for(int i = 0; i < q; i++){\n      int t, x, y, z;\n      cin >> t;\n      if(t == 0){\n        cin >> x >> y >> z;\n        wuf.relate(x, y, z);\n      }else{\n        cin >> x >> y;\n        int ans = wuf.diff(x, y);\n        if(ans < 0)\n          cout << \"?\" << endl;\n        else\n          cout << ans << endl;\n      }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct w_unionfind {\n    using diff_from = pair<int, int>;\n    using result = pair<int, bool>;\n    \n    vector<diff_from> uf;\n    \n    w_unionfind(int n) : uf(n) {\n        for(int i=0; i<n; i++) uf[i] = diff_from(i, 0);\n    }\n    \n    int root(int i) {\n        if(uf[i].first==i) return i;\n        int r = root(uf[i].first);\n        uf[i] = diff_from(r, uf[i].second + uf[uf[i].first].second);\n        return r;\n    }\n    \n    void relate(int i, int j, int d) {\n        int ri = root(i);\n        int rj = root(j);\n        if(ri != rj) {\n            uf[rj] = diff_from(ri, uf[i].second + d - uf[j].second);\n        }\n    }\n\n    result diff(int i, int j) {\n        int ri = root(i);\n        int rj = root(j);\n        if(ri != rj) return result(0, false);\n        return result(uf[j].second - uf[i].second, true);\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    w_unionfind uf(n);\n    while(q--) {\n        int c;\n        cin >> c;\n        if(c) {\n            int x, y;\n            cin >> x >> y;\n            auto&& r = uf.diff(x, y);\n            if(r.second) cout << r.first << endl;\n            else cout << \"?\" << endl;\n        } else {\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.relate(x, y, z);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// (weighted) UnionFind\nclass UnionFind {\n    public:\n        UnionFind(int n) : mPar(n), mRnk(n,0), mWeight(n,0) {\n            for(int i = 0; i < n; ++i) mPar[i] = i;\n        }\n\n        int find(int x){\n            if(mPar[x]==x) return x;\n            int r = find(mPar[x]); // 経路圧縮\n            mWeight[x] += mWeight[mPar[x]]; // 一つ上の親からの累積和\n            return mPar[x] = r;\n        }\n\n        bool same(int x,int y){\n            return find(x) == find(y);\n        }\n\n        int weight(int x){\n            find(x); // 経路圧縮\n            return mWeight[x];\n        }\n\n        int diff(int x, int y){\n            return weight(y) - weight(x);\n        }\n\n        void unite(int x,int y, int w = 0){\n            w += weight(x); w -= weight(y);\n            x = find(x);\n            y = find(y);\n            if(x==y) return;\n            if(mRnk[x] < mRnk[y]) swap(x,y), w = -w;\n            mPar[y] = x;\n            mWeight[y] = w;\n            if(mRnk[x] == mRnk[y]) ++mRnk[x];\n        }\n\n    private:\n        vector<int> mPar, mRnk, mWeight;\n};\n\nint main(){\n    int n,q,c,x,y,z;\n    cin >> n >> q;\n    UnionFind uf(n);\n    for(int i = 0; i < q; ++i){\n        cin >> c;\n        if(c==0){\n            cin >> x >> y >> z;\n            uf.unite(x,y,z);\n        } else {\n            cin >> x >> y;\n            if(uf.same(x,y)) cout << uf.diff(x,y) << '\\n';\n            else cout << '?' << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WeightedUnionFind {\npublic:\n    vector<int> par;\n    vector<int> rank;\n    vector<int> diff_weight;\n    \n    WeightedUnionFind() {}\n    WeightedUnionFind(int size, int weight){\n        rank.resize(size,0);\n        par.resize(size,0);\n        diff_weight.resize(size,0);\n        for(int i=0; i<size; i++) makeSet(i,weight);\n    }\n    \n    void makeSet(int x, int weight){\n        par[x] = x;\n        rank[x] = 0;\n        diff_weight[x] = weight;\n    }\n    \n    bool same(int x, int y){\n        return findSet(x) == findSet(y);\n    }\n    \n    bool relate(int x, int y, int w){\n        w += weight(x); w -= weight(y);\n        x = findSet(x); y = findSet(y);\n        \n        if(x == y) return false;\n        if(rank[x] < rank[y]){\n            swap(x,y);\n            w = -w;\n        }\n        if(rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n    \n    int diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n    \n    int weight(int x){\n        findSet(x);\n        return diff_weight[x];\n    }\n    \n    int findSet(int x){\n        if(par[x] == x){\n            return x;\n        }\n        else {\n            int r = findSet(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n    \n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    WeightedUnionFind wuf = WeightedUnionFind(n, 0);\n    \n    for(int i=0; i<q; i++){\n        int t, x, y;\n        cin >> t >> x >> y;\n        if(t==0){\n            int z; cin >> z;\n            wuf.relate(x, y, z);\n        }\n        else if(t==1){\n            if(!wuf.same(x,y)){\n                cout << '?' << endl;\n                continue;\n            }\n            cout << wuf.diff(x,y) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n#define INF INT_MAX\n\nusing namespace std;\n\n//vector<int> p, r;\nvector<int> p;\n\nvoid makeSet(int x){\n  p[x] = INF;\t\t\t\n  //  r[x] = 0;\n}\n\n//int findSet(int x){\n//  if(x != p[x])p[x] = findSet(p[x]);\n//  return p[x];\n//}\n// \n//void link(int x, int y){\n//  if(r[x] > r[y]) p[y] = x;\n//  else {\n//    p[x] = y;\n//    if(r[x] == r[y]) r[y] = r[y] + 1;\n//  }\n//}\n\n\n\n//void unite(int x, int y){\n//  link(findSet(x), findSet(y));\n//}\nvoid relate(int x, int y, int z){\n  if(p[y]==INF && p[x]==INF){\n    p[y] = z;\n    p[x] = p[y] - z;\n  }\n  else if(p[y]==INF && p[x]!=INF) p[y] = p[x] + z;\n  else if(p[y]!=INF && p[x]==INF) p[x] = p[y] - z;\n\n  // cout << x << p[x] << endl;\n  // cout << y << p[y] << endl;\n\n}\n\n\nvoid diff(int x, int y){\n\n  if(p[x]==INF || p[y]==INF) cout << '?' << endl;\n  else if(p[x]!=INF && p[y]!=INF) cout << p[y] - p[x] << endl;\n\n}\n\n\nint main(){\n\n  int N, Q, com, x, y, z, i;\n\n  cin >> N >> Q;\n\n  p.resize(N);\n  //  r.resize(N);\n\n  for(i=0; i<N; i++) makeSet(i);\n\n  for(i=0; i<Q; i++){\n    cin >> com;\n    if(com == 0){\n      cin >> x >> y >> z;\n      relate(x, y, z);\n    }\n    else if(com == 1){\n      cin >> x >> y;\n      diff(x, y);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100010\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint n,q;\nint p[MAX],cost[MAX];\n\nvoid init(){\n  FOR(i,0,n){ p[i]=i;cost[i]=0; }\n}\n\npii f(int a){\n  if(p[a]==a)return mp(a,0);\n  pii res=f(p[a]);\n  res.s+=cost[a];\n  p[a]=res.f;\n  cost[a]=res.s;\n  return res;\n}\n\nvoid relate(int a,int b,int c){\n  pii d=f(a),e=f(b);\n  p[d.f]=e.f;\n  cost[d.f]=c-d.s+e.s;\n}\n\nvoid diff(int a,int b){\n  pii d=f(a),e=f(b);\n  if(d.f!=e.f)cout<<\"?\"<<endl;\n  else cout<<d.s-e.s<<endl;\n}\n\nint main()\n{\n  cin>>n>>q;\n  init();\n  FOR(i,0,q){\n    int a,b,c,d;\n    cin>>a;\n    if(a==0){\n      cin>>b>>c>>d;\n      relate(b,c,d);\n    }\n    else {\n      cin>>b>>c;\n      diff(b,c);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass weighted_quick_find {\n\tvector<pair<int, T>> data;\n\tvector<vector<int>> all;\npublic:\n\tweighted_quick_find(int n) : data(n), all(n, vector<int>(1)) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i].first = i;\n\t\t\tall[i][0] = i;\n\t\t}\n\t}\n\tvoid unite(int a, int b, T d) {\n\t\tif (same(a, b)) return;\n\t\td += data[a].second - data[b].second;\n\t\ta = data[a].first;\n\t\tb = data[b].first;\n\t\tif (all[a].size() < all[b].size()) swap(a, b), d = -d;\n\t\tfor (auto& id : all[b]) {\n\t\t\tdata[id] = { a, data[id].second + d };\n\t\t}\n\t\tall[a].reserve(all[a].size() + all[b].size());\n\t\tcopy(all[b].begin(), all[b].end(), back_inserter(all[a]));\n\t}\n\tbool same(int a, int b) const {\n\t\treturn data[a].first == data[b].first;\n\t}\n\tT dist(int a, int b) const {\n\t\treturn data[b].second - data[a].second;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tweighted_quick_find<int> wqf(n);\n\twhile (q--) {\n\t\tint com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif (com == 0) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\twqf.unite(x, y, z);\n\t\t}\n\t\telse if (wqf.same(x, y)) {\n\t\t\tprintf(\"%d\\n\", wqf.dist(x, y));\n\t\t}\n\t\telse {\n\t\t\tputs(\"?\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n// Manages Weighted Union-Find Forest.\nclass WeightedUnionFindForest {\n  std::vector<int> parent_;\n  std::vector<int> rank_;\n  std::vector<int> size_;\n  std::vector<int> weight_;\n\n public:\n  // Initialize forest.\n  // parent_[i]=i, rank_[i]=0, size_[i]=1, weight_[i]=0.\n  WeightedUnionFindForest(int n);\n  // Get the number of the root of the node q.\n  int Root(int q);\n  // Return true if the roots of x and y is same.\n  bool IsSame(int x, int y);\n  // Unite the tree x and tree y(weight is w).\n  // If x and y already have been united, return false.\n  bool Unite(int x, int y, int w);\n  // Get the number of nodes which are the same group as node q.\n  int Size(int q);\n  // Get the weight of node q.\n  int Weight(int q);\n  // Get the weights' difference of node x and y.\n  int Diff(int x, int y);\n};\n\nWeightedUnionFindForest::WeightedUnionFindForest(int n) {\n  for (int i = 0; i < n; i++) {\n    parent_.push_back(i);\n    rank_.push_back(0);\n    size_.push_back(1);\n    weight_.push_back(0);\n  }\n}\nint WeightedUnionFindForest::Size(int q) {\n  return size_[Root(q)];\n}\nint WeightedUnionFindForest::Root(int q) {\n  if (parent_[q] == q) {\n    return q;\n  } else {\n    int r = Root(parent_[q]);\n    weight_[q] += weight_[parent_[q]];\n    return parent_[q] = r;\n  }\n}\n\nbool WeightedUnionFindForest::IsSame(int x, int y) {\n  return Root(x) == Root(y);\n}\n\nint WeightedUnionFindForest::Weight(int q) {\n  Root(q);  // compress path\n  return weight_[q];\n}\nint WeightedUnionFindForest::Diff(int x, int y) {\n  if (Root(x) != Root(y)) {\n    // cerr << \"WeightedUnionFindForest: Error\" << endl;\n    // cerr << \"Roots of node x and y aren't same\" << endl;\n    return INT32_MAX;\n  }\n  return Weight(y) - Weight(x);\n}\n\nbool WeightedUnionFindForest::Unite(int x, int y, int w) {\n  w += Weight(x);\n  w -= Weight(y);\n  x = Root(x);\n  y = Root(y);\n\n  if (x == y) return false;\n  if (rank_[x] < rank_[y]) {\n    weight_[x] = w * (-1);\n    parent_[x] = y;\n    size_[y] += size_[x];\n    size_[x] = 0;\n\n  } else {\n    weight_[y] = w;\n    parent_[y] = x;\n    size_[x] += size_[y];\n    size_[y] = 0;\n    if (rank_[x] == rank_[y]) rank_[x]++;\n  }\n  return true;\n}\n\n// for verifying\n// this code solves Weighted Union Find\n// Trees(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_1_B&lang=jp).\n\nint main(void) {\n  int n, q;\n  cin >> n >> q;\n  WeightedUnionFindForest WUFF(n);\n  for (int i = 0; i < q; i++) {\n    int a, x, y, z;\n    cin >> a;\n    switch (a) {\n      case 0:\n        cin >> x >> y >> z;\n        WUFF.Unite(x, y, z);\n        break;\n      case 1:\n        cin >> x >> y;\n        int result = WUFF.Diff(x, y);\n        if (result == INT32_MAX) {\n          cout << \"?\" << endl;\n        } else {\n          cout << result << endl;\n        }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(ll I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nclass UnionFind{\npublic:\n\tvector<ll> par;\n\tvector<ll> d;\n\t//0-indexed\n\tUnionFind(ll n){\n\t\tinit(n);\n\t}\n\tvoid init(ll n = 1) {\n\t\tpar.resize(n);\n\t\td.resize(n,0);\n\t\tfor (ll i = 0; i < n; ++i) par[i] = i;\n\t}\n\tll len1(ll x){\n\t\tif(par[x]==x)return 0;\n\t\tll ans = d[x];\n\t\tans += len1(par[x]);\n\t\treturn ans;\n\t}\n\tll root(ll x = 1){\n\t\tif(par[x]==x)return x;\n\t\telse{\n\t\t\td[x] = len1(par[x]) + d[x];\n\t\t\treturn par[x] = root(par[x]);\n\t\t}\n\t}\n\tll length(ll x,ll y){ // xから右にlengthいったところにy\n\t\treturn len1(y) - len1(x);\n\t}\n\tvoid unite(ll x,ll y,ll dd){ // xから右にdだけ離れたところにy\n\t\tdd += len1(x);x=root(x);\n\t\tdd -= len1(y);y=root(y);\n\t\tif(x==y)return;\n\t\tif(dd>=0){\n\t\t\td[y] = dd;\n\t\t\tpar[y] = x;\n\t\t}else{\n\t\t\td[x] = -dd;\n\t\t\tpar[x] = y;\n\t\t}\n\t}\n};\n \nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll N,Q,a,x,y,z;\n\tcin >> N >> Q;\n\tUnionFind uf(N);\n\tFOR(i,0,Q){\n\t\tcin >> a;\n\t\tif(a==0){\n\t\t\tcin >> x >> y >> z;\n\t\t\tuf.unite(x,y,z);\n\t\t}else{\n\t\t\tcin >> x >> y;\n\t\t\tif(uf.root(x)!=uf.root(y)){\n\t\t\t\tcout << \"?\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << uf.length(x,y) << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\n\n#include <vector>\n\ntemplate <typename T>\nstruct WeightedUnionFind\n{\n    vector<int> data;\n    vector<T> weight_diff;\n\n\n    WeightedUnionFind(int sz) : data(sz, -1), weight_diff(sz) {}\n\n    int find(int k)\n    {\n        if (data[k] < 0)\n            return k;\n        auto par = find(data[k]);\n        weight_diff[k] += weight_diff[data[k]];\n        return data[k] = par;\n    }\n\n    T weight(int t)\n    {\n        find(t);\n        return weight_diff[t];\n    }\n\n    bool unite(int x, int y, T w)\n    {\n        w += weight(x);\n        w -= weight(y);\n        x = find(x), y = find(y);\n        if (x == y)\n            return false;\n        if (data[x] > data[y])\n        {\n            swap(x, y);\n            w *= -1;\n        }\n        data[x] += data[y];\n        data[y] = x;\n        weight_diff[y] = w;\n        return true;\n    }\n\n    T diff(int x, int y)\n    {\n        return weight(y) - weight(x);\n    }\n\n    bool same(int x, int y)\n    {\n        return (find(x) == find(y));\n    }\n};\n\nint main()\n{\n    int N, q;\n    cin >> N >> q;\n    WeightedUnionFind<int> uf(N);\n    for (int i = 0; i < q; i++)\n    {\n        int a;\n        cin >> a;\n        if (a == 0)\n        {\n            int x, y, z;\n            cin >> x >> y >> z;\n            uf.unite(x, y, z);\n        }\n        else\n        {\n            int x, y;\n            cin >> x >> y;\n            if (uf.same(x, y) == true)\n            {\n                cout << uf.diff(x, y) << endl;\n            }\n            else\n            {\n                cout << \"?\" << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint f[1000001];\nint v[1000001];\nint find(int x){\n  if(f[x]==x){\n    return x;\n  }else{\n    int fx=f[x];\n    f[x]=find(f[x]);\n    v[x]+=v[fx];\n    return f[x];\n  }\n}\nvoid join(int x,int y,int z){\n  int fx=find(x);\n  int fy=find(y);\n  if(fx!=fy){\n    v[fx]=z+v[y]-v[x];\n    f[fx]=fy;\n  }\n}\nint main(){\n  int n,q,t,l,r;\n  cin >> n >> q;\n  for(int i=0;i<=n;i++)f[i]=i;\n  while(q--){\n    cin >> t >> l >> r;\n    if(t){\n      int fx=find(l);\n      int fy=find(r);\n      if(fx==fy){\n\tcout<<v[l]-v[r]<<endl;\n      }else cout<<\"?\"<<endl;\n    }else{\n      int z;cin>>z;\n      join(l,r,z);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[LINE \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n};\n// }}}\n\n//--------------------------------------------------------------------\n\nstruct WeightedUnionFind {\n    vector<i64> ps_;  // 親ノード。ただし根の場合 -(集合の要素数)\n    vector<i64> ws_;  // 親ノードに対する重み(負もOK)。根の場合0\n\n    explicit WeightedUnionFind(i64 n) : ps_(n,-1), ws_(n,0) {}\n\n    i64 root(i64 x) {\n        return get<0>(compress(x));\n    }\n\n    // 根に対する重み\n    i64 weight(i64 x) {\n        return get<1>(compress(x));\n    }\n\n    // x, y を併合する\n    // x に対する y の重みを d とする\n    // 併合できたかどうかを返す\n    // x, y が元々同一集合に属する場合、d の値によっては矛盾が生じて併合不能\n    bool unite(i64 x, i64 y, i64 d) {\n        i64 rx, ry, wx, wy;\n        tie(rx,wx) = compress(x);\n        tie(ry,wy) = compress(y);\n        if(rx == ry) return wx + d == wy;\n\n        // 要素数が大きい方を根とする\n        i64 kx = -ps_[rx];\n        i64 ky = -ps_[ry];\n        if(kx < ky) {\n            swap(rx, ry);\n            swap(wx, wy);\n            d *= -1;\n        }\n        ps_[rx] = -(kx + ky);\n        ps_[ry] = rx;\n        ws_[ry] = wx - wy + d;\n        return true;\n    }\n\n    // 経路圧縮\n    // (xの根、根に対するxの重み) を返す\n    tuple<i64,i64> compress(i64 x) {\n        i64 p = ps_[x];\n        if(p < 0) return make_tuple(x, 0);\n\n        i64 r,d; tie(r,d) = compress(p);\n        ps_[x]  = r;\n        ws_[x] += d;\n        return make_tuple(r, ws_[x]);\n    }\n};\n\ni64 N;\n\nvoid solve() {\n    i64 Q; RD(Q);\n\n    WeightedUnionFind wuf(N);\n    REP(_, Q) {\n        i64 cmd; RD(cmd);\n        if(cmd == 0) {\n            i64 x,y,z; RD(x); RD(y); RD(z);\n            if(!wuf.unite(x,y,z))\n                assert(false);\n        }\n        else if(cmd == 1) {\n            i64 x,y; RD(x); RD(y);\n            i64 rx = wuf.root(x);\n            i64 ry = wuf.root(y);\n            if(rx != ry) {\n                PRINTLN(\"?\");\n            }\n            else {\n                i64 ans = wuf.weight(y) - wuf.weight(x);\n                PRINTLN(ans);\n            }\n        }\n        else {\n            assert(false);\n        }\n    }\n}\n\nsigned main() {\n    RD(N);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n#define BUF_SIZE 30\n#define DIVISOR 1000000007\n\n// size: specify sizeof(str)\nint get_str(char *str, int size) {\n    if(!fgets(str, size, stdin)) return -1;\n    return 0;\n}\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\nint get_int2(int *a1, int *a2) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d\", a1, a2);\n#else\n#error\n#endif\n  return 0;\n}\n\nint get_int3(int *a1, int *a2, int *a3) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d %d\", a1, a2, a3);\n#else\n#error\n#endif\n  return 0;\n}\n\nint get_int4(int *a1, int *a2, int *a3, int *a4) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d %d %d\", a1, a2, a3, a4);\n#else\n#error\n#endif\n  return 0;\n}\n\nenum query_type {\n    QUERY_RELATE,\n    QUERY_DIFF,\n};\n\nstruct wufind {\n    int parent;\n    int depth;\n    int weight;\n};\n\n#define VERTEX_MAX 100000\n\nstruct wufind *create_wufind(int vs) {\n    static struct wufind wu[VERTEX_MAX];\n    int i;\n    for(i = 0; i < vs; i++) {\n        wu[i].parent = i;\n    }\n    return wu;\n}\n\nint find_root(struct wufind *wufind, int v1) {\n    struct wufind *elem = &wufind[v1];\n    int base = v1;\n    if(base == elem->parent) {\n        return base;\n    } else {\n        int root = find_root(wufind, elem->parent);\n        struct wufind *par = &wufind[elem->parent];\n        elem->weight += par->weight;\n        elem->parent = root;\n        return root;\n    }\n}\n\nint is_connect(struct wufind *wufind, int v1, int v2) {\n    int bv1 = find_root(wufind, v1);\n    int bv2 = find_root(wufind, v2);\n    return bv1 == bv2;\n}\n\nvoid relate(struct wufind *wufind, int v1, int v2, int diff) {\n    int bv1 = find_root(wufind, v1); int w1 = wufind[v1].weight;\n    int bv2 = find_root(wufind, v2); int w2 = wufind[v2].weight;\n    struct wufind *root1 = &wufind[bv1];\n    struct wufind *root2 = &wufind[bv2];\n    int neww = w1 + diff - w2; // 2->1\n    if(root1->depth >= root2->depth) {\n        if(root1->depth == root2->depth) root1->depth++;\n        root2->depth = root1->depth;\n        root2->parent = bv1;\n        // 2->1(positive)\n        root2->weight = neww;\n    } else {\n        root1->depth = root2->depth;\n        root1->parent = bv2;\n        // 1->2(negative)\n        root1->weight = -neww;\n    }\n    return;\n}\n\n// v1->v2\nint get_dist(struct wufind *wufind, int v1, int v2) {\n    find_root(wufind, v1); find_root(wufind, v2);\n    struct wufind *elem1 = &wufind[v1];\n    struct wufind *elem2 = &wufind[v2];\n    return elem2->weight - elem1->weight;\n}\n\nint main(void) {\n    int num, queries;\n    get_int2(&num, &queries);\n    int i;\n    struct wufind *wufind = create_wufind(num);\n    for(i = 0; i < queries; i++) {\n        int type, v1, v2, diff;\n        get_int4(&type, &v1, &v2, &diff);\n        switch(type) {\n            case QUERY_RELATE:\n                // v1->v2: diff\n                relate(wufind, v1, v2, diff);\n                break;\n            case QUERY_DIFF:\n                if(!is_connect(wufind, v1, v2)) {\n                    printf(\"?\\n\");\n                } else {\n                    int res = get_dist(wufind, v1, v2);\n                    printf(\"%d\\n\", res);\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DSL_1_B Weighted Union Find Trees\n// 2018.4.28 bal4u\n\n#include <stdio.h>\n\n// <重み付きUnion Find>\n#define MAX 100003\n\nint par[MAX], ws[MAX];\n\nvoid initWeightedUnionFind(int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) par[i] = -1;\n}\n\nint find(int x)\n{\n\tint p;\n\tif (par[x] < 0) return x;\n    p = find(par[x]), ws[x] += ws[par[x]];\n    return par[x] = p;\n}\n    \nint weight(int x)\n{\n    find(x); \n    return ws[x];\n}\n    \nint unite(int x, int y, int w)  // x <-(w)- y (x + w = y)\n{\n\tint tmp;\n\n    w += weight(x), w -= weight(y);\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    if (par[y] < par[x]) // 多い方が根になるようにスワップする.\n        tmp = x, x = y, y = tmp, w = -w;\n    \n    par[x] += par[y], par[y] = x;\n    ws[y] = w;\n    return 1;\n}\n    \nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\n// *ans = x - y. 比較不能なら return 0.\nint diff(int *ans, int x, int y)\n{\n    if (find(x) != find(y)) return 0;\n\t*ans = ws[x] - ws[y];\n\treturn 1;\n}\n// </重み付きUnion Find>\n\n#define gc() getchar_unlocked()\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, q, k, x, y, z;\n\t\n\tn = in(), q = in();\n\tinitWeightedUnionFind(n);\n\twhile (q--) {\n\t\tif (in()) {\n\t\t\tx = in(), y = in();\n\t\t\tz = diff(&k, x, y);\n\t\t\tif (!z) puts(\"?\");\n\t\t\telse printf(\"%d\\n\", k);\n\t\t} else {\n\t\t\tx = in(), y = in(), z = in();\n\t\t\tunite(y, x, z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, n, v, x, y, z, dx, dy;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  fgets(buf, 32, stdin);\n  for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n  int s[n], d[n];\n  for (i=0; i<n; s[i]=i,d[i++]=0);\n  while (fgets(buf, 32, stdin)) {\n    for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n    if (buf[0]=='0') { // relate x y z\n      for (y=0,p++; *p!=' '; y=y*10+*(p++)-'0');\n      for (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n      for (dx=0; s[x]!=x; dx+=d[x],x=s[x]);\n      for (dy=0; s[y]!=y; dy+=d[y],y=s[y]);\n      if (x==y) continue;\n      if (x<y) {\n\ts[y] = x;\n\td[y] = dx + z - dy;\n      }\telse {\n\ts[x] = y;\n\td[x] = dy - z - dx;\n      }\n    } else { // diff\n      for (y=0,p++; *p!='\\n'; y=y*10+*(p++)-'0');\n      for (v=0; s[x]!=x; v-=d[x], x=s[x]);\n      for (;s[y]!=y; v+=d[y], y=s[y]);\n      if (x!=y) {\n\tputc_unlocked('?', stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n\ti=30;\n\tif (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\telse if (v<0) {\n\t  for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t  buf[--i] = '-';\n\t} else  buf[--i] = '0';\n\tfputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n#define Q 10001\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint Same(int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==Q) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n\n    if(rx==ry) exit(0); // false\n    \n    if(rank[rx] > rank[ry]){\n        p[ry] = rx;\n        weight[ry]=z+weight[x]-weight[y];\n    }\n    else{\n        p[rx]=ry;\n        weight[rx]=-z+weight[y]-weight[x];\n        if(rank[rx]==rank[ry]) rank[ry]=rank[ry]+1;\n    }\n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint Same(int x, int y){\n    if(findSet(x)==findSet(y)) return 1;\n    else return 0;\n}\n\nint diff(int x, int y){\n    if(Same(x,y)==0) return Q;\n    else return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, n, v, x, y, z, dx, dy;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  fgets(buf, 32, stdin);\n  for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n  int s[n], d[n];\n  for (i=0; i<n; s[i]=i,d[i++]=0);\n  while (fgets(buf, 32, stdin)) {\n    for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n    for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n    if (buf[0]=='0') { // relate x y z\n      for (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n      for (dx=0; s[x]!=x; dx+=d[x],x=s[x]);\n      for (dy=0; s[y]!=y; dy+=d[y],y=s[y]);\n      if (x<y) {\n\ts[y] = x;\n\td[y] = dx + z - dy;\n      }\telse if (x>y){\n\ts[x] = y;\n\td[x] = dy - z - dx;\n      } else continue;\n    } else { // diff\n      for (v=0; s[x]!=x; v-=d[x], x=s[x]);\n      for (;s[y]!=y; v+=d[y], y=s[y]);\n      if (x!=y) {\n\tputc_unlocked('?', stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n\ti=30;\n\tif (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\telse if (v<0) {\n\t  for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t  buf[--i] = '-';\n\t} else  buf[--i] = '0';\n\tfputs_unlocked(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nvoid main(int argc,char* argv){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==-1) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    link(findSet(x),findSet(y),z);\n}\n\nvoid link(int x, int y, int w){\n    if(rank[x] > rank[y]){\n        p[y] = x;\n        weight[y]=w-weight[y]+weight[x];\n    }\n    else{\n        p[x]=y;\n        weight[x]=-w-weight[x]+weight[y];\n        if(rank[x]==rank[y]) rank[y]=rank[y]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint diff(int x, int y){\n    if(weight[x]==0 || weight[y]==0) return -1;\n    return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n#define Q 10001\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint Same(int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==Q) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n    \n    if(rank[rx] > rank[ry]){\n        p[ry] = rx;\n        weight[ry]=z+weight[x]-weight[y];\n    }\n    else{\n        p[rx]=ry;\n        weight[rx]=-z+weight[y]-weight[x];\n        if(rank[rx]==rank[ry]) rank[ry]=rank[ry]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint Same(int x, int y){\n    if(findSet(x)==findSet(y)) return 1;\n    else return 0;\n}\n\nint diff(int x, int y){\n    if(Same(x,y)==0) return Q;\n    else return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF (1LL<<60)\n#define MOD1 1000000007\n\nvoid swap(ll *a, ll *b){ll c;c=*b;*b=*a;*a=c;}/*swap 交換*/\nll max2(ll a,ll b){return a>=b?a:b;}/*2つのうち大きい数を返す*/ \nll min2(ll a,ll b){return a>=b?b:a;}/*2つのうち小さい数を返す*/ \nll ABS(ll a){return a>=0?a:(-a);}/*絶対値*/ \nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\n\ntypedef struct{\n    ll num; //number\n    ll par; //parent\n    ll height; //height\n    ll wdif;\n    ll weight;\n}WUF;\n\nvoid WUFmake(ll n, WUF b[n]){for(ll i=0;i<n;i++){\n    b[i].par = i; b[i].num = i; b[i].height = 1; b[i].wdif = 0; b[i].weight = 0;}}\n\nll WUFroot(ll n, ll a, WUF b[n]){\n    // b[a].weight = b[b[a].par].weight + b[a].wdif;\n    // return a==b[a].par ? a : WUFroot(n,b[a].par,b) ;\n    ll c= a==b[a].par ? a : WUFroot(n,b[a].par,b) ;\n    b[a].weight = b[b[a].par].weight + b[a].wdif;\n    return c;\n}\n\n// b[x]+z=b[y]\nvoid WUFunite(ll n, ll x, ll y, ll z, WUF b[n]){\n    ll xroot = WUFroot(n,x,b), yroot = WUFroot(n,y,b);\n    if(b[xroot].height > b[yroot].height){\n        b[yroot].par = xroot;\n        b[yroot].wdif = b[x].weight+z-b[y].weight;\n    }else{\n        b[xroot].par = yroot;\n        b[yroot].height = max2(b[yroot].height,b[xroot].height+1);\n        b[xroot].wdif = b[y].weight-b[x].weight-z;\n    }\n}\n\nll WUFsame(ll n, ll x, ll y, WUF b[n]){\n    return WUFroot(n,x,b) == WUFroot(n,y,b) ? 1 : 0; \n    // if( WUFroot(n,x,b) == WUFroot(n,y,b) ){\n    //     return 1;\n    // }\n    // return 0;\n}\n\n\nint main(void){\n    ll n,q,i;\n    scanf(\"%lld%lld\",&n,&q);\n    ll query[q],x[q],y[q],z[q];\n    WUF tree[n];\n    WUFmake(n,tree);\n    rep(i,0,q){\n        scanf(\"%lld\",&query[i]);\n        if(query[i]==0){\n            scanf(\"%lld%lld%lld\",&x[i],&y[i],&z[i]);\n        }else{\n            scanf(\"%lld%lld\",&x[i],&y[i]);\n        }\n    }\n    rep(i,0,q){\n        if(query[i]==0){\n            if(!WUFsame(n,x[i],y[i],tree)){\n                WUFunite(n,x[i],y[i],z[i],tree);\n            }\n        }else{\n            if(WUFsame(n,x[i],y[i],tree)){\n                printf(\"%lld\\n\",tree[y[i]].weight-tree[x[i]].weight);\n            }else{\n                printf(\"?\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n    int i, j;\n    int n, q;\n    int x, y, z;\n    int *a;\n    int com;\n\n    scanf(\"%d%d\", &n, &q);\n    a=malloc(sizeof(int) * n * n);\n    for(i=0;i<n*n;i++)a[i]=-1;\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com==0){\n            scanf(\"%d%d%d\", &x, &y, &z);\n            a[y*n+x]=z;\n            for(j=0;j<n;j++){\n                if(a[y*n+j]!=-1 && j!=x){\n                    if(a[y*n+j]>a[y*n+x])a[x*n+j]=a[y*n+j]-a[y*n+x];\n                    else a[j*n+x]= a[y*n+x]-a[y*n+j];\n                }\n                if(a[x*n+j]!=-1)a[y*n+j]=a[y*n+x]+a[x*n+j];\n                if(a[j*n+x]!=-1 && j!=y){\n                    if(a[j*n+x]>a[y*n+x])a[j*n+y]=a[j*n+x]-a[y*n+x];\n                    else a[y*n+j]=a[y*n+x]-a[j*n+x];\n                }\n                if(a[j*n+y]!=-1)a[j*n+x]=a[y*n+x]+a[j*n+y];\n            }\n        }else{\n            scanf(\"%d%d\", &x, &y);\n            if(a[y*n+x]==-1)printf(\"?\\n\");\n            else printf(\"%d\\n\", a[y*n+x]);\n        }\n    }\n    free(a);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(int i=l;i<r;i++)\n#define INF (1LL<<62)\n\n//union-find\n#define UFLIMIT (1<<17)\nint unicnt[UFLIMIT+10];//正ならcnt、非正なら親のindex\nll uniwei[UFLIMIT+10];\nvoid ufinit(int n){rep(i,0,n)unicnt[i]=1;}\nint uniroot(int x){int r;return unicnt[x]<=0?r=uniroot(-unicnt[x]),uniwei[x]+=uniwei[-unicnt[x]],-(unicnt[x]=-r):x;}\nint unisame(int x,int y){return uniroot(x)==uniroot(y);}\nll unidiff(int x,int y){return unisame(x,y)?uniwei[y]-uniwei[x]:INF;}\n//diff(x,y)=wになるようにする。矛盾したらfalse\nint uni(int x,int y,ll w){\n\tint rx=uniroot(x),ry=uniroot(y);\n\tif(rx==ry)return unidiff(rx,x)+unidiff(x,y)+unidiff(y,ry)==unidiff(rx,ry);\n\tw=unidiff(rx,x)+w+unidiff(y,ry);\n\tif(unicnt[rx]<unicnt[ry]){int t=rx;rx=ry;ry=t;w=-w;}\n\tunicnt[rx]+=unicnt[ry];\n\tunicnt[ry]=-rx;\n\tuniwei[ry]=w;\n\treturn 1;\n}\n#undef UFLIMIT\n\nint main(){\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tufinit(n);\n\twhile(q--){\n\t\tint t,x,y;\n\t\tscanf(\"%d%d%d\",&t,&x,&y);\n\t\tif(t){\n\t\t\tll d=unidiff(x,y);\n\t\t\tprintf(d==INF?\"?\\n\":\"%lld\\n\",d);\n\t\t}else{\n\t\t\tint w;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tuni(x,y,w);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, n, v, x, y, z, dx, dy;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  fgets(buf, 32, stdin);\n  for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n  int s[n], d[n];\n  for (i=0; i<n; s[i]=i,d[i++]=0);\n  while (fgets(buf, 32, stdin)) {\n    for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n    for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n    if (buf[0]=='0') { // relate x y z\n      for (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n      for (dx=0; s[x]!=x; dx+=d[x],x=s[x]);\n      for (dy=0; s[y]!=y; dy+=d[y],y=s[y]);\n      if (x==y) continue;\n      if (x<y) {\n\ts[y] = x;\n\td[y] = dx + z - dy;\n      }\telse {\n\ts[x] = y;\n\td[x] = dy - z - dx;\n      }\n    } else { // diff\n      for (v=0; s[x]!=x; v-=d[x], x=s[x]);\n      for (;s[y]!=y; v+=d[y], y=s[y]);\n      if (x!=y) {\n\tputc_unlocked('?', stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n\ti=30;\n\tif (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\telse if (v<0) {\n\t  for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t  buf[--i] = '-';\n\t} else  buf[--i] = '0';\n\tfputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, n, v, x, y, z, dx, dy, x0, y0;\n  char *p, buf[32];\n  buf[31]=0;\n  buf[30]='\\n';\n  fgets(buf, 32, stdin);\n  for (n=0,p=buf; *p!=' '; n=n*10+*(p++)-'0'); \n  int s[n], d[n];\n  for (i=0; i<n; s[i]=i,d[i++]=0);\n  while (fgets(buf, 32, stdin)) {\n    for (x=0,p=buf+2; *p!=' '; x=x*10+*(p++)-'0');\n    for (y=0,p++; *p>='0'; y=y*10+*(p++)-'0');\n    if (buf[0]=='0') { // relate x y z\n      for (z=0,p++; *p!='\\n'; z=z*10+*(p++)-'0');\n      for (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n      for (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n      s[x0]=x;\n      d[x0]=dx;\n      s[y0]=y;\n      d[y0]=dy;\n      if (x<y) {\n\ts[y] = x;\n\td[y] = z + dx - dy;\n      }\telse if (x>y) {\n\ts[x] = y;\n\td[x] = -z - dx + dy;\n      } else continue;\n    } else { // diff\n      for (x0=x,dx=0; s[x]!=x; dx+=d[x], x=s[x]);\n      for (y0=y,dy=0; s[y]!=y; dy+=d[y], y=s[y]);\n      s[x0]=x;\n      d[x0]=dx;\n      s[y0]=y;\n      d[y0]=dy;\n      v=-dx+dy;\n      if (x!=y) {\n\tputc_unlocked('?', stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n\ti=30;\n\tif (v>0)  for (; v>0; buf[--i]='0'+v%10,v/=10);\n\telse if (v<0) {\n\t  for (; v<0; buf[--i]='0'-v%10,v/=10);\n\t  buf[--i] = '-';\n\t} else  buf[--i] = '0';\n\tfputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define NMAX 100000\n\nint ufpar[NMAX], ufw[NMAX];\n\nint UF_find(int);\nint UF_weight(int);\nint UF_union(int, int, int);\nint UF_diff(int*, int, int);\nint main(void)\n{\n  int i, n, q, com, x, y, z, ans;\n  scanf(\"%d %d\", &n, &q);\n  memset(ufpar, -1, sizeof(ufpar));\n  for (i = 0; i < q; i++) {\n    scanf(\"%d\", &com);\n    if (com) {\n      scanf(\"%d %d\", &x, &y);\n      z = UF_diff(&ans, x, y);\n      if (z) printf(\"%d\\n\", ans);\n      else printf(\"?\\n\");\n    } else {\n      scanf(\"%d %d %d\", &x, &y, &z);\n      UF_union(x, y, z);\n    }\n  }\n}\n\nint UF_find(int a)\n{\n  int p;\n  if (ufpar[a] < 0) return a;\n  p = UF_find(ufpar[a]);\n  ufw[a] += ufw[ufpar[a]];\n  return ufpar[a] = p;\n}\n\nint UF_weight(int a)\n{\n  UF_find(a);\n  return ufw[a];\n}\n\nint UF_union(int x, int y, int w)\n{\n  w -= UF_weight(x);\n  w += UF_weight(y);\n  x = UF_find(x);\n  y = UF_find(y);\n  if (x == y) return 0;\n  if (ufpar[x] > ufpar[y]) {\n    ufpar[y] += ufpar[x];\n    ufpar[x] = y;\n    ufw[x] = w;\n  } else {\n    ufpar[x] += ufpar[y];\n    ufpar[y] = x;\n    ufw[y] = -w;\n  }\n  return 1;\n}\n\nint UF_diff(int *ans, int x, int y)\n{\n  if (UF_find(x) != UF_find(y)) return 0;\n  else {\n    *ans = ufw[x] - ufw[y];\n    return 1;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n#define Q 10001\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==Q) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n    \n    if(rank[rx] > rank[ry]){\n        p[ry] = rx;\n        weight[ry]=z-weight[y]+weight[x];\n    }\n    else{\n        p[rx]=ry;\n        weight[rx]=-z-weight[x]+weight[y];\n        if(rank[rx]==rank[ry]) rank[ry]=rank[ry]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        //weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint diff(int x, int y){\n    if(weight[x]==0 || weight[y]==0) return Q;\n    return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==-1) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n    \n    if(rank[rx] < rank[ry]){\n        p[rx] = ry;\n        weight[rx]=z-weight[x]+weight[y];\n    }\n    else{\n        p[ry]=rx;\n        weight[ry]=-z-weight[y]+weight[x];\n        if(rank[rx]==rank[ry]) rank[rx]=rank[rx]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        //weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint diff(int x, int y){\n    if(weight[x]==0 || weight[y]==0) return -1;\n    return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint A[100000];\nint W[100000];\n\ntypedef struct _PW {\n  int pos;\n  int wgt;\n} PW;\n\nPW findSet(int pos) {\n  int tgt;\n  PW pw;\n  pw.pos = pos;\n  tgt = A[pos];\n  pw.wgt = 0;\n\n  while (pw.pos != tgt) {\n    pw.wgt += W[pw.pos];\n    pw.pos = tgt;\n    tgt = A[pw.pos];\n  }\n\n  return pw;\n}\n\nint diff(int s, int d) {\n  \n  PW spw, dpw;\n  spw = findSet(s);\n  dpw = findSet(d);\n\n  if (spw.pos != dpw.pos) return -1;\n  \n  return abs(spw.wgt - dpw.wgt);\n}\n\nvoid relate(int pos, int dis, int wgt) {\n  int tgt, flg;\n  tgt = A[pos];\n  flg = 1;\n  while (flg) {\n    if (pos == tgt) {\n      A[pos] = dis;\n      W[pos] = wgt;\n      flg = 0;\n    }\n    else {\n      wgt -= W[pos];\n      if (wgt < 0) {\n        A[pos] = dis;\n        W[pos] += wgt;\n        A[dis] = tgt;\n        W[dis] = wgt * (-1);\n        flg = 0;\n      }\n      else {\n        pos = tgt;\n        tgt = A[pos];\n      }\n    }\n  }\n}\n\nint main() {\n\tint i, n, q, x, y, z;\n\tint code, ans;\n\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (i = 0; i < n; i++) {\n\t\tA[i] = i;\n\t\tW[i] = 0;\n\t}\n\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &code);\n    if (code) {\n      scanf(\"%d %d\", &x, &y);\n      ans = diff(x, y);\n      if (ans < 0) printf(\"?\\n\");\n      else printf(\"%d\\n\", ans);\n    }\n    else {\n      scanf(\"%d %d %d\", &x, &y, &z);\n      relate(x, y, z);\n    }\n\t}\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*) calloc ((size), sizeof (type)))\n\ntypedef struct potential_union_find {\n  i32 *parent;\n  i32 *weight;\n  i32 size;\n} union_find;\n\nunion_find* new_union_find (i32 n) {\n  union_find *u = ALLOC (1, union_find);\n  u->parent = ALLOC (n, i32);\n  u->weight = ALLOC (n, i32);\n  for (i32 i = 0; i < n; ++i) {\n    u->parent[i] = -1;\n    u->weight[i] = 0;\n  }\n  return u;\n}\n\ni32 root (union_find *u, i32 x) {\n  while (u->parent[x] >= 0) {\n    x = u->parent[x];\n  }\n  return x;\n}\n\nint same (union_find *u, i32 x, i32 y) {\n  return root (u, x) == root (u, y);\n}\n\ni32 get_weight (union_find *u, i32 x) {\n  i32 sum = 0;\n  while (u->parent[x] >= 0) {\n    sum += u->weight[x];\n    x = u->parent[x];\n  }\n  return sum;\n}\n\nint unite (union_find *u, i32 x, i32 y, i32 z) {\n  z += get_weight (u, x);\n  z -= get_weight (u, y);\n  x = root (u, x);\n  y = root (u, y);\n  if (x == y) {\n    return z == 0;\n  }\n  if (u->parent[x] > u->parent[y]) {\n    i32 swap = x;\n    x = y;\n    y = swap;\n    z = -z;\n  }\n  u->parent[x] += u->parent[y];\n  u->parent[y] = x;\n  u->weight[y] = z;\n  return 1;\n}\n\nvoid run (void) {\n  i32 n, q;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &q);\n  union_find *u = new_union_find (n);\n  while (q--) {\n    i32 op, x, y;\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &op, &x, &y);\n    if (op == 0) {\n      i32 z;\n      scanf (\"%\" SCNi32, &z);\n      if (!unite (u, x, y, z)) {\n        puts (\"Contradiction\");\n        exit (1);\n      }\n    } else if (!same (u, x, y)) {\n      puts (\"?\");\n    } else {\n      printf (\"%\" PRIi32 \"\\n\", get_weight (u, y) - get_weight (u, x));\n    }\n  }\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==-1) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n    \n    if(rank[rx] > rank[ry]){\n        p[ry] = rx;\n        weight[ry]=z-weight[y]+weight[x];\n    }\n    else{\n        p[rx]=ry;\n        weight[rx]=-z-weight[x]+weight[y];\n        if(rank[rx]==rank[ry]) rank[ry]=rank[ry]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        //weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint diff(int x, int y){\n    if(weight[x]==0 || weight[y]==0) return -1;\n    return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 10100\n\nint *p;\nint *rank;\nint *weight; // weight_x-weight_p[x]. difference weight.\n\nvoid relate(int, int, int);\nvoid makeSet(int);\nvoid link(int, int,int);\nint findSet(int);\nint diff(int, int);\n\nint main(){\n    int n,q;\n    int com, x, y, z;\n    int *ans;\n    int i;\n\n    scanf(\"%d %d\", &n, &q);\n\n    // create S\n    p = (int *)malloc(n*sizeof(int));\n    rank = (int *)malloc(n*sizeof(int));\n    weight = (int *)malloc(n*sizeof(int));\n\n    // create array answer\n    ans = (int *)malloc(q*sizeof(int));\n    for(i=0;i<q;i++){\n        ans[i] = INF;\n    }\n\n    // make Set\n    for(i=0;i<n;i++){\n        makeSet(i);\n    }\n\n    for(i=0;i<q;i++){\n        scanf(\"%d\", &com);\n        if(com == 0){\n            scanf(\"%d %d %d\", &x,&y,&z);\n            relate(x, y, z);\n        }\n        else if(com == 1){\n            scanf(\"%d %d\", &x,&y);\n            ans[i] = diff(x, y);\n        }\n    }\n\n    // output\n    for(i=0;i<q;i++){\n        if(ans[i]!=INF){\n            if(ans[i]==-1) printf(\"?\\n\");\n            else printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return 0;\n}\n\nvoid makeSet(int x){\n    p[x] = x;\n    rank[x]=0;\n    weight[x]=0; \n}\n\nvoid relate(int x, int y, int z){\n    int rx,ry;\n\n    rx = findSet(x);\n    ry = findSet(y);\n    \n    if(rank[rx] > rank[ry]){\n        p[ry] = rx;\n        weight[ry]=z-weight[y]+weight[x];\n    }\n    else{\n        p[rx]=ry;\n        weight[rx]=-z-weight[x]+weight[y];\n        if(rank[rx]==rank[ry]) rank[ry]=rank[ry]+1;\n    }\n    \n}\n\nint findSet(int x){ // return root.\n    if(x!=p[x]){\n        p[x]=findSet(p[x]);\n        //weight[x]+=weight[p[x]];\n    }\n    return p[x];\n}\n\nint diff(int x, int y){\n    if(weight[x]==0 || weight[y]==0) return -1;\n    return weight[y]-weight[x];\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.*\nimport java.util.*\n\nval pw = PrintWriter(System.out)\n\nfun main(args: Array<String>) {\n    val (n, q) = readLine()!!.split(\" \").map{ it.toInt() }\n    val query = Array(q){ readLine()!! }\n    val uf = WeightedUnionFind(n)\n    repeat(q){\n        val ret = query[it].split(\" \").map{ it.toInt() }\n        if (ret[0] == 0){\n            uf.unite(ret[1], ret[2], ret[3].toLong())\n        }else{\n            val (x, y) = ret[1] to ret[2]\n            if (!uf.isSame(x, y)) pw.println(\"?\")\n            else pw.println(uf.getDiff(x, y))\n        }\n    }\n    pw.flush()\n}\n\n\n\nclass WeightedUnionFind(n: Int) {\n    data class Node(var parent: Int, var size: Int, var weight: Long)\n\n    private val nodes = Array(n) { Node(parent = it, size = 1, weight = 0) }\n    fun findRoot(x: Int): Int {\n        if (x == this.nodes[x].parent) return x\n        val root = findRoot(nodes[x].parent)\n        nodes[x].weight += nodes[nodes[x].parent].weight\n        nodes[x].parent = root\n        return root\n    }\n\n    fun unite(x: Int, y: Int, weight: Long): Boolean {\n        // nodes[x].weight + weight = nodes[y].weightとなるようにする\n        val xRoot = findRoot(x)\n        val yRoot = findRoot(y)\n        if (xRoot == yRoot) return false\n        val (smaller, bigger, newWeight) = when (getSize(xRoot) >= getSize(yRoot)) {\n            true -> Triple(yRoot, xRoot, nodes[x].weight - nodes[y].weight + weight)\n            else -> Triple(xRoot, yRoot, nodes[y].weight - nodes[x].weight - weight)\n        }\n        nodes[smaller].parent = bigger\n        nodes[bigger].size += nodes[smaller].size\n        nodes[smaller].weight = newWeight\n        return true\n    }\n\n    fun getWeight(x: Int): Long {\n        findRoot(x)\n        return nodes[x].weight\n    }\n\n    fun getDiff(x: Int, y: Int) = getWeight(y) - getWeight(x)\n    fun getSize(x: Int) = nodes[findRoot(x)].size\n    fun isSame(x: Int, y: Int) = findRoot(x) == findRoot(y)\n}\n\n"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nvoid main(int argc,char* argv){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main { //HDL-style Disjoint Set\n\tint N; // int_maxsize > 10000 (constrain)\n\tint Q; // int_maxsize > 110000 (worstcase = 10000initial set  + 100000 new set)\n\tboolean Com; //com only have two kind;\n\tint V1;\n\tint V2;\n\tint V3;\n\tint[] S1;\n\tint[] S2;\n\tScanner scanner;\n\tpublic static void main(String[] args){\n\t\tscanner = new Scanner(System.in);\n\t\tN = scanner.nextInt();\n\t\tS1 = new int[N];\n\t\tS2 = new int[N];\n\t\treset();\n\t\tQ = scanner.nextInt();\n\t\tFSM();\n\t}\n\t//end of main\n\tprivate static void reset(){\n\t\tCom = false;\n\t\tV1 = 0;\n\t\tV2 = 0;\n\t\tV3 = 0;\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tS1[i]=i;\n\t\t}\n\t}\n\t//end of reset\n\tprivate static void FSM(){\n\t\twhile(Q>0){\n\t\t\tfetch();\n\t\t\tdispatch();\n\t\t\tQ--;\n\t\t}\n\t}\n\t//end of FSM\n\tprivate static void fetch(){\n\t\tCom = (scanner.nextInt() > 0)?true:false;\n\t\t//V1 = scanner.nextInt();\n\t\t//V2 = scanner.nextInt();\n\t}\n\t//end of feteh\n\tprivate static void dispatch(){\n\t\tif(Com){\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tquery();\n\t\t}else {\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tV3 = scanner.nextInt();\n\t\t\trelate();\n\t\t}\n\t}\n\t//end of dispatch\n\tprivate static void relate(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\treturn;\n\t\t}else{\n\t\t\tmerge();\n\t\t}\n\t}\n\t//end of unite\n\tprivate static void query(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\tSystem.out.println(S2[V2] - S2[V1]);\n\t\t}else{\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n\t//end of same\n\tprivate static void merge(){\n\t\tV3 = S2[V2] - V3 - S2[V1];\n\t\tV1 = S1[V1];// use variable 1 to store the set code of V1\n\t\tV2 = S1[V2];// use variable 2 to store the set code of V2\n\t\tfor(int i = 0; i< N;i++)\n\t\t{\n\t\t\tif(S1[i] == V1){\n\t\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t\tS1[i] = V2;\n\t\t\t\tS2[i] = S2[i] + V3;\n\t\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n\n"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint N = 0;\nint Q = 0;\nint S1[100000];\nint S2[100000];\nint Com = 0;\nint V1 = 0;\nint V2 = 0;\nint V3 = 0;\nvoid relate();\nvoid query();\nvoid merge();\n\nint main(){\n\tint i = 0;\n\tscanf(\"%d %d\",&N,&Q);\n\tfor(i = 0; i<N ; i++){\n\t\tS1[i] = i;\n\t\tS2[i] = 0;\n\t}\n\n\twhile(Q>0){\n\t\tscanf(\"%d\",&Com);\n\t\tif(Com){\n\t\t\tscanf(\"%d %d\",&V1, &V2);\n\t\t\tquery();\n\t\t}else{\n\t\t\tscanf(\"%d %d %d\",&V1 ,&V2, &V3);\n\t\t\trelate();\n\t\t}\n\t\tQ--;\n\t}\n}\n\nvoid relate(){\n\t//printf(\"R : %d %d %d\\n\", V1, V2, V3);\n\tif(S1[V1] == S1[V2]){\n\t\treturn;\n\t}else{\n\t\tmerge();\n\t}\n}\n\nvoid merge(){\n\tint i = 0;\n\tV3 = S2[V2] - V3 -S2[V1];\n\tV1 = S1[V1];\n\tV2 = S1[V2];\n\tfor(i = 0; i<N ;i++){\n\t\tif(S1[i] == V1){\n\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t//printf(\"V1 = %d, V2 = %d, V3 = %d\\n\",V1, V2, V3);\n\t\t\tS1[i] = V2;\n\t\t\tS2[i] = S2[i] + V3;\n\t\t\t//printf(\"S2[%d] = %d\\n\", i, S2[i]);\n\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t}else{\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\nvoid query(){\n\t//printf(\"Q : %d %d \\n\", V1, V2);\n\tif(S1[V1] == S1[V2]){\n\t\tprintf(\"%d\\n\",S2[V2]-S2[V1]);\n\t}else{\n\t\tprintf(\"?\\n\");\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tint N=sc.nextInt();\n\t\tint Q=sc.nextInt();\n\t\tWUnionFindTree uft=new WUnionFindTree(N);\n\t\tfor(int i=0; i<Q; i++) {\n\t\t\tint com=sc.nextInt();\n\n\t\t\tif(com==0) {\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tint y=sc.nextInt();\n\t\t\t\tint z=sc.nextInt();\n\t\t\t\tuft.union(x,y,z);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tint y=sc.nextInt();\n\t\t\t\tInteger df=(Integer)uft.diff(x,y);\n\t\t\t\tif(df==null) {\n\t\t\t\t\tpl(\"?\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpl(df);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static class WUnionFindTree{\n\t\tint[] par; // 親の番号\n\t\tint[] ws;  // 親との重みの差\n\t\tpublic WUnionFindTree(int n){\n\t\t\tpar = new int[n+1];\n\t\t\tws  = new int[n+1];\n\t\t\tfor(int i = 0; i <= n; i++){ par[i] = -1; }\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x] < 0){\n\t\t\t\treturn x;\n\t\t\t}else{\n\t\t\t\tfinal int parent = find(par[x]);\n\t\t\t\tws[x] += ws[par[x]];\n\t\t\t\treturn par[x] = parent;\n\t\t\t}\n\t\t}\n\t\tpublic int weight(int x){\n\t\t\tfind(x);\n\t\t\treturn ws[x];\n\t\t}\n\t\tpublic boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n\t\t\tw += weight(x);\n\t\t\tw -= weight(y);\n\t\t\tx = find(x); y = find(y);\n\t\t\tif(x != y){\n\t\t\t\tif(par[y] < par[x]) {\n\t\t\t\t\tint tmp = x; x = y; y = tmp; w = -w;\n\t\t\t\t}\n\t\t\t\tpar[x] += par[y]; par[y] = x;\n\t\t\t\tws[y] = w;\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tpublic boolean same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\tpublic Integer diff(int x, int y){ // y - x を求める. 比較不能ならnull.\n\t\t\tif(!same(x, y)){ return null; }\n\t\t\treturn this.weight(y) - this.weight(x);\n\t\t}\n\t\tpublic int size(int x){\n\t\t\treturn -par[find(x)];\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main { //HDL-style Disjoint Set\n\tstatic int N; // int_maxsize > 10000 (constrain)\n\tstatic int Q; // int_maxsize > 110000 (worstcase = 10000initial set  + 100000 new set)\n\tstatic boolean Com; //com only have two kind;\n\tstatic int V1;\n\tstatic int V2;\n\tstatic int V3;\n\tstatic int[] S1;\n\tstatic int[] S2;\n\tstatic Scanner scanner;\n\tpublic static void main(String[] args){\n\t\tscanner = new Scanner(System.in);\n\t\tN = scanner.nextInt();\n\t\tS1 = new int[N];\n\t\tS2 = new int[N];\n\t\treset();\n\t\tQ = scanner.nextInt();\n\t\tFSM();\n\t\tscanner=null;\n\t\tif(scanner!=null){\n\t\t    scanner.close();\n\t\t}\n\t}\n\t//end of main\n\tprivate static void reset(){\n\t\tCom = false;\n\t\tV1 = 0;\n\t\tV2 = 0;\n\t\tV3 = 0;\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tS1[i]=i;\n\t\t}\n\t}\n\t//end of reset\n\tprivate static void FSM(){\n\t\twhile(Q>0){\n\t\t\tfetch();\n\t\t\tdispatch();\n\t\t\tQ--;\n\t\t}\n\t}\n\t//end of FSM\n\tprivate static void fetch(){\n\t\tCom = (scanner.nextInt() > 0)?true:false;\n\t\t//V1 = scanner.nextInt();\n\t\t//V2 = scanner.nextInt();\n\t}\n\t//end of feteh\n\tprivate static void dispatch(){\n\t\tif(Com){\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tquery();\n\t\t}else {\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tV3 = scanner.nextInt();\n\t\t\trelate();\n\t\t}\n\t}\n\t//end of dispatch\n\tprivate static void relate(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\treturn;\n\t\t}else{\n\t\t\tmerge();\n\t\t}\n\t}\n\t//end of unite\n\tprivate static void query(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\tSystem.out.println(S2[V2] - S2[V1]);\n\t\t}else{\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n\t//end of same\n\tprivate static void merge(){\n\t\tV3 = S2[V2] - V3 - S2[V1];\n\t\tV1 = S1[V1];// use variable 1 to store the set code of V1\n\t\tV2 = S1[V2];// use variable 2 to store the set code of V2\n\t\tfor(int i = 0; i< N;i++)\n\t\t{\n\t\t\tif(S1[i] == V1){\n\t\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t\tS1[i] = V2;\n\t\t\t\tS2[i] = S2[i] + V3;\n\t\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.logging.Logger;\n\nimport javax.sound.midi.MidiMessage;\n \npublic class Main {\n\t  static int MAX = 510000;\n\t\tstatic long[] fac=new long[MAX];\n\t\tstatic long[] finv=new long[MAX];\n\t\tstatic long[] inv=new long[MAX];\n\t\tstatic long MOD=(long) (Math.pow(10, 9)+7);\n\t\tstatic boolean[] visited;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\tint N=sc.nextInt();\n\t\tint q=sc.nextInt();\n\t\tUnionFindTree uTree=new UnionFindTree(N);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c=sc.nextInt();\n\t\t\tif (c==0) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tuTree.union(s, t, x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tif (!uTree.same(s, t)) {\n\t\t\t\t\tout.println(\"?\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tout.println(uTree.diff(s, t));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\t static class UnionFindTree{\n\t    \tint[] par;\n\t    \tint[] rank;\n\t    \tint[] size;\n\t    \tint[] diff_weight;\n\t    \tint arraysize;\n\t    \tpublic UnionFindTree(int n) {\n\t    \t\tthis.par=new int[n];\n\t    \t\tthis.rank=new int[n];\n\t    \t\tthis.size=new int[n];\n\t    \t\tthis.diff_weight=new int[n];\n\t    \t\tarraysize=n;\n\t    \t\tfor (int i = 0; i < arraysize; i++) {\n\t\t\t\t\tset(i);\n\t\t\t\t}\n\t    \t}\n\t    \tpublic void set(int i) {\n\t    \t\tpar[i]=i;\n\t    \t\trank[i]=0;\n\t    \t\tsize[i]=1;\n\t    \t\tdiff_weight[i]=0;\n\t    \t}\n\t    \tpublic void union(int x,int y,int w) {\n\t    \t\tw += weight(x); \n\t    \t\tw -= weight(y);\n\t    \t\tint rootx=find(x);\n\t    \t\tint rooty=find(y);\n\t    \t\tif (rootx==rooty) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t    \t\tif (rank[rootx]>rank[rooty]) {\n\t\t\t\t\tpar[rooty]=rootx;\n\t\t\t\t\tdiff_weight[rooty] = w;\n\t\t\t\t\tsize[rootx]+=size[rooty];\n\t\t\t\t}\n\t    \t\telse if (rank[rootx]<rank[rooty]) {\n\t\t\t\t\tpar[rootx]=rooty;\n\t\t\t\t\tw=-w;\n\t\t\t\t\tdiff_weight[rootx] = w;\n\t\t\t\t\tsize[rooty]+=size[rootx];\n\t\t\t\t}\n\t    \t\telse {\n\t    \t\t\tpar[rooty]=rootx;\n\t    \t\t\tdiff_weight[rooty] = w;\n\t    \t\t\trank[rootx]++;\n\t\t\t\t\tsize[rootx]+=size[rooty];\n\t\t\t\t}\n\t    \t}\n\t    \tpublic int find(int x) {\n\t    \t\tif(par[x] == x) return x;\n\t    \t\tint r = find(par[x]);\n\t    \t\tdiff_weight[x] += diff_weight[par[x]];\n\t    \t\treturn par[x] = r;\n\t    \t}\n\t    \tpublic int weight(int x) {\n\t    \t\tfind(x);\n\t    \t\treturn diff_weight[x];\n\t    \t}\n\t    \tpublic int size(int i) {\n\t            return size[find(i)];\n\t        }\n\t    \tpublic int diff(int x, int y) {\n\t    \t\treturn weight(y) - weight(x);\n\t    \t}\n\t    \tpublic boolean same(int x, int y) {\n\t            return find(x) == find(y);\n\t        }\n\t    }\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    //////////// Just add a system for weighting\npublic class UFTW_Node {\n\tint name;\n\tUFTW_Node next;\n\tint rank;\n\tint next_diff;\n\n\tpublic UFTW_Node(int new_name){\n\t\tthis.name = new_name;\n\t\tthis.rank =0;\n\t\tthis.next_diff =0;\n\t\tthis.next = this;\n\t\t}\n\n\tpublic UFTW_Node getRep(){\n\t\tUFTW_Node output;\n\t\tif (this.next.name == this.name)\n\t\t\treturn this;\n\t\telse output = this.next.getRep();\n\t\tthis.next = output; \n\t\treturn output;\n\t}\n\t\n\tpublic int getRepDiff(){\n\t\tif (this.next.name == this.name){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tthis.next_diff += this.next.getRepDiff();\n\t\t\treturn this.next_diff;\n\t\t\t\n\t\t}\n\t}\n}\n\n\tUFTW_Node[] nodes;\n\tpublic static void main(String[] args){\n\t\tArrayList<String> output = new ArrayList<String>();\n\t\tMain test = new Main();\n\t\tScanner inputScanner = new Scanner(System.in).useDelimiter(\"\\\\s\");\n\t\tint n = inputScanner.nextInt();\n\t\tint q = inputScanner.nextInt();\n\t\ttest.nodes = test.makeArray(n);\n\t\t\n\t\tint type = -1;\n\t\tint x= -1;\n\t\tint y= -1;\n\t\tint z=0;\n\t\tfor (int i=0;i<q;i++){\n\t\t\ttype = inputScanner.nextInt();\n\t\t\tx = inputScanner.nextInt();\n\t\t\ty = inputScanner.nextInt();\n\t\t\tif(type ==0){\n\t\t\t\tz =inputScanner.nextInt();\n\t\t\t\ttest.union(x,y,z);\n\t\t\t}\n\t\t\tif(type ==1){\n\t\t\t\tif(test.nodes[x].getRep().name == test.nodes[y].getRep().name){\n\t\t\t\toutput.add(Integer.toString(test.same(x, y)));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput.add(\"?\");\n\t\t\t}\n\t\t} \n\t\tfor(String out : output){\n\t\t\tSystem.out.println(out.toString());\n\t\t}\n\t}\n\tpublic UFTW_Node[] makeArray(int num){\n\t\tUFTW_Node[] output = new UFTW_Node[num];\n\t\tfor (int i=0; i<num;i++){\n\t\t\toutput[i] = new UFTW_Node(i);\n\t\t}\n\treturn output;\n\t}\n\t\n\tpublic void union(int x, int y,int z){\n\t\tint xdiff = nodes[x].getRepDiff();\n\t\tint ydiff = nodes[y].getRepDiff();\n\t\tUFTW_Node yRep = nodes[y].getRep();\n\t\tUFTW_Node xRep = nodes[x].getRep();\n\t\tif (yRep.rank> xRep.rank){\n\t\t\txRep.next= yRep;\n\t\t\txRep.next_diff = z - xdiff +ydiff;\n\t\t}\n\t\telse if(yRep.rank< xRep.rank){\n\t\t\tyRep.next= xRep;\n\t\t\tyRep.next_diff = ydiff -z -xdiff;\n\t\t}\n\t\telse{\n\t\t\tyRep.next= xRep;\n\t\t\txRep.rank++;\n\t\t\tyRep.next_diff = ydiff -z -xdiff;\n\t\t}\n\t}\n\t\n\tpublic int same (int x, int y){\n\t\treturn nodes[x].getRepDiff() -nodes[y].getRepDiff();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tclass DisjointSet {\n\t\t\n\t\tint[] p, r, w;\n\t\t\n\t\tpublic DisjointSet(int size) {\n\t\t\tp = new int[size];\n\t\t\tr = new int[size];\n\t\t\tw = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) makeSet(i);\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tp[x] = x;\n\t\t\tr[x] = w[x] = 0;\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tprivate int findSet(int x) {\n\t\t\tif (x != p[x]) {\n\t\t\t\tint tmp = findSet(p[x]);\n\t\t\t\tw[x] += w[p[x]];\n\t\t\t\tp[x] = tmp;\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n\t\t\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - w[x] + w[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (r[x] > r[y]) {\n\t\t\t\tp[y] = x;\n\t\t\t\tw[y] -= cost;\n\t\t\t} else {\n\t\t\t\tp[x] = y;\n\t\t\t\tw[x] += cost;\n\t\t\t\tif (r[x] == r[y]) {\n\t\t\t\t\tr[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint cur = x;\n\t\t\twhile (cur != p[cur]) {\n\t\t\t\tsum += w[cur];\n\t\t\t\tcur = p[cur];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tpublic void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c = Integer.parseInt(st.nextToken());\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\tint y = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tint z = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else {\n\t\t\t\tif (!ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tclass DisjointSet {\n\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint[] weight;\n\t\t\n\t\tpublic DisjointSet(int size) {\n\t\t\tparent = new int[size];\n\t\t\trank = new int[size];\n\t\t\tweight = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) makeSet(i);\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tparent[x] = x;\n\t\t\trank[x] = 0;\n\t\t\tweight[x] = 0;\n\t\t}\n\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - weight[x] + weight[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\tparent[y] = x;\n\t\t\t\tweight[y] -= cost;\n\t\t\t} else {\n\t\t\t\tparent[x] = y;\n\t\t\t\tweight[x] += cost;\n\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\trank[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tprivate int findSet(int x) {\n\t\t\tif (parent[x] != x) {\n\t\t\t\tint tmp = findSet(parent[x]);\n\t\t\t\tweight[x] += weight[parent[x]];\n\t\t\t\tparent[x] = tmp;\n\t\t\t}\n\t\t\treturn parent[x];\n\t\t}\n\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint cur = x;\n\t\t\twhile (cur != parent[cur]) {\n\t\t\t\tsum += weight[cur];\n\t\t\t\tcur = parent[cur];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c = Integer.parseInt(st.nextToken());\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\tint y = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tint z = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else {\n\t\t\t\tif (!ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class DisjointSet {\n\n\t\tprivate int[] parent;\n\t\tprivate int[] rank;\n\t\tprivate int[] weight;\n\t\t\n\t\tpublic DisjointSet(int size) {\n\t\t\tparent = new int[size];\n\t\t\trank = new int[size];\n\t\t\tweight = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmakeSet(i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tparent[x] = x;\n\t\t\trank[x] = 0;\n\t\t\tweight[x] = 0;\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tprivate int findSet(int x) {\n\t\t\tif (x != parent[x]) {\n\t\t\t\tint tmp = findSet(parent[x]);\n\t\t\t\tweight[x] += weight[parent[x]];\n\t\t\t\tparent[x] = tmp;\n\t\t\t}\n\t\t\treturn parent[x];\n\t\t}\n\t\t\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - weight[x] + weight[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\tparent[y] = x;\n\t\t\t\tweight[y] -= cost;\n\t\t\t} else {\n\t\t\t\tparent[x] = y;\n\t\t\t\tweight[x] += cost;\n\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\trank[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint now = x;\n\t\t\twhile (now != parent[now]) {\n\t\t\t\tsum += weight[now];\n\t\t\t\tnow = parent[now];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c, x, y, z;\n\t\t\tc = Integer.parseInt(st.nextToken());\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tz = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main { //HDL-style Disjoint Set\n\tstatic int N; // int_maxsize > 10000 (constrain)\n\tstatic int Q; // int_maxsize > 110000 (worstcase = 10000initial set  + 100000 new set)\n\tstatic boolean Com; //com only have two kind;\n\tstatic int V1;\n\tstatic int V2;\n\tstatic int V3;\n\tstatic int[] S1;\n\tstatic int[] S2;\n\tstatic Scanner scanner;\n\tpublic static void main(String[] args){\n\t\tscanner = new Scanner(System.in);\n\t\tN = scanner.nextInt();\n\t\tS1 = new int[N];\n\t\tS2 = new int[N];\n\t\treset();\n\t\tQ = scanner.nextInt();\n\t\tFSM();\n\t}\n\t//end of main\n\tprivate static void reset(){\n\t\tCom = false;\n\t\tV1 = 0;\n\t\tV2 = 0;\n\t\tV3 = 0;\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tS1[i]=i;\n\t\t}\n\t}\n\t//end of reset\n\tprivate static void FSM(){\n\t\twhile(Q>0){\n\t\t\tfetch();\n\t\t\tdispatch();\n\t\t\tQ--;\n\t\t}\n\t}\n\t//end of FSM\n\tprivate static void fetch(){\n\t\tCom = (scanner.nextInt() > 0)?true:false;\n\t\t//V1 = scanner.nextInt();\n\t\t//V2 = scanner.nextInt();\n\t}\n\t//end of feteh\n\tprivate static void dispatch(){\n\t\tif(Com){\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tquery();\n\t\t}else {\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tV3 = scanner.nextInt();\n\t\t\trelate();\n\t\t}\n\t}\n\t//end of dispatch\n\tprivate static void relate(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\treturn;\n\t\t}else{\n\t\t\tmerge();\n\t\t}\n\t}\n\t//end of unite\n\tprivate static void query(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\tSystem.out.println(S2[V2] - S2[V1]);\n\t\t}else{\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n\t//end of same\n\tprivate static void merge(){\n\t\tV3 = S2[V2] - V3 - S2[V1];\n\t\tV1 = S1[V1];// use variable 1 to store the set code of V1\n\t\tV2 = S1[V2];// use variable 2 to store the set code of V2\n\t\tfor(int i = 0; i< N;i++)\n\t\t{\n\t\t\tif(S1[i] == V1){\n\t\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t\tS1[i] = V2;\n\t\t\t\tS2[i] = S2[i] + V3;\n\t\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n// disjoin set\npublic class Main {\n    static class UnionFindTree {\n\n        private int parent[];\n        private int rank[];\n        private int weight[];\n\n        public UnionFindTree(int Num_element) {\n            parent = new int[Num_element];\n            rank = new int[Num_element];\n            weight = new int[Num_element];\n            for (int i = 0; i < Num_element; i++)\n                makeSet(i);\n        }\n\n        public void makeSet(int x) {\n            parent[x] = x;\n            rank[x] = 0;\n            weight[x] = 0;\n        }\n\n        public void union(int x, int y, int cost) {\n            link(findSet(x), findSet(y), cost - weight[x] + weight[y]);\n        }\n\n        public int findSet(int x) {\n            if (parent[x] != x) {\n                parent[x] = findSet(parent[x]);\n                int tmp = parent[x];\n                weight[x] += weight[parent[x]];\n                parent[x] = tmp;\n            }\n            return parent[x];\n        }\n        public boolean same(int x,int y){\n            return findSet(x) == findSet(y);\n        }\n\n        public void link(int x, int y, int cost) {\n            if (rank[x] > rank[y]) {\n                parent[y] = x;\n                weight[y] -= cost;\n            } else {\n                parent[x] = y;\n                weight[x] += cost;\n                if (rank[x] == rank[y]) {\n                    rank[y]++;\n                }\n            }\n        }\n\n        public int sum(int x) {\n            int sum = 0;\n            int now = x;\n            while ((now != parent[now])) {\n                sum += weight[now];\n                now = parent[now];\n            }\n            return sum;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // Disjoin set element number\n        int Num_element;\n\n        //Query times\n        int Num_query;\n\n\n        Num_element = sc.nextInt();\n        Num_query = sc.nextInt();\n        UnionFindTree Disjoin_set = new UnionFindTree(Num_element);\n        for (int i = 0; i < Num_query; i++) {\n            // '0' denotes unite and '1' denotes same operation.\n            int com = sc.nextInt();\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            if (com == 0) {\n                int z = sc.nextInt();\n                Disjoin_set.union(x, y, z);\n            } else {\n                if(!Disjoin_set.same(x,y)){\n                    System.out.println(\"?\");\n                }else\n                    System.out.println(Disjoin_set.sum(x) - Disjoin_set.sum(y));\n            }\n        }\n\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint op_num = sc.nextInt();\n\t\t\t\tString[] op = new String[op_num+1];\n\t\t\t\tfor (int i = 0 ; i < op.length; i++) {\n\t\t\t\t\top[i] = sc.nextLine();\n\t\t\t\t}\n\t\t\t\t//get datag\n\t\t\t\tint[][] data = new int[op_num][];\n\t\t\t\tfor (int i = 1, n1 =0; i<= op_num; i++,n1++) {\n\t\t\t\t\tif(op[i].length()== 5) {\n\t\t\t\t\t\tdata[n1] = new int[3];\n\t\t\t\t\t\tdata[n1][0] = Integer.parseInt((String)op[i].substring(0,1));\n\t\t\t\t\t\tdata[n1][1] = Integer.parseInt((String)op[i].substring(2,3));\n\t\t\t\t\t\tdata[n1][2] = Integer.parseInt((String)op[i].substring(4,5));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(op[i].length()== 7){\n\t\t\t\t\t\tdata[n1] = new int[4];\n\t\t\t\t\t\tdata[n1][0] = Integer.parseInt((String)op[i].substring(0,1));\n\t\t\t\t\t\tdata[n1][1] = Integer.parseInt((String)op[i].substring(2,3));\n\t\t\t\t\t\tdata[n1][2] = Integer.parseInt((String)op[i].substring(4,5));\n\t\t\t\t\t\tdata[n1][3] = Integer.parseInt((String)op[i].substring(6,7));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Operate data\n\t\t\t\tSet2 set = new Set2(n);\n\t\t\t\tset.makeset();\n\t\t\t\tfor(int i= 0 ;i < data.length;i++ ) {\n\t\t\t\t\tif(data[i][0] == 0) {\n\t\t\t\t\t\tset.link(data[i][1], data[i][2],data[i][3]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][0] == 1){\n\t\t\t\t\t\tint x = data[i][1];\n\t\t\t\t\t\tint y = data[i][2];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(set.findset(x)== set.findset(y))\n\t\t\t\t\t\t\tSystem.out.println(set.we[y] - set.we[x]);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n}\n\n\nclass Set2{\n\n\tint[] rank,parent;\n\tint n;\n\tint weight;\n\tint[] we;\n\tint index;\n\tprivate static final int INF = Integer.MAX_VALUE;\n\t\n\t\n\tpublic Set2(int n) {\n\t\trank = new int[n];\n\t\tparent = new int[n];\n\t\twe = new int[n];\n\t\tthis.n = n;\n\t\tmakeset();\n\t}\n\t\n\tvoid makeset() {\n\t\tfor(int i= 0 ; i< n; i++)\n\t\t\tparent[i] = i;\n\t}\n\t\n\tint findset(int x) {\n\t\tint y = 0;\n\t\tif (x == parent[x])\n\t\t\treturn x;\n\t\telse {\n\t\t\tint temp = parent[x];\n\t\t\tparent[x] = findset(parent[x]);\n\t\t\twe[x] += we[temp]; \n\t\t\treturn parent[x];\n\t\t}\n\t}\n\t\n\tvoid link(int x, int y, int z) {\n\t\tint a = findset(x);\n\t\tint b = findset(y);\n\t\t//int c = findset(z);\n\t\t\n\t\tif(a!=b) {\n\t\t\tparent[b] = a;\n\t\t\twe[b] = we[x] - we[y] + z;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main { //HDL-style Disjoint Set\n\tstatic int N; // int_maxsize > 10000 (constrain)\n\tstatic int Q; // int_maxsize > 110000 (worstcase = 10000initial set  + 100000 new set)\n\tstatic boolean Com; //com only have two kind;\n\tstatic int V1;\n\tstatic int V2;\n\tstatic int V3;\n\tstatic int[] S1;\n\tstatic int[] S2;\n\tstatic Scanner scanner;\n\tpublic static void main(String[] args){\n\t\tscanner = new Scanner(System.in);\n\t\tN = scanner.nextInt();\n\t\tS1 = new int[N];\n\t\tS2 = new int[N];\n\t\treset();\n\t\tQ = scanner.nextInt();\n\t\tFSM();\n\t}\n\t//end of main\n\tprivate static void reset(){\n\t\tCom = false;\n\t\tV1 = 0;\n\t\tV2 = 0;\n\t\tV3 = 0;\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tS1[i]=i;\n\t\t}\n\t}\n\t//end of reset\n\tprivate static void FSM(){\n\t\twhile(Q>0){\n\t\t\tfetch();\n\t\t\tdispatch();\n\t\t\tQ--;\n\t\t}\n\t}\n\t//end of FSM\n\tprivate static void fetch(){\n\t\tCom = (scanner.nextInt() > 0)?true:false;\n\t\t//V1 = scanner.nextInt();\n\t\t//V2 = scanner.nextInt();\n\t}\n\t//end of feteh\n\tprivate static void dispatch(){\n\t\tif(Com){\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tquery();\n\t\t}else {\n\t\t\tV1 = scanner.nextInt();\n\t\t\tV2 = scanner.nextInt();\n\t\t\tV3 = scanner.nextInt();\n\t\t\trelate();\n\t\t}\n\t}\n\t//end of dispatch\n\tprivate static void relate(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\treturn;\n\t\t}else{\n\t\t\tmerge();\n\t\t}\n\t}\n\t//end of unite\n\tprivate static void query(){\n\t\tif(S1[V1] == S1[V2]){\n\t\t\tSystem.out.println(S2[V2] - S2[V1]);\n\t\t}else{\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n\t//end of same\n\tprivate static void merge(){\n\t\tV3 = S2[V2] - V3 - S2[V1];\n\t\tV1 = S1[V1];// use variable 1 to store the set code of V1\n\t\tV2 = S1[V2];// use variable 2 to store the set code of V2\n\t\tfor(int i = 0; i< N;i++)\n\t\t{\n\t\t\tif(S1[i] == V1){\n\t\t\t\t//System.out.println(\"V1 = \"+ V1 + \"V2 = \" + V2+ \"V3 = \" + V3);\n\t\t\t\tS1[i] = V2;\n\t\t\t\tS2[i] = S2[i] + V3;\n\t\t\t\t//System.out.println(\"S2[i] = \"+ S2[i]);\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tUnionFindTree uft = new UnionFindTree(n);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t    int type = sc.nextInt();\n\t\t    if (type == 0) {\n\t\t        int x = sc.nextInt();\n\t\t        int y = sc.nextInt();\n\t\t        int z = sc.nextInt();\n\t\t        uft.unite(x, y, z);\n\t\t    } else {\n\t\t        int x = sc.nextInt();\n\t\t        int y = sc.nextInt();\n\t\t        sb.append(uft.diff(x, y)).append(\"\\n\");\n\t\t    }\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\t\n\tstatic class UnionFindTree {\n\t    int[] parents;\n\t    int[] weight;\n\t    int[] rank;\n\t    \n\t    public UnionFindTree(int size) {\n\t        parents = new int[size];\n\t        weight = new int[size];\n\t        rank = new int[size];\n\t        for (int i = 0; i < size; i++) {\n\t            parents[i] = i;\n\t        }\n\t    }\n\t    \n\t    public int find(int x) {\n\t        if (parents[x] == x) {\n\t            return x;\n\t        } else {\n\t            int p = find(parents[x]);\n\t            weight[x] += weight[parents[x]];\n\t            return parents[x] = p;\n\t        }\n\t    }\n\t    \n\t    public boolean same(int x, int y) {\n\t        return find(x) == find(y);\n\t    }\n\t    \n\t    public void unite(int x, int y, int w) {\n\t        int xx = find(x);\n\t        int yy = find(y);\n\t        if (xx == yy) {\n\t            return;\n\t        }\n\t        if (rank[xx] < rank[yy]) {\n\t            weight[xx] = - weight[x] + weight[y] + w;\n\t            parents[xx] = yy;\n\t            rank[yy] = Math.max(rank[yy], rank[xx] + 1);\n\t        } else {\n\t            weight[yy] = weight[x] - weight[y] - w;\n\t            parents[yy] = xx;\n\t            rank[xx] = Math.max(rank[xx], rank[yy] + 1);\n\t        }\n\t    }\n\t    \n\t    public String diff(int x, int y) {\n\t        if (same(x, y)) {\n\t            return String.valueOf(weight[x] - weight[y]);\n\t        } else {\n\t            return \"?\";\n\t        }\n\t    }\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main implements Runnable {\n\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        // Run with 32MB stack\n        Thread thread = new Thread(null, new Main(), \"\", 32 * 1024 * 1024);\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        final Scanner scanner = new Scanner(System.in);\n        solve(scanner);\n    }\n\n    static void solve(Scanner scanner) {\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n        scanner.nextLine();\n\n        WeightedUnionFindTree uft = new WeightedUnionFindTree(N);\n        for (int i = 0; i < Q; i++) {\n            int[] q = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            if (q[0] == 0) {\n                uft.merge(q[1], q[2], q[3]);\n            } else {\n                int ans = uft.diff(q[1], q[2]);\n                if (ans == Integer.MAX_VALUE) {\n                    System.out.println('?');\n                } else {\n                    System.out.println(ans);\n                }\n            }\n        }\n    }\n\n}\n\nclass WeightedUnionFindTree {\n    int size;\n    int[] par;\n    int[] rank;\n    int[] weight;\n\n    public WeightedUnionFindTree(int size) {\n        this.size = size;\n        par = new int[size];\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n        }\n        rank = new int[size];\n        Arrays.fill(rank, 1);\n        weight= new int[size];\n    }\n\n    private int root(int x) {\n        if (x == par[x]) {\n            return x;\n        }\n        int root = root(par[x]);\n        // cSum\n        weight[x] += weight[par[x]];\n        par[x] = root;\n        return root;\n    }\n\n    private int calcWeight(int x) {\n        root(x);\n        return weight[x];\n    }\n\n    public int diff(int x, int y) {\n        if (!same(x, y)) {\n            return Integer.MAX_VALUE;\n        }\n        return calcWeight(y) - calcWeight(x);\n    }\n\n    public boolean same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    public void merge(int x, int y) {\n        merge(x, y, 1);\n    }\n\n    // merge as weight(y) = weight(x) + w\n    public void merge(int x, int y, int w) {\n        w += calcWeight(x);\n        w -= calcWeight(y);\n\n        int xr = root(x);\n        int yr = root(y);\n\n        if (xr == yr) {\n            return;\n        }\n\n        if (rank[xr] < rank[yr]) {\n            par[xr] = yr;\n            weight[xr] = -w;\n        } else {\n            par[yr] = xr;\n            weight[yr] = w;\n            if (rank[xr] == rank[yr]) {\n                rank[xr]++;\n            }\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final int INF = Integer.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t\t\t\tint n = 0;\n\t\t\t\tint op_num = 0;\n\t\t\t\tn  = sc.nextInt();\n\t\t\t\top_num = sc.nextInt();\n\t\t\t\tString[] op = new String[op_num+1];\n\t\t\t\tfor (int i = 0 ; i < op.length; i++) {\n\t\t\t\t\top[i] = sc.nextLine();\n\t\t\t\t}\n\t\t\t\t//get datag\n\t\t\t\tint[][] data = new int[op_num][3];\n\t\t\t\tfor (int i = 1, n1 =0; i<= op_num; i++,n1++) {\n\t\t\t\t\tif(data[n1][0] == 0) {\n\t\t\t\t\t\tString[] Split = op[i].split(\" \");\n\t\t\t\t\t\tdata[n1] = new int[Split.length];\n\t\t\t\t\t\tfor(int j = 0;j<Split.length;j++)\n\t\t\t\t\t\t\tdata[n1][j] = Integer.parseInt(Split[j]);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tString[] Split = op[i].split(\" \");\n\t\t\t\t\t\tdata[n1] = new int[Split.length];\n\t\t\t\t\t\tfor(int j = 0;j<Split.length;j++)\n\t\t\t\t\t\t\tdata[n1][j] = Integer.parseInt(Split[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//Operate data\n\t\t\t\tSet2 set = new Set2(n);\n\t\t\t\tset.makeset();\n\t\t\t\t\n\t\t\t\tfor(int i= 0 ;i < data.length;i++ ) {\n\t\t\t\t\tif(data[i][0] == 0) {\n\t\t\t\t\t\tint x = data[i][1];\n\t\t\t\t\t\tint y = data[i][2];\n\t\t\t\t\t\tint z = data[i][3];\n\t\t\t\t\t\tset.link(x, y, z);\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][0] == 1){\n\t\t\t\t\t\tint x = data[i][1];\n\t\t\t\t\t\tint y = data[i][2];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(set.findset(x)== set.findset(y))\n\t\t\t\t\t\t\tSystem.out.println(set.we[y] - set.we[x]);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t}\n}\n\n\nclass Set2{\n\n\tint[] rank,parent;\n\tint n;\n\tint weight;\n\tint[] we;\n\tint index;\n\tprivate static final int INF = Integer.MAX_VALUE;\n\t\n\t\n\tpublic Set2(int n) {\n\t\trank = new int[n];\n\t\tparent = new int[n];\n\t\twe = new int[n];\n\t\tthis.n = n;\n\t\tmakeset();\n\t}\n\t\n\tvoid makeset() {\n\t\tfor(int i= 0 ; i< n; i++)\n\t\t\tparent[i] = i;\n\t}\n\t\n\tint findset(int x) {\n\t\tint y = 0;\n\t\tif (x == parent[x])\n\t\t\treturn x;\n\t\telse {\n\t\t\tint temp = parent[x];\n\t\t\tparent[x] = findset(parent[x]);\n\t\t\twe[x] += we[temp]; \n\t\t\treturn parent[x];\n\t\t}\n\t}\n\t\n\tvoid link(int x, int y, int z) {\n\t\tint a = findset(x);\n\t\tint b = findset(y);\n\t\t//int c = findset(z);\n\t\t\n\t\tif(a!=b) {\n\t\t\tparent[b] = a;\n\t\t\twe[b] = we[x] - we[y] + z;\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        \n        int n, q;\n        int com;\n        int x, y, d;\n        WeightedUnionFind uf;\n\n        n = sc.nextInt();\n        q = sc.nextInt();\n\n        uf = new WeightedUnionFind(n);\n\n        for (int i = 0; i < q; i++) {\n            com = sc.nextInt();\n\n            if (com == 0) {\n                x = sc.nextInt();\n                y = sc.nextInt();\n                d = sc.nextInt();\n\n                uf.unite(x, y, d);\n            }\n            else {\n                x = sc.nextInt();\n                y = sc.nextInt();\n\n                if (uf.isSameGroup(x, y)) {\n                    System.out.println(uf.diff(x, y));\n                }\n                else {\n                    System.out.println(\"?\");\n                }\n            }\n        }\n        \n    }\n}\n\n/**\n * 重み付きUnionFind木.\n * アーベル群まで拡張したいけどパフォが気になるので保留\n * ArrayList\\<Integer\\>がint[]よりだいぶ遅い\n * @see <a href=\"https://atcoder.jp/contests/arc090/submissions/5441773\">検証</a>\n */\nclass WeightedUnionFind {\n    /** 親を示す 自身が根の場合は -(集合の大きさ) を持つ */\n    private int[] parent;\n    \n    /** ノードの重み (親との差分) */\n    private int[] diff_weight;\n\n    public WeightedUnionFind(int nmemb) {\n        parent = new int[nmemb];\n        diff_weight = new int[nmemb];\n\n        Arrays.fill(parent, -1);\n        Arrays.fill(diff_weight, 0);\n    }\n\n    /** 根を求める */\n    private int root(int x) {\n        if (parent[x] < 0) {\n            return x;\n        }\n\n        // 累積和的に重みを再計算\n        int r = root(parent[x]);\n        diff_weight[x] += diff_weight[parent[x]];\n        parent[x] = r;\n\n        return parent[x];\n    }\n\n    private int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n\n    public int diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    \n    public boolean isSameGroup(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    /**\n     * x->yの重みをwとして併合.\n     * 即ち, weight(y) = weight(x) + w が成り立つ\n     * x, yが既に同じグループのときは何もしない\n     */\n    public void unite(int x, int y, int w) {\n        if (isSameGroup(x, y)) {\n            return;\n        }\n\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n    \n        parent[y] = x;\n        diff_weight[y] = w;\n    }\n\n    public int groubSize(int x) {\n        return -parent[root(x)];\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n    \tPrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n    \tWeightedUnionFind uf = new WeightedUnionFind(n);\n        \n        for(int i=0;i<q;i++){\n        \tint t = sc.nextInt();\n        \tint x = sc.nextInt();\n        \tint y = sc.nextInt();\n        \t\n        \tif(t==0){\n        \t\tlong w = sc.nextLong();\n        \t\tuf.unite(x, y, new AbelWeight(w));\n        \t}\n        \telse{\n        \t\tif(!uf.isSame(x, y)){\n        \t\t\tout.println(\"?\");\n        \t\t}\n        \t\telse{\n        \t\t\tout.println(uf.diff(y,x).value);\n        \t\t}\n        \t}\n        }\n\n        out.flush();\n    }\n    \n}\n\nclass WeightedUnionFind {\n\tint[] par;\n\tint[] rank;\n\tAbelWeight[] diff;\t//親ノードとのweightの差\n\t\n\tstatic AbelWeight ide = AbelWeight.ide();\n\t\n\tpublic WeightedUnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tdiff = new AbelWeight[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdiff[i] = ide;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t\n\t//木の根を求める\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}\n\t\telse{\n\t\t\tint root = find(par[x]);\n\t\t\tdiff[x] = diff[x].ope(diff[par[x]]); //重みの累積和\n\t\t\treturn par[x] = root;\t//経路圧縮\t\n\t\t}\n\t}\n\t\n\t//親とのweightの差を求めつつ経路圧縮\n\tAbelWeight weight(int x){\n\t\tfind(x);\n\t\treturn diff[x];\n\t}\n\t\n\t//y-x\n\tAbelWeight diff(int y, int x){\n\t\treturn weight(y).ope(weight(x).inv());\n\t}\n\t\n\t//big = small + w\n\tpublic void unite(int small, int big, AbelWeight w){\n\t\tw = w.ope(weight(small));\n\t\tw = w.ope(weight(big).inv());\n\t\t\n\t\tint px = find(small);\n\t\tint py = find(big);\n\t\t\n\t\tif(px == py){\n\t\t\treturn;\n\t\t}\n\t\telse if(rank[px] < rank[py]){\n\t\t\tpar[px] = py;\n\t\t\tdiff[px] = w.inv();\t//pyがpxの親になる\n\n\t\t}\n\t\telse{\n\t\t\tpar[py] = px;\n\t\t\tif(rank[px]==rank[py]){\n\t\t\t\trank[px]++;\n\t\t\t}\n\t\t\tdiff[py] = w;\t//pxがpyの親になる\t\n\t\t}\n\t\t\n\t}\n\t\n\t//xとyが同じ集合に属するか\n\tpublic boolean isSame(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n}\n\n//アーベル群\nclass AbelWeight{\n\tlong value;\n\t\n\tpublic AbelWeight(long value){\n\t\tthis.value = value;\n\t}\n\t\n\t//単位元\n\tstatic AbelWeight ide(){\n\t\treturn new AbelWeight(0);\n\t}\n\t\n\t//逆元\n\tAbelWeight inv(){\n\t\treturn new AbelWeight(-value);\n\t}\n\t\n\t//演算\n\tAbelWeight ope(AbelWeight y){\n\t\treturn new AbelWeight(this.value + y.value);\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\nclass Main {\n\tstatic int[] parents;\n\tstatic int[] weight;\n\tstatic int[] rank;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\n\t\tparents = new int[n];\n\t\tweight = new int[n];\n\t\trank = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparents[i] = i;\n\t\t}\n\n\t\tint type, x, y, z;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ttype = scanner.nextInt();\n\t\t\tx = scanner.nextInt();\n\t\t\ty = scanner.nextInt();\n\n\t\t\tif(type == 0) {\n\t\t\t\tz = scanner.nextInt();\n\t\t\t\trelate(x, y, z);\n\t\t\t} else {\n\t\t\t\tdiff(x, y);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int find(int x) {\n\t\tif (x == parents[x]) \n\t\t\treturn x;\n\t\telse {\n\t\t\tint r = find(parents[x]);\n\t\t\tweight[x] += weight[parents[x]];\n\t\t\treturn parents[x] = r;\n\t\t}\n\t}\n\n\tstatic int weight(int x) {\n\t\tfind(x);\n\t\treturn weight[x];\n\t}\n\n\tstatic void relate(int x, int y, int z) {\n\t\tz += weight(x);\n\t\tz -= weight(y);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t\tz = -z;\n\t\t}\n\n\t\tif(rank[x] == rank[y]){\n\t\t\trank[x]++;\n\t\t}\n\n\t\tparents[y] = x;\n\t\tweight[y] = z;\n\t}\n\n\tstatic void diff(int x, int y) {\n\t\tif(find(x) == find(y)) {\n\t\t\tSystem.out.println(weight(y) - weight(x));\n\t\t} else {\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tstatic boolean DEBUG;\n\tpublic static void main(String[] args) {\n\t\tDEBUG = args.length > 0 && args[0].equals(\"-DEBUG\");\n\t\tSolver solver = new Solver();\n\t\tsolver.solve();\n\t\tsolver.exit();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t}else{\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Solver {\n\t\tFastScanner sc = new FastScanner();\n\t\tpublic Solver() { }\n\n\t\tString ns() { return sc.next(); }\n\t\tString[] ns(int n) {\n\t\t\tString a[] = new String[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(); }\n\t\t\treturn a;\n\t\t}\n\t\tString[][] ns(int n, int m) {\n\t\t\tString a[][] = new String[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(m); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[] nc(int n) {\n\t\t\tString str = ns();\n\t\t\tchar a[] = new char[str.length()];\n\t\t\tfor(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[][] nc(int n, int m) {\n\t\t\tchar a[][] = new char[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nc(m); }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[] nb(int n, char t) {\n\t\t\tboolean a[] = new boolean[n];\n\t\t\tchar c[] = nc(n);\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = c[i] == t; }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[][] nb(int n, int m, char t) {\n\t\t\tboolean a[][] = new boolean[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nb(m, t); }\n\t\t\treturn a;\n\t\t}\n\t\tint ni() { return (int)sc.nextLong(); }\n\t\tint[] ni(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(); }\n\t\t\treturn a;\n\t\t}\n\t\tint[][] ni(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(m); }\n\t\t\treturn a;\n\t\t}\n\t\tlong nl() { return sc.nextLong(); }\n\t\tlong[] nl(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(); }\n\t\t\treturn a;\n\t\t}\n\t\tlong[][] nl(int n, int m) {\n\t\t\tlong a[][] = new long[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(m); }\n\t\t\treturn a;\n\t\t}\n\t\tdouble nd() { return Double.parseDouble(sc.next()); }\n\t\tdouble[] nd(int n) {\n\t\t\tdouble a[] = new double[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nd(); }\n\t\t\treturn a;\n\t\t}\n\t\tdouble[][] nd(int n, int m) {\n\t\t\tdouble a[][] = new double[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nd(m); }\n\t\t\treturn a;\n\t\t}\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tPrintWriter err = new PrintWriter(System.err);\n\t\tvoid prt() { out.print(\"\"); }\n\t\t<T> void prt(T a) { out.print(a); }\n\t\tvoid prtln() { out.println(\"\"); }\n\t\t<T> void prtln(T a) { out.println(a); }\n\t\tvoid prtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(int[][] a) { for(int[] element : a){ prtln(element); } }\n\t\tvoid prtln(long[][] a) { for(long[] element : a){ prtln(element); } }\n\t\tvoid prtln(double[][] a) { for(double[] element : a){ prtln(element); } }\n\t\tvoid prtln(String[][] a) { for(String[] element : a){ prtln(element); } }\n\t\tvoid prtln(char[][] a) { for(char[] element : a){ prtln(element); } }\n\t\tString errconvert(int a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tString errconvert(long a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tvoid errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }\n\t\tvoid errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }\n\t\tvoid errprt() { if(DEBUG) { err.print(\"\"); } }\n\t\t<T> void errprt(T a) { if(DEBUG) { err.print(a); } }\n\t\tvoid errprt(boolean a) { if(DEBUG) { errprt(a ? \"#\" : \".\"); } }\n\t\tvoid errprtln() { if(DEBUG) { err.println(\"\"); } }\n\t\tvoid errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }\n\t\tvoid errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }\n\t\t<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }\n\t\tvoid errprtln(boolean a) { if(DEBUG) { errprtln(a ? \"#\" : \".\"); } }\n\t\tvoid errprtln(int... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int element : a){ sb.append(errconvert(element)+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(long... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(long element : a){ sb.append(errconvert(element)+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(double... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(String... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(char... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(boolean... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(boolean element : a){ sb.append((element ? \"#\" : \".\")+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }\n\n\t\tvoid reply(boolean b) { prtln(b ? \"Yes\" : \"No\"); }\n\t\tvoid REPLY(boolean b) { prtln(b ? \"YES\" : \"NO\"); }\n\n\t\tvoid flush() { out.flush(); if(DEBUG) { err.flush(); } }\n\t\tvoid exit() { flush(); System.exit(0); }\n\n\t\tint min(int a, int b) { return Math.min(a, b); }\n\t\tlong min(long a, long b) { return Math.min(a, b); }\n\t\tdouble min(double a, double b) { return Math.min(a, b); }\n\t\tint min(int... x) {\n\t\t\tint min = x[0];\n\t\t\tfor(int val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tlong min(long... x) {\n\t\t\tlong min = x[0];\n\t\t\tfor(long val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tdouble min(double... x) {\n\t\t\tdouble min = x[0];\n\t\t\tfor(double val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tint max(int a, int b) { return Math.max(a, b); }\n\t\tlong max(long a, long b) { return Math.max(a, b); }\n\t\tdouble max(double a, double b) { return Math.max(a, b); }\n\t\tint max(int... x) {\n\t\t\tint max = x[0];\n\t\t\tfor(int val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long... x) {\n\t\t\tlong max = x[0];\n\t\t\tfor(long val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double... x) {\n\t\t\tdouble max = x[0];\n\t\t\tfor(double val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong sum(int... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(int element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(long... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(long element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble sum(double... a) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(double element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(int[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(long[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble[] sums(double[] a) {\n\t\t\tdouble sum[] = new double[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\n\t\tlong abs(double x) { return (long)Math.abs(x); }\n\t\tlong round(double x) { return Math.round(x); }\n\t\tlong floor(double x) { return (long)Math.floor(x); }\n\t\tlong ceil(double x) { return (long)Math.ceil(x); }\n\t\tdouble sqrt(double x) { return Math.sqrt(x); }\n\t\tdouble pow(double x, double y) { return Math.pow(x, y); }\n\t\tlong pow(long x, long y) { return (long)Math.pow(x, y); }\n\t\tint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong lcm(long a, long b) { return a * b / gcd(a, b); }\n\n\t\tint upperToInt(char a) { return a - 'A'; }\n\t\tint lowerToInt(char a) { return a - 'a'; }\n\t\tint numToInt(char a) { return a - '0'; }\n\t\tint charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }\n\t\tchar intToUpper(int a) { return (char)(a + 'A'); }\n\t\tchar intToLower(int a) { return (char)(a + 'a'); }\n\t\tchar intToNum(int a) { return (char)(a + '0'); }\n\n\t\tlong[] div(long a) {\n\t\t\tList<Long> divList = new ArrayList<Long>();\n\t\t\tfor(long i = 1; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tdivList.add(i);\n\t\t\t\t\tif(i * i != a) { divList.add(a / i); };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong div[] = new long[divList.size()];\n\t\t\tfor(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }\n\t\t\treturn div;\n\t\t}\n\n\t\tlong[][] factor(long a) {\n\t\t\tList<Long> factorList = new ArrayList<Long>();\n\t\t\tList<Long> degreeList = new ArrayList<Long>();\n\t\t\tfor(long i = 2; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tlong count = 0;\n\t\t\t\t\twhile(a % i == 0) {\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tfactorList.add(i);\n\t\t\t\t\tdegreeList.add(count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a > 1) {\n\t\t\t\tfactorList.add(a);\n\t\t\t\tdegreeList.add(1L);\n\t\t\t}\n\t\t\tlong factor[][] = new long[factorList.size()][2];\n\t\t\tfor(int i = 0; i < factorList.size(); i ++) {\n\t\t\t\tfactor[i][0] = factorList.get(i);\n\t\t\t\tfactor[i][1] = degreeList.get(i);\n\t\t\t}\n\t\t\treturn factor;\n\t\t}\n\n\t\tlong[][] countElements(long[] a, boolean sort) {\n\t\t\tint len = a.length;\n\t\t\tlong array[] = new long[len];\n\t\t\tfor(int i = 0; i < len; i ++) {\n\t\t\t\tarray[i] = a[i];\n\t\t\t}\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add(array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\t\tlong[][] countElements(String str, boolean sort) {\n\t\t\tint len = str.length();\n\t\t\tchar array[] = str.toCharArray();\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add((long)array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\n\t\tint numDigits(long a) { return Long.toString(a).length(); }\n\t\tlong bitFlag(int a) { return 1L << (long)a; }\n\t\tboolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }\n\n\t\tlong countString(String str, String a) { return (str.length() - str.replace(a, \"\").length()) / a.length(); }\n\t\tlong countStringAll(String str, String a) { return str.length() - str.replaceAll(a, \"\").length(); }\n\n\t\tvoid reverse(String array[]) {\n\t\t\tString reversed[] = new String[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(int array[]) {\n\t\t\tint reversed[] = new int[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(long array[]) {\n\t\t\tlong reversed[] = new long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(double array[]) {\n\t\t\tdouble reversed[] = new double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(boolean array[]) {\n\t\t\tboolean reversed[] = new boolean[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid fill(int array[], int x) { Arrays.fill(array, x); }\n\t\tvoid fill(long array[], long x) { Arrays.fill(array, x); }\n\t\tvoid fill(double array[], double x) { Arrays.fill(array, x); }\n\t\tvoid fill(boolean array[], boolean x) { Arrays.fill(array, x); }\n\t\tvoid fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }\n\t\tvoid fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }\n\t\tvoid fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }\n\t\tvoid fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }\n\t\tvoid fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }\n\t\tvoid fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }\n\t\tvoid fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }\n\t\tvoid fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }\n\n\t\tlong INF = (long)1e18 + 7;\n\t\tboolean isINF(long a) { return abs(a) > INF / 1000; }\n\t\tboolean isPlusINF(long a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(long a) { return isPlusINF(- a); }\n\t\tint I_INF = (int)1e9 + 7;\n\t\tboolean isINF(int a) { return abs(a) > I_INF / 1000; }\n\t\tboolean isPlusINF(int a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(int a) { return isPlusINF(- a); }\n\n\n\t\t// mods\n\t\tlong MOD = (long)1e9 + 7; // 998244353;\n\t\tpublic long mod(long i) { i %= MOD; return i + (i < 0 ? MOD : 0); }\n\n\t\tlong pow_m(long x, long y) {\n\t\t\tif (y == 0) { return 1;\n\t\t\t}else {\n\t\t\t\tlong tmp = pow_m(x, y / 2);\n\t\t\t\treturn mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));\n\t\t\t}\n\t\t}\n\t\tlong[] pows_m(long x, int max) {\n\t\t\tlong pow[] = new long[max + 1];\n\t\t\tpow[0] = 1;\n\t\t\tfor(int i = 0; i < max; i ++) {\n\t\t\t\tpow[i + 1] = mod(pow[i] * x);\n\t\t\t}\n\t\t\treturn pow;\n\t\t}\n\n\t\tint MAX_INV_SIZE = 100_100;\n\t\tHashMap<Long, Long> invMap = new HashMap<>();\n\t\tlong inv(long x) {\n\t\t\tx = mod(x);\n\t\t\tif(invMap.containsKey(x)) { return invMap.get(x); }\n\t\t\tif(invMap.size() >= MAX_INV_SIZE) { return calInv(x); }\n\t\t\tinvMap.put(x, calInv(x));\n\t\t\treturn invMap.get(x);\n\t\t}\n\t\tlong calInv(long x) { return pow_m(x, MOD - 2); }\n\n\t\tint MAX_FACT = 5_000_100;\n\t\tlong fact[];\n\t\tlong invFact[];\n\t\tboolean isFactPrepared = false;\n\t\tHashMap<Integer, long[]> factMap;\n\t\tvoid prepareFact() {\n\t\t\tfact = new long[MAX_FACT];\n\t\t\tArrays.fill(fact, 0);\n\t\t\tinvFact = new long[MAX_FACT];\n\t\t\tArrays.fill(invFact, 0);\n\t\t\tfact[0] = 1;\n\t\t\tint maxIndex = min(MAX_FACT, (int)MOD);\n\t\t\tfor(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }\n\t\t\tinvFact[maxIndex - 1] = inv(fact[maxIndex - 1]);\n\t\t\tfor(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }\n\n\t\t\tfactMap = new HashMap<>();\n\t\t\tisFactPrepared = true;\n\t\t}\n\n\t\tlong P(int n, int r) {\n\t\t\tif(!isFactPrepared) { prepareFact(); }\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\tif(n >= MAX_FACT) {\n\t\t\t\tif(!factMap.containsKey(n)) {\n\t\t\t\t\tlong largeFact[] = new long[MAX_FACT];\n\t\t\t\t\tfactMap.put(n, largeFact);\n\t\t\t\t\tfill(largeFact, -INF);\n\t\t\t\t\tlargeFact[0] = 1;\n\t\t\t\t}\n\t\t\t\tlong largeFact[] = factMap.get(n);\n\t\t\t\tint i = r;\n\t\t\t\twhile(isINF(largeFact[i])) { i --; }\n\t\t\t\tfor(; i < r; i ++) { largeFact[i + 1] = mod(largeFact[i] * (n - i)); }\n\t\t\t\treturn largeFact[r];\n\t\t\t}\n\t\t\treturn mod(fact[n] * invFact[n - r]);\n\t\t}\n\t\tlong C(int n, int r) {\n\t\t\tif(!isFactPrepared) { prepareFact(); }\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\treturn mod(P(n, r) * invFact[r]);\n\t\t}\n\t\tlong H(int n, int r) { return C((n - 1) + r, r); }\n\n\n\t\t// grid\n\t\tclass Grid implements Comparable<Grid> {\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint h;\n\t\t\tint w;\n\t\t\tint i;\n\t\t\tboolean b;\n\t\t\tlong val;\n\n\t\t\tGrid() {  }\n\t\t\tGrid(int x, int y, int h, int w) { init(x, y, h, w, false, 0); }\n\t\t\tGrid(int x, int y, int h, int w, boolean b) { init(x, y, h, w, b, 0); }\n\t\t\tGrid(int x, int y, int h, int w, long val) { init(x, y, h, w, false, val); }\n\t\t\tGrid(int x, int y, int h, int w, boolean b, long val) { init(x, y, h, w, b, val); }\n\n\t\t\tvoid init(int x, int y, int h, int w, boolean b, long val) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.b = b;\n\t\t\t\tthis.val = val;\n\t\t\t\ti = x * w + y;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Grid g) {\n\t\t\t\treturn Long.compare(this.val, g.val);\n\t\t\t}\n\t\t}\n\n\t\tint dx[] = {-1, 1, 0, 0};\n\t\tint dy[] = {0, 0, -1, 1};\n\t\t// int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t// int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\tboolean isValid(int x, int y, int h, int w) {\n\t\t\treturn x >= 0 && x < h && y >= 0 && y < w;\n\t\t}\n\t\tboolean isValid(Grid g) {\n\t\t\treturn isValid(g.x, g.y, g.h, g.w);\n\t\t}\n\t\tGrid next(Grid g, int i) {\n\t\t\treturn new Grid(g.x + dx[i], g.y + dy[i], g.h, g.w);\n\t\t}\n\n\n\t\t// graph\n\t\tclass Graph {\n\t\t\tint numNode;\n\t\t\tint numEdge;\n\t\t\tboolean directed;\n\t\t\tEdge edges[];\n\t\t\tNode nodes[];\n\t\t\tNode reversedNodes[];\n\n\t\t\tGraph(int numNode, int numEdge, Edge edges[], boolean directed) {\n\t\t\t\tthis.numNode = numNode;\n\t\t\t\tthis.numEdge = numEdge;\n\t\t\t\tthis.directed = directed;\n\t\t\t\tthis.edges = edges;\n\t\t\t\tnodes = new Node[numNode];\n\t\t\t\treversedNodes = new Node[numNode];\n\t\t\t\tfor(int i = 0; i < numNode; i ++) {\n\t\t\t\t\tnodes[i] = new Node(i);\n\t\t\t\t\treversedNodes[i] = new Node(i);\n\t\t\t\t}\n\n\t\t\t\tfor(Edge edge : edges) {\n\t\t\t\t\tnodes[edge.source].add(edge.target, edge.cost);\n\t\t\t\t\tif(directed) {\n\t\t\t\t\t\treversedNodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid clearNodes() {\n\t\t\t\tfor(Node n : nodes) { n.clear(); }\n\t\t\t\tfor(Node n : reversedNodes) { n.clear(); }\n\t\t\t}\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tArrayList<Edge> edges = new ArrayList<Edge>();\n\n\t\t\tNode(int id) {\n\t\t\t\tthis.id = id;\n\t\t\t}\n\t\t\tvoid add(int target, long cost) {\n\t\t\t\tedges.add(new Edge(id, target, cost));\n\t\t\t}\n\t\t\tvoid clear() {\n\t\t\t\tedges.clear();\n\t\t\t}\n\t\t}\n\n\t\tclass Edge implements Comparable<Edge> {\n\t\t\tint source;\n\t\t\tint target;\n\t\t\tlong cost;\n\t\t\tEdge(int source, int target, long cost) {\n\t\t\t\tthis.source = source;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Edge e) {\n\t\t\t\treturn Long.compare(this.cost, e.cost);\n\t\t\t}\n\t\t}\n\npublic void solve() {\n\tint num = ni();\n\tint q = ni();\n\tUnionFind uf = new UnionFind(num);\n\tfor(int query = 0; query < q; query ++) {\n\t\tint a = ni();\n\t\tif(a == 0) {\n\t\t\tint x = ni();\n\t\t\tint y = ni();\n\t\t\tlong w = nl();\n\t\t\tuf.unite(x, y, w);\n\t\t}else {\n\t\t\tint x = ni();\n\t\t\tint y = ni();\n\t\t\tlong w = uf.diff(x, y);\n\t\t\tif(isINF(w)) {\n\t\t\t\tprtln(\"?\");\n\t\t\t}else {\n\t\t\t\tprtln(w);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tint parent[];\n\tint size[];\n\tlong weight[];\n\n\tUnionFind(int num) {\n\t\tparent = new int[num];\n\t\tsize = new int[num];\n\t\tweight = new long[num];\n\t\tfor(int i = 0; i < num; i ++) {\n\t\t\tinitNode(i);\n\t\t}\n\t}\n\n\tvoid initNode(int i) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t\tweight[i] = 0;\n\t}\n\n\tboolean unite(int x, int y, long w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tint xRoot = root(x);\n\t\tint yRoot = root(y);\n\t\tif(xRoot == yRoot) { return diff(x, y) == w; }\n\t\tif(size[yRoot] > size[xRoot]) {\n\t\t\tparent[xRoot] = yRoot;\n\t\t\tweight[xRoot] = - w;\n\t\t\tsize[yRoot] += size[xRoot];\n\t\t}else {\n\t\t\tparent[yRoot] = xRoot;\n\t\t\tweight[yRoot] = w;\n\t\t\tsize[xRoot] += size[yRoot];\n\t\t}\n\t\treturn true;\n\t}\n\n\tint size(int i) {\n\t\treturn size[root(i)];\n\t}\n\n\tint root(int i) {\n\t\tif(i != parent[i]) {\n\t\t\tint root = root(parent[i]);\n\t\t\tweight[i] += weight[parent[i]];\n\t\t\tparent[i] = root;\n\t\t}\n\t\treturn parent[i];\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tlong weight(int i) {\n\t\troot(i);\n\t\treturn weight[i];\n\t}\n\n\tlong diff(int x, int y) {\n\t\treturn same(x, y) ? weight(y) - weight(x) : INF;\n\t}\n}\n\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  static final int MAX = 10000;\n  static int[] rank = new int[MAX];\n  static int[] par = new int[MAX];\n  static int[] weight = new int[MAX];\n  static ArrayList<Integer> ansArr = new ArrayList<Integer>();\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int q = sc.nextInt();\n\n    for(int i = 0 ; i < n ; i++) {\n      rank[i] = 0;\n      weight[i] = 0;\n      par[i] = i;\n    }\n\n    int com, x, y, z;\n    for(int i = 0 ; i < q ; i++) {\n      com = sc.nextInt();\n      if(com == 0) {\n        x = sc.nextInt();\n        y = sc.nextInt();\n        z = sc.nextInt();\n        realte(x, y, z);\n      } else {\n        //System.out.println(\"diff : \");\n        x = sc.nextInt();\n        y = sc.nextInt();\n        diff(x, y);\n      }\n    }\n\n    // 答え出力\n    for(Integer ans: ansArr) {\n      if(ans < 0) {\n        System.out.println(\"?\");\n      } else System.out.println(ans);\n    }\n  }\n\n  static int find(int x) {\n    if(x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  static int weight(int x) {\n    find(x);\n    return weight[x];\n  }\n\n  static void realte(int x, int y, int z) {\n    z += weight(x);\n    z -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      int swap = x;\n      x = y;\n      y = swap;\n      z = -z;\n    }\n    if(rank[x] == rank[y]) {\n      ++rank[x];\n    }\n    par[y] = x;\n    weight[y] = z;\n  }\n\n  static void diff(int x, int y) {\n    ansArr.add(weight(y) - weight(x));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static int[] par; // 親の番号\n    static int[] ws;  // 親との重みの差\n    \n    public static void WeightedUnionFind(int n){\n        par = new int[n];\n        ws  = new int[n];\n        for(int i = 0; i < n; i++){ par[i] = -1; }\n    }\n    \n    public static int find(int x){\n        if(par[x] < 0){\n            return x;\n        }else{\n            final int parent = find(par[x]);\n            ws[x] += ws[par[x]];\n            return par[x] = parent;\n        }\n    }\n    \n    public static int weight(int x){\n        find(x); \n        return ws[x];\n    }\n    \n    public static boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)\n        w += weight(x); \n        w -= weight(y);\n        x = find(x); y = find(y);\n        \n        if(x != y){\n            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.\n                int tmp = x; x = y; y = tmp; w = -w;\n            }\n            par[x] += par[y]; par[y] = x;\n            ws[y] = w;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    \n    public static boolean same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n    public static Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.\n        if(!same(x, y)){ return null; }\n        return weight(x) - weight(y);\n    }\n    // size()はUnionFindと同じなので省略.\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        WeightedUnionFind(n);\n        for (int i=0;i<q;i++) {\n            int flag = sc.nextInt();\n            if (flag==0) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int z = sc.nextInt();\n                union(x, y, z);\n            } else {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                Integer ans = diff(y, x);\n                if (ans==null) {\n                    System.out.println(\"?\");\n                } else {\n                    System.out.println(ans);\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n// disjoin set\npublic class Main {\n    static class UnionFindTree {\n\n        private int parent[];\n        private int rank[];\n        private int weight[];\n\n        public UnionFindTree(int Num_element) {\n            parent = new int[Num_element];\n            rank = new int[Num_element];\n            weight = new int[Num_element];\n            for (int i = 0; i < Num_element; i++)\n                makeSet(i);\n        }\n\n        public void makeSet(int x) {\n            parent[x] = x;\n            rank[x] = 0;\n            weight[x] = 0;\n        }\n\n        public void union(int x, int y, int cost) {\n            link(findSet(x), findSet(y), cost - weight[x] + weight[y]);\n        }\n\n        public int findSet(int x) {\n            if (parent[x] != x) {\n                parent[x] = findSet(parent[x]);\n                int tmp = parent[x];\n                weight[x] += weight[parent[x]];\n                parent[x] = tmp;\n            }\n            return parent[x];\n        }\n        public boolean same(int x,int y){\n            return findSet(x) == findSet(y);\n        }\n\n        public void link(int x, int y, int cost) {\n            if (rank[x] > rank[y]) {\n                parent[y] = x;\n                weight[y] -= cost;\n            } else {\n                parent[x] = y;\n                weight[x] += cost;\n                if (rank[x] == rank[y]) {\n                    rank[y]++;\n                }\n            }\n        }\n\n        public int sum(int x) {\n            int sum = 0;\n            int now = x;\n            while ((now != parent[now])) {\n                sum += weight[now];\n                now = parent[now];\n            }\n            return sum;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // Disjoin set element number\n        int Num_element;\n\n        //Query times\n        int Num_query;\n\n\n        Num_element = sc.nextInt();\n        Num_query = sc.nextInt();\n        UnionFindTree Disjoin_set = new UnionFindTree(Num_element);\n        for (int i = 0; i < Num_query; i++) {\n            // '0' denotes unite and '1' denotes same operation.\n            int com = sc.nextInt();\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            if (com == 0) {\n                int z = sc.nextInt();\n                Disjoin_set.union(x, y, z);\n            } else {\n                if(!Disjoin_set.same(x,y)){\n                    System.out.printf(\"?\");\n                }else\n                    System.out.println(Disjoin_set.sum(x) - Disjoin_set.sum(y));\n            }\n        }\n\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\nclass Main {\n\tstatic int[] parents;\n\tstatic int[] weight;\n\tstatic int[] rank;\n\t\n\tstatic int find(int x) {\n\t\tif (x == parents[x]) \n\t\t\treturn x;\n\t\telse {\n\t\t\tint r = find(parents[x]);\n\t\t\tweight[x] += weight[parents[x]];\n\t\t\treturn parents[x] = r;\n\t\t}\n\t}\n\n\tstatic int weight(int x) {\n\t\tfind(x);\n\t\treturn weight[x];\n\t}\n\n\tstatic void relate(int x, int y, int z) {\n\t\tz += weight(x);\n\t\tz -= weight(y);\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t\tz = -z;\n\t\t}\n\n\t\tif(rank[x] == rank[y]){\n\t\t\trank[x]++;\n\t\t}\n\n\t\tparents[y] = x;\n\t\tweight[y] = z;\n\t}\n\n\tstatic void diff(int x, int y) {\n\t\tif(find(x) == find(y)) {\n\t\t\tSystem.out.println(weight(y) - weight(x));\n\t\t} else {\n\t\t\tSystem.out.println(\"?\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint q = scanner.nextInt();\n\n\t\tparents = new int[n];\n\t\tweight = new int[n];\n\t\trank = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparents[i] = i;\n\t\t}\n\n\t\tint type, x, y, z;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ttype = scanner.nextInt();\n\t\t\tx = scanner.nextInt();\n\t\t\ty = scanner.nextInt();\n\n\t\t\tif(type == 0) {\n\t\t\t\tz = scanner.nextInt();\n\t\t\t\trelate(x, y, z);\n\t\t\t} else {\n\t\t\t\tdiff(x, y);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tclass DisjointSet {\n\t\t\n\t\tint[] p, r, w;\n\t\t\n\t\tpublic DisjointSet(int size) {\n\t\t\tp = new int[size];\n\t\t\tr = new int[size];\n\t\t\tw = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) makeSet(i);\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tp[x] = x;\n\t\t\tr[x] = w[x] = 0;\n\t\t}\n\t\t\n\t\tprivate int findSet(int x) {\n\t\t\tif (p[x] != x) {\n\t\t\t\tint tmp = findSet(p[x]);\n\t\t\t\tw[x] += w[p[x]];\n\t\t\t\tp[x] = tmp;\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - w[x] + w[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (r[x] > r[y]) {\n\t\t\t\tp[y] = x;\n\t\t\t\tw[y] -= cost;\n\t\t\t} else {\n\t\t\t\tp[x] = y;\n\t\t\t\tw[x] += cost;\n\t\t\t\tif (r[x] == r[y]) {\n\t\t\t\t\tr[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint cur = x;\n\t\t\twhile (cur != p[cur]) {\n\t\t\t\tsum += w[cur];\n\t\t\t\tcur = p[cur];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c = Integer.parseInt(st.nextToken());\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\tint y = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tint z = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else {\n\t\t\t\tif (ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  static int[] rank;\n  static int[] par;\n  static int[] weight;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int q = sc.nextInt();\n\n    rank = new int[n];\n    par = new int[n];\n    weight = new int[n];\n\n    for(int i = 0 ; i < n ; i++) {\n      par[i] = i;\n    }\n\n    int com, x, y, z;\n    for(int i = 0 ; i < q ; i++) {\n      com = sc.nextInt();\n      x = sc.nextInt();\n      y = sc.nextInt();\n      if(com == 0) {\n        z = sc.nextInt();\n        realte(x, y, z);\n      } else same(x,y);\n    }\n  }\n\n  static int find(int x) {\n    if(x == par[x]) return x;\n    else {\n      int r = find(par[x]);\n      weight[x] += weight[par[x]];\n      return par[x] = r;\n    }\n  }\n\n  static int weight(int x) {\n    find(x);\n    return weight[x];\n  }\n\n  static void realte(int x, int y, int z) {\n    z += weight(x);\n    z -= weight(y);\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      int swap = x;\n      x = y;\n      y = swap;\n      z = -z;\n    }\n    if(rank[x] == rank[y]) {\n      ++rank[x];\n    }\n    par[y] = x;\n    weight[y] = z;\n  }\n\n  static void diff(int x, int y) {\n    System.out.println(weight(y) - weight(x));\n  }\n\n  static void same(int x, int y) {\n    if(find(x) == find(y)) {\n      diff(x,y);\n    } else {\n      System.out.println(\"?\");\n    }\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main { //HDL-style Disjoint Set\n\tstatic int N; // int_maxsize > 10000 (constrain)\n\tstatic int Q; // int_maxsize > 110000 (worstcase = 10000initial set  + 100000 new set)\n\tstatic boolean Com; //com only have two kind;\n\tstatic int V1;\n\tstatic int V2;\n\tstatic int[] S;\n\tstatic Scanner scanner;\n\tpublic static void main(String[] args){\n\t\tscanner = new Scanner(System.in);\n\t\tN = scanner.nextInt();\n\t\tN = 100000;\n\t\tS = new int[N];\n\t\treset();\n\t\tQ = scanner.nextInt();\n\t\tFSM();\n\t}\n\t//end of main\n\tprivate static void reset(){\n\t\tCom = false;\n\t\tV1 = 0;\n\t\tV2 = 0;\n\t\tfor(int i = 0; i<N; i++){\n\t\t\tS[i]=i;\n\t\t}\n\t}\n\t//end of reset\n\tprivate static void FSM(){\n\t\twhile(Q>0){\n\t\t\tfetch();\n\t\t\tdispatch();\n\t\t\tQ--;\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\t//end of FSM\n\tprivate static void fetch(){\n\t\tCom = (scanner.nextInt() > 0)?true:false;\n\t\tV1 = scanner.nextInt();\n\t\tV2 = scanner.nextInt();\n\t}\n\t//end of feteh\n\tprivate static void dispatch(){\n\t\tif(Com){\n\t\t\tsame();\n\t\t}else {\n\t\t\tunite();\n\t\t}\n\t}\n\t//end of dispatch\n\tprivate static void unite(){\n\t\tif(S[V1] == S[V2]){\n\t\t\treturn;\n\t\t}else{\n\t\t\tmerge();\n\t\t}\n\t}\n\t//end of unite\n\tprivate static void same(){\n\t\tif(S[V1] == S[V2]){\n\t\t\tSystem.out.println(1);\n\t\t}else{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t}\n\t//end of same\n\tprivate static void merge(){\n\t\tV1 = S[V1];// use variable 1 to store the set code of V1\n\t\tV2 = S[V2];// use variable 2 to store the set code of V2\n\t\tfor(int i = 0; i< N;i++)\n\t\t{\n\t\t\tif(S[i] == V1){\n\t\t\t\tS[i] = V2;\n\t\t\t}else{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    //////////// Just add a system for weighting\npublic class UFTW_Node {\n\tint name;\n\tUFTW_Node next;\n\tint rank;\n\tint next_diff;\n\n\tpublic UFTW_Node(int new_name){\n\t\tthis.name = new_name;\n\t\tthis.rank =0;\n\t\tthis.next_diff =0;\n\t\tthis.next = this;\n\t\t}\n\n\tpublic UFTW_Node getRep(){\n\t\tUFTW_Node output;\n\t\tif (this.next.name == this.name)\n\t\t\treturn this;\n\t\telse output = this.next.getRep();\n\t\tthis.next = output; \n\t\treturn output;\n\t}\n\t\n\tpublic int getRepDiff(){\n\t\tif (this.next.name == this.name){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tthis.next_diff += this.next.getRepDiff();\n\t\t\treturn this.next_diff;\n\t\t\t\n\t\t}\n\t}\n}\n\n\tUFTW_Node[] nodes;\n\tpublic static void main(String[] args){\n\t\tArrayList<String> output = new ArrayList<String>();\n\t\tMain test = new Main();\n\t\tScanner inputScanner = new Scanner(\"System.in\").useDelimiter(\"\\\\s\");\n\t\tint n = inputScanner.nextInt();\n\t\tint q = inputScanner.nextInt();\n\t\ttest.nodes = test.makeArray(n);\n\t\t\n\t\tint type = -1;\n\t\tint x= -1;\n\t\tint y= -1;\n\t\tint z=0;\n\t\tfor (int i=0;i<q;i++){\n\t\t\ttype = inputScanner.nextInt();\n\t\t\tx = inputScanner.nextInt();\n\t\t\ty = inputScanner.nextInt();\n\t\t\tif(type ==0){\n\t\t\t\tz =inputScanner.nextInt();\n\t\t\t\ttest.union(x,y,z);\n\t\t\t}\n\t\t\tif(type ==1){\n\t\t\t\tif(test.nodes[x].getRep().name == test.nodes[y].getRep().name){\n\t\t\t\toutput.add(Integer.toString(test.same(x, y)));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput.add(\"?\");\n\t\t\t}\n\t\t} \n\t\tfor(String out : output){\n\t\t\tSystem.out.println(out.toString());\n\t\t}\n\t}\n\tpublic UFTW_Node[] makeArray(int num){\n\t\tUFTW_Node[] output = new UFTW_Node[num];\n\t\tfor (int i=0; i<num;i++){\n\t\t\toutput[i] = new UFTW_Node(i);\n\t\t}\n\treturn output;\n\t}\n\t\n\tpublic void union(int x, int y,int z){\n\t\tint xdiff = nodes[x].getRepDiff();\n\t\tint ydiff = nodes[y].getRepDiff();\n\t\tUFTW_Node yRep = nodes[y].getRep();\n\t\tUFTW_Node xRep = nodes[x].getRep();\n\t\tif (yRep.rank> xRep.rank){\n\t\t\txRep.next= yRep;\n\t\t\txRep.next_diff = z - xdiff +ydiff;\n\t\t}\n\t\telse if(yRep.rank< xRep.rank){\n\t\t\tyRep.next= xRep;\n\t\t\tyRep.next_diff = ydiff -z -xdiff;\n\t\t}\n\t\telse{\n\t\t\tyRep.next= xRep;\n\t\t\txRep.rank++;\n\t\t\tyRep.next_diff = ydiff -z -xdiff;\n\t\t}\n\t}\n\t\n\tpublic int same (int x, int y){\n\t\treturn nodes[x].getRepDiff() -nodes[y].getRepDiff();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n// disjoin set\npublic class Main {\n    static class UnionFindTree {\n\n        private int parent[];\n        private int rank[];\n        private int weight[];\n\n        public UnionFindTree(int Num_element) {\n            parent = new int[Num_element];\n            rank = new int[Num_element];\n            weight = new int[Num_element];\n            for (int i = 0; i < Num_element; i++)\n                makeSet(i);\n        }\n\n        public void makeSet(int x) {\n            parent[x] = x;\n            rank[x] = 0;\n            weight[x] = 0;\n        }\n\n        public void union(int x, int y, int cost) {\n            link(findSet(x), findSet(y), cost - weight[x] + weight[y]);\n        }\n\n        public int findSet(int x) {\n            if (x != parent[x]) {\n                int tmp = findSet(parent[x]);;\n                weight[x] += weight[parent[x]];\n                parent[x] = tmp;\n            }\n            return parent[x];\n        }\n        public boolean same(int x,int y){\n            return findSet(x) == findSet(y);\n        }\n\n        public void link(int x, int y, int cost) {\n            if (rank[x] > rank[y]) {\n                parent[y] = x;\n                weight[y] -= cost;\n            } else {\n                parent[x] = y;\n                weight[x] += cost;\n                if (rank[x] == rank[y]) {\n                    rank[y]++;\n                }\n            }\n        }\n\n        public int sum(int x) {\n            int sum = 0;\n            int now = x;\n            while ((now != parent[now])) {\n                sum += weight[now];\n                now = parent[now];\n            }\n            return sum;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // Disjoin set element number\n        int Num_element;\n\n        //Query times\n        int Num_query;\n\n\n        Num_element = sc.nextInt();\n        Num_query = sc.nextInt();\n        UnionFindTree Disjoin_set = new UnionFindTree(Num_element);\n        for (int i = 0; i < Num_query; i++) {\n            // '0' denotes unite and '1' denotes same operation.\n            int com = sc.nextInt();\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            if (com == 0) {\n                int z = sc.nextInt();\n                Disjoin_set.union(x, y, z);\n            } else {\n                if(!Disjoin_set.same(x,y)){\n                    System.out.println(\"?\");\n                }else\n                    System.out.println(Disjoin_set.sum(x) - Disjoin_set.sum(y));\n            }\n        }\n\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tclass DisjointSet {\n\t\t\n\t\tint[] p, w, r;\n\t\tint size;\n\t\t\n\t\tpublic DisjointSet(int n) {\n\t\t\tsize = n;\n\t\t\tp = new int[size];\n\t\t\tr = new int[size];\n\t\t\tw = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) makeSet(i);\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tp[x] = x;\n\t\t\tw[x] = r[x] = 0;\n\t\t}\n\t\t\n\t\tprivate int findSet(int x) {\n\t\t\tif (p[x] != x) {\n\t\t\t\tint tmp = findSet(p[x]);\n\t\t\t\tw[x] += w[p[x]];\n\t\t\t\tp[x] = tmp;\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - w[x] + w[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (r[x] > r[y]) {\n\t\t\t\tp[y] = x;\n\t\t\t\tw[y] -= cost;\n\t\t\t} else {\n\t\t\t\tp[x] = y;\n\t\t\t\tw[x] += cost;\n\t\t\t\tif (r[x] == r[y]) {\n\t\t\t\t\tr[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint cur = x;\n\t\t\twhile (cur != p[cur]) {\n\t\t\t\tsum += w[cur];\n\t\t\t\tcur = p[cur];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tpublic void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c = Integer.parseInt(st.nextToken());\n\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\tint y = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tint z = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else {\n\t\t\t\tif (ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class DisjointSet {\n\n\t\tprivate int[] parent;\n\t\tprivate int[] rank;\n\t\tprivate int[] weight;\n\t\t\n\t\tpublic DisjointSet(int size) {\n\t\t\tparent = new int[size];\n\t\t\trank = new int[size];\n\t\t\tweight = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmakeSet(i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void makeSet(int x) {\n\t\t\tparent[x] = x;\n\t\t\trank[x] = 0;\n\t\t\tweight[x] = 0;\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\n\t\tprivate int findSet(int x) {\n\t\t\twhile (x != parent[x]) {\n\t\t\t\tx = parent[x];\n\t\t\t}\n\t\t\treturn parent[x];\n\t\t}\n\t\t\n\t\tpublic void relate(int x, int y, int z) {\n\t\t\tlink(findSet(x), findSet(y), z - weight[x] + weight[y]);\n\t\t}\n\n\t\tprivate void link(int x, int y, int cost) {\n\t\t\tif (rank[x] > rank[y]) {\n\t\t\t\tparent[y] = x;\n\t\t\t\tweight[y] -= cost;\n\t\t\t} else {\n\t\t\t\tparent[x] = y;\n\t\t\t\tweight[x] += cost;\n\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\trank[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int sum(int x) {\n\t\t\tint sum = 0;\n\t\t\tint now = x;\n\t\t\twhile (now != parent[now]) {\n\t\t\t\tsum += weight[now];\n\t\t\t\tnow = parent[now];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint q = Integer.parseInt(st.nextToken());\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\tint c, x, y, z;\n\t\t\tc = Integer.parseInt(st.nextToken());\n\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\tif (c == 0) {\n\t\t\t\tz = Integer.parseInt(st.nextToken());\n\t\t\t\tds.relate(x, y, z);\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!ds.same(x, y)) {\n\t\t\t\t\tSystem.out.println(\"?\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ds.sum(x) - ds.sum(y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Numerics;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n\n    public void Solve(Scanner sc)\n    {\n        int N, Q;\n        sc.Make(out N, out Q);\n        var uf = new WeightedUnionFind(N);\n        while (Q-- > 0)\n        {\n            var t = sc.Next<int>();\n            if (t == 0)\n            {\n                int x, y, z;\n                sc.Make(out x, out y, out z);\n                uf.Union(x, y, z);\n            }\n            else\n            {\n                int x, y;sc.Make(out x, out y);\n                if (uf[x] != uf[y]) WriteLine(\"?\");\n                else WriteLine(uf.Dif(x, y));\n            }\n        }\n    }\n}\n\nclass WeightedUnionFind\n{\n    public int GroupCount { get; private set; }\n    protected int[] data;\n    private long[] dif;\n    public virtual int this[int i] { get { return Find(i); } }\n    public WeightedUnionFind(int size)\n    {\n        data = new int[size]; dif = new long[size];\n        GroupCount = size;\n        for (var i = 0; i < size; i++)\n            data[i] = -1;\n    }\n    protected int Find(int i)\n    {\n        if (data[i] < 0) return i;\n        var root = Find(data[i]);\n        dif[i] += dif[data[i]];\n        return data[i] = root;\n    }\n    private long Weight(int i) { Find(i); return dif[i]; }\n    public long Dif(int u, int v)\n        => Weight(v) - Weight(u);\n    public int Size(int i)\n        => -data[Find(i)];\n    public virtual bool Union(int u, int v, long w)\n    {\n        w += Weight(u); w -= Weight(v);\n        u = Find(u); v = Find(v);\n        if (u == v) return false;\n        if (data[u] > data[v])\n        { swap(ref u, ref v); w = -w; }\n        GroupCount--;\n        data[u] += data[v];\n        data[v] = u;\n        dif[v] = w;\n        return true;\n    }\n}\n\n\npublic class RollingHash\n{\n    public string str { get; }\n    private ulong[] hashTable;\n    private static ulong[] pow;\n    private static uint Base { get; }\n    const ulong MASK30 = (1UL << 30) - 1;\n    const ulong MASK31 = (1UL << 31) - 1;\n    private const ulong MOD = (1UL << 61) - 1;\n    public RollingHash(string str)\n    {\n        this.str = str;\n        hashTable = new ulong[str.Length + 1];\n        for (var j = 1; j <= str.Length; j++)\n            hashTable[j] = CalcMod(Mul(hashTable[j - 1], Base) + str[j - 1]);\n    }\n    static RollingHash()\n    {\n        var rnd = new Random(); int min = 150, max = int.MaxValue;\n        Base = (uint)rnd.Next(min, max);\n        pow = new ulong[31];\n        pow[0] = 1;\n        for (var j = 1; j < pow.Length; j++)\n            pow[j] = Mul(pow[j - 1], Base);\n    }\n\n    private static ulong Mul(ulong a, ulong b)\n    {\n        var au = a >> 31;\n        var ad = a & MASK31;\n        var bu = b >> 31;\n        var bd = b & MASK31;\n        var mid = ad * bu + au * bd;\n        var midu = mid >> 30;\n        var midd = (mid & MASK30);\n        return CalcMod(au * bu * 2 + midu + (midd << 31) + ad * bd);\n    }\n    private static ulong CalcMod(ulong val)\n    {\n        val = (val & MOD) + (val >> 61);\n        if (val > MOD) val -= MOD;\n        return val;\n    }\n\n    public ulong GetHash(int l = 0, int r = -1)\n    {\n        if (r < 0) r = str.Length;\n        return CalcMod(hashTable[r] + MOD * ((1UL << 3) - 1) - Mul(hashTable[l], pow[r - l]));\n    }\n}\n#region Template\npublic static class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve(new Scanner());\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == 1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) == -1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static T Unify<T>(this T[] A, Func<T, T, T> f, T init = default(T)) { for (var i = 0; i < A.Length; i++) init = f(init, A[i]); return init; }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\n\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    //public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    //public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    //public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b, out T3 c) { Deconstruct(out a, out b); c = v3; }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static Reader;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    public static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var n = NextInt;\n        var q = NextInt;\n        var uf = new PotentializedUnionFind<int>(n, (x, y) => x + y, x => -x, 0);\n        for (int i = 0; i < q; i++)\n        {\n            if (NextInt == 0)\n            {\n                uf.TryUnite(NextInt, NextInt, NextInt);\n            }\n            else\n            {\n                var a = NextInt;\n                var b = NextInt;\n                Console.WriteLine(uf.Find(a) == uf.Find(b) ? uf.GetPotential(b, a).ToString() : \"?\");\n            }\n        }\n        Console.Out.Flush();\n    }\n}\n\nclass PotentializedUnionFind<T> where T : IEquatable<T>\n{\n    public int Size { get; private set; }\n    public int GroupCount { get; private set; }\n    public IEnumerable<int> AllRepresents => Parent.Where((x, y) => x == y);\n    int[] Sizes;\n    int[] Parent;\n    T[] Value;\n    Func<T, T, T> Operate;\n    Func<T, T> Inverse;\n    T Identity;\n\n    public PotentializedUnionFind(int count, Func<T, T, T> operate, Func<T, T> inverse, T identity)\n    {\n        Size = count;\n        GroupCount = count;\n        Parent = new int[count];\n        Sizes = new int[count];\n        Value = new T[count];\n        for (int i = 0; i < count; i++) { Sizes[Parent[i] = i] = 1; Value[i] = identity; }\n        Operate = operate;\n        Inverse = inverse;\n        Identity = identity;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public bool TryUnite(int x, int y, T distance)\n    {\n        T xd, yd;\n        int xp = Find(x, out xd);\n        int yp = Find(y, out yd);\n\n        if (yp == xp) return Operate(distance, yd).Equals(xd);\n\n        GroupCount--;\n        if (Sizes[xp] < Sizes[yp])\n        {\n            Value[xp] = Operate(Operate(Inverse(xd), distance), yd);\n            Parent[xp] = yp;\n            Sizes[yp] += Sizes[xp];\n        }\n        else\n        {\n            Value[yp] = Operate(Operate(Inverse(yd), Inverse(distance)), xd);\n            Parent[yp] = xp;\n            Sizes[xp] += Sizes[yp];\n        }\n        return true;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int GetSize(int x) => Sizes[Find(x)];\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T GetPotential(int x, int y)\n    {\n        T xd, yd;\n        int xp = Find(x, out xd);\n        int yp = Find(y, out yd);\n        if (yp == xp) return Operate(Inverse(xd), yd);\n        else return Identity;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int Find(int x)\n    {\n        while (x != Parent[x]) { Value[x] = Operate(Value[x], Value[Parent[x]]); Parent[x] = Parent[Parent[x]]; x = Parent[x]; }\n        return x;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private int Find(int x, out T potential)\n    {\n        potential = Identity;\n        while (x != Parent[x])\n        {\n            Value[x] = Operate(Value[x], Value[Parent[x]]);\n            Parent[x] = Parent[Parent[x]];\n            potential = Operate(potential, Value[x]);\n            x = Parent[x];\n        }\n        return x;\n    }\n}\n\n\nstatic class Reader\n{\n    const int BUF_SIZE = 1 << 12;\n    static Stream Stream = Console.OpenStandardInput();\n    static byte[] Buffer = new byte[BUF_SIZE];\n    static int ptr = BUF_SIZE - 1;\n    static void Move() { if (++ptr >= Buffer.Length) { Stream.Read(Buffer, 0, BUF_SIZE); ptr = 0; } }\n\n\n    public static int NextInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            int res = 0; while (Buffer[ptr] < 48) Move();\n            do { res = res * 10 + (int)(Buffer[ptr] ^ 48); Move(); } while (48 <= Buffer[ptr]);\n            return res;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var U = new PotentialDisjointSet(N);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                U.Unite(cin.nextint, cin.nextint, cin.nextlong);\n            }\n            else if (com == 1)\n            {\n                int x = cin.nextint;\n                int y = cin.nextint;\n                if (U.Same(x, y))\n                {\n                    WriteLine(U.Diff(x, y));\n                }\n                else\n                {\n                    WriteLine('?');\n                }\n            }\n        }\n    }\n    \n}\n\nclass PotentialDisjointSet\n{\n    readonly int[] par;\n    readonly byte[] rank;\n    readonly long[] diff_weight;\n    /// <summary>\n    /// 0 から <paramref name=\"N\"/>-1 までの番号がついた <paramref name=\"N\"/> 個の要素からなる集合を作成します．\n    /// </summary>\n    /// <param name=\"N\">要素数</param>\n    /// <remarks>このコンストラクタは O(N) で実行されます．</remarks>\n    public PotentialDisjointSet(int N)\n    {\n        par = new int[N];\n        rank = new byte[N];\n        diff_weight = new long[N];\n        for (int i = 0; i < N; i++) par[i] = -1;\n    }\n    /// <summary>\n    /// 指定した要素が属する集合の代表値を取得します．\n    /// </summary>\n    /// <param name=\"id\">調べたい要素の 0-indexed での番号</param>\n    /// <returns>指定した要素が属する集合の代表値</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public int this[int id]\n    {\n        get\n        {\n            if (par[id] < 0) return id;\n            int r = this[par[id]];\n            diff_weight[id] += diff_weight[par[id]];\n            return par[id] = r;\n        }\n    }\n    /// <summary>\n    /// 指定した 2 つの要素が属する集合同士を 1 つに統合することを試みます．weight(y) = weight(x) + w です．\n    /// </summary>\n    /// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n    /// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n    /// <param name=\"w\">weight(y) = weight(x) + w となるポテンシャル</param>\n    /// <returns>統合に成功したならば true，そうでなければ false．</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public bool Unite(int x, int y, long w)\n    {\n        w += Weight(x); w -= Weight(y);\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var tmp = x; x = y; y = tmp; w = -w; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n        diff_weight[y] = w;\n        return true;\n    }\n    /// <summary>\n    /// 指定した要素が属する集合のサイズを取得します．\n    /// </summary>\n    /// <param name=\"x\">指定する要素の 0-indexed での番号</param>\n    /// <returns>集合のサイズ</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public int Size(int x) => -par[this[x]];\n\n    /// <summary>\n    /// 指定した 2 つの要素が属する集合が同じかどうかを判定する．計算量 O(α(N))．\n    /// </summary>\n    /// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n    /// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n    /// <returns>同じならば true，そうでなければ false．</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public bool Same(int x, int y) => this[x] == this[y];\n\n    long Weight(int x)\n    {\n        var tmp = this[x];\n        return diff_weight[x];\n    }\n    /// <summary>\n    /// 指定した 2 つの要素のポテンシャルの差．Weight(y) - Weight(x)．計算量 O(α(N))．\n    /// </summary>\n    /// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n    /// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n    /// <returns>ポテンシャルの差</returns>\n    /// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n    public long Diff(int x, int y) => Weight(y) - Weight(x);\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush=\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ' '));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\tvar N = cin.ReadInt;\n\t\t\tvar Q = cin.ReadInt;\n\t\t\tvar W = new WeightedUFF(N);\n\t\t\tfor(int j = 0; j<Q; j++) {\n\t\t\t\tvar query = cin.ReadInt;\n\t\t\t\tint[] datum;\n\t\t\t\tswitch(query) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdatum = cin.ReadIntArray(3);\n\t\t\t\t\t\tW.Union(datum[0], datum[1], datum[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdatum=cin.ReadIntArray(2);\n\t\t\t\t\t\tConsole.WriteLine(W.Weight(datum[0], datum[1])?.ToString()??\"?\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static void Swap<T>(this T[] A, int x, int y) {\n\t\t\tvar tmp = A[x];\n\t\t\tA[x]=A[y];\n\t\t\tA[y]=tmp;\n\t\t}\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[] X) => Enumerable.Range(0, X.Length);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[,] X, int dim)\n\t\t\t=> Enumerable.Range(0, X.GetLength(dim));\n\t\tpublic static string Join<T>(this T[,] X, string separatorD2 = \",\", string separatorD1 = \"\\n\")\n\t\t\t=> X.Indices(0).Select(\n\t\t\t\ti => X.Indices(1).Select(j => X[i, j]).Join(separatorD2)\n\t\t\t).Join(separatorD1);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator=separator;\n\t\t\tthis._stream=stream;\n\t\t\tinputStream=new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count!=0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i<tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i<N; ++i)\n\t\t\t\tret[i]=Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i<N; ++i) ret[i]=ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i<N; ++i) ret[i]=ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i<N; ++i) ret[i]=ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek()==-1; }\n\t\t}\n\t}\n\tclass WeightedUFF {\n\t\tpublic class WNode {\n\t\t\tpublic int value { get; set; }\n\t\t\tpublic long weight { get; set; } = 0;\n\t\t\tpublic WNode parent { get; set; }\n\t\t\tpublic int rank { get; private set; }    //meanful iff root\n\t\t\tpublic void rankIncrement() => rank++;\n\t\t\tpublic WNode root {\n\t\t\t\tget {\n\t\t\t\t\tvar path = new Queue<WNode>();\n\t\t\t\t\tvar res = this;\n\t\t\t\t\tvar dist = 0L;\n\t\t\t\t\twhile(res.parent!=res) {\n\t\t\t\t\t\tpath.Enqueue(res);\n\t\t\t\t\t\tdist+=res.weight;\n\t\t\t\t\t\tres=res.parent;\n\t\t\t\t\t}\n\t\t\t\t\twhile(path.Any()) {\n\t\t\t\t\t\tvar d = path.Dequeue();\n\t\t\t\t\t\td.parent=res;\n\t\t\t\t\t\tdist-=d.weight;\n\t\t\t\t\t\td.weight+=dist;\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic WNode(int _value) {\n\t\t\t\tvalue=_value;\n\t\t\t\tparent=this;\n\t\t\t\trank=1;\n\t\t\t}\n\t\t}\n\t\tpublic WeightedUFF(int N) {\n\t\t\tfor(int i = 0; i<N; i++) Register(i);\n\t\t}\n\t\tpublic readonly Dictionary<int, WNode> Registry = new Dictionary<int, WNode>();\n\t\tpublic void Union(int x, int y, long weight) => Union(Registry[x], Registry[y], weight);\n\t\tpublic void Union(WNode X, WNode Y, long weight) {\n\t\t\tvar RX = X.root;\n\t\t\tvar RY = Y.root;\n\t\t\tswitch(RX.rank.CompareTo(RY.rank)) {\n\t\t\t\tcase 1:\n\t\t\t\t\tRY.parent=RX;\n\t\t\t\t\tRY.weight=-(weight+Y.weight-X.weight);\n\t\t\t\t\tbreak;\n\t\t\t\tcase -1:\n\t\t\t\t\tRX.parent=RY;\n\t\t\t\t\tRX.weight=weight+Y.weight-X.weight;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRX.parent=RY;\n\t\t\t\t\tRX.weight=weight+Y.weight-X.weight;\n\t\t\t\t\tRY.rankIncrement();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpublic void Register(int id) {\n\t\t\tvar N = new WNode(id);\n\t\t\tRegistry.Add(id, N);\n\t\t}\n\t\tpublic bool Find(int x, int y) => Find(Registry[x], Registry[y]);\n\t\tpublic bool Find(WNode X, WNode Y) => X.root==Y.root;\n\t\tpublic long? Weight(WNode From, WNode To) {\n\t\t\tif(!Find(From, To)) return null;\n\t\t\treturn From.weight-To.weight;\n\t\t}\n\t\tpublic long? Weight(int from, int to) => Weight(Registry[from], Registry[to]);\n\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def get_height x\n    px, hx = x, 0\n    while px != @parent[px][0]\n        hx += @parent[px][1]\n        px = @parent[px][0]\n    end\n    return [px, hx]\nend\n\nn, q = gets.chomp.split.map(&:to_i)\n\n@parent = []\n0.upto(n - 1){|i| @parent[i] = [i, 0]}\n\nq.times{\n    command, x, y, z = gets.chomp.split.map(&:to_i)\n    px, hx = get_height(x)\n    py, hy = get_height(y)\n\n    case command\n    when 0\n        next if px == py\n        if px < py\n            @parent[py] = px, hx - hy + z\n        else\n            @parent[px] = py, hy - hx - z\n        end\n    when 1\n        puts (px != py) ? \"?\" : hy - hx\n    end\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class UnionFindWeighted\n  def initialize(n)\n    @parent = (0...n).to_a # 親の番号\n    @rank = Array.new(n, 0) # 木の深さ\n    @diff_weight = Array.new(n, 0) # 親との重みの差\n  end\n\n  def root(x)\n    return x if @parent[x] == x\n    r = root(@parent[x])\n    @diff_weight[x] += @diff_weight[@parent[x]]\n    @parent[x] = r\n    return r\n  end\n\n  def weight(x)\n    root(x)\n    return @diff_weight[x]\n  end\n\n  def same?(x, y)\n    root(x) == root(y)\n  end\n\n  def diff(x, y)\n    # x と y とが同じグループにいるとき、weight(y) - weight(x) を返す\n    # 同じグループでないならnil\n    return nil if !same?(x, y)\n    return weight(y) - weight(x)\n  end\n\n  def merge(x, y, w)\n    # weight(y) - weight(x) = wとなるように結合\n    w += weight(x)\n    w -= weight(y)\n    x, y = root(x), root(y)\n    return false if x == y\n    if @rank[x] < @rank[y]\n      x, y = y, x\n      w = -w\n    end\n    @rank[x] += 1 if @rank[x] == @rank[y]\n    @parent[y] = x\n    @diff_weight[y] = w\n    return true\n  end\nend\n\nn, q = gets.split.map(&:to_i)\nuf = UnionFindWeighted.new(n)\nans = []\nq.times do\n  query = gets.split.map(&:to_i)\n  if query[0] == 1\n    x, y = query[1..-1]\n    ans << (uf.diff(x, y) || \"?\")\n  else\n    x, y, z = query[1..-1]\n    uf.merge(x, y, z)\n  end\nend\n\nputs ans\n\n"
  },
  {
    "language": "Ruby",
    "code": "class PotentialUnionFind\n  def initialize(n)\n    @size = Array.new(n, 1)\n    @rank = Array.new(n, 0)\n    @diff_weight = Array.new(n + 1, 0)\n    @parent = []\n\n    (0..n).each do |i|\n      @parent[i] = i\n    end\n  end\n\n  def find(x)\n    if @parent[x] == x\n      x\n    else\n      root = find(@parent[x])\n      @diff_weight[x] += @diff_weight[@parent[x]]\n      @parent[x] = root\n    end\n  end\n\n  def unite(x, y, w)\n    w += weight(x)\n    w -= weight(y)\n    x = find(x)\n    y = find(y)\n\n    return false if x == y\n\n    if @rank[x] < @rank[y]\n      @diff_weight[x] = -w\n      @parent[x] = y\n      @size[y] += @size[x]\n    else\n      @parent[y] = x\n      @diff_weight[y] = w\n      @size[x] += @size[y]\n\n      @rank[x] += 1 if @rank[x] == @rank[y]\n    end\n  end\n\n  def weight(x)\n    find(x)\n    @diff_weight[x]\n  end\n\n  def diff(x, y)\n    weight(y) - weight(x)\n  end\n\n  def same?(x, y)\n    find(x) == find(y)\n  end\n\n  def size(x)\n    @size[find(x)]\n  end\nend\n\nN, Q = gets.split.map(&:to_i)\npuf = PotentialUnionFind.new(N + 1)\n\nQ.times do\n  query = gets.split.map(&:to_i)\n\n  if query.first == 0\n    _, x, y, z = query\n\n    puf.unite(x, y, z)\n  else\n    _, x, y = query\n\n    if puf.same?(x, y)\n      puts puf.diff(x, y)\n    else\n      puts '?'\n    end\n  end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :next, :cost\n  def initialize(i)\n    @next=i\n    @cost=0\n  end\nend\n\ndef cal_cost(x)\n  temp = x\n  cost = 0\n  while temp != $nodes[temp].next\n    cost += $nodes[temp].cost\n    temp = $nodes[temp].next\n  end\n  return [temp,cost]\nend\n\nn,q = gets.split.map(&:to_i)\n$nodes = []\nn.times{|i| $nodes << Node.new(i)}\n\nq.times{\n  com, x, y, z = gets.split.map(&:to_i)\n  tempx, costx = cal_cost(x)\n  tempy, costy = cal_cost(y)\n  if com == 0\n    if tempx != tempy\n      if tempx < tempy\n        $nodes[tempy].next = tempx\n        $nodes[tempy].cost = costx - costy + z\n      else\n        $nodes[tempx].next = tempy\n        $nodes[tempx].cost = costy - costx - z\n      end\n    end\n#    $nodes.each_with_index{|node,i| puts \"id:#{i} next:#{node.next} cost:#{node.cost}\"}\n#    puts\n  elsif com == 1\n#    $nodes.each_with_index{|node,i| puts \"id:#{i} next:#{node.next} cost:#{node.cost}\"}\n#    puts\n    puts tempx != tempy ? \"?\" : costy-costx\n  end\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def get_i() #空白区切の入力を数値(整数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_i)\nend\ndef get_f() #空白区切の入力を数値(実数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_f)\nend\ndef get() #空白区切の入力を文字列の配列で返す\n  return gets.chomp.split(\" \")\nend\ndef get_nsp() #入力されたものを一文字ずつに区切った文字列の配列で返す\n  return gets.chomp.split(\"\")\nend\ndef yn_judge(bool,y=\"Yes\",n=\"No\") #boolに真偽を投げることで、trueならy、falseならnの値を出力する\n  return bool ? y : n \nend\ndef array(size,n=1,init=nil) #nに配列の次元数、sizeに配列の大きさ、initに初期値を投げることでその配列を返す\n  if n==1\n    return Array.new(size){init}\n  else\n    return Array.new(n).map{Array.new(size){init}}\n  end\nend\n\nclass WUFT\n  attr_accessor:node,:rank,:weight\n  def initialize(n)\n    @node=Array.new(n){|i| i}\n    @rank=array(n,1,0)\n    @weight=array(n,1,0)\n  end\n\n  def find(x)\n    return x if @node[x]==x\n    y=find(@node[x])\n    @weight[x]+=@weight[@node[x]]\n    @node[x]=y\n    return y\n  end\n\n  def union(x,y,z)\n    rx=find(x)\n    ry=find(y)\n    if @rank[rx]<@rank[ry]\n      @node[rx]=ry\n      @weight[rx]=z-@weight[x]+@weight[y]\n    else\n      @node[ry]=rx\n      @weight[ry]=-z-@weight[y]+@weight[x]\n      @rank[rx]+=1 if @rank[rx]==@rank[ry]\n    end \n  end\n\n  def diff(x,y)\n    return @weight[x]-@weight[y]\n  end\n\n  def same?(x,y)\n    return find(x)==find(y)\n  end\nend\n\n\nn,q=get_i\nwuft=WUFT.new(n)\nq.times do\n  que=get_i\n  if que[0].zero?\n    wuft.union(que[1],que[2],que[3])\n  else\n    if wuft.same?(que[1],que[2])\n      puts wuft.diff(que[1],que[2])\n    else\n      puts \"?\"\n    end\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :next, :cost\n  def initialize(i)\n    @next=i\n    @cost=0\n  end\nend\n\ndef cal_cost(x)\n  temp = x\n  cost = 0\n  while temp != $nodes[temp].next\n    cost += $nodes[temp].cost\n    temp = $nodes[temp].next\n  end\n  return [temp,cost]\nend\n\nn,q = gets.split.map(&:to_i)\n$nodes = []\nn.times{|i| $nodes << Node.new(i)}\nq.times{\n  com, x, y, z = gets.split.map(&:to_i)\n  tempx, costx = cal_cost(x)\n  tempy, costy = cal_cost(y)\n  if com == 0\n    if tempx != tempy\n      if tempx < tempy\n        $nodes[tempy].next = tempx\n        $nodes[tempy].cost = costx - costy + z\n      else\n        $nodes[tempx].next = tempy\n        $nodes[tempx].cost = costy - costx - z\n      end\n    end\n#    $nodes.each_with_index{|node,i| puts \"id:#{i} next:#{node.next} cost:#{node.cost}\"}\n#    puts\n  elsif com == 1\n#    $nodes.each_with_index{|node,i| puts \"id:#{i} next:#{node.next} cost:#{node.cost}\"}\n#    puts\n    puts tempx != tempy ? \"?\" : costy-costx.abs\n  end\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc newScanner() *bufio.Scanner {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanWords)\n\treturn scanner\n}\n\nvar sc = newScanner()\n\nfunc scanInt() int {\n\tsc.Scan()\n\tv, _ := strconv.Atoi(sc.Text())\n\treturn v\n}\n\nfunc scanInts(n int) []int {\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = scanInt()\n\t}\n\treturn a\n}\n\nfunc scanString() string {\n\tif sc.Scan() {\n\t\treturn sc.Text()\n\t}\n\tpanic(sc.Err())\n}\n\nfunc main() {\n\tn, q := scanInt(), scanInt()\n\tweightedUnionFindTrees(n, q)\n}\n\nfunc debug(a ...interface{}) {\n\t// fmt.Println(a...)\n}\n\nfunc weightedUnionFindTrees(n, q int) {\n\tpar := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tpar[i] = i\n\t}\n\trank := make([]int, n)\n\tweight := make([]int, n)\n\tfor i := 0; i < q; i++ {\n\t\texecuteQuery(par, rank, weight)\n\t}\n}\n\nfunc executeQuery(par, rank, weight []int) {\n\tcmd := scanInt()\n\tswitch cmd {\n\tcase 0: // relate\n\t\tx, y, z := scanInt(), scanInt(), scanInt()\n\t\tsetWeight(x, y, z, weight, par)\n\tcase 1: // diff\n\t\tx, y := scanInt(), scanInt()\n\t\tdiff(x, y, weight, par)\n\t}\n}\n\nfunc setWeight(small, large, greaterBy int, weight, par []int) {\n\tdebug(\"setWeight\", small, large, greaterBy)\n\tif getRoot(small, par, weight) != getRoot(large, par, weight) {\n\t\tsmallRoot := getRoot(small, par, weight)\n\t\tweight[smallRoot] = weight[smallRoot] - weight[small] - greaterBy\n\t\tpar[smallRoot] = large\n\t} else {\n\t\tweight[small] = weight[large] - greaterBy\n\t}\n\tdebug(weight)\n}\n\nfunc diff(x, y int, weight, par []int) {\n\tdebug(\"diff\", x, y)\n\tif getRoot(x, par, weight) == getRoot(y, par, weight) {\n\t\tfmt.Println(weight[y] - weight[x])\n\t} else {\n\t\tfmt.Println(\"?\")\n\t}\n\n\tdebug(weight)\n}\n\nfunc getRoot(x int, par, weight []int) int {\n\tdebug(\"getRoot [START]\", x, par, weight)\n\tif par[x] == x {\n\t\tdebug(\"getRoot [END]\", x, par, weight)\n\t\treturn x\n\t}\n\troot := getRoot(par[x], par, weight)\n\tweight[x] += weight[par[x]]\n\tpar[x] = root\n\tdebug(\"getRoot [END]\", x, par, weight)\n\treturn root\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\ntype node struct {\n\titem   int\n\tprev   *node\n\trank   int\n\tweight int\n}\n\nfunc (n *node) root() *node {\n\tvar parent *node\n\tfor parent = n; parent.prev != nil; parent = parent.prev {\n\t\tcontinue\n\t}\n\tif n != parent {\n\t\tif n.prev != nil {\n\t\t\tn.weight += n.prev.weight\n\t\t}\n\t\tn.prev = parent\n\t}\n\treturn parent\n}\n\nfunc diff(nodeX, nodeY *node) int {\n\treturn nodeY.Weight() - nodeX.Weight()\n}\n\nfunc issame(nodeX, nodeY *node) bool {\n\treturn nodeX.root() == nodeY.root()\n\n}\n\nfunc (n *node) Weight() int {\n\tn.root()\n\treturn n.weight\n}\n\nfunc merge(nodeX, nodeY *node, w int) {\n\tw += nodeX.Weight()\n\tw -= nodeY.Weight()\n\n\tnodeX = nodeX.root()\n\tnodeY = nodeY.root()\n\tif nodeX.item == nodeY.item {\n\t\treturn\n\t}\n\n\tif nodeX.rank < nodeY.rank {\n\t\tnodeX, nodeY = nodeY, nodeX\n\t\tw *= -1\n\t}\n\n\tif nodeX.rank == nodeY.rank {\n\t\tnodeX.rank += 1\n\t}\n\n\tif nodeX.prev != nil || nodeY.prev != nil {\n\t\tpanic(fmt.Sprintf(\"%v, %v\", nodeX, nodeY))\n\t}\n\n\tnodeY.prev = nodeX\n\tnodeY.weight = w\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\n\tgroups := make([]*node, n)\n\tfor i := 0; i < n; i++ {\n\t\tgroups[i] = &node{item: i, prev: nil, rank: 0}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tcom, x, y := next(), next(), next()\n\t\tif com == 0 {\n\t\t\tz := next()\n\t\t\tmerge(groups[x], groups[y], z)\n\n\t\t} else {\n\t\t\tif issame(groups[x], groups[y]) {\n\t\t\t\tfmt.Println(diff(groups[x], groups[y]))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"?\")\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\ntype node struct {\n\titem   int\n\tprev   *node\n\trank   int\n\tweight int\n}\n\nfunc (n *node) root() *node {\n\tvar parent *node\n\tfor parent = n; parent.prev != nil; parent = parent.prev {\n\t\tcontinue\n\t}\n\tif parent != n {\n\t\tif n.prev != nil {\n\t\t\tn.weight += n.prev.weight\n\t\t}\n\t\tn.prev = parent\n\t}\n\treturn parent\n}\n\nfunc (n *node) Weight() int {\n\tn.root()\n\treturn n.weight\n}\n\nfunc diff(nodeX, nodeY *node) int {\n\treturn nodeY.Weight() - nodeX.Weight()\n}\n\nfunc issame(nodeX, nodeY *node) bool {\n\treturn nodeX.root() == nodeY.root()\n\n}\n\nfunc merge(nodeX, nodeY *node, w int) {\n\tparentX := nodeX.root()\n\tparentY := nodeY.root()\n\tif parentX.item == parentY.item {\n\t\treturn\n\t}\n\n\tw += nodeX.Weight()\n\tw -= nodeY.Weight()\n\n\tif nodeX.rank < nodeY.rank {\n\t\tnodeX, nodeY = nodeY, nodeX\n\t\tw = -w\n\t}\n\n\tif nodeX.rank == nodeY.rank {\n\t\tnodeX.rank += 1\n\t}\n\n\tif parentX.prev != nil || parentY.prev != nil {\n\t\tpanic(fmt.Sprintf(\"%v, %v\", parentX, parentY))\n\t}\n\n\tparentY.prev = parentX\n\tparentY.weight = w\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\n\tgroups := make([]*node, n)\n\tfor i := 0; i < n; i++ {\n\t\tgroups[i] = &node{item: i, prev: nil, rank: 0}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tcom, x, y := next(), next(), next()\n\t\tif com == 0 {\n\t\t\tw := next()\n\t\t\tmerge(groups[x], groups[y], w)\n\n\t\t} else {\n\t\t\tif !issame(groups[x], groups[y]) {\n\t\t\t\tfmt.Println(\"?\")\n\n\t\t\t} else {\n\t\t\t\tfmt.Println(diff(groups[x], groups[y]))\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\n\tif os.Getenv(\"MASPY\") == \"ますピ\" {\n\t\tfp, _ = os.Open(os.Getenv(\"BEET_THE_HARMONY_OF_PERFECT\"))\n\t}\n\tif os.Getenv(\"MASPYPY\") == \"ますピッピ\" {\n\t\twfp, _ = os.Create(os.Getenv(\"NGTKANA_IS_GENIUS10\"))\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\n\tn := getNextInt(scanner)\n\tq := getNextInt(scanner)\n\n\tnodes := make([]Node, n)\n\tfor i := 0; i < n; i++ {\n\t\tnodes[i].p = i\n\t}\n\tfor i := 0; i < q; i++ {\n\t\tt := getNextInt(scanner)\n\t\tx := getNextInt(scanner)\n\t\ty := getNextInt(scanner)\n\n\t\trx := root(x, nodes)\n\t\try := root(y, nodes)\n\n\t\tif t == 1 {\n\t\t\tif rx != ry {\n\t\t\t\tfmt.Fprintln(writer, \"?\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintln(writer, nodes[x].d-nodes[y].d)\n\t\t\tcontinue\n\t\t}\n\n\t\tz := getNextInt(scanner)\n\n\t\tnodes[rx].d = z + nodes[y].d - nodes[x].d\n\t\tnodes[rx].p = ry\n\t}\n\n\twriter.Flush()\n}\nfunc root(i int, nodes []Node) int {\n\tif i == nodes[i].p {\n\t\treturn i\n\t}\n\tp := root(nodes[i].p, nodes)\n\tnodes[i].d += nodes[nodes[i].p].d\n\tnodes[i].p = p\n\n\treturn p\n}\n\ntype Node struct {\n\tp, d int\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\ntype node struct {\n\titem   int\n\tprev   *node\n\trank   int\n\tweight int\n}\n\nfunc (n *node) root() *node {\n\tif n.prev == nil {\n\t\treturn n\n\t}\n\tr := n.prev.root()\n\tn.weight += n.prev.weight\n\tn.prev = r\n\treturn r\n}\n\nfunc diff(nodeX, nodeY *node) int {\n\treturn nodeY.Weight() - nodeX.Weight()\n}\n\nfunc issame(nodeX, nodeY *node) bool {\n\treturn nodeX.root() == nodeY.root()\n\n}\n\nfunc (n *node) Weight() int {\n\tn.root()\n\treturn n.weight\n}\n\nfunc merge(nodeX, nodeY *node, w int) {\n\tw += nodeX.Weight()\n\tw -= nodeY.Weight()\n\n\tnodeX = nodeX.root()\n\tnodeY = nodeY.root()\n\tif nodeX.item == nodeY.item {\n\t\treturn\n\t}\n\n\tif nodeX.rank < nodeY.rank {\n\t\tnodeX, nodeY = nodeY, nodeX\n\t\tw *= -1\n\t}\n\n\tif nodeX.rank == nodeY.rank {\n\t\tnodeX.rank += 1\n\t}\n\n\tif nodeX.prev != nil || nodeY.prev != nil {\n\t\tpanic(fmt.Sprintf(\"%v, %v\", nodeX, nodeY))\n\t}\n\n\tnodeY.prev = nodeX\n\tnodeY.weight = w\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\n\tgroups := make([]*node, n)\n\tfor i := 0; i < n; i++ {\n\t\tgroups[i] = &node{item: i, prev: nil, rank: 0}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tcom, x, y := next(), next(), next()\n\t\tif com == 0 {\n\t\t\tz := next()\n\t\t\tmerge(groups[x], groups[y], z)\n\n\t\t} else {\n\t\t\tif issame(groups[x], groups[y]) {\n\t\t\t\tfmt.Println(diff(groups[x], groups[y]))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"?\")\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\ntype node struct {\n\titem   int\n\tprev   *node\n\trank   int\n\tweight int\n}\n\nfunc (n *node) root() *node {\n\tvar parent *node\n\tfor parent = n; parent.prev != nil; parent = parent.prev {\n\t\tcontinue\n\t}\n\tif parent != n {\n\t\tif n.prev != nil {\n\t\t\tn.weight += n.prev.weight\n\t\t}\n\t\tn.prev = parent\n\t}\n\treturn parent\n}\n\nfunc (n *node) Weight() int {\n\tn.root()\n\treturn n.weight\n}\n\nfunc diff(nodeX, nodeY *node) int {\n\treturn nodeY.Weight() - nodeX.Weight()\n}\n\nfunc issame(nodeX, nodeY *node) bool {\n\treturn nodeX.root() == nodeY.root()\n\n}\n\nfunc merge(nodeX, nodeY *node, w int) {\n\tw += nodeX.Weight()\n\tw -= nodeY.Weight()\n\tparentX := nodeX.root()\n\tparentY := nodeY.root()\n\tif parentX.item == parentY.item {\n\t\treturn\n\t}\n\n\tif parentX.rank < parentY.rank {\n\t\tparentX, parentY = parentY, parentX\n\t\tw = -w\n\t}\n\n\tif parentX.rank == parentY.rank {\n\t\tparentX.rank += 1\n\t}\n\n\tif parentX.prev != nil || parentY.prev != nil {\n\t\tpanic(fmt.Sprintf(\"%v, %v\", parentX, parentY))\n\t}\n\n\tparentY.prev = parentX\n\tparentY.weight = w\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\n\tgroups := make([]*node, n)\n\tfor i := 0; i < n; i++ {\n\t\tgroups[i] = &node{item: i, prev: nil, rank: 0}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tcom, x, y := next(), next(), next()\n\t\tif com == 0 {\n\t\t\tw := next()\n\t\t\tmerge(groups[x], groups[y], w)\n\n\t\t} else {\n\t\t\tif !issame(groups[x], groups[y]) {\n\t\t\t\tfmt.Println(\"?\")\n\n\t\t\t} else {\n\t\t\t\tfmt.Println(diff(groups[x], groups[y]))\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\ntype node struct {\n\titem   int\n\tprev   *node\n\trank   int\n\tweight int\n}\n\nfunc (n *node) root() *node {\n\tif n.prev == nil {\n\t\treturn n\n\t}\n\tr := n.prev.root()\n\tn.weight += n.prev.weight\n\tn.prev = r\n\treturn r\n}\n\nfunc diff(nodeX, nodeY *node) int {\n\treturn nodeY.Weight() - nodeX.Weight()\n}\n\nfunc issame(nodeX, nodeY *node) bool {\n\treturn nodeX.root() == nodeY.root()\n\n}\n\nfunc (n *node) Weight() int {\n\tn.root()\n\treturn n.weight\n}\n\nfunc merge(nodeX, nodeY *node, w int) {\n\tw += nodeX.Weight()\n\tw -= nodeY.Weight()\n\n\tnodeX = nodeX.root()\n\tnodeY = nodeY.root()\n\tif nodeX.item == nodeY.item {\n\t\treturn\n\t}\n\n\tif nodeX.rank < nodeY.rank {\n\t\tnodeX, nodeY = nodeY, nodeX\n\t\tw *= -1\n\t}\n\n\tif nodeX.rank == nodeY.rank {\n\t\tnodeX.rank += 1\n\t}\n\n\tif nodeX.prev != nil || nodeY.prev != nil {\n\t\tpanic(fmt.Sprintf(\"%v, %v\", nodeX, nodeY))\n\t}\n\n\tnodeY.prev = nodeX\n\tnodeY.weight = w\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar n, q int\n\tfmt.Scanf(\"%d %d\", &n, &q)\n\n\tgroups := make([]*node, n)\n\tfor i := 0; i < n; i++ {\n\t\tgroups[i] = &node{item: i, prev: nil, rank: 0}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tcom, x, y := next(), next(), next()\n\t\tif com == 0 {\n\t\t\tz := next()\n\t\t\tmerge(groups[x], groups[y], z)\n\n\t\t} else {\n\t\t\tif issame(groups[x], groups[y]) {\n\t\t\t\tfmt.Println(diff(groups[x], groups[y]))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"?\")\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\ntype node struct {\n\tkey int\n\trelated int\n\tweight int\n}\nvar q int\nvar n int\nvar p []node\nfunc main(){\n\tfmt.Scanf(\"%d %d\",&n,&q)\n\tp=make([]node,n)\n\tfor i := 0; i < n; i++ {\n\t\tmakeSet(i)\n\t}\n\tvar op,x,y,diff int\n\tfor i := 0; i < q; i++ {\n\t\tfmt.Scanf(\"%d %d %d %d\",&op,&x,&y,&diff)\n\t\tif 1 == op {\n\t\t\tdiff_xy(x,y)\n\t\t}else {\n\t\t\tunite(x,y,diff)\n\t\t}\n\t}\n}\nfunc makeSet(x int)  {\n\tp[x]=node{\n\t\tkey: x,\n\t\trelated: x,\n\t}\n}\nfunc unite(x,y,diff int){\n\ttemp1:=findSet(x)\n\ttemp2:=findSet(y)\n\tif temp1 != temp2{\n\t\tp[temp2].related=temp1\n\t\tp[temp2].weight=p[x].weight - p[y].weight+diff\n\t}\n}\nfunc diff_xy(x,y int) {\n\tif findSet(x) == findSet(y) {\n\t\tfmt.Println(p[y].weight-p[x].weight)\n\t}else {\n\t\tfmt.Println(\"?\")\n\t}\n}\nfunc findSet(x int) int{\n\tif x == p[x].related {\n\t\treturn x\n\t}else {\n\t\ttemp:=p[x].related\n\t\tp[x].related = findSet(p[x].related)\n\t\tp[x].weight += p[temp].weight\n\t\treturn p[x].related\n\t}\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.math, std.typecons;\n\n\nvoid main() {\n    int n, q;\n    scan(n, q);\n\n    auto wuf = WeightedUnionFind!int(n);\n\n    foreach (_ ; 0 .. q) {\n        auto line = readln.split.to!(int[]);\n\n        if (line[0] == 0) {\n            wuf.merge(line[1], line[2], line[3]);\n        }\n        else {\n            auto dif = wuf.diff(line[1], line[2]);\n            writeln(dif < int.max ? dif.to!string : \"?\");\n        }\n    }\n}\n\n\n\nstruct WeightedUnionFind(T) {\n    private {\n        int[] _parent, _rank;\n        T[] _diff;\n    }\n\n    this(int N) {\n        _parent = new int[](N);\n        _rank = new int[](N);\n        _diff = new T[](N);\n\n        foreach (i ; 0 .. N) {\n            _parent[i] = i;\n        }\n    }\n\n    int findRoot(int x) {\n        if (_parent[x] != x) {\n            int r = findRoot(_parent[x]);\n            _diff[x] += _diff[_parent[x]];\n            _parent[x] = findRoot(r);\n        }\n\n        return _parent[x];\n    }\n\n    bool same(int x, int y) {\n        return findRoot(x) == findRoot(y);\n    }\n\n    T weight(int x) {\n        findRoot(x);\n        return _diff[x];\n    }\n\n    // x, y が異なるグループに属すならinf(十分大きい値)を返す\n    T diff(int x, int y) {\n        return same(x, y) ? weight(y) - weight(x) : T.max;\n    }\n\n    import std.algorithm : swap;\n\n    // weight(y) = weight(x) + w\n    bool merge(int x, int y, T w) {\n        w += weight(x) - weight(y);\n\n        int u = findRoot(x);\n        int v = findRoot(y);\n\n        // x, y が既に同じグループであるなら距離の更新はしない\n        if (u == v) return false;\n\n        if (_rank[u] < _rank[v]) {\n            swap(u, v);\n            w = -w;\n        }\n\n        if (_rank[u] == _rank[v]) {\n            _rank[u]++;\n        }\n\n        _parent[v] = u;\n        _diff[v] = w;\n\n        return true;\n    }\n}\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "# see: https://twitter.com/maspy_stars/status/1179226257982185472\nimport sys\ninput = sys.stdin.buffer.readline\n\n\nclass WeightedUnionFindTree:\n    \"\"\"Disjoint-Set Data Structure with weight\n\n    complexity:\n        - init: O(n)\n        - find, unite, same: O(alpha(n))\n    \"\"\"\n\n    def __init__(self, n_nodes):\n        self.par = [i for i in range(n_nodes)]  # parent\n        self.rank = [0] * n_nodes  # depth of tree\n        self.weights = [0] * n_nodes\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        root = self.find(self.par[x])\n        self.weights[x] += self.weights[self.par[x]]\n        self.par[x] = root\n        return root\n\n    def unite(self, x, y, weight=0):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x == root_y:\n            return\n        if self.rank[root_x] < self.rank[root_y]:\n            self.par[root_x] = root_y\n            self.weights[root_x] = weight - self.weights[x] + self.weights[y]\n        else:\n            self.par[root_y] = root_x\n            self.weights[root_y] = -weight - self.weights[y] + self.weights[x]\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weights[x] - self.weights[y]\n\n\ndef aoj():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_1_B\n    N, Q = map(int, input().split())\n    uft = WeightedUnionFindTree(N)\n    ans = []\n    for _ in range(Q):\n        type_, u, v, *weight = map(int, input().split())\n        if type_ == 0:\n            uft.unite(u, v, weight[0])\n        else:\n            ans.append(uft.diff(u, v) if uft.is_same(u, v) else '?')\n    print('\\n'.join(map(str, ans)))\n\n\nif __name__ == '__main__':\n    aoj()\n\n"
  },
  {
    "language": "Python",
    "code": "\nn, q = map(int, input().split())\n\np = [i for i in range(n)]\nrank = [0 for i in range(n)]\ndiff_weight = [0 for i in range(n)]\n\n\ndef link(x, y, z):\n if rank[x] > rank[y]:\n  p[y] = x\n  diff_weight[y] = z\n else:\n  p[x] = y\n  diff_weight[x] = -z\n  if rank[x] == rank[y]:\n   rank[y] = rank[y] + 1\n\ndef findSet(x):\n if x != p[x]:\n  p[x] = findSet(p[x])\n  diff_weight[x] += diff_weight[p[x]]\n return p[x]\n\n\ndef relate(x, y, z):\n rootx = findSet(x)\n rooty = findSet(y)\n z += diff_weight[x]\n z -= diff_weight[y]\n if rootx != rooty:\n  link(rootx, rooty, z)\n\n\ndef same(x, y):\n x = findSet(x)\n y = findSet(y)\n\n if x == y:\n  return 1\n else :\n  return 0\n\ndef weight(x):\n findSet(x)\n return diff_weight[x]\n\ndef diff(x, y):\n if same(x, y) != 1:\n  return '?'\n else :\n  return diff_weight[y] - diff_weight[x]\n\n\noutput = []\n\nfor i in range(q):\n line = list(map(int, input().split()))\n\n if line[0] == 0:\n  relate(line[1], line[2], line[3])\n\n else :\n  output.append(diff(line[1],line[2]))\n  print(diff(line[1],line[2]))\n\n\nfor ans in output:\n print(ans)\n"
  },
  {
    "language": "Python",
    "code": "n, q = map(int, input().split())\n\nnodes = [x for x in range(n)]\nweight = [0 for x in range(n)]\n\ndef unite(x, y, w) :   \n    if nodes[x] < nodes[y] :\n        nodes[y] = x\n        weight[y] = w\n    else :\n        nodes[x] = y\n        weight[x] = -w\n        \ndef get_root(idx) :\n    if nodes[idx] == idx :\n        return idx\n    else :\n        r = get_root(nodes[idx])\n        weight[idx] += weight[nodes[idx]]\n        nodes[idx] = r\n        return r\n\nfor i in range(q) :\n    ip = input()\n    \n    # union\n    if ip[0] == \"0\" :\n        q, a, b, w = map(int, ip.split())\n        unite(a, b, w)\n        \n    # evaluate\n    else :\n        q, a, b = map(int, ip.split())\n        \n        if get_root(a) == get_root(b) :\n            print(weight[b] - weight[a])\n        else :\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#1:set\n#1_A\n\"\"\"\nn,q = map(int, input().split(\" \"))\ngroup = [[i] for i in range(n)]\nkey = [i for i in range(n)]\nfor i in range(q):\n    com, x, y = map(int, input().split(\" \"))\n    if com == 0:\n        if key[x] != key[y]:\n            v = key[y]\n            group[key[x]] = group[key[x]] + group[key[y]]\n            for j in group[v]:\n                key[j] = key[x]\n            group[v] = []\n    if com == 1:\n        if key[x] == key[y]:\n            print(1)\n        else:\n            print(0)\n\"\"\"\n\n#1_B 重み付きunionfind\ndef root(x):\n    if par[x] == x:\n        return x\n    r = root(par[x])\n    w[x] += w[par[x]]\n    par[x] = r\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y,z):\n    z += w[x]-w[y]\n    x = root(x)\n    y = root(y)\n    if rank[x] < rank[y]:\n        par[x] = y\n        w[x] = -z\n    else:\n        par[y] = x\n        w[y] = z\n        if rank[x] == rank[y]:\n            rank[x] += 1\nn,Q = LI()\npar = [i for i in range(n)]\nrank = [0 for i in range(n)]\nw = [0 for i in range(n)]\nfor _ in range(Q):\n    q = LI()\n    if q[0]:\n        x,y = q[1],q[2]\n        if same(x,y):\n            print(w[y]-w[x])\n        else:\n            print(\"?\")\n    else:\n        x,y,z = q[1:]\n        if not same(x,y):\n            unite(x,y,z)\n#2:range quary\n#2_A rmq\n\"\"\"\ndef rmq(a,b,k,l,r):\n    if r <= a or b <= l:\n        return inf\n    if a <= l and r <= b:\n        return st[k]\n    vl = rmq(a,b,2*k+1,l,(l+r)//2)\n    vr = rmq(a,b,2*k+2,(l+r)//2,r)\n    return min(vl,vr)\n\nn,Q = LI()\nn1 = 1\nwhile n1 <= n:\n    n1 *= 2\nn = n1\ninf = pow(2,31)-1\nst = [inf for i in range(2*n-1)]\nfor _ in range(Q):\n    q = LI()\n    if not q[0]:\n        x,y = q[1:]\n        i = n+x-1\n        st[i] = y\n        while i > 0:\n            i = (i-1)//2\n            st[i] = min(st[2*i+1],st[2*i+2])\n    else:\n        a,b = q[1:]\n        print(rmq(a,b+1,0,0,n))\n\"\"\"\n\n#2_B rsq\n\"\"\"\ndef rsq(a,b,k,l,r):\n    if r <= a or b <= l:\n        return 0\n        if a <= l and r <= b:\n            return st[k]\n            vl = rsq(a,b,2*k+1,l,(l+r)//2)\n            vr = rsq(a,b,2*k+2,(l+r)//2,r)\n            return vl+vr\n\n            n,Q = LI()\n            n1 = 1\n            while n1 <= n:\n                n1 *= 2\n                n = n1\n                st = [0 for i in range(2*n-1)]\n                for _ in range(Q):\n                    q = LI()\n                    if not q[0]:\n                        x,y = q[1:]\n                        i = n+x-1\n                        st[i] += y\n                        while i > 0:\n                            i = (i-1)//2\n                            st[i] += y\n                        else:\n                            a,b = q[1:]\n                            print(rsq(a,b+1,0,0,n))\n\"\"\"\n#2_C\n\n#2_D\n\"\"\"\ndef ruq(a,b,k,l,r,z):\n    if r <= a or b <= l:\n        return\n    if a <= l and r <= b:\n        st[k] = z\n        return\n    vl = ruq(a,b,2*k+1,l,(l+r)//2,z)\n    vr = ruq(a,b,2*k+2,(l+r)//2,r,z)\n    return\n\nn,Q = LI()\nn1 = 1\nwhile n1 <= n:\n    n1 *= 2\nn = n1\nd = pow(2,31)-1\nst = [d for i in range(2*n-1)]\nfor _ in range(Q):\n    q = LI()\n    if not q[0]:\n        x,y,z = q[1:]\n        ruq(x,y+1,0,0,n,z)\n    else:\n\"\"\"\n#2_E\n\n#2_F\n\n#2_G\n\n#2_H\n\n#2_I\n\n\n#3:sliding window\n#3_A\n\"\"\"\nn,s = MI()\na = LI()\nfor i in range(1,n):\n    a[i] += a[i-1]\na.insert(0,0)\nl = 0\nr = 0\nans = float(\"inf\")\nif a[1] >= s:\n    print(1)\n    quit()\nwhile r < n:\n    r += 1\n    if a[r]-a[l] >= s:\n        while a[r]-a[l] >= s and l < r:\n            l += 1\n        ans = min(ans, r-l+1)\nif ans == float(\"inf\"):\n    print(0)\n    quit()\nprint(ans)\n\"\"\"\n\n#3_B\n\"\"\"\nn,k = MI()\na = LI()\nl = 0\nr = 0\nans = float(\"inf\")\nfl = [0 for i in range(k+1)]\ns = 0\nif k == 1 and a[0] == 1:\n    print(1)\n    quit()\nif a[0] <= k:\n    fl[a[0]] = 1\n    s = 1\nwhile r < n-1:\n    r += 1\n    if a[r] <= k:\n        if not fl[a[r]]:\n            s += 1\n        fl[a[r]] += 1\n    if s == k:\n        while s == k:\n            l += 1\n            if a[l-1] <= k:\n                if fl[a[l-1]] == 1:\n                    s -= 1\n                fl[a[l-1]] -= 1\n        ans = min(ans, r-l+2)\nif ans == float(\"inf\"):\n    print(0)\n    quit()\nprint(ans)\n\"\"\"\n\n#3_C\n\"\"\"\nn,q = LI()\na = LI()\nx = LI()\nfor i in range(q):\n    ans = 0\n    r = -1\n    s = 0\n    for l in range(n):\n        while r+1 < n and s+a[r+1] <= x[i]:\n            r += 1\n            s += a[r]\n        if s <= x[i]:\n            ans += r-l+1\n        if l == r:\n            r += 1\n            if r < n:\n                s += a[r]\n        s -= a[l]\n    print(ans)\n\"\"\"\n\n\n#3_D\n\"\"\"\nn,l = LI()\na = LI()\nk = [0 for i in range(l)]\nfor i in range(l):\n    k[i] = a[i]\nk.sort()\nans = [k[0]]\nfor i in range(n-l):\n    j = bisect.bisect_left(k,a[i])\n    x = k.pop(j)\n    j = bisect.bisect_left(k,a[l+i])\n    k.insert(j,a[l+i])\n    ans.append(k[0])\nfor i in range(len(ans)-1):\n    print(ans[i],end = \" \")\nprint(ans[-1])\n\"\"\"\n\n#4:coordinate compression\n#4_A\n\"\"\"\nn = int(sys.stdin.readline())\nd = defaultdict(int)\nlx = []\nly = []\nfor i in range(n):\n    x,y,s,t = map(int,sys.stdin.readline()[:-1].split())\n    d[(x,y)] += 1\n    d[(x,t)] -= 1\n    d[(s,y)] -= 1\n    d[(s,t)] += 1\n    i = bisect.bisect_left(lx,x)\n    if i >= len(lx) or lx[i] != x:\n        lx.insert(i,x)\n    i = bisect.bisect_left(ly,y)\n    if i >= len(ly) or ly[i] != y:\n        ly.insert(i,y)\n    i = bisect.bisect_left(lx,s)\n    if i >= len(lx) or lx[i] != s:\n        lx.insert(i,s)\n    i = bisect.bisect_left(ly,t)\n    if i >= len(ly) or ly[i] != t:\n        ly.insert(i,t)\n\nfor x in lx:\n    for j in range((len(ly))-1):\n        d[(x,ly[j+1])] += d[(x,ly[j])]\nfor y in ly:\n    for i in range((len(lx))-1):\n        d[(lx[i+1],y)] += d[(lx[i],y)]\nans = 0\nfor j in range(len(ly)-1):\n    y = ly[j]\n    p_y = ly[j+1]\n    for i in range(len(lx)-1):\n        x = lx[i]\n        p_x = lx[i+1]\n        if d[(x,y)] >= 1:\n            ans += (p_y-y)*(p_x-x)\nprint(ans)\n\"\"\"\n#5:comulative sum\n#5_A\n\"\"\"\nn,t = map(int, input().split(\" \"))\nnum = [0 for i in range(t)]\nfor i in range(n):\n    l,r = map(int, input().split(\" \"))\n    num[l] += 1\n    if r < t:\n        num[r] -= 1\nfor i in range(1,t):\n    num[i] += num[i-1]\nprint(max(num))\n\"\"\"\n\n#5_B\n\"\"\"\nn = int(input())\nlec = [[0 for i in range(1001)] for j in range(1001)]\nmax_x = 0\nmax_y = 0\nfor i in range(n):\n    x,y,s,t = map(int, input().split(\" \"))\n    lec[y][x] += 1\n    lec[y][s] -= 1\n    lec[t][x] -= 1\n    lec[t][s] += 1\n    max_x = max(max_x, s)\n    max_y = max(max_y, t)\n\nfor i in range(max_y+1):\n    for j in range(1, max_x+1):\n        lec[i][j] += lec[i][j-1]\n\nfor i in range(1, max_y+1):\n    for j in range(max_x+1):\n        lec[i][j] += lec[i-1][j]\n\nans = 0\nfor i in range(max_y+1):\n    for j in range(max_x+1):\n        ans = max(ans, lec[i][j])\n\nprint(ans)\n\"\"\"\n\n"
  },
  {
    "language": "Python",
    "code": "MAX = 10003 \nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(N)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return False\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==False:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    if(z > wx):\n        z = z - wx+wy\n    else:\n        z = wx-wy - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "idx_com = 0\nidx_x = 1\nidx_y = 2\nidx_z = 3\n\nn, nq = map(int, input().split())\nparents = list(range(n))\nranks = [0] * n\nweights = [0] * n\n\ndef find(x):\n    if parents[x] == x:\n        return x\n    y = find(parents[x])\n    weights[x] += weights[parents[x]]\n    parents[x] = y\n    return y\n\ndef unite(x, y, w):\n    root_x = find(x)\n    root_y = find(y)\n\n    if ranks[root_x] < ranks[root_y]:\n        parents[root_x] = root_y\n        weights[root_x] = -w - weights[x] + weights[y]\n    else:\n        parents[root_y] = root_x\n        weights[root_y] = +w - weights[y] + weights[x]\n        if ranks[root_x] == ranks[root_y]:\n            ranks[root_x] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weights[y] - weights[x]\n\nfor _ in range(nq):\n    q = list(map(int, input().split()))\n    if q[idx_com] == 0:\n        unite(q[idx_x], q[idx_y], q[idx_z])\n    else:\n        if same(q[idx_x], q[idx_y]):\n            print(diff(q[idx_x], q[idx_y]))\n        else:\n            print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFindTree:\n\n    def __init__(self, n_nodes):\n        super().__init__()\n        self.par = [i for i in range(n_nodes)]\n        self.rank = [0] * n_nodes\n        self.weights = [0] * n_nodes\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        root = self.find(self.par[x])\n        self.weights[x] += self.weights[self.par[x]]\n        self.par[x] = root\n        return root\n\n    def unite(self, x, y, weight=0):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x == root_y:\n            return\n        if self.rank[root_x] < self.rank[root_y]:\n            self.par[root_x] = root_y\n            self.weights[root_x] = weight - self.weights[x] + self.weights[y]\n        else:\n            self.par[root_y] = root_x\n            self.weights[root_y] = - \\\n                (weight - self.weights[x] + self.weights[y])\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weights[x] - self.weights[y]\n\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    uft = WeightedUnionFindTree(N)\n    ans = []\n    for _ in range(Q):\n        type_, u, v, *weight = map(int, input().split())\n        if type_ == 0:\n            uft.unite(u, v, weight[0])\n        else:\n            ans.append(uft.diff(u, v) if uft.is_same(u, v) else '?')\n    for a in ans:\n        print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    n,q = [int(i) for i in input().split()]\n    par = [ i for i in range(n)]\n    diff_weight = [ 0 for i in range(n)]\n    rank = [ 0 for i in range(n)]\n    def diff(x,y):\n        return weight(y)-weight(x)\n\n    def weight(x):\n        root(x)\n        return diff_weight[x]\n\n    def root(x):\n        if par[x] == x:\n            return x\n        else:\n            diff_weight[x] += diff_weight[par[x]]\n            par[x] = root(par[x])\n            return par[x]\n\n    def merge(x,y,w):\n        w += weight(x)\n        w -= weight(y)\n        x = root(x)\n        y = root(y)\n        if x == y:\n            return False\n        if rank[x]<rank[y]:\n            tmp = x\n            x = y\n            y = tmp\n            w = -w\n        if rank[x] == rank[y]:\n            rank[x] += 1\n        par[y] = x\n        diff_weight[y] = w\n        return True\n\n    for i in range(q):\n        s = [int(j) for j in input().split()]\n        if s[0] == 0:\n            merge(s[1],s[2],s[3])\n        else:\n            if root(s[1]) == root(s[2]):\n                print(diff(s[1],s[2]))\n            else:\n                print('?')\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys \ninput = sys.stdin.readline\n\n\nclass UnionFindWeighted:\n    \"\"\"ポテンシャル付きUnionFind\"\"\"\n    def __init__(self, n):\n        self.parent = [-1] * n\n        self.weight = [0] * n\n        self.cnt = n\n        self.INF = 10 ** 18\n       \n    def root(self, x):\n        \"\"\"頂点xの根を求める\"\"\"\n        if self.parent[x] < 0:\n            return x\n        rt = self.root(self.parent[x])\n        self.weight[x] += self.weight[self.parent[x]]\n        self.parent[x] = rt\n        return rt\n\n    def merge(self, x, y, weight):\n        \"\"\"頂点xを含む集合と頂点y含む集合を結合する\n        weight: 頂点yに対する頂点xのポテンシャル(頂点xの方がweight高い)\n        \"\"\"\n        root_x = self.root(x)\n        root_y = self.root(y)\n        if root_x == root_y:\n            return\n        if self.parent[root_x] < self.parent[root_y]:\n            self.parent[root_x] += self.parent[root_y]\n            self.parent[root_y] = root_x\n            self.weight[root_y] = -weight + self.weight[x] - self.weight[y]\n        else:\n            self.parent[root_y] += self.parent[root_x]\n            self.parent[root_x] = root_y\n            self.weight[root_x] = weight - self.weight[x] + self.weight[y]\n        self.cnt -= 1\n\n    def is_same(self, x, y):\n        \"\"\"頂点x, yが同じ集合に属するかどうかを返す\"\"\"\n        return self.root(x) == self.root(y)\n\n    def diff(self, x, y):\n        \"\"\"頂点yに対する頂点xのポテンシャルを求める\n        ただし、頂点x,y間にポテンシャルが定義されていない場合は INF を返す\n        \"\"\"\n        if not self.is_same(x, y):\n            return self.INF\n        return self.weight[x] - self.weight[y]\n\n    def get_size(self, x):\n        \"\"\"頂点xを含む集合の要素数を返す\"\"\"\n        return -self.parent[self.root(x)]\n\n    def get_cnt(self):\n        \"\"\"集合の個数を返す\"\"\"\n        return self.cnt\n\n\ndef solve():\n    n, q = list(map(int, input().split()))\n    query = [list(map(int, input().split())) for i in range(q)]\n    INF = 10 ** 18\n    ufw = UnionFindWeighted(n)\n\n    for i in range(q):\n        if query[i][0] == 0:\n            # クエリ1の場合\n            _, x, y, weight = query[i]\n            ufw.merge(x, y, weight)\n        else:\n            # クエリ2の場合\n            _, x, y = query[i]\n            ans = ufw.diff(x, y)\n            if ans == INF:\n                print(\"?\")\n            else:\n                print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "rank = []\np = []\nw = []\n\ndef makeSet(x):\n    p.append(x)\n    rank.append(0)\n    w.append(0)\n\n\ndef union(x, y):\n    link(findSet(x), findSet(y))\n\n\ndef link(x, y):\n    if rank[x] > rank[y]:\n        p[y] = x\n\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] = rank[y] + 1\n\n\ndef findSet(x):\n    if p[x] == x:\n        return x\n\n    i = findSet(p[x])\n    w[x] += w[p[x]]\n    p[x] = i\n    return i\n\n\ndef same(x, y):\n    return findSet(x) == findSet(y)\n\ndef relate (x,y,z):\n    i = findSet(x)\n    j = findSet(y)\n\n    if rank[i] < rank[j]:\n        p[i] = j\n        w[i] = z - w[x] + w[y]\n    else:\n        p[j] = i\n        w[j] = -z - w[y] + w[x]\n        if rank[i] == rank[j]:\n            rank[i] += 1\n\nn, q = map(int, input().split())\nfor i in range(n):\n    makeSet(i)\nfor i in range(q):\n    com, *cmd = map(int, input().split())\n    if com == 0:\n        relate(cmd[0], cmd[1],cmd[2])\n    else:\n        x, y = cmd\n        if same(x, y):\n            print(w[x] - w[y])\n        else:\n            print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "\n\nclass UnionFind():\n\n    def __init__(self, s):\n        self.nodes = [-1 for _ in range(s)]\n        self.rank = [0 for _ in range(s)]\n        self.weight = [0 for _ in range(s)]\n\n    def find(self, x):\n        if self.nodes[x] < 0:\n            return x\n        else:\n            root = self.find(self.nodes[x])\n            self.weight[x] += self.weight[self.nodes[x]]\n            self.nodes[x] = root\n            return root\n\n    def union(self, x, y, z):\n        s_1 = self.find(x)\n        s_2 = self.find(y)\n        if s_1 == s_2:\n            return False\n        if self.rank[s_1] < self.rank[s_2]:\n            self.nodes[s_1] = s_2\n            self.weight[s_1] = z - self.weight[x] + self.weight[y]\n        elif self.rank[s_1] > self.rank[s_2]:\n            self.nodes[s_2] = s_1\n            self.weight[s_2] = self.weight[x] - self.weight[y] - z\n        else:\n            self.nodes[s_2] = s_1\n            self.weight[s_2] = self.weight[x] - self.weight[y] - z\n            self.rank[s_1] += 1\n        return True\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    sets = UnionFind(n)\n    for i in range(q):\n        inputs = [int(i) for i in input().split()]\n        if inputs[0] == 0:\n            sets.union(inputs[1], inputs[2], inputs[3])\n        else:\n            if sets.is_same(inputs[1], inputs[2]):\n                print(sets.diff(inputs[1], inputs[2]))\n            else:\n                print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\n\nn,q= map(int,readline().split())\n\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # 根への距離を管理\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            # 親への重みを追加しながら根まで走査\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # 併合\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # xの木の高さ < yの木の高さ\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # xの木の高さ ≧ yの木の高さ\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # 木の高さが同じだった場合の処理\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # xからyへのコスト\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\nuf = WeightedUnionFind(n)\n\nfor i in range(q):\n    s = readline().rstrip().decode('utf-8')\n    if s[0] == \"0\":\n        com,a,b,w = map(int,s.split())\n    else:\n        com,a,b = map(int,s.split())\n    if com:\n        if uf.same(a,b):\n            print(uf.diff(a,b))\n        else:\n            print(\"?\")\n    else:\n        uf.union(a,b,w)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(1000000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef root(x):\n    if par[x] == x:\n        return x\n    else:\n        r = root(par[x])\n        weight[x] += weight[par[x]]\n        par[x] = r\n        return r\n\ndef union(x,y,w):\n    rx = root(x)\n    ry = root(y)\n    if rank[rx] < rank[ry]:\n        par[rx] = ry\n        weight[rx] = w - weight[x] + weight[y]\n    else:\n        par[ry] = rx\n        weight[ry] = - w - weight[y] + weight[x]\n        if rank[rx] == rank[ry]:\n            rank[rx] += 1\ndef same(x,y):\n    return root(x) == root(y)\n\ndef diff(x,y):\n    return weight[x] - weight[y]\n\nn,q = LI()\npar = [i for i in range(n)]\nweight = [0]*n\nrank = [0]*n\nfor _ in range(q):\n    lst = LI()\n    if lst[0] == 0:\n        x,y,z = lst[1:4]\n        if not same(x,y):\n            union(x,y,z)\n    else:\n        x,y = lst[1:3]\n        if not same(x,y):\n            print('?')\n        else:\n            print(diff(x,y))\n\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Trees\n[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\npath_c = [[] for i in range(n)]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef union(x, y):\n    link(findSet(x), findSet(y))\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\ndef relate(x, y, z):\n    global w, path_c\n    path_c[x].append((y, z))\n    #print(w)\n    if w[y] == 0:\n        w[y] = w[x] + z\n    else:\n        update(x, y, z)\n        #w[x] = w[y] - z\n    #print(\"cost:\", w[y])\n    union(x, y)\n\ndef update(x, y, z):\n    global w, path_c\n    w[x] = w[y] - z\n    for i in range(len(path_c[x])):\n        update(path_c[x][i][0], x, path_c[x][i][1])\n\n\ndef diff(x, y):\n    if same(x, y) == 1:\n        global w\n        return abs(w[y] - w[x])\n        '''\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n        '''\n    else:\n        return \"?\"     \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(n):\n    makeSet(i)\n\n#w = [0 for i in range(n)]\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2]))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    element[x] = y\n    weight[x] = z - (wx+wy)\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nclass WeightedUnionFind:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.weight = [0] * N\n\n    def find(self, x):\n        stack = [x]\n        while self.parent[x] != x:\n            x = self.parent[x]\n            stack.append(x)\n        r = stack[-1]\n        while stack:\n            x = stack.pop()\n            self.weight[x] += self.weight[self.parent[x]]\n            self.parent[x] = r\n        return r\n\n    def unite(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        w += self.weight[x] - self.weight[y]\n        x = rx\n        y = ry\n        if x == y:\n            return False\n\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n            w = -w\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.parent[y] = x\n        self.weight[y] = w\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        self.find(x)\n        self.find(y)\n        return self.weight[y] - self.weight[x]\n\nn, q = map(int, input().split())\nwuf = WeightedUnionFind(n)\nfor _ in range(q):\n    t, *data = map(int, input().split())\n    if t == 0:\n        x, y, z = data\n        wuf.unite(x, y, z)\n    else:\n        x, y = data\n        if not wuf.same(x, y):\n            print('?')\n        else:\n            print(wuf.diff(x, y))\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # 根への距離を管理\n        self.weight = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            # 親への重みを追加しながら根まで走査\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # 併合\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # xの木の高さ < yの木の高さ\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # xの木の高さ ≧ yの木の高さ\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # 木の高さが同じだった場合の処理\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # 同じ集合に属するか\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # xからyへのコスト\n    def diff(self, x, y):\n        if self.find(x) != self.find(y):\n            return \"?\"\n        return self.weight[x] - self.weight[y]\n\n\nn, q = map(int, input().split())\n\ntree = WeightedUnionFind(n)\n\nfor i in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        x, y, z = query[1:4]\n        tree.union(x, y, z)\n    else:\n        x, y = query[1:3]\n        ans = tree.diff(x, y)\n        print(ans)\n"
  },
  {
    "language": "Python",
    "code": "\ndef union(x, y, t):\n    x, t_x = findSet(x)\n    y, t_y = findSet(y)\n    link(x, t_x, y, t_y, t)\n\n\ndef link(x, d_x, y, d_y, t):\n    #print('', 'x', 'y')\n    #print('', x, y)\n    #print('', d_x, d_y, t)\n    if r[x] > r[y]:\n        p[y] = x\n        d[y] = d_x - d_y - t\n        #print('', y, '->', p[y], '=', d[y], '\\n')\n\n    else:\n        p[x] = y\n        d[x] = d_y - d_x + t\n        if r[x] == r[y]: r[y] = r[y] + 1\n        #print('', x, '->', p[x], '=', d[x], '\\n')\n\n\ndef findSet(x):\n    if x != p[x]:\n        p[x], t = findSet(p[x])\n        d[x] += t\n    return p[x], d[x]\n\n\ndef diff(x, y):\n    x, d_x = findSet(x)\n    y, d_y = findSet(y)\n    if x == y:\n        return d_x - d_y\n\n    else:\n        return '?'\n\n\n\n\nif __name__ == '__main__':\n\n    p, r, d = [], [], []\n\n    n_set, n_quare = map(int, input().split())\n\n    for i in range(n_set):\n        p.append(i)\n        r.append(0)\n        d.append(0)\n\n\n    for i in range(n_quare):\n        l = input().split()\n\n        if len(l) == 4:\n            _, x, y, t = map(int, l)\n            union(x, y, t)\n\n        else:\n            _, x, y = map(int, l)\n            print(diff(x, y))\n\n"
  },
  {
    "language": "Python",
    "code": "\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [i for i in range(n)]\n        self.weights = [0 for _ in range(n)]\n\n    def connected(self, i, j):\n        ri = self.root(i)\n        rj = self.root(j)\n        return ri == rj\n\n    def union(self, i, j, w):\n        ri = self.root(i)\n        rj = self.root(j)\n        if ri != rj:\n            assert self.weights[ri] == 0\n            assert self.weights[rj] == 0\n            wi = self.weight(i, ri)\n            wj = self.weight(j, rj)\n            self.nodes[ri] = rj\n            self.weights[ri] = wj - wi + w\n        else:\n            assert self.weight(i, ri) - self.weight(j, ri) == w\n\n    def weight(self, i, j):\n        ri = self.root(i)\n        rj = self.root(j)\n        if ri != rj:\n            raise ValueError('{} and {} is not connected'.format(i, j))\n        wi, wj = 0, 0\n        while i != ri:\n            wi += self.weights[i]\n            i = self.nodes[i]\n        while j != rj:\n            wj += self.weights[j]\n            j = self.nodes[j]\n\n        return wi - wj\n\n    def root(self, i):\n        ri = self.nodes[i]\n        while ri != self.nodes[ri]:\n            ri = self.nodes[ri]\n        return ri\n\n\ndef run():\n    n, q = [int(i) for i in input().split()]\n    wuf = WeightedUnionFind(n)\n\n    for _ in range(q):\n        com, *args = input().split()\n        if com == '0':\n            wuf.union(*[int(i) for i in args])\n        elif com == '1':\n            x, y = [int(i) for i in args]\n            if wuf.connected(x, y):\n                print(wuf.weight(x, y))\n            else:\n                print('?')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\nimport sys\nsys.setrecursionlimit(1000000000)\niim = lambda: map(int, input().rstrip().split())\n\ndef resolve():\n    N, Q = iim()\n    S = [i for i in range(N)]\n    W = [0] * N\n    R = [0] * N\n\n    def find(x):\n        if S[x] == x:\n            return x\n\n        i = find(S[x])\n        W[x] += W[S[x]]\n        S[x] = i\n        return i\n\n    def relate(x, y, w):\n        i = find(x)\n        j = find(y)\n\n        if R[i] < R[j]:\n            S[i] = j\n            W[i] = w - W[x] + W[y]\n        else:\n            S[j] = i\n            W[j] = -w - W[y] + W[x]\n            if R[i] == R[j]:\n                R[i] += 1\n\n    def diff(x, y):\n        i = find(x)\n        j = find(y)\n\n        if i != j: return \"?\"\n\n        return W[x] - W[y]\n\n    ans = []\n    for com, *xyz in (map(int, s.split()) for s in sys.stdin):\n        if com == 0:\n            relate(*xyz)\n        else:\n            ans.append(diff(*xyz))\n    print(*ans, sep=\"\\n\")\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y = simplefindset(y,element)\n    link(x,wx,y,w,element)\n\ndef link(x,wx,y,z,element):\n    if(z > wx):\n        z = z - wx\n    else:\n        z = wx - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "N = 100\nweight_to_root = [ 0 for i in range(N)]\nrank = [ 0 for i in range(N) ]\npar = [ i for i in range(N)]\n\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        root = find(par[x])\n        weight_to_root[x] += weight_to_root[par[x]]\n        return root\n\ndef union(x,y,w):\n    a = find(x)\n    b = find(y)\n    if a == b:\n        return\n    w -= weight_to_root[x]\n    w += weight_to_root[y]\n    if rank[a]>rank[b]:\n        weight_to_root[a]=w\n        par[a]=b\n    elif rank[b]<rank[a]:\n        weight_to_root[b]=-w\n        par[b]=a\n    else:\n        rank[b] += 1\n        par[a] = b\n        weight_to_root[a]=w\n\ndef diff(x,y):\n    a=find(x)\n    b=find(y)\n    if a!=b:\n        return \"?\"\n    return weight_to_root[x]-weight_to_root[y]\n\ndef is_same(x,y):\n    return find(x) == find(y)\n\ndef main():\n    global weight_to_root,par,rank\n    n,q = [int(i) for i in input().split()]\n    weight_to_root = [ 0 for i in range(n)]\n    par = [ i for i in range(n)]\n    rank = [0 for i in range(n)]\n\n    for i in range(q):\n        s = [int(j) for j in input().split()]\n        if s[0] == 0:\n            union(s[1],s[2],s[3])\n        else:\n            print(diff(s[1],s[2]))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n        sumW += weight[x]\n    else:\n        resultPos = x\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findset(x,element,weight)\n        y,wy = findset(y,element,weight)\n        if(x == y):\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(50000)\n\ndef findset(x,element,weight):\n    if(x != element[x]):\n        element[x],s = findset(element[x],element,weight)\n        weight[x] += s\n    return element[x],weight[x]\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findset(x,element,weight)\n        y,wy = findset(y,element,weight)\n        if(x == y):\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\nsys.setrecursionlimit(20000)\n\ndef find(tree,x):\n    (idx,weight) = tree[x]\n    if(idx== -1):\n        return x\n    else:\n        root_idx = find(tree,idx)\n        tree[x] = (root_idx, tree[x][1] + tree[idx][1])\n        return root_idx\n\ndef relate(tree,x,y,z):\n    x_root_idx = find(tree,x)\n    y_root_idx = find(tree,y)\n    if(x_root_idx == y_root_idx):\n        return False\n    \n    if (tree_rank[y_root_idx] < tree_rank[x_root_idx]):\n        tree[y_root_idx] = (x_root_idx, z+tree[x][1]-tree[y][1])\n    else:\n        tree[x_root_idx] = (y_root_idx, -z-tree[x][1]+tree[y][1])\n        if(tree_rank[x_root_idx]==tree_rank[y_root_idx]):\n            tree_rank[y_root_idx] = tree_rank[y_root_idx] + 1\n    #tree[x_root_idx] = (y_root_idx,z-tree[x_root_idx][1]+tree[y_root_idx][1])\n\ndef diff(tree,x,y):\n    x_idx = find(tree,x)\n    y_idx = find(tree,y)\n    if not(x_idx == y_idx):\n        return \"?\"\n    return tree[y][1] - tree[x][1]\n\nif __name__ == '__main__':\n    N,query_num = map(int, input().split())\n    weighted_union_find_tree = [(-1,0) for _ in range(N)]\n    tree_rank = [0]*N\n    for i in range(query_num):\n        query = list(map(int,input().split()))\n        if(query[0]==0):\n            relate(weighted_union_find_tree,query[1],query[2],query[3])\n            #print(weighted_union_find_tree)\n            #print(tree_rank)\n        elif(query[0]==1):\n            res = diff(weighted_union_find_tree,query[1],query[2])\n            print(res)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind():\n    def __init__(self,n):\n        self.n = n\n        self.parents = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.weight = [0 for _ in range(n)]\n    def find(self,x):\n        root = x\n        stack = [root]\n        while self.parents[root] != root:\n            root = self.parents[root]\n            stack.append(root)\n        while stack:\n            s = stack.pop()\n            self.weight[s] += self.weight[self.parents[s]]\n        while self.parents[x] != root:\n            parent = self.parents[x]\n            self.parents[x] = root\n            x = parent\n        return root\n    def unite(self,x,y,w):\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if xroot == yroot:\n            return\n        xrank = self.rank[xroot]\n        yrank = self.rank[yroot]\n        if xrank < yrank:\n            self.parents[xroot] = yroot\n            self.weight[xroot] = w-self.weight[x]+self.weight[y]\n        else:\n            self.parents[yroot] = xroot\n            self.weight[yroot] = -w+self.weight[x]-self.weight[y]\n            if xrank == yrank:\n                self.rank[xroot] += 1\n\n    def diff(self,x,y):\n        return self.weight[x]-self.weight[y]\n\nN,Q = map(int,input().split())\nuf = WeightedUnionFind(N)\nans = []\n\nfor _ in range(Q):\n    q = list(map(int,input().split()))\n    if q[0] == 0:\n        uf.unite(q[1],q[2],q[3])\n    else:\n        if uf.find(q[1]) == uf.find(q[2]):\n            ans.append(uf.diff(q[1],q[2]))\n        else:\n            ans.append('?')\n\nprint('\\n'.join(map(str,ans)))\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFindTree():\n    '''ランク付きUnionFind木'''\n    def __init__(self, n):\n        ''' 初期化 '''\n        self.par = list(range(n))#自分自信を根とする\n        self.rank = [0] * n # 木の高さ 最初は0\n        self.w = [0] * n # 重み\n\n    def root(self, x):\n        ''' 木の根を求める '''\n        if self.par[x] == x:#自分が根ノードなら\n            return x\n\n        root = self.root(self.par[x])\n        self.w[x] += self.w[self.par[x]]# 累積和をとる\n        self.par[x] = root\n        return root\n    def relate(self, x, y, weight=0):\n        # x と y の root へ (x と y が既につながっていたらreturn\n        root_x, root_y = self.root(x), self.root(y)\n        if root_x == root_y: return;\n        #木の高さ-ランクが低い方に繋げる\n        if self.rank[root_x] < self.rank[root_y]:\n            self.par[root_x] = root_y # 低いroot_xにroot_yを繋げ、低い方が根なのでひく\n            self.w[root_x] = weight - self.w[x] + self.w[y]\n        else:\n            self.par[root_y] = root_x # 逆\n            self.w[root_y] = -weight + self.w[x] - self.w[y]\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_x] += 1\n\n    def same(self, x, y):\n        #xとyが同じ集合に属するか\n        return self.root(x) == self.root(y)\n\n    def diff(self, x, y):\n        if self.same(x, y):\n            return self.w[x] - self.w[y]\n        else:\n            return \"?\"\n\ndef querying(queries, uft):\n    for query in queries:\n        if query[0] == 0:#unite\n            uft.relate(query[1], query[2], query[3])\n        else:\n            print(uft.diff(query[1], query[2]))\n\nif __name__ == '__main__':\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_1_B\n    n, q = map(int, input().split())\n    queries = [list(map(int, input().split())) for i in range(q)]\n    uft = WeightedUnionFindTree(n)#instant UnionFindTree\n    querying(queries, uft)#Querying\n\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind:\n    def __init__(self, N):\n        # negative value: represents the root of a tree; its absolute value is the size of the tree\n        # positive value: the parent's index\n        self.vertices = [-1 for _ in range(N)]\n        self.rank = [0] * N\n        self.diff_weight = [0] * N\n    \n    def weight(self, v):\n        self.find(v) # path compression\n        return self.diff_weight[v]\n    \n    def dist(self, u, v):\n        if self.is_connected(x, y):\n            return self.weight(v) - self.weight(u)\n        else:\n            return None\n    \n    def find(self, v):\n        if self.vertices[v] < 0:\n            return v\n        else:\n            # path compression: reconnect v to the root\n            root = self.find(self.vertices[v])\n            self.diff_weight[v] += self.diff_weight[self.vertices[v]]\n            self.vertices[v] = root\n            return self.vertices[v]\n    \n    def union(self, u, v, w):\n        s1 = self.find(u) # the root of the tree including vertex u\n        s2 = self.find(v) # the root of the tree including vertex v\n        \n        if s1 == s2: # u and v is in the same tree\n            return False\n        \n        if self.rank[s1] > self.rank[s2]: # the tree including u is taller\n            self.vertices[s1] += self.vertices[s2] # update the size of the bigger tree\n            self.vertices[s2] = s1\n            self.diff_weight[s2] = w - self.diff_weight[v] + self.diff_weight[u]\n        else: # the tree including v is taller\n            self.vertices[s2] += self.vertices[s1] # update the size of the bigger tree\n            self.vertices[s1] = s2\n            self.diff_weight[s1] = -w - self.diff_weight[u] + self.diff_weight[v]\n            if self.rank[s1] == self.rank[s2]:\n                self.rank[s2] += 1\n        return True\n        \n    def is_connected(self, u, v):\n        return self.find(u) == self.find(v)\n    \n    def size(self, v):\n        return -self.vertices[self.find(v)]\n    \nn, q = map(int, input().split())\nwuf = WeightedUnionFind(n)\nfor _ in range(q):\n    txt = input().split()\n    if txt[0] == '0':\n        x, y, z = map(int, txt[1:])\n        wuf.union(x, y, z)\n    else:\n        x, y = map(int, txt[1:])\n        res = wuf.dist(x, y)\n        if res is not None:\n            print(res)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100000\nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(MAX)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return False\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==False:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "\nn, q = map(int, input().split())\n\np = [i for i in range(n)]\nrank = [0 for i in range(n)]\ndiff_weight = [0 for i in range(n)]\n\n\ndef link(x, y, z):\n if rank[x] > rank[y]:\n  p[y] = x\n  diff_weight[y] = z\n else:\n  p[x] = y\n  diff_weight[x] = -z\n  if rank[x] == rank[y]:\n   rank[y] = rank[y] + 1\n\ndef findSet(x):\n if x != p[x]:\n  parent = p[x]\n  p[x] = findSet(p[x])\n  diff_weight[x] += diff_weight[parent]\n return p[x]\n\n\ndef relate(x, y, z):\n rootx = findSet(x)\n rooty = findSet(y)\n z += diff_weight[x]\n z -= diff_weight[y]\n if rootx != rooty:\n  link(rootx, rooty, z)\n\n\ndef same(x, y):\n x = findSet(x)\n y = findSet(y)\n\n if x == y:\n  return 1\n else :\n  return 0\n\ndef weight(x):\n findSet(x)\n return diff_weight[x]\n\ndef diff(x, y):\n if same(x, y) != 1:\n  return '?'\n else :\n  return diff_weight[y] - diff_weight[x]\n\n\noutput = []\n\nfor i in range(q):\n #print(p)\n #print(rank)\n #print(diff_weight)\n line = list(map(int, input().split()))\n\n if line[0] == 0:\n  relate(line[1], line[2], line[3])\n\n else :\n  output.append(diff(line[1],line[2]))\n  #print(diff(line[1],line[2]))\n\n\nfor ans in output:\n print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, Q = map(int, readline().split())\n*p, = range(N)\ndata = [0]*N\ndef root(x):\n    if x == p[x]:\n        return x\n    r = p[x]\n    p[x] = y = root(r)\n    data[x] += data[r]\n\n    return y\ndef unite(x, y, z):\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    if px < py:\n        p[py] = px\n        data[py] = data[x] - data[y] - z\n    else:\n        p[px] = py\n        data[px] = data[y] - data[x] + z\n    return 1\n\n\nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        x, y = cmd\n        px = root(x); py = root(y)\n        if px == py:\n            ans.append(str(data[x] - data[y]))\n        else:\n            ans.append(\"?\")\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_A\n\n\nclass WeightedUnionFind:\n    \"\"\"\n    重み付きUnionFind\n\n    \"\"\"\n    root_position = 0\n\n    def __init__(self, size: int):\n        self.size = size\n        # 負の値はルート (集合の代表) で集合の個数\n        # 正の値は次の要素を表す\n        self.parent = [-1] * size\n        self.weight = [WeightedUnionFind.root_position] * size\n\n    def find(self, x: int) -> (int, int):\n        \"\"\"\n        xを含む集合の代表とxの代表からの位置を求める\n        \"\"\"\n        if self.parent[x] < 0:\n            return x, self.weight[x]\n        # 集合の代表にリンクを繋ぎ変える\n        same_group_items = []\n        y = x\n        while self.parent[y] >= 0:\n            same_group_items.append(y)\n            y = self.parent[y]\n        w = 0\n        while same_group_items:\n            child = same_group_items.pop()\n            w += self.weight[child]\n            self.weight[child] = w\n            self.parent[child] = y\n        return y, self.weight[x]\n\n    def unite(self, x: int, y: int, weight: int) -> bool:\n        \"\"\"\n        xを含む集合とyを含む集合を併合する\n        `weight[x] + weight = weight[y]`になるように辺に重みをもたせる。\n        xとyがすでに同じ集合に含まれている場合Falseを返す。\n        \"\"\"\n        root_x, weight_x = self.find(x)\n        root_y, weight_y = self.find(y)\n\n        if root_x == root_y:\n            return False\n\n        if self.parent[root_x] >= self.parent[root_y]:\n            self.parent[root_x] += self.parent[root_y]\n            self.parent[root_y] = root_x\n            self.weight[root_y] = weight_x + weight - weight_y\n        else:\n            self.parent[root_y] += self.parent[root_x]\n            self.parent[root_x] = root_y\n            self.weight[root_x] = weight_y - weight - weight_x\n\n        return True\n\n\ndef solve():\n    n, q = map(int, input().split())\n    uf = WeightedUnionFind(n)\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            _, x, y, z = query\n            uf.unite(x, y, z)\n        else:\n            _, x, y = query\n            root_x, pos_x = uf.find(x)\n            root_y, pos_y = uf.find(y)\n            if root_x == root_y:\n                print(pos_y - pos_x)\n            else:\n                print('?')\n\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# DSL_1_B: Weighted Union Find Trees\n\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [i for i in range(n)]\n        self.weights = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def connected(self, i, j):\n        wi, ri = self.root(i)\n        wj, rj = self.root(j)\n        return ri == rj\n\n    def union(self, i, j, w):\n        wi, ri = self.root(i)\n        wj, rj = self.root(j)\n        if ri == rj:\n            return\n\n        if self.size[ri] < self.size[rj]:\n            self.nodes[ri] = rj\n            self.weights[ri] = wj - wi + w\n            self.size[rj] += self.size[ri]\n        else:\n            self.nodes[rj] = ri\n            self.weights[rj] = wi - wj - w\n            self.size[ri] += self.size[rj]\n\n    def weight(self, i, j):\n        wi, ri = self.root(i)\n        wj, rj = self.root(j)\n        if ri != rj:\n            raise ValueError('{} and {} is not connected'.format(i, j))\n\n        return wi - wj\n\n    def root(self, i):\n        r = self.nodes[i]\n        w = self.weights[i]\n        while r != self.nodes[r]:\n            w += self.weights[r]\n            r = self.nodes[r]\n        return w, r\n\n\ndef run():\n    n, q = [int(i) for i in input().split()]\n    wuf = WeightedUnionFind(n)\n\n    for _ in range(q):\n        com, *args = input().split()\n        if com == '0':\n            wuf.union(*[int(i) for i in args])\n        elif com == '1':\n            x, y = [int(i) for i in args]\n            if wuf.connected(x, y):\n                print(wuf.weight(x, y))\n            else:\n                print('?')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Trees\n[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        pre_parent = p[x]\n        p[x] = findSet(p[x])\n        w[x] += w[pre_parent]\n    return p[x]\n\ndef link(x, y, z):\n    global p, rank, w\n    if rank[x] > rank[y]:\n        p[y] = x\n        w[y] = z\n    else:\n        p[x] = y\n        w[x] = -z\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\ndef relate(x, y, z):\n    global w\n    root_x = findSet(x)\n    root_y = findSet(y)\n    z += w[x]\n    z -= w[y]\n    link(root_x, root_y, z)\n   \ndef diff(x, y):\n    if same(x, y) == 1:\n        global w\n        return w[y] - w[x]\n    else:\n        return \"?\"     \n\nfor i in range(n):\n    makeSet(i)\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2]))\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    \n    def __init__(self, root, length, dist):\n        self.root = root\n        self.child = None\n        self.length = length\n        self.dist = dist\n        self.tail = root\n        \ndef relate(x, y, z):\n    X = A[x].root\n    Y = A[y].root\n    if A[X].length > A[Y].length:\n        x, y, z, X, Y = y, x, -z, Y, X\n    T = A[Y].tail\n    A[T].child = X\n    A[Y].tail = A[X].tail\n    A[Y].length += A[X].length\n    tmp = X\n    xd = A[x].dist\n    yd = A[y].dist\n    for _ in range(A[X].length):\n        A[tmp].root = Y\n        A[tmp].dist += yd - z - xd\n        tmp = A[tmp].child\n    \nn,q = [int(i) for i in input().split()]\nA = []\nfor i in range(n):\n    A.append(Node(i, 1, 0))\nfor _ in range(q):\n    c = [int(i) for i in input().split()]\n    if c[0] == 0 and A[c[1]].root != A[c[2]].root:\n        relate(c[1], c[2], c[3])\n    elif c[0] == 1:\n        if A[c[1]].root == A[c[2]].root:\n            print(A[c[2]].dist - A[c[1]].dist)\n        else:\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    if(z > (wx+wy)):\n        z = z - (wx+wy)\n    else:\n        z = (wx+wy) - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(x,y,wx,wy,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100003 \nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(N)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return False\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==False:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\ninput = sys.stdin.readline\n\ndef diff(node_a, node_b):\n    root_a, cost_a = node_a.root(0)\n    root_b, cost_b = node_b.root(0)\n    if root_a == root_b:\n        return True, cost_a - cost_b\n    else:\n        return False, cost_a - cost_b\n\ndef merge(node_a, node_b, weight):\n    root_a, cost_a = node_a.root(0)\n    root_b, cost_b = node_b.root(0)\n    root_a.weight = weight + cost_b - cost_a\n    root_a.is_root = False\n    root_a.parent = root_b\n\nclass Node:\n    def __init__(self):\n        self.is_root = True\n        self.parent = None\n        self.weight = 0\n    \n    def root(self, cost):\n        if self.is_root:\n            return self, cost\n        root, max_ = self.parent.root(cost + self.weight)\n        self.parent = root\n        self.weight = max_ - cost\n        return root, max_\n\ndef main():\n    n, q = map(int, input().split())\n    \n    nodes = [Node() for i in range(n)]\n\n    for i in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            x, y, z = query[1:]\n            if not diff(nodes[x], nodes[y])[0]:\n                merge(nodes[x], nodes[y], z)\n        else:\n            x, y = query[1:]\n            jud, ans = diff(nodes[x], nodes[y])\n            if jud:\n                print(ans)\n            else:\n                print(\"?\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\ndef findset(x,element,weight):\n    if(x != element[x]):\n        element[x],s = findset(element[x],element,weight)\n        weight[x] += s\n    return element[x],weight[x]\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findset(x,element,weight)\n        y,wy = findset(y,element,weight)\n        if(x == y):\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Tree\n[p, rank, d] = [[], [], []]\nw = {}\n\ndef makeSet(x):\n    global p, rank, w\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef relate(x, y, z):\n    global w\n    w[(x, y)] = z\n    union(x, y)\n\ndef cost(x, y, n, total):\n    global w, d\n    for i in range(n):\n        if ((x, i) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total += w[(x, i)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result + w[(x, i)]\n                return total     \n\n        if ((i, x) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total -= w[(i, x)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result - w[(i, x)]\n                return total\n\ndef diff(x, y, n):\n    if same(x, y) == 1:\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n    else:\n        return \"?\"     \n\ndef union(x, y):\n    link(findSet(x), findSet(y))    \n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\n[n, q] = list(map(int, input().split()))\nfor i in range(n):\n    makeSet(i)\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2], n))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "class WUnionFind:\n    MAX_N = 0\n    PAR  = [] \n    RANK = []\n    DIFF_WEIGHT=[]\n\n    def __init__(self,n):\n        self.MAX_N = n\n        self.PAR = [ i for i in range(n)]\n        self.RANK= [ 0 ] * n\n        self.DIFF_WEIGHT=[ 0 ] * n\n\n    def root(self,x):\n        if self.PAR[x] == x:\n            return x\n        else:\n            r = self.root(self.PAR[x])\n            self.DIFF_WEIGHT[x] += self.DIFF_WEIGHT[self.PAR[x]]\n            self.PAR[x] = r\n            return r\n    \n    def weight(self,x):\n        self.root(x)\n        return self.DIFF_WEIGHT[x]\n\n    def issame(self,x,y):\n        return self.root(x) == self.root(y)\n\n    def diff(self,x,y):\n        return self.weight(y)-self.weight(x)\n\n    def merge(self,x,y,w):\n        w += self.weight(x)\n        w -= self.weight(y)\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.RANK[x] < self.RANK[y]:\n            x,y = y,x\n            w = -w\n        if self.RANK[x] == self.RANK[y]:\n            self.RANK[x] += 1\n\n        self.PAR[y] = x\n        self.DIFF_WEIGHT[y] = w\n        return True\n\n\nN,Q  = map(int,input().split())\nAns = []\ntree = WUnionFind(N+1)\n\nfor _ in range(Q):\n    s = list(map(int,input().split()))\n    if s[0] == 0:\n        x = s[1]\n        y = s[2]\n        w = s[3]\n        tree.merge(x,y,w)\n    else:\n        x = s[1]\n        y = s[2]\n        if tree.issame(x,y):\n            a = tree.diff(x,y)\n        else:\n            a = '?'\n        Ans.append(a)\n\nfor a in Ans:\n    print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\ndef findSet(x):\n  if x == parent[x]:\n    return x\n  else:\n    temp = parent[x]\n    parent[x] = findSet(parent[x])\n    weight[x] += weight[temp]\n    return parent[x]\n  \ndef link(x, y, z):\n  a = findSet(x)\n  b = findSet(y)\n  if a != b:\n    parent[b] = a\n    weight[b] = weight[x] - weight[y] + z\n\nn, q = list(map(int, input().split()))\n\ndata = (i for i in range(n))\nparent = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n  Ltemp = list(map(int, input().split()))\n  if len(Ltemp) == 4:\n    x, y, z = Ltemp[1:]\n    link(x, y, z)\n  else:\n    x, y = Ltemp[1:]\n    if findSet(x) == findSet(y):\n      print(weight[y] - weight[x])\n    else:\n      print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100005\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(MAX*2)]\n\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return 0\n    ans = ws[x] - ws[y]\n    return 1 ,ans\n\n\nif __name__=='__main__':\n   global ans\n   N, Q =  (int(x) for x in  input().split())\n   for q in range(Q):\n        t, *cmd =  (int(x) for x in  input().split())\n        if t:\n            x, y = cmd\n            z = diff(x, y)\n            if z==False :print(\"?\")\n            else :print(z[1])\n        else:\n            x, y, z = cmd\n            unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass WeightedUnionFind:\n    def __init__(self, N:int):\n        \"\"\"N: 大きさ\n        size: 連結成分の大きさ\n        weight: rootからの重み\n        \"\"\"\n        self.par = [i for i in range(N)]\n        #self.size = [1]*N\n        self.rank = [0]*N\n        self.weight = [0]*N\n\n    def root(self, x:int)->int:\n        \"\"\"根を求める\"\"\"\n        if self.par[x] == x: # if root\n            return x\n        else:\n            root_x = self.root(self.par[x]) # 経路圧縮\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = root_x\n            return root_x\n\n    def get_weight(self, x: int)->int:\n        \"\"\"x の重みを取得\"\"\"\n        self.root(x) # 経路圧縮\n        return self.weight[x]\n\n    def get_diff(self, x:int, y:int)->int:\n        \"\"\"x と y の差分を取得\"\"\"\n        if not self.is_same(x, y): return \"?\" # 判定不可\n        return self.get_weight(y) - self.get_weight(x)\n\n    def is_same(self, x:int, y:int)->bool:\n        \"\"\"x と y が同じ集合に属するか否か\"\"\"\n        return self.root(x)==self.root(y)\n\n    def unite(self, x:int, y:int, w:int)->bool:\n        \"\"\"weight[y] = weight[x]+w となるようにmerge(x が y の親)\n        return True if merge 可能\"\"\"\n        if self.is_same(x, y): return False\n        root_x = self.root(x)\n        root_y = self.root(y)\n        w += (self.weight[x] - self.weight[y])\n        if self.rank[root_x] < self.rank[root_y]:\n            self.par[root_x] = root_y\n            self.weight[root_x] = -w\n        else:\n            self.par[root_y] = root_x\n            self.weight[root_y] = w\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_x] += 1\n        return True\n\n    def get_size(self, x:int)->int:\n        \"\"\"xの属するグループのサイズ\"\"\"\n        return self.size[self.root(x)]\n\nif __name__ == \"__main__\":\n    N,Q = map(int, sys.stdin.readline().split())\n    UNITE,DIFF = 0,1\n    wuf = WeightedUnionFind(N)\n    for _ in range(Q):\n        com,*x = map(int, sys.stdin.readline().split())\n        if com==UNITE:\n            wuf.unite(*x)\n        else: # same\n            print(wuf.get_diff(*x))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(50000)\n\ndef findSet(x,element,weight):\n    if(x != element[x]):\n        element[x],s = findSet(element[x],element,weight)\n        weight[x] += s\n\n    return element[x],weight[x]\n\ndef union(x,y,element,weight,w):\n    x,wx = findSet(x, element, weight)\n    y,wy = findSet(y, element, weight)\n\n    link(x,wx,y,wy,w,element)\n    \ndef link(x,wx,y,wy,z,element):\n    z = z + wy - wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n\n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findSet(x,element,weight)\n        y,wy = findSet(y,element,weight)\n\n        if(x == y):\n            print(wx - wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "idx_com = 0\nidx_x = 1\nidx_y = 2\nidx_z = 3\n\nn, nq = map(int, input().split())\nparents = list(range(n))\nranks = [0] * n\nweights = [0] * n\n\ndef find(x):\n    if parents[x] == x:\n        return x\n    y = find(parents[x])\n    weights[x] += weights[parents[y]]\n    parents[x] = y\n    return y\n\ndef unite(x, y, w):\n    root_x = find(x)\n    root_y = find(y)\n\n    if ranks[root_x] < ranks[root_y]:\n        parents[root_x] = root_y\n        weights[root_x] = -w - weights[x] + weights[y]\n    else:\n        parents[root_y] = root_x\n        weights[root_y] = w - weights[y] + weights[x]\n        if ranks[root_x] == ranks[root_y]:\n            ranks[root_x] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weights[y] - weights[x]\n\nfor _ in range(nq):\n    q = list(map(int, input().split()))\n    if q[idx_com] == 0:\n        unite(q[idx_x], q[idx_y], q[idx_z])\n    else:\n        if same(q[idx_x], q[idx_y]):\n            print(diff(q[idx_x], q[idx_y]))\n        else:\n            print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "MAX = 10003 \nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(N)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return 1\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==1:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n  def __init__(self, n):\n    self.tree = [-1] * n\n    self.rank = [0] * n\n    self.diff_weight = [0] * n\n  \n  def unite(self, a, b, w):\n    w += self.weight(a)\n    w -= self.weight(b)\n    a = self.root(a)\n    b = self.root(b)\n    if a == b:\n      return\n    if self.rank[a] < self.rank[b]:\n      a, b = b, a\n      w *= -1\n    if self.rank[a] == self.rank[b]:\n      self.rank[a] += 1\n    self.tree[b] = a\n    self.diff_weight[b] = w\n    \n  def root(self, a):\n    if(self.tree[a] < 0):\n      return a\n    else:\n      res = self.root(self.tree[a])\n      self.diff_weight[a] += self.diff_weight[self.tree[a]]\n      self.tree[a] = res\n      return self.tree[a]\n\n  def same(self, a, b):\n    return self.root(a) == self.root(b)\n\n  def weight(self, a):\n    self.root(a)\n    return self.diff_weight[a]\n\n  def diff(self, a, b):\n    return self.weight(b) - self.weight(a)\n\nimport sys\n\nstdin = sys.stdin\nna = lambda: map(int, stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(ns())\n\ndef main():\n  n, m = na()\n  uf = UnionFind(n)\n  for _ in range(m):\n    t = list(na())\n    a, b, c = t[0], t[1], t[2]\n    if a == 0:\n      d = t[3]\n      uf.unite(b, c, d)\n    else:\n      if uf.same(b, c):\n        print(uf.diff(b, c))\n      else:\n        print(\"?\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "line = input()\nn, q = list(map(int, line.split()))\nrel = {}\nfor i in range(0, n):\n    rel[i] = []\nparent = [i for i in range(0, n)]\nrank = [0] * n\nweight = [0] * n\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    else:\n        y = find(parent[x])\n        weight[x] += weight[parent[x]]\n        parent[x] = y\n        return y\n\ndef union(x, y, w):\n    rx = find(x)\n    ry = find(y)\n    if rank[rx] < rank[ry]:\n        parent[rx] = ry\n        weight[rx] = w - weight[x] + weight[y]\n    else:\n        parent[ry] = rx\n        weight[ry] = - w - weight[y] + weight[x]\n        if rank[rx] == rank[ry]:\n            rank[rx] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weight[x] - weight[y]\n\nfor _ in range(0, q):\n    line = input()\n    query = list(map(int, line.split()))\n    if query[0] == 0:\n        x, y, z = query[1:]\n        union(x, y, z)\n    elif query[0] == 1:\n        x, y = query[1:]\n        if same(x, y):\n            print(diff(x, y))\n        else:\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if(par[x]==x):\n        return x\n    else:\n        r=root(par[x])\n        diff_weight[x]+=diff_weight[par[x]]\n        par[x]=r\n        return r\n\ndef weight(x):\n    root(x)\n    return diff_weight[x]\n\ndef diff(x,y):\n    return weight(y)-weight(x)\n\ndef relate(a,b,w):\n    w+=weight(a);w-=weight(b)\n    a=root(a)\n    b=root(b)\n    if(a==b):\n        return False\n    if rank[a]<rank[b]:\n        a,b=b,a\n        w=-w\n    if rank[a]==rank[b]:\n        rank[b]+=1\n        par[b]=a\n    par[b]=a\n    diff_weight[b]=w\n    siz[a]+=siz[b]\n    return True\n\ndef size(a):\n    return siz[root(a)]\n    \ndef same(a,b):\n    return root(a)==root(b)\n    \nN,Q=map(int,input().split())\npar=[i for i in range(N)]\nsiz=[1 for _ in range(N)]\nrank=[0 for _ in range(N)]\ndiff_weight=[0 for _ in range(N)]\nfor i in range(Q):\n    query=list(map(int,input().split()))\n    if not query[0]:\n        X,Y,W=query[1:]\n        relate(X,Y,W)\n    else:\n        X,Y=query[1:]\n        if same(X,Y):\n            print(diff(X,Y))\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "par = [i for i in range(100)]\nrank = [0 for i in range(100)]\nweight_to_root = [0 for i in range(100)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        root = find(par[x])\n        weight_to_root[x] += weight_to_root[par[x]]\n        par[x] = root\n        return root\n\ndef is_same(x,y):\n    return find(x) == find(y)\n\ndef union(x,y,w):\n    a = find(x)\n    b = find(y)\n    if a==b:\n        return False\n    if rank[a] > rank[b]:\n        par[b] = a\n        weight_to_root[b] = -w - weight_to_root[y] + weight_to_root[x]\n    elif rank[a] < rank[b]:\n        par[a] = b\n        weight_to_root[a] = w - weight_to_root[x] + weight_to_root[y]\n    else:\n        par[b] = a\n        weight_to_root[b] = -w - weight_to_root[y] + weight_to_root[x]\n        rank[a] += 1\n    return True\n\ndef diff(x,y):\n    return weight_to_root[x] - weight_to_root[y]\n\n\ndef main():\n    global rank,par,weight_to_root\n    n,q = [int(i) for i in input().split()]\n    rank = [0 for i in range(n)]\n    par = [i for i in range(n)]\n    weight_to_root = [0 for i in range(n)]\n    for i in range(q):\n        s = [int(j) for j in input().split()]\n        if s[0] == 0:\n            union(s[1],s[2],s[3])\n        else:\n            if is_same(s[1],s[2]):\n                print(diff(s[1],s[2]))\n            else:\n                print('?')\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\ndef union(x, y, t):\n    x, t_x = findSet(x)\n    y, t_y = findSet(y)\n    link(x, t_x, y, t_y, t)\n\n\ndef link(x, d_x, y, d_y, t):\n    #print('', 'x', 'y')\n    #print('', x, y)\n    #print('', d_x, d_y, t)\n    if r[x] > r[y]:\n        p[y] = x\n        d[y] = d_x + d_y - t\n        #print('', y, '->', p[y], '=', d[y], '\\n')\n\n    else:\n        p[x] = y\n        d[x] = d_y - d_x + t\n        if r[x] == r[y]: r[y] = r[y] + 1\n        #print('', x, '->', p[x], '=', d[x], '\\n')\n\n\ndef findSet(x):\n    if x != p[x]:\n        p[x], t = findSet(p[x])\n        d[x] += t\n    return p[x], d[x]\n\n\ndef diff(x, y):\n    x, d_x = findSet(x)\n    y, d_y = findSet(y)\n    if x == y:\n        return d_x - d_y\n\n    else:\n        return '?'\n\n\n\n\nif __name__ == '__main__':\n\n    p, r, d = [], [], []\n\n    n_set, n_quare = map(int, input().split())\n\n    for i in range(n_set):\n        p.append(i)\n        r.append(0)\n        d.append(0)\n\n\n    for i in range(n_quare):\n        l = input().split()\n\n        if len(l) == 4:\n            _, x, y, t = map(int, l)\n            union(x, y, t)\n\n        else:\n            _, x, y = map(int, l)\n            print(diff(x, y))\n\n"
  },
  {
    "language": "Python",
    "code": "\nn, q = map(int, input().split())\n\np = [i for i in range(n)]\nrank = [0 for i in range(n)]\ndiff_weight = [0 for i in range(n)]\n\n\ndef link(x, y, z):\n if rank[x] > rank[y]:\n  p[y] = x\n  diff_weight[y] = z\n else:\n  p[x] = y\n  diff_weight[x] = -z\n  if rank[x] == rank[y]:\n   rank[y] = rank[y] + 1\n\ndef findSet(x):\n if x != p[x]:\n  p[x] = findSet(p[x])\n  diff_weight[x] += diff_weight[p[x]]\n return p[x]\n\n\ndef relate(x, y, z):\n rootx = findSet(x)\n rooty = findSet(y)\n z += diff_weight[x]\n z -= diff_weight[y]\n link(rootx, rooty, z)\n\n\ndef same(x, y):\n x = findSet(x)\n y = findSet(y)\n\n if x == y:\n  return 1\n else :\n  return 0\n\ndef weight(x):\n findSet(x)\n return diff_weight[x]\n\ndef diff(x, y):\n if same(x, y) != 1:\n  return '?'\n else :\n  return diff_weight[y] - diff_weight[x]\n\n\noutput = []\n\nfor i in range(q):\n line = list(map(int, input().split()))\n\n if line[0] == 0:\n  relate(line[1], line[2], line[3])\n\n else :\n  output.append(diff(line[1],line[2]))\n\n\nfor ans in output:\n print(ans)\n"
  },
  {
    "language": "Python",
    "code": "\nn, q = map(int, input().split())\n\np = [i for i in range(n)]\nrank = [0 for i in range(n)]\ndiff_weight = [0 for i in range(n)]\n\n\ndef link(x, y, z):\n if rank[x] > rank[y]:\n  p[y] = x\n  diff_weight[y] = z\n else:\n  p[x] = y\n  diff_weight[x] = -z\n  if rank[x] == rank[y]:\n   rank[y] = rank[y] + 1\n\ndef findSet(x):\n if x != p[x]:\n  p[x] = findSet(p[x])\n  diff_weight[x] += diff_weight[p[x]]\n return p[x]\n\n\ndef relate(x, y, z):\n rootx = findSet(x)\n rooty = findSet(y)\n z += diff_weight[x]\n z -= diff_weight[y]\n if rootx != rooty:\n  link(rootx, rooty, z)\n\n\ndef same(x, y):\n x = findSet(x)\n y = findSet(y)\n\n if x == y:\n  return 1\n else :\n  return 0\n\ndef weight(x):\n findSet(x)\n return diff_weight[x]\n\ndef diff(x, y):\n if same(x, y) != 1:\n  return '?'\n else :\n  return diff_weight[y] - diff_weight[x]\n\n\noutput = []\n\nfor i in range(q):\n line = list(map(int, input().split()))\n\n if line[0] == 0:\n  relate(line[1], line[2], line[3])\n\n else :\n  output.append(diff(line[1],line[2]))\n  #print(diff(line[1],line[2]))\n\n\nfor ans in output:\n print(ans)\n"
  },
  {
    "language": "Python",
    "code": "\ndef union(x, y, t):\n    x, t_x = findSet(x)\n    y, t_y = findSet(y)\n    link(x, t_x, y, t_y, t)\n\n\ndef link(x, d_x, y, d_y, t):\n    print('', 'x', 'y')\n    print('', x, y)\n    print('', d_x, d_y, t)\n    if r[x] > r[y]:\n        p[y] = x\n        d[y] = d_x + d_y - t\n        print('', y, '->', p[y], '=', d[y], '\\n')\n\n    else:\n        p[x] = y\n        d[x] = d_y - d_x + t\n        if r[x] == r[y]: r[y] = r[y] + 1\n        print('', x, '->', p[x], '=', d[x], '\\n')\n\n\ndef findSet(x):\n    if x != p[x]:\n        p[x], t = findSet(p[x])\n        d[x] += t\n    return p[x], d[x]\n\n\ndef diff(x, y):\n    x, d_x = findSet(x)\n    y, d_y = findSet(y)\n    if x == y:\n        return d_x - d_y\n\n    else:\n        return '?'\n\n\n\n\nif __name__ == '__main__':\n\n    p, r, d = [], [], []\n\n    n_set, n_quare = map(int, input().split())\n\n    for i in range(n_set):\n        p.append(i)\n        r.append(0)\n        d.append(0)\n\n\n    for i in range(n_quare):\n        l = input().split()\n\n        if len(l) == 4:\n            _, x, y, t = map(int, l)\n            union(x, y, t)\n\n        else:\n            _, x, y = map(int, l)\n            print(diff(x, y))\n\n"
  },
  {
    "language": "Python",
    "code": "\nn, q = map(int, input().split())\n\np = [i for i in range(n)]\nrank = [0 for i in range(n)]\ndiff_weight = [0 for i in range(n)]\n\n\ndef link(x, y, z):\n if rank[x] >= rank[y]:\n  p[y] = x\n  diff_weight[y] = z\n  if rank[x] == rank[y]:\n   rank[x] = rank[x] + 1\n else:\n  p[x] = y\n  diff_weight[x] = -z\n\ndef findSet(x):\n if x != p[x]:\n  p[x] = findSet(p[x])\n  diff_weight[x] += diff_weight[p[x]]\n return p[x]\n\n\ndef relate(x, y, z):\n rootx = findSet(x)\n rooty = findSet(y)\n z += diff_weight[x]\n z -= diff_weight[y]\n link(rootx, rooty, z)\n\n\ndef same(x, y):\n x = findSet(x)\n y = findSet(y)\n\n if x == y:\n  return 1\n else :\n  return 0\n\ndef weight(x):\n findSet(x)\n return diff_weight[x]\n\ndef diff(x, y):\n if same(x, y) != 1:\n  return '?'\n else :\n  return diff_weight[y] - diff_weight[x]\n\n\noutput = []\n\nfor i in range(q):\n line = list(map(int, input().split()))\n\n if line[0] == 0:\n  relate(line[1], line[2], line[3])\n\n else :\n  output.append(diff(line[1],line[2]))\n\n\nfor ans in output:\n print(ans)\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Tree\n[p, rank, d] = [[], [], []]\n[n, q] = list(map(int, input().split()))\ntime = 0\n\ndef makeSet(x):\n    global p, rank, w\n    p.append(x)\n    rank.append(0)\n\nfor i in range(n):\n    makeSet(i)\n\nw = [[] for i in range(n)]\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef relate(x, y, z):\n    global w\n    w[x].append((y, z))\n    union(x, y)\n\ndef cost(x, y, n, total):\n    global w, d, time\n    time += 1\n    if time > 5:\n        return None\n    for i in range(len(w[x])):\n        if d[w[x][i][0]] == 0:\n            #print(x, w[x][i][0])\n            d[w[x][i][0]] = 1\n            if y == w[x][i][0]:\n                total += w[x][i][1]\n                return total\n            result = cost(w[x][i][0], y, n, total)\n            if result != None:\n                total = result + w[x][i][1]\n                return total\n\n    for i in range(n):\n        for j in range(len(w[i])):\n            if w[i][j][0] == x and d[i] == 0:\n                #print(i, x)\n                d[i] = 1\n                if y == i:\n                    total -= w[i][j][1]\n                    return total\n                result = cost(i, y, n, total)\n                if result != None:\n                    total = result - w[i][j][1]\n                    return total\n\n'''\n        if ((x, i) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total += w[(x, i)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result + w[(x, i)]\n                return total     \n\n        if ((i, x) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total -= w[(i, x)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result - w[(i, x)]\n                return total\n                '''\n\ndef diff(x, y, n):\n    if same(x, y) == 1:\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n    else:\n        return \"?\"     \n\ndef union(x, y):\n    link(findSet(x), findSet(y))    \n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2], n))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100000\nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(MAX)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return False\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==False:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class WeightedUnionFind():\n    def __init__(self,n):\n        self.n=n\n        self.parents=[-1]*n\n        self.differ=[0]*n\n\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            r=self.find(self.parents[x])\n            self.differ[x]+=self.differ[self.parents[x]]\n            self.parents[x]=r\n            return self.parents[x]\n\n    def unite(self,x,y,w):\n        xp=self.find(x)\n        yp=self.find(y)\n        w=w+self.differ[x]-self.differ[y]\n\n        if xp!=yp:\n            if self.parents[xp]>self.parents[yp]:\n                xp,yp=yp,xp\n                w=-w\n\n            self.parents[xp]+=self.parents[yp]\n            self.parents[yp]=xp\n            self.differ[yp]=w\n\n    def diff(self,x,y):\n        xp=self.find(x)\n        yp=self.find(y)\n        if xp==yp:\n            return True,self.differ[y]-self.differ[x]\n        else:\n            return False,0\n\nn,q=map(int,input().split())\nWUF=WeightedUnionFind(n)\nfor i in range(q):\n    query=list(map(int,input().split()))\n    if query[0]==0:\n        WUF.unite(query[1],query[2],query[3])\n    elif query[0]==1:\n        judge,diff=WUF.diff(query[1],query[2])\n        if judge:\n            print(diff)\n        else:\n            print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "idx_com = 0\nidx_x = 1\nidx_y = 2\nidx_z = 3\n\nn, nq = map(int, input().split())\nparents = list(range(n))\nranks = [0] * n\nweights = [0] * n\n\ndef find(x):\n    if parents[x] == x:\n        return x\n    y = find(parents[x])\n    weights[y] += weights[parents[x]]\n    parents[x] = y\n    return y\n\ndef unite(x, y, w):\n    root_x = find(x)\n    root_y = find(y)\n\n    if ranks[root_x] < ranks[root_y]:\n        parents[root_x] = root_y\n        weights[root_x] = -w - weights[x] + weights[y]\n    else:\n        parents[root_y] = root_x\n        weights[root_y] = w - weights[y] + weights[x]\n        if ranks[root_x] == ranks[root_y]:\n            ranks[root_x] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weights[y] - weights[x]\n\nfor _ in range(nq):\n    q = list(map(int, input().split()))\n    if q[idx_com] == 0:\n        unite(q[idx_x], q[idx_y], q[idx_z])\n    else:\n        if same(q[idx_x], q[idx_y]):\n            print(diff(q[idx_x], q[idx_y]))\n        else:\n            print(\"?\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nclass Union():\n    def __init__(self, n):\n        self.par = [i for  i in range(n+1)]\n        self.rank = [0]*(n+1)\n        self.weight = [0]*(n+1) #子から親までの距離\n        \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        y = self.find(self.par[x])\n        self.weight[x] += self.weight[self.par[x]]\n        self.par[x] = y\n        return y\n    \n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n        \n    def same(self, x, y):\n        return (self.find(x) == self.find(y))\n    \n    #ｘからｙへの距離\n    def diff(self, x, y):\n        if self.same(x,y):\n            return self.weight[x] - self.weight[y]\n        else:return '?'\n\nn ,q = map(int, input().split())\nunite = Union(n)\nfor i in range(q):\n    a, b, c, *d = map(int, input().split())\n    if a == 0:unite.union(b,c,d[0])\n    else:print(unite.diff(b,c))\n"
  },
  {
    "language": "Python",
    "code": "class P_UnionFind:\n    def __init__(self, n):\n        self.p=[i for i in range(n)]\n        self.r=[0 for i in range(n)]\n        self.d=[0 for i in range(n)]\n    def root(self,x):\n        if self.p[x]==x:\n            return x\n        else:\n            tmp = self.root(self.p[x])\n            self.d[x] += self.d[self.p[x]]\n            self.p[x] = tmp\n            return self.p[x]\n    \n    def weight(self,x):\n        self.root(x)\n        return self.d[x]\n\n    def diff(self,x,y):\n        if self.root(x)==self.root(y):\n            return self.weight(y)-self.weight(x)\n        else:\n            return '?'\n\n    def uni(self,x,y,w):\n        w+=self.weight(x)\n        w-=self.weight(y)\n        x=self.root(x)\n        y=self.root(y)\n        if(x==y):\n            return\n        if self.r[x]<self.r[y]:\n            self.p[x]=y\n            self.d[x]=-w\n        else:\n            self.p[y]=x\n            self.d[y]=w\n            if self.r[x]==self.r[y]:\n                self.r[x]+=1\n    \n    def same(self,x,y):\n        return self.root(x)==self.root(y)\n\nn,q=map(int,input().split())\nuf=P_UnionFind(n)\nans=[]\nfor i in range(q):\n    d=list(map(int,input().split()))\n    if d[0]==0:\n        c,x,y,z=d\n        uf.uni(x,y,z)\n    else:\n        c,x,y=d\n        ans.append(uf.diff(x,y))\nprint(*ans,sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom sys import stdin,setrecursionlimit\nsys.setrecursionlimit(10**6)\ninput=stdin.readline\n#import pysnooper\n\nclass Weighted_Union_find:\n    \n    def __init__(self,n):\n        self.n=n\n        self.root=[i for i in range(n+1)]\n        self.rank=[0]*(n+1)\n        self.weight=[0]*(n+1)\n\n    #@pysnooper.snoop()\n    def find_root(self,x):# 頂点xのroot(根)頂点を見つける\n        if self.root[x]==x:\n            return x\n        else:\n            y=self.find_root(self.root[x])\n            self.weight[x]+=self.weight[self.root[x]]\n            self.root[x]=y\n            return y\n    #@pysnooper.snoop()\n    def unite(self,x,y,w):#頂点xと頂点yを繋ぐ辺を追加\n        rx=self.find_root(x)\n        ry=self.find_root(y)\n        if rx==ry:\n            return 0\n        if self.rank[rx]<self.rank[ry]:\n            self.root[rx]=ry\n            self.weight[rx]=w-self.weight[x]+self.weight[y]\n        else:\n            self.root[ry]=rx\n            self.weight[ry]=-w-self.weight[y]+self.weight[x]\n            if self.rank[rx]==self.rank[ry]:\n                self.rank[rx]+=1\n\n    def same(self,x,y):#頂点xと頂点yが連結であるか判定\n        return self.find_root(x)==self.find_root(y)\n\n    def count(self,x):#頂点xが属する木のサイズ\n        return -self.root[self.find_root(x)]\n    \n    def diff(self,x,y):#頂点xから頂点yへのコスト\n        return self.weight[x]-self.weight[y]\n\n#@pysnooper.snoop()\ndef main():\n    n,q=map(int,input().split())\n    gragh=Weighted_Union_find(n+1)\n    for _ in range(q):\n        query=tuple(map(int,input().split()))\n        if not query[0]:\n            gragh.unite(query[1],query[2],query[3])\n        else:\n            if gragh.same(query[1],query[2]):\n                print(gragh.diff(query[1],query[2]))\n            else:\n                print(\"?\")\n    #print(1111111111111111)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Trees\n[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\npath_c = [[] for i in range(n)]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef union(x, y):\n    link(findSet(x), findSet(y))\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\ndef relate(x, y, z):\n    global w, path_c\n    path_c[x].append((y, z))\n    #print(w)\n    if w[y] == 0:\n        w[y] = w[x] + z\n    else:\n        update(x, y, z)\n        #w[x] = w[y] - z\n    #print(\"cost:\", w[y])\n    union(x, y)\n\ndef update(x, y, z):\n    global w, path_c\n    w[x] = w[y] - z\n    for i in range(len(path_c[x])):\n        update(path_c[x][i][0], x, path_c[x][i][1])\n\n\ndef diff(x, y):\n    if same(x, y) == 1:\n        global w\n        return w[y] - w[x]\n        '''\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n        '''\n    else:\n        return \"?\"     \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(n):\n    makeSet(i)\n\n#w = [0 for i in range(n)]\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2]))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "class UnionSet:\n    def __init__(self, nmax: int) -> None:\n        self.size = [1] * nmax\n        self.id = [i for i in range(nmax)]\n        self.weight = [0] * nmax\n\n    def root(self, i: int) -> int:\n        if (i == self.id[i]):\n            return i\n        else:\n            tmp = self.root(self.id[i])\n            self.weight[i] += self.weight[self.id[i]]\n            self.id[i] = tmp\n            return self.id[i]\n\n    def get_weight(self, i: int) -> int:\n        self.root(i)\n        return self.weight[i]\n\n    def connected(self, p: int, q: int) -> bool:\n        return self.root(p) == self.root(q)\n\n    def unite(self, p: int, q: int, w: int) -> None:\n        w += self.get_weight(p)\n        w -= self.get_weight(q)\n        i, j = self.root(p), self.root(q)\n        if (i == j):\n            return\n        if self.size[i] < self.size[j]:\n            self.id[i] = j\n            self.size[j] += self.size[i]\n            self.weight[i] = -w\n        else:\n            self.id[j] = i\n            self.size[i] += self.size[j]\n            self.weight[j] = w\n\n    def diff(self, p: int, q: int) -> None:\n        i, j = self.root(p), self.root(q)\n        if (i == j):\n            print(self.get_weight(q) - self.get_weight(p))\n        else:\n            print(\"?\")\n\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n\n    u = UnionSet(n)\n    for _ in range(q):\n        op, *v = map(lambda x: int(x), input().split())\n        if (0 == op):\n            x, y, w = v\n            u.unite(x, y, w)\n        else:\n            x, y = v\n            u.diff(x, y)\n\n"
  },
  {
    "language": "Python",
    "code": "#! python3\n# weighted_union_find_tree.py\n\nclass WeightedUnionFindTree():\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.weight = [0] * (n+1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    def unite(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\nn, q = [int(x) for x in input().split(' ')]\nwuft = WeightedUnionFindTree(n-1)\nfor i in range(q):\n    query = [int(x) for x in input().split(' ')]\n    if query[0] == 0:\n        x, y, z = query[1:]\n        wuft.unite(x, y, z)\n    elif query[0] == 1:\n        x, y = query[1:]\n        if wuft.same(x, y):\n            print(wuft.diff(x,y))\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y = simplefindset(y,element)\n    link(x,wx,y,w,element)\n\ndef link(x,wx,y,z,element):\n    if(z > wx):\n        z = z - wx\n    else:\n        z = wx - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(abs(wx-wy))\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(50000)\ndef main():\n    n,q = [int(i) for i in input().split()]\n    par = [ i for i in range(n)]\n    diff_weight = [ 0 for i in range(n)]\n    rank = [ 0 for i in range(n)]\n    def diff(x,y):\n        return weight(y)-weight(x)\n\n    def weight(x):\n        root(x)\n        return diff_weight[x]\n\n    def root(x):\n        if par[x] == x:\n            return x\n        else:\n            diff_weight[x] += diff_weight[par[x]]\n            par[x] = root(par[x])\n            return par[x]\n\n    def merge(x,y,w):\n        w += weight(x)\n        w -= weight(y)\n        x = root(x)\n        y = root(y)\n        if x == y:\n            return False\n        if rank[x]<rank[y]:\n            tmp = x\n            x = y\n            y = tmp\n            w = -w\n        if rank[x] == rank[y]:\n            rank[x] += 1\n        par[y] = x\n        diff_weight[y] = w\n        return True\n\n    for i in range(q):\n        s = [int(j) for j in input().split()]\n        if s[0] == 0:\n            merge(s[1],s[2],s[3])\n        else:\n            if root(s[1]) == root(s[2]):\n                print(diff(s[1],s[2]))\n            else:\n                print('?')\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "idx_com = 0\nidx_x = 1\nidx_y = 2\nidx_z = 3\n\nn, nq = map(int, input().split())\nparents = list(range(n))\nranks = [0] * n\nweights = [0] * n\n\ndef find(x):\n    if parents[x] == x:\n        return x\n    y = find(parents[x])\n    weights[x] += weights[parents[x]]\n    parents[x] = y\n    return y\n\ndef unite(x, y, w):\n    root_x = find(x)\n    root_y = find(y)\n\n    if ranks[root_x] < ranks[root_y]:\n        parents[root_x] = root_y\n        weights[root_x] = -w - weights[x] + weights[y]\n    else:\n        parents[root_y] = root_x\n        weights[root_y] = +w - weights[y] + weights[x]\n        if ranks[root_x] == ranks[root_y]:\n            ranks[root_x] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weights[y] - weights[x]\n\nfor _ in range(nq):\n    q = list(map(int, input().split()))\n    if q[idx_com] == 0:\n        unite(q[idx_x], q[idx_y], q[idx_z])\n    else:\n        if same(q[idx_x], q[idx_y]):\n            print(diff(q[idx_x], q[idx_y]))\n        else:\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass weightedUnionTree:\n    def __init__(self,n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.weight = [0] * (n+1)\n\n    def find(self,x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    def union(self,x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        #self.isThere[x] = True; self.isThere[y] = True\n\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        \"\"\"\n        print(\"diff: \",end=\"\")\n        print(self.weight[x],end=\" \")\n        print(self.weight[y],end=\" \")\n        #print(self.isThere)\n        \"\"\"\n\n        if(self.same(x, y)): #conditional branch\n            print(self.weight[x] - self.weight[y])\n        else:\n            print(\"?\")\n\n\nif __name__ == \"__main__\":\n    n, q = (int(p) for p in input().split())\n    tree = weightedUnionTree(n)\n    #for i in range(n):\n    #    queue.append(0)\n    for i in range(q):\n        question, num = input().split(' ', 1)\n        #print(question)\n        #print(input)\n        if(int(question) == 0):\n            #print(\"relate\")\n            x, y, z = num.split(' ')\n            tree.union(int(x), int(y), int(z))\n        else:\n            #print(\"diff\")\n            x, y = num.split(' ')\n            tree.diff(int(x), int(y))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    if(z > (wx+wy)):\n        z = z - (wx+wy)\n    else:\n        z = (wx+wy) - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "# N,M = map(int,sys.stdin.readline().split())\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n# s = sys.stdin.readline().rstrip()\n# N = int(sys.stdin.readline())\n# INF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(1000000)\nN,Q = map(int,sys.stdin.readline().split())\nqs = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(Q)) # multi line with multi param\n\nparents = list(range(N))\ndiffs = [0]*N\n\ndef root(x):\n    if parents[x]==x:\n        return x\n    else:\n        pr = root(parents[x])\n        diffs[x] += diffs[parents[x]]\n        parents[x] = pr\n        return pr\n\ndef weight(x):\n    root(x)\n    return diffs[x]\n\ndef diff(x,y):\n    return weight(y)-weight(x)\n\ndef issame(x,y):\n    return root(x) == root(y)\n\n# make sure weight(y)-weight(x)=w\ndef merge(x,y,w):\n    # assume ry > rx\n    rx = root(x)\n    ry = root(y)\n    # incase rx!=x and ry !=y\n    diff = weight(x)+(w-weight(y))\n    if rx == ry:\n        return False\n    if rx < ry:\n        rx,ry,diff = ry,rx,-diff\n    diffs[ry] = diff\n    parents[ry] = rx\n    return True\n\nfor q in qs:\n    if q[0]==0:\n        x,y,z = q[1:]\n        merge(x,y,z)\n    else:\n        x,y = q[1:]\n        if root(x)==root(y):\n            print(diff(x,y))\n        else:\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        pre_parent = p[x]\n        p[x] = findSet(p[x])\n        w[x] += w[pre_parent]\n    return p[x]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\n\ndef link(x, y, z):\n    global p, rank, w\n    if rank[x] > rank[y]:\n        p[y] = x\n        w[y] = z\n    else:\n        p[x] = y\n        w[x] = -z\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef relate(x, y, z):\n    global w\n    root_x = findSet(x)\n    root_y = findSet(y)\n    z += w[x]\n    z -= w[y]\n    link(root_x, root_y, z)\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n   \ndef difference(x, y):\n    if same(x, y) == 1:\n        global w\n        return w[y] - w[x]\n    else:\n        return \"?\"     \n\nfor i in range(n):\n    makeSet(i)\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(difference(data[1], data[2]))\n\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100000\nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(N)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return False\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==False:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Trees\n[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\npath_c = [[] for i in range(n)]\npath_c_len = [0 for i in range(n)]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef union(x, y):\n    link(findSet(x), findSet(y))\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\ndef relate(x, y, z):\n    global w, path_c\n    path_c[y].append((x, z))\n    path_c_len[y] += 1\n    #print(w)\n    if w[y] == 0:\n        w[y] = w[x] + z\n    else:\n        update(x, y, z)\n    union(x, y)\n\ndef update(x, y, z):\n    global w, path_c\n    w[x] = w[y] - z\n    for i in range(path_c_len[x]):\n        update(path_c[x][i][0], x, path_c[x][i][1])\n\n\ndef diff(x, y):\n    if same(x, y) == 1:\n        global w\n        return w[y] - w[x]\n        #return abs(w[y] - w[x])\n    else:\n        return \"?\"     \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(n):\n    makeSet(i)\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2]))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Tree\n[p, rank, d] = [[], [], []]\n[n, q] = list(map(int, input().split()))\n#time = 0\n\ndef makeSet(x):\n    global p, rank, w\n    p.append(x)\n    rank.append(0)\n\nfor i in range(n):\n    makeSet(i)\n\nw = [[] for i in range(n)]\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef relate(x, y, z):\n    global w\n    w[x].append((y, z))\n    union(x, y)\n\ndef cost(x, y, n, total):\n    global w, d, time\n    #time += 1\n    #if time > 5:\n    #    return None\n    for i in range(len(w[x])):\n        if d[w[x][i][0]] == 0:\n            #print(x, w[x][i][0])\n            d[w[x][i][0]] = 1\n            if y == w[x][i][0]:\n                total += w[x][i][1]\n                return total\n            result = cost(w[x][i][0], y, n, total)\n            if result != None:\n                total = result + w[x][i][1]\n                return total\n\n    for i in range(n):\n        for j in range(len(w[i])):\n            if w[i][j][0] == x and d[i] == 0:\n                #print(i, x)\n                d[i] = 1\n                if y == i:\n                    total -= w[i][j][1]\n                    return total\n                result = cost(i, y, n, total)\n                if result != None:\n                    total = result - w[i][j][1]\n                    return total\n\n'''\n        if ((x, i) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total += w[(x, i)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result + w[(x, i)]\n                return total     \n\n        if ((i, x) in w.keys()) == True and d[i] == 0:\n            d[i] = 1\n            if i == y:\n                total -= w[(i, x)]\n                return total\n            result = cost(i, y, n, total)\n            if result != None:\n                total = result - w[(i, x)]\n                return total\n                '''\n\ndef diff(x, y, n):\n    if same(x, y) == 1:\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n    else:\n        return \"?\"     \n\ndef union(x, y):\n    link(findSet(x), findSet(y))    \n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2], n))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    if(z > wx):\n        z = z - wx+wy\n    else:\n        z = wx-wy - z\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(abs(wx-wy))\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "# Disjoint Set: Union Find Trees\n[p, rank] = [[], []]\n[n, q] = list(map(int, input().split()))\nw = [0 for i in range(n)]\n\ndef makeSet(x):\n    global p, rank\n    p.append(x)\n    rank.append(0)\n\ndef findSet(x):\n    global p\n    if x != p[x]:\n        p[x] = findSet(p[x])\n    return p[x]\n\ndef link(x, y):\n    global p, rank\n    if rank[x] > rank[y]:\n        p[y] = x\n    else:\n        p[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\ndef union(x, y):\n    link(findSet(x), findSet(y))\n\ndef same(x, y):\n    if findSet(x) == findSet(y):\n        return 1\n    else:\n        return 0   \n\ndef relate(x, y, z):\n    global w\n    #print(w)\n    if w[y] == 0:\n        w[y] = w[x] + z\n    else:\n        w[x] = w[y] - z\n    #print(\"cost:\", w[y])\n    union(x, y)\n'''\ndef cost(x, y, n, total):\n    global w, d\n    #time += 1\n    #if time > 5:\n    #    return None\n    for i in range(len(w[x])):\n        if d[w[x][i][0]] == 0:\n            #print(x, w[x][i][0])\n            d[w[x][i][0]] = 1\n            if y == w[x][i][0]:\n                total += w[x][i][1]\n                return total\n            result = cost(w[x][i][0], y, n, total)\n            if result != None:\n                total = result + w[x][i][1]\n                return total\n\n    for i in range(n):\n        for j in range(len(w[i])):\n            if w[i][j][0] == x and d[i] == 0:\n                #print(i, x)\n                d[i] = 1\n                if y == i:\n                    total -= w[i][j][1]\n                    return total\n                result = cost(i, y, n, total)\n                if result != None:\n                    total = result - w[i][j][1]\n                    return total\n'''\n\ndef diff(x, y):\n    if same(x, y) == 1:\n        global w\n        return w[y] - w[x]\n        '''\n        global d\n        total = 0\n        d = [0 for i in range(n)]\n        d[x] = 1\n        return cost(x, y, n, total)\n        '''\n    else:\n        return \"?\"     \n\n'''\nprint(p)\nprint(rank)\nprint(w)\nprint(\"\\n\")\n'''\n\nfor i in range(n):\n    makeSet(i)\n\n#w = [0 for i in range(n)]\n\nfor i in range(q):\n    data = list(map(int, input().split()))\n    if data[0] == 0:\n        relate(data[1], data[2], data[3])\n    else:\n        print(diff(data[1], data[2]))\n    '''\n    print(\"\\n\")\n    print(p)\n    print(rank)\n    print(w)\n    print(\"\\n\")\n    '''\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef simplefindset(x,element,resultPos=0):\n    if(x != element[x]):\n        resultPos = simplefindset(element[x],element,resultPos)\n    else:\n        resultPos = x\n    return resultPos\n\ndef findset(x,element,weight,resultPos=0,sumW=0):\n    if(x != element[x]):\n        resultPos,sumW = findset(element[x],element,weight,resultPos,sumW)\n    else:\n        resultPos = x\n    sumW += weight[x]\n    return resultPos,sumW\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\n\ndef link(x,wx,y,wy,z,element):\n    element[x] = y\n    weight[x] = z - (wx+wy)\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        if(simplefindset(x,element) == simplefindset(y,element)):\n            x,wx = findset(x,element,weight)\n            y,wy = findset(y,element,weight)\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(50000)\n\ndef findset(x,element,weight):\n    if(x != element[x]):\n        element[x],s = findset(element[x],element,weight)\n        weight[x] += s\n    return element[x],weight[x]\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,wx,y,wy,w,element)\ndef link(x,wx,y,wy,z,element):\n    z = z+wy-wx\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findset(x,element,weight)\n        y,wy = findset(y,element,weight)\n        if(x == y):\n            print(wx-wy)\n        else:\n            print('?')\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(50000)\n\ndef findset(x,element,weight):\n    if(x != element[x]):\n        element[x],s = findset(element[x],element,weight)\n        weight[x] += s\n    return element[x],weight[x]\n\ndef union(x,y,element,weight,w):\n    x,wx = findset(x,element,weight)\n    y,wy = findset(y,element,weight)\n    link(x,y,w+wy-wx,element,weight)\n\ndef link(x,y,z,element,weight):\n\n    element[x] = y\n    weight[x] = z\n\nn,q = map(int, input().split());\n\nelement = [i for i in range(n)]\nweight = [0 for i in range(n)]\n\nfor i in range(q):\n    inp = map(int, input().split());\n    inp = list(inp)    \n    if(inp[0] == 0):\n        x,y,w = inp[1],inp[2],inp[3]\n        union(x,y,element,weight,w)\n    else:\n        x,y = inp[1],inp[2]\n        x,wx = findset(x,element,weight)\n        y,wy = findset(y,element,weight)\n        if(x == y):\n            print(wx-wy)\n        else:\n            print('?')\n"
  },
  {
    "language": "Python",
    "code": "idx_com = 0\nidx_x = 1\nidx_y = 2\nidx_z = 3\n\nn, nq = map(int, input().split())\nparents = list(range(n))\nranks = [0] * n\nweights = [0] * n\n\ndef find(x):\n    if parents[x] == x:\n        return x\n    y = find(parents[x])\n    weights[y] += weights[parents[x]]\n    parents[x] = y\n    return y\n\ndef unite(x, y, w):\n    root_x = find(x)\n    root_y = find(y)\n\n    if ranks[root_x] < ranks[root_y]:\n        parents[root_x] = root_y\n        weights[root_x] = -w - weights[x] + weights[y]\n    else:\n        parents[root_y] = root_x\n        weights[root_y] = w - weights[y] + weights[x]\n        if ranks[root_x] == ranks[root_y]:\n            ranks[root_x] += 1\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef diff(x, y):\n    return weights[y] - weights[x]\n\nfor _ in range(nq):\n    q = list(map(int, input().split()))\n    if q[idx_com] == 0:\n        unite(q[idx_x], q[idx_y], q[idx_z])\n    else:\n        print(diff(q[idx_x], q[idx_y]))\n\n"
  },
  {
    "language": "Python",
    "code": "n,q=map(int,input().split())\nQ=[list(map(int,input().split())) for i in range(q)]\n\n#UnionFind\n\nGroup=[[i,0] for i in range(n)]#グループ分け.Group[i]=jのときiとjは同じグループ\n\ndef find(x):#find(a)=find(b)のとき同じグループ\n    ANS=Group[x][1]\n    while Group[x][0] != x:\n        x=Group[x][0]\n        ANS+=Group[x][1]\n    return x,ANS\n\ndef Union(x,y,z):  # xとyが同じグループになるよう更新\n    if find(x)[0] != find(y)[0]:\n        MIN=min(find(x)[0],find(y)[0])\n        if find(x)[0]==MIN:\n            Group[find(y)[0]]=[MIN,z+find(x)[1]-find(y)[1]]\n        else:\n            Group[find(x)[0]]=[MIN,-z+find(y)[1]-find(x)[1]]\n            \n\nfor query in Q:\n    if query[0]==0:\n        Union(query[1],query[2],query[3])\n        #print(Group)\n    else:\n        if find(query[1])[0]==find(query[2])[0]:\n            print(find(query[2])[1]-find(query[1])[1])\n        else:\n            print(\"?\")\n"
  },
  {
    "language": "Python",
    "code": "MAX = 10003 \nN, Q =  (int(x) for x in  input().split())\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(N)]\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n    return y\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return -1\n    ans = ws[x] - ws[y]\n    return ans\n\n\n\nfor q in range(Q):\n    t, *cmd =  (int(x) for x in  input().split())\n    if t:\n        x, y = cmd\n        z = diff(x, y)\n        if z==-1:print(\"?\")\n        else :print(z)\n    else:\n        x, y, z = cmd\n        unite(x, y, z)\n\n\n"
  },
  {
    "language": "Python",
    "code": "MAX = 100003\nws = [0 for i in range(MAX)] \npar = [-1 for i in range(MAX*2)]\n\n\ndef weight(x):\n    root(x)\n    return ws[x]\n\ndef root(x):\n    if par[x] < 0: return x\n    p = root(par[x])\n    ws[x] = ws[x] + ws[par[x]]\n    par[x] = p\n    return par[x]\n\n\ndef unite(y, x, z):\n    z = z + weight(x)\n    z = z - weight(y)\n    x = root(x)\n    y = root(y)\n    if x == y: return 0\n    if par[y] < par[x]:\n        tmp = x\n        x = y \n        y = tmp \n        z = -z\n     \n    par[x] = par[x] + par[y]\n    par[y] = x\n    ws[y] = z\n    return 1 \n\ndef diff(x,y):\n    if root(x) != root(y) :return 0\n    ans = ws[x] - ws[y]\n    return 1 ,ans\n\n\nif __name__=='__main__':\n   global ans\n   N, Q =  (int(x) for x in  input().split())\n   for q in range(Q):\n        t, *cmd =  (int(x) for x in  input().split())\n        if t:\n            x, y = cmd\n            z = diff(x, y)\n            if z==False :print(\"?\")\n            else :print(z[1])\n        else:\n            x, y, z = cmd\n            unite(x, y, z)\n\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\nmod util {\n    use std::fmt::Debug;\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n/// https://qiita.com/drken/items/cce6fc5c579051e64fab\npub struct WeightedUFT {\n    pub par: Vec<usize>,\n    pub rank: Vec<usize>,\n    pub diff_weight: Vec<i64>,\n}\nimpl WeightedUFT {\n    pub fn new(size: usize) -> WeightedUFT {\n        WeightedUFT {\n            par: (0..size).collect(),\n            rank: vec![0; size],\n            diff_weight: vec![0; size],\n        }\n    }\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let p = self.par[x];\n            let r = self.root(p);\n            self.diff_weight[x] += self.diff_weight[p];\n            self.par[x] = r;\n            r\n        }\n    }\n    pub fn weight(&mut self, x: usize) -> i64 {\n        self.root(x);\n        self.diff_weight[x]\n    }\n    pub fn merge(&mut self, mut x: usize, mut y: usize, mut w: i64) -> bool {\n        w += self.weight(x);\n        w -= self.weight(y);\n        x = self.root(x);\n        y = self.root(y);\n        if x == y {\n            return false;\n        }\n        if self.rank[x] < self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n            w = -w;\n        }\n        if self.rank[x] == self.rank[y] {\n            self.rank[y] += 1;\n        }\n        self.par[y] = x;\n        self.diff_weight[y] = w;\n        true\n    }\n}\n\nfn solve() {\n    let (n, q) = get!(usize, usize);\n\n    let mut uft = WeightedUFT::new(n);\n\n    let mut line = String::new();\n    util::with_bufwriter(|mut out| {\n        for _ in 0..q {\n            line.clear();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            if iter.next() == Some(\"0\") {\n                let x: usize = iter.next().unwrap().parse().unwrap();\n                let y: usize = iter.next().unwrap().parse().unwrap();\n                let w: i64 = iter.next().unwrap().parse().unwrap();\n\n                uft.merge(x, y, w);\n            } else {\n                let x: usize = iter.next().unwrap().parse().unwrap();\n                let y: usize = iter.next().unwrap().parse().unwrap();\n\n                if uft.root(x) != uft.root(y) {\n                    writeln!(out, \"?\").unwrap();\n                } else {\n                    writeln!(out, \"{}\", uft.weight(y) - uft.weight(x)).unwrap();\n                }\n            }\n        }\n    });\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "pub fn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\npub fn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\npub fn read_vec2<T: std::str::FromStr>(n: u32) -> Vec<Vec<T>> {\n    (0..n).map(|_| read_vec()).collect()\n}\n\npub fn read_col<T: std::str::FromStr>(n: u32) -> Vec<T> {\n    (0..n).map(|_| read()).collect()\n}\n\nstruct UnionFind {\n    size: Vec<usize>,\n    parent: Vec<Option<usize>>,\n    diff: Vec<i32>,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind {\n            size: vec![1; n],\n            parent: vec![None; n],\n            diff: vec![0; n],\n        }\n    }\n\n    fn get_parent_diff(&mut self, x: usize) -> (usize, i32) {\n        match self.parent[x] {\n            None => (x, 0),\n            Some(y) => {\n                let (p, d) = self.get_parent_diff(y);\n                self.parent[x] = Some(p);\n                self.diff[x] = d + self.diff[x];\n                (p, self.diff[x])\n            }\n        }\n    }\n\n    fn relate(&mut self, x: usize, y: usize, z: i32) {\n        let (xp, dx) = self.get_parent_diff(x);\n        let (yp, dy) = self.get_parent_diff(y);\n\n        if xp != yp {\n            let sxp = self.size[xp];\n            let syp = self.size[yp];\n            if sxp < syp {\n                self.parent[xp] = Some(yp);\n                self.diff[xp] = z + dy - dx;\n                self.size[yp] = sxp + syp;\n            } else {\n                self.parent[yp] = Some(xp);\n                self.diff[yp] = dx - dy - z;\n                self.size[xp] = sxp + syp;\n            }\n        }\n    }\n\n    fn diff(&mut self, x: usize, y: usize) -> Option<i32> {\n        let (xp, dx) = self.get_parent_diff(x);\n        let (yp, dy) = self.get_parent_diff(y);\n        if xp != yp {\n            None\n        } else {\n            Some(dx - dy)\n        }\n    }\n}\n\nfn main() {\n    let nq: Vec<usize> = read_vec();\n    let n = nq[0];\n    let q = nq[1];\n\n    let coms: Vec<Vec<usize>> = read_vec2(q as u32);\n\n    let mut uf = UnionFind::new(n);\n\n    for cv in coms {\n        if cv[0] == 0 {\n            uf.relate(cv[1], cv[2], cv[3] as i32);\n        } else {\n            if let Some(d) = uf.diff(cv[1], cv[2]) {\n                println!(\"{}\", d);\n            } else {\n                println!(\"?\");\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! semigroup_impl {\n  ($marker:ty, $t:ty, | $lhs:pat, $rhs:pat | $append:expr) => {\n    impl $crate::math::algebra::Semigroup for $marker {\n      type T = $t;\n\n      fn append($lhs: &$t, $rhs: &$t) -> $t {\n        $append\n      }\n    }\n  };\n}\n\nmacro_rules! monoid_impl {\n  ($marker:ty, $t:ty, | $lhs:pat, $rhs:pat | $append:expr, $identity:expr) => {\n    semigroup_impl! { $marker, $t, |$lhs, $rhs| $append }\n\n    impl $crate::math::algebra::Monoid for $marker {\n      fn identity() -> $t {\n        $identity\n      }\n    }\n  };\n}\n\nmacro_rules! commutative_monoid_impl {\n  ($marker:ty, $t:ty, | $lhs:pat, $rhs:pat | $append:expr, $identity:expr) => {\n    monoid_impl! { $marker, $t, |$lhs, $rhs| $append, $identity }\n\n    impl $crate::math::algebra::CommutativeMonoid for $marker {}\n  };\n}\n\nmacro_rules! abelian_group_impl {\n  ($marker:ty, $t:ty, | $lhs:pat, $rhs:pat | $append:expr, | $x:pat | $invert:expr, $identity:expr) => {\n    commutative_monoid_impl! { $marker, $t, |$lhs, $rhs| $append, $identity }\n\n    impl $crate::math::algebra::AbelianGroup for $marker {\n      fn invert($x: &$t) -> $t {\n        $invert\n      }\n    }\n  };\n}\n\nfn solve<R: BufRead, W: Write>(_reader: R, _writer: &mut W) {\n  let mut _scanner = Scanner::new(_reader);\n\n  #[allow(unused_macros)]\n  macro_rules! scan {\n    ($t:ty) => {\n      _scanner.next::<$t>().unwrap()\n    };\n    ($($t:ty),+) => {\n      ($(scan!($t)),+)\n    };\n    ($t:ty; $n:expr $(; $m:expr)*) => {{\n      let mut vec = Vec::with_capacity($n);\n      for _ in 0..$n {\n        vec.push(scan!($t $(; $m)*));\n      }\n      vec\n    }};\n    ($t_0:ty, $t_1:ty; $n:expr) => {\n      scan!($t_0 = 0, $t_1 = 1; $n)\n    };\n    ($t_0:ty, $t_1:ty, $t_2:ty; $n:expr) => {\n      scan!($t_0 = 0, $t_1 = 1, $t_2 = 2; $n)\n    };\n    ($($t:ty = $i:tt),+; $n:expr) => {{\n      let mut vecs = ($(Vec::<$t>::with_capacity($n)),+);\n      for _ in 0..$n {$(\n        vecs.$i.push(scan!($t));\n      )+}\n      vecs\n    }};\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! scan_iter {\n    ($t:ty; $n:expr) => {\n      _scanner.take::<$t>($n).map(|x| x.unwrap())\n    };\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! print {\n    ($fmt:expr) => {\n      write!(_writer, $fmt).unwrap()\n    };\n    ($fmt:expr, $($arg:tt)*) => {\n      write!(_writer, $fmt, $($arg)*).unwrap()\n    };\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! println {\n    ($fmt:expr) => {\n      writeln!(_writer, $fmt).unwrap()\n    };\n    ($fmt:expr, $($arg:tt)*) => {\n      writeln!(_writer, $fmt, $($arg)*).unwrap()\n    };\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! eprint {\n    ($fmt:expr) => {\n      #[cfg(debug_assertions)]\n      write!(::std::io::stderr(), $fmt).unwrap()\n    };\n    ($fmt:expr, $($arg:tt)*) => {\n      #[cfg(debug_assertions)]\n      write!(::std::io::stderr(), $fmt, $($arg)*).unwrap()\n    };\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! eprintln {\n    ($fmt:expr) => {\n      #[cfg(debug_assertions)]\n      writeln!(::std::io::stderr(), $fmt).unwrap()\n    };\n    ($fmt:expr, $($arg:tt)*) => {\n      #[cfg(debug_assertions)]\n      writeln!(::std::io::stderr(), $fmt, $($arg)*).unwrap()\n    };\n  }\n\n  #[allow(unused_macros)]\n  macro_rules! dump {\n    ($($x:expr),+) => {\n      eprint!(\"[{}:{}] \", file!(), line!());\n      eprintln!(concat!($(stringify!($x), \" = {:?}; \"),+), $($x),+);\n    };\n  }\n\n  use data_structures::PotentializedUnionFindTree;\n  use math::algebra::AdditiveGroup;\n\n  let (n, q) = scan!(usize, usize);\n  let mut uf = PotentializedUnionFindTree::<AdditiveGroup<i64>>::new(n);\n\n  for _ in 0..q {\n    match scan!(usize) {\n      0 => {\n        let (x, y, z) = scan!(usize, usize, i64);\n        uf.unite(x, y, &z);\n      }\n      1 => {\n        let (x, y) = scan!(usize, usize);\n        match uf.potential_diff(x, y) {\n          Some(diff) => println!(\"{}\", diff),\n          None => println!(\"?\"),\n        };\n      }\n      _ => panic!(),\n    }\n  }\n}\n\nconst STACK_SIZE_MEBIBYTES: Option<usize> = None;\n\nfn main() {\n  fn run_solver() {\n    let stdin = stdin();\n    let stdout = stdout();\n    #[cfg(debug_assertions)]\n    let mut writer = stdout.lock();\n    #[cfg(not(debug_assertions))]\n    let mut writer = ::std::io::BufWriter::new(stdout.lock());\n    solve(stdin.lock(), &mut writer);\n    writer.flush().unwrap();\n  }\n  if let Some(size) = STACK_SIZE_MEBIBYTES {\n    let builder = ::std::thread::Builder::new().stack_size(size * 1024 * 1024);\n    builder.spawn(run_solver).unwrap().join().unwrap();\n  } else {\n    run_solver();\n  }\n}\n\nuse io::Scanner;\nuse std::io::{stdin, stdout, BufRead, Write};\n\npub mod math {\n  pub mod algebra {\n    pub use self::abelian_group::*;\n    pub use self::additive_group::*;\n    pub use self::commutative_monoid::*;\n    pub use self::monoid::*;\n    pub use self::semigroup::*;\n\n    mod semigroup {\n      use std::fmt::Debug;\n\n      pub trait Semigroup {\n        type T: Clone + Debug;\n\n        fn append(lhs: &Self::T, rhs: &Self::T) -> Self::T;\n\n        fn append_assign(lhs: &mut Self::T, rhs: &Self::T) {\n          *lhs = Self::append(lhs, rhs);\n        }\n      }\n    }\n\n    mod monoid {\n      use math::algebra::Semigroup;\n\n      pub trait Monoid: Semigroup {\n        fn identity() -> Self::T;\n      }\n    }\n\n    mod commutative_monoid {\n      use math::algebra::Monoid;\n\n      pub trait CommutativeMonoid: Monoid {}\n    }\n\n    mod abelian_group {\n      use math::algebra::CommutativeMonoid;\n\n      pub trait AbelianGroup: CommutativeMonoid {\n        fn invert(&Self::T) -> Self::T;\n\n        fn append_inverse(lhs: &Self::T, rhs: &Self::T) -> Self::T {\n          Self::append(lhs, &Self::invert(rhs))\n        }\n\n        fn append_inverse_assign(lhs: &mut Self::T, rhs: &Self::T) {\n          *lhs = Self::append_inverse(lhs, rhs);\n        }\n      }\n    }\n\n    mod additive_group {\n      use std::marker::PhantomData;\n\n      pub struct AdditiveGroup<T> {\n        _marker: PhantomData<fn() -> T>,\n      }\n\n      macro_rules! additive_group_impl {\n        ($($t:ty)+) => {$(\n          abelian_group_impl! { AdditiveGroup<$t>, $t, |&lhs, &rhs| lhs + rhs, |&x| -x, 0 }\n        )+};\n      }\n\n      additive_group_impl! { i32 i64 isize }\n    }\n  }\n}\n\npub mod data_structures {\n  pub use self::potentialized_union_find_tree::*;\n\n  pub mod potentialized_union_find_tree {\n    use math::algebra::AbelianGroup;\n    use std::mem::swap;\n\n    pub struct PotentializedUnionFindTree<G: AbelianGroup> {\n      nodes: Vec<PotentializedNode<G>>,\n    }\n\n    #[derive(Clone, Copy, Debug)]\n    enum Node {\n      Root { node_count: usize },\n      Descendant { parent_index: usize },\n    }\n\n    struct PotentializedNode<G: AbelianGroup> {\n      node: Node,\n      potential: G::T,\n    }\n\n    impl<G: AbelianGroup> PotentializedUnionFindTree<G> {\n      pub fn new(size: usize) -> Self {\n        let mut nodes = Vec::with_capacity(size);\n        for _ in 0..size {\n          nodes.push(PotentializedNode {\n            node: Node::Root { node_count: 1 },\n            potential: G::identity(),\n          });\n        }\n        PotentializedUnionFindTree { nodes: nodes }\n      }\n\n      pub fn len(&self) -> usize {\n        self.nodes.len()\n      }\n\n      pub fn unite(&mut self, l_index: usize, r_index: usize, potential_diff: &G::T) -> bool {\n        debug_assert!(l_index < self.len());\n        debug_assert!(r_index < self.len());\n        let mut l_root_index = self.find(l_index);\n        let mut r_root_index = self.find(r_index);\n        if l_root_index == r_root_index {\n          return false;\n        }\n        let l_potential = self.potential_diff(l_root_index, l_index).unwrap();\n        let r_potential = self.potential_diff(r_root_index, r_index).unwrap();\n        let mut potential_diff = G::append_inverse(&G::append(potential_diff, &l_potential), &r_potential);\n        match (self.nodes[l_root_index].node, self.nodes[r_root_index].node) {\n          (Node::Root { node_count: l_node_count }, Node::Root { node_count: r_node_count }) => {\n            let node_count = l_node_count + r_node_count;\n            if l_node_count < r_node_count {\n              swap(&mut l_root_index, &mut r_root_index);\n              potential_diff = G::invert(&potential_diff);\n            }\n            self.nodes[l_root_index] = PotentializedNode {\n              node: Node::Root { node_count: node_count },\n              potential: { G::identity() },\n            };\n            self.nodes[r_root_index] = PotentializedNode {\n              node: Node::Descendant { parent_index: l_root_index },\n              potential: potential_diff,\n            };\n          }\n          _ => unreachable!(\"`find` must return root index\"),\n        }\n        true\n      }\n\n      pub fn find(&mut self, index: usize) -> usize {\n        debug_assert!(index < self.len());\n        match self.nodes[index].node {\n          Node::Root { .. } => index,\n          Node::Descendant { parent_index } => {\n            let root_index = self.find(parent_index);\n            self.assert_parent_is_root(parent_index);\n            self.nodes[index] = PotentializedNode {\n              node: Node::Descendant { parent_index: root_index },\n              potential: G::append(&self.nodes[parent_index].potential, &self.nodes[index].potential),\n            };\n            root_index\n          }\n        }\n      }\n\n      pub fn is_same_group(&mut self, l_index: usize, r_index: usize) -> bool {\n        debug_assert!(l_index < self.len());\n        debug_assert!(r_index < self.len());\n        self.find(l_index) == self.find(r_index)\n      }\n\n      pub fn count_elements(&mut self, index: usize) -> usize {\n        debug_assert!(index < self.len());\n        let root_index = self.find(index);\n        match self.nodes[root_index].node {\n          Node::Root { node_count } => node_count,\n          _ => unreachable!(\"`find` must return root index\"),\n        }\n      }\n\n      pub fn potential_diff(&mut self, l_index: usize, r_index: usize) -> Option<G::T> {\n        debug_assert!(l_index < self.len());\n        debug_assert!(r_index < self.len());\n        if self.is_same_group(l_index, r_index) {\n          self.assert_parent_is_root(l_index);\n          self.assert_parent_is_root(r_index);\n          Some(G::append_inverse(&self.nodes[r_index].potential, &self.nodes[l_index].potential))\n        } else {\n          None\n        }\n      }\n\n      fn assert_parent_is_root(&self, index: usize) {\n        if cfg!(debug_assertion) {\n          if let Node::Descendant { parent_index } = self.nodes[index].node {\n            if let Node::Descendant { .. } = self.nodes[parent_index].node {\n              panic!(\"\"); // TODO\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npub mod io {\n  pub use self::from_bytes::*;\n  pub use self::scanner::*;\n\n  mod scanner {\n    use io::FromBytes;\n    use std::io::BufRead;\n    use std::marker::PhantomData;\n\n    pub struct Scanner<R> {\n      reader: R,\n      buffer: Vec<u8>,\n      position: usize,\n    }\n\n    impl<R: BufRead> Scanner<R> {\n      pub fn new(reader: R) -> Self {\n        Scanner { reader: reader, buffer: vec![], position: 0 }\n      }\n\n      pub fn next<T: FromBytes>(&mut self) -> Result<T, T::Err> {\n        FromBytes::from_bytes(self.next_bytes().unwrap_or(&[]))\n      }\n\n      pub fn take<T: FromBytes>(&mut self, n: usize) -> Take<R, T> {\n        Take { scanner: self, n: n, _marker: PhantomData }\n      }\n\n      pub fn next_bytes(&mut self) -> Option<&[u8]> {\n        if self.buffer.is_empty() {\n          self.read_line();\n        }\n        loop {\n          match self.buffer.get(self.position) {\n            Some(&b' ') => self.position += 1,\n            Some(&b'\\n') => self.read_line(),\n            Some(_) => break,\n            None => return None,\n          }\n        }\n        let start = self.position;\n        loop {\n          match self.buffer.get(self.position) {\n            Some(&b' ') | Some(&b'\\n') | None => break,\n            Some(_) => self.position += 1,\n          }\n        }\n        Some(&self.buffer[start..self.position])\n      }\n\n      fn read_line(&mut self) {\n        self.position = 0;\n        self.buffer.clear();\n        self.reader.read_until(b'\\n', &mut self.buffer).unwrap();\n      }\n    }\n\n    pub struct Take<'a, R: 'a, T> {\n      scanner: &'a mut Scanner<R>,\n      n: usize,\n      _marker: PhantomData<fn() -> T>,\n    }\n\n    impl<'a, R: BufRead, T: FromBytes> Iterator for Take<'a, R, T> {\n      type Item = Result<T, T::Err>;\n\n      fn next(&mut self) -> Option<Self::Item> {\n        if self.n > 0 {\n          self.n -= 1;\n          Some(self.scanner.next())\n        } else {\n          None\n        }\n      }\n\n      fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.n, Some(self.n))\n      }\n    }\n\n    impl<'a, R: BufRead, T: FromBytes> ExactSizeIterator for Take<'a, R, T> {}\n  }\n\n  mod from_bytes {\n    use misc::{ByteChar, ByteString};\n    use std::str;\n    use std::str::FromStr;\n\n    pub struct FromBytesError;\n\n    pub trait FromBytes: Sized {\n      type Err;\n\n      fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Err>;\n    }\n\n    impl FromBytes for ByteChar {\n      type Err = FromBytesError;\n\n      fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Err> {\n        if bytes.len() == 1 {\n          Ok(ByteChar(*unsafe { bytes.get_unchecked(0) }))\n        } else {\n          Err(FromBytesError)\n        }\n      }\n    }\n\n    impl FromBytes for ByteString {\n      type Err = FromBytesError;\n\n      fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Err> {\n        Ok(ByteString(bytes.iter().cloned().map(ByteChar).collect()))\n      }\n    }\n\n    impl<T: FromStr> FromBytes for T {\n      type Err = T::Err;\n\n      fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Err> {\n        let s = if cfg!(debug_assertions) { str::from_utf8(bytes).unwrap() } else { unsafe { str::from_utf8_unchecked(bytes) } };\n        T::from_str(s)\n      }\n    }\n  }\n}\n\npub mod misc {\n  pub use self::byte_char::*;\n  pub use self::byte_string::*;\n\n  mod byte_char {\n    use std::fmt::{Debug, Display, Error, Formatter};\n\n    #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]\n    pub struct ByteChar(pub u8);\n\n    impl Debug for ByteChar {\n      fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"b\\'{}\\'\", self.0 as char)\n      }\n    }\n\n    impl Display for ByteChar {\n      fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"{}\", self.0 as char)\n      }\n    }\n  }\n\n  mod byte_string {\n    use misc::ByteChar;\n    use std::fmt::{Debug, Display, Error, Formatter};\n\n    #[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]\n    pub struct ByteString(pub Vec<ByteChar>);\n\n    impl Debug for ByteString {\n      fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"b\\\"\")?;\n        for &c in &self.0 {\n          write!(f, \"{}\", c.0 as char)?;\n        }\n        write!(f, \"b\\\"\")\n      }\n    }\n\n    impl Display for ByteString {\n      fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        for &c in &self.0 {\n          write!(f, \"{}\", c.0 as char)?;\n        }\n        Ok(())\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n\n// ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n// diff: using Parser\n#[macro_export]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\nstruct WeightedUnionFind {\n    par: Vec<usize>,\n    rank: Vec<usize>,\n    diff_weight: Vec<i32>,\n}\nimpl WeightedUnionFind {\n    fn new(n: usize) -> WeightedUnionFind {\n        WeightedUnionFind {\n            par: (0..n).collect::<Vec<usize>>(),\n            rank: vec![0; n],\n            diff_weight: vec![0; n],\n        }\n    }\n\n    fn root(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n             return x;\n        } else {\n            let y = self.par[x];\n            let z = self.root(y);\n            self.diff_weight[x] += self.diff_weight[y];\n            self.par[x] = z;\n            return z;\n        }\n    }\n\n    fn weight(&mut self, x: usize) -> i32 {\n        self.root(x);\n        self.diff_weight[x]\n    }\n\n    fn same(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n\n    fn merge(&mut self, x: usize, y: usize, w: i32) -> bool {\n        let mut w = w;\n        w += self.weight(x);\n        w -= self.weight(y);\n\n        let mut a = self.root(x);\n        let mut b = self.root(y);\n\n        if a == b {\n            return false;\n        }\n\n        if self.rank[a] < self.rank[b] {\n            std::mem::swap(&mut a, &mut b);\n            w = -w;\n        }\n        assert!(self.rank[a] >= self.rank[b]);\n\n        if self.rank[a] == self.rank[b] {\n            self.rank[a] += 1;\n        }\n\n        self.par[b] = a;\n        self.diff_weight[b] = w;\n\n        return true\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize,\n        q: usize,\n    }\n    let mut uf = WeightedUnionFind::new(n);\n    for _ in 0 .. q {\n        input! {\n            parser = parser,\n            command: usize,\n        }\n        if command == 0 {\n            input! {\n                parser = parser,\n                a: usize,\n                b: usize,\n                d: i32\n            }\n            uf.merge(a, b, d);\n        } else {\n            input! {\n                parser = parser,\n                a: usize,\n                b: usize,\n            }\n            if !uf.same(a,b) {\n                println!(\"?\");\n            } else {\n                println!(\"{}\", uf.weight(b)-uf.weight(a));\n            }\n        }\n    }\n}\n\nuse std::io::BufRead;\nuse std::io;\nuse std::str;\n\n// ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n// ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n// diff: using std::io::BufRead::fill_buf()\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\n\nimpl<R:BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len,complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                (len, buf2[len-1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T:str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            }\n            else {\n                self.update_buf();\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::prelude::*;\nuse std::iter::repeat;\n\nstruct WeightedUnionFindTree(Vec<(usize, i64)>);\nimpl WeightedUnionFindTree {\n    fn new(n: usize) -> WeightedUnionFindTree {\n        WeightedUnionFindTree((0..n).zip(repeat(0)).collect())\n    }\n\n    fn diff(&mut self, n: usize) -> (usize, i64) {\n        let p = self.0[n].0;\n        if n != p {\n            let (newp, d) = self.diff(p);\n            self.0[n] = (newp, d + self.0[n].1);\n        }\n        self.0[n]\n    }\n\n    fn relate(&mut self, x: usize, y: usize, z: i64) {\n        let (px, dx) = self.diff(x);\n        let (py, dy) = self.diff(y);\n\n        self.0[py] = (px, z - (dy - dx));\n    }\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    let line0 = lines.next().unwrap().unwrap();\n    let n = line0.split_whitespace().next().unwrap().parse().unwrap();\n\n    let mut wuft = WeightedUnionFindTree::new(n);\n\n    for l in lines.map(Result::unwrap) {\n        let mut words = l.split_whitespace();\n        let com = words.next().unwrap().parse().unwrap();\n        let x = words.next().unwrap().parse().unwrap();\n        let y = words.next().unwrap().parse().unwrap();\n        match com {\n            0 => {\n                let z = words.next().unwrap().parse().unwrap();\n                wuft.relate(x, y, z);\n            }\n            1 => {\n                let (px, dx) = wuft.diff(x);\n                let (py, dy) = wuft.diff(y);\n                if px == py {\n                    println!(\"{}\", dy - dx);\n                } else {\n                    println!(\"?\");\n                }\n            }\n            _ => (),\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\nuse std::collections::VecDeque;\n\n#[allow(unused_macros)]\nmacro_rules! ite {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nstruct WeightedUnionFindNode {\n    parent: usize,\n    dist_to_parent: i64,\n    num: usize,\n}\n\nimpl WeightedUnionFindNode {\n    fn new(parent: usize) -> WeightedUnionFindNode {\n        WeightedUnionFindNode {\n            parent: parent,\n            dist_to_parent: 0,\n            num: 1,\n        }\n    }\n}\n\npub struct WeightedUnionFind(Vec<WeightedUnionFindNode>);\n\nimpl WeightedUnionFind {\n    pub fn new(n: usize) -> WeightedUnionFind {\n        let mut xs = vec![];\n        for i in 0..n {\n            xs.push(WeightedUnionFindNode::new(i));\n        }\n        WeightedUnionFind(xs)\n    }\n    pub fn root(&mut self, i: usize) -> (usize, i64) {\n        let parent = self.0[i].parent;\n        if parent == i {\n            (i, 0)\n        } else {\n            let (new_parent, dist_to_parent) = self.root(parent);\n            let new_dist_to_parent = self.0[i].dist_to_parent + dist_to_parent;\n            self.0[i].parent = new_parent;\n            self.0[i].dist_to_parent = new_dist_to_parent;\n            (new_parent, new_dist_to_parent)\n        }\n    }\n    pub fn unite(&mut self, i: usize, k: usize, w: i64) {\n        let (i,d_i) = self.root(i);\n        let (k,d_k) = self.root(k);\n        if i == k {\n            return;\n        }\n        if self.0[i].num < self.0[k].num {\n            let d = w - (d_i - d_k);\n            self.0[i].parent = k;\n            self.0[i].dist_to_parent = d;\n            self.0[k].num += self.0[i].num;\n        } else {\n            let d = -(w - (d_i - d_k));\n            self.0[k].parent = i;\n            self.0[k].dist_to_parent = d;\n            self.0[i].num += self.0[k].num;\n        }\n    }\n    pub fn is_same_set(&mut self, i: usize, k: usize) -> bool {\n        self.root(i).0 == self.root(k).0\n    }\n    pub fn dist(&mut self, i: usize, k: usize) -> Option<i64> {\n        let (ri, d_i) = self.root(i);\n        let (rk, d_k) = self.root(k);\n        if ri == rk {\n            Some(d_i - d_k)\n        }\n        else {\n            None\n        }\n    }\n}\n\n// ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n// diff: using Parser\n#[macro_export]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize,\n        q: usize,\n    }\n    let mut wuf = WeightedUnionFind::new(n);\n    for _ in 0..q {\n        input! {\n            parser = parser,\n            command: usize,\n        }\n        if command == 0 {\n            input! {\n                parser = parser,\n                i: usize,\n                k: usize,\n                w: i64,\n            }\n            wuf.unite(i, k, w);\n        } else {\n            input! {\n                parser = parser,\n                i: usize,\n                k: usize,\n            }\n            match wuf.dist(i, k) {\n                Some(d) => {\n                    println!(\"{}\", d);\n                }\n                None => {\n                    println!(\"?\");\n                }\n            }\n        }\n    }\n}\n\nuse std::io::BufRead;\nuse std::io;\nuse std::str;\n\n// ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n// ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n// diff: using std::io::BufRead::fill_buf()\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\n\nimpl<R:BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len,complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                (len, buf2[len-1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T:str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            }\n            else {\n                self.update_buf();\n            }\n        }\n    }\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!();\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!();\n}\n\n"
  }
]