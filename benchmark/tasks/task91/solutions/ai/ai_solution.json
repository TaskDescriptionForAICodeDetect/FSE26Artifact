[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, cost;\n} Bridge;\n\nint parent[100000];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_set(int u, int v) {\n    int root_u = find(u);\n    int root_v = find(v);\n    if (root_u != root_v) {\n        parent[root_v] = root_u;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Bridge *bridgeA = (Bridge *)a;\n    Bridge *bridgeB = (Bridge *)b;\n    return bridgeA->cost - bridgeB->cost;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Bridge bridges[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &bridges[i].u, &bridges[i].v, &bridges[i].cost);\n    }\n\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n    }\n\n    qsort(bridges, m, sizeof(Bridge), compare);\n\n    int total_cost = 0;\n    for (int i = 0; i < m; i++) {\n        int u = bridges[i].u;\n        int v = bridges[i].v;\n        if (find(u) != find(v)) {\n            union_set(u, v);\n            total_cost += bridges[i].cost;\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, cost;\n        \n        Edge(int src, int dest, int cost) {\n            this.src = src;\n            this.dest = dest;\n            this.cost = cost;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    static int[] parent;\n    \n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n    \n    public static int minimumMaintenanceCost(int n, int m, int[][] bridges) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        List<Edge> edges = new ArrayList<>();\n        for (int[] bridge : bridges) {\n            edges.add(new Edge(bridge[0], bridge[1], bridge[2]));\n        }\n        \n        Collections.sort(edges);\n        \n        int totalCost = 0;\n        for (Edge edge : edges) {\n            if (find(edge.src) != find(edge.dest)) {\n                union(edge.src, edge.dest);\n                totalCost += edge.cost;\n            }\n        }\n        \n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 18:34:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Bridge {\n    int u, v, cost;\n    bool operator<(const Bridge &other) const {\n        return cost < other.cost;\n    }\n};\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Bridge> bridges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> bridges[i].u >> bridges[i].v >> bridges[i].cost;\n    }\n    sort(bridges.begin(), bridges.end());\n    \n    parent.resize(n);\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n    \n    int total_cost = 0;\n    for (const Bridge &bridge : bridges) {\n        if (find(bridge.u) != find(bridge.v)) {\n            unite(bridge.u, bridge.v);\n            total_cost += bridge.cost;\n        }\n    }\n    \n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_CITIES 100005\n\nint parent[MAX_CITIES];\nint rank[MAX_CITIES];\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compareEdges(const void* a, const void* b) {\n    Edge* edgeA = (Edge*)a;\n    Edge* edgeB = (Edge*)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nvoid makeSet(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint findSet(int x) {\n    if (parent[x] != x) {\n        parent[x] = findSet(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSets(int x, int y) {\n    int rootX = findSet(x);\n    int rootY = findSet(y);\n\n    if (rootX == rootY) return;\n\n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint minimumMaintenanceCost(int n, int m, Edge* edges) {\n    qsort(edges, m, sizeof(Edge), compareEdges);\n    makeSet(n);\n\n    int totalCost = 0;\n    int edgesUsed = 0;\n\n    for (int i = 0; i < m; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n\n        if (findSet(u) != findSet(v)) {\n            unionSets(u, v);\n            totalCost += cost;\n            edgesUsed++;\n        }\n    }\n\n    return (edgesUsed == n - 1) ? totalCost : -1;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge* edges = malloc(m * sizeof(Edge));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n    }\n\n    int result = minimumMaintenanceCost(n, m, edges);\n    printf(\"%d\\n\", result);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) return;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n};\n\nint minimumMaintenanceCost(int n, vector<vector<int>>& bridges) {\n    sort(bridges.begin(), bridges.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[2] < b[2];\n    });\n\n    DisjointSet ds(n);\n    int totalCost = 0;\n\n    for (const auto& bridge : bridges) {\n        int u = bridge[0], v = bridge[1], cost = bridge[2];\n\n        if (ds.find(u) != ds.find(v)) {\n            ds.unite(u, v);\n            totalCost += cost;\n        }\n    }\n\n    int connectedComponents = 0;\n    for (int i = 0; i < n; i++) {\n        if (ds.find(i) == i) {\n            connectedComponents++;\n        }\n    }\n\n    return connectedComponents > 1 ? -1 : totalCost;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> bridges(m, vector<int>(3));\n    for (int i = 0; i < m; i++) {\n        cin >> bridges[i][0] >> bridges[i][1] >> bridges[i][2];\n    }\n\n    int result = minimumMaintenanceCost(n, bridges);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Bridge implements Comparable<Bridge> {\n    int src, dest, cost;\n\n    public Bridge(int src, int dest, int cost) {\n        this.src = src;\n        this.dest = dest;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Bridge other) {\n        return this.cost - other.cost;\n    }\n}\n\npublic class Main {\n    private static int[] parent;\n\n    private static int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    private static boolean union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV) {\n            return false;\n        }\n        parent[rootV] = rootU;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n\n        PriorityQueue<Bridge> pq = new PriorityQueue<>();\n        for (int i = 0; i < m; i++) {\n            int src = scanner.nextInt();\n            int dest = scanner.nextInt();\n            int cost = scanner.nextInt();\n            pq.add(new Bridge(src, dest, cost));\n        }\n\n        int totalCost = 0;\n        int edgesUsed = 0;\n\n        while (!pq.isEmpty() && edgesUsed < n - 1) {\n            Bridge bridge = pq.poll();\n            if (union(bridge.src, bridge.dest)) {\n                totalCost += bridge.cost;\n                edgesUsed++;\n            }\n        }\n\n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 18:35:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find(parent, i):\n    if parent[i] == i:\n        return i\n    else:\n        return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rank[rootX] < rank[rootY]:\n        parent[rootX] = rootY\n    elif rank[rootX] > rank[rootY]:\n        parent[rootY] = rootX\n    else:\n        parent[rootY] = rootX\n        rank[rootX] += 1\n\ndef min_cost_to_connect_cities(n, m, bridges):\n    parent = [i for i in range(n)]\n    rank = [0 for _ in range(n)]\n    bridges.sort(key=lambda x: x[2])\n    mst_cost = 0\n    edges_used = 0\n\n    for u, v, cost in bridges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, find(parent, u), find(parent, v))\n            mst_cost += cost\n            edges_used += 1\n            if edges_used == n - 1:\n                break\n\n    return mst_cost\n\n# Example usage:\nn = 4\nm = 5\nbridges = [\n    (0, 1, 10),\n    (0, 2, 6),\n    (0, 3, 5),\n    (1, 3, 15),\n    (2, 3, 4)\n]\nprint(min_cost_to_connect_cities(n, m, bridges))  # Output: 19",
    "timestamp": "2025-08-12 23:54:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WaterDeven {\n    static class Bridge implements Comparable<Bridge> {\n        int city1, city2, cost;\n\n        Bridge(int city1, int city2, int cost) {\n            this.city1 = city1;\n            this.city2 = city2;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Bridge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    public static int findParent(int[] parent, int city) {\n        if (parent[city] != city) {\n            parent[city] = findParent(parent, parent[city]);\n        }\n        return parent[city];\n    }\n\n    public static void union(int[] parent, int[] rank, int city1, int city2) {\n        int root1 = findParent(parent, city1);\n        int root2 = findParent(parent, city2);\n\n        if (rank[root1] > rank[root2]) {\n            parent[root2] = root1;\n        } else if (rank[root1] < rank[root2]) {\n            parent[root1] = root2;\n        } else {\n            parent[root2] = root1;\n            rank[root1]++;\n        }\n    }\n\n    public static int minimizeCost(int n, int m, int[][] bridges) {\n        List<Bridge> bridgeList = new ArrayList<>();\n        for (int[] bridgeData : bridges) {\n            bridgeList.add(new Bridge(bridgeData[0], bridgeData[1], bridgeData[2]));\n        }\n        \n        Collections.sort(bridgeList);\n\n        int[] parent = new int[n];\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        int minCost = 0;\n        int edgesUsed = 0;\n\n        for (Bridge bridge : bridgeList) {\n            if (findParent(parent, bridge.city1) != findParent(parent, bridge.city2)) {\n                minCost += bridge.cost;\n                union(parent, rank, bridge.city1, bridge.city2);\n                edgesUsed++;\n                if (edgesUsed == n - 1) {\n                    break;\n                }\n            }\n        }\n\n        return minCost;\n    }\n\n    public static void main(String[] args) {\n        int n = 4; \n        int m = 5; \n        int[][] bridges = {\n            {0, 1, 10},\n            {0, 2, 6},\n            {0, 3, 5},\n            {1, 3, 15},\n            {2, 3, 4}\n        };\n\n        System.out.println(minimizeCost(n, m, bridges));\n    }\n}",
    "timestamp": "2025-08-12 23:54:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int src, dest, cost;\n} Bridge;\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int parent[], int rank[], int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n\n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint compare(const void* a, const void* b) {\n    return ((Bridge*)a)->cost - ((Bridge*)b)->cost;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Bridge bridges[m];\n    \n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &bridges[i].src, &bridges[i].dest, &bridges[i].cost);\n    }\n    \n    qsort(bridges, m, sizeof(Bridge), compare);\n    \n    int parent[n], rank[n];\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    int mstCost = 0, edgesUsed = 0;\n    for (int i = 0; i < m && edgesUsed < n - 1; i++) {\n        int u = find(parent, bridges[i].src);\n        int v = find(parent, bridges[i].dest);\n        \n        if (u != v) {\n            mstCost += bridges[i].cost;\n            unionSet(parent, rank, u, v);\n            edgesUsed++;\n        }\n    }\n    \n    printf(\"%d\\n\", mstCost);\n    return 0;\n}",
    "timestamp": "2025-08-12 23:54:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_maintenance_cost(n, m, bridges):\n    # Sort bridges by maintenance cost\n    bridges.sort(key=lambda x: x[2])\n    \n    # Initialize disjoint set\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    connected_bridges = 0\n    \n    for u, v, cost in bridges:\n        if union(u, v):\n            total_cost += cost\n            connected_bridges += 1\n            \n            # Minimum spanning tree is complete\n            if connected_bridges == n - 1:\n                break\n    \n    return total_cost",
    "timestamp": "2025-08-12 23:54:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        else:\n            self.parent[y_root] = x_root\n            if self.rank[x_root] == self.rank[y_root]:\n                self.rank[x_root] += 1\n        return True\n\ndef minimum_maintenance_cost(n, m, bridges):\n    bridges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    total_cost = 0\n    for u, v, cost in bridges:\n        if uf.union(u, v):\n            total_cost += cost\n    return total_cost\n\n# Sample usage:\n# n, m = map(int, input().split())\n# bridges = []\n# for _ in range(m):\n#     u, v, cost = map(int, input().split())\n#     bridges.append((u, v, cost))\n# print(minimum_maintenance_cost(n, m, bridges))",
    "timestamp": "2025-08-12 23:54:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Bridge {\n    int u, v, cost;\n    bool operator<(const Bridge& other) const {\n        return cost < other.cost;\n    }\n};\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n    \n    bool unite(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV) return false;\n        \n        if (rank[rootU] < rank[rootV]) {\n            swap(rootU, rootV);\n        }\n        \n        parent[rootV] = rootU;\n        if (rank[rootU] == rank[rootV]) {\n            rank[rootU]++;\n        }\n        \n        return true;\n    }\n    \nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Bridge> bridges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> bridges[i].u >> bridges[i].v >> bridges[i].cost;\n    }\n    \n    sort(bridges.begin(), bridges.end());\n    \n    UnionFind uf(n);\n    int totalCost = 0;\n    \n    for (const Bridge& bridge : bridges) {\n        if (uf.unite(bridge.u, bridge.v)) {\n            totalCost += bridge.cost;\n        }\n    }\n    \n    cout << totalCost << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:51:45"
  }
]