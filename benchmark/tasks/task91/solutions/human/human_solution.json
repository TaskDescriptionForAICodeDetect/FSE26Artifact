[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.mutable\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val N, M = sc.nextInt\n    if (N != 0 || M != 0) {\n      val list = Array.fill[List[(Int, Int)]](N)(List[(Int, Int)]())\n      for (i <- 0 until M) {\n        val a, b, cost = sc.nextInt\n        list(a) :+= (b, cost)\n        list(b) :+= (a, cost)\n      }\n      val que = mutable.PriorityQueue.empty[(Int, Int)](implicitly[Ordering[(Int, Int)]].reverse)\n      que.enqueue((0, 0))\n      val flag = Array.fill[Boolean](N)(false)\n      var ans = 0\n      while (que.length != 0) {\n        val now = que.dequeue()\n        if (!flag(now._2)) {\n          flag(now._2) = true\n          ans += now._1\n          for (next <- list(now._2)) {\n            if (!flag(next._1)) {\n              que.enqueue((next._2, next._1))\n            }\n          }\n        }\n      }\n      println(ans)\n      solve(sc)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n    solve(sc)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  def solve: Unit = {\n    val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n    if (n == 0) return\n    val cities = Array.tabulate(n){_ ⇒ new UnionFindTree}\n    var cost = 0\n    for ((a, b, c) ← Array.tabulate(m){_ ⇒\n      val Array(a, b, cost) = readLine.trim.split(' ').map(_.toInt)\n      (a, b, cost)\n    }.sortBy(_._3)){\n      if (!cities(a).isSameUnion(cities(b))){\n        cities(a).merge(cities(b))\n        cost += c\n      }\n    }\n    println(cost)\n    solve\n  }\n  class UnionFindTree{\n    private var mParent: Option[UnionFindTree] = None\n    private var mSize: Int = 1\n    private def parent: UnionFindTree = {\n      mParent.map{_.parent} match {\n        case None ⇒ this\n        case c@Some(p) ⇒\n          mParent = c\n          p\n      }\n    }\n    def isSameUnion(that: UnionFindTree): Boolean = {\n      parent == that.parent\n    }\n    def merge(that: UnionFindTree): Unit = {\n      if (!isSameUnion(that)){\n        val p = parent\n        val tp = that.parent\n        if (p.mSize > tp.mSize){\n          tp.mParent = Some(p)\n          p.mSize += tp.mSize\n        }else {\n          p.mParent = Some(tp)\n          tp.mSize += p.mSize\n        }\n      }\n    }\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nconst int MAX_N = 100, MAX_M = 100, INF = 1 << 24;\nint n, m;\nint cost[MAX_N][MAX_N], mincost[MAX_N], used[MAX_N];\n\nint prim(){\n\tstd::fill(mincost, mincost+MAX_N, INF);\n\tstd::fill(used, used+MAX_N, 0);\n\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmincost[i] = std::min(mincost[i], cost[v][i]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\twhile(std::cin >> n >> m, n){\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tstd::fill(cost[i], cost[i]+MAX_N, INF);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a, b, c;\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tstd::cout << prim() << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/02/15 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nstruct bridge{\n\tint a;\n\tint b;\n\tint c;\n\tbool chk;\n};\n\nint main()\n{\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)\n\t\t\tbreak;\n\n\t\tstruct bridge brd[4950];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> brd[i].a >> brd[i].b >> brd[i].c;\n\t\t\tbrd[i].chk = false;\n\t\t}\n\n\t\tint ttl = 0;\n\t\tint num = m;\n\t\twhile(num>0){\n\t\t\tint i_min = -1;\n\t\t\tint c_min = 200;\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(brd[i].chk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(brd[i].c<c_min){\n\t\t\t\t\ti_min = i;\n\t\t\t\t\tc_min = brd[i].c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tttl += brd[i_min].c;\n\t\t\tint n_fr = brd[i_min].a;\n\t\t\tint n_to = brd[i_min].b;\n\t\t\tbrd[i_min].chk = true;\n\t\t\tnum--;\n\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(brd[i].chk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(brd[i].a==n_fr)\n\t\t\t\t\tbrd[i].a = n_to;\n\t\t\t\telse if(brd[i].b==n_fr)\n\t\t\t\t\tbrd[i].b = n_to;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t\tif(brd[i].a==brd[i].b){\n\t\t\t\t\tbrd[i].chk = true;\n\t\t\t\t\tnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ttl << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m && n + m != 0){\n    priority_queue<pair<int,edge>,vector<P>,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n\n    UnionFind u(m);\n    int cost = 0;\n    for (int i = 0; i < n-1; ++i){\n      edge top = que.top().second;\n      int topCost = que.top().first;\n      que.pop();\n      if(u.unionSet(top.from,top.to)){\n\tcost += topCost;\n\tcout << \"cost:\" << topCost << \" \" << top.from << \",\" <<top.to << endl;\n      }\n    }\n    cout << cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nstruct Edge\n{\n\tint src, dst;\n\tint weight;\n\tEdge(int src, int dst, int weight) : src(src), dst(dst), weight(weight) {}\n\n\tbool operator< (const Edge& e)const\n\t{\n\t\treturn weight != e.weight ? weight > e.weight :\n\t\t\tsrc != e.src ? src < e.src : dst < e.dst;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind\n{\n\tvi data;\n\n\tUnionFind(int size) : data(size, -1) {}\n\n\t// xツづツづ個集ツ債づーツ閉ケツ債つキツづゥ\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])\n\t\t\t\tswap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\n\t// xツづツづ個集ツ債つェツ督卍つオツつ「ツつゥツ偲ヲツ督セツつキツづゥ\n\tbool findSet(int x, int y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x)\n\t{\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x)\n\t{\n\t\treturn -data[root(x)];\n\t}\n};\n\npair<int, Edges> Kruskal(const Graph& g)\n{\n\tint n = g.size();\n\tUnionFind uf(n);\n\tpriority_queue<Edge> Q;\n\n\trep(i, n) rep(j, g[i].size())\n\t\tif(i < g[i][j].dst)\n\t\t\tQ.push(g[i][j]);\n\n\tint total = 0;\n\tEdges F;\n\twhile(F.size() < n-1 && !Q.empty()){\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif(uf.unionSet(e.src, e.dst)){\n\t\t\tF.push_back(e);\n\t\t\ttotal += e.weight;\n\t\t}\n\t}\n\treturn pair<int, Edges>(total, F);\n}\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b, cost;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &cost);\n\t\t\tg[a].push_back(Edge(a, b, cost));\n\t\t\tg[b].push_back(Edge(b, a, cost));\n\t\t}\n\n\t\tpair<int, Edges> result = Kruskal(g);\n\t\tprintf(\"%d\\n\", result.first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal() << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nstruct Edge\n{\n\tint src, dst;\n\tint weight;\n\tEdge(int src, int dst, int weight) : src(src), dst(dst), weight(weight) {}\n\n\tbool operator< (const Edge& e)const\n\t{\n\t\treturn weight != e.weight ? weight > e.weight :\n\t\t\tsrc != e.src ? src < e.src : dst < e.dst;\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind\n{\n\tvi data;\n\n\tUnionFind(int size) : data(size, -1) {}\n\n\t// xツづツづ個集ツ債づーツ閉ケツ債つキツづゥ\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])\n\t\t\t\tswap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\n\t// xツづツづ個集ツ債つェツ督卍つオツつ「ツつゥツ偲ヲツ督セツつキツづゥ\n\tbool findSet(int x, int y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x)\n\t{\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x)\n\t{\n\t\treturn -data[root(x)];\n\t}\n};\n\npair<int, Edges> Kruskal(const Graph& g)\n{\n\tint n = g.size();\n\tUnionFind uf(n);\n\tpriority_queue<Edge> Q;\n\n\trep(i, n) rep(j, g[i].size())\n\t\tif(i < g[i][j].dst)\n\t\t\tQ.push(g[i][j]);\n\n\tint total = 0;\n\tEdges F;\n\twhile(F.size() < n-1 && !Q.empty()){\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tprintf(\"%d %d %d\\n\", e.src, e.dst, e.weight);\n\t\tif(uf.unionSet(e.src, e.dst)){\n\t\t\tF.push_back(e);\n\t\t\ttotal += e.weight;\n\t\t}\n\t}\n\treturn pair<int, Edges>(total, F);\n}\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b, cost;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &cost);\n\t\t\tg[a].push_back(Edge(a, b, cost));\n\t\t\tg[b].push_back(Edge(b, a, cost));\n\t\t}\n\n\t\tpair<int, Edges> result = Kruskal(g);\n\t\tprintf(\"%d\\n\", result.first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1){\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    rep(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x){\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]); // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 二つのデータx, yが属する木をマージする\n  void unite(int x, int y){\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y)  return;\n\n    // xの木がyの木より大きくなるようにする\n\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n\nstruct Edge\n{\n  int a, b, cost;\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n; //頂点数\n  vector<Edge> es; //辺集合\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  int kruskal(){\n    // コストが小さい順にソート\n    sort(es.begin(), es.end());\n\n    UnionFind uf(n);\n    int min_cost = 0;\n\n    rep(ei, es.size()){\n      Edge& e = es[ei];\n      if(!uf.same(e.a, e.b)){\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\nGraph input_graph(int k, int l){\n  Graph g;\n  int m;\n  g.n = k;\n  m = l;\n  rep(i, m) {\n    Edge e;\n    cin >> e.a >> e.b >> e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  Graph g;\n  while((cin >> n >> m) && n){\n    g = input_graph(n, m);\n    cout << g.kruskal() << endl;\n  }\n\n  \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[1001],f[1001],g[1001],h,i,j,size[1001],ban[1001];\n\tint z,x,q;\n\twhile(1){\n\t\tq=0;\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<a;i++){\n\t\t\tban[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\t\tfor(j=i+1;j<s;j++){\n\t\t\t\tif(g[i]>g[j]){\n\t\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tz=d[i]; x=f[i];\n\t\t\twhile(ban[z]!=z) z=ban[z];\n\t\t\twhile(ban[x]!=x) x=ban[x];\n\t\t\tif(z!=x){\n\t\t\t\tq+=g[i];\n\t\t\t\tif(size[z]>size[x]) ban[z]=x;\n\t\t\t\telse if(size[z]<size[x]) ban[x]=z;\n\t\t\t\telse{\n\t\t\t\t\tban[x]=z;\n\t\t\t\t\tsize[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {  \n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : \n    (e.src != f.src ? e.src < f.src : e.dst < f.dst);\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );    \n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    for(auto f : g[e.dst]){\n        if(!visited[f.dst]) Q.push(f);\n    }\n  }\n  T.erase(T.begin());\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n    while(1){\n        int n, m; cin >> n >> m;\n        if(n==0) break;\n        Graph g(n);\n        int a, b, cost;\n        for(int i=0; i<m; i++){\n            cin >> a >> b >> cost;\n            g[a].push_back(Edge(a, b, cost));\n            g[b].push_back(Edge(b, a, cost));\n        }\n\n        cout << prim(g).first << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint P[10010];\nvoid init(int N){\n    for(int i=0;i<=N;i++)\n        P[i] = i;\n}\nint root(int a){\n    if(P[a]==a)\n        return a;\n    return(P[a] = root(P[a]));\n}\nbool is_same_set(int a, int b){\n    return root(a) == root(b);\n}\nvoid unit(int a, int b){\n    P[root(a)] = root(b);\n}\n\nint main(){\n    int n; cin >> n;\n    pair<int, pair<int,int> > a;\n    vector< pair<int, pair<int,int> > > e;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            int x; cin >> x;\n            if(x!=-1){\n                e.push_back(make_pair(x, make_pair(i,j)));\n            }\n        }\n    }\n    sort(e.begin(),e.end());\n    int ans = 0;\n    init(n);\n    for(vector< pair<int, pair<int,int> > >::iterator it = e.begin();it != e.end();it++){\n        int s = it->second.first;\n        int g = it->second.second;\n        if(!is_same_set(s,g)){\n            unit(s,g);\n            ans += it->first;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n\n#define MAX_V 110\n#define INF 1000000\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v){\n    os << \"{ \";\n    for(typename vector<T>::const_iterator it=v.begin(); it!=v.end(); ++it)\n        os << '\\\"' << *it << '\\\"' << (it+1==v.end() ? \"\" : \", \");\n    os << \" }\";\n    return os;\n}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n#define vv(type,w,h,init) vector<vector<type>>(h,vector<type>(w,init))\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef unsigned uint;\ntypedef unsigned long ul;\ntypedef unsigned long long ull;\n\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define mp make_pair\n\nstring const resstr[] = {\"Impossible\",\"Possible\",\"No\",\"Yes\"};\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prom(){\n\tfor(int i=0; i < V; ++i){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\trep(u,V)\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\t\n\t}\n\treturn res;\n}\n\nint main(){\n\tint E;\n\twhile(cin >> V >> E, V+E){\n\t\trep(i, V)\n\t\t\trep(j, V) cost[i][j] = INF;\n\t\n\t\trep(i, E){\n\t\t\tint a, b ,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tcout << prom() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// デブンキー一家の大活躍.cpp : Defines the entry point for the console application.\n//\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nbool check(bool a[], int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(void)\n{\n\tint result[1000], suffix = 0;\n\n\twhile (1) {\n\t\tint ncity, nbridge, glaph[100][100] = { 0 };\n\n\t\tscanf(\"%d %d\", &ncity, &nbridge);\n\t\tif (ncity == 0 && nbridge == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint a, b, value;\n\t\tfor (int i = 0; i < nbridge; i++) {\n\t\t\tscanf(\"%d %d %d\", &a, &b, &value);\n\t\t\tglaph[a][b] = value;\n\t\t\tglaph[b][a] = value;\n\t\t}\n\n\t\tint min, cost = 0, s;\n\t\tbool visit[100] = { false };\n\t\tvisit[0] = true;\n\n\t\tint count = 0;\n\t\twhile (check(visit, ncity) == false) {\n\t\t\tmin = 100;\n\t\t\tfor (int i = 0; i < ncity; i++) {\n\t\t\t\tif (visit[i] == true) { //始点\n\t\t\t\t\tfor (int j = 0; j < ncity; j++) { //隣接点\n\t\t\t\t\t\tif (glaph[i][j] != 0 && visit[j] == false) {\n\t\t\t\t\t\t\tif (min > glaph[i][j]) {\n\t\t\t\t\t\t\t\tmin = glaph[i][j];\n\t\t\t\t\t\t\t\ts = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvisit[s] = true;\n\t\t\tcost += min;\n\t\t}\n\n\t\tresult[suffix++] = cost;\n\t}\n\n\tfor (int i = 0; i < suffix; i++) {\n\t\tprintf(\"%d\\n\", result[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\n\nstruct Unionfind{\n    vector<int> parents;\n    int n;\n    Unionfind(int n):n(n),parents(n,-1){ }\n\n    int find(int x){\n        if(parents[x] < 0) return x;\n        else return parents[x] = find(parents[x]);\n    }\n\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n\n        if(x==y) return;\n        if(parents[x] > parents[y]) swap(x,y);\n        parents[x] += parents[y];\n        parents[y] = x;\n    }  \n\n   int size(int x){\n       return -parents[find(x)];\n   }\n\n   bool same(int x,int y){\n       return find(x) == find(y);\n   }\n\n   vector<int> members(int x){\n       int root = find(x);\n       vector<int> member;\n       for(int i=0;i<n;i++){\n           if(find(i)==root){\n               member.push_back(i);\n           }\n       }\n      return member;\n  }\n\n  int group_cnt(){\n      int c = 0;\n      rep(i,n){\n          if(parents[i] < 0) ++c;\n      }\n      return c;\n  }\n};\n\nstruct edge{\n    int from,to,cost;  \n};\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 && m == 0) break;\n        vector<edge> eg;\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            eg.push_back(edge{a,b,c});\n        }\n\n        sort(eg.begin(),eg.end(),[](const edge &l,const edge &r){\n            return l.cost < r.cost;\n        });\n\n        Unionfind uf(n);\n        int ans = 0;\n\n        rep(i,eg.size()){\n            if(uf.same(eg[i].from,eg[i].to)) continue;\n            uf.unite(eg[i].from,eg[i].to);\n            ans += eg[i].cost;\n        }\n        \n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_E 1001\n#define MAX_N 101\n\nstruct Edge {\n  int u, v, cost;\n};\n\nEdge es[MAX_E];\nint n, m;\nint par[MAX_N], rank[MAX_N];\n\nvoid init_union_find() {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nbool issame(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool comp(const Edge &e1, const Edge &e2 ) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + m, comp);\n  init_union_find();\n  int res = 0;\n  for(int i=0; i<m; i++) {\n    Edge e = es[i];\n    if(!issame(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> n >> m && n+m) {\n    for(int i=0; i<m; i++) {\n      cin >> es[i].u >> es[i].v >> es[i].cost;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 99999999;\nint cost[101][101];\nint mincost[101];\nbool used[101];\nint n, m;\n\nint prim()\n{\n\tfor(int u = 0; u < 101; ++u)\n\t{\n\t\tmincost[u] = INF;\n\t\tused[u] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; ++u)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\tif(v == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int u = 0; u < n; ++u)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> n >> m, n || m)\n\t{\n\t\tfor(int i = 0; i < 101; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 101; ++j)\n\t\t\t{\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n//disjoint-set\nint parent[100];\n\nvoid init(int n){\n  for(int i=0; i<n; i++) parent[i]=i;\n}\n\nint root(int a){\n  if (parent[a] == a) return a;\n  return (parent[a] = root(parent[a]));\n}\n\nbool same_set_p(int a,int b){\n  return root(a) == root(b);\n}\n\nvoid unite(int a,int b){\n  parent[root(a)] = root(b);\n}\n\n//graph\nclass Edge{\npublic:\n  int cost,a,b;\n  Edge(int c=0,int d=0,int e=0):cost(c),a(d),b(e){}\n  bool operator< (const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n//main\nint n,m;\nEdge graph[100];\n\nint main(){\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(int i=0; i<m; i++){\n      int a,b,cost;\n      scanf(\"%d %d %d\",&a,&b,&cost);\n      graph[i] = Edge(cost,a,b);\n    }\n\n    sort(graph,graph+m);\n\n    int answer=0;\n    init(n);\n\n    for(int i=0; i<m; i++){\n      Edge e = graph[i];\n      if(!same_set_p(e.a,e.b)){\n\tanswer += e.cost;\n\tunite(e.a,e.b);\n      }\n    }\n\n    printf(\"%d\\n\",answer);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int c) { to = a; cost = c; }\n  int to, cost;\n};\n\nint n, m;\nvector<Edge> g[100];\n\nint prim() {\n  minPQ<pii> q;\n  bool vis[100] = {};\n  \n  q.emplace(0, 0);\n  int res = 0;\n  while (q.size()) {\n    auto t = q.top(); q.pop();\n    if (vis[t.Se]) continue;\n    vis[t.Se] = true;\n    res += t.Fi;\n    for (auto e : g[t.Se]) {\n      q.emplace(e.cost, e.to);\n    }\n  }\n\n  return res;\n}\n\nsigned main() {\n  while (cin >> n >> m, n || m) {\n    fill(ALL(g), vector<Edge>());\n    REP(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      g[a].eb(b, c);\n      g[b].eb(a, c);\n    }\n    print(prim());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(const Graph& g,vector<Edge>& forest)\n{\n\tforest.clear();\n\t\n\tvector<Edge> es;\n\trep(i,g.size()) rep(j,g[i].size())\n\t\tes.push_back(g[i][j]);\n\tsort(all(es));\n\t\n\tUnionFind uf(g.size());\n\tint res=0;\n\trep(i,es.size())\n\t\tif(uf.Find(es[i].src)!=uf.Find(es[i].dst)){\n\t\t\tuf.Unite(es[i].src,es[i].dst);\n\t\t\tres+=es[i].weight;\n\t\t\tforest.push_back(es[i]);\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint s,d,w; scanf(\"%d%d%d\",&s,&d,&w);\n\t\t\tg[s].push_back(Edge(s,d,w));\n\t\t\tg[d].push_back(Edge(d,s,w));\n\t\t}\n\t\t\n\t\tvector<Edge> forest;\n\t\tint res=Kruskal(g,forest);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Stellar Performance of the Debunkey Family\n#include<iostream>\n#include<vector>\n#include<set>\n#include<climits>\nusing namespace std;\n\n#define NONE 0\n\nint prim(int n, vector< vector<int> >v)\n{\n  set<int>selected;\n  set<int>::iterator it;\n  int mincost,mini;\n  int i;\n  int ans=0;\n\n  selected.insert(0);\n\n  while(selected.size()!=n){\n    mincost=INT_MAX;\n    mini=NONE;\n\n    for(it=selected.begin();it!=selected.end();it++){\n      for(i=0;i<n;i++){\n\tif(selected.find(i)!=selected.end())continue;\n\tif(v[*it][i]==NONE)continue;\n\tif(v[*it][i]>=mincost)continue;\n\tmincost=v[*it][i];\n\tmini=i;\n      }\n    }\n\n    if(mini==NONE)break;\n    selected.insert(mini);\n    ans+=mincost;\n  }\n\n  return ans;\n}\n\nint main()\n{\n  int n,m,a,b,cost;\n  int i;\n  while(cin>>n>>m,n|m){\n    vector< vector<int> >v(n,vector<int>(n,NONE));\n    for(i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      v[a][b]=v[b][a]=cost;\n    }\n    cout<<prim(n,v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[1000];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nlong long prim(int V, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[0] = 0; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<int, long long> pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; used[a2] = true;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint to = X[a2][i].first; long long leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && !used[to]) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 0; i < V; i++) sum += dist[i];\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<int, long long> > G[100];\nint main() {\n\twhile(cin >> n >> m, n) {\n\t\tfor(int i = 0; i < n; i++) G[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> u >> v >> w;\n\t\t\tG[u].push_back(make_pair(v, w));\n\t\t\tG[v].push_back(make_pair(u, w));\n\t\t}\n\t\tcout << prim(n, G) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Edge {\npublic:\n    int u, v, cost;\n    Edge() {}\n    Edge(int _u, int _v, int _cost) {\n        u = _u;\n        v = _v;\n        cost = _cost;\n    }\n\n    bool operator<(const Edge& e) const {\n        return cost < e.cost;\n    }\n};\n\nclass UnionFind {\npublic:\n    int n;\n    vector<int> parent_nodes, rank;\n    UnionFind() {}\n    UnionFind(int _n) {\n        n = _n;\n        // all node is same rank\n        for (int i = 0; i < n; ++i) {\n            parent_nodes.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    int find(int v) {\n        if(parent_nodes[v] == v) return v; // return root.\n        return parent_nodes[v] = find(parent_nodes[v]); // compress path\n    }\n\n    // unite sets\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y){\n            return;\n        }\n\n        if (rank[x] < rank[y]) {\n            parent_nodes[x] = y;\n        } else {\n            parent_nodes[y] = x;\n            if (rank[x] == rank[y]) {\n                ++rank[x];\n            }\n        }\n\n        return;\n    }\n\n    // validation of same set\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint kruskal(int n_vertex, int n_edge, vector<Edge> edges) {\n    int costs = 0;\n    sort(edges.begin(), edges.end());\n    UnionFind uf = UnionFind(n_vertex);\n\n    for (int i = 0; i < n_edge; ++i) {\n        if(!uf.same(edges[i].u, edges[i].v)) {\n            uf.unite(edges[i].u, edges[i].v);\n            costs += edges[i].cost;\n        }\n    }\n\n    return costs;\n}\n\n\nint main()\n{\n    int n, m, a, b, cost, result;\n    vector<Edge> edges;\n    while(cin>>n>>m) {\n        if(n == 0 && m == 0) {\n            break;\n        }\n        for (int i = 0; i < m; ++i) {\n            cin >> a >> b >> cost;\n            edges.push_back(Edge(a, b, cost));\n        }\n\n        result = kruskal(n, m, edges);\n        cout << result << endl;\n        edges.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int d[100][100];\n    fill_n(d[0],10000,1<<29);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    int ds[100];\n    fill_n(ds,100,1<<29);\n    ds[0]=0;\n    bool u[100]={};\n    int p[100]={};\n    for(int i=0;i<n;i++){\n      int m=1<<29;\n      int v;\n      for(int i=0;i<n;i++){\n\tif(!u[i]&&ds[i]<m){\n\t  m=ds[i];\n\t  v=i;\n\t}\n      }\n      u[v]=true;\n      for(int i=0;i<n;i++){\n\tif(ds[i]>ds[v]+d[v][i]){\n\t  ds[i]=ds[v]+d[v][i];\n\t  p[i]=d[v][i];\n\t}\n      }\n    }\n    cout<<accumulate(p,p+n,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int INF = 1000000;\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n && !m)\n\t\t\tbreak;\n\t\tint bridge[101][101];\n\t\tint pre_vertex[101][101];\n\t\tint a,b,cost;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tbridge[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tbridge[i][j] = INF;\n\t\t\t\tpre_vertex[i][j] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tif(bridge[a][b] > cost){\n\t\t\t\tbridge[a][b] = cost;\n\t\t\t\tbridge[b][a] = cost;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint dis = bridge[i][k]+bridge[k][j];\n\t\t\t\t\tif(dis < bridge[i][j]){\n\t\t\t\t\t\tbridge[i][j] = dis;\n\t\t\t\t\t\tpre_vertex[i][j] = pre_vertex[k][j];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tsum += bridge[i][j] - bridge[i][pre_vertex[i][j]];\n\t\t\t}\n\t\t\tif(sum < min)\n\t\t\t\tmin = sum;\n\t\t}\n\t\tcout << min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[101];\nbool city[101];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile( 1 )\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n)\n\t{\n\t\tvector<P> edges[100];\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tedges[a].push_back(P(c, b));\n\t\t\tedges[b].push_back(P(c, a));\n\t\t}\n\t\tbool inTree[100];\n\t\tfill(inTree, inTree+n, false);\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tinTree[0] = true;\n\t\tfor (int i = 0; i < edges[0].size(); ++i)\n\t\t\tq.push(edges[0][i]);\n\t\tint ans = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP e = q.top();\n\t\t\tq.pop();\n\t\t\tif (inTree[e.second])\n\t\t\t\tcontinue;\n\n\t\t\tinTree[e.second] = true;\n\t\t\tans += e.first;\n\t\t\tfor (int i = 0; i < edges[e.second].size(); ++i)\n\t\t\t\tq.push(edges[e.second][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, int> P3;\nconst ll MOD = ll(1e9)+7;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-11;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nconst int MAX_V = 100000;\n\nstruct UnionFindTree {\n    int par[MAX_V];\n    int rank[MAX_V];\n\n    void init(int n) {\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct edge {\n    int u, v, cost;\n};\n\nbool comp(const edge &e1, const edge &e2) { return e1.cost < e2.cost; }\n\nvector<edge> es;\nint V, E;\n\nint kruskal() {\n    sort(es.begin(), es.end(), comp);\n    UnionFindTree a;\n    a.init(V);\n    int res = 0;\n    for (int i = 0; i < es.size(); i++) {\n        edge e = es[i];\n        if (!a.same(e.u, e.v)) {\n            a.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\nint main() {\n    while(cin >> V >> E, V){\n        REP(i,E){\n            int a, b, c;\n            cin >> a >> b >> c;\n            es.push_back({a,b,c});\n        }\n        cout << kruskal() << endl;\n        es.clear();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\nint par[10000]; int hukasa[10000];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tpar[x] = y;\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct UnionFind\n{\n\tvint data;\n\t\n\tUnionFind(int size) : data(size, -1) { }\n\t\n\tint unite(int x, int y)\n\t{\n\t\tx = root(x), y = root(y);\n\t\t\n\t\tif(x != y)\n\t\t{\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\t\n\t\treturn x != y;\n\t}\n\t\n\tint root(int x)\n\t{\treturn data[x] < 0 ? x : root(data[x]);\t}\n\t\n\tint size(int x)\n\t{\treturn -data[root(x)];\t}\n\t\n\tbool same(int x, int y)\n\t{\treturn root(x) == root(y);\t}\n};\n\nstruct edge{ int u, v, cost;\t};\n\nbool comp(const edge& e1, const edge& e2)\n{\treturn e1.cost < e2.cost;\t}\n\nint main()\n{\n    int n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\tvector<edge> es(m);\n\t\tUnionFind uft(n);\n\t\t\n\t\trep(i, m) cin >> es[i].u >> es[i].v >> es[i].cost;\n\t\t\n\t\tsort(ALL(es), comp);\n\t\t\n\t\tint res = 0;\n\t\trep(i, m)\n\t\t{\n\t\t\tedge e(es[i]);\n\t\t\t\n\t\t\tif(!uft.same(e.u, e.v))\n\t\t\t{\n\t\t\t\tuft.unite(e.u, e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nint parent [100];\nint root(int x){\n\tif(parent[x]==x) return x;\n\treturn parent[x]=root(parent[x]);\n}\nvoid unite(int x,int y){\n\tx=root(x);\n\ty=root(y);\n\tparent[x]=y;\n}\nbool same(int x,int y){\n\treturn root(x)==root(y);\n}\nstruct P{\n\tint from,to,cost;\n};\nbool operator<(P a,P b){\n\treturn a.cost<b.cost;\n}\nbool operator>(P a,P b){\n\treturn a.cost>b.cost;\n}\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m&&n!=0&&m!=0){\n\tint a,b,c;\n\tfor(int i=0;i<n;i++)parent[i]=i;\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tp.push(P{a,b,c});\n\t}\n\tint sum=0,d=0;\n\twhile(d!=n-1){\n\t\tP t=p.top();p.pop();\n\t\tif(!same(t.from,t.to)){\n\t\t\tunite(t.from,t.to);\n\t\t\td++;\n\t\t\tsum+=t.cost;\n\t\t}\n\t}\n\tcout<<sum<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint P[10010];\nint N, M, A[10010], B[10010], COST[10010];\npair<int,int> bridge[10010];\n\nvoid init(int N) {\n\tfor (int i=0; i<N; ++i) { P[i] = i; }\n}\n\nint root(int a) {\n\tif (P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nbool is_same_set(int a, int b) {\n\treturn root(a) == root(b);\n}\n\nvoid unite(int a, int b) {\n\tP[root(a)] = root(b);\n}\n\nint main() {\n\t\n\twhile(cin >> N >> M) {\n\t\tint costs=0;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tinit(N);\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tcin >> A[i] >> B[i] >> COST[i];\n\t\t\tbridge[i].first = COST[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+M);\n\t\t\n\t\tfor (int i=0; i<M; i++) {\n\t\t\tint cost = bridge[i].first;\n\t\t\tint machiID = bridge[i].second;\n\t\t\tif (!is_same_set(A[machiID], B[machiID])) {\n\t\t\t\tunite(A[machiID],B[machiID]);\n\t\t\t\tcosts+=cost;\n\t\t\t}\n\t\t}\n\t\tcout << costs << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 101\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){\n\tif(parent[a]==a)return a;\n\treturn parent[a]=root(parent[a]);\n}\nint unite(int a,int b){\n\tif(root(a)!=root(b))return 0;\n\tparent[root(a)]=root(b);\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;cin>>n>>m,n;cout<<s<<endl){\n\t\tfor(i=0;i<m;i++)cin>>a[i]>>b[i]>>node[i].first,node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define MAX_E 501\n#define MAX_V 101\n#define INF 1e9\n\nusing namespace std;\n\nint cost[MAX_V][MAX_V]; // cost[u][v]テ」ツ?ッティツセツコe=(u,v)テ」ツ?ョテ」ツつウテ」ツつケテ」ツδ?テ・ツュツ佚・ツ慊ィテ」ツ?療」ツ?ェテ」ツ??・ツ?エテ・ツ青暗」ツ?ッINF)\nint mincost[MAX_V]; // テゥツ崢?・ツ青?テ」ツ?凝」ツつ嘉」ツ?ョティツセツコテ」ツ?ョテヲツ慊?・ツーツ湘」ツつウテ」ツつケテ」ツδ?\nbool used[MAX_V];   // テゥツ?づァツつケiテ」ツ?傾テ」ツ?ォテ・ツ青ォテ」ツ?セテ」ツつ古」ツ?ヲテ」ツ??」ツつ凝」ツ??\nint V;\n\nint prim() {\n  for (int i = 0; i < V; ++i) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n\n  while (true) {\n    int v = -1;\n    // Xテ」ツ?ォテ・ツアツ榲」ツ?陛」ツ?ェテ」ツ??ゥツ?づァツつケテ」ツ?ョテ」ツ??」ツ?。Xテ」ツ?凝」ツつ嘉」ツ?ョティツセツコテ」ツ?ョテ」ツつウテ」ツつケテ」ツδ暗」ツ?古ヲツ慊?・ツーツ湘」ツ?ォテ」ツ?ェテ」ツつ凝ゥツ?づァツつケテ」ツつ津ヲツ篠「テ」ツ??\n    for (int u = 0; u < V; u++) {\n      if (!used[u] && (v == -1 || mincost[u] < mincost[v]))\n        v = u;\n    }\n\n    if (v == -1)\n      break;\n    used[v] = true;    // テゥツ?づァツつケvテ」ツつ湛テ」ツ?ォティツソツステ・ツ環?\n    res += mincost[v]; // ティツセツコテ」ツ?ョテ」ツつウテ」ツつケテ」ツδ暗」ツつ津・ツ環?」ツ?暗」ツつ?\n\n    for (int u = 0; u < V; u++) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n\n  return res;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n != 0 || m != 0){\n        V = n;\n        for(int i=0;i<MAX_V;++i)\n            for(int j=0;j<MAX_V;++j)\n                cost[i][j] = INF;\n        for(int i=0;i<m;++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            cost[a][b] = c;\n            cost[b][a] = c;\n        }\n        cout << prim() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    bool u[n];\n    memset(u,0,sizeof(u));\n    vector<P> v[n];\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x].push_back(P(y,z));\n      v[y].push_back(P(x,z));\n    }\n    int ans=0;\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(0,0));\n    while(!que.empty()) {\n      P p=que.top();que.pop();\n      int x=p.second,c=p.first;\n      if(u[x]) continue;\n      u[x]=1;\n      ans+=c;\n      for(int i=0; i<v[x].size(); i++) {\n        int y=v[x][i].first;\n        if(!u[y]) que.push(P(v[x][i].second,y));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint main(void){\n\tint n,m,a[501],b[501],cost[501],i,j,temp,root[101],size[101],x,y,sum;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tsize[i]=1;\n\t\t\troot[i]=i;\n\t\t}\n\t\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>cost[i];\n\t\tfor(i=0;i<m-1;i++){\n\t\t\tfor(j=i+1;j<m;j++){\n\t\t\t\tif(cost[i]>cost[j]){\n\t\t\t\t\ttemp=cost[i]; cost[i]=cost[j]; cost[j]=temp;\n\t\t\t\t\ttemp=a[i]; a[i]=a[j]; a[j]=temp;\n\t\t\t\t\ttemp=b[i]; b[i]=b[j]; b[j]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor(i=0;i<m;i++)cout<<cost[i]<<endl;\n\t\tsum=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tx=a[i]; y=b[i];\n\t\t\twhile(root[x]!=x) x=root[x];\n\t\t\twhile(root[y]!=y) y=root[y];\n\t\t\tif(x!=y){\n\t\t\t\tsum+=cost[i];\n\t\t\t\tif(size[x]>size[y]) root[y]=x;\n\t\t\t\telse if(size[x]<size[y]) root[x]=y;\n\t\t\t\telse {\n\t\t\t\t\troot[x]=y;\n\t\t\t\t\tsize[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint par[MAX_N];\nint rank[MAX_N];\n\n#define MAX_E 10000\nstruct edge { int u, v, cost; };\nedge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find(int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init_union_find(V);\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    edge e = es[i];\n    if(!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(cin >> V >> E && (V||E)) {\n    E *= 2;\n    for(int i=0; i<E; i+=2) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      es[i].u = a, es[i].v = b, es[i].cost = c;\n      es[i].u = b, es[i].v = a, es[i].cost = c;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass UnionFind\n{\nprivate:\n  vector<int> parent, rank;\n\npublic:\n  UnionFind(int n)\n  {\n    for (int i = 0; i < n; ++i) {\n      parent.push_back(i);\n      rank.push_back(0);\n    }\n  }\n\n  int find(int x)\n  {\n    if (parent[x] == x)\n      return x;\n    else\n      return parent[x] = find(parent[x]);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n\n    if (rank[x] < rank[y]) {\n      parent[x] = y;\n    } else {\n      parent[y] = x;\n      if (rank[x] == rank[y])\n\t++rank[x];\n    }\n  }\n\n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    priority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > que;\n    for (int i = 0; i < m; ++i) {\n      pair<int, pair<int, int> > p;\n      cin >> p.second.first >> p.second.second >> p.first;\n      que.push(p);\n    }\n\n    int ans = 0;\n    UnionFind uf(n);\n    while (!que.empty()) {\n      const pair<int, pair<int, int> > p = que.top();\n      que.pop();\n\n      if (!uf.same(p.second.first, p.second.second)) {\n\tuf.unite(p.second.first, p.second.second);\n\tans += p.first;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <set>\n#define INF 1e8\n\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    vector<vector<int> > g(n);\n    for(int i=0;i<n;++i){\n      g[i].reserve(n);\n      for(int j=0;j<n;++j) g[i][j]=INF;\n    }\n    for(int i=0,a,b,cost;i<m;++i){\n      cin>>a>>b>>cost;\n      g[a][b]=cost;\n      g[b][a]=cost;\n    }\n    int ans=0;\n    set<int> v;\n    v.insert(0);\n    while(v.size()!=n){\n      int min_cost=INF,to=0;\n      for(set<int>::iterator vit=v.begin();vit!=v.end();++vit){\n        for(int i=0;i<n;++i){\n          if(v.find(i)==v.end()&&g[*vit][i]<min_cost){\n            to=i;\n            min_cost=g[*vit][i];\n          }\n        }\n      }\n      ans+=min_cost;\n      v.insert(to);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nvector<P> branch[128];\n\nint prim();\n\nint main()\n{\n    while (scanf(\"%d %d\", &n, &m), n != 0){\n        for (int i = 0; i < n; i++) branch[i].clear();\n\n        for (int i = 0; i < m; i++){\n            int a, b, c;\n\n            scanf(\"%d %d %d\", &a, &b, &c);\n            branch[a].push_back(P(c, b));\n            branch[b].push_back(P(c, a));\n        }\n        printf(\"%d\\n\", prim());\n    }\n\n    return 0;\n}\n\nint prim()\n{\n    bool v[1024] = {false};\n    priority_queue<P, vector<P>, greater<P> > q;\n    int sum = 0;\n\n    q.push(P(0, 0));\n    v[0] = 0;\n    while (!q.empty()){\n        P p = q.top(); q.pop();\n\n        if (v[p.second]) continue;\n        v[p.second] = true;\n        sum += p.first;\n        for (int i = 0; i < branch[p.second].size(); i++){\n            q.push(branch[p.second][i]);\n        }\n    }\n\n    return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\nint par[10000]; int hukasa[10000];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tif (hukasa[x] < hukasa[y]) par[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (hukasa[x] == hukasa[y]) hukasa[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t\thukasa[i] = 0;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\ntypedef pair<int,int> pp;\n\nconst int maxn = 110, inf = 10100;\n\nint cost[maxn][maxn];\nbool used[maxn];\nint n,m,a,b;\n\nint main()\n{\n\twhile(cin >> n >> m && (n && m))\n\t{\n\t\tmemset(used, false, sizeof(used));\n\t\tmemset(cost,inf, sizeof(cost));\n\t\tpriority_queue<pp, vector<pp>, greater<pp> > que;\n\t\tque.push(pp(0, 0));\n\n\t\tint ans = 0;\n\t\tREP(m)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tcin >> cost[a][b];\n\t\t\tcost[b][a] = cost[a][b];\n\t\t}\n\t\t\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tpp p = que.top(); que.pop();\n\t\t\tif(used[p.second]) continue;\n\t\t\t\n\t\t\tans += p.first;\n\t\t\tused[p.second] = true;\n\t\t\t\n\t\t\tREP(n) que.push(pp(cost[p.second][i], i ));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n_T _DEF(T,in,int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_DEF(int,in,){return in<int>(gcu());}\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n_T _SCAN(T &n){int c=gcu();return c==EOF?n=0,false:(n=in<T>(c),true);}\n_SCAN(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_SCAN(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=(char)c;}}\n#endif\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);} _OUT(const char *s){while(*s)pcu(*s++);} _OUT(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_OUT(string s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _OUT(vector<T> v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _OUTL(T&&... t){out(move(t)...);outl();}\nstruct range{\n\tint e,b=0,s=1; range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it { int v, s; it (int _v, int _s) : v(_v), s(_s) {} operator int()const{return v;} operator int&(){return v;} int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin() {return {b, s};} it end() {return {e, s};}};\n\nstruct union_find {\n\tstruct node {int p, r = 0;};\n\tvector<node> nodes;\n\n\tunion_find(int n) : nodes(n) {\n\t\tint i = 0;\n\t\tfor (node &n: nodes)\n\t\t\tn.p = i++;\n\t}\n\tint find(int x) {\n\t\tint &p = nodes[x].p;\n\t\tif (p != x)\n\t\t\tp = find(p);\n\t\treturn p;\n\t}\n\tvoid unite(int a, int b) {\n\t\tint ar = find(a), br = find(b);\n\t\tnode &an = nodes[ar], &bn = nodes[br];\n\t\tif (an.r > bn.r)\n\t\t\tbn.p = ar;\n\t\telse {\n\t\t\tan.p = br;\n\t\t\tif (an.r == bn.r)\n\t\t\t\tbn.r++;\n\t\t}\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n};\n\nstruct edge {\n\tint s, t, w;\n\tbool operator < (edge &a) {return w < a.w;}\n};\n\nint main() {\n\tfor (int n; (n = in());) {\n\t\tunion_find V(n);\n\t\tvector<edge> E(in());\n\t\tint r = 0;\n\t\tfor (edge &e: E)\n\t\t\te = {in(), in(), in()};\n\t\tsort(E.begin(), E.end());\n\t\tfor (edge e: E)\n\t\t\tif (!V.same(e.s, e.t)) {\n\t\t\t\tr += e.w;\n\t\t\t\tV.unite(e.s, e.t);\n\t\t\t}\n\t\toutl(r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <utility>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\n#define N 100\n\ntypedef pair<int,int> arw;\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  list<arw>::iterator it;\n  int i;\n\n  for ( ; ; )\n  {\n    priority_queue<arw, vector<arw>, greater<arw> > lis;\n    list<arw> d[ N ];\n    int mk[ N ] = { };\n    int res = 0;\n    int n, m;\n\n    scanf ( \"%d%d\", &n, &m );\n    if ( n == 0 && m == 0 ) break ;\n    for ( i = 0; i < m; ++i )\n    {\n      int a, b, cost;\n\n      scanf ( \"%d%d%d\", &a, &b, &cost );\n      d[ a ].push_back ( make_pair ( cost, b ) );\n      d[ b ].push_back ( make_pair ( cost, a ) );\n    }\n\n    /* Prim's Algorithm */\n    lis.push ( make_pair ( 0, 0 ) );\n    while ( !lis.empty ( ) )\n    {\n      const arw c = lis.top ( );\n      lis.pop ( );\n\n      if ( mk[ c.second ] )\n        continue ;\n\n      res += c.first;\n      for ( it = d[ c.second ].begin ( ); it != d[ c.second ].end ( ); ++it )\n      {\n        lis.push ( *it );\n      }\n\n      mk[ c.second ] = 1;\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint e[100]={};\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tv.insert((*it2).second);\n\t\t\t\t\tres+=(*it2).first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( type ) vector< type >\n#define VVT( type ) vector< vector< type > >\n#define LIM( type ) numeric_limits< type >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline void input_n( vector< T > &out ) { copy_n( istream_iterator< T >( cin ), out.size(), out.begin() ); };\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) (c).begin(), (c).end()\n#define AALL( a, t ) (t*)a, (t*)a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n// Prim 法による MST\n#include <vector>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <type_traits>\nnamespace MinimumSpanningTree\n{\n\ttemplate < typename COST_TYPE = int, typename = typename std::enable_if< std::is_arithmetic< COST_TYPE >::value >::type >\n\tclass Prim\n\t{\n\t\tusing Edge = std::pair< COST_TYPE, int >;\n\t\tconst COST_TYPE INF = std::numeric_limits< COST_TYPE >::max() / 2;\n\n\t\tconst int N;\n\t\tstd::vector< std::vector< Edge > > G;\n\n\tpublic:\n\t\tPrim( const int n ) : N( n ), G( N )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvoid connect( const int u, const int v, COST_TYPE c )\n\t\t{\n\t\t\tG[u].emplace_back( c, v );\n\t\t\tG[v].emplace_back( c, u );\n\n\t\t\treturn;\n\t\t}\n\n\t\tCOST_TYPE solve()\n\t\t{\n\t\t\tstd::vector< COST_TYPE > costs( N, INF );\n\t\t\tcosts[0] = 0;\n\n\t\t\tstd::vector< bool > used( N );\n\n\t\t\tstd::priority_queue< Edge, std::vector< Edge >, greater< Edge > > que;\n\t\t\tque.emplace( 0, 0 );\n\n\t\t\tCOST_TYPE result = 0;\n\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tconst COST_TYPE cost = que.top().first;\n\t\t\t\tconst int u = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( used[u] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tused[u] = true;\n\t\t\t\tresult += cost;\n\n\t\t\t\tfor ( Edge &e : G[u] )\n\t\t\t\t{\n\t\t\t\t\tconst COST_TYPE c = e.first;\n\t\t\t\t\tconst int v = e.second;\n\n\t\t\t\t\tif ( c < costs[v] )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.emplace( costs[v] = c, v );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n}\n// MinimumSpanningTree::Prim( |V| )\n// connect( u, v, cost )\n// solve()\n\nint solve( const int N, const int M )\n{\n\tMinimumSpanningTree::Prim<> prim( N );\n\tREP( i, 0, M )\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tprim.connect( a, b, c );\n\t}\n\n\treturn prim.solve();\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n, m; cin >> n >> m, ( n | m ); cout << solve( n, m ) << endl );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Edge {\n\tint a, b, cost;\n};\n\nint n, m;\nint root[100], high[100];\nEdge e[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++)root[i] = i, high[i] = 1;\n}\n\nint getroot(int n){\n\tif (n == root[n])return n;\n\treturn root[n] = getroot(root[n]);\n}\n\nbool issame(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\ta = getroot(a), b = getroot(b);\n\tif (a == b)return;\n\tif (high[a] > high[b])root[b] = a;\n\telse if (high[a] < high[b])root[a] = b;\n\telse if (high[a] == high[b])root[a] = b, high[a]++;\n}\n\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> e[i].a >> e[i].b >> e[i].cost;\n\t\t}\n\t\tsort(e, e + m, [](Edge& l, Edge& r) {\n\t\t\treturn l.cost < r.cost;\n\t\t});\n\t\tint ans = 0;\n\t\tinit(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!issame(e[i].a, e[i].b)) {\n\t\t\t\tunite(e[i].a, e[i].b);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n#define X first\n#define Y second\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Union-Find **/\nconst int MAX_N = 10000;\nconst int MAX_E = 10000;\n\nclass UnionFind {\npublic:\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\t\n\tvoid init(int n)\n\t{\n\t\trep(i, n) {\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\t\n\tint find(int x)\n\t{\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\t\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n/** 最小全域木 kruskal法 O(|E|log|V|) **/\nstruct edge {int u, v, cost;};\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nedge es[MAX_E];\nint V, E;\n\nint kruskal()\n{\n\tUnionFind UF;\n\tsort(es, es+E, comp);\n\tUF.init(V);\n\tint res=0;\n\tfor (int i=0; i<E; i++) {\n\t\tedge e = es[i];\n\t\tif (!UF.same(e.u, e.v)) {\n\t\t\tUF.unite (e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin>>V>>E, V) {\n\t\trep(i, E) {\n\t\t\tcin >> es[i].u >> es[i].v >> es[i].cost;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\nstatic const int INF = 999999;\nint V, E;\nstruct SEdge\n{\n\tint From;\n\tint To;\n\tint Cost;\n};\nvector<SEdge> Edge;\n\nvector<int> par;\nvector<int> rank;\n\nvoid init(int n)\n{\n\tpar.clear();\n\trank.clear();\n\tpar.resize(n);\n\trank.resize(n);\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif(par[x] == x)\n\t{\n\t\treturn(x);\n\t}\n\telse\n\t{\n\t\treturn(par[x] = find(par[x]));\n\t}\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t{\n\t\treturn;\n\t}\n\tif(rank[x] < rank[y])\n\t{\n\t\tpar[x] = y;\n\t}\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t{\n\t\t\t++rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn(find(x) == find(y));\n}\n\nbool comp(const SEdge& e1, const SEdge& e2)\n{\n\treturn(e1.Cost < e2.Cost);\n}\n\nint Kruskal()\n{\n\tinit(V);\n\tsort(Edge.begin(), Edge.end(), comp);\n\tint res = 0;\n\tfor(int i = 0; i < E; ++i)\n\t{\n\t\tSEdge e = Edge[i];\n\t\tif(!same(e.From, e.To))\n\t\t{\n\t\t\tunite(e.From, e.To);\n\t\t\tres += e.Cost;\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V >> E, V || E)\n\t{\n\t\tEdge.clear();\n\t\tEdge.resize(E);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tSEdge e;\n\t\t\tcin >> e.From >> e.To >> e.Cost;\n\t\t\tEdge[i] = e;\n\t\t}\n\t\tcout << Kruskal() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 101\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){\n\tif(parent[a]==a)return a;\n\treturn parent[a]=root(parent[a]);\n}\nint unite(int a,int b){\n\tif(root(a)==root(b))return 0;\n\tparent[root(a)]=root(b);\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;cin>>n>>m,n;cout<<s<<endl){\n\t\tfor(i=0;i<m;i++)cin>>a[i]>>b[i]>>node[i].first,node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tint from, to, cost;\n\tREP(i, m){\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second; q.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second]){\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int maxn = 101, maxm = 5500,INF = 11100;\n\nint cost[maxn][maxn];\nint mincost[maxn];\nbool used[maxn];\nint n,m,a,b;\n\nint main()\n{\n    while(cin>> n >> m &&(n&&m))\n    {\n        memset(cost,INF,sizeof(cost));\n        memset(used,false,sizeof(used));\n        memset(mincost,INF,sizeof(mincost));\n\n        REP(m)\n        {\n            cin >> a >> b ;\n            cin >>cost[a][b];\n            cost[b][a] = cost[a][b];\n\n        }\n        mincost[0] = 0;\n        int ans = 0;\n\n        while(true)\n        {\n            int minv = -1;\n            REP(n)if(!used[i] &&(minv == -1 ||mincost[i] < mincost[minv] )) minv = i;\n            //cout << \"v\" << minv << endl;\n            if(minv == -1) break;\n            used[minv] = true;\n            ans += mincost[minv];\n            //cout<<minv<<\":\" << mincost[minv] << endl;\n            \n            REP(n) mincost[i] = min(mincost[i], cost[minv][i]);\n        }\n        \n        cout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=1000000;\nint n,m;\nint cost[101][101];\nint mincost[101];\nbool used[101];\n\nint prim(){\n\tint a;\n\tfor(a=0;a<n;++a){\n\t\tmincost[a]=INF;\n\t\tused[a]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(a=0;a<n;a++){\n\t\t\tif(!used[a] && (v==-1 || mincost[a] < mincost[v]))v=a;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(a=0;a<n;a++){\n\t\t\tmincost[a]=min(mincost[a],cost[v][a]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tfor(a=0;a<=100;a++){\n\t\t\tfor(b=0;b<=100;b++){\n\t\t\t\tcost[a][b]=INF;\n\t\t\t\tif(a==b)cost[a][b]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(a=0;a<m;a++){\n\t\t\tint b,c,d;\n\t\t\tcin >> b >> c >> d;\n\t\t\tif(cost[b][c]>d){\n\t\t\t\tcost[b][c]=d;\n\t\t\t\tcost[c][b]=d;\n\t\t\t}\n\t\t}\n\t\tint ans=prim();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(200,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\nint field[100][100];\nbool used[100];\n\nint prim() {\n\t// コスト、ノード番号\n\ttypedef pair<int, int> edge;\n\tint result = 0;\n\tfill(used, used + n, false);\n\tpriority_queue<edge, vector<edge>, greater<edge> > que;\n\tque.push(make_pair(0, 0));\n\twhile (!que.empty()) {\n\t\tedge current = que.top();\n\t\tque.pop();\n\t\tint cost = current.first;\n\t\tint pos = current.second;\n\t\tif (used[pos]) continue;\n\t\tused[pos] = true;\n\t\tresult += cost;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (field[pos][i] > 0 && !used[i]) {\n\t\t\t\tque.push(make_pair(field[pos][i], i));\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tfield[a][b] = field[b][a] = c;\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nlong long minSpanningTree(const vector<vector<Edge> >& edges)\n{\n    int n = edges.size();\n    vector<bool> used(n, false);\n    int usedNum = 0;\n    vector<int> minCost(n, INT_MAX);\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, 0));\n\n    long long ret = 0;\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(used[v])\n            continue;\n        ret += p.first;\n        used[v] = true;\n        if(++usedNum == n)\n            return ret;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(!used[e.to] && e.cost < minCost[e.to]){\n                minCost[e.to] = e.cost;\n                q.push(make_pair(e.cost, e.to));\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            edges[a].push_back(Edge(b, cost));\n            edges[b].push_back(Edge(a, cost));\n        }\n\n        cout << minSpanningTree(edges) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint data[101][101];\n\nint prim( int n )\n{\n\tvector<int> key( n, 99999 );\n\tkey[0] = 0;\n\tvector<int> pq;\n\tbool inQueue[101];\n\tfor( int i = 0;i < 101;i++ ) inQueue[i] = true;\n\tfor( int i = 0;i < n;i++ ){\n\t\tpq.push_back( key[i] );\n\t}\n\n\twhile( !pq.empty() ){\n\t\tvector<int>::iterator it = min_element( pq.begin(), pq.end() );\n\t\tint u = distance( pq.begin(), it );\n\t\tpq.erase( it );\n\t\tinQueue[u] = false;\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tif( data[u][i] ){\n\t\t\t\tif( inQueue[i] ){\n\t\t\t\t\tint w = data[u][i];\n\t\t\t\t\tif( w < key[i] ){\n\t\t\t\t\t\tkey[i] = w;\n\t\t\t\t\t\tpq[i] = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint answer = 0;\n\tfor( int i = 0;i < n;i++ ){\n\t\tanswer += key[i];\n\t}\n\n\treturn answer;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n,m;\n\tint a,b,cost;\n\n\twhile( cin >> n >> m && n != 0 ){\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0;i < m;i++ ){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tdata[a][b] = cost;\n\t\t\tdata[b][a] = cost;\n\t\t}\n\n\t\tint answer = prim( n );\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nint N,M;\nconst int MAX_V = 10000;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\n\nll Prim(){\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  ll res =0;\n\n  while(1){\n    int v = -1;\n    for(ll u = 0; u < V; ++u){\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if( v == -1){\n      break;\n    }\n    used[v] = true;\n    res += mincost[v];\n    for(ll u = 0; u < V; ++u){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nll prim(){\n  ll res = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N >> M && N && M){\n    int a,b,c;\n    V = N;\n    cost = vector<vector<ll>>(V,vector<ll>(V,inf));\n    rep(i,100){\n      g[i].clear();\n    }\n    rep(i,M){\n      cin >> a >> b >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n//       cost[a][b] = c;\n//       cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[b][a] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n que.pop();\n     }\n    \n  }\n  return cost_sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[150];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef struct{\n\tint u,v,co;\n}wa;\nbool com(const wa& a,const wa& b){\n\treturn a.co<b.co;\n}\nwa way[1000];\nint pa[1000];\nint find(int t){\n\tif(pa[t]==t)\n\treturn t;\n\telse return find(pa[t]);\n}\nvoid uni(int s,int t){\n\ts=find(s);\n\tt=find(t);\n\tpa[s]=t;\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nint main(){\n\tint n,m,sum;\n\twhile(cin>>n>>m,n||m){\n\t\tsum=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcin>>way[i].v>>way[i].u>>way[i].co;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpa[i]=i;\n\t\tsort(way,way+m,com);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].u,way[i].v)){\n\t\t\t\tuni(way[i].u,way[i].v);\n\t\t\t\tsum+=way[i].co;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define FOR(i,a) for(int i=0;i<(int)(a);i++)\n#define pb push_back\n#define clr clear()\n#define sz size()\ntypedef unsigned int ui;\n\nclass node{\npublic:\n  int num;\n  void set(int n){\n    num = n;\n  }\n};\n\nclass edge{\npublic:\n  node b,e;\n  int cost;\n  void set(int s,int g,int c){\n    b.set(s);\n    e.set(g);\n    cost = c;\n  }\n};\n\nclass graph{\npublic:\n  vector<node> n;\n  vector<edge> e;\n\n  void set(void){\n    n.clr;\n    e.clr;\n  }\n\n  void Nadd(node a){\n    if(!n.sz)n.pb(a);\n    else{\n      ui i = 0;\n      while(n[i].num < a.num && i<n.sz)i++;\n      n.insert(n.begin()+i,a);\n    }\n  }\n\n  void Eadd(edge a){\n    if(!e.sz)e.pb(a);\n    else{\n      ui i = 0;\n      while(e[i].cost < a.cost && i<e.sz)i++;\n      e.insert(e.begin()+i,a);\n    }\n  }\n\n  bool Nexist(node a){\n    FOR(i,n.sz){\n      if(a.num == n[i].num)return true;\n    }\n    return false;\n  }\n\n  graph prim(void){\n    graph res;\n\n    res.set();\n\n    if(!e.sz)return res;\n    else{\n      res.Eadd(e[0]);\n      res.Nadd(e[0].b);\n      res.Nadd(e[0].e);\n\n      while(res.n.sz < n.sz){\n\tFOR(i,e.sz){\n\t  if(res.Nexist(e[i].b) && !res.Nexist(e[i].e)){\n\t    res.Eadd(e[i]);\n\t    res.Nadd(e[i].e);\n\t    i = 0;\n\t  }else if(!res.Nexist(e[i].b) && res.Nexist(e[i].e) ){\n\t    res.Eadd(e[i]);\n\t    res.Nadd(e[i].b);\n\t    i = 0;\n\t  }\n\t}\n      }\n      return res;\n    }\n  }\n};\n\nint main(){\n  int n,m,ans;\n  int a,b,c;\n  graph g,p;\n  node tmp;\n  edge etmp;\n\n  while(1){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    g.set();\n    for(int i=0;i<n;i++){\n      tmp.set(i);\n      g.Nadd(tmp);\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      etmp.set(a,b,c);\n      g.Eadd(etmp);\n    }\n\n    p = g.prim();\n\n    ans = 0;\n    for(int i=0;i<p.e.size();i++)ans += p.e[i].cost;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 114\n#define INF 1e9\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prim(){\n  for(int i = 0 ; i < V ; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n  \n    for(int u = 0 ; u < V ; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])){\n        v = u;\n      }\n    }\n    if(v == -1){ break; }\n    used[v] = true;        \n    res += mincost[v];     \n\n    for(int u = 0 ; u < V ; u++){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E,s,t,w;\n  while(cin >> V >> E,V){\n    for(int i = 0 ; i < V ; i++){\n      for(int j = 0 ; j < V ; j++){\n        cost[i][j] = INF;\n      }\n    }\n    for(int i = 0 ; i < E ; i++){\n      cin >> s >> t >> w;\n      cost[s][t] = cost[t][s] = w;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef int ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5 + 1;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\nint N, M;\nvector<ppr> G;\n\nconst int MAX_N = 1000;\n\nint par[MAX_N + 1], r[MAX_N + 1];\n\nvoid init(int n){\n\tfor(int i = 0; i < n; ++i){\n\t\tpar[i] = i;\n\t\tr[i] = 0;\n\t}\t\n}\n\nint find(int x){\n\tif(par[x] == x)\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\t\n\tif(r[x] < r[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(r[x] == r[y])\n\t\t\tr[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint main() {\n\twhile(cin >> N >> M && N){\n\t\tG.clear();\n\t\tREP(i,M){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tG.PB(ppr(c, pr(a, b)));\n\t\t}\n\t\tinit(N+1);\n\t\tsort(BE(G));\n\t\tint ans = 0;\n\t\tREP(i,G.size()){\n\t\t\tppr e = G[i];\n\t\t\tif(!same(e.S.F, e.S.S)){\n\t\t\t\tunite(e.S.F, e.S.S);\n\t\t\t\tans += e.F;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M;\nint U[100000], R[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    vector<P2> edges;\n    rep(i, M) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      edges.pb(P2(c, P(a, b)));\n    }\n    sort(all(edges));\n    for (int i=0; i<N; i++) U[i] = i, R[i] = 1;\n    int s = 0;\n    for (P2 e : edges) {\n      int a = e._2._1, b = e._2._2;\n      if (!same(a, b)) {\n        s += e._1;\n        unite(a, b);\n      }\n    }\n    cout << s << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1,const edge& e2){return e1.cost<e2.cost;}\n\nint par[101],cost[101];\nvoid init(int n){\n\tfor(int i=0;i<n;i++)par[i]=i,cost[i]=0;\n}\nint find(int n){\n\tif(n==par[n])return n;\n\treturn par[n]=find(par[n]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x==y)return;\n\tif(cost[x]<cost[y])par[x]=y;\n\telse{\n\t\tpar[y]=x;\n\t\tif(cost[x]==cost[y])cost[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tint ans=0;\n\t\tedge es[m];\n\t\tfor(int i=0;i<m;i++)cin>>es[i].u>>es[i].v>>es[i].cost;\n\t\tsort(es,es+m,comp);\n\t\tinit(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tedge e=es[i];\n\t\t\tif(!same(e.u,e.v)){\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tans+=e.cost;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORR(i,a,b) for(int i=(a);i>(b);i--)\n#define REP(i,n)  FOR(i,0,n)\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//debug\n//-------------------------------------------\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define VISITED 1\n#define NOT_VISITED 0\n#define INF (1<<21)\n\n//typedef\n//-------------------------------------------\ntypedef long long ll;\nint g[101][101];\nint visited[101];\nint d[101];\nint n, m;\n\nint prim() {\n    d[0] = 0;\n\n    while(true) {\n        int min = INF;\n        int u = -1;\n        REP(i, n) {\n            if (visited[i] != VISITED && d[i] < min) {\n                min = d[i];\n                u = i;\n            }\n        }\n        if (u < 0) break;\n\n        visited[u] = VISITED;\n\n        REP(v, n) {\n            if (visited[v] != VISITED && g[u][v] != INF) {\n                if (g[u][v] < d[v]) {\n                    d[v] = g[u][v];\n                }\n            }\n        }\n    }\n    int sum = 0;\n    REP(i, n) sum += d[i];\n    return sum;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true) {\n        cin >> n >> m;\n        if (!n && !m) break;\n        REP(i, n) {\n            visited[i] = NOT_VISITED;\n            d[i] = INF;\n        }\n        REP(i, 101) REP(j, 101) g[i][j] = INF;\n        REP(i, m) {\n            int s, d, c;\n            cin >> s >> d >> c;\n            g[s][d] = c;\n            g[d][s] = c;\n        }\n        cout << prim() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint cost[110][110];\nbool used[110];\n\nint main() {\n\tint n,m;\n\tint a,b,c;\n\twhile(n=in(),m=in()){\n\t\tint i,j;\n\t\tfor(i=0;i<110;i++){\n\t\t\tfor(j=0;j<100;j++){\n\t\t\t\tcost[i][j]=1000;\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\tif(cost[a][b]>c){\n\t\t\t\tcost[a][b]=c;\n\t\t\t\tcost[b][a]=c;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\tque.push(pint(0,0));\n\t\tint res=0;\n\t\twhile(!que.empty()){\n\t\t\tpint p=que.top();\n\t\t\tque.pop();\n\t\t\tif(used[p.second])continue;\n\t\t\tused[p.second]=true;\n\t\t\tres+=p.first;\n//cout<<p.first<<\" \"<<p.second<<endl;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(used[i])continue;\n\t\t\t\tif(cost[p.second][i]==1000)continue;\n\t\t\t\tque.push(pint(cost[p.second][i],i));\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint n, m;\nint cost[101][101];\nint mincost[101];\nbool used[101];\n\n\nint prim() {\n  fill_n(mincost, 101, INF);\n  fill_n(used, 101, false);\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while( 1 ) {\n    int v = -1;\n    Rep(u, n) {\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v]) ) v = u;\n    }\n\n    if( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    Rep(u, n) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n\n  return res;\n}\n\n\t  \nint main()\n{\n  while( cin >> n >> m, n+m ) {\n    fill_n(*cost, 101*101, INF);\n\n    Rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n\n    cout << prim() << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cst;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cst < right.cst;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tpar[x] = y;\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tedge Data[128];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cst);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cst;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\n#define N 101\n\nusing namespace std;\n\nconst int infty = 1<<28;\n\nstruct Node{\n  vector<int> cons;\n  vector<int> costs;\n};\n\nstruct Edge{\n  int src,dst;\n  Edge():src(0),dst(0){}\n  Edge(int s,int d):src(s),dst(d){}\n};\n\nint BruteForceMST(const vector<Node> &G){\n  int ret = 0;\n  bool inMST[G.size()];\n  vector< Node > MST;\n  vector< Edge > MSTE;\n\n  fill( inMST, inMST+G.size(), false );\n  MST.push_back( G[0] );\n  inMST[0]=true;\n  while( MST.size() < G.size() ){\n    int from_id = 0;\n    int next_id = 0;\n    int mincost = infty;\n\n    for(int i = 0; i < MST.size(); ++i){\n      for(int j = 0; j < MST[i].cons.size(); ++j){\n\tif( !inMST[ MST[i].cons[j] ] &&\n\t    mincost > MST[i].costs[j] ){\n\t  from_id = i;\n\t  next_id = MST[i].cons[j];\n\t  mincost = MST[i].costs[j];\n\t}\n      }\n    }\n\n    inMST[ next_id ] = true;\n    ret += mincost;\n    MST.push_back( G[next_id] );\n    MSTE.push_back( Edge(from_id, next_id) );\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    int n,m;\n    vector<Node> G;\n    cin >> n >> m;\n    if( n == 0 && m == 0 ) break;\n    G.resize(n);\n    for(int i = 0; i < m; ++i){\n      int a,b,cost;\n      cin>>a>>b>>cost;\n      G[a].cons.push_back( b );\n      G[a].costs.push_back( cost );\n      G[b].cons.push_back( a );\n      G[b].costs.push_back( cost );\n    }\n    cout << BruteForceMST(G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint cost[128][128];\nint mincost[128];\nbool used[128];\nint V,E;\nvoid init(){\n\trep(i,V)rep(j,V)cost[i][j] = INF;\n\tfill(mincost,mincost+V,INF);\n\tfill(used,used+V,false);\n}\nint prim(){\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\trep(u,V)if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n\t\tif(v == -1)break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\trep(u,V)mincost[u] = min(mincost[u],cost[v][u]);\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tV = n;\n\t\tinit();\n\t\trep(i,m){\n\t\t\tint from,to,pay;\n\t\t\tscanf(\"%d%d%d\",&from,&to,&pay);\n\t\t\tcost[from][to] = pay;\n\t\t\tcost[to][from] = pay;\n\t\t}\n\t\tprintf(\"%d\\n\",prim());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\n\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\n\ntypedef pair<int,pair<int,int> > P;\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n | m) != 0){\n    priority_queue<P,vector<P> ,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,make_pair(a, b)));\n    }\n    UnionFind u(MAXN);\n    int ans = 0;\n    for (int i = 0; i < m; ++i){\n      int from = que.top().second.first;\n      int to = que.top().second.second;\n      int cost = que.top().first;\n      que.pop();\n      if(!u.findSet(to, from)){\n\t//cout << \"cost:\" << cost << \" \" << top.to << \" \" << top.from << endl;\n\tans += cost;\n\tu.unionSet(to,from);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Bridge\n{\n\tint cost;\n\tint edge[ 2 ];\n};\n\nclass BridgeAsc\n{\npublic:\n\tbool operator()( const Bridge& a, const Bridge& b ) const\n\t{\n\t\tif( a.cost < b.cost ) return true;\n\t\treturn false;\n\t};\n};\n\nint main()\n{\n\tint n, m;\n\twhile( cin >> n >> m && ( n || m ) ){\n\t\tvector< Bridge > bridge;\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tBridge b;\n\t\t\tcin >> b.edge[ 0 ] >> b.edge[ 1 ] >> b.cost;\n\t\t\tbridge.push_back( b );\n\t\t}\n\t\tsort( bridge.begin(), bridge.end(), BridgeAsc() );\n\n\t\tint city[ 100 ] = {0};\n\t\tint id = 1;\n\t\tint cntBridge = 0;\n\t\tint index = 0;\n\t\tint ans = 0;\n\t\twhile( cntBridge < n - 1 ){\n\t\t\tBridge b = bridge[ index ];\n\t\t\tint con = 0;\n\t\t\tint x = b.edge[ 0 ];\n\t\t\tint y = b.edge[ 1 ];\n\t\t\tif( city[ x ] != 0 && city[ x ] == city[ y ] ){\n\t\t\t\t++index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( city[ x ] == 0 && city[ y ] == 0 ){\n\t\t\t\tcity[ x ] = city[ y ] = id++;\n\t\t\t}else if( city[ x ] == 0 ){\n\t\t\t\tcity[ x ] = city[ y ];\n\t\t\t}else if( city[ y ] == 0 ){\n\t\t\t\tcity[ y ] = city[ x ];\n\t\t\t}else{\n\t\t\t\tfor( int i = 0; i < n; ++i ){\n\t\t\t\t\tif( city[ i ] == city[ y ] ){\n\t\t\t\t\t\tcity[ i ] = city[ x ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += b.cost;\n\t\t\t++cntBridge;\n\t\t\t++index;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\tBridge(const Bridge& b) : from(b.from), to(b.to), cost(b.cost) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tbridge[i] = Bridge();\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(city[current.to] && city[current.from])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n#include <cctype>\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <map>\n#include <algorithm>\n\n\nusing namespace std;\n\n#define Max INT_MAX\n#define Inf INT_MIN\n\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repi(i,l,n) for(int (i)=(int)(l);(i)<(int)(n);(i)++)\n// s <= x < g ?\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n// 0 <= x < w && 0 <= y < h ?\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\ntypedef pair<int, int> P;\n\n\n#define MaxN 1000\n\nint par[MaxN];\nint rank[MaxN];\n\n//要素数nで木を初期生成\nvoid init(int n){\n   rep(i,n){\n       par[i] = i;\n       rank[i] = 0;\n   }\n   return;\n}\n\nint find(int x){\n    if(par[x] == x) {\n       return x;\n    } else {\n       return par[x] = find( par[x] ); \n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if ( x == y ) { return; }\n\n    if( rank[x] < rank[y] ){\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if( rank[x] == rank[y] ) { rank[x]++; }\n    }\n}\n\nbool same( int x, int y){\n    return find(x) == find(y);\n}\n\n\n\n\nstruct edge{ \n    int u, v, cost;\n\n    edge(int a, int b, int c){\n        u = a; v = b; cost = c;\n    }\n}; \n\n//typedef struct edge edge;\n\nbool comp( const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\n\n#define MaxE 1000\nvector<struct edge> vec;\n//struct edge es[MaxE];\n\nint E;\nint N;\nint kruskal() { \n    sort(vec.begin(), vec.end(), comp);\n    init(1000);\n    int res = 0;\n    rep(i,E){\n        struct edge e = vec[i];\n        if(!same(e.u,e.v)) { \n            unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\n\n\n\n\nint main()\n{\n    while ( cin >> N >> E ){\n        vec.clear();\n        init(100);\n        if( N == 0 && E == 0 ) { break; }\n        int a,b,c;\n        rep(i,E){\n            cin >> a >> b >> c;\n            vec.push_back( edge( a, b, c) );\n        }\n        cout << kruskal() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int u;\n    int v;\n    int cost;\n    bool operator<(const edge& r) const {\n        return cost < r.cost;\n    }\n};\n\nconst int MAXM = 10000;\nconst int MAXN = 110;\nedge es[MAXM];\n\nint par[MAXN];\nint rankrank[MAXN];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        rankrank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (rankrank[x] < rankrank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rankrank[x] == rankrank[y]) rankrank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint kruskal(int m) {\n    sort(es, es+m);\n    int ret = 0;\n    for (int i = 0; i < m; i++) {\n        edge e = es[i];\n        if (!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            ret += e.cost;\n        }\n    }\n    return ret;\n}\n\nint main(void) {\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        for (int i = 0; i < m; i++) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            edge e;\n            e.u = a; e.v = b; e.cost = cost;\n            es[i] = e;\n        }\n        init(n);\n        cout << kruskal(m) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tint from, to, cost;\n\tREP(i, m){\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second; q.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second]){\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nint par[101],rank[101];\nstruct edge{int u,v,cost;};\n\nusing namespace std;\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[101];\nint V,E;\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E){\n    if(V==0 && E==0)break;\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      int edge[n][n];\n      memset(edge,-1,sizeof(edge));\n      for(int i=0;i<m;i++)\n\t{\n\t  int a,b,cost;\n\t  cin>>a>>b>>cost;\n\t  edge[a][b]=cost;\n\t  edge[b][a]=cost;\n\t}\n      bool closed[n];\n      memset(closed,false,sizeof(closed));\n      int cnt=n-1;\n      int ans=0;\n      closed[0]=true;\n      priority_queue<pair<int,int>, vector<pair<int,int> > ,greater<pair<int,int> > > qu;\n      for(int i=0;i<n;i++)\n\t{\n\t  if(edge[0][i]!=-1)\n\t    qu.push(make_pair(i,edge[0][i]));\n\t}\n      while(true)\n\t{\n\t  int pos=qu.top().first;\n\t  int cost=qu.top().second;\n\t  //  cout<<\"#\"<<pos<<\" \"<<cost<<endl;\n\t  qu.pop();\n\t  if(closed[pos])\n\t    continue;\n\t  closed[pos]=true;\n\t  ans+=cost;\n\t  cnt--;\n\t  if(cnt<=0)\n\t    break;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(edge[pos][i]!=-1)\n\t\tqu.push(make_pair(i,edge[pos][i]));\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\n\n// UnionFind??¨ ??????????????????\nclass UnionFindTree{\nprivate:\n  int m_size, unite_count;\n  vector<int> parent;\n  vector<int> rank;\n  int find(int a);\npublic:\n  void init(int size);\n  void unite(int a, int b);\n  bool same(int a, int b);\n  bool isConnected(void);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  m_size = size;\n  unite_count = 0;\n  parent.clear();\n  rank.clear();\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n  }\n  return;\n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  unite_count++;\n  if(rank[x] < rank[y]){ parent[x] = y; }\n  else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// UF??¨??§?????????????????????????????¨???????????????????????????\nbool UnionFindTree::isConnected(void){\n  return unite_count == m_size - 1;\n}\n\nint kruskal(int v, vector<pair<int, pair<int, int> > > sorted_edgelist){\n  int sum = 0;\n  UnionFindTree uf;\n  uf.init(v);\n\n  for(int i = 0; i < (int)sorted_edgelist.size() && !uf.isConnected(); i++){\n    int cost = sorted_edgelist[i].first;\n    int a = sorted_edgelist[i].second.first;\n    int b = sorted_edgelist[i].second.second;\n\n    if(!uf.same(a, b)){\n      sum += cost;\n      uf.unite(a, b);\n    }\n  }\n  \n  return sum;\n}\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n    \n    int a, b, cost;\n    vector<pair<int, pair<int, int> > > edgelist(n);\n    for(int i = 0; i < m; i++){\n      cin >> a >> b >> cost;\n      edgelist.push_back(make_pair(cost, make_pair(a, b)));\n    }\n    sort(edgelist.begin(), edgelist.end());\n    \n    cout << kruskal(n, edgelist) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// テ」ツつーテ」ツδゥテ」ツδ陛ァツ板ィテ」ツδ佚」ツδε」ツδ?\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// テヲツ慊?・ツーツ湘・ツ?ィテ・ツ淞淌ヲツ慊ィ(Minimum Spanning Tree) by Prim Algorithm\n/*\n  g : テ」ツつーテ」ツδゥテ」ツδ?\n  r : テヲツ慊?・ツ按敕」ツ?ォテ・ツ青ォテ」ツつ?ゥツ?づァツつケ\n*/\npair<Weight, Edges> MST(const Graph &g, int r = 0) {\n    int n = g.size(); Edges T; Weight total = 0;\n    vector<bool> visited(n);\n    priority_queue<Edge> q;\n    q.push(Edge(-1, r, 0));\n    while (q.size()) {\n        Edge e = q.top(); q.pop();\n        if (visited[e.dst]) continue;\n        T.push_back(e);\n        total += e.weight;\n        visited[e.dst] = true;\n        for(auto& f: g[e.dst]) if (!visited[f.dst]) q.push(f);\n    }\n    return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n){\n        Graph g(n);\n        rep(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            g[a].emplace_back(a,b,c);\n            g[b].emplace_back(b,a,c);\n        }\n        cout << MST(g).first << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1<<20\n#define MAX_V 100\n\nbool done[MAX_V];\nint d[MAX_V];\nint V;\nint cost[MAX_V+1][MAX_V+1];\n\nint dijkstra(int s) {\n  int total = 0;\n  \n  fill(done, done+V, false);\n  fill(d, d+V, INF);\n  \n  d[s] = 0;\n\n  while(1) {\n    int v = -1;\n    for(int u = 0; u < V; u++) {\n      if(!done[u] && ( v == -1 || d[u]<d[v] )) {\n\tv = u;\n      }\n    }\n    if(v == -1) break;\n\n    done[v] = true;\n\n    for(int u = 0; u < V; u++) {\n      d[u] = min(d[u], d[v] + cost[v][u]);\n    }\n  }\n\n  for(int i=0; i<V; i++) {\n    total += d[i];\n  }\n  \n  return total;\n}\n\nint main() {\n  // テ・ツ、ツ姪」ツ?療」ツ?淌」ツつ嘉ヲツ篠・テァツカツ堙」ツ?古」ツ?ェテ」ツ??ゥツδステ・ツクツづ」ツつ津」ツ?陛」ツ?古」ツ??\n  \n  int m;\n  \n  while(cin>>V>>m && (V||m)) {\n    \n    fill(cost[0], cost[MAX_V], INF);\n    \n    for(int i=0; i<m; i++) {\n      int a, b, cst;\n      cin >> a >> b >> cst;\n      cost[a][a] = cost[b][b] = 0;\n      cost[a][b] = cost[b][a] = cst;\n    }\n\n    int res = INF;\n    \n    for(int i=0; i<V; i++) {\n      for(int j=0; j<V; j++) {\n\tif(i  == j) continue;\n\t// i <-> j テ・ツ、ツ姪」ツ??\n\tint temp = cost[i][j];\n\tcost[i][j] = cost[j][i] = INF;\n\t\n\t// テ」ツ?ゥテ」ツ?禿」ツ?ォテ」ツつづァツケツ凝」ツ?古」ツつ嘉」ツ?ェテ」ツ??」ツつ津ァツ「ツコティツェツ?\n\tint all = 0, cnt = 0;\n\tfor(int k=0; k<V; k++) {\n\t  all ++;\n\t  if(cost[i][k] == INF) cnt ++;\n\t}\n\tif(all == cnt) { goto lpend; }\n\t\n\tall = 0, cnt = 0;\n\tfor(int k=0; k<V; k++) {\n\t  all ++;\n\t  if(cost[j][k] == INF) cnt ++;\n\t}\n\tif(all == cnt) { goto lpend; }\n\n\t/*\n\tfor(int k=0; k<V; k++) {\n\t  int all = 0, cnt = 0;\n\t  for(int l=0; l<V; l++) {\n\t    all ++;\n\t    // テ」ツ?ゥテ」ツ?禿」ツ?ォテ」ツつづァツケツ凝」ツ?古」ツつ嘉」ツ?ェテ」ツ??」ツつ津ァツ「ツコティツェツ?\n\t    if(cost[k][l]==INF) cnt ++;\n\t  }\n\t  if(all == cnt) {\n\t    cost[i][j] = cost[j][i] = temp;\n\t    goto bad;\n\t  }\n\t}\n\t*/\n\t\n\tfor(int I=0; I<V; I++) {\n\t  res = min(dijkstra(I), res);\n\t}\n\t\n      lpend:\n\tcost[i][j] = cost[j][i] = temp;\n      }\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    vector<pair<int,pair<int, int> > > bridge;\n    bool city[101] = {false};\n    int cost = 0;\n    for(int i=0; i<m; i++){\n      int x,y,z;\n      cin >>x>>y>>z;\n      bridge.push_back(make_pair(z,make_pair(x,y)));\n    }\n    sort(bridge.begin(),bridge.end());\n    city[bridge[0].second.first] = true;\n    city[bridge[0].second.second] = true;\n    cost+=bridge[0].first;\n    for(int i=1; i<n; i++){\n      for(int j=0; j<m; j++){\n\tif(city[bridge[j].second.first] && (!city[bridge[j].second.second])){\n\t  cost+=bridge[j].first;\n\t  city[bridge[j].second.second] = true;\n\t  break;\n\t}\n\tif((!city[bridge[j].second.first]) && city[bridge[j].second.second]){\n\t  cost+=bridge[j].first;\n\t  city[bridge[j].second.first] = true;\n\t  break;\n\t}\n      }\n    }\n    cout <<cost<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint par[200];\nint ran[200];\n\nvoid init(int n){\n\trep(i, n){\n\t\tpar[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x == par[x]){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nbool same(int x, int y){\n\tif(find(x) == find(y)) return true;\n\telse return false;\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(ran[x] > ran[y]){\n\t\tpar[y] = x;\n\t}else{\n\t\tpar[x] = y;\n\t\tif(ran[x] == ran[y]) ran[y]++;\n\t}\n}\nPP bridge[10000];\n\nint main(){\n\tint n, m, a, b, c;\n\tint res;\n\twhile(cin >> n >> m && (n ||m)){\n\t\tres = 0;\n\t\tinit(n);\n\t\trep(i, m){\n\t\t\tcin >> bridge[i].second.first >> bridge[i].second.second >> bridge[i].first;\n\t\t}\n\t\tsort(bridge, bridge + m);\n\t\tint pos = 0;\n\t\twhile(n > 1){\n\t\t\tPP pp = bridge[pos++];\n\t\t\ta = pp.second.first;\n\t\t\tb = pp.second.second;\n\t\t\tc = pp.first;\n\t\t\tif(!same(a, b)){\n\t\t\t\tunite(a, b);\n\t\t\t\tn--;\n\t\t\t\tres += c;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d?\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct EDGE\n{\n\tint from, to, cost;\n\tbool operator < (const EDGE& t) const {\n\t\treturn cost < t.cost;\n\t}\n};\n\nint par[100];\nvector<EDGE> v;\n\nvoid init()\n{\n\tfor (int i = 0; i < 100; i++) par[i] = i;\n\tv.clear();\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid _union(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tpar[x] = y;\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tv.push_back((EDGE){a, b, c});\n\t\t\tv.push_back((EDGE){b, a, c});\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < v.size(); i++){\n\t\t\tEDGE& e = v[i];\n\t\t\tif (same(e.from, e.to)) continue;\n\t\t\t_union(e.from, e.to);\n\t\t\tres += e.cost;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstatic const int INF = 99999999;\n\nvoid solve()\n{\n\tint n, m;\n\twhile(cin >> n >> m, n || m)\n\t{\n\t\tvector< vector<int> > Vec(n, vector<int>(n));\n\t\tint from, to, cost;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tVec[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tcin >> from >> to >> cost;\n\t\t\tVec[from][to] = cost;\n\t\t\tVec[to][from] = cost;\n\t\t}\n\t\tvector<int> dist(n);\n\t\tvector<bool> use(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdist[i] = INF;\n\t\t\tuse[i] = false;\n\t\t}\n\t\tdist[0] = 0;\n\t\tint res = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif(!use[i] && (v == -1 || dist[i] < dist[v]))\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v == -1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuse[v] = true;\n\t\t\tres += dist[v];\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tdist[i] = min(dist[i], Vec[v][i]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint V, m;\nint cost[200][200];\nint mincost[200];\nbool used[200];\n\nint prim(){\n  for(int i=0; i < V; ++i){\n    mincost[i] = INT_MAX/2;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u=0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for(int u=0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> V >> m, V | m){\n    for(int i=0; i < V; i++)\n      for(int j=0; j < m; j++)\n        cost[i][j] = INT_MAX/2;\n    for(int i=0; i < m; i++){\n      int a, b, c; cin >> a >> b >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> uni;\nint find(int at){\n    if(at==uni[at]) return at;\n    else return uni[at]=find(uni[at]);\n}\nvoid unite(int a,int b){\n    uni[find(a)]=find(b);\n}\n\nint main(){\n    for(;;){\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0) break;\n        vector<pair<int,pair<int,int> > > costs;\n        uni=vector<int>(n);\n        for(int i=0;i<n;i++){\n            uni[i]=i;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            costs.push_back(make_pair(c,make_pair(a,b)));\n        }\n        sort(costs.begin(),costs.end());\n        int ret=0;\n        for(int i=0;i<costs.size();i++){\n            int a=costs[i].second.first,b=costs[i].second.second,co=costs[i].first;\n            if(find(a)!=find(b)){\n                ret+=co;\n                unite(a,b);\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\n#define f first\n#define s second\n\nclass S{\n\tpublic:\n\tint t;\n\tint v;\n\tS(int t,int v):t(t),v(v){}\n\tbool operator<(const S&a)const{\n\t\treturn v>a.v;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<pair<int,int> > load[111];\n\t\t\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\tload[a].push_back(make_pair(b,c));\n\t\t\tload[b].push_back(make_pair(a,c));\n\t\t}\n\t\t\n\t\tint visit[111]={0};\n\t\t\n\t\tpriority_queue<S> que;\n\t\t\n\t\t\n\t\tvisit[0]=1;\n\t\trep(i,load[0].size()){\n\t\t\tpair<int,int> e = load[0][i];\n\t\t\tque.push(S(e.f, e.s));\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\t\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\t\n\t\t\tS u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.t]==1)continue;\n\t\t\tvisit[u.t]=1;\n\t\t\t\n\t\t\tans+=u.v;\n\t\t\t\n\t\t\t\n\t\t\trep(i,load[u.t].size()){\n\t\t\t\tpair<int,int> e=load[u.t][i];\n\t\t\t\tque.push(S(e.f,e.s));\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0180\n// PCK2008yosen-08\n// パソコン甲子園・・・チームrand()・・・うっ・・・高校時代も今もあいつらとは目を合わせないように生きてきたんだ・・・\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct bridge {\n\tint a;\n\tint b;\n\tint cost;\n\t\n\tbool operator < ( const bridge& com ) const {\n\t\treturn (this->cost < com.cost);\n\t};\n};\n\nint root[110];\nbridge br[10010];\n\nint getroot(int city) {\n\tif ( root[city] == city ) {\n\t\treturn city;\n\t}\n\troot[city] = getroot(root[city]);\n\treturn root[city];\n}\n\nint main(void) {\n\t\n\twhile(true) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif ( n == 0 ) { return 0; }\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tscanf(\"%d %d %d\", &br[i].a, &br[i].b, &br[i].cost);\n\t\t}\n\t\t\n\t\tsort(br, br+m);\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\troot[i] = i;\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tif ( getroot(br[i].a) == getroot(br[i].b) ) { continue; }\n\t\t\t\n\t\t\t// 橋を追加\n\t\t\ttotal += br[i].cost;\n\t\t\tint ra = getroot(br[i].a);\n\t\t\tint rb = getroot(br[i].b);\n\t\t\troot[ra] = rb;\n\t\t\t\n\t\t\tint j;\n\t\t\tfor(j=1; j<n; j++) {\n\t\t\t\tif (getroot(j) != getroot(0)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int aa=0; aa<n; aa++) {\n\t\t\t\tprintf(\"%d \", root[aa]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t\tif ( j == n ) { break; }\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 100\n\nint par[MAX],rank[MAX];\nint V,E;\n\nstruct edge{\n  int u,v,cost;\n};\n\nbool comp(const edge &e1,const edge &e2){\n  return e1.cost < e2.cost;\n}\n\nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nedge es[MAX*MAX];\n\nint kruskal(){\n  init();\n  sort(es,es+E,comp);\n\n  int res = 0;\n  for(int i = 0 ; i < E ; i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      res += e.cost;\n      unite(e.u,e.v);\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> V >> E , (V | E)){\n    int a,b,c;\n    for(int i = 0 ; i < E ; i++){\n      cin >> a >> b >> c;\n      es[i] = (edge){a,b,c};\n    }\n    cout << kruskal() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nclass Load{\n\tpublic:\n\tint n,m,o,p;\n\tload(){p=0;}\n\tload(int a,int b){n=a;m=b;p=0;}\n};\n\nint n,m;\nLoad load[100];\n\nint prim(){\n\tvector<int> visit;\n\tvisit.push_back(0);\n\tint cont=0;\n\t\n\twhile(1){\n\t\tif(visit.size()==n){\n\t\t\tbreak;\n\t\t}\n\t\tint maxi=1000000000;\n\t\tint maxo=0;\n\t\tint maxa=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<visit.size();j++){\n\t\t\t\tif(load[i].n==visit[j]&&load[i].p==0){\n\t\t\t\t\tif(maxi>load[i].o){\n\t\t\t\t\t\tload[i].p=1;\n\t\t\t\t\t\tmaxi=load[i].o;\n\t\t\t\t\t\tmaxo=load[i].m;\n\t\t\t\t\t\tmaxa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(load[i].m==visit[j]&&load[i].p==0){\n\t\t\t\t\tif(maxi>load[i].o){\n\t\t\t\t\t\tload[i].p=1;\n\t\t\t\t\t\tmaxi=load[i].o;\n\t\t\t\t\t\tmaxo=load[i].n;\n\t\t\t\t\t\tmaxa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d\\n\",maxa,maxo,maxi);\n\t\tcont+=maxi;\n\t\tvisit.push_back(maxo);\n\t}\n\treturn cont;\n}\n\nint main(){\n\twhile(1){\n\tcin>>n>>m;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tload[i].n=a;\n\t\t\tload[i].m=b;\n\t\t\tload[i].o=c;\n\t\t\tload[i].p=0;\n\t\t}\n\t\tprintf(\"%d\\n\",prim());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define MAX_N 200\n#define INF 999999999\n\n\nint edge[MAX_N][MAX_N];\n\nint prim(int n){    //n : ???????????°\n    bool used[MAX_N];\n    int mincost[MAX_N];\n    \n    rep(i,n){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    int res=0;\n    \n    while(1){\n        int v=-1;\n        rep(u,n){\n            if(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n                v=u;\n        }\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        \n        rep(u,n){\n            mincost[u]=min(mincost[u],edge[v][u]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        \n        rep(i,200)rep(j,200)edge[i][j]=INF;\n        rep(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            edge[a][b]=edge[b][a]=c;\n        }\n        cout<<prim(n)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"Graph.hpp\"\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}\n       "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define INF 1e9\n\nint prim(vector<vector<pair<int, int> > > adjlist){\n  int n = adjlist.size();\n  vector<int> result(n, INF);\n  int sum = 0;\n  \n  priority_queue<pair<int, int> > wait;\n  wait.push(make_pair(0, 0));\n  result[0] = 0;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(nowcost > result[nowpoint]){ continue; }\n\n    sum += nowcost;\n    result[nowpoint] = -INF;\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        result[nextpoint] = nextcost;\n        wait.push(make_pair(-nextcost, nextpoint));\n      }\n    }\n  }\n\n  return sum;\n}\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n    \n    int a, b, cost;\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      cin >> a >> b >> cost;\n      adjlist[a].push_back(make_pair(cost, b));\n      adjlist[b].push_back(make_pair(cost, a));\n    }\n\n    cout << prim(adjlist) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nstruct Edge{\n\tint a,b,cost;\n\tbool operator <(const Edge &a)const{\n\t\treturn cost<a.cost;\n\t}\n};\n\nint par[100],rank_[100];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i] = i, rank_[i] = 1;\n}\n\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool unite(int a_,int b_){\n\tint a = find(a_), b = find(b_);\n\tif(a==b) return false;\n\tif(rank_[a]<rank_[b]){\n\t\tpar[a] = b;\n\t}\n\telse{\n\t\tpar[b] = a;\n\t\tif(rank_[a]==rank_[b]) rank_[a]++;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint N,M;\n\tEdge e[10000];\n\twhile(cin>>N>>M,N||M){\n\t\tinit(N);\n\t\tfor(int i=0;i<M;i++) cin>>e[i].a>>e[i].b>>e[i].cost;\n\t\tsort(e,e+M);\n\t\tint ans = 0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(unite(e[i].a,e[i].b)) ans += e[i].cost;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nvin par(200);\nvin deep(200);\nvoid init(int n);\nint root(int x);\nvoid unite(int x,int y);\nbool same(int x,int y);\nint a,b,c,res;\n\nint kruskal(int n,int m){\n    vector<tuple<int,int,int>> edge;\n    rep(i,m){\n        cin>>a>>b>>c;\n        edge.push_back(make_tuple(c,a,b));\n    }\n    sort(all(edge));\n    init(n);\n    res=0;\n    for(auto e:edge){\n        if(!same(get<1>(e),get<2>(e))){\n            unite(get<1>(e),get<2>(e));\n            res+=get<0>(e);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    queue<int> ans;\n    while(1){\n        cin>>n>>m;\n        if(n==0&&m==0)break;\n        ans.push(kruskal(n,m));\n    }\n    while(ans.size()){\n        cout<<ans.front()<<endl;\n        ans.pop();\n    }\n}\n\nvoid init(int n){\n    rep(i,n+1){\n        par[i]=i;\n        deep[i]=0;\n    }\n}\nint root(int x){\n    if(par[x]==x)return x;\n    else return par[x]=root(par[x]);\n}\nvoid unite(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y)return;\n    if(deep[x]<deep[y])par[x]=y;\n    else{\n        par[y]=x;\n        if(deep[x]==deep[y])deep[x]++;\n    }\n}\nbool same(int x,int y){\n    return root(x)==root(y);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        int city[102][102];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                city[i][j]=INT_MAX;\n            }\n            city[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            cin>>a>>b>>c;\n            city[a][b]=c;\n            city[b][a]=c;\n        }\n        vector<int>que;\n        vector<int>vec;\n        vec.push_back(0);\n        for(int i=1;i<n;i++){\n            que.push_back(i);\n        }\n        int ret=0;\n        while(!que.empty()){\n            int mi=INT_MAX;\n            int cur=-1,in;\n            for(int j=0;j<que.size();j++){\n                for(int i=0;i<vec.size();i++){\n                    if(city[vec[i]][que[j]]<mi){\n                        mi=city[vec[i]][que[j]];\n                        cur=que[j];\n                        in=j;\n                    }\n                }\n            }\n            ret+=mi;\n            que.erase(que.begin()+in);\n            vec.push_back(cur);\n        }\n        cout<<ret<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct E {\n    int from, to, cost;\n    E(int f, int t, int c) : from(f), to(t), cost(c) { }\n    bool operator <(const E &x) const {\n        return cost < x.cost;\n    }\n};\n\nstruct union_find {\n    vector<int> par;\n    union_find(int n) : par(n, -1) { }\n    bool same(int x, int y) {\n        x = root(x);\n        y = root(y);\n        return x == y;\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x != y) {\n            par[x] += par[y]; par[y] = x;\n        }\n    }\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n};\n\nint kruskal(vector<E> edges, const int N) {\n    sort(edges.begin(), edges.end());\n    union_find uf(N);\n    int res = 0;\n    for(int i = 0; i < (int)edges.size(); i++) {\n        E e = edges[i];\n        if(uf.same(e.from, e.to) == false) {\n            res += e.cost;\n            uf.merge(e.from, e.to);\n        }\n    }\n    return res;\n}\n\nint main() {\n    for(int N, M; cin >> N >> M, N + M != 0; ) {\n        vector<E> edges;\n        for(int i = 0; i < M; i++) {\n            int f, t, c; cin >> f >> t >> c;\n            edges.push_back(E(f, t, c));\n        }\n        int res = kruskal(edges, N);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1e9)\n#define cost first\n#define node second\nusing namespace std;\ntypedef pair <int, int> P;\nint n,m;\nvector<P> G[101];\n\nint prim(){\n  int res = 0;\n  bool visited[101]={};\n  int D[101];\n  for(int i=0;i<n;i++) D[i] = INF;\n  priority_queue <P, vector<P>, greater<P> > Q;\n  Q.push(P(0,0));\n  while(!Q.empty()){\n    P t = Q.top(); Q.pop();\n    if(visited[t.node]) continue;\n    visited[t.node] = true;\n    res += t.cost;\n    for(int i=0;i<G[t.node].size();i++){\n      int nnode = G[t.node][i].node;\n      int ncost = G[t.node][i].cost;\n      if(D[nnode] > ncost) Q.push(P(ncost,nnode)),D[nnode]=ncost;\n    }\n  }\n  return res;\n}\nvoid init(int n){\n  for(int i=0;i<n;i++) G[i].clear();\n}\n\nint main() {\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m ==0) break;\n    init(n);\n    for(int i=0;i<m;i++) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      G[a].push_back((P){c,b});\n      G[b].push_back((P){c,a});\n    }\n    cout << prim()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< vector< PII > > G( n );\n\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\n\t\t\tG[a].PB( MP( b, c ) );\n\t\t\tG[b].PB( MP( a, c ) );\n\t\t}\n\n\t\tpriority_queue< PII, vector< PII >, greater< PII > > que;\n\t\tque.push( MP( 0, 0 ) );\n\n\t\tvector< bool > used( n, false );\n\n\t\tint res = 0;\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tauto cur = que.top();\n\t\t\tque.pop();\n\n\t\t\tif ( used[ cur.snd ] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tused[ cur.snd ] = true;\n\t\t\tres += cur.fst;\n\n\t\t\tEACH( e, G[ cur.snd ] )\n\t\t\t{\n\t\t\t\tauto next = MP( e.snd, e.fst );\n\n\t\t\t\tque.push( next );\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint data[101][101];\n\nint prim( int n )\n{\n\tvector<int> key( n, 9999999 );\n\tkey[0] = 0;\n\tmap<int,int> pq;\n\tbool inQueue[101];\n\tfor( int i = 0;i < 101;i++ ) inQueue[i] = true;\n\tfor( int i = 0;i < n;i++ ){\n\t\tpq.insert( pair<int,int>( i, key[i] ) );\n\t}\n\n\twhile( !pq.empty() ){\n\t\tmap<int,int>::iterator target = pq.begin();\n\t\tfor( map<int,int>::iterator it = pq.begin();it != pq.end();it++ ){\n\t\t\tif( target->second > it->second ) target = it;\n\t\t}\n\t\tint u = target->first;\n\t\tpq.erase( target );\n\t\tinQueue[u] = false;\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tif( data[u][i] ){\n\t\t\t\tif( inQueue[i] ){\n\t\t\t\t\tint w = data[u][i];\n\t\t\t\t\tif( w < key[i] ){\n\t\t\t\t\t\tkey[i] = w;\n\t\t\t\t\t\tpq[i] = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint answer = 0;\n\tfor( int i = 0;i < n;i++ ){\n\t\tanswer += key[i];\n\t}\n\n\treturn answer;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n,m;\n\tint a,b,cost;\n\n\twhile( cin >> n >> m && n != 0 ){\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0;i < m;i++ ){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tdata[a][b] = cost;\n\t\t\tdata[b][a] = cost;\n\t\t}\n\n\t\tint answer = prim( n );\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n\n// int N, M, A[10010], B[10010], COST[10010];\n// pair<int, int> bridge[10010];\nint P[10010];//村のrootが保存\n\nvoid init(int N){\n  for(int i=0; i< N; ++i){\n    P[i]= i;\n  }\n}\n\nint root(int a){//aのroot(代表元)を決める\n  if(P[a]==a) return a;//aはroot\n  return (P[a] = root(P[a]));//aの親のrootを求め,aの親とする\n}\nbool is_same_set(int a, int b){\n  return root(a) == root(b);\n}\nvoid unite(int a, int b){\n   P[root(a)] = root(b);\n}\n\n\nint main(){\n  int N, M, A[10010], B[10010], COST[10010];\n  pair<int, int> bridge[10010];\n\n  //root決める\n  while(cin >> N >> M  && N>0){\n    int allcost = 0;\n    int bridgenum = 0;\n    init(N);\n    for (int i = 0; i < M; ++i)\n    {\n      cin >> A[i] >> B[i] >> COST[i];\n      bridge[i].first = COST[i];\n      bridge[i].second = i ;\n    }\n    sort(bridge,bridge+M);\n    for (int i = 0; i < M; ++i)\n    {\n      int cost = bridge[i].first;\n      int a = A[bridge[i].second];\n      int b = B[bridge[i].second];\n\n      if (bridgenum == M-1)\n      {\n        unite(a,b);\n      }\n      if(is_same_set(a,b)){\n\n      }else{\n        unite(a,b);\n        allcost += cost;\n        // cout <<  allcost << endl;\n        bridgenum += 1;\n      }\n\n\n      // 「a から b に cost の橋がかかっている」と表示\n    }\n    cout <<  allcost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct edge{ int to, cost; };\ntypedef pair<int, int> P;\n\nint m, n;\n\nint main()\n{\n    while(cin >> n >> m && n) {\n        int a,b,cost;\n        vector<vector<edge> > es(n);\n        for(int i = 0; i < m; i++) {\n            cin >> a >> b >> cost;\n            es[a].push_back((edge){b, cost});\n            es[b].push_back((edge){a, cost});\n        }\n\n        int ans = 0;\n        priority_queue< P, vector<P>, greater<P> > que;\n        que.push(P(0, 0));\n        bool visit[n];\n        fill(visit, visit + n, false);\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            if(visit[p.second]) \n                continue;\n            \n            visit[p.second] = true;\n            ans += p.first;\n            \n            for(int i = 0; i < es[p.second].size(); i++)\n                que.push(P(es[p.second][i].cost, es[p.second][i].to));\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n　　　  ∧＿∧　やあ\n　　 （´・ω・｀)　　　　　/　　　　　ようこそ、バーボンハウスへ。\n　　 ／∇y:::::＼　　　 [￣]　　　　　このテキーラはサービスだから、まず飲んで落ち着いて欲しい。\n　　 |:⊃:|:::::|　　　|──|\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　うん、「また」なんだ。済まない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|￣　  仏の顔もって言うしね、謝って許してもらおうとも思っていない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣／|\n　　　　∇　∇　∇　∇　　　／.／|　　　でも、この提出を見たとき、君は、きっと言葉では言い表せない\n　　　　┴　┴　┴　┴　／ ／　  |　　　「ときめき」みたいなものを感じてくれたと思う。\n￣￣￣￣￣￣￣￣￣￣|／　　  |　　　殺伐としたコンテストの中で、そういう気持ちを忘れないで欲しい\n￣￣￣￣￣￣￣￣￣￣　　　　 |　　　そう思って、この提出を投げたんだ。\n　　　(⊆⊇)　(⊆⊇)　(⊆⊇)　　|\n　    ||　　 ||　　||　　|　　　 じゃあ、判定を聞こうか。\n　　.／|＼　／|＼ ／|＼\n*/\n\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define fst first\n#define snd second\n#define mp make_pair\n#define ALL(obj) (obj).begin(),(obj).end()\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n) \n#define SIZE(x) ((int)(x).size())\n#define debug(x) cerr << #x << \" -> \" << x << \" (line:\" << __LINE__ << \")\" << '\\n';\n#define debugpair(x, y) cerr << \"(\" << #x << \", \" << #y << \") -> (\" << x << \", \" << y << \") (line:\" << __LINE__ << \")\" << '\\n';\ntypedef long long lint;\ntypedef pair<int, int> pint;\ntypedef pair<lint, lint> plint;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> matrix;\ntypedef priority_queue<lint> p_que;\ntypedef priority_queue<lint, vector<lint>, greater<lint>> p_que_rev;\nconst lint INF = INT_MAX;\nconst lint LINF = LLONG_MAX;\nconst lint MOD = 1000000000 + 7;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nconst int di[]{0, -1, 0, 1, -1, -1, 1, 1};\nconst int dj[]{1, 0, -1, 0, 1, -1, -1, 1};\n\nlint gcd(lint a, lint b) {\n    lint r;\n    while (b != 0) {\n        r = a % b;\n        a = b; \n        b = r;\n    }\n    return a;\n}\n\nlint lcm(lint a, lint b) {\n    return (a / gcd(a, b)) * b;\n}\n\nlint power(lint x, lint n, lint mod = MOD) {\n    lint ret = 1;\n    while(n > 0) {\n        if(n & 1){\n            (ret *= x) %= mod;\n        }\n        (x *= x) %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvector<lint> make_power(int n, lint base){\n    lint num = 1;\n    vector<lint> ret;\n    for (int i=0; i<=n; ++i){\n        ret.push_back(num);\n        num *= base;\n    }\n    return ret;\n}\n\n// Graph Templates\nusing Weight = lint;\n// using Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    // Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n//const Weight INF = numeric_limits<Weight>::max() / 8;\n\n// add edge a <--(weight = w)--> b\nvoid add_edge(Graph &g, int a, int b, Weight w) {\n    g[a].push_back(Edge(a, b, w));\n    g[b].push_back(Edge(b, a, w));\n}\n\n// add edge a --(weight = w)--> b\nvoid add_arc(Graph &g, int a, int b, Weight w) { g[a].push_back(Edge(a, b, w)); }\n\nstruct uf_tree {\n    std::vector<int> parent;\n    int __size;\n    uf_tree(int size_) : parent(size_, -1), __size(size_) {}\n    void unite(int x, int y) {\n        if ((x = find(x)) != (y = find(y))) {\n            if (parent[y] < parent[x]) std::swap(x, y);\n            parent[x] += parent[y];\n            parent[y] = x;\n            __size--;\n        }\n    }\n    bool is_same(int x, int y) { return find(x) == find(y); }\n    int find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n    int size(int x) { return -parent[find(x)]; }\n    int size() { return __size; }\n};\n\n// Kruskal\npair<Weight, Edges> kruskal(Graph const &g) {\n    uf_tree uf(g.size());\n    Edges es;\n    for (auto &adj : g)\n        for (auto &e : adj) es.emplace_back(e);\n    sort(es.begin(), es.end(), [](const Edge &e, const Edge &f) { return e.weight < f.weight; });\n    Weight total = 0;\n    Edges T;\n    for (auto &e : es)\n        if (!uf.is_same(e.src, e.dst)) {\n            T.push_back(e);\n            total += e.weight;\n            uf.unite(e.src, e.dst);\n        }\n    return make_pair(total, T);\n}\n\nint main(){\n    int n, m;\n    int s, t;\n    Weight w;\n    Graph g;\n    while(cin >> n >> m){\n        if(n == 0 && m == 0){\n            break;\n        }\n        g.clear();\n        g.resize(n);\n        for (int i=0; i<m; ++i){\n            cin >> s >> t >> w;\n            add_edge(g, s, t, w);\n        }\n        pair<Weight, Edges> ans = kruskal(g);\n        cout << ans.first << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define\tmp(a,b)\t\tmake_pair(a,b)\n#define\tmt(a,b,c)\tmp(mp(a,b),c)\n#define\t_1st\tfirst.first\n#define\t_2nd\tfirst.second\n#define\t_3rd\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int> pii;\ntypedef pair<pii,int> tiii;\n\nvector<int> city;\n\nint UF_Root(int i)\n{\n\tif (city[i]==-1)\treturn i;\n\treturn city[i]=UF_Root(city[i]);\n}\n\nbool UF_Find(int i,int j)\n{\n\treturn UF_Root(i)==UF_Root(j);\n}\n\nvoid UF_Union(int i,int j)\n{\n\ti=UF_Root(i);\n\tj=UF_Root(j);\n\tif(i!=j)\tcity[j]=i;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tcity=vector<int>(n,-1);\n\n\t\tvector<tiii> data(m);\n\t\twhile(m--){\n\t\t\tint a,b,c;\tcin>>a>>b>>c;\n\t\t\tdata[m]=mt(c,a,b);\n\t\t}\n\t\tsort(data.begin(),data.end());\n\n\t\tint totalcost=0;\n\t\tfor(int i=0;i<data.size();i++){\n\t\t\tif(!UF_Find(data[i]._2nd,data[i]._3rd)){\n\t\t\t\tUF_Union(data[i]._2nd,data[i]._3rd);\n\t\t\t\ttotalcost+=data[i]._1st;\n\t\t\t}\n\t\t}\n\t\tcout<<totalcost<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \";if(_c.size()){cout<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;}cout<<\" ]\"<<endl; }\n}\nostream &operator<<(ostream &os, const pair<int,int> &p){return(os<<\"(\"<<p.first<<\",\"<<p.second<<\")\");}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tn>\nclass UnionFind {\n    int m_node;\n    vector<_Tn> node;\npublic:\n    UnionFind(int n = 0){ init(n);}\n    void init(int n){ m_node = n; node = vector<_Tn>(n,-1); }\n    bool connect(_Tn n1, _Tn n2){\n        dbgchk(n1 < 0 || n2 < 0 || n1 >= m_node || n2 >= m_node);\n        n1 = root(n1); n2 = root(n2);\n        if(n1 == n2) return false;\n        if(node[n1] > node[n2]) swap(n1,n2);\n        node[n1] += node[n2]; node[n2] = n1;\n        return true;\n    }\n    bool is_connect(_Tn n1, _Tn n2){ return root(n1) == root(n2); }\n    _Tn root(_Tn n){\n        dbgchk(n < 0 || n >= m_node);\n        return (node[n] < 0) ? n : root(node[n]);\n    }\n    int size(_Tn n){\n        idbgchkf(n < 0 || n >= m_node);\n        return -node[root(n)];\n    }\n    void dbgprint(){\n        REP(i,m_node){\n            if(node[i] >= 0) continue;\n            printf(\"(%d:%d\", -node[i], i);\n            REP(j,m_node){\n                if(i == j) continue;\n                if(root(j) == i) printf(\",%d\", j);\n            }\n            printf(\"),\");\n        }\n        printf(\"\\n\");\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass kruskal_branch {\npublic:\n    _T1 node1, node2;\n    _T2 weight;\n    kruskal_branch(_T1 n1, _T1 n2, _T2 w) : node1(n1), node2(n2), weight(w) {;}\n    bool operator> (const kruskal_branch<_T1, _T2> &p) const { return (weight > p.weight); }\n};\n\ntemplate <class _T1, class _T2>\nclass kruskal {\npublic:\n    typedef kruskal_branch<_T1,_T2> kruskal_branch_t;\n    typedef priority_queue<kruskal_branch_t, vector<kruskal_branch_t>, greater<kruskal_branch_t> > kruskal_queue_t;\nprivate:\n    int m_nodes;\n    kruskal_queue_t queue, mintree;\n    UnionFind<_T1> node;\npublic:\n    kruskal() : m_nodes(0){;}\n    void nodenum_set(int n){ m_nodes = MAX(m_nodes, n); }\n    void branch_add(kruskal_branch_t &b){\n        dbgchk(b.node1 < 0 || b.node2 < 0);\n        queue.push(b); m_nodes = MAX(m_nodes, MAX(b.node1+1, b.node2+1));\n    }\n    kruskal_queue_t &get_mintree(void){ return mintree; }\n    UnionFind<_T1> &get_node(void){ return node; }\n\n    _T2 solve(){\n        _T2 totalcost = 0;\n        node.init(m_nodes);\n        for(; !queue.empty(); queue.pop()){\n            const kruskal_branch_t &b = queue.top();\n            if(!node.is_connect(b.node1, b.node2)){\n                mintree.push(b);\n                totalcost += b.weight;\n                node.connect(b.node1, b.node2);\n            }\n        }\n        return totalcost;\n    }\n};\n\ntypedef kruskal<int,int> kruskal_t;\ntypedef kruskal_t::kruskal_queue_t kruskal_queue_t;\ntypedef kruskal_t::kruskal_branch_t kruskal_branch_t;\n\nint solve(int n, kruskal_t &k){\n    k.solve();\n    kruskal_queue_t &mintree = k.get_mintree();\n\n    int total = 0;\n    for(; !mintree.empty(); mintree.pop()){\n        const kruskal_branch_t &b = mintree.top();\n        pf(\"node1 = %d, node2 = %d, weight = %d\\n\", b.node1, b.node2, b.weight);\n        total += b.weight;\n    }\n    return total;\n}\n\nint main(){\n    int n, m;\n\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        kruskal_t k;\n        REP(i,m){\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            kruskal_branch_t branch(a, b, cost);\n            k.branch_add(branch);\n        }\n        cout << solve(n, k) << endl;;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,m;\nint mp[101][101];\n\nint check() {\n  int flg[101] ={};\n  int dis[101];\n  int sum = 0;\n  for(int i=0;i<n;i++) dis[i] = 1000000000;\n  dis[0]  = 0;\n\n  for(int k=0;k<n;k++) {\n    int mincost = 1000000000;\n    int ima;\n    for(int i=0;i<n;i++) {\n      if(mincost > dis[i] && flg[i] == 0) {\n\tmincost = dis[i];\n\tima = i;\n      }\n    }\n    sum += mincost;\n    flg[ima] = 1;\n    // cout << mincost<<endl;;\n    \n    for(int i=0;i<n;i++) \n      if(mp[ima][i] < dis[i] && flg[i] == 0 )\n\tdis[i] = mp[ima][i];\n  }\n\n\n  return sum;\n\n}\n\nint main() {\n  \n  while(1) {\n    cin >> n >> m;\n\n    if(n == 0 && m ==0) break;\n\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++)\n\tmp[i][j] = 1000000000;\n\n    int a,b,cost;\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> cost;\n      mp[a][b] = cost;\n      mp[b][a] = cost;\n    }\n    \n    \n    int ans = check();\n    \n    cout << ans << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n && !m)\n\t\t\tbreak;\n\t\tint bridge[101][101];\n\t\tint pre_vertex[101][101];\n\t\tint a,b,cost;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tbridge[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tbridge[i][j] = INF;\n\t\t\t\tpre_vertex[i][j] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tif(bridge[a][b] > cost){\n\t\t\t\tbridge[a][b] = cost;\n\t\t\t\tbridge[b][a] = cost;\n\t\t\t}\n\t\t}\n\t\t//ツフツδ債イツド\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint dis = bridge[i][k]+bridge[k][j];\n\t\t\t\t\tif(dis < bridge[i][j]){\n\t\t\t\t\t\tbridge[i][j] = dis;\n\t\t\t\t\t\tpre_vertex[i][j] = pre_vertex[k][j];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tsum += bridge[i][j];\n\t\t\t\tsum -= bridge[i][pre_vertex[i][j]];\n\t\t\t}\n\t\t\tif(sum < min)\n\t\t\t\tmin = sum;\n\t\t}\n\t\tcout << min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct node {\n    int weight;\n    int to_id;\n\n    node(int t, int w) {\n        this->weight = w;\n        this->to_id = t;\n    }\n    bool operator>(node const &rhs) const {\n        if (this->weight > rhs.weight) { return true; }\n        else if (this->weight < rhs.weight) { return false; }\n        if (this->to_id > rhs.to_id) { return true; }\n        else if (this->to_id < rhs.to_id) { return false; }\n        return false;\n    }\n};\n\n// Graph:\ntypedef std::vector<std::vector<node>> Graph;\n\nint prim(Graph const &input) {\n    std::vector<bool> used(input.size(), false);\n    int used_count = 0;\n    int total_weight = 0;\n    std::priority_queue<node, std::vector<node>, std::greater<node>> que;\n\n    used[0] = true; used_count++;\n    for (auto const &e: input[0]) que.push(e);\n    while (used_count < input.size()) {\n        // std::cout << que.size() << \"; \" << used_count << std::endl;\n        assert(!que.empty());\n        node s = que.top();\n        que.pop();\n        if (used[s.to_id]) continue;\n        // std::cout << \"marked \" << s.to_id << \" as used.\" << std::endl;\n        used[s.to_id] = true; used_count++;\n        total_weight += s.weight;\n        for (auto const &e: input[s.to_id]) que.push(e);\n    }\n    return total_weight;\n}\n\nint main(void)\n{\n    int n, m;\n    while ( std::cin >> n >> m, n) {\n        Graph g(n);\n        for (int i = 0; i < m; i++) {\n            int f, t, c;\n            std::cin >> f >> t >> c;\n            g[f].emplace_back(t, c);\n            g[t].emplace_back(f, c);\n        }\n\n        std::cout << prim(g) << std::endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      int edge[n][n];\n      memset(edge,-1,sizeof(edge));\n      for(int i=0;i<m;i++)\n\t{\n\t  int a,b,cost;\n\t  cin>>a>>b>>cost;\n\t  edge[a][b]=cost;\n\t  edge[b][a]=cost;\n\t}\n      bool closed[n];\n      int cnt=n-1;\n      int ans=0;\n      memset(closed,false,sizeof(closed));\n      closed[0]=true;\n      priority_queue<pair<int,int>, vector<pair<int,int> > ,greater<pair<int,int> > > qu;\n      for(int i=0;i<m;i++)\n\t{\n\t  if(edge[0][i]!=-1)\n\t    qu.push(make_pair(i,edge[0][i]));\n\t}\n      while(true)\n\t{\n\t  int pos=qu.top().first;\n\t  int cost=qu.top().second;\n\t  qu.pop();\n\t  if(closed[pos])\n\t    continue;\n\t  closed[pos]=true;\n\t  ans+=cost;\n\t  cnt--;\n\t  if(cnt<=0)\n\t    break;\n\t  for(int i=0;i<m;i++)\n\t    {\n\t      if(!closed[i]&&edge[pos][i]!=-1)\n\t\tqu.push(make_pair(i,edge[pos][i]));\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}\n       \n       \n       \n     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\n\nconst int INF = 100000000;\n\nstruct edge {\n    int to, cost;\n    bool operator<(const edge& r)const{\n        return cost>r.cost;\n    }\n};\n\n// state = edge\n// struct state {\n//     int from, d;\n// };\nvector<vector<edge> > G;\nint V;\n\nbool used[111];\nint prim(){\n    int sum=0;\n    int es=0;\n    memset(used,0,sizeof(used));\n    priority_queue<edge> q;\n    q.push({0,0});\n    while(es!=G.size()){\n        edge e=q.top(); q.pop();\n        if(used[e.to])continue;\n        es++;\n        used[e.to]=1;\n        int from=e.to;\n        //cout<<\" \"<<from<<endl;\n        sum+=e.cost;\n        FOR(i,0,G[from].size()){\n            q.push(G[from][i]);\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int m;\n    while(1){\n        cin>>V>>m;\n        if(!(m||V))break;\n        G=vector<vector<edge> >(V);\n        FOR(i,0,m){\n            int a,b,cost;cin>>a>>b>>cost;\n            G[a].push_back({b,cost});\n            G[b].push_back({a,cost});\n        }\n        cout<<prim()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint n,m,sum,r;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tif(P[b[bridge[i].second]] != P[a[bridge[i].second]]) {\n\t\t\t\tif(P[a[bridge[i].second]] == a[bridge[i].second]) {\n\t\t\t\t\tP[a[bridge[i].second]] = P[b[bridge[i].second]];\n\t\t\t\t\tr = a[bridge[i].second];\n\t\t\t\t} else {\n\t\t\t\t\tP[b[bridge[i].second]] = P[a[bridge[i].second]];\n\t\t\t\t\tr = b[bridge[i].second];\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<n; ++k) {\n\t\t\t\t\tif(P[k] == r) {\n\t\t\t\t\t\troot(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += bridge[i].first;\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m,a[10010],b[10010],cost[10010];\nint parent[101];\npair<int,int> bridge[10010];\nvoid init(int N){\n\tfor(int i=0;i<N;i++)parent[i]=i;\n}\nint root(int a){\n\tif(parent[a]==a)return a;\n\treturn (parent[a]=root(parent[a]));\n}\nbool is_same_set(int a,int b){\n\treturn (root(a)==root(b));\n}\nvoid unite(int a,int b){\n\tparent[root(a)]=root(b);\n}\n\nint main(){\n\twhile(cin>>n>>m&&n>0){\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a[i]>>b[i]>>cost[i];\n\t\t\tbridge[i].first=cost[i];\n\t\t\tbridge[i].second=i;\n\t\t}\n\t\tsort(bridge, bridge+m);\n\t\tinit(n);\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(is_same_set(a[bridge[i].second],b[bridge[i].second]))continue;\n\t\t\tunite(a[bridge[i].second],b[bridge[i].second]);\n\t\t\tans+=bridge[i].first;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n;\n  bool f;\n  State(int d = 0, int n = 0, bool f = false):d(d),n(n),f(f){}\n  bool operator < (const State &s) const {return d > s.d;}\n};\n\nint Dijkstra(int start/*, int goal*/, vector<vector<int> > Graph){\n\n  int size = Graph.size();\n  vector<State> d(size);\n  priority_queue<State> Q;\n  State u,v;\n\n  for(int i=0;i<size;i++){\n    d[i].d = INF;\n    d[i].f = false;\n    }\n  u.d = d[start].d = 0;\n  u.n = start;\n  Q.push(u);\n\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n\n    if(d[u.n].f) continue;\n    d[u.n].f = true;\n\n    for(int i=0;i<size;i++){\n      if(!d[i].f && /*d[u.n].d +*/ Graph[u.n][i] < d[i].d){\n\tv = u;\n\tv.d = d[i].d = /*d[u.n].d +*/ Graph[u.n][i];\n\tv.n = i;\n\tQ.push(v);\n      }\n    }\n  }\n  /*return d[goal].d;*/\n  int ans = 0;\n  for(int i=0;i<size;i++) ans += d[i].d;\n  return ans;\n\n}\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > G(n);\n    for(int i=0;i<n;i++){\n      vector<int> v(n);\n      v.assign(n,INF);\n      G[i] = v;\n    }\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      G[a][b] = G[b][a] = c;\n    }\n    cout << Dijkstra(0,G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define TOSHI_MAX 100\n#define COST_MAX 10\nusing namespace std;\n\nint prim(int data[TOSHI_MAX][TOSHI_MAX], int toshiNum) {\n  bool visited[toshiNum];\n  int cost[toshiNum];\n  for(int i = 0; i < toshiNum; i++) {\n    visited[i] = false;\n    cost[i] = COST_MAX;\n  }\n  cost[0] = 0;\n  while(1) {\n    int min = COST_MAX;\n    int p;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && cost[i] < min) {\n\tmin = cost[i];\n\tp = i;\n      }\n    }\n    if(min == COST_MAX) break;\n\n    visited[p] = true;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && data[p][i] < cost[i]) {\n\tcost[i] = data[p][i];\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int i = 0; i < toshiNum; i++) {\n    if(cost[i] != COST_MAX) ans += cost[i];\n  }\n\n  return ans;\n}\n\nint main() {\n  while(1) {\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    int data[TOSHI_MAX][TOSHI_MAX];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tdata[i][j] = COST_MAX;\n      }\n    }\n\n    for(int i = 0; i < m; i++) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      data[a][b] = data[b][a] = cost;\n    }\n\n    cout << prim(data, n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define INF 2000000000\n\nusing namespace std;\n\nint main(void){\n\tint n,m;\n\t\n\twhile(cin >> n >> m){\n\t\tif((n|m) == 0) break;\n\t\t\n\t\tint s,t,cost;\n\t\t\n\t\tint f[n][n];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tf[i][j] = INF;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> s >> t >> cost;\n\t\t\tf[s][t] = cost;\n\t\t\tf[t][s] = cost;\n\t\t}\n\t\t//Minimum Spaning Tree\n\t\tvector<int> connected;\n\t\tconnected.push_back(0);\n\t\tint ret = 0;\n\t\twhile(connected.size() != n){\n\t\t\tint mini=INF,tmp,tmpindex;\n\t\t\tfor(int i=0;i<connected.size();i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(f[connected[i]][j] < mini && \n\t\t\t\t\tfind(connected.begin(),connected.end(),j) == connected.end()){\n\t\t\t\t\t\tmini = f[connected[i]][j];\n\t\t\t\t\t\ttmpindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += mini;\n\t\t\tconnected.push_back(tmpindex);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,a,b) for(int (i)=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\n\nstruct UnionFind {\n    vector<int> p;\n    UnionFind(int n) : p(n, -1) {};\n    bool unite(int u, int v) {\n        if ((u = root(u)) == (v = root(v))) return false;\n        if (p[u] > p[v]) swap(u, v);\n        p[u] += p[v]; p[v] = u;\n        return true;\n    }\n    bool find(int u, int v) { return root(u) == root(v); }\n    int root(int u) { return p[u] < 0 ? u : p[u] = root(p[u]); }\n    int size(int u) { return -p[root(u)]; }\n};\n\nstruct Edge {\n    int src, dst, cost;\n    Edge(int s, int d, int c) : src(s), dst(d), cost(c) {};\n    bool operator<(const Edge& e) const {\n        return cost < e.cost;\n    }\n};\n\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<Edge> es;\n        rep(i, m) {\n            int a, b, c; cin >> a >> b >> c;\n            es.emplace_back(a, b, c);\n        }\n        sort(es.begin(), es.end());\n        UnionFind uf(n);\n        int tot = 0;\n        for (auto&& e : es) {\n            if (uf.unite(e.src, e.dst))\n                tot += e.cost;\n        }\n        cout << tot << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nvector<P> branch[128];\n\nint prim();\n\nint main()\n{\n    while (scanf(\"%d %d\", &n, &m), n != 0){\n        for (int i = 0; i < n; i++) branch[i].clear();\n\n        for (int i = 0; i < m; i++){\n            int a, b, c;\n\n            scanf(\"%d %d %d\", &a, &b, &c);\n            branch[a].push_back(P(c, b));\n            branch[b].push_back(P(c, a));\n        }\n        printf(\"%d\\n\", prim());\n    }\n\n    return 0;\n}\n\nint prim()\n{\n    bool v[1024];\n    priority_queue<P, vector<P>, greater<P> > q;\n    int sum = 0;\n\n    q.push(P(0, 0));\n    v[0] = 0;\n    while (!q.empty()){\n        P p = q.top(); q.pop();\n\n        if (v[p.second]) continue;\n        v[p.second] = true;\n        sum += p.first;\n        for (int i = 0; i < branch[p.second].size(); i++){\n            q.push(branch[p.second][i]);\n        }\n    }\n\n    return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Union-Find\nstruct union_find{\n\tvector<int> par, rank;\n\t\n\t// コンストラクタで初期化\n\tunion_find(int n){\n\t\tvector<int> v(n);\n\t\tpar = v;\n\t\trank = v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t// x の root を返す\n\tint find(int x){\n\t\treturn ( par[x] == x )? x : (par[x] = find(par[x]) ) ;\n\t}\n\t// x と y の属する集合を併合する\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x == y ) return;\n\t\t\n\t\tif( rank[x] < rank[y] ){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif( rank[x] == rank[y] )\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\t// x と y が同じ集合に属するかどうか\n\tbool same(int x, int y){\n\t\treturn ( find(x) == find(y) );\n\t}\n};\n\nstruct edge{\n\tint u,v,cost;\n\tedge(int u_, int v_, int cost_){\n\t\tu = u_;\n\t\tv = v_;\n\t\tcost = cost_;\n\t}\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\n// 辺集合\nvector<edge> es;\n// 頂点数\nint V;\n\n// 初期化\nvoid init(int n){\n\tV = n;\n\tes.clear();\n}\n\n// 最小全域木を求める (クラスカル法)\nint kruskal(){\n\t// コストの小さい順にソート\n\tsort( es.begin() , es.end() , comp );\n\t// 頂点数で初期化\n\tunion_find uf( V );\n\tint res = 0;\n\tfor(int i = 0 ; i < es.size() ; i++ ){\n\t\tedge e = es[i];\n\t\tif( !uf.same( e.u , e.v ) ){\n\t\t\tuf.unite( e.u , e.v );\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n// 重み cost の辺(u,v)の追加\nvoid add_edge(int u, int v, int cost){\n\tedge e(u,v,cost);\n\tes.push_back( e );\n}\n\nint main(){\n\tint n,m;\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit( n );\n\t\tfor(int i = 0 ; i < m ; i++ ){\n\t\t\tint u, v, c ;\n\t\t\tcin >> u >> v >> c;\n\t\t\tadd_edge( u , v , c );\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[b][a] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       auto top = que.top();\n       que.pop();\n       if(frag[top.second] == false){\n\t cost_sum += top.first;\n\t frag[top.second] = true;\n\t current = top.second;\n\t break;\n\t }\n     }  \n  }\n  return cost_sum;\n}\n       \n       \n       \n     \n     \n     \n     "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\n#define f first\n#define s second\n\nclass E{\n\tpublic:\n\tint a,b,v;\n\tE(int a,int b,int v):a(a),b(b),v(v){}\n\tbool operator<(const E&a)const{\n\t\treturn v<a.v;\n\t}\n};\n\n\nclass T{\n\tpublic:\n\tint bef;\n\tvector<int> ko;\n};\n\nT uf[111];\n\n\nvoid ufto(int a,int b){\n\tuf[b].bef = a;\n\tuf[a].ko.push_back(b);\n\t\n\trep(i,uf[b].ko.size()){\n\t\tufto(a,uf[b].ko[i]);\n\t}\n\tuf[b].ko.clear();\n}\n\nint find(int a){\n\treturn uf[a].bef;\n}\nvoid unit(int a,int b){\n\tufto(find(a),find(b));\n}\nint check(int a,int b){\n\treturn find(a)==find(b);\n}\n\nint main(){\n\twhile(1){\n\t\trep(i,111){\n\t\t\tuf[i].bef=i;\n\t\t\tuf[i].ko.clear();\n\t\t}\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\t\n\t\tif(n==0)break;\n\t\t\n\t\tvector<E> ed;\n\t\t\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\ted.push_back(E(a,b,c));\n\t\t}\n\t\t\n\t\t\n\t\tsort(ed.begin(),ed.end());\n\t\t\n\t\t\n\t\tint ans=0;\n\t\trep(i,m){\n\t\t\tif(check(ed[i].a,ed[i].b)==0){\n\t\t\t\tans+=ed[i].v;\n\t\t\t\tunit(ed[i].a,ed[i].b);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n/*\n5 6\n0 2 1\n2 1 3\n2 3 8\n1 3 2\n3 4 5\n1 4 4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\n\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\n\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n | m) != 0){\n    priority_queue<pair<int,pair<int,int> > > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,make_pair(a, b)));\n    }\n    UnionFind u(MAXN);\n    int ans = 0;\n    for (int i = 0; i < m; ++i){\n      int from = que.top().second.first;\n      int to = que.top().second.second;\n      int cost = que.top().first;\n      if(!u.findSet(to, from)){\n\t//cout << \"cost:\" << cost << \" \" << top.to << \" \" << top.from << endl;\n\tans += cost;\n\tu.unionSet(to,from);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nstruct Bri{\n\tint fn;\n\tint tn;\n\tint cost;\n\tbool operator <(const Bri &bBri)const{\n\t\treturn cost>bBri.cost;\n\t}\n};\nint main(void){\n\twhile (true){\n\t\tint citynum, brinum;\n\t\tcin >> citynum >> brinum;\n\t\tif (citynum == 0 && brinum == 0)break;\n\t\tint CostCol[100][100];\n\t\tfor (int i = 0; i < 100; ++i){\n\t\t\tfor (int j = 0; j < 100; ++j){\n\t\t\t\tCostCol[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\tvector<int> IsSelected;\n\t\tfor (int i = 0; i < citynum; ++i){\n\t\t\tIsSelected.push_back(0);\n\t\t}\n\t\tvector<Bri> BriQue;\n\t\tfor (int i = 0; i < brinum; ++i){\n\t\t\tint a, b, cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tBriQue.push_back({ a, b, cost });\n\t\t}\n\t\tsort(BriQue.begin(), BriQue.end());\n\t\treverse(BriQue.begin(),BriQue.end());\n\t\tint CostSum=0;\n\t\tIsSelected[BriQue[0].fn] = 1; IsSelected[BriQue[0].tn] = 1;\n\t\tCostSum += BriQue[0].cost; \n\t\twhile (1){\n\t\t\tfor (auto it = BriQue.begin(); it != BriQue.end(); ++it){\n\t\t\t\tif (IsSelected[(*it).fn] + IsSelected[(*it).tn] == 1){\n\t\t\t\t\tIsSelected[(*it).fn] = 1;\n\t\t\t\t\tIsSelected[(*it).tn] = 1;\n\t\t\t\t\tCostSum += (*it).cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all_of(IsSelected.begin(), IsSelected.end(), [](int x){return x == 1; })){\n\t\t\t\tcout << CostSum << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int INF = 1001001001;\n\nint cost[111][111];\nint minc[111];\nbool used[111];\nint n, m;\n\nint prim() {\n    for (int i = 0; i < n; i++) {\n        minc[i] = INF;\n        used[i] = false;\n    }\n    minc[0] = 0;\n    int res = 0;\n    while (1) {\n        int v = -1;\n        for (int u = 0; u < n; u++) {\n            if (!used[u] && (v == -1 || minc[u] < minc[v])) v = u;\n        }\n        if (v == -1) break;\n        used[v] = true;\n        res += minc[v];\n        for (int u = 0; u < n; u++) {\n            minc[u] = min(minc[u], cost[v][u]);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m && (n != 0 || m != 0)) {\n        for (int i = 0; i < 111; i++) {\n            for (int j = 0; j < 111; j++) {\n                cost[i][j] = INF;\n            }\n        }\n        for (int i = 0, a, b, c; i < m; i++) {\n            cin >> a >> b >> c;\n            cost[a][b] = cost[b][a] = c;\n        }\n        int ans = prim();\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cst;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cst < right.cst;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nedge Data[128];\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n == m && n == 0)break;\n\t\tmemset(Data,0,sizeof(Data));\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cst);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cst;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n\nconst int MAX_N = 100;\nconst int INF = 100000;\n\nint n, m;\nint cost[MAX_N][MAX_N], mincost[MAX_N];\nbool used[MAX_N];\n\nint prim(){\n\tfor (int i = 0; i < n; ++i)\n\t\tmincost[i] = INF;\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile (1){\n\t\tint v = -1;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t\tv = i;\n\t\t}\n\t\tif (v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\tfor (int i = 0;  i < n; ++i)\n\t\t\tmincost[i] = std::min(mincost[i], cost[v][i]);\n\t\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1){\n\t\tstd::cin >> n >> m;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tstd::memset(used, 0, n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tint a, b, c;\n\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tstd::cout << prim() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Bridge\n{\n\tint cost;\n\tint edge[ 2 ];\n};\n\nclass BridgeAsc\n{\npublic:\n\tbool operator()( const Bridge& a, const Bridge& b ) const\n\t{\n\t\tif( a.cost < b.cost ) return true;\n\t\treturn false;\n\t};\n};\n\nint main()\n{\n\tint n, m;\n\twhile( cin >> n >> m && ( n || m ) ){\n\t\tvector< Bridge > bridge;\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tBridge b;\n\t\t\tcin >> b.edge[ 0 ] >> b.edge[ 1 ] >> b.cost;\n\t\t\tbridge.push_back( b );\n\t\t}\n\t\tsort( bridge.begin(), bridge.end(), BridgeAsc() );\n\n\t\tint city[ 100 ] = {0};\n\t\tint id = 1;\n\t\tint cntBridge = 0;\n\t\tint index = 0;\n\t\tint ans = 0;\n\t\twhile( cntBridge < n - 1 ){\n\t\t\tBridge b = bridge[ index ];\n\t\t\tint con = 0;\n\t\t\tint x = b.edge[ 0 ];\n\t\t\tint y = b.edge[ 1 ];\n\t\t\tif( city[ x ] != 0 && city[ x ] == city[ y ] ){\n\t\t\t\t++index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( city[ x ] == 0 && city[ y ] ){\n\t\t\t\tcity[ x ] = city[ y ] = id++;\n\t\t\t}else if( city[ x ] == 0 ){\n\t\t\t\tcity[ x ] = city[ y ];\n\t\t\t}else if( city[ y ] == 0 ){\n\t\t\t\tcity[ y ] = city[ x ];\n\t\t\t}else{\n\t\t\t\tfor( int i = 0; i < n; ++i ){\n\t\t\t\t\tif( city[ i ] == city[ y ] ){\n\t\t\t\t\t\tcity[ i ] = city[ x ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += b.cost;\n\t\t\t++cntBridge;\n\t\t\t++index;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstruct Bridge\n{\n  int a, b, cost;\n};\n\nint n, m, ans, parent[10001];\nBridge bridge[10001];\n\nint bridge_comp(const void *a, const void *b)\n{\n  return ((Bridge *)a)->cost - ((Bridge *)b)->cost;\n}\n\nint root(int a)\n{\n  if (parent[a] == a) return a;\n  else return (parent[a] = root(parent[a]));\n}\n\nint main()\n{\n  while((cin >> n >> m), n && m)\n  {\n    for (int i = 0; i < n; i++)\n      parent[i] = i;\n    for (int i = 0; i < m; i++)\n      cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n    qsort(bridge, m, sizeof(Bridge), bridge_comp);\n    ans = 0;\n    for (int i = 0; i < m; i++)\n    {\n      if ((n = root(bridge[i].a)) != root(bridge[i].b))\n      {\n\tparent[bridge[i].b] = n;\n\tans += bridge[i].cost;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nstruct edge\n{\n\tint from, to, cost;\n\n\tedge( int from, int to, int cost )\n\t:\tfrom( from ), to( to ), cost( cost )\n\t{}\n};\n\nint n, m;\nstd::vector<edge> es;\n\nint par[100], rank[100];\n\nvoid init()\n{\n\trep( i, n )\n\t\tpar[i] = i, rank[i] = 0;\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( x == par[x] )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] > rank[y] )\n\t\tpar[y] = x;\n\telse\n\t{\n\t\tpar[x] = y;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[y];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &n, &m ), n|m )\n\t{\n\t\tes.clear();\n\t\tinit();\n\t\trep( i, m )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d%d%d\", &a, &b, &c );\n\t\t\tes.push_back( edge( a, b, c ) );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), []( const edge& e1, const edge& e2 ){ return e1.cost < e2.cost; } );\n\n\t\tint ans = 0;\n\t\trep( i, es.size() )\n\t\t{\n\t\t\tedge& e = es[i];\n\t\t\tif( !same( e.from, e.to ) )\n\t\t\t{\n\t\t\t\tans += e.cost;\n\t\t\t\tunite( e.from, e.to );\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,k,n) for(int i = k ; i < n ; i++ )\n#define INF 10000000\n\nbool used[101];\nint mincost[101];\nint cost[101][101];\nint V;\n\nint prim(){\n\n  fill(mincost,mincost + 101,INF);\n  fill(used,used+101,false);\n\n  int re = 0;\n  mincost[0] = 0;\n  while(1){\n\n    int v = -1;\n    for(int i = 0 ; i < V ; i++ ){\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n    }\n\n    re += mincost[v];\n    if(v == -1)break;\n    used[v] = true;\n\n\n    for(int i = 0 ; i < V ; ++i){\n      if(!used[i])mincost[i] = min(mincost[i],cost[v][i]);\n    }\n  }\n  return re;\n}\n\nint main(){\n  int n;\n  while(cin >> V >> n , V+n){\n\n    fill(cost[0],cost[101],INF);\n    for(int i = 0 ; i < n ; ++i ){\n      int a,b,c;\n      cin >> a >> b >> c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    int res = prim();\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n\nconst int MAX_N = 100;\nconst int INF = 100000;\n\nint n, m;\nint cost[MAX_N][MAX_N], mincost[MAX_N];\nbool used[MAX_N];\n\nint prim(){\n\tfor (int i = 0; i < n; ++i)\n\t\tmincost[i] = INF;\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile (1){\n\t\tint v = -1;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t\tv = i;\n\t\t}\n\t\tif (v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\tfor (int i = 0;  i < n; ++i)\n\t\t\tmincost[i] = std::min(mincost[i], cost[v][i]);\n\t\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1){\n\t\tstd::cin >> n >> m;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tstd::memset(used, 0, n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tint a, b, c;\n\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tstd::cout << prim() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n};\nbool operator >(const Edge& e1, const Edge& e2) {\n\treturn e1.cost > e2.cost;\n}\n\nint main() {\n\tint n, m;\n\twhile ( cin >> n >> m, n || m ) {\n\t\tvector< vector<Edge> > edge(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b, cost; cin >> a >> b >> cost;\n\t\t\tedge[a].push_back( (Edge){ b, cost } );\n\t\t\tedge[b].push_back( (Edge){ a, cost } );\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tpriority_queue<Edge, vector<Edge>, greater<Edge> > Q;\n\t\tQ.push( (Edge){ 0, 0 } );\n\t\tvector<bool> f(n, false);\n\t\twhile ( !Q.empty() ) {\n\t\t\tEdge e = Q.top(); Q.pop();\n\n\t\t\tif (f[e.to]) continue;\n\t\t\tf[e.to] = true;\n\n\t\t\tans += e.cost;\n\n\t\t\tfor (int i = 0; i < edge[e.to].size(); ++i) {\n\t\t\t\tQ.push(edge[e.to][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Dset {\n  Dset *parent;\n  int rank;\n\n  Dset() {\n    clear();\n  }\n\n  void clear() {\n    parent = NULL;\n    rank = 0;\n  }\n\n  Dset *find() {\n    if (!parent) {\n      return this;\n    } else {\n      parent = parent->find();\n      return parent;\n    }\n  }\n\n  bool merge(Dset *a) {\n    Dset *myRoot = find();\n    Dset *yourRoot = a->find();\n    if (myRoot->rank < yourRoot->rank) {\n      myRoot->parent = yourRoot;\n    } else if (myRoot->rank > yourRoot->rank) {\n      yourRoot->parent = myRoot;\n    } else if (myRoot != yourRoot) {\n      yourRoot->parent = myRoot;\n      myRoot->rank++;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\nstruct Bridge {\n  int a;\n  int b;\n  int cost;\n  \n  bool operator<(const Bridge &obj) const {\n    return (cost < obj.cost);\n  }\n};\n\nint main() {\n  int n, m, ans;\n  Bridge bridge[6000];\n  Dset x[100];\n  while (1) {\n    cin >> n >> m;\n    if (!n && !m) break;\n    for (int i=0; i<m; i++) {\n      cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n    }\n    sort(bridge, bridge+m);\n    for (int i=0; i<n; i++) {\n      x[i].clear();\n    }\n    ans = 0;\n    for (int i=0; i<m; i++) {\n      if (x[bridge[i].a].merge(&x[bridge[i].b])) {\n        ans += bridge[i].cost;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n, m;\n\nclass DisjointSet{\n  public:\n    vector<int> rank, p;\n\n    DisjointSet(){}\n    DisjointSet(int size){\n        rank.resize(size, 0);\n        p.resize(size, 0);\n        for(int i = 0; i < size; i++) makeSet(i);\n    }\n\n    void makeSet(int x){\n        p[x] = x;\n        rank[x] = 0;\n    }\n\n    bool same(int x, int y){\n        return findSet(x) == findSet(y);\n    }\n    \n    bool unite(int x, int y){\n        link(findSet(x), findSet(y));\n    }\n\n    void link(int x, int y){\n        if(rank[x] > rank[y]){\n            p[y] = x;\n        }else{\n            p[x] = y;\n            if(rank[x] == rank[y]){\n                rank[y]++;\n            }\n        }\n    }\n\n    int findSet(int x){\n        if(x != p[x]){\n            // path compression\n            p[x] = findSet(p[x]);\n        }\n        return p[x];\n    }\n};\n\nstruct bridge{\n    int from, to, cost;\n    bridge(int f, int t, int c) : from(f), to(t), cost(c) {}\n    bool operator<(const bridge other) const{\n        return cost < other.cost;\n    }\n};\n\nint main(){\n    while(1){\n        cin >> n >> m;\n        if(n+m == 0)  break;\n\n        DisjointSet uf(n);\n        int a, b, c;\n        vector<bridge> vb; \n        for(int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            vb.push_back(bridge(a,b,c));\n        }\n\n        sort(vb.begin(), vb.end());\n\n        int ans = 0;\n        for(bridge b : vb){\n            if(uf.same(b.from, b.to))   continue;\n\n            ans += b.cost;\n            uf.unite(b.from, b.to);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to, cost;\n    edge_t(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    int min_cost;\n    state_t(int v, int min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline vertex_t& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(vertex_t v) {\n        g.push_back(v);\n    }\n\n    int prim() {\n        bool used[g.size()];\n        int min_span_cost = 0;\n        priority_queue< edge_t, vector<edge_t>, greater<edge_t> > q;\n\n        fill(used, used+g.size(), false);\n\n        used[0] = true;\n        for (int i = 0; i < g[0].size(); i++) {\n            q.push(g[0][i]);\n        }\n\n        while (!q.empty()) {\n            edge_t e = q.top(); q.pop();\n            if (used[e.to]) continue;\n            used[e.to] = true;\n            min_span_cost += e.cost;\n            for (int i = 0; i < g[e.to].size(); i++) {\n                q.push(g[e.to][i]);\n            }\n        }\n\n        return min_span_cost;\n    }\n\n    void dijkstra(int s, vector<int> &min_cost) {\n        min_cost.resize(g.size());\n        priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n        \n        fill(min_cost.begin(), min_cost.end(), INF);\n\n        min_cost[s] = 0;\n        q.push(state_t(s, 0));\n\n        while (!q.empty()) {\n            state_t p = q.top(); q.pop();\n            int v = p.v;\n            if (min_cost[v] < p.min_cost) continue;\n            for (int i = 0; i < g[v].size(); i++) {\n                edge_t e = g[v][i];\n                if (min_cost[e.to] > min_cost[v] + e.cost)  {\n                    min_cost[e.to] = min_cost[v] + e.cost;\n                    q.push(state_t(e.to, min_cost[e.to]));\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        graph_t graph(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            graph[a].push_back(edge_t(a, b, cost));\n            graph[b].push_back(edge_t(b, a, cost));\n        }\n        cout << graph.prim() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\t\ntypedef int Weight;\nstruct Edge {  //src:辺の始点,dst:辺の終点,weight:辺の重さ\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : //辺は重さが重いものを\"小さい\"と定義する\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \n//引数 g:隣接リスト,r:最小全域木の始点\n//戻値 total:最小全域木の重み,T:最小全域木の辺集合\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );    //始め、-1とrを結ぶ辺があると考える\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();++f) if(!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\n//-----------------\nint main()\n{ \n    while(true){\n        int i, a, b, n, m;\n        Weight c;\n        cin >> n >> m;\n        if((n==0)&(m==0))break;\n        Graph g(n);    //頂点数vの空隣接リストgを生成\n        for(i=0; i<m; i++){\n            cin >> a >> b >> c;    \n            g[a].push_back(Edge(a, b, c));    //隣接リストgにsからtに向かう重さwの辺を追加\n            g[b].push_back(Edge(b, a, c));\n        }\n        pair<Weight,Edges>ans=prim(g);\n        cout << ans.first << endl;\n    }\n  \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define C first\n#define S second.first\n#define Z second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 100;\n\nint n;\nbool ok[N][N];\nint c[N][N];\n\nbool check();\n\nint main(void){\n    for(int m, res; cin >> n >> m, n; cout << res << endl){\n        res = 0;\n\n        vector< pair<int, pii> > in;\n        while(m--){\n            int a, b, cost; cin >> a >> b >> cost;\n\n            ok[a][b] = ok[b][a] = true;\n            c[a][b] = cost;\n            c[b][a] = cost;\n            in.pb(mp(cost, mp(a, b)));\n        }\n        sort(ALL(in), greater< pair<int, pii> >());\n\n        rep(i, in.size()){\n            int a = in[i].S, b = in[i].Z;\n            ok[a][b] = false;\n            ok[b][a] = false;\n\n            if(!check()){\n                ok[a][b] = true;\n                ok[b][a] = true;\n            }\n        }\n\n        rep(i, n) for(int j = i + 1; j < n; j++) if(ok[i][j]) res += c[i][j];\n    }\n\n    return 0;\n}\n\nbool check(){\n    vector<bool> used(n);\n    \n    queue<int> q;\n    q.push(0);\n\n    while(!q.empty()){\n        int cur = q.front(); q.pop();\n        if(used[cur]) continue;\n        used[cur] = true;\n\n        rep(next, n) if(ok[cur][next]) q.push(next);\n    }\n\n    return !count(ALL(used), false);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Node\n{\n\tpublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\n\tpublic:\n\tint p,c,dc;\n\n\tTrl(int p, int c, int dc):p(p),c(c),dc(dc){}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c>t.c;\n\t}\n};\n\n\nint main()\n{\n\tint n,m;\n\tint a,b,c;\n\twhile(cin >> n >> m , (n||m))\n\t{\n\t\tNode node[100];\n\t\twhile(m--)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tnode[a].to.push_back(b);\n\t\t\tnode[b].to.push_back(a);\n\t\t\tnode[a].c.push_back(c);\n\t\t\tnode[b].c.push_back(c);\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tbool visit[100] = {false};\n\t\tpriority_queue<Trl> q;\n\t\tq.push(Trl(0,0,0));\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tTrl t=q.top(); q.pop();\n\t\t\tif(visit[t.p]) continue;\n\n\t\t\tvisit[t.p] = true;\n\t\t\ttotal += t.dc;\n\n\t\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next = node[t.p].to[i];\n\t\t\t\tint tc   = node[t.p].c[i];\n\t\t\t\tif(visit[next]) continue;\n\t\t\t\t\n\t\t\t\tq.push(Trl(next,t.c+tc,tc));\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\n\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\n\ntypedef pair<int,pair<int,int> > P;\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n | m) != 0){\n    priority_queue<P,vector<P> ,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,make_pair(a, b)));\n    }\n    UnionFind u(MAXN);\n    int ans = 0;\n    for (int i = 0; i < m; ++i){\n      int from = que.top().second.first;\n      int to = que.top().second.second;\n      int cost = que.top().first;\n      if(!u.findSet(to, from)){\n\t//cout << \"cost:\" << cost << \" \" << top.to << \" \" << top.from << endl;\n\tans += cost;\n\tu.unionSet(to,from);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0180\n\n#include <stdio.h>\n#include <algorithm>\n\nint A[10010], B[10010];\nstd::pair<int, int> bridge[10010];\n\nint parent[110]; //代表元\n\nint root(int a) {\n\tif(parent[a] == a) { return a; }\n\tparent[a] = root(parent[a]);\n\treturn parent[a];\n}\n\nint main(void) {\n\tint n, m;\n\t\n\twhile(true) {\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif ( n == 0 ) { break; }\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tbridge[i].second = i;\n\t\t\tscanf(\"%d %d %d\", &A[i], &B[i], &(bridge[i].first));\n\t\t}\n\t\t\n\t\tsort(bridge, bridge+m);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint bid = bridge[i].second;\n\t\t\tif ( root(A[bid]) == root(B[bid]) ) { continue; } //既に連結\n\t\t\t\n\t\t\tsum += bridge[i].first;\n\t\t\tparent[root(A[bid])] = root(B[bid]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100)\n\nstruct edge { int from, to, cost; };\n\nbool comp ( const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint par[MAX_N];\t\t/// 親\nint rank[MAX_N];\t/// 木の深さ\n\n/// n要素で初期化\nvoid init ( int n )\n{\n\tfor (int i = 0; i < n; ++i) {\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n/// 木の根を求める\nint find ( int x ) \n{\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n/// xとyの属する集合を合併\nvoid unite ( int x, int y )\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif (x == y) { return; }\n\n\tif (rank[x] < rank[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y]) { ++rank[x]; }\n\t}\n}\n\n/// xとyが同じ集合に属するか否か\nbool same ( int x, int y )\n{\n\treturn find(x) == find(y);\n}\n\nusing namespace std;\n\nint main ( void )\n{\n\tint n, m;\n\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> es(m);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tedge& e = es[i];\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\t}\n\n\t\tsort(es.begin(), es.end(), comp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.from, e.to)) {\n\t\t\t\tunite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[b][a] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       auto top = que.top();\n       que.pop();\n       if(frag[top.second] == false){\n\t cost_sum += top.first;\n\t frag[top.second] = true;\n\t current = top.second;\n\t break;\n\t }\n     }  \n  }\n  return cost_sum;\n}\n       \n       \n       \n     \n     \n     \n     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n && !m)\n\t\t\tbreak;\n\t\tint bridge[100][100];\n\t\tint pre_vertex[100][100];\n\t\tint a,b,cost;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tbridge[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tbridge[i][j] = INF;\n\t\t\t\tpre_vertex[i][j] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tif(bridge[a][b] > cost){\n\t\t\t\tbridge[a][b] = cost;\n\t\t\t\tbridge[b][a] = cost;\n\t\t\t}\n\t\t}\n\t\t//ツフツδ債イツド\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint dis = bridge[i][k]+bridge[k][j];\n\t\t\t\t\tif(dis < bridge[i][j]){\n\t\t\t\t\t\tbridge[i][j] = dis;\n\t\t\t\t\t\tpre_vertex[i][j] = pre_vertex[k][j];\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tsum += bridge[i][j];\n\t\t\t\tsum -= bridge[i][pre_vertex[i][j]];\n\t\t\t}\n\t\t\tif(sum < min)\n\t\t\t\tmin = sum;\n\t\t}\n\t\tcout << min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#define INF (1<<21)\nusing namespace std;\n\nint main(){\n  int i,j,n,m,s,t,cost,a[100][100],d[100],f[100],min,p,sum;\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    for(i=0;i<n;i++){\n      d[i] = INF;\n      f[i] = 0;\n      for(j=0;j<n;j++){\n\ta[i][j] = INF;\n      }\n    }\n\n    for(i=0;i<m;i++){\n      cin >> s >> t >> cost;\n      a[s][t] = a[t][s] = cost;\n    }\n\n    d[0] = 0;\n    while(1){\n      min = INF;\n      for(i=0;i<n;i++){\n\tif(d[i]<min && f[i] == 0){\n\t  min = d[i];\n\t  p = i;\n\t}\n      }\n      if(min == INF) break;\n      f[p] = 1;\n      for(i=0;i<n;i++){\n\tif(f[i] == 1) continue;\n   \tif(a[p][i] < d[i]) d[i] = a[p][i];\n      }\n    }\n    \n    sum = 0;\n    for(i=0;i<n;i++){\n      sum += d[i];\n    }\n\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <random>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\nconst double pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tREP(i, v.size()) { if (i)os << \" \"; os << v[i]; }return os;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) {\n\tREP(i, v.size()) { if (i)os << endl; os << v[i]; }return os;\n}\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\n//s\nusing weight = int;\n\nstruct edge {\n    int from, to;\n    weight cost;\n    bool operator<(edge const& rhs) const {\n        return cost > rhs.cost;\n    }\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nedges kruskal (int V, edges& es) {\n    std::sort(es.rbegin(), es.rend());\n    union_find uf(V);\n    edges res;\n    for(int i=0; i<es.size(); ++i) {\n        edge e = es[i];\n        if(!uf.same(e.from, e.to)) {\n            uf.unite(e.from, e.to);\n            res.push_back(e);\n        }\n    }\n    return res;\n}\n\nedges prim(graph& g) {\n    edges res;\n    std::vector<bool> used(g.size(), 0);\n    priority_queue<edge> que;\n    que.push((edge{-1, 0, 0}));\n    while(!que.empty()) {\n        edge e = que.top(); que.pop();\n        if(used[e.to]) continue;\n        if(e.from >= 0) {\n            res.push_back(e);\n        }\n        used[e.to] = true;\n        for(auto ee : g[e.to]) {\n            if(!used[ee.to]) {\n                que.push(ee);\n            }\n        }\n    }\n    sort(res.rbegin(), res.rend());\n    return res;\n}\n\n\nint main() {\n\tint n,m;\n    cin >> n >> m;\n    edges es,answer;\n    while(n!=0 && m!=0){\n        int sum = 0;\n        edge e;\n        es.erase(es.begin(),es.begin()+es.size());\n        for(int i=0;i<m;++i){\n            int v1,v2,c;\n            cin >> v1 >> v2 >> c;\n            e = edge{v1,v2,c};\n            es.push_back(e);\n        }\n        answer = kruskal(n,es);\n        for(auto a: answer){\n            sum += a.cost;\n        }\n        cout << sum << endl;\n        cin >> n >> m;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n \nusing namespace std;\n \nconst int MAX = 101;\nconst int INF = (1<<20);\n \nint cost[MAX][MAX];\nint mincost[MAX];\nbool used[MAX];\nint V;\n \nint prim(){\n  mincost[0] = 0;\n  int res = 0;\n \n  while(1){\n \n    int v = -1;\n    for(int i = 0; i < V; i++)\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n \n    if(v == -1) break;\n \n    used[v] = true;\n    res+=mincost[v];\n\n    for(int i = 0; i < V; i++)\n      mincost[i] = min(mincost[i],cost[v][i]);\n \n  }\n  return res;\n}\n \nvoid init(){\n  fill(mincost,mincost+MAX,INF);\n  fill(used,used+MAX,false);\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      cost[i][j] = INF;\n}\nint main(){\n  int m;\n  while(cin >> V  >> m && V+m){\n    init();\n   \n    while(m--){\n      int f,t,cos;\n      cin >> f >> t >> cos;\n      cost[f][t] = cost[t][f] = cos;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\n//struct edge {int to, cost;};\ntypedef pair<int, int> P;\ntypedef complex<double> C;\n\nstruct edge {\n    int from, to, cost;\n    edge() {}\n    edge(int f, int t, int c) {\n        from = f; to = t; cost = c;\n    }\n};\n\nbool cmp (const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nint INF = 100000000;\nconst int MAX_V = 100000;\nconst int MAX_E = 100000;\n\nint uni[MAX_V];\nedge es[MAX_E];\nint V, E;\n\nvoid init_uf(int n) {\n    REP(i, n) uni[i] = -1;\n}\n\nint root(int x) {\n    if (uni[x] < 0) return x;\n    else {\n        return uni[x] = root(uni[x]);\n    }\n}\n\nbool same(int x, int y) {\n    return root(x) == root(y);\n}\n\nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n\n    if (x == y) return;\n\n    if (uni[x] > uni[y]) swap(x, y);\n\n    uni[x] += uni[y];\n    uni[y] = x;\n}\n\nint kruskal() {\n    sort(es, es + E, cmp);\n    init_uf(V);\n    int res = 0;\n    REP(i, E) {\n        edge e = es[i];\n        if (!same(e.from, e.to)) {\n            unite(e.from, e.to);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    printf(\"%d\\n\", kruskal() );\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d%d\", &V, &E);\n        if (!V && !E) return 0;\n        REP(i, E) {\n            int f, t, c;\n            scanf(\"%d%d%d\", &f, &t, &c);\n            es[i] = edge(f, t, c);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#define INF 1<<29\nusing namespace std;\nint V;\nint cost[1000][1000],mincost[1000];\nbool used[1000];\nbool connect[1000];\n\nint prime()\n{\n  int res = 0;\n  for(int i=0;i<V;++i)\n    {\n      mincost[i] = INF;\n      used[i]=false;\n    }\n\n  mincost[0]=0;\n  \n \n  while(true)\n    {\n int v = -1;\n      for(int i=0;i<V;i++)\n\t{\n\t  if(connect[i] && !used[i] && (v == -1 ||  mincost[i] < mincost[v]))v = i;\n\t}\n      \n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n      \n      for(int i=0;i<V;i++)\n\t{\n\t  mincost[i] = min(mincost[i],cost[v][i]);\n\t}\n\n    }\n  \n  return res;\n}\n\n\n\n\nint main()\n{\n  int m,a,b;\n\n  while(true)\n    {\n      cin >> V >> m;\n      if(V == 0 && m == 0)break;\n      for(int i=0;i<V;i++)for(int j=0;j<V;j++)cost[i][j] = INF;\n      memset(connect,false,sizeof(connect));\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> a >> b;\n\t  cin >> cost[a][b];\n\t  cost[b][a] = cost[a][b];\n\t  connect[a] = true;\n\t  connect[b] = true;\n\t}\n      cout << prime() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef struct{\n\tint to;\n\tint from;\n\tint cost;\n} edge;\n\nconst int INF = 10000000000;\n\nint main(void)\n{\n\tedge edges[10005];\n\tint ch[105];\n\tint n, m, ind;\n\tint i, j, a, b, v;\n\tint min, sum_cost;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tif (n == 0 && m == 0) break;\n\t\t\n\t\tfor (i = 0; i < n; i++) ch[i] = 0;\n\t\t\n\t\tfor (i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", &a, &b, &v);\n\t\t\tedges[i].from = a;\n\t\t\tedges[i].to = b;\n\t\t\tedges[i].cost = v;\n\t\t}\n\t\t\n\t\tsum_cost = 0;\n\t\tch[0] = 1;\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tmin = INF;\n\t\t\t\n\t\t\tfor (j = 0; j < m; j++){\n\t\t\t\tif ( (ch[edges[j].from] == 1 && ch[edges[j].to] == 0) || (ch[edges[j].from] == 0 && ch[edges[j].to] == 1)){\n\t\t\t\t\tif (edges[j].cost < min){\n\t\t\t\t\t\tmin = edges[j].cost;\n\t\t\t\t\t\tind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (min == INF) break;\n\t\t\t\n\t\t\tif (ch[edges[ind].from] == 1 && ch[edges[ind].to] == 0){\n\t\t\t\tch[edges[ind].to] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tch[edges[ind].from] = 1;\n\t\t\t}\n\t\t\tsum_cost += edges[ind].cost;\n\t\t}\n\t\t\n\t\t\n\t\tprintf(\"%d\\n\", sum_cost);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\twhile(1){\n\t\tq=0;\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<a;i++){\n\t\t\tban[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\t\tfor(j=i+1;j<s;j++){\n\t\t\t\tif(g[i]>g[j]){\n\t\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tz=d[i]; x=f[i];\n\t\t\twhile(ban[z]!=z) z=ban[z];\n\t\t\twhile(ban[x]!=x) x=ban[x];\n\t\t\tif(z!=x){\n\t\t\t\tq+=g[i];\n\t\t\t\tif(size[z]>size[x]) ban[z]=x;\n\t\t\t\telse if(size[z]<size[x]) ban[x]=z;\n\t\t\t\telse{\n\t\t\t\t\tban[x]=z;\n\t\t\t\t\tsize[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[200];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define TOSHI_MAX 100\n#define COST_MAX 100000\nusing namespace std;\n\nint prim(int data[][TOSHI_MAX], int toshiNum) {\n  bool visited[toshiNum];\n  int cost[toshiNum];\n  for(int i = 0; i < toshiNum; i++) {\n    visited[i] = false;\n    cost[i] = COST_MAX;\n  }\n  cost[0] = 0;\n  while(1) {\n    int min = COST_MAX;\n    int p;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && cost[i] < min) {\n\tmin = cost[i];\n\tp = i;\n      }\n    }\n    if(min == COST_MAX) break;\n\n    visited[p] = true;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && data[p][i] < cost[i]) {\n\tcost[i] = data[p][i];\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int i = 0; i < toshiNum; i++) {\n    if(cost[i] != COST_MAX) ans += cost[i];\n  }\n\n  return ans;\n}\n\nint main() {\n  while(1) {\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    int data[TOSHI_MAX][TOSHI_MAX];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < m; j++) {\n\tdata[i][j] = COST_MAX;\n      }\n    }\n\n    for(int i = 0; i < m; i++) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      data[a][b] = data[b][a] = cost;\n    }\n\n    cout << prim(data, m) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nset<int> si;\n\nint n, m;\nint a, b, cost;\nint d[110];\nbool used[110];\n\nstruct edge{\n\tint to, cost;\n\tedge(int _to, int _cost) :to(_to), cost(_cost){};\n};\n\nvector<edge> G[110];\n\nvoid prim(int s){\n\tfill(d, d + 110, INF);\n\tREP(i, n)used[i] = false;\n\td[s] = 0;\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> n >> m&&n + m){\n\t\tREP(i, m){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tG[a].push_back(edge(b, cost));\n\t\t\tG[b].push_back(edge(a, cost));\n\t\t}\n\t\tprim(0);\n\t\tint ans = 0;\n\t\tREP(i, n){\n\t\t\tans += d[i];\n\t\t}\n\t\tcout << ans << endl;\n\t\tREP(i, n)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( type ) vector< type >\n#define VVT( type ) vector< vector< type > >\n#define LIM( type ) numeric_limits< type >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline void input_n( vector< T > &out ) { copy_n( istream_iterator< T >( cin ), out.size(), out.begin() ); };\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) (c).begin(), (c).end()\n#define AALL( a, t ) (t*)a, (t*)a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n// Prim 法による MST\n#include <vector>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <type_traits>\nnamespace MinimumSpanningTree\n{\n\ttemplate < typename COST_TYPE = int, typename = typename std::enable_if< std::is_arithmetic< COST_TYPE >::value >::type >\n\tclass Prim\n\t{\n\t\ttypedef std::pair< COST_TYPE, int > Edge;\n\t\tconst COST_TYPE INF = std::numeric_limits< COST_TYPE >::max() / 2;\n\n\t\tconst int N;\n\t\tstd::vector< std::vector< Edge > > G;\n\n\tpublic:\n\t\tPrim( const int n ) : N( n ), G( N )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvoid connect( const int u, const int v, COST_TYPE c )\n\t\t{\n\t\t\tG[u].emplace_back( c, v );\n\t\t\tG[v].emplace_back( c, u );\n\n\t\t\treturn;\n\t\t}\n\n\t\tCOST_TYPE solve()\n\t\t{\n\t\t\tstd::vector< COST_TYPE > costs( N, INF );\n\t\t\tcosts[0] = 0;\n\n\t\t\tstd::vector< bool > used( N );\n\n\t\t\tstd::priority_queue< Edge, std::vector< Edge >, greater< Edge > > que;\n\t\t\tque.emplace( 0, 0 );\n\n\t\t\tCOST_TYPE result = 0;\n\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tconst COST_TYPE cost = que.top().first;\n\t\t\t\tconst int u = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( used[u] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tused[u] = true;\n\t\t\t\tresult += cost;\n\n\t\t\t\tfor ( Edge &e : G[u] )\n\t\t\t\t{\n\t\t\t\t\tconst COST_TYPE c = e.first;\n\t\t\t\t\tconst int v = e.second;\n\n\t\t\t\t\tif ( c < costs[v] )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.emplace( costs[v] = c, v );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n}\n// MinimumSpanningTree::Prim( |V| )\n// connect( u, v, cost )\n// solve()\n\nint solve( const int N, const int M )\n{\n\tMinimumSpanningTree::Prim<> prim( N );\n\tREP( i, 0, M )\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tprim.connect( a, b, c );\n\t}\n\n\treturn prim.solve();\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n, m; cin >> n >> m, ( n | m ); cout << solve( n, m ) << endl );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 101\n#define INF (1<<29)\n\nint n, m;\nint cost[MAX][MAX];\nint minCost[MAX];\nbool used[MAX];\n\nint prim(){\n  fill(minCost, minCost+MAX, INF);\n  memset(used, false, sizeof(used));\n  \n  minCost[0] = 0;\n  int ans = 0;\n  \n  while(true){\n    int v = -1;\n    for(int i = 0 ; i < n ; i++){\n      if(!used[i] && (v == -1 || minCost[i] < minCost[v])) v = i;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    ans += minCost[v];\n    \n    for(int i = 0 ; i < n ; i++){\n      minCost[i] = min(minCost[i], cost[v][i]);\n    }\n  }\n  return ans;\n}\n    \nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    fill(cost[0], cost[0]+MAX*MAX, INF);\n    int a, b, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> a >> b >> C;\n      cost[a][b] = C;\n      cost[b][a] = C;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n\n#define DEBUG false\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int v) : data(v, -1) {}\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  void merge(int x, int y) {\n    x = root(x), y = root(y);\n    if (x != y) {\n      if (size(y) > size(x))\n        swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n};\n\nstruct NODE{\n\tint x, y;\n\tint cost;\n\t\n\tNODE(){x = y = cost = 0;}\n\tNODE(int x, int y, int cost):x(x), y(y), cost(cost){}\n\t\n\tbool operator<(const NODE r){\n\t\treturn cost < r.cost;\n\t}\n};\n\nint main(){\n\t\n\tint n, m;\n\twhile(cin >> n >> m, m, n){\n\t\tvector<NODE> v(m);\n\t\trep(i, m){\n\t\t\tint x, y, cost;\n\t\t\tcin >> x >> y >> cost;\n\t\t\tv[i] = NODE(x, y, cost);\n\t\t}\n\t\t\n\t\tSORT(v);\n\t\t\n\t\tUnionFind uni(n+1);\n\t\t\n\t\tll ans = 0;\n\t\trep(i, m){\n\t\t\tint xx = v[i].x;\n\t\t\tint yy = v[i].y;\n\t\t\tif(uni.root(xx) != uni.root(yy)){\n\t\t\t\tuni.merge(xx, yy);\n\t\t\t\tans += v[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n\n/*\nstruct BIT {\n  int N;\n  vector<ll> data;\n  BIT(int n) : N(n), data(n + 1, 0) { }\n  void add(int a, ll w) {\n    ++a;\n    for(int x = a; x <= N; x += x & -x) {\n      data[x] += w;\n    }\n  }\n  ll sum(int a) {\n    ll ret = 0;\n    for(int x = a; x > 0; x -= x & -x) {\n      ret += data[x];\n    }\n    return ret;\n  }\n  \n  ll sum(int l, int r){//[l, r)\n  \treturn sum(r) - sum(l);\n  }\n};\n\nBIT bit = BIT(1);\nint m, n;\n\nll dfs(int pos, int rest){\n\tll ret = LLINF;\n\t\n\tif(rest == 1) return bit.sum(pos, n+1);\n\tfor(int i = 0; i + pos <= n+1; i++){\n\t\tll hoge1 = bit.sum(pos, pos+i);\n\t\tll hoge2 = dfs(pos+i, rest-1);\n\t\tcout << \"sum(\" << pos << \", \" << pos+i << \"): \" << hoge1 << endl;\n\t\tcout << \"des(\" << pos+i << \". \" << rest-1 << \"): \" << hoge2 << endl;\n\t\tcout << endl;\n\t\tret = min(ret, hoge1 + hoge2);\n\t}\n\t\n\treturn ret;\n}\n\nint main(){\n\n\twhile(cin >> m >> n, m, n){\n\t\tbit = BIT(n);\n\t\trep(i, n){\n\t\t\tll tmp;\n\t\t\tcin >> tmp;\n\t\t\tbit.add(i+1, tmp);\n\t\t}\n\t\t\n\t\tcout << dfs(1, m) << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Edge {\n\tint a, b, cost;\n};\n\nint n, m;\nint root[100], high[100];\nEdge e[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++)root[i] = i, high[i] = 1;\n}\n\nint getroot(int n){\n\tif (n == root[n])return n;\n\treturn root[n] = getroot(root[n]);\n}\n\nbool issame(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\ta = getroot(a), b = getroot(b);\n\tif (a == b)return;\n\tif (high[a] > high[b])root[b] = a;\n\telse if (high[a] < high[b])root[a] = b;\n\telse if (high[a] == high[b])root[a] = b, high[a]++;\n}\n\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> e[i].a >> e[i].b >> e[i].cost;\n\t\t}\n\t\tsort(e, e + m, [](Edge& l, Edge& r) {\n\t\t\treturn l.cost < r.cost;\n\t\t});\n\t\tint ans = 0;\n\t\tinit(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!issame(e[i].a, e[i].b)) {\n\t\t\t\tunite(e[i].a, e[i].b);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 10010\n\nint P[10010];\nint A[1001];\nint B[1001];\nint COST[1001];\nint N;\nint M;\npair<int,int> bridge[1001];\n\nvoid init(int N) { // 初期化 はじめは全ての頂点はバラバラ\n\tfor (int i=0; i<N; ++i) P[i] = i;\n}\n\nint root(int a) { // a の root(代表元) を求める\n\tif (P[a] == a) return a; // aはroot\n\treturn (P[a] = root(P[a])); // a の親の root を求め,a の親とする\n\t\n}\n\nbool is_same_set(int a, int b) { // a と b が同じグループに属するか?\n\treturn root(a) == root(b);\n}\n\nvoid unite(int a, int b) { // a と b を同一グループにまとめる\n\tP[root(a)] = root(b);\n}\n\nint main()\n{\n\twhile(cin >> N >> M && N){\n\t\tinit(1001);\n\t\tfor(int i=0; i<M; ++i)\n\t\t{\n\t\t\tcin >> A[i] >> B[i] >> COST[i];\n\t\t\tbridge[i].first = COST[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\t\n\t\tsort(bridge, bridge+M);\n\t\tfor(int i=0; i<M; ++i)\n\t\t{\n\t\t\tint cost = bridge[i].first;\n\t\t\tint a = A[bridge[i].second];\n\t\t\tint b = B[bridge[i].second];\n\t\t\t//cout << a << \"から\" << b << \"に\" << cost << \"コスト橋が架かっている\" << endl;\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tfor(int i=0; i<M; ++i)\n\t\t{\n\t\t\tint a = A[bridge[i].second];\n\t\t\tint b = B[bridge[i].second];\n\t\t\tif(is_same_set(a,b)) continue;\n\t\t\tunite(a,b);\n\t\t\ttotal += bridge[i].first;\n\t\t}\n\t\tcout << total << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 1000\n#define INF 1000000000\nint dist[MAX_N], color[MAX_N]; vector<pair<int, int> >X[MAX_N];\npriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >Q;\nlong long prim(int V) {\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<int, int>pa = Q.top(); Q.pop();\n\t\tint a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint main() {\n\tint N, M, a, b, c;\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) { X[i].clear(); }\n\t\tcin >> N >> M; if (N == 0 && M == 0) { break; }\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c; X[a].push_back(make_pair(b, c));\n\t\t\tX[b].push_back(make_pair(a, c));\n\t\t}\n\t\tcout << prim(N) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N, M, A[10010], B[10010], COST[10010], parent[10010];\npair<int, int> bridge[10010];\n\nvoid init(int N){\n  for(int i=0; i<N; ++i) parent[i] = i;\n}\nint root(int a){\n  if(parent[a] == a) return a;\n  return (parent[a] = root(parent[a]));\n}\nbool is_same_set(int a, int b){\n  return root(a) == root(b);\n}\nvoid unite(int a, int b){\n  parent[root(a)] = root(b);\n}\n\nint main(){\n  while(cin >> N >> M && N > 0){\n    init(N);\n    for(int i=0; i<M; ++i){\n      cin >> A[i] >> B[i] >> COST[i];\n      bridge[i].first = COST[i];\n      bridge[i].second = i;\n    }\n    sort(bridge, bridge+M);\n\n    int sum = 0;\n\n    for(int i=0; i<M; ++i){\n      int cost = bridge[i].first;\n      int a = A[bridge[i].second];\n      int b = B[bridge[i].second];\n      if(is_same_set(a, b)) continue;\n      unite(a, b);\n      sum += cost;\n    }\n    cout << sum << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\tBridge(const Bridge& b) : from(b.from), to(b.to), cost(b.cost) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint n,m,sum,r;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\nvoid unite(int a,int b) {\n\tP[root(a)] = root(b);\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tint br2 = bridge[i].second;\n\t\t\tif(P[root(b[br2])] != P[root(a[br2])]) {\n\t\t\t\tunite(a[br2],b[br2]);\n\t\t\t\tsum += bridge[i].first;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#define INF (1LL << 60)\nusing namespace std;\nbool used[100]; long long dist[100];\nlong long prim(int V, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[0] = 0; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<int, long long> pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; used[a2] = true;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint to = X[a2][i].first; long long leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && !used[to]) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 0; i < V; i++) sum += dist[i];\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<int, long long> > G[100];\nint main() {\n\twhile(cin >> n >> m, n) {\n\t\tfor(int i = 0; i < n; i++) G[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> u >> v >> w;\n\t\t\tG[u].push_back(make_pair(v, w));\n\t\t\tG[v].push_back(make_pair(u, w));\n\t\t}\n\t\tcout << prim(n, G) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#define ll long long\n#define ALL(x) (x).begin(),(x).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define vi vector<int>\n#define vvi vector<vector<int>>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<vector<int>> Graph; // {ID,Number,ParentID,Height}\n\n    void flatten(int x, int rootid) {\n        int parentid = Graph[x][0];\n        while (Graph[parentid][0] != Graph[parentid][2]) {\n            Graph[parentid][2] = rootid;\n            int next = Graph[parentid][2];\n            parentid = next;\n        }\n    }\npublic:\n    void push(int x) {\n        int i = Graph.size();\n        Graph.push_back({ i,x,i,1 });\n    }\n    void unite(int x, int y) {\n        int hx = Graph[root(x)][3];\n        int hy = Graph[root(y)][3];\n        if (hx < hy) {\n            Graph[root(x)][2] = root(y);\n            flatten(x, root(y));\n        }\n        else if(hx == hy){\n            Graph[root(y)][2] = root(x);\n            Graph[root(x)][3]++;\n            flatten(y, root(x));\n        }\n        else {\n            Graph[root(y)][2] = root(x);\n            flatten(y, root(x));\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n   \n    int root(int x) {\n        int parentid = Graph[x][0];\n        while (Graph[parentid][0] != Graph[parentid][2]) {\n            int next = Graph[parentid][2];\n            parentid = next;\n        }\n       \n        return parentid;\n    }\n};\n\nint sub(int n, int m) {\n\n    vector<vector<int>> edges; // {weight, from_id, to_id} both 0-indexed\n\n    for (int i = 0; i < m; i++) {\n        int a, b, cost; cin >> a >> b >> cost;\n        edges.push_back({ cost,a,b });\n    }\n\n    sort(ALL(edges));\n    int n_edges = 0;\n    int TotalCost = 0;\n\n    UnionFind uf;\n    for (int i = 0; i < n; i++) uf.push(i);\n\n    for (int i = 0; n_edges < n - 1; i++) {\n        vector<int> edge = edges[i];\n       \n        if (uf.root(edge[1]) != uf.root(edge[2])) {\n            uf.unite(edge[1], edge[2]);\n            n_edges++;\n            TotalCost += edge[0];\n        }\n    }\n\n\n    return TotalCost;\n}\n\nint main() {\n    int n, m;\n    vector<int> ans;\n    while (true) {\n        cin >> n >> m;\n\n        if (n == 0 && m == 0) {\n            break;\n        }\n        else {\n            ans.push_back(sub(n, m));\n        }\n    }\n\n    for (int elem : ans) {\n        cout << elem << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <vector>\n#define MAX 25000\n#define rep(i,p) for(int i=0;i<p;i++)\n#define rep1(i,p) for(int i=1;i<=p;i++)\n#define pb push_back\nusing namespace std;\nint n,m,sum,num;\nint A[MAX];\nint B[MAX];\nint C[MAX];\nint V[MAX];\npair<int,int> bridge[MAX];\nint root (int child) {\n  int a = child;\n  while (V[a] != a) {\n    a = V[a];\n  }\n  return a;\n}\nint main(){\n  while (1) {\n    cin >> n >> m;\n    if (n==0 && m==0) return 0;\n    // n : city\n    // m : bridge\n    rep(j,m) {\n      cin >> A[j] >> B[j] >> C[j];\n      bridge[j].first = C[j];\n      bridge[j].second = j;\n    }\n    // sort by lenght of bridge\n    sort(bridge, bridge+m);\n    sum = 0;\n    // Union Find Tree\n    rep(i,m) V[i] = i;\n    rep(i,m) {\n      num = bridge[i].second;\n      int ra = root(A[num]);\n      int rb = root(B[num]);\n      if (ra != rb) {\n        V[ra] = rb;\n        sum += bridge[i].first;\n      }\n      // cout << bridge[i].first << \" \" << bridge[i].second << endl;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cst;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cst < right.cst;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tedge Data[128];\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cst);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cst;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 1000\n\nint par[MAX_N];\nint rank[MAX_N];\n\n#define MAX_E 1000\nstruct edge { int u, v, cost; };\nedge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find(int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init_union_find(V);\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    edge e = es[i];\n    if(!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(cin >> V >> E && (V||E)) {\n    for(int i=0; i<E; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      es[i].u = a, es[i].v = b, es[i].cost = c;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i,j;\n  int a[100][100],b[100],p[5000],q[5000],r[5000],m,n,o;\n  int sm;\n  while(cin>>n>>m&&n+m){\n    memset(a,0,sizeof(a));\n    for(i=0;i<m;i++){\n      cin>>p[i]>>q[i]>>r[i];\n      a[p[i]][q[i]]=r[i];\n      a[q[i]][p[i]]=r[i];\n    }\n    do{\n      h=0;\n      for(i=1;i<m;i++){\n\tif(r[i-1]>r[i]){\n\t  swap(p[i-1],p[i]);\n\t  swap(q[i-1],q[i]);\n\t  swap(r[i-1],r[i]);\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,0,sizeof(b));\n    h=-1;\n    o=0;\n    sm=0;\n    for(i=1;i<n;i++){\n      for(h++;r[h]==0;h++);\n      sm+=r[h];\n      if(b[p[h]]==0&&b[q[h]]==0){\n\to++;\n\tb[p[h]]=o;\n\tb[q[h]]=o;\n      }else if(b[p[h]]==0)\n\tb[p[h]]=b[q[h]];\n      else if(b[q[h]]==0)\n\tb[q[h]]=b[p[h]];\n      else{\n\tfor(j=0;j<n;j++){\n\t  if(p[h]!=j&&b[p[h]]==b[j])\n\t    b[j]=b[q[h]];\n\t}\n\tb[p[h]]=b[q[h]];\n      }\n      for(j=0;j<n;j++){\n\tif(b[p[h]]==b[j]&&a[p[h]][j]){\n\t  a[p[h]][j]=0;\n\t  a[j][p[h]]=0;\n\t}\n\tif(b[q[h]]==b[j]&&a[q[h]][j]){\n\t  a[q[h]][j]=0;\n\t  a[j][q[h]]=0;\n\t}\n      }\n      for(j=h+1;j<m;j++){\n\tif(r[j]&&a[p[j]][q[j]]==0)\n\t  r[j]=0;\n      }\n    }\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N = 10010;\nint M,A[10010],B[10010],COST[10010];\npair<int,int> bridge[10010]; //コストと橋番号のペア\nint P[10010]; //0から10000までの取り扱い可能\nvoid init(int N) { //初期化　初めは全ての頂点はバラバラ\n  for (int i = 0; i < N; ++i) P[i] = i;\n  }\n \n int root(int a) { //aのroot(代表元)を求める\n   if (P[a] == a) return a; //aはroot\n   return (P[a] = root(P[a])); //aの親のrootを求め、aの親とする\n  }\n  bool is_same_set(int a, int b){ //aとbが同じグループに属するか?\n    return root(a) == root(b);\n\t}\n  void unite(int a, int b) { //aとbを同一グループにまとめる\n    P[root(a)] = root(b);\n\t}\n\t\nint main(){\n  while(cin >> N >> M && (N>0)){\n //(NとMを読み込み,Nが0より大きければ処理する)\n    init(N);\n\tint sum = 0;\n    for (int i=0; i<M; ++i) {\n\t  //A[i]とB[i]とCOST[i]を読み込む\n\t  cin >> A[i] >> B[i] >> COST[i];\n\t  bridge[i].first = COST[i];\n\t  bridge[i].second = i;\n\t  }\n\t   //コストの小さい順に整列\n\t  sort(bridge, bridge+M);\n  for (int i=0; i<M; ++i) {\n    int cost = bridge[i].first;\n\tint a = A[bridge[i].second];\n\tint b = B[bridge[i].second];\n\t//「aからbにcostの橋がかかっている」と表示\n\tfor (int i=0; i<M; ++i){ //安い橋から順に\n\tif (!is_same_set(a,b)){ //(端の両端の節点が既に連結だったら)\n\t//端の両端の節点を同一グループに併合する\n\tunite (a,b);\n\t//合計に,橋のコストを加える\n\tsum += cost;\n\t  }\n\t }\n\t}\n\t//合計を出力\n\tcout << sum << endl;\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint n, m;\nint cost[101][101];\nint mincost[101];\nbool used[101];\n\n\nint prim() {\n  fill_n(mincost, 101, INF);\n  fill_n(used, 101, false);\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while( 1 ) {\n    int v = -1;\n    Rep(u, n) {\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v]) ) v = u;\n    }\n\n    if( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    Rep(u, n) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n\n  return res;\n}\n\n\t  \nint main()\n{\n  while( cin >> n >> m, n+m ) {\n    fill_n(*cost, 101*101, INF);\n\n    Rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n    }\n\n    cout << prim() << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nclass Load{\n\tpublic:\n\tint n,m,o,p;\n};\n\nint n,m;\nLoad load[100];\n\nint prim(){\n\tvector<int> visit;\n\tvisit.push_back(0);\n\tint cont=0;\n\t\n\twhile(1){\n\t\tif(visit.size()==n){\n\t\t\tbreak;\n\t\t}\n\t\tint maxi=1000000000;\n\t\tint maxo=0;\n\t\tint maxa=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<visit.size();j++){\n\t\t\t\tif(load[i].n==visit[j]&&load[i].p==0){\n\t\t\t\t\tif(maxi>load[i].o){\n\t\t\t\t\t\tload[i].p=1;\n\t\t\t\t\t\tmaxi=load[i].o;\n\t\t\t\t\t\tmaxo=load[i].m;\n\t\t\t\t\t\tmaxa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(load[i].m==visit[j]&&load[i].p==0){\n\t\t\t\t\tif(maxi>load[i].o){\n\t\t\t\t\t\tload[i].p=1;\n\t\t\t\t\t\tmaxi=load[i].o;\n\t\t\t\t\t\tmaxo=load[i].n;\n\t\t\t\t\t\tmaxa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d\\n\",maxa,maxo,maxi);\n\t\tcont+=maxi;\n\t\tvisit.push_back(maxo);\n\t}\n\treturn cont;\n}\n\nint main(){\n\twhile(1){\n\tcin>>n>>m;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tload[i].n=a;\n\t\t\tload[i].m=b;\n\t\t\tload[i].o=c;\n\t\t\tload[i].p=0;\n\t\t}\n\t\tprintf(\"%d\\n\",prim());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nint Kruskal(const Graph& g,vector<Edge>& forest)\n{\n\tint n=g.size();\n\tvector<Edge> es;\n\trep(i,n) es.insert(end(es),all(g[i]));\n\tsort(all(es));\n\t\n\tUnionFind uf(n);\n\tint res=0;\n\tfor(auto e:es)\n\t\tif(uf.Unite(e.src,e.dst)){\n\t\t\tres+=e.weight;\n\t\t\tforest.push_back(e);\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvector<Edge> forest;\n\t\tcout<<Kruskal(g,forest)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct edge{int u,v,cost;};\n\nint par[100000],rank[100000],V,E;\nedge es[100000];\n\nvoid init(int n){for(int i=0;i<n;i++){par[i]=i;rank[i]=0;}}\nint find(int x){if(par[x]==x)return x;else return find(par[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank[x]<rank[y])par[x]=y;else{par[y]=x;if(rank[x]==rank[y])rank[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n\nbool comp(const edge e1,const edge e2){return e1.cost<e2.cost;}\n\nint kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tint res=0;\n\trep(i,E){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>V>>E&&V){\n\t\trep(i,E)cin>>es[i].u>>es[i].v>>es[i].cost;\n\t\tcout<<kruskal()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n#define PB push_back\n\ntypedef struct{\n  int to,cost;\n}edge;\n\n\nvector<edge> E[100];\n\nint n,m;\n\nint kruskal(){\n  int ret=0;\n  set<int> V;\n  V.insert(0);\n  \n  while(V.size()<n){\n    int minc=10000,to,from;\n    FOR(siter,V){\n      rep(i,E[*siter].size()){\n        if(V.count(E[*siter][i].to))continue;\n        if(E[*siter][i].cost<minc){\n          to=E[*siter][i].to;\n          minc=E[*siter][i].cost;\n        }\n      }\n    }\n    ret+=minc;\n    V.insert(to);\n  }\n  return ret;\n}\n  \n    \n\n\nmain(){\n  while(cin>>n>>m,n){\n    \n    rep(i,n)E[i].clear();\n    \n    rep(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      E[a].PB((edge){b,c});\n      E[b].PB((edge){a,c});\n    }\n    \n    cout<<kruskal()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\n\nstruct edge{ int from, to, cost; };\n\n#define MAX_N 101\n#define MAX_E 1000\n\nint par[MAX_N];\nint Rank[MAX_N];\nedge map[MAX_E];\n\n// nで初期化\nvoid init( int n ) {\n\tfor(int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n// 木の根を求める\nint find( int x ) {\n\tif(par[x] == x) {\n\t\treturn x;\n\t} else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n// xとyの属する集合を合併\nvoid unite( int x, int y ){\n\tx = find(x);\n\ty = find(y);\n\n\tif( x == y ) {\n\t\treturn;\n\t}\n\n\tif( Rank[x] < Rank[y] ) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[x] = y;\n\t\tif( Rank[x] == Rank[y] ) {\n\t\t\tRank[x]++;\n\t\t}\n\t}\n}\n\n// xとyが同じ集合に属するか否か\nbool same( int x, int y ) {\n\treturn find(x) == find(y);\n}\n\n\nbool comp( const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint main() {\n\tint n, m;\n\n\twhile( true ){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint a, b, c;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tmap[i].from = a;\n\t\t\tmap[i].to = b;\n\t\t\tmap[i].cost = c;\n\t\t}\n\n\t\tsort(map, map + m, comp);\n\t\tinit(n);\n\t\tint res = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tedge e = map[i];\n\t\t\tif(!same(e.from, e.to)) {\n\t\t\t\tunite(e.from, e.to);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include<stdio.h>\n//#include<stdlib.h>\n//int N,M,t[101],i,j,r;\n//typedef struct e{int f,t,c;}e;\n//e B[101];\n//int cmp(const void *a,const void *b){e x=*(e*)a,y=*(e*)b;return x.c-y.c;}\n//void in(n){for(;n--;)t[n]=n;}\n//int p(n){return t[n]=t[n]==n?n:p(t[n]);}\n//void u(a,b){t[p(a)]=p(b);}\n//int s(a,b){return p(a)==p(b);}\n//\n//main()\n//{\n//\tfor(;scanf(\"%d%d\",&N,&M),N,M;)\n//\t{\n//\t\tin(N);\n//\t\tfor(i=r=0;i<M;i++)\n//\t\t\tscanf(\"%d%d%d\",&B[i].f,&B[i].t,&B[i].c);\n//\t\tqsort(B,M,sizeof(e),cmp);\n//\t\tfor(i=0;i<M;i++)\n//\t\t\tif(!s(B[i].f,B[i].t))\n//\t\t\t{\n//\t\t\t\tu(B[i].f,B[i].t);\n//\t\t\t\tr+=B[i].c;\n//\t\t\t}\n//\t\tprintf(\"%d\\n\",r);\n//\t}\n//\treturn 0;\n//}\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define MAX_N 10005\nusing namespace std;\n\ntypedef struct edge\n{\n\tint from,to,cost;\n} edge;\n\nbool mcmp(edge x,edge y)\n{\n\treturn x.cost<y.cost;\n}\n\nint uft[MAX_N];\nvector<edge>e;\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i=0;i<=n;i++)\n\tuft[i]=i;\n}\n\nint parent(int n)\n{\n\tif (uft[n]==n)\n\t\treturn n;\n\telse\n\t\treturn uft[n]=parent(uft[n]);\n}\n\nvoid unit(int p, int q)\n{\n\tuft[parent(p)]=parent(q);\n}\n\nint same(int p, int q)\n{\n\treturn parent(p)==parent(q);\n}\n\nint kruskal(int n,int r)\n{\n\tint res=0;\n\tsort(e.begin(),e.end(),mcmp);\n\tinit(n);\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tedge tmp=e[i];\n\t\tif(!same(tmp.from,tmp.to))\n\t\t{\n\t\t\tres+=tmp.cost;\n\t\t\tunit(tmp.from,tmp.to);\n\t\t}\n\t}\n\treturn res;\n}\n\nint piles[10001][2];\nint m_distance(int f,int t)\n{\n\treturn pow((double)piles[f][0]-piles[t][0],2)+pow((double)piles[f][1]-piles[t][1],2);\n}\n\nint main()\n{\n\tint N,M;\n\tfor(;scanf(\"%d%d\",&N,&M),N,M;)\n\t{\n\t\tfor(int j=0;j<M;j++)\n\t\t{\n\t\t\tedge tmp;\n\t\t\tscanf(\"%d%d%d\",&tmp.from,&tmp.to,&tmp.cost);\n\t\t\te.push_back(tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",kruskal(N,M));\n\t\te.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\nbool visited[MAXN];\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\npriority_queue<pair<int,edge>,vector<P>,greater<P> > que;\nint main(){\n  int n,m;\n  while(cin >> n >> m && n + m != 0){\n\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n    UnionFind u(m);\n    int cost = 0;\n    for (int i = 0; i < n-1; ++i){\n      edge top = que.top().second;\n      int topCost = que.top().first;\n      que.pop();\n      if(u.unionSet(top.from,top.to)){\n\tcost += topCost;\n      }\n    }\n    cout << cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint par[120];\nint rnk[120];\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nvoid init(int n) {\n\tfor (int i = 0;i < n;i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\nint find(int a) {\n\tif (par[a] == a)return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rnk[x] < rnk[y])par[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rnk[x] == rnk[y])rnk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n, m) {\n\t\tedge es[1000];\n\t\tfor (int i = 0;i < m;i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tes[i].u = a;\n\t\t\tes[i].v = b;\n\t\t\tes[i].cost = c;\n\t\t}\n\t\tsort(es, es + m, comp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\tfor (int i = 0;i < m;i++) {\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.u, e.v)) {\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, m, a, b, cost;\n\twhile (cin >> n >> m, n || m) {\n\t\tvector< queue< P > > bridge(n);\n\t\tvector<int> group(n,0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> cost;\n\t\t\tbridge[a].push(P(-cost,-b));\n\t\t\tbridge[b].push(P(-cost,-a));\n\t\t}\n\t\tgroup[0] = 1;\n\t\tpriority_queue< P > pq;\n\t\tint ncost = 0;\n\t\twhile (!bridge[0].empty()) {\n\t\t\tpq.push(bridge[0].front());\n\t\t\tbridge[0].pop();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\twhile (group[-pq.top().second]) {\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t\tP tmp = pq.top();\n\t\t\tpq.pop();\n\t\t\tgroup[-tmp.second] = 1;\n\t\t\tncost -= tmp.first;\n\t\t\twhile (!bridge[-tmp.second].empty()) {\n\t\t\t\tpq.push(bridge[-tmp.second].front());\n\t\t\t\tbridge[-tmp.second].pop();\n\t\t\t}\n\t\t}\n\t\tcout << ncost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nint map[101][100];\nint n,m;\n\nbool check(int x,vector<bool> &used){\n\n    used[x] = true;\n    bool flg = true;\n    for(int i=0;i<used.size();i++){\n\tif(!used[i]) flg = false;\n    }\n    if(flg) return true;\n\n    bool res = false;\n    for(int i=0;i<n;i++){\n\tif(map[x][i] > 0  && !used[i]){\n\t    res |= check(i,used);\n\t}\n    }\n\n    return res;\n\n}\n\nint main(){\n\n    while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> cost(m);\n    vector< pair <  pair<int,int> , pair<int,int> > >  q(m);\n    int sum = 0;\n    for(int i=0;i<m;i++){\n\tcin >> a[i] >> b[i] >> cost[i];\n\tsum += cost[i];\n\tq[i] = pair< pair<int,int>, pair<int,int> >(pair<int,int>(cost[i],a[i]), pair<int,int>(b[i],i));\n\tmap[a[i]][b[i]] = cost[i];\n\tmap[b[i]][a[i]] = cost[i];\n    }\n    sort(q.rbegin(),q.rend());\n    for(int i=0;i<m;i++){\n\tint x = q[i].first.second ;\n\tint y = q[i].second.first ;\n\tint temp = map[x][y];\n\tmap[x][y]  = 0;\n\tmap[y][x]  = 0;\n\tvector<bool> used1(n,false);\n\tvector<bool> used2(n,false);\n\tif(check(x,used1) && check(y,used2)){\n\t    sum -= temp;\n\t}else{\n\t    map[x][y]  = temp;\n\t    map[y][x]  = temp;\n\t}\n    }\n    cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(cost, 0x3f, sizeof(cost));\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tcost[a][b] = c; cost[b][a] = c;\n\t\t}\n\t\tmemset(mincost, 0x3f, sizeof(mincost));\n\t\tmemset(used, 0, sizeof(used));\n\t\tmincost[0] = 0;\n\t\tint ans = 0;\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\trep(i, n) {\n\t\t\t\tif (!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t\t\tv = i;\n\t\t\t}\n\t\t\tif (v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tans += mincost[v];\n\t\t\trep(i, n)mincost[i] = min(mincost[i], cost[v][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> ppi;\n\nstruct Edge { int to, cost; };\nvector<Edge> edges[100];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        fill(edges, edges+100, vector<Edge>());\n        int a, b, cost;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> b >> cost;\n            edges[a].push_back((Edge){b, cost});\n        }\n        int res = 0;\n        bool used[100] = {};\n        priority_queue<ppi, vector<ppi>, greater<ppi> > q;\n        q.push(make_pair(make_pair(0,0),0));\n        while ( ! q.empty()) {\n            int d = q.top().first.first;\n            int now = q.top().first.second;\n            int c = q.top().second;\n            q.pop();\n            if (used[now]) {\n                continue;\n            } else {\n                used[now] = true;\n                res += c;\n                for (int i=0; i<edges[now].size(); ++i) {\n                    Edge &e = edges[now][i];\n                    q.push(make_pair(make_pair(d + e.cost, e.to), e.cost));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cst;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cst < right.cst;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nedge Data[128];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tmemset(Data,0,sizeof(Data));\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cst);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cst;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Stellar Performance of the Debunkey Family\n//Level: 2\n//Category: グラフ,Graph,最小全域木,Minimum Spanning Tree,MST\n//Note:\n\n/*\n * 最小全域木を求めればよい。\n *\n * このコードではKruskal法を用いている。\n * オーダーは O(M log M)。\n */\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Edge {\n    int a, b, c;\n\n    bool operator <(const Edge &e) const {\n        return c < e.c;\n    }\n};\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nbool solve() {\n    int N, M;\n    if(!(cin >> N >> M)) return false;\n    if(!N && !M) return false;\n\n    vector<Edge> edges(M);\n    for(int i = 0; i < M; ++i) {\n        Edge &e = edges[i];\n        cin >> e.a >> e.b >> e.c;\n    }\n    sort(begin(edges), end(edges));\n\n    DisjointSet ds(N);\n    int ans = 0;\n    for(const auto &e : edges) {\n        if(ds.unite(e.a, e.b)) {\n            ans += e.c;\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//都市の数\nint m;//橋の数\n/*クラスカル法*/\nconst int MAX_E = 110;\nconst int MAX_V = 110;\nint V,E;//頂点数、辺の数\nstruct edge{\n\tint u,v,cost;//頂点uからvへのcost\n};\nedge es[MAX_E];\n//union-find\nint parent[MAX_V];//parent[x]=xの時xが根である\nint rank[MAX_V];//木の高さ\nvoid init(int V){\n\tfor(int i= 0;i < V;i++){\n\t\tparent[i] = i;\n\t\trank[i] =0;\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x)\n\t\treturn x;\n\telse{\n\t\treturn find(parent[x]);\n\t}\n}\n\nvoid unit(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}\n\telse{\n\t\tparent[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost <e2.cost;\n}\n\nint kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tint res = 0;\n\tfor(int i = 0;i < E;i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunit(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\twhile(cin>>V>>E,V||E){\n\t\trep(i,E){\n\t\t\tcin>>es[i].u>>es[i].v>>es[i].cost;\n\t\t}\n\t\tcout <<kruskal()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tban[i]=i;\n\t\tsize[i]=1;\n\t}\n\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\tfor(i=0;i<s;i++){\n\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\tfor(j=i+1;j<s;j++){\n\t\t\tif(g[i]>g[j]){\n\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<s;i++){\n\t\tz=d[i]; x=f[i];\n\t\twhile(ban[z]!=z) z=ban[z];\n\t\twhile(ban[x]!=x) x=ban[x];\n\t\tif(z!=x){\n\t\t\tq+=g[i];\n\t\t\tif(size[z]>size[x]) ban[z]=x;\n\t\t\telse if(size[z]<size[x]) ban[x]=z;\n\t\t\telse{\n\t\t\t\tban[x]=z;\n\t\t\t\tsize[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",q);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main()\n{\n  typedef std::pair<int,std::pair<int,int> > bridge;\n  int n,m;\n  while (true) {\n    std::cin >> n >> m;\n    if (n==0 && m==0) {\n      break;\n    }\n    int totalcost = 0;\n    std::vector<bridge> bridges(m);\n    for (int i = 0; i < m; i++) {\n      int a,b,cost;\n      std::cin >> a >> b >> cost;\n      bridges[i] = bridge(cost,std::make_pair(a,b));\n    }\n    std::sort(bridges.begin(),bridges.end());\n    union_find reachable(n);\n    for (int i = 0; i < m; i++) {\n      if (!(reachable.same(bridges[i].second.first,bridges[i].second.second))) {\n\ttotalcost += bridges[i].first;\n\treachable.unite(bridges[i].second.first,bridges[i].second.second);\n      }\n    }\n    std::cout << totalcost << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\n#define N 101\n\nusing namespace std;\n\nstruct Node{\n  vector<int> cons;\n  vector<int> costs;\n};\n\nstruct State{\n  int id;\n  int cost;\n  int sz;\n  bool vis[N];\n  State():id(0),cost(0),sz(0){\n    fill(vis,vis+N,false);\n    vis[0]=true;\n  }\n  State(int id, int cst, int sz):id(id),cost(cst),sz(sz){\n    fill(vis,vis+N,false);\n    vis[id]=true;\n  }\n  bool isMST(){\n    for(int i = 0; i < sz; ++i){\n      if( !vis[i] ) return false;\n    }\n    return true;\n  }\n  bool operator>(const State &t)const{\n    return cost < t.cost;\n  }\n};\n\nconst int infty = 1<<28;\nstruct Edge{\n  int src,dst;\n  Edge():src(0),dst(0){}\n  Edge(int s,int d):src(s),dst(d){}\n};\n\nint Prim(const vector<Node> &G){\n  int ret = 0;\n  bool inMST[G.size()];\n  vector< Node > MST;\n  vector< Edge > MSTE;\n\n  fill( inMST, inMST+G.size(), false );\n  MST.push_back( G[0] );\n  inMST[0]=true;\n  while( MST.size() < G.size() ){\n    int from_id = 0;\n    int next_id = 0;\n    int mincost = infty;\n\n    for(int i = 0; i < MST.size(); ++i){\n      for(int j = 0; j < MST[i].cons.size(); ++j){\n\tif( !inMST[ MST[i].cons[j] ] &&\n\t    mincost > MST[i].costs[j] ){\n\t  from_id = i;\n\t  next_id = MST[i].cons[j];\n\t  mincost = MST[i].costs[j];\n\t}\n      }\n    }\n    //cout << \"FROM : \" << from_id << \" NEXT : \" << next_id << \" COST : \" << mincost << endl;\n\n    inMST[ next_id ] = true;\n    ret += mincost;\n    MST.push_back( G[next_id] );\n    MSTE.push_back( Edge(from_id, next_id) );\n  }\n\n  /*\n  for(int i = 0; i < MSTE.size(); ++i){\n    cout << MSTE[i].src << \" -> \" << MSTE[i].dst << endl;\n  }\n  */\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    int n,m;\n    vector<Node> G;\n    cin >> n >> m;\n    if( n == 0 && m == 0 ) break;\n    G.resize(n);\n    for(int i = 0; i < m; ++i){\n      int a,b,cost;\n      cin>>a>>b>>cost;\n      G[a].cons.push_back( b );\n      G[a].costs.push_back( cost );\n      G[b].cons.push_back( a );\n      G[b].costs.push_back( cost );\n    }\n    cout << Prim(G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<i_i, int> p_i;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    int len = v.size();\n    for (int i = 0; i < len; ++i) {\n        s << v[i]; if (i < len - 1) s << \"\\t\";\n    }\n    return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n    int len = vv.size();\n    for (int i = 0; i < len; ++i) {\n        s << vv[i] << endl;\n    }\n    return s;\n}\n\nstruct union_find {\n    int n;\n    vi d;\n    union_find() {}\n    union_find(int n_): n(n_), d(n, -1) {}\n    int root(int v) {\n        if (d[v] < 0) {\n            return v;\n        }\n        return d[v] = root(d[v]);\n    }\n    int size(int v) {\n        return -d[root(v)];\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        if (size(x) < size(y)) {\n            swap(x, y);\n        }\n        d[x] += d[y];\n        d[y] = x;\n        return true;\n    }\n};\n\nint main() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if ( n == 0 ) { break; }\n        vvi edges(m);\n        rep (i, m) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            edges[i] = {cost, a, b};\n        }\n        sort(all(edges));\n\n        int ans = 0;\n        union_find uf(n);\n        rep (i, m) {\n            if ( uf.unite(edges[i][1], edges[i][2]) ) {\n                ans += edges[i][0];\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int MAX = 1000;\n\nint n,m,par[MAX],rank[MAX];\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint kruskal(pair<int,pair<int,int> > es[MAX]){\n  sort(es,es+m);\n  init(n);\n  int res = 0;\n  for(int i = 0 ; i < m ; i++){\n    int a = es[i].second.first;\n    int b = es[i].second.second;\n    if(!same(a,b)){\n      unite(a,b);\n      res += es[i].first;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m ,n +m){\n    pair<int,pair<int,int> > es[MAX];\n    for(int i = 0 ; i < m ; i++){\n      cin >> es[i].second.first >> es[i].second.second >> es[i].first;\n    }\n    cout << kruskal(es) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint a,s,d[501],f[501],g[501],h,size[101],ban[101];\nint z,x,q;\nint main(void)\n{\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<a;i++){\n\t\t\tban[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\t\tfor(i=0;i<s-1;i++){\n\t\t\tfor(j=i+1;j<s;j++){\n\t\t\t\tif(g[i]>g[j]){\n\t\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq=0;\n\t\tfor(i=0;i<s;i++){\n\t\t\t//if(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\t\tz=d[i]; x=f[i];\n\t\t\twhile(ban[z]!=z) z=ban[z];\n\t\t\twhile(ban[x]!=x) x=ban[x];\n\t\t\tif(z!=x){\n\t\t\t\tq+=g[i];\n\t\t\t\tif(size[z]>size[x]) ban[x]=z;\n\t\t\t\telse ban[z]=x;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint UF[100];\npair<int,pair<int,int> > edge[10000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);\n\tb=FIND(b);\n\tif(a!=b){\n\t\tif(UF[a]<UF[b]){\n\t\t\tint val=a;\n\t\t\ta=b;\n\t\t\tb=val;\n\t\t}\n\t\tUF[b]+=UF[a];\n\t\tUF[a]=b;\n\t}\n\treturn;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint c,d,e;\n\t\t\tscanf(\"%d%d%d\",&c,&d,&e);\n\t\t\tedge[i]=make_pair(e,make_pair(c,d));\n\t\t}\n\t\tstd::sort(edge,edge+b);\n\t\tint ret=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(FIND(edge[i].second.first)!=FIND(edge[i].second.second)){\n\t\t\t\tret+=edge[i].first;\n\t\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int>PAIR;//cost/pos\nint main(){\n\tint N,M;\n\twhile(cin>>N>>M,N){\n\t\tint ans=0,cnt=0;\n\t\tbool flag[100]={0};\n\t\tint load[100][100];\n\t\tmemset(load,-1,sizeof(load));\n\t\tfor(int i=0,A,B,C;i<M;i++){\n\t\t\tcin>>A>>B>>C;\n\t\t\tload[A][B]=load[B][A]=C;\n\t\t}\n\t\tpriority_queue<PAIR,vector<PAIR>,greater<PAIR> > Q;\n\t\tQ.push(make_pair(0,0));\n\t\tfor(int now,cost;!Q.empty();){\n\t\t\tcost=Q.top().first;\n\t\t\tnow=Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(flag[now]==0){\n\t\t\t\tflag[now]=1;\n\t\t\t\tans+=cost;\n\t\t\t\tcnt++;\n\t\t\t\tfor(int i=0;i<N;i++)if(load[now][i]>0&&flag[i]==0)Q.push(make_pair(load[now][i],i));\n\t\t\t}\n\t\t\tif(cnt==N)break;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){\n\treturn parent[a]==a?a:parent[a]=root(parent[a]);\n}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;cin>>n>>m,n;cout<<s<<endl){\n\t\tfor(i=0;i<m;i++)cin>>a[i]>>b[i]>>node[i].first,node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint V, m;\nint cost[200][200];\nint mincost[200];\nbool used[200];\n\nint prim(){\n  for(int i=0; i < V; ++i){\n    mincost[i] = INT_MAX/2;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u=0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for(int u=0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> V >> m, V | m){\n    for(int i=0; i < V; i++)\n      for(int j=0; j < m; j++)\n        cost[i][j] = INT_MAX/2;\n    for(int i=0; i < m; i++){\n      int a, b, c; cin >> a >> b >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// uf\nnamespace uf\n{\n  const int Size = 1002;\n  int par[Size];\n  int rank[Size];\n  \n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n    \n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  \n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n}; /* uf */ \n\n// mst\nstruct edge {\n  int u, v, cost;\n};\n\nbool comp(const edge& a, const edge& b) {\n  return a.cost < b.cost;\n}\n\nconst int MAX_E = 10002;\nedge es[MAX_E];\nint V, E;\n\nint kruskal() {\n  sort(es, es + E, comp);\n  uf::init(V);\n  int res = 0;\n  for (int i = 0; i < V; ++i) {\n    edge e = es[i];\n    if (!uf::same(e.u, e.v)) {\n      uf::unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint solve() {\n  int a, b, cost;\n  rep (i,E) {\n    cin >> a >> b >> cost;\n    es[i] = (edge){ a, b, cost };\n  }\n  return kruskal();\n}\n\nint main() {\n  while (cin >> V >> E, V|E) {\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint Par[100], Rank[100];\nint Find(int a) {\n\tif (Par[a] == a)return a;\n\treturn Par[a]=Find(Par[a]);\n}\nvoid unite(int a, int b) {\n\ta = Find(a);\n\tb = Find(b);\n\tif (Rank[a] > Rank[b]) {\n\t\tPar[b] = a;\n\t}\n\telse if (Rank[a] < Rank[b]) {\n\t\tPar[a] = b;\n\t}\n\telse {\n\t\tPar[b] = a;\n\t\tRank[a]++;\n\t}\n}\nint main() {\n\tint a, b;\n\tP s[500];\n\twhile (cin >> a >> b, a | b) {\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tPar[i] = i; Rank[i] = 0;\n\t\t}\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tint d, e, f; scanf(\"%d%d%d\", &d, &e, &f);\n\t\t\ts[c] = P(f, p(d, e));\n\t\t}\n\t\tsort(s, s + b);\n\t\tbool k[100]{};\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tif (Find(s[i].second.first)!=Find(s[i].second.second)) {\n\t\t\t\tunite(s[i].second.first, s[i].second.second);\n\t\t\t\tsum += s[i].first;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint table[100][100],n,m,sum,fixed[100],count,a,b,cost,minimum,checkTable[100],min_index;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n == 0 && m == 0)break;\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcheckTable[i] = 0;\n\t\t\tfor(int k=0; k < n; k++)table[i][k] = 0;\n\t\t}\n\n\t\tfor(int i=0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\",&a,&b,&cost);\n\t\t\ttable[a][b] = cost;\n\t\t\ttable[b][a] = cost;\n\t\t}\n\n\t\tcheckTable[0] = 1;\n\t\tfixed[0] = 0;\n\t\tcount = 1;\n\t\tsum = 0;\n\n\t\twhile(count < n){\n\t\t\tminimum = 1000000000;\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int k=0; k < n; k++){\n\t\t\t\t\tif(table[fixed[i]][k] > 0 && checkTable[k] == 0 && table[fixed[i]][k] < minimum){\n\t\t\t\t\t\tminimum = table[fixed[i]][k];\n\t\t\t\t\t\tmin_index = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += minimum;\n\t\t\tcheckTable[min_index] = 1;\n\t\t\tfixed[count] = min_index;\n\t\t\tcount++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum);\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint cost[101][101];\nint mincost[101];\nbool used[101];\nconst int INF = 100000000;\nint n,m;\n\nint prim() {\n  for ( int i = 0; i < n; ++i ) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n  int res = 0;\n\n  while(true) {\n    int v = -1;\n    for ( int u = 0; u < n; u++ ) {\n      if ( !used[u] && ( v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if ( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for ( int u = 0; u < n; u++ ) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> n >> m, n||m) {\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = 0; j < n; j++ ) {\n\tcost[i][j] = INF;\n      }\n    }\n    for (int i = 0; i < m; i++ ) {\n      int a,b,c; cin >> a >> b >> c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    int ans = prim();\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int MAX = 100,INF = 1000000;\nint edge[MAX][MAX];\n\nbool check(int a[],const int n){\n\tfor(int i = 1;i < n;++i){\n\t\tif(a[i - 1] != a[i]) return true;\n\t}\n\treturn false;\n}\n\nint prim(int n){\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tint done[n],cost;\n\tP tmp;\n\tmemset(done,0,sizeof(done));\n\tfor(int i = 0;i < n;++i){\n\t\tif(edge[0][i] != INF) pq.push(make_pair(edge[0][i],i));\n\t}\n\tdone[0] = 1;\n\tcost = 0;\n\twhile(check(done,n) && !pq.empty()){\n\t\ttmp = pq.top();\n\t\tpq.pop();\n\t\tif(!done[tmp.second]){\n\t\t\tcost += tmp.first;\n\t\t\tdone[tmp.second] = 1;\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tif(edge[tmp.second][i] != INF) pq.push(make_pair(edge[tmp.second][i],i));\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n,m,a,b,cost;\n\twhile(cin >> n >> m,n){\n\t\tfor(int i = 0;i < MAX;++i){\n\t\t\tfor(int j = 0;j < MAX;++j){\n\t\t\t\tedge[i][j] = MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;++i){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tedge[a][b] = edge[b][a] = cost;\n\t\t}\n\t\tcout << prim(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 隣接リスト表現のグラフのプリム法 (優先度付きキューを使用)\n * 計算量は O(|E| log |V|)\n *\n */\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 1e+8;\n// first : コスト, second : 頂点番号\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(int v, int cost_){\n\t\tto = v;\n\t\tcost = cost_;\n\t}\n};\n\n// 頂点数\nint V;\n// G[u][i] = ノード u に接続している i 番目の edge が返ってくる\nvector<edge> G[MAX_V];\n// 頂点の集合 X からの辺の最小コスト\nint mincost[MAX_V];\n// used[i] := 頂点 i が集合に含まれているか\nbool used[MAX_V];\n\n// 初期化\nvoid init(int n){\n\tV = n;\n\tfor(int i = 0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 最小全域木のコストの総和を返す (プリム法)\nint prim(){\n\t// greater<P> を指定することで first が小さい順に取り出せる\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\t// 初期化\n\tfill( mincost , mincost+V , INF );\n\tfill( used , used+V , false );\n\tmincost[0] = 0;\n\tint res = 0;\n\tq.push( P(0,0) );\n\t\n\twhile( !q.empty() ){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\t\n\t\tif( mincost[v] < p.first ) continue;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tedge e = G[v][i];\n\t\t\tif( !used[e.to] && mincost[e.to] > e.cost ){\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t\tq.push( P(e.cost,e.to) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n// 重み cost の辺 (u,v) の追加\nvoid add_edge(int u, int v, int cost){\n\tedge e( v , cost );\n\tG[u].push_back( e );\n\t// 有向グラフなら以下の処理は不要\n\te.to = u;\n\tG[v].push_back( e );\n}\n\nint main(){\n\tint n,m;\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit( n );\n\t\tfor(int i = 0 ; i < m ; i++ ){\n\t\t\tint u, v, c ;\n\t\t\tcin >> u >> v >> c;\n\t\t\tadd_edge( u , v , c );\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define N 20000\n\nusing namespace std;\n\nint Prim(const vector< vector<int> >& data){\n  vector<bool> is_reached(data.size(), false);\n  vector<int> cost(data.size(), N);\n  int i, j, ans;\n  i = 0;\n  ans = 0;\n  cost[i] = 0;\n  while(i != -1){\n    ans += cost[i];\n    is_reached[i] = true;\n    for(j=0; j<data[i].size(); ++j){\n      cost[j] = min(cost[j], data[i][j]);\n    }\n    for(i=-1, j=0; j<is_reached.size(); ++j){\n      if(!is_reached[j] && (i < 0 || cost[i] > cost[j])) i = j;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n, m;\n  int a, b, c;\n\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    vector< vector<int> > data(n, vector<int>(n, N));\n    for(int i=0; i<m; ++i){\n      cin >> a >> b >> c;\n      data[a][b] = c;\n      data[b][a] = c;\n    }\n    cout << Prim(data) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nconst int MAX_N = 110;\n\nint par[MAX_N];\nint ranks[MAX_N];\nint ufSize;\n\nvoid init(int n){\n    ufSize = n;\n    for(int i=0; i<n; i++){\n        par[i] = i;\n        ranks[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }\n    else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    ufSize--;\n\n    if(ranks[x] < ranks[y]){\n        par[x] = y;\n    }\n    else{\n        par[y] = x;\n    }\n    \n    if(ranks[x] == ranks[y]){\n        ranks[x]++;\n    }\n}\n\nint kruskal(int n, vector<T> &edge){\n    sort(edge.begin(), edge.end());\n    init(n);\n    int res = 0;\n    for(int i=0; i<edge.size(); i++){\n        int cost, cv, nv;\n        tie(cost, cv, nv) = edge[i];\n        if(!same(cv, nv)){\n            unite(cv, nv);\n            res += cost;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(1){\n        int n, m; cin>>n>>m;\n        if(n == 0) return 0;\n        vector<T> edge;\n        for(int i=0; i<m; i++){\n            int a, b, c; cin>>a>>b>>c;\n            edge.eb(T(c, a, b));\n        }\n\n        cout << kruskal(n, edge) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nint N,M;\nconst int MAX_V = 10000;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\n\nll Prim(){\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  ll res =0;\n\n  while(1){\n    int v = -1;\n    for(ll u = 0; u < V; ++u){\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if( v == -1){\n      break;\n    }\n    used[v] = true;\n    res += mincost[v];\n    for(ll u = 0; u < V; ++u){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nll prim(){\n  ll res = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N >> M && N && M){\n    ll a,b,c;\n    V = N;\n    cost = vector<vector<ll>>(V,vector<ll>(V,inf));\n    rep(i,M){\n      cin >> a >> b >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n//       cost[a][b] = c;\n//       cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[10001];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nconst int INF = 1000000;\n\nvoid init()\n{\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(i==j)\n\t\t\t\tcost[i][j] = 0;\n\t\t\telse\n\t\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(n==0 && m==0)\n\t\t\tbreak;\n\t\tinit();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = false;\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u]&&(v==-1 || mincost[u] < mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iiP;\nstruct edge{\n  int to, cost; edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint n, m;\nvector<vector<edge> > graph;\n\nvoid init(int n){\n  \n  graph.resize(0), graph.resize(n);\n\n}\n\nint Prim(){\n  \n  int ret = 0;\n  vector <int> used(n, 0);\n  priority_queue<iiP, vector<iiP>, greater<iiP> > que;\n  que.push(iiP(0, 0));\n  while(!que.empty()){\n    iiP p = que.top(); que.pop();\n    if(used[p.sc]++) continue;\n    ret += p.fr;\n    for(int i = 0; i < graph[p.sc].size(); i++){\n      que.push(iiP(graph[p.sc][i].cost, graph[p.sc][i].to));\n    }\n  }\n  return ret;\n\n}\n\nint main(){\n\n  while(cin >> n >> m, n||m){\n    init(n);\n    for(int i = 0; i < m; i++){\n      int a, b, c; cin >> a >> b >> c;\n      graph[a].push_back(edge(b, c));\n      graph[b].push_back(edge(a, c));\n    }\n    \n    cout << Prim() << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tint from, to, cost;\n\tREP(i, m){\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t\tnode[to].PB(MP(cost, from));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second; q.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second]){\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\n\nint main(){\n    while(1){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==0)break;\n\tvector<vector<mp> > g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(mp(c,b));\n\t\tg[b].push_back(mp(c,a));\n\t}\n\tpriority_queue<mp,vector<mp>,greater<mp> > q;\n\tfor(int i=0;i<g[0].size();i++)q.push(g[0][i]);\n\tint sum = 0;\n\tvector<bool> used(n,false);\n\tused[0] = true;\n\t//cout<<\"ok\"<<endl;\n\twhile(!q.empty()){\n\t\tmp now = q.top();\n\t\tq.pop();\n\t\tint nn = now.second;\n\t\tint cost = now.first;\n\t\tif(used[nn])continue;\n\t//\tcout<<nn<<' '<<cost<<endl;\n\t\tused[nn] = true;\n\t\tsum+=cost;\n\t\tfor(int i=0;i<g[nn].size();i++){\n\t\t    \tif(used[g[nn][i].second])continue;\n\t\t\tq.push(g[nn][i]);\n\t\t}\n\n\t}\n\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n#include<climits>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        int city[102][102];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                city[i][j]=INT_MAX;\n            }\n            city[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            cin>>a>>b>>c;\n            city[a][b]=c;\n            city[b][a]=c;\n        }\n        vector<int>que;\n        vector<int>vec;\n        vec.push_back(0);\n        for(int i=1;i<n;i++){\n            que.push_back(i);\n        }\n        int ret=0;\n        while(!que.empty()){\n            int mi=INT_MAX;\n            int cur=-1,in;\n            for(int j=0;j<que.size();j++){\n                for(int i=0;i<vec.size();i++){\n                    if(city[vec[i]][que[j]]<mi){\n                        mi=city[vec[i]][que[j]];\n                        cur=que[j];\n                        in=j;\n                    }\n                }\n            }\n            ret+=mi;\n            que.erase(que.begin()+in);\n            vec.push_back(cur);\n        }\n        cout<<ret<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 100\n\nint par[MAX_N];\nint rank[MAX_N];\n\n#define MAX_E 100\nstruct edge { int u, v, cost; };\nedge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find(int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init_union_find(V);\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    edge e = es[i];\n    if(!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(cin >> V >> E && (V||E)) {\n    E *= 2;\n    for(int i=0; i<E; i+=2) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      es[i].u = a, es[i].v = b, es[i].cost = c;\n      es[i].u = b, es[i].v = a, es[i].cost = c;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( type ) vector< type >\n#define VVT( type ) vector< vector< type > >\n#define LIM( type ) numeric_limits< type >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline void input_n( vector< T > &out ) { copy_n( istream_iterator< T >( cin ), out.size(), out.begin() ); };\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) (c).begin(), (c).end()\n#define AALL( a, t ) (t*)a, (t*)a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n// Prim 法による MST\n#include <vector>\n#include <utility>\n#include <queue>\n#include <limits>\n#include <type_traits>\nnamespace MinimumSpanningTree\n{\n\ttemplate < typename COST_TYPE = int, typename = typename std::enable_if< std::is_arithmetic< COST_TYPE >::value >::type >\n\tclass Prim\n\t{\n\t\ttypedef std::pair< COST_TYPE, int > Edge;\n\t\tconst COST_TYPE INF;\n\n\t\tconst int N;\n\t\tstd::vector< std::vector< Edge > > G;\n\n\tpublic:\n\t\tPrim( const int n ) : INF( std::numeric_limits< COST_TYPE >::max() / 2 ), N( n ), G( N )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvoid connect( const int u, const int v, COST_TYPE c )\n\t\t{\n\t\t\tG[u].emplace_back( c, v );\n\t\t\tG[v].emplace_back( c, u );\n\n\t\t\treturn;\n\t\t}\n\n\t\tCOST_TYPE solve()\n\t\t{\n\t\t\tstd::vector< COST_TYPE > costs( N, INF );\n\t\t\tcosts[0] = 0;\n\n\t\t\tstd::vector< bool > used( N );\n\n\t\t\tstd::priority_queue< Edge, std::vector< Edge >, greater< Edge > > que;\n\t\t\tque.emplace( 0, 0 );\n\n\t\t\tCOST_TYPE result = 0;\n\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tconst COST_TYPE cost = que.top().first;\n\t\t\t\tconst int u = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( used[u] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tused[u] = true;\n\t\t\t\tresult += cost;\n\n\t\t\t\tfor ( Edge &e : G[u] )\n\t\t\t\t{\n\t\t\t\t\tconst COST_TYPE c = e.first;\n\t\t\t\t\tconst int v = e.second;\n\n\t\t\t\t\tif ( c < costs[v] )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.emplace( costs[v] = c, v );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n}\n// MinimumSpanningTree::Prim( |V| )\n// connect( u, v, cost )\n// solve()\n\nint solve( const int N, const int M )\n{\n\tMinimumSpanningTree::Prim<> prim( N );\n\tREP( i, 0, M )\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tprim.connect( a, b, c );\n\t}\n\n\treturn prim.solve();\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n, m; cin >> n >> m, ( n | m ); cout << solve( n, m ) << endl );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <sstream>\nusing namespace std;\n\nvector<int> input(size_t n){\n\tstring s;\n\tif(!getline(cin, s)){ throw 0; }\n\tstringstream ss1(s), ss2;\n\tistream_iterator<int> beg(ss1), en;\n\tvector<int> ret(beg, en);\n\tif(ret.size() != n){ throw 0; }\n\tfor(size_t i = 0; i < n; ++i){\n\t\tif(i){ ss2 << ' '; }\n\t\tss2 << ret[i];\n\t}\n\tif(ss2.str() != s){ throw 0; }\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tvector<int> v = input(2);\n\t\tint n = v[0], m = v[1];\n\t\tif(n == 0 && m == 0){ break; }\n\t\tif(n < 2 || n > 100){ throw 0; }\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tv = input(3);\n\t\t\tint a = v[0], b = v[1], c = v[2];\n\t\t\tif(a < 0 || a >= n || b < 0 || b >= n){ throw 0; }\n\t\t\tif(c < 1 || c > 100){ throw 0; }\n\t\t}\n\t}\n\tif(cin.eof()){ throw 0; }\n\tcin.peek();\n\tif(!cin.eof()){ throw 0; }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n\nconst int MAX_N = 100;\nconst int INF = 100000;\n\nint n, m;\nint cost[MAX_N][MAX_N], mincost[MAX_N];\nbool used[MAX_N];\n\nint prim(){\n\tfor (int i = 0; i < n; ++i)\n\t\tmincost[i] = INF;\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile (1){\n\t\tint v = -1;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t\tv = i;\n\t\t}\n\t\tif (v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\tfor (int i = 0;  i < n; ++i)\n\t\t\tmincost[i] = std::min(mincost[i], cost[v][i]);\n\t\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1){\n\t\tstd::cin >> n >> m;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tstd::memset(used, 0, n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tint a, b, c;\n\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tstd::cout << prim() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n):uf(n, -1){}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline bool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\n\t\tuf[y] = x;\n\n\t\treturn true;\n\t}\n};\n\ntypedef int weight;\nstruct edge {\n\tint u, v;\n\tweight cost;\n\tedge(int u, int v, weight c):u(u), v(v), cost(c){}\n\n\tbool operator< (const edge& o) const {\n\t\treturn cost < o.cost;\n\t}\n};\n\nint n, m;\nvector<edge> es;\n\nweight kruskal() {\n\tsort(es.begin(), es.end());\n\tunion_find uf(n);\n\n\tweight res = 0;\n\tfor(int i = 0; i < es.size(); ++i)\n\t\tif(uf.unite(es[i].u, es[i].v))\n\t\t\tres += es[i].cost;\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n >> m && n) {\n\t\tes.clear();\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tes.emplace_back(u, v, cost);\n\t\t}\n\n\t\tcout << kruskal() << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (ll)n; i++)\n#define PI 3.14159265358979323846\n#define vll vector<long long>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nclass UnionFind {\nprivate:\n  ll n;\n  vll P;\n  ll root(ll x);\n  void setN(ll N);\n  void init();\n\npublic:\n  UnionFind(ll N);\n  void unite(ll x, ll y);\n  bool same(ll x, ll y);\n};\n\n// コンストラクタ\nUnionFind::UnionFind(ll N) {\n  setN(N);\n  init();\n}\n\n// nを変更\nvoid UnionFind::setN(ll N) { n = N; }\n\n// Union-Find Treeを初期化する\nvoid UnionFind::init() {\n  P.clear();\n  rep(i, n) { P.push_back(i); }\n}\n\n// 根の値を返す\nll UnionFind::root(ll x) {\n  if (P[x] == x) { return x; }\n  return (P[x] = root(P[x])); // パス圧縮しつつ返す\n}\n\n// 木を結合する（rankはとりあえず無視）\nvoid UnionFind::unite(ll x, ll y) { P[root(x)] = root(y); }\n\n// xとyが同じ集合にあるか判別\nbool UnionFind::same(ll x, ll y) {\n  if (root(x) == root(y)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// ----本問について----\n// 問題：橋の取り壊し\n// 問題文URL：https://onlinejudge.u-aizu.ac.jp/problems/0180\n// 所要時間：\n// 学んだこと：\n// ------------------\n\n// ----ここから本問のソースコード----\n\nstruct edge {\n  ll w, s, e; // weight, start, end\n\n  // コンストラクタ\n  edge(ll W, ll S, ll E) {\n    w = W;\n    s = S;\n    e = E;\n  }\n};\n\n// edge用の比較関数\nbool cmpI(const edge &a, const edge &b) { return a.w < b.w; }\n\n// グローバル変数（入力）\nll n, m;\nvector<edge> edges;\n\n// 入力\nvoid input() {\n  edges.clear();\n  rep(i, m) {\n    ll a, b, cost;\n    cin >> a >> b >> cost;\n    edges.push_back(edge(cost, a, b));\n  }\n}\n\n// 最小全域木の重みの合計を求める（クラスカル法）．\nvoid solve() {\n  sort(edges.begin(), edges.end(), cmpI); // 辺を重みをキーに昇順ソート\n  UnionFind u(n);                         // UnionFind木を初期化\n  ll ans = 0;\n  rep(i, edges.size()) {\n    if (!u.same(edges[i].s, edges[i].e)) { // 閉路ができない\n      u.unite(edges[i].s, edges[i].e);     // 辺を張る\n      ans += edges[i].w;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  while (cin >> n >> m && n > 0) {\n    input();\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\nusing Q = std::tuple<int,int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\ntemplate <int n>\nstruct UnionFind{\n    UnionFind(){\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    int find(int x){\n        if(x == par[x])return x;\n        return par[x] = find(par[x]);\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){return;}\n        \n        if(rank[x] > rank[y]){\n            par[y] = x;\n        }else{\n            par[x] = y;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\n    int rank[n], par[n];\n};\n\nvector<Q> edges;\nUnionFind<1000> uf;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    int N, M;\n    while(true){\n        std::cin >> N >> M;\n\n        if(N == 0 && M == 0){return 0;}\n\n        edges.clear();\n        uf = UnionFind<1000>();\n    \n        int sum = 0;\n    \n        for(int i=0;i<M;++i){\n            int u, v, cost;\n            std::cin >> u >> v >> cost;\n\n            edges.emplace_back(cost, u, v);\n        }\n    \n        sort(edges.begin(), edges.end());\n\n        for(Q &q : edges){\n            int u, v, cost;\n            tie(cost, u, v) = q;\n\n            if(uf.same(u, v)){\n                continue;\n            }\n\n            uf.unite(u, v);\n            sum += cost;\n        }\n\n        std::cout << sum << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\n-- templete\n\nnewUF n = newArray (0,n-1) (-1)\n\nroot uf i = do\n  c <- readArray uf i\n  if c==(-1) then return i else root uf c >>= writeArray uf i >> readArray uf i\n\nsame uf i j = (==) <$> root uf i <*> root uf j\n\nunite uf i j = root uf i >>= writeArray uf j\n\nkruskal n es = runST $ do\n    uf <- newUF n :: ST s (STUArray s Int Int)\n    cost <- newSTRef 0\n    forM_ es $ \\(c, (a, b)) -> do\n      s <- same uf a b\n      unless s $ do\n          modifySTRef cost (+c)\n          unite uf a b\n    readSTRef cost\n\ntype Edge = (Int, (Int,Int))\nedge a b cost = (cost, (a, b))\n\nmain = do\n    [n, m] <- getInts\n    when (n/=0 || m/=0) $ do\n        es <- sort . map (apply3 edge) <$> replicateM m getInts\n        print $ kruskal n es\n        main\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Edge { int from, to, cost; };\n\nint main() {\n\tint n, m, a, b, cost;\n\twhile (cin >> n >> m, n) {\n\t\tvector<Edge> G;\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tcin >> a >> b >> cost;\n\t\t\tG.push_back((Edge){ a, b, cost });\n\t\t\tG.push_back((Edge){ b, a, cost });\n\t\t}\n\t\tint ret = 0;\n\t\tbool used[100] = {};\n\t\tused[0] = true;\n\t\twhile (1) {\n\t\t\tint k, mn = 1e5;\n\t\t\tfor (int i=0; i<(int)G.size(); ++i) {\n\t\t\t\tif (used[G[i].from] && ! used[G[i].to] && G[i].cost < mn) {\n\t\t\t\t\tmn = G[i].cost;\n\t\t\t\t\tk = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn == 1e5) break;\n\t\t\tused[G[k].to] = true;\n\t\t\tret += G[k].cost;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int MAX_V = 102, INF = 1 << 30;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V, E;\n\nint prim() {\n  for (int u = 0; u < V; ++u) {\n    mincost[u] = INF;\n    used[u] = false;\n  }\n  \n  mincost[0] = 0;\n  int res = 0;\n  while (true) {\n    int v = -1;\n    rep (u,V) {\n      if (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if (v == -1) break;    \n    used[v] = true;\n    res += mincost[v];\n    \n    rep (u,V) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint solve() {\n  int a, b, c;\n  rep (i,V) rep (j,V) cost[i][j] = INF;\n  rep (i,E) {\n    cin >> a >> b >> c;\n    cost[a][b] = cost[b][a] = c;\n  }\n  return prim();\n}\n\nint main() {\n  while (cin >> V >> E, V|E) {\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass S{\n\tpublic:\n\tint x,now,bef;\n\tS(int x,int now,int bef):x(x),now(now),bef(bef){}\n\tbool operator<(const S&a)const{\n\t\treturn now>a.now;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tint to[111][111]={0};\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\tto[a][b]=c;\n\t\t\tto[b][a]=c;\n\t\t}\n\t\t\n\t\tpriority_queue<S> que;\n\t\tque.push(S(0,0,-1));\n\t\t\n\t\tint ans=0;\n\t\t\n\t\tint visit[111]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\t\n\t\t\tS u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.x]==1)continue;\n\t\t\tvisit[u.x]=1;\n\t\t\t\n\t\t\tif(u.bef!=-1){\n\t\t\t\tans += to[u.x][u.bef];\n\t\t\t}\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\tif(to[u.x][i]==0)continue;\n\t\t\t\tif(visit[i]==1)continue;\n\t\t\t\tque.push( S(i ,to[u.x][i]+u.now ,u.x) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V>>E&&V) {\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal()<< std::endl;\n\t\te = {};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//都市の数\nint m;//橋の数\n/*クラスカル法*/\nconst int MAX_E = 110;\nconst int MAX_V = 110;\nint V,E;//頂点数、辺の数\nstruct edge{\n\tint u,v,cost;//頂点uからvへのcost\n};\nedge es[MAX_E];\n//union-find\nint parent[MAX_V];//parent[x]=xの時xが根である\nint rank[MAX_V];//木の高さ\nvoid init(int V){\n\tfor(int i= 0;i < V;i++){\n\t\tparent[i] = i;\n\t\trank[i] =0;\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x)\n\t\treturn x;\n\telse{\n\t\treturn find(parent[x]);\n\t}\n}\n\nvoid unit(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}\n\telse{\n\t\tparent[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost <e2.cost;\n}\n\nint kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tint res = 0;\n\tfor(int i = 0;i < E;i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunit(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\twhile(cin>>V>>E,V||E){\n\t\trep(i,E){\n\t\t\tes[i].u=es[i].v,es[i].cost = 0;\n\t\t}\n\t\trep(i,E){\n\t\t\tcin>>es[i].u>>es[i].v>>es[i].cost;\n\t\t}\n\t\tcout <<kruskal()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define _w_ 1\nconst int INF=1e9;\nint cost[101][101];\nint mincost[101];\nbool used[101];\nint V;\n\nint prim(){\n\tfor(int i = 0; i < V; ++i){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(_w_){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;++u){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int u = 0; u < V; ++u){\n\t\t\tmincost[u] = std::min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\twhile(scanf(\"%d %d\",&n, &m) , n+m){\n\t\tfor(int i=0;i<101;++i){\n\t\t\tfor(int j=0;j<101;++j){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tcost[a][b] = c, cost[b][a] = c;\n\t\t}\n\t\tV = n;\n\t\tprintf(\"%d\\n\",prim());\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Edge {\n\tint s;\n\tint t;\n\tint cost;\n\tEdge() {}\n\tEdge(int s, int t, int cost) : s(s), t(t), cost(cost) {}\n};\nbool operator < (const Edge& e, const Edge& f) { return e.cost < f.cost; }\n\nint root(int* par, int x)\n{\n\tif (x==par[x]) return x;\n\telse return par[x] = root(par, par[x]);\n}\n\nvoid unite(int* par, int x, int y)\n{\n\tpar[root(par, x)] = root(par, y);\n}\n\nbool isSame(int* par, int x, int y)\n{\n\treturn root(par, x) == root(par, y);\n}\n\nint main()\n{\n\tint n, m;\n\twhile (true) {\n\t\tstd::cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tstd::vector<Edge> edge_list;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tint s, t, cost;\n\t\t\tstd::cin >> s >> t >> cost;\n\t\t\tedge_list.push_back( Edge(s, t, cost) );\n\t\t}\n\t\tstd::sort(edge_list.begin(), edge_list.end());\n\t\tint* par = new int[n];\n\t\tfor (int i=0; i<n; i++) par[i] = i;\n\t\tint res = 0;\n\t\tint count = 0;\n\t\tfor (int i=0; i<edge_list.size(); i++) {\n\t\t\tif (isSame(par, edge_list[i].s, edge_list[i].t)) continue;\n\t\t\tunite(par, edge_list[i].s, edge_list[i].t);\n\t\t\tres += edge_list[i].cost;\n\t\t\tcount++;\n\t\t\tif (count == n-1) break;\n\t\t}\n\t\tstd::cout << res << std::endl;\n\t\tdelete[] par;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[200];\nint V,E;\n\nvoid init_union_find(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x] < rank[y])par[x]=y;\n  else par[y]=x,rank[x]+=(rank[x]==rank[y]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nbool comp(const edge& e1,const edge& e2){return e1.cost < e2.cost;}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v))unite(e.u,e.v),res+=e.cost;\n  }\n  return res;\n}\n\nint main(void){\n  int a,b,c;\n\n  while(cin >> V >> E && V){\n    for(int i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a,es[i].v=b,es[i].cost=c;\n    }\n    cout << kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct edge { int u, v, cost; };\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost < e2.cost;\n}\nint par[100];\nint rank[100];\n\nvoid init_union_find(int n){\n  for ( int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\n\n\n\nint n,m;\nedge es[10000];\nint V,E;\n\nint kruskal(){\n  sort (es,es + m, comp);\n  init_union_find(n);\n  int res = 0;\n  for(int i=0;i<m;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    for(int i=0;i<m;i++){\n      cin>>es[i].u>>es[i].v>>es[i].cost;\n    }\n    cout<<kruskal()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint Par[100],Rank[100];\nvoid Init(int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tPar[i]=i;\n\t\tRank[i]=0;\n\t}\n}\nint Find(int x) {\n\tif(Par[x]==x) {\n\t\treturn x;\n\t}else {\n\t\treturn Par[x]=Find(Par[x]);\n\t}\n}\nvoid Unite(int x,int y) {\n\tx=Find(x);\n\ty=Find(y);\n\tif(x==y) return;\n\tif(Rank[x]<Rank[y]) {\n\t\tPar[x]=y;\n\t}else {\n\t\tPar[y]=x;\n\t\tif(Rank[x]==Rank[y])Rank[x]++;\n\t}\n}\nbool Same(int x,int y) {\n\treturn Find(x)==Find(y);\n}\nstruct Edge {\n\tint from,to,cost;\n\tEdge(int _f,int _t,int _c) {from=_f,to=_t,cost=_c;}\n\tbool operator < (const Edge& E) {return cost<E.cost;}\n};\nint main() {\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n) {\n\t\tvector<Edge> es;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&cost);\n\t\t\tes.push_back(Edge(a,b,cost));\n\t\t}\n\t\tsort(es.begin(),es.end());\n\t\tInit(n);\n\t\tint sum=0;\n\t\tfor(int i=0;i<es.size();i++) {\n\t\t\tif(!Same(es[i].from,es[i].to)) {\n\t\t\t\tUnite(es[i].from,es[i].to);\n\t\t\t\tsum+=es[i].cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Dset {\n  Dset *parent;\n  int rank;\n\n  Dset() {\n    clear();\n  }\n\n  void clear() {\n    parent = NULL;\n    rank = 0;\n  }\n\n  Dset *find() {\n    if (!parent) {\n      return this;\n    } else {\n      parent = parent->find();\n      return parent;\n    }\n  }\n\n  bool merge(Dset *a) {\n    Dset *myRoot = find();\n    Dset *yourRoot = a->find();\n    if (myRoot->rank < yourRoot->rank) {\n      myRoot->parent = yourRoot;\n    } else if (myRoot->rank > yourRoot->rank) {\n      yourRoot->parent = myRoot;\n    } else if (myRoot != yourRoot) {\n      yourRoot->parent = myRoot;\n      myRoot->rank++;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\nstruct Bridge {\n  int a;\n  int b;\n  int cost;\n  \n  bool operator<(const Bridge &obj) const {\n    return (cost < obj.cost);\n  }\n};\n\nint main() {\n  int n, m, ans;\n  Bridge bridge[6000];\n  Dset x[100];\n  while (1) {\n    cin >> n >> m;\n    if (!n && !m) break;\n    for (int i=0; i<m; i++) {\n      cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n    }\n    sort(bridge, bridge+m);\n    for (int i=0; i<m; i++) {\n      x[i].clear();\n    }\n    ans = 0;\n    for (int i=0; i<m; i++) {\n      if (x[bridge[i].a].merge(&x[bridge[i].b])) {\n        ans += bridge[i].cost;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstatic const int INFTY = 1000001;\nstatic const int MAX = 102;\n\nclass Edge{\npublic:\n    int target, cost;\n    Edge(int target = 0, int cost = 0) : target(target), cost(cost) {}\n};\n\nstd::vector<Edge> G[MAX];\nbool visited[MAX];\nint parent[MAX], key[MAX];\nint V, minv, min_index;\n\nint minKey() {\n    minv = INFTY;\n    for (int v = 0; v < V; v++)\n        if (!visited[v] && key[v] < minv)\n            minv= key[v], min_index = v;\n    return min_index;\n}\n\nvoid printMST()\n{\n    int sum = 0;\n    for (int i = 1; i < V; i++)\n        sum += key[i];\n    std::printf(\"%d\\n\", sum);\n\n}\n\nvoid prim() {\n\n    for (int i = 0; i < V; i++) {\n        key[i] = INFTY;\n        visited[i] = false;\n    }\n    key[0] = 0;\n    parent[0] = -1;\n\n    int current, target, cost;\n\n    for (int i = 0; i < V-1; i++) {\n        current = minKey();\n        visited[current] = true;\n\n        for (unsigned long v = 0; v < G[current].size(); v++) {\n            target = G[current][v].target;\n            cost = G[current][v].cost;\n            if (!visited[target] && cost < key[target])\n                parent[target] = current, key[target] = cost;\n        }\n    }\n    printMST();\n\n}\n\n\nint main()\n{\n    int E, source, target, cost;\n    for(; ;) {\n        std::scanf(\"%d %d\", &V, &E);\n        if (V == 0 && E == 0) break;\n        for (int i = 0; i < E; i++) {\n            std::scanf(\"%d %d %d\", &source, &target, &cost);\n            G[source].push_back(Edge(target, cost));\n            G[target].push_back(Edge(source, cost));\n        }\n        prim();\n        for (int i = 0; i <= V; i++) G[i].clear();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n,m,a,b,c,mi,ret;\n\tint info[100][100];\n\n\twhile(cin >> n >> m && n){\n\t\tret = 0;\n\t\trep(i,100)rep(j,100)info[i][j] = INT_MAX;\n\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\tinfo[a][b] = info[b][a] = c;\n\t\t}\n\n\t\tlist<int> X,Y;\n\t\tX.push_back(0);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tY.push_back(i);\n\t\t}\n\n\t\twhile(!Y.empty()){\n\t\t\tmi = INT_MAX;\n\t\t\tfor(list<int>::iterator it = X.begin(); it != X.end(); ++it){\n\t\t\t\trep(i,n){\n\t\t\t\t\tif( count(Y.begin(),Y.end(),i) ){\n\t\t\t\t\t\tif(info[*it][i]<mi){\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tmi = info[*it][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tX.push_back(a);\n\t\t\tfor(list<int>::iterator it = Y.begin(); it != Y.end(); ++it){\n\t\t\t\tif((*it)==a){\n\t\t\t\t\tY.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret+=mi;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass S{\n\tpublic:\n\tint x,now,bef;\n\tS(int x,int now,int bef):x(x),now(now),bef(bef){}\n\tbool operator<(const S&a)const{\n\t\treturn now>a.now;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tint to[111][111]={0};\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\tto[a][b]=c;\n\t\t\tto[b][a]=c;\n\t\t}\n\t\t\n\t\tpriority_queue<S> que;\n\t\tque.push(S(0,0,-1));\n\t\t\n\t\tint ans=0;\n\t\t\n\t\tint visit[111]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\t\n\t\t\tS u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.x]==1)continue;\n\t\t\tif(visit[u.bef]==1)continue;\n\t\t\tvisit[u.x]=1;\n\t\t\t\n\t\t\tif(u.bef!=-1){\n\t\t\t\tans += to[u.x][u.bef];\n\t\t\t}\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\tif(to[u.x][i]==0)continue;\n\t\t\t\tif(visit[i]==1)continue;\n\t\t\t\tque.push( S(i ,to[u.x][i]+u.now ,u.x) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int d[100][100];\n    fill_n(d[0],10000,1<<29);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    int ds[100];\n    fill_n(ds,100,1<<29);\n    ds[0]=0;\n    bool u[100]={};\n    for(int i=0;i<n-1;i++){\n      int m=1<<29;\n      int v;\n      for(int i=0;i<n;i++){\n\tif(!u[i]&&ds[i]<m){\n\t  m=ds[i];\n\t  v=i;\n\t}\n      }\n      u[v]=true;\n      for(int i=0;i<n;i++){\n\tif(!u[i]){\n\t  ds[i]=min(ds[i],d[v][i]);\n\t}\n      }\n    }\n    cout<<accumulate(ds,ds+n,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\nconst int N = 10000;\nint par[N]; int hukasa[N];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tif (hukasa[x] < hukasa[y]) par[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (hukasa[x] == hukasa[y]) hukasa[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t\thukasa[i] = 0;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#incldue <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 110\n#define MAX_E 10100\n\nstruct Edge{\n  int u,v,cost;\n  Edge(){}\n  Edge(int u,int v,int cost) : u(u),v(v),cost(cost) {}\n  bool operator < (const Edge &e)const{\n    return cost < e.cost;\n  }\n};\n\nint par[MAX],rank[MAX];\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y){\n    return;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return (find(x) == find(y));\n}\n\nEdge e[MAX_E];\n\nint kruskal(int E){\n  sort(e,e+E);\n  int res = 0;\n  for(int i = 0 ; i < E ; i++){\n    if(!same(e[i].u,e[i].v)){\n      unite(e[i].u,e[i].v);\n      res += e[i].cost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N,M,a,b,c;\n  while(cin >> N >> M,N){\n    init(N);\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b >> c;\n      e[i] = Edge(a,b,c);\n    }\n    cout << kruskal(M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint n, m;\n\n// UnionFind\n#define MAXN 110\nint par[MAXN], rank[MAXN];\n\nvoid init(int n_) {\n    for (int i = 0; i < n_; i++) {\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y;\n    else {\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n// kruskal\n#define MAXM 100010\nstruct edge {\n    int from, to, cost;\n};\n\nbool comp(const edge &e1, const edge &e2) {\n    return e1.cost < e2.cost;\n}\n\nedge es[MAXM];\n\nint kruskal(void) {\n    sort(es, es+m, comp);\n    init(n);\n    int ret = 0;\n    for (int i = 0; i < m; i++) {\n        edge e = es[i];\n        if (!same(e.from, e.to)) {\n            unite(e.from, e.to);\n            ret += e.cost;\n        }\n    }\n    return ret;\n}\nint main(void) {\n    while (cin >> n >> m && n && m) {\n        for (int i = 0; i < m; i++) {\n            cin >> es[i].from >> es[i].to >> es[i].cost;\n        }\n        cout << kruskal() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\n///**********************************///\n///**********Union-Find Tree*********///\n///**********************************///\nconst int N = 1000;\nint par[N]; int hukasa[N];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tif (hukasa[x] < hukasa[y]) par[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (hukasa[x] == hukasa[y]) hukasa[x]++;\n\t}\n}\n\nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n) //要素数nのUFTを初期化\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t\thukasa[i] = 0;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n    explicit operator int() const {return to;}\n};\n\nclass UnionFind {\n    vector<int> uni;\n    int n;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\ntemplate< typename T >\nT kruskal(vector<edge<T>> &G, int V)\n{\n    sort(begin(G), end(G), [](const edge< T > &a, const edge< T > &b) { return (a.cost < b.cost); });\n    UnionFind tree(V);\n    T ret = 0;\n    for(auto &e : G) {\n        if(tree.unite(e.from, e.to)) ret += e.cost;\n    }\n    return (ret);\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        vector<edge<int>> G;\n        for (int i = 0; i < m; ++i) {\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            G.emplace_back(a, b, c);\n        }\n        cout << kruskal(G, n) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n};\n#include<algorithm>\n#include<vector>\nint n,m;\nmain()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tvector<pair<int,pair<int,int> > >e;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\te.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tUF uf(n);\n\t\tsort(e.begin(),e.end());\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a=e[i].second.first,b=e[i].second.second,c=e[i].first;\n\t\t\tif(uf.same(a,b))continue;\n\t\t\tuf.unite(a,b);\n\t\t\tans+=c;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint prim(int a[101][101], int n)\n{\n\tint r = 0, mcost[101];\n\tbool vis[101];\n\t\n\tfill(mcost, mcost+101, inf);\n\tfill(vis, vis+101, false);\n\tmcost[0] = 0;\n\t\n\twhile(1){\n\t\tint v = -1;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!vis[i] && (v == -1 || mcost[v] > mcost[i])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tvis[v] = true;\n\t\tr += mcost[v];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmcost[i] = min(mcost[i], a[v][i]);\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint n, m, a[101][101], s, t, u;\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfill(&a[0][0], &a[101][101], inf);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile(m--){\n\t\t\tcin >> s >> t >> u;\n\t\t\ta[s][t] = a[t][s] = u;\n\t\t}\n\t\t\n\t\tcout << prim(a, n) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<20)\ntypedef pair<int,int> P;\n\nint N,M;\nvector<P> bri[111];\n\nint prim(){\n  bool used[111];\n  int ans = 0;\n  memset(used,false,sizeof(used));\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0,0));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int cost = p.first;\n    int now = p.second;\n    if(used[now]) continue;\n    used[now] = true;\n    ans += cost;\n    for(int i=0;i<bri[now].size();i++){\n      int next = bri[now][i].second;\n      int to = bri[now][i].first;\n      que.push(P(next,to));\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M ,N){\n    for(int j=0;j<M;j++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      bri[a].push_back(P(b,c));\n      bri[b].push_back(P(a,c));\n    }\n    cout << prim() << endl;\n    for(int i=0;i<111;i++){\n      bri[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[b][a] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*Union Find*/\nint par[100];\n\nvoid init(int n){\n  for(int i = 0; i < n; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  par[x] = y;\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\n/*Kruskal*/\nstruct edge {int u, v, cost;};\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint N, M;\n\nint kruskal(){\n  vector<edge>::iterator it = es.begin();\n  sort(it, it + M, comp);\n  init(N);\n  int res = 0;\n  for(int i = 0; i < M; i++){\n    edge e = es[i];\n    if(!same(e.u, e.v)){\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main(void){\n  while(true){\n    int a, b, cost;\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    es.clear();\n    for(int i = 0; i < M; i++){\n      cin >> a >> b >> cost;\n      edge tmp;\n      tmp.u = a, tmp.v = b; tmp.cost = cost;\n      es.push_back(tmp);\n    }\n    cout << kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <queue>\n#include <limits.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nstruct Bridge {\n\tint a, b, cost;\n};\n\nbool operator <(const Bridge& b1, const Bridge& b2) {\n\treturn b1.cost < b2.cost;\n}\n\nbool operator >(const Bridge& b1, const Bridge& b2) {\n\treturn b1.cost > b2.cost;\n}\n\nint n, m, a, b, cost;\nconst int MAX_N = 100;\nint T[MAX_N][MAX_N];\npriority_queue<Bridge, vector<Bridge>, greater<Bridge> > q;\n\nint main() {\n\twhile(cin >> n >> m, n | m) {\n\t\tfill(&T[0][0], &T[0][0]+MAX_N*MAX_N, INT_MAX);\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> cost;\n\t\t\tT[a][b] = T[b][a] = cost;\n\t\t}\n\n\t\tq = priority_queue<Bridge, vector<Bridge>, greater<Bridge> >();\n\t\trep(i,n) {\n\t\t\tif(T[0][i] != INT_MAX) {\n\t\t\t\tBridge bdg;\n\t\t\t\tbdg.a = 0;\n\t\t\t\tbdg.b = i;\n\t\t\t\tbdg.cost = T[0][i];\n\t\t\t\tq.push(bdg);\n\t\t\t}\n\t\t}\n\n\t\tint total = 0;\n\t\tbitset<MAX_N> visited;\n\t\tvisited.set(0);\n\t\twhile(!q.empty()) {\n\t\t\tBridge bdg = q.top();\n\t\t\tq.pop();\n\t\t\tif(visited[bdg.b]) continue;\n\n\t\t\ttotal += bdg.cost;\n\t\t\tvisited.set(bdg.b);\n\t\t\trep(i,n) {\n\t\t\t\tif(!visited[i] && T[bdg.b][i] != INT_MAX) {\n\t\t\t\t\tBridge new_bdg;\n\t\t\t\t\tnew_bdg.a = bdg.b;\n\t\t\t\t\tnew_bdg.b = i;\n\t\t\t\t\tnew_bdg.cost = T[bdg.b][i];\n\t\t\t\t\tq.push(new_bdg);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(visited.count() == n) break;\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nEdges prim(Graph &g){\n  Edges res;\n  vector<int> visited(g.size(), 0);\n  priority_queue<Edge> q;\n  q.push((Edge){-1, 0, 0});\n  while (!q.empty()) {\n    Edge e = q.top();\n    q.pop();\n    if (visited[e.dest]) continue;\n    if (e.src >= 0) res.push_back(e);\n    visited[e.dest] = 1;\n    for (Edge i : g[e.dest]) if(visited[i.dest] == 0) q.push(i);\n  }\n  sort(res.rbegin(), res.rend());\n  return res;\n}\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    Graph g(n);\n    REP(i,m) {\n      int a,b,c;\n      cin>>a>>b>>c;\n      g[a].push_back((Edge){a,b,c});\n      g[b].push_back((Edge){b,a,c});\n    }\n    auto es = prim(g);\n    int sum = 0;\n    for(auto e:es) sum += e.weight;\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nclass UnionFind{\n\tint n;\n\tvector<int> par;\n\tvector<int> rank;\npublic:\n\tUnionFind(){ }\n\tUnionFind(int size){ reset(size); }\n\n\tvoid reset(int size){\n\t\tn = size;\n\t\tpar.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i = 0; i < size; i++) par[i] = i,rank[i] = 0;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x),y = find(y);\n\t\tif(x == y) return ;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\tn--;\n\t}\n\n\tbool same(int x,int y){return find(x) == find(y);}\n\n\tint size() {return n;}\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tUnionFind u(n);\n\t\tvector<pair<int,Pii> > v;\n\t\tFOR(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\tv.push_back(make_pair(c,Pii(a,b)));\n\t\t}\n\t\tint ans = 0;\n\t\tsort(v.begin(),v.end());\n\t\tFOR(i,m){\n\t\t\tif(u.size() == 1) break;\n\t\t\tint cost = v[i].first;\n\t\t\tPii p = v[i].second;\n\t\t\tif(!u.same(p.first,p.second)){\n\t\t\t\tans += cost;\n\t\t\t\tu.unite(p.first,p.second);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main() {\n  int n, m;\n  while(cin>>n>>m, n||m) {\n    Graph g(n);\n    while(m--) {\n      int a, b, cost;\n      cin >> a>> b >> cost;\n      g[a].push_back(Edge(a,b,cost));\n      g[b].push_back(Edge(b,a,cost));\n    }\n    cout << prim(g).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\nusing namespace std;\n#define INF (1<<30)\n\nint n,m;\nbool linked[100] = {false};\nvector<vector<pair<int,int> > > vec;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), n != 0){\n\t\tvec = vector<vector<pair<int,int> > >(n);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&cost);\n\t\t\tvec[a].push_back(make_pair(b,cost));\n\t\t\tvec[b].push_back(make_pair(a,cost));\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlinked[i] = false;\n\t\t}\n\t\tlinked[0] = true;\n\n\t\tint ans = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint mi = INF;\n\t\t\tint mic = INF;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(linked[j]){\n\t\t\t\t\tint mj = INF;\n\t\t\t\t\tint mjc = INF;\n\t\t\t\t\tfor(int k = 0; k < vec[j].size(); k++){\n\t\t\t\t\t\tif(vec[j][k].second < mjc && !linked[vec[j][k].first]){\n\t\t\t\t\t\t\tmj = vec[j][k].first;\n\t\t\t\t\t\t\tmjc = vec[j][k].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(mjc < mic){\n\t\t\t\t\t\tmi = mj;\n\t\t\t\t\t\tmic = mjc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += mic;\n\t\t\tlinked[mi] = true;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define INF 256;\n\nint V, E;\nint cost[110][110];\nint mincost[110];\nbool used[110];\n\nint prim(){\n    REP(i, V){\n        mincost[i] = INF;\n        used[i] = false;\n    }\n    mincost[0] = 0;\n    int res = 0;\n\n    while(true){\n        int v = -1;\n        REP(u, V){\n            if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n        }\n\n        if(v == -1) break;\n        used[v] = true;\n        res += mincost[v];\n\n        REP(u, V){\n            mincost[u] = min(mincost[u], cost[v][u]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> V >> E, V+E != 0){\n        REP(i, 110) REP(j, 110) cost[i][j] = INF;\n\n        REP(i, E){\n            int a, b, c;\n            cin >> a >> b >> c;\n            cost[a][b] = c;\n            cost[b][a] = c;\n        }\n        cout << prim() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while ((int)F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        Graph g(n);\n        int sum = 0;\n        for ( int i = 0; i < m; i++ ) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            g[a].push_back( Edge( a, b, c ) );\n            g[b].push_back( Edge( b, a, c ) );\n            sum += c;\n        }\n\n        cout << minimumSpanningForest(g).first << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nint parent [100];\nint root(int x){\n\tif(parent[x]==x) return x;\n\treturn parent[x]=root(parent[x]);\n}\nvoid unite(int x,int y){\n\tx=root(x);\n\ty=root(y);\n\tparent[x]=y;\n}\nbool same(int x,int y){\n\treturn root(x)==root(y);\n}\nstruct P{\n\tint from,to,cost;\n};\nbool operator<(P a,P b){\n\treturn a.cost<b.cost;\n}\nbool operator>(P a,P b){\n\treturn a.cost>b.cost;\n}\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m&&n!=0&&m!=0){\n\tint a,b,c;\n\tfor(int i=0;i<n;i++)parent[i]=i;\n\tpriority_queue<P, vector<P>, greater<P>>p;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tp.push(P{a,b,c});\n\t}\n\tint sum=0,d=0;\n\twhile(d!=n-1){\n\t\tP t=p.top();p.pop();\n\t\tif(!same(t.from,t.to)){\n\t\t\tunite(t.from,t.to);\n\t\t\td++;\n\t\t\tsum+=t.cost;\n\t\t}\n\t}\n\tcout<<sum<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n \nconst int MAXN = 105;\nusing namespace std;\nbool visited[MAXN];\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n | m) != 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n    UnionFind u(MAXN);\n    int ans = 0;\n    while(!que.empty()){\n      edge e = que.top().second;\n      int  cost= que.top().first;\n      que.pop();\n      if(!u.findSet(e.from,e.to)){\n\tans += cost;\n\tu.unionSet(e.from, e.to);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge {\n    int u, v, cost;\n};\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nbool comp(const edge &e1, const edge &e2)\n{\n    return e1.cost < e2.cost;\n}\n\nconst int MAX_M = (100 - 1) * 50 + 1;\nint N, M;\nedge es[MAX_M];\n\nvoid Kruskal()\n{\n    sort(es, es + M, comp);\n    UnionFind uf(N);\n    int res = 0;\n    int cnt = 0;\n\n    for (int i = 0; i < M; i++) {\n        edge e = es[i];\n        if (!uf.findSet(e.u, e.v)) {\n            uf.unionSet(e.u, e.v);\n            res += e.cost;\n            cnt++;\n        }\n    }\n\n    cout << res << endl;\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        for (int i = 0; i < M; ++i)\n            cin >> es[i].u >> es[i].v >> es[i].cost;\n        Kruskal();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector< vector<int> > map(100,vector<int>(100,0));\nint n,m;\n\nbool check(int x,vector<bool> &used){\n\n    used[x] = true;\n    bool flg = true;\n    for(int i=0;i<used.size();i++){\n\tif(!used[i]) flg = false;\n    }\n    if(flg) return true;\n\n    bool res = false;\n    for(int i=0;i<n;i++){\n\tif(map[x][i] > 0  && !used[i]){\n\t    res |= check(i,used);\n\t}\n    }\n\n    return res;\n\n}\n\nint main(){\n\n    while(true){\n\tmap = vector< vector<int> >(100,vector<int>(100,0));\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> cost(m);\n    vector< pair <  pair<int,int> , pair<int,int> > >  q(m);\n    long long int sum = 0;\n    for(int i=0;i<m;i++){\n\tcin >> a[i] >> b[i] >> cost[i];\n\tsum += cost[i];\n\tq[i] = pair< pair<int,int>, pair<int,int> >(pair<int,int>(cost[i],a[i]), pair<int,int>(b[i],i));\n\tmap[a[i]][b[i]] = cost[i];\n\tmap[b[i]][a[i]] = cost[i];\n    }\n    sort(q.rbegin(),q.rend());\n    for(int i=0;i<m;i++){\n\tint x = q[i].first.second ;\n\tint y = q[i].second.first ;\n\tint temp = map[x][y];\n\tmap[x][y]  = 0;\n\tmap[y][x]  = 0;\n\tvector<bool> used1(n,false);\n\tvector<bool> used2(n,false);\n\tif(check(x,used1) && check(y,used2)){\n\t    sum -= temp;\n\t}else{\n\t    map[x][y]  = temp;\n\t    map[y][x]  = temp;\n\t}\n    }\n    cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nstd::pair<Weight, Edges> prim(const Graph &g, const int &root = 0) {\n  struct comp {\n    bool operator()(const Edge &e, const Edge &f) const { return e.weight > f.weight; }\n  };\n  Edges tree;\n  Weight total = 0;\n  std::vector<int> vs(g.size());\n  std::priority_queue<Edge, std::vector<Edge>, comp> q;\n  q.emplace(-1, root, 0);\n  while (q.size()) {\n    Edge e = q.top();\n    q.pop();\n    if (vs[e.dst]) continue;\n    vs[e.dst] = true;\n    total += e.weight;\n    if (e.src != -1) tree.emplace_back(e);\n    for (auto &f : g[e.dst]) {\n      if (!vs[f.dst]) q.emplace(f);\n    }\n  }\n  return {total, tree};\n}\n\nmain {\n  int n, m;\n  while (cin >> n >> m, n) {\n    Graph g(n);\n    while (m--) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      g.addEdge(a, b, cost);\n    }\n    cout << prim(g).first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 100000;\nstruct Edge { int from, to, cost; };\nint dist[100];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<Edge> G;\n        int a, b, cost;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> b >> cost;\n            G.push_back((Edge){ a, b, cost });\n            G.push_back((Edge){ b, a, cost });\n        }\n        int ret = 0;\n        fill(dist, dist+100, INF);\n        dist[0] = 0;\n        while (1) {\n            int k, mn = INF;\n            for (int i=0; i<(int)G.size(); ++i) {\n                if (dist[G[i].to] == INF && dist[G[i].from] + G[i].cost < mn) {\n                    mn = dist[G[i].from] + G[i].cost;\n                    k = i;\n                }\n            }\n            if (mn == INF) break;\n            dist[G[k].to] = dist[G[k].from] + G[k].cost;\n            ret += G[k].cost;\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pll;\ntypedef pair<int,pll> P;\nstruct unionfind{\n  int par[110]; // 親ノード  必要に応じて要素数を変えよう\n  int rank[110]; // ランク　必要に応じて要素数を変えよう\n  unionfind(int n){\n    init(n);\n  }\n  void init(int n){\n    for(int i=0;i<=n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = root(par[x]);\n    }\n  }\n  int size(int x){\n    return rank[root(x)];\n  }\n  bool same(int x,int y) {\n    return root(x) == root(y);\n  }\n  void unite(int x,int y) {\n    x=root(x);\n    y=root(y);\n    if(x==y){\n      return;\n    }\n    if(rank[x]<rank[y]){\n      swap(x,y);\n    }\n    rank[x]=rank[x]+rank[y];\n    par[y]=x;\n  }\n};\nint main(){\n  while(1){\n    int n,m,i;\n    cin >> n >> m;\n    if(n==0 && m==0){\n      return 0;\n    }\n    unionfind tree(n);\n    vector<P> g;\n    for(i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g.push_back(make_pair(c,pll(a,b)));\n    }\n    sort(g.begin(),g.end());\n    int ans=0;\n    for(i=0;i<m;i++){\n      if(!tree.same(g[i].second.first,g[i].second.second)){\n        tree.unite(g[i].second.first,g[i].second.second);\n        ans+=g[i].first;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nstruct Edge {\n  int from, to, w;\n  Edge(int from, int to, int w) : from(from), to(to), w(w) {}\n  Edge(){}\n  bool operator<(const Edge& x) const {\n    return w != x.w ? w > x.w : from != x.from ? from < x.from : to < x.to;\n  }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint prim(const Graph& g, int r=0){\n  int n = g.size();\n  int total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push(Edge(-1, r, 0));\n  while (!Q.empty()){\n    Edge e = Q.top();\n    Q.pop();\n    if (visited[e.to]) continue;\n    total += e.w;\n    visited[e.to] = true;\n    for (Edges::const_iterator f = g[e.to].begin(); f != g[e.to].end(); f++){\n      if (!visited[f->to]) Q.push(*f);\n    }\n  }\n  return total;\n}\n\nint main()\n{\n  int n, m;\n  while (n = in(), m = in(), n){\n    Graph g(n);\n    rep(i, m){\n      int from, to, w;\n      from = in();\n      to = in();\n      w = in();\n      g[from].push_back(Edge(from, to, w));\n      g[to].push_back(Edge(to, from, w));\n    }\n    printf(\"%d\\n\", prim(g));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\nusing ll=long long;\nusing namespace std;\n//const int INF = 7+(1e+9);\nll GCD(ll x, ll y)\n{\n    if (y == 0)\n    {\n        return x;\n    }\n    else\n    {\n        return GCD(y, x % y);\n    }\n}\nll LCM(ll x, ll y)\n{\n    return x / GCD(x, y) * y;\n}\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\nvector<vector<char>> vec(12,vector<char>(12));\n\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint dfs(int y,int x){\n    vec[y][x]='5';\n    for(int i=0;i<4;i++){\n        if(x+dx[i]<12&&x+dx[i]>=0&&y+dy[i]<12&&y+dy[i]>=0&&vec[dy[i]+y][dx[i]+x]=='1'){\n            dfs(y+dy[i],x+dx[i]);\n        }\n    }\n    return 0;\n}\nint main(){\n    int n,m;\n    \n    while(cin>>n>>m){\n    vector<vector<int>> vec(m,vector<int>(3));\n    for(int i=0;i<m;i++){\n        int a,b,w;\n        cin>>a>>b>>w;\n        vec[i][0]=w;\n        vec[i][1]=a;\n        vec[i][2]=b;\n    }\n    sort(vec.begin(),vec.end());\n    UnionFind tree(n);\n    int sum=0;\n    for(int i=0;i<m;i++){\n        if(!tree.same(vec[i][1],vec[i][2])){\n            tree.unite(vec[i][2],vec[i][1]);\n            sum += vec[i][0];\n        }\n    }\n    if(sum==0)break;\n    cout<<sum<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\n\nint N, M;\nint cost[110][110];\n\nint prim(){\n    int mincost[110], used[110];\n    REP(i, 110){\n        mincost[i] = INF;\n        used[i] = 0;\n    }\n\n    mincost[0] = 0;\n    \n    int res = 0;\n    while(1){\n        int u = -1;\n        \n        REP(i, N){\n            if(!used[i] && (u == -1 || mincost[u] > mincost[i])){u = i;}\n        }\n\n        if(u == -1){break;}\n\n        used[u] = 1;\n        res += mincost[u];\n\n        REP(i, N){\n            mincost[i] = std::min(mincost[i], cost[i][u]);\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, 110){\n            REP(j, 110){\n                cost[i][j] = INF;\n            }\n        }\n\n        REP(i, M){\n            int to, from, co;\n            std::cin >> to >> from >> co;\n\n            cost[to][from] = co;\n            cost[from][to] = co;\n        }\n\n        std::cout << prim() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint p[100];\n\nint find(int x){\n\treturn x == p[x] ? x : (p[x] = find(p[x]));\n}\nint merge(int x,int y){\n\tx=find(x),y=find(y);\n\tif( x == y ) return 0;\n\tp[y] = x;\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 0 ; i < n ; i++) p[i] = i;\n\t\tvector< pair<int,pair<int,int> > > e;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\te.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tint ans = 0;\n\t\tsort(e.begin(),e.end());\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tif( merge(e[i].second.first,e[i].second.second) ){\n\t\t\t\tans += e[i].first;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct edge{\n    int to,cost;\n    edge(int a,int b):to(a),cost(b){}\n    edge(){}\n    bool operator>(const edge &d)const{\n        return cost>d.cost;\n    }\n};\nint main(){\n    int N,M;\n    while(scanf(\"%d%d\",&N,&M),N||M){\n        vector<vector<edge> >V(N);\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            V[a].push_back(edge(b,c));\n            V[b].push_back(edge(a,c));\n        }\n        priority_queue<edge,vector<edge>,greater<edge> >Q;\n        Q.push(edge(0,0));\n        bool used[100];fill(used,used+100,false);\n        int res=0;\n        while(Q.size()){\n            int to=Q.top().to,cost=Q.top().cost;\n            Q.pop();\n            if(used[to])continue;\n            used[to]=true;\n            res+=cost;\n            for(int i=0;i<V[to].size();i++)Q.push(V[to][i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 100000;\nstruct Edge { int from, to, cost; };\nint dist[100];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<Edge> G;\n        int a, b, cost;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> b >> cost;\n            G.push_back((Edge){ a, b, cost });\n            // G.push_back((Edge){ b, a, cost });\n        }\n        int ret = 0;\n        fill(dist, dist+100, INF);\n        dist[0] = 0;\n        while (1) {\n            int k, mn = INF;\n            for (int i=0; i<(int)G.size(); ++i) {\n                if (dist[G[i].to] == INF && dist[G[i].from] + G[i].cost < mn) {\n                    mn = dist[G[i].from] + G[i].cost;\n                    k = i;\n                }\n            }\n            if (mn == INF) break;\n            dist[G[k].to] = dist[G[k].from] + G[k].cost;\n            ret += G[k].cost;\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n\nint par[100], rank[100];\n\nvoid init( int n )\n{\n\tfor( int i = 0; i != n; ++i )\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( par[x] == x )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] < rank[y] )\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[x];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nstruct edge{ int from, to, cost; };\n\nint n, m;\nstd::vector<edge> es;\n\nint main()\n{\n\twhile( std::cin >> n >> m, n | m )\n\t{\n\t\tes.clear();\n\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tint a, b, cost;\n\t\t\tstd::cin >> a >> b >> cost;\n\t\t\tedge e = { a, b, cost };\n\t\t\tes.push_back( e );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), []( const edge& e1, const edge& e2 ){ return e1.cost < e2.cost; } );\n\n\t\tinit( n );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tif( !same( es[i].from, es[i].to ) )\n\t\t\t{\n\t\t\t\tans += es[i].cost;\n\t\t\t\tunite( es[i].from, es[i].to );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n\n\nconst int INF = 1000000;\nconst int mod = 1e9 + 7;\n\n\n\nconst int MAX_E = 300100;\nconst int MAX_V = 100100;\n \nint par_uft[MAX_V];\nint rank_uft[MAX_V];\n \nvoid init_uft(int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tpar_uft[i] = i;\n\t\trank_uft[i] = 0;\n\t}\n}\n \nint find_uft(int x) {\n\tif (par_uft[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par_uft[x] = find_uft(par_uft[x]);\n\t}\n}\n \nvoid unite_uft(int x, int y) {\n\tx = find_uft(x);\n\ty = find_uft(y);\n\tif (x == y)return;\n \n\tif (rank_uft[x] < rank_uft[y]) {\n\t\tpar_uft[x] = y;\n\t}\n\telse {\n\t\tpar_uft[y] = x;\n\t\tif (rank_uft[x] == rank_uft[y]) {\n\t\t\trank_uft[x]++;\n\t\t}\n\t}\n}\n \nbool same_uft(int x, int y) {\n\treturn find_uft(x) == find_uft(y);\n}\n \n \n \nstruct edge { \n\tint u, v, cost;\n\tedge(){}\n\tedge(int u,int v,int cost):u(u),v(v),cost(cost){}\n};\n \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n \nedge es[MAX_E];\nint V, E;\n \nll kruskal() {\n\tsort(es, es + E, comp);\n\tinit_uft(V);\n\tll res = 0LL;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same_uft(e.u, e.v)) {\n\t\t\tunite_uft(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m && n>0 ) {\n\t\tV=n; E=m*2;\n\t\tint a,b,c;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\tes[i*2] =edge(a,b,c);\n\t\t\tes[i*2+1] = edge(b,a,c);\n\t\t}\n\t\tcout<<kruskal()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint n,m,sum;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tif(P[b[bridge[i].second]] == b[bridge[i].second]) {\n\t\t\t\tif(P[a[bridge[i].second]] != b[bridge[i].second]) {\n\t\t\t\t\tP[b[bridge[i].second]] = a[bridge[i].second];\n\t\t\t\t\troot(b[bridge[i].second]);\n\t\t\t\t\tsum += bridge[i].first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<climits>\n#include<map>\nusing namespace std;\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define ALL(x) (x).begin(),(x).end()\n#define INF (2<<25)\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tint n,m;\n\t\tint cost[200][200];\n\t\tbool used[200]={};\n\t\t\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tFOR(i,200)FOR(j,200)cost[i][j]=INF;\n\t\t\n\t\tFOR(i,m)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\t\n\t\tpriority_queue< pii,vector<pii>,greater<pii> > que;\n\t\tque.push(pii(0,0));\n\t\tint ans=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tpii now=que.top();que.pop();\n\t\t\tif(used[now.second])continue;\n\t\t\tused[now.second]=true;\n\t\t\tans+=now.first;\n\t\t\tFOR(i,200)\n\t\t\t{\n\t\t\t\tif(cost[now.second][i]==INF)continue;\n\t\t\t\tque.push(pii(cost[now.second][i],i));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n \nconst int MAXN = 100;\nusing namespace std;\nbool visited[MAXN];\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\npriority_queue<pair<int,edge>,vector<P>,greater<P> > que;\nint main(){\n  int n,m;\n  while(cin >> n >> m && n + m != 0){\n \n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n    UnionFind u(m);\n    int ans = 0;\n    while(!que.empty()){\n      edge e = que.top().second;\n      int  cost= que.top().first;\n      que.pop();\n      if(!u.findSet(e.from,e.to)){\n\tans += cost;\n\tu.unionSet(e.from, e.to);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint data[101][101];\n\nint prim( int n )\n{\n\tvector<int> key( n, 99999999 );\n\tkey[0] = 0;\n\tvector<int> pq;\n\tvector<bool> inQueue( n, true );\n\tfor( int i = 0;i < n;i++ ){\n\t\tpq.push_back( key[i] );\n\t}\n\n\twhile( !pq.empty() ){\n\t\tvector<int>::iterator it = min_element( pq.begin(), pq.end() );\n\t\tint u = distance( pq.begin(), it );\n\t\tpq.erase( it );\n\t\tinQueue[u] = false;\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tif( data[u][i] ){\n\t\t\t\tif( inQueue[i] ){\n\t\t\t\t\tint w = data[u][i];\n\t\t\t\t\tif( w < key[i] ){\n\t\t\t\t\t\tkey[i] = w;\n\t\t\t\t\t\tpq[i] = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint answer = 0;\n\tfor( int i = 0;i < n;i++ ){\n\t\tanswer += key[i];\n\t}\n\n\treturn answer;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n,m;\n\tint a,b,cost;\n\n\twhile( cin >> n >> m && n != 0 ){\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0;i < m;i++ ){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tdata[a][b] = cost;\n\t\t\tdata[b][a] = cost;\n\t\t}\n\n\t\tint answer = prim( n );\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\nint par[1000];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tpar[x] = y;\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int maxn=101,maxm = 5010, INF = 10010;\nint cost[maxn][maxn];\nint mincost[maxn];\nbool used[maxn];\nint n,m,a,b;\n\nint main()\n{\n    while(cin >> n >> m &&(n&&m))\n    {\n        memset(cost,INF,sizeof(cost));\n        memset(mincost,INF,sizeof(mincost));\n        memset(used,false,sizeof(used));\n        mincost[0] = 0;\n\n        REP(m)\n        {\n            cin >> a >> b;\n            cin >> cost[a][b];\n            cost[b][a] = cost[a][b];\n        }\n\n        int ans = 0;\n        while(true)\n        {\n            int minv = INF;\n            REP(n)if(!used[i] &&(minv==INF || mincost[i] < mincost[minv])) minv = i;\n            if(minv == INF) break;\n\n            used[minv] = true;\n            ans += mincost[minv];\n            REP(n)mincost[i] = min(mincost[i], cost[minv][i]);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[200];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[500];\nint V,E;\n\nvoid init_union_find(int);\nint find(int);\nvoid unite(int,int);\nbool same(int,int);\nbool comp(const edge& e1,const edge& e2);\nint kruskal(void);\n\nusing namespace std;\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E && V){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void)\n{\n\tint n,m,a[500],b[500],cost[500],node[100],size[100],sum;\n\tint i,j,k;\n\twhile(1) {\n\t\tcin>>n>>m;\n\t\tsum=0;\n\t\tif(n==0&&m==0) break;\n\t\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>cost[i];\n\t\tfor(i=0;i<m-1;i++) {\n\t\t\tfor(j=i+1;j<m;j++) {\n\t\t\t\tif(cost[i]>cost[j]) {\n\t\t\t\t\tswap(cost[i],cost[j]);\n\t\t\t\t\tswap(a[i],a[j]);\n\t\t\t\t\tswap(b[i],b[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++) size[i]=1,node[i]=i;\n\t\tfor(i=0;i<m;i++) {\n\t\t\tint x,y,va;\n\t\t\tx=a[i],y=b[i],va=cost[i];\n\t\t\twhile(x!=node[x]) x=node[x];\n\t\t\twhile(y!=node[y]) y=node[y];\n\t\t\tif(x!=y) {\n\t\t\t\tsum+=va;\n\t\t\t\tif(size[x]>=size[y]) node[y]=x;\n\t\t\t\telse node[x]=y;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <class T>\nstruct Kruskal {\n  struct UnionFind {\n    int N;\n    vector<int> sz_tree, parent;\n    UnionFind() {}\n    UnionFind(int N) : N(N), sz_tree(N, 1), parent(N) {\n      iota(parent.begin(), parent.end(), 0);\n    }\n    int root(int x) {\n      return parent[x] == x ? x : parent[x] = root(parent[x]);\n    }\n    void merge(int x, int y) {\n      if ((x = root(x)) == (y = root(y))) return;\n      if (sz_tree[x] < sz_tree[y]) swap(x, y);\n      sz_tree[x] += sz_tree[y];\n      parent[y] = x;\n    }\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    int size(int x) {\n      return sz_tree[root(x)];\n    }\n  };\n  struct edge {\n    int from, to; T cost;\n    edge() {}\n    edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n  };\n \n  int N;\n  vector<edge> es;\n  Kruskal() {}\n  Kruskal(int N) : N(N) {}\n \n  void add_edge(int from, int to, T cost) {\n    es.emplace_back(from, to, cost);\n  }\n  T mst() {\n    T res = 0;\n    UnionFind uf(N);\n    sort(es.begin(), es.end(), [&](edge a, edge b) {\n      return a.cost < b.cost;\n    });\n    for (auto &e : es) {\n      if (uf.same(e.from, e.to)) continue;\n      uf.merge(e.from, e.to);\n      res += e.cost;\n    }\n    return res;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n, m;\n  while (cin >> n >> m, n) {\n    Kruskal<int> K(n);\n    for (int i = 0; i < m; i++) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      K.add_edge(a, b, cost);\n      K.add_edge(b, a, cost);\n    }\n    cout << K.mst() << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tban[i]=i;\n\t\tsize[i]=1;\n\t}\n\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\tfor(i=0;i<s;i++){\n\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\tfor(j=i+1;j<s;j++){\n\t\t\tif(g[i]>g[j]){\n\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t}\n\t\t}\n\t}\n\t/*for(i=0;i<s;i++)\n\t\tprintf(\"%d %d %d\\n\",d[i],f[i],g[i]);*/\n\tfor(i=0;i<s;i++){\n\t//\tprintf(\"%d %d %d\\n\\n\",d[i],f[i],g[i]);\n\t\tz=d[i]; x=f[i];\n\t\twhile(ban[z]!=z) z=ban[z];\n\t\twhile(ban[x]!=x) x=ban[x];\n\t\tif(z!=x){\n\t\t\tq+=g[i];\n\t\t\tif(size[z]>=size[x]) ban[x]=z;\n\t\t\telse if(size[z]<size[x]) ban[z]=x;\n\t\t\t/*else{\n\t\t\t\tban[x]=z;\n\t\t\t\tsize[x]++;\n\t\t\t}*/\n\t\t}\n\t}\n\tprintf(\"%d\\n\",q);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int b[],int c[],int n){\n  int i,j;\n  int mn=-1;\n  for(i=0;i<n;i++){\n    if(c[i]){\n      for(j=0;j<n;j++){\n\tif(a[i][j]!=-1&&c[j]==0&&(b[j]==-1||b[j]>a[i][j]))\n\t  b[j]=a[i][j];\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    if(b[i]!=-1&&c[i]==0&&(mn==-1||b[mn]>b[i]))\n      mn=i;\n  }\n  c[mn]=1;\n  return b[mn];\n}\nint main(){\n  int h,i,j;\n  int a[100][100],b[100],c[100],m,n;\n  int sm;\n  while(cin>>n>>m&&n+m){\n    memset(a,-1,sizeof(a));\n    memset(c,0,sizeof(c));\n    for(i=0;i<m;i++){\n      int p,q,r;\n      cin>>p>>q>>r;\n      a[p][q]=r;\n      a[q][p]=r;\n      c[p]++;\n      c[q]++;\n    }\n    sm=0;\n    do{\n      h=0;\n      for(i=0;i<n;i++){\n\tif(c[i]==1){\n\t  for(j=0;a[i][j]==-1;j++);\n\t  sm+=a[i][j];\n\t  a[i][j]=-1;\n\t  a[j][i]=-1;\n\t  c[i]--;\n\t  c[j]--;\n\t  h=1;\n\t}\n      }\n    }while(h);\n    for(i=0;c[i]==0;i++);\n    memset(b,-1,sizeof(b));\n    memset(c,0,sizeof(c));\n    b[i]=0;\n    c[i]=1;\n    for(i=1;i<n;i++)\n      sm+=f(a,b,c,n);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nint n, m;\n\nconst int UFSIZE = 110;\nint P[UFSIZE]; // 親\n\nvoid init() {\n  for (auto i=0; i<n; i++) {\n    P[i] = i;\n  }\n}\n\nint root(int a) {\n  if (a == P[a]) return a;\n  return (P[a] = root(P[a]));\n}\n\nbool issame(int a, int b) {\n  return root(a) == root(b);\n}\n\nvoid unite(int a, int b) {\n  P[root(a)] = root(b);\n}\n\n\nint main() {\n  while (cin >> n >> m && n) {\n    vector< tuple<int, int, int> > V; // cost, node1, node2\n    for (auto i=0; i<m; i++) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      V.push_back(make_tuple(cost, a, b));\n    }\n    sort(V.begin(), V.end());\n    int sum = 0;\n    init();\n    for (auto i=0; i<m; i++) {\n      int cost = get<0>(V[i]);\n      int nodea = get<1>(V[i]);\n      int nodeb = get<2>(V[i]);\n      if (!issame(nodea, nodeb)) {\n\tunite(nodea, nodeb);\n\tsum += cost;\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid init_union_find(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_E = 10000;\nedge es[MAX_E];\nint V, E;\n\nint kruskal(void){\n\tsort(es, es + E, comp);\n\tinit_union_find(V);\n\n\tint res = 0;\n\tfor(int i=0; i<E; ++i){\n\t\tedge e = es[i];\n\t\tif(!same(e.from, e.to)){\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\twhile(true){\n\t\tcin >> V >> E;\n\t\tif( V == 0 && E == 0 )\n\t\t\tbreak;\n\t\tfor(int i=0; i<E; i++){\n\t\t\tcin >> es[i].from >> es[i].to >> es[i].cost;\n\t\t}\n\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) (a).begin(),(a).end()\n#define pb(x) push_back(x)\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10) \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge{ int from, to, cost; };\n\nconst int N = 1000;\nint par[N]; int hukasa[N];\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x == y) return;\n\tif (hukasa[x] < hukasa[y]) par[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (hukasa[x] == hukasa[y]) hukasa[x]++;\n\t}\n}\n\nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid init_UFT(int n)\n{\n\tREP(i, n)\n\t{\n\t\tpar[i] = i;\n\t\thukasa[i] = 0;\n\t}\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nvector<edge> es;\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tinit_UFT(n);\n\t\tes.clear();\n\t\tint a, b, c;\n\t\tREP(i, m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e = { a, b, c };\n\t\t\tes.push_back(e);\n\t\t}\n\t\tsort(ALL(es), comp);\n\t\tint sum = 0;\n\t\tREP(i, es.size())\n\t\t{\n\t\t\tif (!same(es[i].from, es[i].to))\n\t\t\t{\n\t\t\t\tunite(es[i].from, es[i].to);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tint p, c;\n\tstate(int p, int c) : p(p), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tint a, b, c;\n\t\tvvi dist(n, vi(n, INF));\n\t\tREP(i, m) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a][b] = min(dist[a][b], c);\n\t\t\tdist[b][a] = min(dist[b][a], c); \n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tvi used(n);\n\t\tQ.push(state(0, 0));\n\t\tint ans = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(used[st.p]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tused[st.p] = 1;\n\t\t\tans += st.c;\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(dist[st.p][i] != INF && st.p != i) {\n\t\t\t\t\tQ.push(state(i, dist[st.p][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Bridge {\npublic:\n\tint u, v, cost;\n};\n\nBridge MapData[500];\nint Point[100];\nint Height[100];\n\n\nint find(int root) {\n\n\twhile (root != Point[root]) {\n\t\troot = Point[root];\n\t}\n\n\treturn root;\n}\n\nbool judge(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) {\n\t\treturn false;\n\t}\n\n\tif (Height[x] < Height[y]) {\n\t\tPoint[x] = y;\n\t}\n\telse {\n\t\tPoint[y] = x;\n\t\tif (Height[x] == Height[y]) {\n\t\t\tHeight[x]++;\n\t\t}\t\n\t}\n\n\treturn true;\n}\n\nbool cmp(Bridge &b1, Bridge &b2) {\n\treturn b1.cost < b2.cost;\n}\n\nint solve(int n, int m) {\n\tint cnt, sum;\n\n\tsort(MapData, MapData + m, cmp);\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint[i] = i;\n\t\tHeight[i] = 1;\n\t}\n\n\tcnt = sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (cnt == n - 1) {\n\t\t\treturn sum;\n\t\t}\n\n\t\tif (judge(MapData[i].u, MapData[i].v)) {\n\t\t\tcnt++;\n\t\t\tsum += MapData[i].cost;\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint main() {\n\tint n, m;\n\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> MapData[i].u >> MapData[i].v >> MapData[i].cost;\n\t\t}\n\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nclass dii{\n\tpublic:\n\tint first;\n\tint second;\n\tdii(int f,int s):first(f),second(s){}\n\tbool operator<(const dii& d)const{\n\t\tif(d.first == first) return d.second<second;\n\t\treturn d.first<first;\n\t}\n};\nint main(void){\n\tA:;\n\t\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==0)return 0;\n\t\n\tvector<pii> edge[100];\n\tint st = -1;\n\tint stmin = 1000000000;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tedge[a].push_back(pii(b,c));\n\t\tedge[b].push_back(pii(a,c));\n\t\t\n\t\tif(c<stmin){\n\t\t\tstmin = c;\n\t\t\tst = a;\n\t\t}\n\t}\n\t\n\tpriority_queue<dii> que;\n\trep(i,edge[st].size()){\n\t\tque.push(dii(edge[st][i].second, edge[st][i].first));\n\t}\n\t\n\tint visit[101]={0};\n\tvisit[st]=1;\n\tint ans = 0;\n\twhile(1){\n\t\tif(que.empty())break;\n\t\tdii u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.second]==1)continue;\n\t\tvisit[u.second]=1;\n\t\t\n\t\tans += u.first;\n\t\t\n\t\trep(i,edge[u.second].size()){\n\t\t\tque.push(dii(edge[u.second][i].second, edge[u.second][i].first));\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\tgoto A;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(lli i=0;i<(lli)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint pass[200][200];\n\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        \n        rep(i,200)rep(j,200)pass[i][j]=INF;\n        \n        rep(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            pass[a][b]=c;\n            pass[b][a]=c;\n        }\n        \n        bool used[200];\n        int mincost[200];\n        rep(i,200)mincost[i]=INF;\n        rep(i,200)used[i]=false;\n        \n        int res=0;\n        mincost[0]=0;\n\n        while(1){\n            int v=-1;\n            rep(i,n){\n                if( !used[i]&&(v==-1||mincost[v]>mincost[i]) )v=i;\n            }\n            \n            if(v==-1)break;\n            \n            used[v]=true;\n            res+=mincost[v];\n            \n            rep(i,n){\n                mincost[i] = min( mincost[i] , pass[v][i] );\n            }\n        }\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=100052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\n\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tUF uf;\n\t\tpriority_queue<pair<int,pii>> pq;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tpq.push(mkp(-c,mkp(a,b)));\n\t\t}\n\t\tint ans=0;\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> top=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(uf[top.S.F]!=uf[top.S.S]){\n\t\t\t\tans+=-top.F;\n\t\t\t\tuf.unite(top.S.F,top.S.S);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\tbreak;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint V, E;\nvector<vector<edge>> es;\nbool used[10000];\n\npair<int, vector<edge>> prim()\n{\n\tmemset(used, false, sizeof(used));\n\tvector<edge> res;\n\tint sum = 0;\n\n\tpriority_queue<edge, vector<edge>, greater<edge>> que;\n\tque.push(edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (edge i : es[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn pair<int, vector<edge>>(sum, res);\n}\n\nint main()\n{\n\twhile (cin >> V >> E, V)\n\t{\n\t\tes.clear();\n\t\tes.resize(V);\n\t\tREP(i, E)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tes[a].push_back(edge{ a, b, c });\n\t\t\tes[b].push_back(edge{ b, a, c });\n\t\t}\n\t\tcout << prim().first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nbool used[100]; long long dist[100];\nlong long prim(int V, vector<pair<int, long long> > X[]) {\n\tpriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > Q;\n\tfor (int i = 0; i < V; i++) dist[i] = INF, used[i] = false;\n\tdist[0] = 0; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<int, long long> pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; used[a2] = true;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint to = X[a2][i].first; long long leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && !used[to]) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0;\n\tfor (int i = 0; i < V; i++) sum += dist[i];\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<int, long long> > G[100];\nint main() {\n\twhile(cin >> n >> m, n) {\n\t\tfor(int i = 0; i < n; i++) G[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> u >> v >> w;\n\t\t\tG[u].push_back(make_pair(v, w));\n\t\t\tG[v].push_back(make_pair(u, w));\n\t\t}\n\t\tcout << prim(n, G) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define MAX_V 100\n\nint cost[MAX_V][MAX_V]; // cost[u][v] ?????????u??????v???????????????\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;// V???????????°\n\n// ????°???¨?????¨??§?????????O(V^2)\n\n// ???????????????????????????????????????cost????¨?????????????????????¨\n\nint prim(){\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\tmincost[0] = 0;\n\t\n\tint total = 0;\n\t\n\twhile(true){\n\t\t\n\t\tint add_v = -1;\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u] && (add_v == -1 || mincost[u] < mincost[add_v])){\n\t\t\t\tadd_v = u;\n\t\t\t}\n\t\t} // ??????????????????????±????\n\t\t\n\t\tif(add_v == -1){\n\t\t\tbreak;\n\t\t} // ??´??°???????????????????????´????????????\n\t\tused[add_v] = true;\n\t\ttotal += mincost[add_v];\n\t\t\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[add_v][u]);\n\t\t} // ???????????????????????????????°???????????????´??°\n\t}\n\treturn total;\n}\n\nint main(){\n\t\n\tint ans, m;\n\t\n\twhile(true){\n\t\tcin >> V >> m;\n\t\tif(V == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a, b, c;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\t\n\t\tans = prim();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main(){\n  int br[100][100];\n  bool f[100];\n  int tr[100];\n  int n,m;\n\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0) break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n\tbr[i][j] = -1;\n      tr[i]=INT_MAX;\n      f[i]=0;\n    }    \n    for(int k=0;k<m;k++){\n      int a,b,cost;\n      cin>>a>>b>>cost;\n      br[a][b]=cost;\n      br[b][a]=cost;\n    }\n    int comin=0,r,trmin;\n    tr[0] = 0;\n\n    for(int k=0;k<n;k++){\n      trmin=INT_MAX;\n      for(int i=0;i<n;i++)\n\tif(f[i]==0 && trmin>tr[i]) r=i,trmin=tr[i];\n      //cout << trmin<<endl;\n      comin+=trmin;\n      f[r]=1;\n      for(int i=0;i<n;i++){\n\tif(f[i]==0 && tr[i]>br[r][i] && br[r][i]!=-1) tr[i]=br[r][i];\n      }\n    }\n    cout <<comin<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\nusing LL = long long;\t\tusing VB = vector<bool>;\nusing VI = vector<int>;\t\tusing VL = vector<LL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing VVI = vector<VI>;\t\tusing VVL = vector<VL>;\nusing PII = pair<int, int>;\tusing PLL = pair<LL, LL>;\nusing VP = vector<PII>;\t\tusing VPL = vector<PLL>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\nusing Weight = LL;\nstruct Edge {\n\tint to; Weight cost;\n\tEdge(int _to, Weight _cost = 1) :to(_to), cost(_cost) {}\n};\nbool operator>(const Edge& e1, const Edge& e2) { return e1.cost > e2.cost; }\nstruct Edge2 {\n\tint u, v; Weight cost;\n\tEdge2() :u(-1), v(-1), cost(0) {}\n\tEdge2(int _u, int _v, Weight _cost) :u(_u), v(_v), cost(_cost) {}\n};\nusing Graph = vector<vector<Edge>>;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n\nclass UnionFind {\n\tvector<int> par, sz;\npublic:\n\tUnionFind(int n = 1) {\n\t\tinit(n);\n\t}\n\tvoid init(int n) {\n\t\tpar.resize(n); sz.resize(n);\n\t\tfor (int i = 0; i < n; i++)par[i] = i, sz[i] = 1;\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = root(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint size(int x) {\n\t\treturn sz[root(x)];\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return;\n\t\tpar[y] = x;\n\t\tsz[x] += sz[y];\n\t}\n};\n\nWeight Kruskal(int V, vector<Edge2>& graph) {\n\tsort(graph.begin(), graph.end(),\n\t\t[](const Edge2& e1, const Edge2& e2) {return e1.cost < e2.cost; });\n\tint E = graph.size(); Weight ret = 0;\n\tUnionFind uf(V);\n\tfor (auto e : graph) {\n\t\tif (!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tret += e.cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m && (n || m)) {\n\t\tvector<Edge2> g;\n\t\trep(i, m) {\n\t\t\tint a = in, b = in; LL c = in;\n\t\t\tg.eb(a, b, c);\n\t\t\tg.eb(b, a, c);\n\t\t}\n\t\tout(Kruskal(n, g));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tban[i]=i;\n\t\tsize[i]=1;\n\t}\n\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\tfor(i=0;i<s;i++){\n\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\tfor(j=i+1;j<s;j++){\n\t\t\tif(g[i]>g[j]){\n\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<s;i++){\n\t//\tprintf(\"%d %d %d\\n\\n\",d[i],f[i],g[i]);\n\t\tz=d[i]; x=f[i];\n\t\twhile(ban[z]!=z) z=ban[z];\n\t\twhile(ban[x]!=x) x=ban[x];\n\t\tif(z!=x){\n\t\t\tq+=g[i];\n\t\t\tif(size[z]>size[x]) ban[z]=x;\n\t\t\telse if(size[z]<size[x]) ban[x]=z;\n\t\t\telse{\n\t\t\t\tban[x]=z;\n\t\t\t\tsize[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",q);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0180\n// PCK2008yosen-08\n// パソコン甲子園・・・チームrand()・・・うっ・・・高校時代も今もあいつらとは目を合わせないように生きてきたんだ・・・\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct bridge {\n\tint a;\n\tint b;\n\tint cost;\n\t\n\tbool operator < ( const bridge& com ) const {\n\t\treturn (this->cost < com.cost);\n\t};\n};\n\nint root[110];\nbridge br[10010];\n\nint getroot(int city) {\n\tif ( root[city] == city ) {\n\t\treturn city;\n\t}\n\troot[city] = getroot(root[city]);\n\treturn root[city];\n}\n\nint main(void) {\n\t\n\twhile(true) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif ( n == 0 ) { return 0; }\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tscanf(\"%d %d %d\", &br[i].a, &br[i].b, &br[i].cost);\n\t\t}\n\t\t\n\t\tsort(br, br+m);\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\troot[i] = i;\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tif ( root[br[i].a] == root[br[i].b] ) { continue; }\n\t\t\t\n\t\t\t// 橋を追加\n\t\t\ttotal += br[i].cost;\n\t\t\tint ra = getroot(br[i].a);\n\t\t\tint rb = getroot(br[i].b);\n\t\t\troot[ra] = rb;\n\t\t\t\n\t\t\tint j;\n\t\t\tfor(j=1; j<n; j++) {\n\t\t\t\tif (getroot(j) != getroot(0)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int aa=0; aa<n; aa++) {\n\t\t\t\tprintf(\"%d \", root[aa]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t\tif ( j == n ) { break; }\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass S{\n\tpublic:\n\tint x,now,bef;\n\tS(int x,int now,int bef):x(x),now(now),bef(bef){}\n\tbool operator<(const S&a)const{\n\t\treturn now>a.now;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tint to[111][111]={0};\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\tto[a][b]=c;\n\t\t\tto[b][a]=c;\n\t\t}\n\t\t\n\t\tpriority_queue<S> que;\n\t\tque.push(S(0,0,-1));\n\t\t\n\t\tint ans=0;\n\t\t\n\t\tint visit[111]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\t\n\t\t\tS u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.x]==1)continue;\n\t\t\tvisit[u.x]=1;\n\t\t\t\n\t\t\tif(u.bef!=-1){\n\t\t\t\tans += u.now;\n\t\t\t}\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\tif(to[u.x][i]==0)continue;\n\t\t\t\tque.push( S(i ,to[u.x][i] ,u.x) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n// O(n'2 + e)\n// テ」ツδ療」ツδェテ」ツδ?ヲツウツ?\n\n#include <iostream>\n#include <algorithm>\n#define MAX 100\n#define INF 999999\n\nusing namespace std;\n\nint cost[MAX + 1][MAX + 1];\nint mincost[MAX + 1];\nbool used[MAX + 1];\n\nint prim(int V){ // テ」ツδ偲」ツδシテ」ツδ嘉ヲツ閉ー\n\n  for(int i = 0 ; i < V ; i++){ // テ・ツ按敕ヲツ慊淌・ツ個?\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0; \n  int res = 0 ; \n\n  while(true){\n    int v = -1;\n    for(int u = 0 ; u < V ; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      // テ、ツスツソテ」ツ?」テ」ツ?ヲテ」ツ?ェテ」ツ??」ツつ?」ツ?、テ」ツ?ァテヲツ慊?」ツつづ・ツーツ湘」ツ?陛」ツ??ostテ」ツ?ョテヲツキツサテ・ツュツ療」ツつ津ヲツ篠「テ」ツ??\n    }\n    if(v == -1) break;\n    used[v] = true; // テ」ツ?凖」ツ?ァテ」ツ?ォテ、ツスツソテ」ツ?」テ」ツ?淌」ツ?禿」ツ?ィテ」ツ?ォテ」ツ?凖」ツつ?\n    res += mincost[v];\n\n    for(int u = 0 ; u < V ; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n      // mincostテ」ツ?ョテァツ「ツコテ・ツョツ?\n    }\n  }\n  return res;\n}\n\nint main(void){\n\n  int n, m;\n  while(cin >> n >> m, n + m){\n\n    fill(cost[0], cost[MAX], INF);\n\n    for(int i = 0 ; i < m ; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    cout << prim(n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main(){\n  int br[100][100];\n  bool f[100];\n  int tr[100];\n  int n,m;\n\n  while(1){\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)\n\tbr[i][j] = -1;\n      tr[i]=INT_MAX;\n      f[i]=0;\n    }    \n    for(int k=0;k<m;k++){\n      int a,b,cost;\n      cin>>a>>b>>cost;\n      br[a][b]=cost;\n      br[b][a]=cost;\n    }\n    int comin=0,r,trmin;\n    tr[0] = 0;\n\n    for(int k=0;k<n;k++){\n      trmin=INT_MAX;\n      for(int i=0;i<n;i++)\n\tif(f[i]==0 && trmin>tr[i]) r=i,trmin=tr[i];\n      //cout << trmin<<endl;\n      comin+=trmin;\n      f[r]=1;\n      for(int i=0;i<n;i++){\n\tif(f[i]==0 && tr[i]>br[r][i] && br[r][i]!=-1) tr[i]=br[r][i];\n      }\n    }\n    cout <<comin<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(cost, 0x3f, sizeof(cost));\n\t\trep(i, m) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tcost[a][b] = c;\n\t\t}\n\t\tmemset(mincost, 0x3f, sizeof(mincost));\n\t\tmemset(used, 0, sizeof(used));\n\t\tmincost[0] = 0;\n\t\tint ans = 0;\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\trep(i, n) {\n\t\t\t\tif (!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t\t\tv = i;\n\t\t\t}\n\t\t\tif (v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tans += mincost[v];\n\t\t\trep(i, n)mincost[i] = min(mincost[i], cost[v][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1<<27\nint n,cost[110][110],mincost[110];\nbool used[110];\nint prim(){\n  r(i,n)mincost[i]=INF,used[i]=false;\n  mincost[0]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    r(u,n)if(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n    if(v==-1)break;\n    used[v]=1;\n    res+=mincost[v];\n    r(u,n)mincost[u]=min(mincost[u],cost[v][u]);\n  }\nreturn res;\n}\nint main(){\n  int m,q,w,e;\n  while(cin>>n>>m,n){\n  r(i,n)r(j,n)cost[i][j]=INF;\n  while(m--)cin>>q>>w>>e,cost[w][q]=cost[q][w]=e;\n  cout<<prim()<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// http://www.prefield.com/algorithm/container/union_find.html\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main(){\n  while(true){\n    int n,m;\n    cin>>n>>m;\n    if(n==0 && m==0)break;\n    int res = 0;\n    vector< pair<int,pii> > edges(m);\n    REP(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      edges[i] = make_pair(c,make_pair(a,b));\n    }\n    sort(ALL(edges));\n    UnionFind uf(n);\n    REP(i,m){\n      int a,b,c;\n      c = edges[i].first;\n      a = edges[i].second.first;\n      b = edges[i].second.second;\n      if(!uf.findSet(a,b)){\n        uf.unionSet(a,b);\n        res += c;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n\ntemplate<typename T>\nstruct Kruskal {\n    struct Edge {\n        int from, to;\n        T cost;\n        bool used;\n        Edge(int from, int to, T cost) : from(from), to(to), cost(cost), used(false){}\n        bool operator<(const Edge& e) const {\n            return cost < e.cost;\n        }\n    };\n    struct UF {\n        vector<int> r, p;\n        UF() = default;\n        UF(int sz) : r(sz, 1), p(sz){ iota(begin(p), end(p), 0LL); }\n        int find(int x){\n            return (x == p[x] ? x : p[x] = find(p[x]));\n        }\n        bool same(int x, int y){\n            return find(x) == find(y);\n        }\n        void unite(int x, int y){\n            x = find(x), y = find(y);\n            if(x == y) return;\n            if(r[x] < r[y]) swap(x, y);\n            r[x] += r[y];\n            p[y] = x;\n        }\n    };\n    vector<Edge> es;\n    UF uf;\n    Kruskal() = default;\n    Kruskal(int n) : uf(n){}\n    void addEdge(int u, int v, T c){\n        es.emplace_back(u, v, c);\n    }\n    T build(){\n        sort(begin(es), end(es));\n        T res = 0;\n        for(auto& e : es){\n            if(!uf.same(e.from, e.to)){\n                res += e.cost;\n                uf.unite(e.from, e.to);\n                e.used = true;\n            }\n        }\n        return res;\n    }\n    Edge operator[](int i) const {\n        return es[i];\n    }\n    vector<Edge> edgeSet() const {\n        return es;\n    }\n};\n\n\nsigned main(){\n    int N, M;\n    while(cin >> N >> M, N+M){\n        Kruskal<int> g(N);\n        for(int i = 0;i < M;++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            g.addEdge(a, b, c);\n        }\n        cout << g.build() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#define MAX_V 1000\n#define INF 1<<29\n#define cl(a,b) for(int i=0;i<a;i++)for(int j=0;j<b;j++)cost[i][j] = INF;\n#define de(a)  for(int i=0;i<a;i++){cout << mincost[i] << \" \"; if(i == a-1){cout << endl;}}\n#define de2(a,b) for(int I=0;I<a;I++){for(int j=0;j<b;j++){cout << cost[I][j] << \" \";}cout << endl;}cout << endl;\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n bool connect[10000];\n\nint prime()\n{\n  for(int i=0;i<V;++i)\n    {\n      mincost[i]=INF;\n      used[i]=false;\n    }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  //de(10);\n  \n\n  //de2(10,10);\n  \n\n  while(true)\n    {\n      int v = -1; \n      for(int u = 0; u<V ; u++ )\n\t{\n\t  if(connect[u] && !used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t    {\n\t      v = u;\n\t    }\n\t}\n\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n     \n      for(int u = 0; u < V; u++)\n\t{\n\t \n\t  mincost[u] = min(mincost[u],cost[v][u]);\n\t  //cout << \"mincost[u] = \" << mincost[u] << \", cost[v][u] = \" << cost[v][u] << endl;\n\t  \n\t}\n    }\n  return res;\n}\n\n\n\nint main()\n{\n\n  int n,m,a,b;\n \n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n == 0 && m == 0)break;\n      cl(n,n);\n      memset(connect,false,sizeof(connect));\n\n      V = n;\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> a >> b;\n\t  cin >> cost[a][b];\n\t  cost[b][a] = cost[a][b];\n\t  connect[a] = true;\n\t  connect[b] = true;\n\t}\n      \n\n      cout << prime() << endl;\n\n\n\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(), (c).end()\n\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    foreach(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\tg[a].push_back(Edge(a,b,c));\n\t\t\tg[b].push_back(Edge(b,a,c));\n\t\t}\n\t\tcout<<minimumSpanningTree(g).first<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n,m,a,b,c,mi,ret;\n\tint info[100][100];\n\twhile(cin >> n >> m && n){\n\t\tret = 0;\n\t\trep(i,100)rep(j,100)info[i][j] = INT_MAX;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tinfo[a][b] = info[b][a] = c;\n\t\t}\n\t\tlist<int> X,Y;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tY.push_back(i);\n\t\t}\n\t\tX.push_back(0);\n\t\twhile(!Y.empty()){\n\t\t\tmi = INT_MAX;\n\t\t\tlist<int>::iterator it = X.begin();\n\t\t\twhile( it != X.end() ){\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif( count(Y.begin(),Y.end(),i) )\n\t\t\t\t\t\tif(info[*it][i]<mi){\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tmi = info[*it][i];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++it;\n\t\t\t}\n\t\t\tX.push_back(a);\n\t\t\tit = Y.begin();\n\t\t\twhile( it != Y.end() ){\n\t\t\t\tif((*it)==a){\n\t\t\t\t\tY.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++it;\n\t\t\t}\n\t\t\tret+=mi;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 150\n#define INF 1e9\n\nbool used[MAX_V];\nint cost[MAX_V][MAX_V], mincost[MAX_V], V;\n\nint prim(){\n  for(int i = 0 ; i < V ; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0 ; u < V ; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])){\n        v = u;\n      }\n    }\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0 ; u < V ; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int E, a, b, c;\n\n  while(cin >> V >> E, (V|E)){\n    fill(cost[0],cost[MAX_V],INF);\n    for(int i = 0 ; i < E ; i++){\n      cin >> a >> b >> c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){\n\tif(parent[a]==a)return a;\n\treturn parent[a]=root(parent[a]);\n}\nint unite(int a,int b){\n\tif(root(a)==root(b))return 0;\n\tparent[root(a)]=root(b);\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;cin>>n>>m,n;cout<<s<<endl){\n\t\tfor(i=0;i<m;i++)cin>>a[i]>>b[i]>>node[i].first,node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<climits>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m),n+m){\n    int  cost[n][n];\n    bool f[n];\n    memset(cost, 0, sizeof(cost));\n    memset(f, 0, sizeof(f));\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      cost[a][b] = cost[b][a] = c;\n    }\n    f[0] = true;\n    int ans = 0;\n    REP(i,n-1){\n      int m = INT_MAX;\n      int ii,jj;\n      for(int i=0; i<n; i++){\n\tfor(int j=i+1; j<n; j++){\n\t  if(f[i] ^ f[j] && cost[i][j] != 0){\n\t    if(m > cost[i][j]){\n\t      ii = i; jj = j;\n\t      m = cost[i][j];\n\t    }\n\t  }\n\t}\n      }\n      f[ii] = f[jj] = true;\n      ans += m;\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define  MAX 101\n\n\nstruct Dis\n{\n    int pa[MAX];\n    int used[MAX];\n    int n;\n    Dis(int n):n(n)\n    {\n        for(int i=0;i<n;i++)\n        {\n            pa[i]=i;\n            used[i]=0;\n        }\n    }\n    void use(int i)\n    {\n        used[i]=1;\n    }\n    int root(int a)\n    {\n        if(pa[a]==a)\n            return a;\n        return pa[a]=root(pa[a]);\n    }\n    bool is_same_set(int a,int b)\n    {\n        return root(a)==root(b);\n    }\n    void unite(int n,int m)\n    {\n        use(n);\n        use(m);\n        pa[root(n)]=root(m);\n    }\n    bool is_connected()\n    {\n        int rt=-1;\n        for(int i=0;i<n;i++)\n        {\n            if(rt>=0 &&used[i] && rt!=root(i))\n                return false;\n            if(used[i])\n                rt=root(i);\n        }\n        return rt!=-1;\n    }\n};\n\nint br[6000][3];\n\nint getMin(int m)\n{\n    int tmp=-1;\n    for(int i=0;i<m;i++)\n    {\n        if(br[i][2]!=-1)\n        {\n            if(tmp==-1 || br[tmp][2]>br[i][2])\n            {\n                tmp=i;\n            }\n        }\n    }\n    if(tmp!=-1)\n    {\n        return tmp;\n    }\n    return -1;\n}\n\nint main(void)\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)==2 && n && m)\n    {\n        Dis dis(n);\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",br[i],br[i]+1,br[i]+2);\n        }\n        int nc=0;\n        int cost=0;\n        while(nc<n-1)\n        {\n            int min=getMin(m);\n            if(min==-1)\n            {\n                puts(\"min=-1\");\n            }\n            int a=br[min][0];\n            int b=br[min][1];\n            if(!dis.is_same_set(a,b))\n            {\n                dis.unite(a,b);\n                nc++;\n                cost+=br[min][2];\n            }\n            br[min][2]=-1;\n        }\n        printf(\"%d\\n\",cost);\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct Kruskal{\n    struct edge{\n        int from,to,used; T cost;\n        edge(int from,int to,T cost):\n            from(from),to(to),cost(cost),used(0){}\n        bool operator<(const edge &e) const{\n            if (cost!=e.cost) return cost<e.cost;\n            else if (from!=e.from) return from<e.from;\n            else return to<e.to;\n        }\n    };\n    int num;\n    vector<int> par,rank;\n    vector<edge> es;\n    Kruskal(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        if (par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n    void add_edge(int u,int v,T c){\n        es.emplace_back(u,v,c);\n    }\n    T build(){\n        sort(es.begin(),es.end());\n        T res=0;\n        for (auto &e:es){\n            if (!same(e.from,e.to)){\n                res+=e.cost;\n                merge(e.from,e.to);\n                e.used=1;\n            }\n        }\n        return res;\n    }\n    vector<int> used_es(T &c){\n        int E=es.size();\n        map<edge,int> m;\n        for (int i=0;i<E;++i) m[es[i]]=i;\n        c=build();\n        vector<int> list(E);\n        for (int i=0;i<E;++i) list[m[es[i]]]=es[i].used;\n        return list;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    while(cin >> n >> m,n,m){\n        Kruskal<int> K(n);\n        for (int i=0;i<m;++i){\n            int a,b,cost; cin >> a >> b >> cost;\n            K.add_edge(a,b,cost);\n        }\n        cout << K.build() << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n\nint par[100], rank[100];\n\nvoid init( int n )\n{\n\tfor( int i = 0; i != n; ++i )\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( par[x] == x )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] < rank[y] )\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[x];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nstruct edge{ int from, to, cost; };\n\nint n, m;\nstd::vector<edge> es;\n\nint main()\n{\n\twhile( std::cin >> n >> m, n | m )\n\t{\n\t\tes.clear();\n\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tint a, b, cost;\n\t\t\tstd::cin >> a >> b >> cost;\n\t\t\tedge e = { a, b, cost };\n\t\t\tes.push_back( e );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), []( const edge& e1, const edge& e2 ){ return e1.cost < e2.cost; } );\n\n\t\tinit( n );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tif( !same( es[i].from, es[i].to ) )\n\t\t\t{\n\t\t\t\tans += es[i].cost;\n\t\t\t\tunite( es[i].from, es[i].to );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n//#include <fstream>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int M = 100000;\n\nint prim (vector <vector <int> > t )\n{\n\tint size = t.size();\n\tvector <int> cost (size, M ); \n\tvector <bool> visit (size, false );\n\tvector <int> path (size, -1 );\n\n\tcost[0] = 0;\n\tint mincost = M;\n\tint i,p;\n\n\tdo{\n\t\tmincost = M;\n\t\tfor (i = 0; i < size; ++i){\n\t\t\tif (!visit[i] && mincost > cost[i] ){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tp = i;\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tvisit[p] = true;\n\t\t\n\t\tfor (i = 0; i < size; ++i){\n\t\t// m[huÉ×ÚµÄ¢ém[hÅ\n\t\t// Ü¾ÜÜêÄ¢È¢m[hÌRXgÌXV\n\t\t\tif (!visit[i] && t[p][i] < cost[i] ){\n\t\t\t\tcost[i] = t[p][i];\n\t\t\t\tpath[i] = p;\n\t\t\t} // end if\n\t\t} // end for\n\n\t}while ((int)count (visit.begin(), visit.end(), true ) != size );\n\n\tset <P> bridge;\n\n\tfor (i = size - 1; i > 0; --i){\n\t\tint n = i;\n\t\twhile (n != -1){\n\t\t\tP b(i, path[i] );\n\t\t\tbridge.insert (b );\n\t\t\tn = path[n];\n\t\t} // end while\n\t} // end for\n\n\tint res = 0;\n\tset <P>::iterator it = bridge.begin();\n\tfor (; it != bridge.end(); ++it){\n\t\tres += t[(*it).first][(*it).second];\t\t\n\t} // end for\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.stellar\", \"r\", stdin );\n\n\tstring str = \"\";\n\tint n, m;\n\n\twhile (getline (cin, str ) ){\n\t\tstringstream ssn(str);\n\t\tssn >> n >> m;\n\t\t\n\t\tif (!n && !m ){\n\t\t\tbreak;\n\t\t} // end if\n\n\t\tvector <vector <int> > t (n, vector <int> (n, M ) );\n \t\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tint from, to, cost;\n\t\t\tgetline (cin, str );\n\t\t\tstringstream ss(str);\n\t\t\tss >> from >> to >> cost;\n\t\t\tt[from][to] = cost;\n\t\t\tt[to][from] = cost;\n\t\t} // end for\n\t\t\n\t\tint res = prim (t );\n\t\tcout << res << endl;\t\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint par[104];\nint ran[105];\nvoid init(int n) {\n\tfor (int i = 0; i<n; i++) {\n\t\tpar[i] = i;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (ran[x]<ran[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nstruct edge { int s, t, cost; };\nbool comp(edge& e1, edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n != 0) {\n\t\tinit(n);\n\t\tedge b[10008];\n\t\tint x, y, z;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tb[i].s = x;\n\t\t\tb[i].t = y;\n\t\t\tb[i].cost = z;\n\t\t}\n\t\tint ans = 0;\n\t\tsort(b, b + m, comp);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tedge now = b[i];\n\t\t\tif (!same(now.s, now.t)) {\n\t\t\t\tunite(now.s, now.t);\n\t\t\t\tans += now.cost;\n\t\t\t}\n\t\t}cout << ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}\n       \n       \n       \n     "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nint path[101][101];\n\nint main(){\n\tstring str;\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) continue;\n\t\t\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost+n,INF);\n\t\tfill((int*)path,(int*)path+101*101,INF);\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&cost);\n\t\t\tpath[a][b] = min(cost,path[a][b]);\n\t\t\tpath[b][a] = min(cost,path[b][a]);\n\t\t}\n\n\t\tint res=0;\n\t\tmincost[0] = 0;\n\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v])){\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = min(mincost[u],path[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\n\t\tdelete[] mincost;\n\t\tdelete[] used;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint n, m;\nint cost[100][100];\nbool used[100];\nint mincost[100];\n\nint prim(){\n  for(int i=0;i<n;++i){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u=0;u<n;++u){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u=0;u<n;++u){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    fill(cost[0], cost[100], INF);\n    for(int i=0;i<m;++i){\n      int a, b, c;\n      cin >> a >> b >> c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nstruct edge\n{\n    int to, cost;\n    edge(int to, int cost) { this->to = to, this->cost = cost; }\n};\nint n, m;\nint MST(vector<edge> G[])\n{\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> used(n, 0);\n    que.push(make_pair(0, 0));\n    int res = 0;\n    while(que.size())\n    {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(used[v]) continue;\n        used[v] = 1;\n        res += p.first;\n        for(int u = 0; u < G[v].size(); u++)\n        {\n            edge e = G[v][u];\n            que.push(make_pair(e.cost, e.to));\n        }\n    }\n    return res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> n >> m, n | m)\n    {\n        vector<edge> G[n];\n        for(int i = 0; i < m; i++)\n        {\n            int a, b, c; cin >> a >> b >> c;\n            G[a].push_back(edge(b, c));\n            G[b].push_back(edge(a, c));\n        }\n        cout << MST(G) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_E 1001\n#define MAX_N 101\n\nstruct Edge {\n  int u, v, cost;\n};\n\nEdge es[MAX_E];\nint n, m;\nint par[MAX_N], rank[MAX_N];\n\nvoid init_union_find() {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nbool issame(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool comp(const Edge &e1, const Edge &e2 ) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + m, comp);\n  init_union_find();\n  int res = 0;\n  for(int i=0; i<m; i++) {\n    Edge e = es[i];\n    if(!issame(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> n >> m && n+m) {\n    for(int i=0; i<n; i++) {\n      cin >> es[i].u >> es[i].v >> es[i].cost;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_N = 100, MAX_M = 100;\n\nint n, m;\nint G[MAX_N][MAX_N];\nint d[MAX_N];\nbool visited[MAX_N];\n\nint main(){\n    while(scanf(\"%d%d\", &n, &m) && (n||m)){\n        for(int x = 0; x < n; x++){\n            for(int y = 0; y < n; y++){\n                if(x - y) G[x][y] = INF;\n                else G[x][y] = 0;\n            }\n        }\n        for(int x = 0; x < m; x++){\n            int a, b, c;\n            scanf(\"%d%d%d\", &a, &b, &c);\n            G[a][b] = c;\n            G[b][a] = c;\n        }\n        fill(d, d+n, INF);\n        fill(visited, visited+n, false);\n        d[0] = 0;\n        visited[0] = true;\n        int ans = 0;\n        int a = 0;\n        for(int x = 0; x < n; x++){\n            int v = -1;\n            for(int y = 0; y < n; y++){\n                if(visited[y]) continue;\n                d[y] = min(d[y], G[a][y]);\n                if(v == -1 || d[y] < d[v]){\n                    v = y;\n                }\n            }\n            if(v == -1) break;\n            visited[v] = true;\n            ans += d[v];\n            a = v;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nvector<pii> G[MAX];\n\nvoid init()\n{\n    for (int i = 0; i < MAX; i++) {\n        G[i].clear();\n    }\n}\n\nint prim()\n{\n    int res = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> Q;\n    Q.push(pii(0, 0));\n\n    bool close[MAX] = {};\n    \n    while (!Q.empty()) {\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        \n        if (close[v]) continue;\n        close[v] = 1;\n        \n        res += p.first;\n        \n        for (int i = 0; i < (int)G[v].size(); i++) {\n            pii e = G[v][i];\n            Q.push(pii(e.second, e.first));\n        }        \n    }    \n    return res;\n}\n\nint main()\n{\n    int N, M, a, b, c;\n    while (cin >> N >> M, N) {\n        init();\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            G[a].push_back(pii(b, c));\n            G[b].push_back(pii(a, c));\n        }\n        cout << prim() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}\n       "
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tvector<bool> done(n, false);\n\tREP(i, m){\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t\tnode[to].PB(MP(cost, from));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second] && !done[p.second]){\n\t\t\t\tdone[u] = true;\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\nusing vb = vector<bool>;\nusing vi = vector<int>; using vvi = vector<vector<int>>;\nusing vl = vector<ll>; using vvl = vector<vector<ll>>;\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define rALL(obj) (obj).rbegin(), (obj).rend()\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst ll MOD = 1e9+7;\n//#define int ll\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nstruct edge{\n  int to,wt,from;\n  bool operator<(edge right){\n    return wt < right.wt;\n  }\n};\nusing ve = vector<edge>;\nusing vve = vector<ve>;\nstruct union_find{//rank,経路圧縮で高速化\n  vector<long long> data;//そのノードがrootであれば-（集合のサイズ）を表し、そうでなければ親ノードidを示す。\n  union_find(long long size):data(size,-1){}//コンストラクタ,size個のノードを作成し、-1で初期化\n  long long root(long long a){//根を探す,経路圧縮\n    return data[a] < 0 ? a : data[a]=root(data[a]);\n  }\n  bool find(long long a,long long b){//a,bが同じ集合に属するか調べる\n    return root(a) == root(b);\n  }\n  bool unite(long long a,long long b){//小さい方の木の根に大きい方の根を上書きする\n    a = root(a),b = root(b);\n    if(a==b) return false;//根が同じなら終了,uniteが失敗したことを出力\n    if(data[a]<data[b]) swap(a,b); //集合サイズの大きい方の根に低い方の根をつける\n    data[a] += data[b];//集合サイズを統合\n    data[a] = b;//yの親にxをつける\n    return true;//unite成功を出力\n  }\n  long long size(long long a){//aが属する集合のサイズを出力\n    return -data[root(a)];\n  }\n};\nint kruskal(int sz,ve &edges){\n  sort(rALL(edges));\n  union_find uf(sz);\n  int res = 0;\n  while(!edges.empty()){\n    edge &e = edges.back();\n    edges.pop_back();\n    if(!uf.unite(e.to,e.from)) continue;\n    res += e.wt;\n  }\n  return res;\n}\nsigned main(){\n  int v,e;\n  while(cin >> v >> e,v){\n    ve edges(e);\n    REP(i,e){\n      int nd1,nd2,wt;\n      cin >> nd1 >> nd2 >> wt;\n      edges[i]=(edge){nd1,wt,nd2};\n    }\n    cout << kruskal(v,edges) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\n\nclass UnionFind{\npublic:\n    UnionFind(int n){\n        REP(i, n){\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    int find(int x){\n        if(x == par[x])return x;\n        return par[x] = find(par[x]);\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){return;}\n\n        if(rank[x] > rank[y]){\n            par[y] = x;\n        }else{\n            par[x] = y;\n            if(rank[x] == rank[y]){rank[y]++;}\n        }\n    }\nprivate:\n    int rank[MAX_N], par[MAX_N];\n};\n\nstruct Edge{\n    int to, from, cost;\n};\n\nbool comp(const Edge& le, const Edge& re){\n    return le.cost < re.cost;\n}\n\nint N, M;\nstd::vector<Edge> E;\n\nint kruskal(){\n    std::sort(E.begin(), E.end(), comp);\n\n    int res = 0;\n    UnionFind uf(N);\n\n    REP(i, M){\n        Edge e = E[i];\n\n        if(!uf.same(e.to, e.from)){\n            uf.unite(e.to, e.from);\n            res += e.cost;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        E.clear();\n        \n        REP(i, M){\n            int to, from, cost;\n            std::cin >> to >> from >> cost;\n            E.push_back({to, from, cost});\n        }\n\n        std::cout << kruskal() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nset<int> si;\n\nint n, m;\nint a, b, cost;\nint d[110];\nbool used[110];\n\nstruct edge{\n\tint to, cost;\n\tedge(int _to, int _cost) :to(_to), cost(_cost){};\n};\n\nvector<edge> G[110];\n\nvoid prim(int s){\n\tfill(d, d + 110, INF);\n\tREP(i, n)used[i] = false;\n\td[s] = 0;\n\tpriority_queue< P,vector<P>,greater<P> > que;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> n >> m&&n + m){\n\t\tREP(i, m){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tG[a].push_back(edge(b, cost));\n\t\t\tG[b].push_back(edge(a, cost));\n\t\t}\n\t\tprim(0);\n\t\tint ans = 0;\n\t\tREP(i, n){\n\t\t\tans += d[i];\n\t\t}\n\t\tcout << ans << endl;\n\t\tREP(i, n)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <limits>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define all(v) begin(v), end(v)\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntemplate<class T> using vv=vector<vector< T > >;\n\nstruct union_find {\n    int n;\n    vi d;\n    union_find() {}\n    union_find(int n_): n(n_), d(n, -1) {}\n    int root(int v) {\n        if (d[v] < 0) {\n            return v;\n        }\n        return d[v] = root(d[v]);\n    }\n    int size(int v) {\n        return -d[root(v)];\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        if (size(x) < size(y)) {\n            swap(x, y);\n        }\n        d[x] += d[y];\n        d[y] = x;\n        return true;\n    }\n};\n\nint main() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if ( n == 0 ) { break; }\n        vvi edges(m);\n        rep (i, m) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            edges[i] = {cost, a, b};\n        }\n        sort(all(edges));\n\n        int ans = 0;\n        union_find uf(n);\n        rep (i, m) {\n            if ( uf.unite(edges[i][1], edges[i][2]) ) {\n                ans += edges[i][0];\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 10000000\nint cost[110][110];\nint mincost[110];\nbool used[110];\n\nint prim(int V) {\n\tfor (int i = 0; i < V; i++) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) {\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (n == 0 &&  m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 110; i++) {\n\t\t\tfor (int j = 0; j < 110; j++) {\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint a,b,c;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tcout << prim(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\n\nint Prim(const Graph& g,vector<Edge>& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tvi vis(g.size());\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(pq.size()){\n\t\tEdge cur=pq.top(); pq.pop();\n\t\tif(vis[cur.dst])\n\t\t\tcontinue;\n\t\tvis[cur.dst]=true;\n\t\tres+=cur.weight;\n\t\tif(cur.src!=-1)\n\t\t\ttree.push_back(cur);\n\t\tforeach(e,g[cur.dst])\n\t\t\tpq.push(*e);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint s,d,w; scanf(\"%d%d%d\",&s,&d,&w);\n\t\t\tg[s].push_back(Edge(s,d,w));\n\t\t\tg[d].push_back(Edge(d,s,w));\n\t\t}\n\t\t\n\t\tvector<Edge> tree;\n\t\tint res=Prim(g,tree);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cost;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cost < right.cost;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tif(rank[x] == rank[y]){\n\t\tpar[x] = y;\n\t\trank[y]++;\n\t}\n\t(rank[x] < rank[y]) ? par[x] = y : par[y] = x ;\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nedge Data[128];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cost);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<memory>\n#include<vector>\n#include<algorithm>\n\nclass UnionFind{\nprivate:\n\tint n;\n\tstd::unique_ptr<int[]> par, rank;\npublic:\n\tUnionFind(int n);\n\tint find(int x);\n\tvoid unite(int x, int y);\n\tbool same(int x, int y);\n};\n\nUnionFind::UnionFind(int _n)\n\t:n(_n)\n{\n\tthis->par.reset(new int[n]);\n\tthis->rank.reset(new int[n]);\n\tfor(int i=0;i<n;i++){\n\t\tthis->par[i] = i;\n\t\tthis->rank[i] = 0;\n\t}\n}\n\nint UnionFind::find(int x){\n\tif(x == this->par[x]){\n\t\treturn x;\n\t}\n\treturn this->par[x] = find(par[x]);\n}\n\nvoid UnionFind::unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y){//すでに同じ\n\t\treturn;\n\t}\n\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]){\n\t\t\trank[x]++;\n\t\t}\n\t}\n}\n\nbool UnionFind::same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nstruct Edge{\n\tint from, to, cost;\n};\n\nbool comp(const Edge& l_edge, const Edge& r_edge){\n\treturn l_edge.cost < r_edge.cost;\n}\n\nconst int MAX_N = 100, MAX_M = 100;\nconst int INF = 1 << 24;\n\nint kruskal(int V, std::vector<Edge> &ev){\n\t\tstd::sort(ev.begin(), ev.end(), comp);\n\t\tUnionFind uf(V);\n\t\tint res = 0, ev_size = ev.size();\n\t\tfor(int i=0;i<ev_size;i++){\n\t\t\tEdge e = ev[i];\n\t\t\tif(!uf.same(e.from, e.to)){\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tint cost[MAX_N][MAX_N];\n\twhile(std::cin >> n >> m, n){\n\t\tstd::vector<Edge> ev;\n\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tstd::fill(cost[i], cost[i]+MAX_N, INF);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a, b, c;\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tEdge e = {a, b, c};\n\t\t\tev.push_back(e);\n\t\t}\n\n\t\tstd::cout << kruskal(n, ev) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 101\n#define MAX_E 1001\n\nstruct Edge {\n  int u, v, cost;\n};\nint par[MAX_N], rank[MAX_N];\nEdge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find() {\n  for(int i=0; i<V; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint p_find(int x) {\n  if(par[x] == x) return x;\n  return par[x] = p_find(par[x]);\n}\n\nbool issame(int x, int y) {\n  return p_find(x) == p_find(y);\n}\n\nvoid unite(int x, int y) {\n  x = p_find(x);\n  y = p_find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) {\n      rank[x] ++;\n    }\n  }\n}\n\nbool comp(const Edge &e1, const Edge &e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es+E, comp);\n  init_union_find();\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    Edge e = es[i];\n    if(!issame(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> V >> E && V+E) {\n    for(int i=0; i<E; i++) {\n      cin >> es[i].u >> es[i].v >> es[i].cost;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint n,m,sum,r;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tif(P[b[bridge[i].second]] != P[a[bridge[i].second]]) {\n\t\t\t\tif(P[a[bridge[i].second]] == a[bridge[i].second]) {\n\t\t\t\t\tP[a[bridge[i].second]] = P[b[bridge[i].second]];\n\t\t\t\t\tr = a[bridge[i].second];\n\t\t\t\t} else {\n\t\t\t\t\tP[b[bridge[i].second]] = P[a[bridge[i].second]];\n\t\t\t\t\tr = b[bridge[i].second];\n\t\t\t\t}\n\t\t\t\tfor(int k=0; k<n; ++k) {\n\t\t\t\t\tif(P[k] == r) {\n\t\t\t\t\t\troot(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += bridge[i].first;\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint parent[10010];\nvoid init(int N){int i=0;for(;i<N;i++)parent[i]=i;}\nint root(int a){\n\tif(parent[a]==a)return a;\n\treturn parent[a]=root(parent[a]);\n}\nbool is_same_set(int a,int b){return root(a)==root(b);}\nvoid unite(int a,int b){parent[root(a)] = root(b);}\n\nint i, s, N, M, A[10010], B[10010], COST[10010];\npair<int,int> bridge[10010];\nint main(){\n\tfor(;cin>>N>>M,N;cout<<s<<endl){\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin>>A[i]>>B[i]>>COST[i];\n\t\t\tbridge[i].first = COST[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge, bridge+M);\n\t\tinit(N);\n\t\tfor(s=i=0;i<M;i++){\n\t\t\tint cost = bridge[i].first;\n\t\t\tint a = A[bridge[i].second];\n\t\t\tint b = B[bridge[i].second];\n\t\t\tif(is_same_set(a,b))continue;\n\t\t\tunite(a,b);\n\t\t\ts+=cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\n#define mp make_pair\n#define all(x) x.begin(),x.end()\nusing namespace std;\nint pt[123456], n, m, ans;\nvector<pair<int, pair<int, int>>>v;\nvoid setup() {\n\tans = 0; v.clear();\n\tfor0 (i, n)pt[i] = i;\n\treturn;\n}\nint root(int i) {\n\tif (pt[i] == i)return i;\n\telse return pt[i] = root(pt[i]);\n}\nvoid unite(int a, int b) {\n\tpt[root(b)] = root(a);\n\troot(b);\n\treturn;\n}\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tsetup();\n\t\tfor0(i, m) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tv.push_back(mp(c, mp(a, b)));\n\t\t}\n\t\tsort(all(v));\n\t\tfor0(i, m) {\n\t\t\tint a = v[i].second.first, b = v[i].second.second, c = v[i].first;\n\t\t\tif (root(a) != root(b)) {\n\t\t\t\tunite(a, b);\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint p[110];\ntypedef pair<int,pair<int,int> >P;\npriority_queue<P,vector<P>,greater<P> >Q;\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n+m){\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      Q.push(make_pair(c,make_pair(a,b)));\n    }\n    for(int i=0;i<n;i++)p[i]=i;\n    int ans=0;\n    while(!Q.empty()){\n      int a=Q.top().second.first,b=Q.top().second.second;\n      int cost=Q.top().first;Q.pop();\n      int x=a,y=b;\n      while(p[x]!=x)x=p[x];\n      while(a!=x)a=p[a],p[a]=x;\n      while(p[y]!=y)y=p[y];\n      while(b!=y)b=p[b],p[b]=y;\n      if(x!=y){\n\tans+=cost;\n\tp[x]=y;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n#define inf 1000000000\n\nusing namespace std;\n\n\nint n,m;\nint C[100][100];\n\nint prim(){\n\tint from[100],now[100],visit[100];\n\tint ans=0;\n\t\n\tfor(int i=0;i<100;i++){\n\t\tfrom[i]=visit[i]=0;\n\t\tnow[i]=inf;\n\t}\n\t\n\tnow[0]=0;\n\tfrom[0]=-1;\n\t\n\twhile(1){\n\t\tint mini=inf,mino;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(visit[i]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(mini>now[i]){\n\t\t\t\tmini=now[i];\n\t\t\t\tmino=i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mini==inf){\n\t\t\tbreak;\n\t\t}\n\t\tvisit[mino]=1;\n\t\t\n\t\tif(from[mino]!=-1)\n\t\tans+=C[mino][from[mino]];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(C[mino][i]==inf || visit[i]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(now[i]>C[mino][i]){\n\t\t\t\tnow[i]=C[mino][i];\n\t\t\t\tfrom[i]=mino;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tC[i][j]=inf;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tC[a][b]=C[b][a]=c;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconst int INF = 10000000;\n\nusing namespace std;\n/** Problem0180 : Stellar Performance of the Debunkey Family **/\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint V, E;\n\nint prim()\n{\n\tfor (int i=0; i<V; i++) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\t\n\twhile (1) {\n\t\tint v=-1;\n\t\tfor (int u=0; u<V; u++) {\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\t\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (int u=0; u<V; u++) {\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> V >> E, V!=0 && E!= 0) {\n\t\trep(i, 100) rep(j, 100) cost[i][j]=INF;\n\t\t\n\t\trep(i, E) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Node\n{\n\tpublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\n\tpublic:\n\tint p,c,dc;\n\n\tTrl(int p, int c):p(p),c(c){}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c>t.c;\n\t}\n};\n\n\nint main()\n{\n\tint n,m;\n\tint a,b,c;\n\twhile(cin >> n >> m , (n||m))\n\t{\n\t\tNode node[100];\n\t\twhile(m--)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tnode[a].to.push_back(b);\n\t\t\tnode[b].to.push_back(a);\n\t\t\tnode[a].c.push_back(c);\n\t\t\tnode[b].c.push_back(c);\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tbool visit[100] = {false};\n\t\tpriority_queue<Trl> q;\n\t\tq.push(Trl(0,0));\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tTrl t=q.top(); q.pop();\n\t\t\tif(visit[t.p]) continue;\n\n\t\t\tvisit[t.p] = true;\n\t\t\ttotal += t.c;\n\n\t\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next = node[t.p].to[i];\n\t\t\t\tint tc   = node[t.p].c[i];\n\t\t\t\tif(visit[next]) continue;\n\t\t\t\t\n\t\t\t\tq.push(Trl(next,tc));\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\twhile(1){\n\t\tq=0;\n\t\tscanf(\"%d %d\",&a,&s);\n\t\tif(a==0&&s==0) break;\n\t\tfor(i=0;i<a;i++){\n\t\t\tban[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\t\tfor(i=0;i<s;i++){\n\t\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\t\tfor(j=i+1;j<s;j++){\n\t\t\t\tif(g[i]>g[j]){\n\t\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<s;i++){\n\t\t\tz=d[i]; x=f[i];\n\t\t\twhile(ban[z]!=z) z=ban[z];\n\t\t\twhile(ban[x]!=x) x=ban[x];\n\t\t\tif(z!=x){\n\t\t\t\tq+=g[i];\n\t\t\t\tif(size[x]>size[z]) ban[z]=x;\n\t\t\t\telse if(size[x]<size[z]) ban[x]=z;\n\t\t\t\telse{\n\t\t\t\t\tban[x]=z;\n\t\t\t\t\tsize[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// =======================\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge1(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n}\n\n// ------ disjoint set ------ //\nstruct UnionFind {\n    vector<int> data;\n    int __size;\n    UnionFind(int size) : data(size, -1), __size(size) { }\n    bool unionSet(int x, int y) {\n        if ((x = root(x)) != (y = root(y))) {\n            if (data[y] < data[x]) swap(x, y);  // par -> child とは限らない\n            data[x] += data[y]; data[y] = x; __size--;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int size() { return __size; }\n    vector<int> subset_roots() {\n        vector<int> roots;\n        for (int i = 0; i < data.size(); i++) if (data[i] < 0) roots.push_back(i);\n        return roots;\n    }\n};\n\n// ------ minimumSpanningForest ------ //\npair<Weight, Edges> kruskal(priority_queue<Edge> &PQ, int n) {\n    UnionFind uf(n);\n    Weight total = 0;\n    Edges F;\n    while (F.size() < n-1 && !PQ.empty()) {\n        Edge e = PQ.top(); PQ.pop();\n        if (uf.unionSet(e.src, e.dst)) {\n            F.push_back(e);\n            total += e.weight;\n        }\n    }\n    return pair<Weight, Edges>(total, F);\n}\n// =======================\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        priority_queue<Edge> PQ;\n        for (int i = 0; i < m; i++) {\n            int a, b, cost; cin >> a >> b >> cost;\n            PQ.push(Edge{a, b, cost});\n        }\n        pair<Weight, Edges> res = kruskal(PQ, n);\n        cout << res.first << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvector<int>d(n,inf);\n\t\tvector<bool>used(n);\n\t\tvvi cost(n,vi(n));\n\t\trep(i,n)rep(j,n)cost[i][j]=inf;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\td[0]=0;\n\t\tint out=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(i,n)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tout+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<out<<endl;\n\t\t//int sum=0;\n\t\t//rep(i,n)cout<<i<<\" \"<<d[i]<<endl;//sum+=d[i];\n\t\t//cout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 100000;\nstruct Edge { int from, to, cost; };\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<Edge> G;\n        int a, b, cost;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> b >> cost;\n            G.push_back((Edge){ a, b, cost });\n            G.push_back((Edge){ b, a, cost });\n        }\n        int ret = 0;\n        bool used[100] = {};\n        used[0] = true;\n        while (1) {\n            int k, mn = INF;\n            for (int i=0; i<(int)G.size(); ++i) {\n                if (used[G[i].from] && ! used[G[i].to] && G[i].cost < mn) {\n                    mn = G[i].cost;\n                    k = i;\n                }\n            }\n            if (mn == INF) break;\n            used[G[k].to] = true;\n            ret += G[k].cost;\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nint main(){\n  int a[2];\n  while(std::cin >> a[0] >> a[1]){\n    int i,j;\n    int city[a[0]][a[0]];\n    int Tcity[a[0]];\n    int cost = 0;\n    for(i=0; i<a[0]; i++){\n      Tcity[i] = 0;\n      for(j=0; j<a[0]; j++){\n        city[i][j] = INT_MAX;\n      }\n    }\n    std::vector<std::vector<int> > v;\n    for(i=0; i<a[1]; i++){\n      std::vector<int> w;\n      int s,g,c;\n      std::cin >> s >> g >>c;\n      city[s][g] = c;\n      w.push_back(s);\n      w.push_back(g);\n      v.push_back(w);\n    }\n    Tcity[0] = 1;\n    while(1){\n      int min = INT_MAX;\n      int min_s,min_g;\n      for(i=0; i<a[0]; i++){\n        if(Tcity[i] == 1){\n          for(j=0; j<a[0]; j++){\n            if(city[i][j] < min){\n              min = city[i][j];\n              min_s = i;\n              min_g = j;\n            }\n          }\n        }\n      }\n      Tcity[min_s] = 1;\n      Tcity[min_g] = 1;\n      cost += min;\n      int loop = 1;\n      for(j=0; j<a[0]; j++){\n        if(Tcity[j] == 0) loop = 0;\n      }\n      if(loop){\n        std::cout << cost << std::endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1<<25\nint n,cost[100][100],mincost[100];\nbool used[100];\nint prim(){\n  r(i,n)mincost[i]=INF,used[i]=false;\n  mincost[0]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    r(u,n)if(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n    if(v==-1)break;\n    used[v]=1;\n    res+=mincost[v];\n    r(u,n)mincost[u]=min(mincost[u],cost[v][u]);\n  }\nreturn res;\n}\nint main(){\n  int m,q,w,e;\n  while(cin>>n>>m,n){\n  r(i,n)r(j,n)cost[i][j]=INF;\n  while(m--)cin>>q>>w>>e,cost[q][w]=e;\n  cout<<prim()<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nint N,M;\nconst int MAX_V = 10000;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\n\nll Prim(){\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  ll res =0;\n\n  while(1){\n    int v = -1;\n    for(ll u = 0; u < V; ++u){\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if( v == -1){\n      break;\n    }\n    used[v] = true;\n    res += mincost[v];\n    for(ll u = 0; u < V; ++u){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nll prim(){\n  ll res = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N >> M && N && M){\n    int a,b,c;\n    V = N;\n    cost = vector<vector<ll>>(V,vector<ll>(V,inf));\n    rep(i,M){\n      cin >> a >> b >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n//       cost[a][b] = c;\n//       cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint n,m,sum;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tif(P[b[bridge[i].second]] != P[a[bridge[i].second]]) {\n\t\t\t\t//if(P[a[bridge[i].second]] != b[bridge[i].second]) {\n\t\t\t\tP[b[bridge[i].second]] = a[bridge[i].second];\n\t\t\t\troot(b[bridge[i].second]);\n\t\t\t\tfor(int k=0; k<n; ++k) {\n\t\t\t\t\tif(P[k] == b[bridge[i].second]) {\n\t\t\t\t\t\troot(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += bridge[i].first;\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nvector<int> v, parent, depth;\n\nint find(int a){\n  if(parent[a] == a) return a;\n  else return parent[a] = find(parent[a]);\n}\n\nvoid merge(int a, int b){\n  int pa = find(a), pb = find(b);\n  if(pa == pb) return ;\n\n  if(depth[pa] > depth[pb]) swap(pa, pb);\n  if(depth[pa] == depth[pb]) ++depth[pa];\n  parent[pb] = pa;\n}\n\nbool same(int a, int b){\n  return find(a) == find(b);\n}\n\nvoid init_union_find(int V){\n  v = vector<int>(V);\n  parent = vector<int>(V);\n  depth = vector<int>(V, 1);\n  REP(i, V) parent[i] = i;\n}\n\nstruct edge {\n  int f, t, c;\n  bool operator < (const edge &e) const { return c < e.c; };\n};\n\nint kruskal(int V, int E, vector<edge> es){\n  sort(es.begin(), es.end());\n  init_union_find(V);\n  int min_cost = 0;\n  REP(i, E){\n    if(!same(es[i].f, es[i].t)){\n      min_cost += es[i].c;\n      merge(es[i].f, es[i].t);\n    }\n  }\n  return min_cost;\n}\n\nint main() {\n  int V, E;\n  while(cin >>V >>E && V){\n    vector<edge> es(E);\n    REP(i, E) cin >>es[i].f >>es[i].t >>es[i].c;\n    cout <<kruskal(V, E, es) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Bridge\n{\n\tint cost;\n\tint edge[ 2 ];\n};\n\nclass BridgeAsc\n{\npublic:\n\tbool operator()( const Bridge& a, const Bridge& b ) const\n\t{\n\t\tif( a.cost < b.cost ) return true;\n\t\treturn false;\n\t};\n};\n\nint main()\n{\n\tint n, m;\n\twhile( cin >> n >> m && ( n || m ) ){\n\t\tvector< Bridge > bridge;\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tBridge b;\n\t\t\tcin >> b.edge[ 0 ] >> b.edge[ 1 ] >> b.cost;\n\t\t\tbridge.push_back( b );\n\t\t}\n\t\tsort( bridge.begin(), bridge.end(), BridgeAsc() );\n\n\t\tint city[ 100 ] = {0};\n\t\tint id = 1;\n\t\tint cntBridge = 0;\n\t\tint index = 0;\n\t\tint ans = 0;\n\t\twhile( cntBridge < n - 1 ){\n\t\t\tBridge b = bridge[ index ];\n\t\t\tint con = 0;\n\t\t\tint x = b.edge[ 0 ];\n\t\t\tint y = b.edge[ 1 ];\n\t\t\tif( city[ x ] != 0 && city[ x ] == city[ y ] ){\n\t\t\t\t++index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( city[ x ] == 0 && city[ y ] == 0 ){\n\t\t\t\tcity[ x ] = city[ y ] = id++;\n\t\t\t}else if( city[ x ] == 0 ){\n\t\t\t\tcity[ x ] = city[ y ];\n\t\t\t}else if( city[ y ] == 0 ){\n\t\t\t\tcity[ y ] = city[ x ];\n\t\t\t}else{\n\t\t\t\tint tmp = city[ y ];\n\t\t\t\tfor( int i = 0; i < n; ++i ){\n\t\t\t\t\tif( city[ i ] == tmp ){\n\t\t\t\t\t\tcity[ i ] = city[ x ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += b.cost;\n\t\t\t++cntBridge;\n\t\t\t++index;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define INF 1000000\n#define MAX_N 100\nusing namespace std;\nint n,m;\nint cost[MAX_N][MAX_N];\nint mincost[MAX_N];\nbool used[MAX_N];\n\nvoid solve() {\n  for(int i=0;i<n;i++) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(true) {\n    int v = -1;\n    for(int i=0;i<n;i++) {\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n    }\n    if(v == -1) break;\n    res += mincost[v];\n    used[v] = true;\n\n    for(int i=0;i<n;i++) {\n      mincost[i] = min(mincost[i],cost[v][i]);\n    }\n  }\n  cout << res << endl;\n}\n\nint main() {\n  while(cin >> n >> m) {\n    if(n==0&&m==0) break;\n    for(int i=0;i<100;i++) {\n      for(int j=0;j<100;j++) {\n        cost[i][j] = INF;\n      }\n    }\n    for(int i=0;i<m;i++) {\n      int f,t,c;\n      cin >> f >> t >> c;\n      cost[f][t] = c;\n      cost[t][f] = c;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nint N,M;\nconst int MAX_V = 10000;\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\n\nll Prim(){\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  ll res =0;\n\n  while(1){\n    int v = -1;\n    for(ll u = 0; u < V; ++u){\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if( v == -1){\n      break;\n    }\n    used[v] = true;\n    res += mincost[v];\n    for(ll u = 0; u < V; ++u){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N >> M && N && M){\n    ll a,b,c;\n    V = N;\n    cost = vector<vector<ll>>(V,vector<ll>(V,inf));\n    rep(i,M){\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    cout << Prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_E 10000\n#define MAX_V 100\n\nint V,E;\nint par[MAX_V],rank[MAX_V];\nvoid init(){\n  for(int i = 0 ; i < V ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nstruct edge{\n  int u,v,cost;\n};\n\nbool comp(const edge &e1,const edge &e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[MAX_E];\n\nint kruskal(){\n  init();\n  sort(es , es + E,comp);\n\n  int res = 0;\n  for(int i = 0 ; i < E ; i++){\n    edge e = es[i];\n    if(!same(e.u , e.v)){\n      unite(e.u , e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int a,b,c;\n  while(scanf(\"%d %d\" ,&V ,&E) ,(V | E)){\n    for(int i = 0 ; i < E ; i++){\n      scanf(\"%d %d %d\" ,&a ,&b ,&c);\n      es[i] = (edge){a,b,c};\n    }\n    printf(\"%d\\n\" ,kruskal());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//都市の数\nint m;//橋の数\n/*クラスカル法*/\nconst int MAX_E = 110;\nconst int MAX_V = 110;\nint V,E;//頂点数、辺の数\nstruct edge{\n\tint u,v,cost;//頂点uからvへのcost\n\tedge(int _u,int _v,int _cost){u =_u;v = _v;cost =_cost;};\n};\nvector<edge> es;\n//union-find\nint parent[MAX_V];//parent[x]=xの時xが根である\nint rank[MAX_V];//木の高さ\nvoid init(int V){\n\tfor(int i= 0;i < V;i++){\n\t\tparent[i] = i;\n\t\trank[i] =0;\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x)\n\t\treturn x;\n\telse{\n\t\treturn find(parent[x]);\n\t}\n}\n\nvoid unit(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}\n\telse{\n\t\tparent[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost <e2.cost;\n}\n\nint kruskal(){\n\tsort(es.begin(),es.end(),comp);\n\tinit(V);\n\tint res = 0;\n\tfor(int i = 0;i < E;i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunit(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\twhile(cin>>V>>E,V||E){\n\t\tes.clear();\n\t\trep(i,E){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.push_back(edge(a,b,c));\n\t\t}\n\t\tcout <<kruskal()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+9;\nconst int MAX_V = 100;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint n, m;\n\nint prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u = 0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v]) )\n\t\t\t\tv = u;\n\t\t}\n\t\t\n\t\tif( v == -1 ) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u = 0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\tfor(int u = 0 ; u < n ; u++ ){\n\t\t\tfor(int v = 0 ; v < n ; v++ ){\n\t\t\t\tcost[u][v] = cost[v][u] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t}\n\t\tint ans = prim();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define INF 1 << 30\n#define MAX_N 100\n\nusing namespace std;\n\nint cost[MAX_N][MAX_N];\nint mincost[MAX_N];\nbool used[MAX_N];\nint n;\n\nint prim(){\n  rep(i, n){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true){\n    int v = -1;\n    rep(u, n)\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n\n    rep(u, n)\n      mincost[u] = min(mincost[u], cost[v][u]);\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, m){\n      int a, b, c;\n      scanf(\"%d%d%d\", &a, &b, &c);\n      cost[a][b] = cost[b][a] = c;\n    }\n    \n    printf(\"%d\\n\", prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct bridge{\n  int a;\n  int b;\n  int cost;\n  bool operator<(const bridge &another) const{\n    return cost<another.cost;\n  };\n};\n\nint main(void){\n  int n,m;\n  int a,b,cost;\n  int retval;\n  while(1){\n    cin>>n>>m;\n    retval=0;\n    if(n==0 and m==0)break;\n    vector<bridge> bridges;\n    for(int i=0;i<m;i++){\n      bridge bri;\n      cin>>a>>b>>cost;\n      bri.a=a;\n      bri.b=b;\n      bri.cost=cost;\n      bridges.push_back(bri);\n    }\n    sort(bridges.begin(),bridges.end());\n    int city[n];\n    for(int i=0;i<n;i++){\n      city[i]=i;\n    }\n    for(int i=0;i<m;i++){\n      bridge bri=bridges[i];\n      if(city[bri.a]==city[bri.b]){\n        continue;\n      }\n      else{\n        retval+=bri.cost;\n        int group=city[bri.b];\n        for(int j=0;j<n;j++){\n          if(city[j]==group){\n            city[j]=city[bri.a];\n          }\n        }\n      }\n    }\n    cout<<retval<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint par[104];\nint ran[105];\nvoid init(int n) {\n\tfor (int i = 0; i<n; i++) {\n\t\tpar[i] = i;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (ran[x]<ran[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nstruct edge { int s, t, cost; };\nbool comp(edge&e1, edge &e2) {\n\treturn e1.cost < e2.cost;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n != 0) {\n\t\tinit(n);\n\t\tedge b[10008];\n\t\tint x, y, z;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tb[i].s = x;\n\t\t\tb[i].t = y;\n\t\t\tb[i].cost = z;\n\t\t}\n\t\tint ans = 0;\n\t\tsort(b, b + m, comp);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tedge now = b[i];\n\t\t\tif (!same(now.s, now.t)) {\n\t\t\t\tunite(now.s, now.t);\n\t\t\t\tans += now.cost;\n\t\t\t}\n\t\t}cout << ans;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// uf\nnamespace uf\n{\n  const int Size = 102;\n  int par[Size];\n  int rank[Size];\n  \n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n    \n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  \n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n}; /* uf */ \n\n// mst\nstruct edge {\n  int u, v, cost;\n};\n\nbool comp(const edge& a, const edge& b) {\n  return a.cost < b.cost;\n}\n\nconst int MAX_E = 10002;\nedge es[MAX_E];\nint V, E;\n\nint kruskal() {\n  sort(es, es + E, comp);\n  uf::init(V);\n  int res = 0;\n  for (int i = 0; i < V; ++i) {\n    edge e = es[i];\n    if (!uf::same(e.u, e.v)) {\n      uf::unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint solve() {\n  int a, b, cost;\n  rep (i,E) {\n    cin >> a >> b >> cost;\n    es[i] = (edge){ a, b, cost };\n  }\n  return kruskal();\n}\n\nint main() {\n  while (cin >> V >> E, V) {\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nint map[101][100];\nint n,m;\n\nbool check(int x,vector<bool> &used){\n\n    used[x] = true;\n    bool flg = true;\n    for(int i=0;i<used.size();i++){\n\tif(!used[i]) flg = false;\n    }\n    if(flg) return true;\n\n    bool res = false;\n    for(int i=0;i<n;i++){\n\tif(map[x][i] > 0  && !used[i]){\n\t    res |= check(i,used);\n\t}\n    }\n\n    return res;\n\n}\n\nint main(){\n\n    while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    vector<int> a(m);\n    vector<int> b(m);\n    vector<int> cost(m);\n    vector< pair <  pair<int,int> , pair<int,int> > >  q(m);\n    long long int sum = 0;\n    for(int i=0;i<m;i++){\n\tcin >> a[i] >> b[i] >> cost[i];\n\tsum += cost[i];\n\tq[i] = pair< pair<int,int>, pair<int,int> >(pair<int,int>(cost[i],a[i]), pair<int,int>(b[i],i));\n\tmap[a[i]][b[i]] = cost[i];\n\tmap[b[i]][a[i]] = cost[i];\n    }\n    sort(q.rbegin(),q.rend());\n    for(int i=0;i<m;i++){\n\tint x = q[i].first.second ;\n\tint y = q[i].second.first ;\n\tint temp = map[x][y];\n\tmap[x][y]  = 0;\n\tmap[y][x]  = 0;\n\tvector<bool> used1(n,false);\n\tvector<bool> used2(n,false);\n\tif(check(x,used1) && check(y,used2)){\n\t    sum -= temp;\n\t}else{\n\t    map[x][y]  = temp;\n\t    map[y][x]  = temp;\n\t}\n    }\n    cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint par[104];\nint ran[105];\nvoid init(int n) {\n\tfor (int i = 0; i<n; i++) {\n\t\tpar[i] = i;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (ran[x]<ran[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nstruct edge { int s, t, cost; };\nbool comp(const edge& e1,const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n != 0) {\n\t\tinit(n);\n\t\tedge b[10008];\n\t\tint x, y, z;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tb[i].s = x;\n\t\t\tb[i].t = y;\n\t\t\tb[i].cost = z;\n\t\t}\n\t\tint ans = 0;\n\t\tsort(b, b + m, comp);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tedge now = b[i];\n\t\t\tif (!same(now.s, now.t)) {\n\t\t\t\tunite(now.s, now.t);\n\t\t\t\tans += now.cost;\n\t\t\t}\n\t\t}cout << ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n\n// int N, M, A[10010], B[10010], COST[10010];\n// pair<int, int> bridge[10010];\nint P[10010];//村のrootが保存\n\nvoid init(int N){\n  for(int i=0; i< N; ++i){\n    P[i]= i;\n  }\n}\n\nint root(int a){//aのroot(代表元)を決める\n  if(P[a]==a) return a;//aはroot\n  return (P[a] = root(P[a]));//aの親のrootを求め,aの親とする\n}\nbool is_same_set(int a, int b){\n  return root(a) == root(b);\n}\nvoid unite(int a, int b){\n   P[root(a)] = root(b);\n}\n\n\nint main(){\n  int N, M, A[10010], B[10010], COST[10010];\n  pair<int, int> bridge[10010];\n\n  //root決める\n  while(cin >> N >> M  && N>0){\n    int allcost = 0;\n    // int bridgenum = 0;\n    init(N);\n    for (int i = 0; i < M; ++i)\n    {\n      cin >> A[i] >> B[i] >> COST[i];\n      bridge[i].first = COST[i];\n      bridge[i].second = i ;\n    }\n    sort(bridge,bridge+M);\n    for (int i = 0; i < M; ++i)\n    {\n      int cost = bridge[i].first;\n      int a = A[bridge[i].second];\n      int b = B[bridge[i].second];\n\n      // if (bridgenum == M-1)\n      // {\n      //   unite(a,b);\n      //   // allcost += cost;\n      // }\n      if(is_same_set(a,b)){\n\n      }else{\n        unite(a,b);\n        allcost += cost;\n        // cout <<  allcost << endl;\n        // bridgenum += 1;\n      }\n      // 「a から b に cost の橋がかかっている」と表示\n    }\n    cout <<  allcost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int src,int dst,int weight):src(src),dst(dst),weight(weight){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint Prim(Graph& g,Edges& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tint size=g.size();\n\tvector<int> visited(size);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)\n\t\t\ttree.push_back(e);\n\t\tvisited[e.dst]=1;\n\t\tres+=e.weight;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i];\n\t\t\tif(!visited[cand.dst])\n\t\t\t\tpq.push(cand);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint a,b,cost; cin>>a>>b>>cost;\n\t\t\tg[a].push_back(Edge(a,b,cost));\n\t\t\tg[b].push_back(Edge(b,a,cost));\n\t\t}\n\t\t\n\t\tEdges t;\n\t\tint res=Prim(g,t);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, weight;\n};\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<vector<edge>> g(n);\n        for(int i=0; i<m; ++i) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            g[a].push_back((edge){b, cost});\n            g[b].push_back((edge){a, cost});\n        }\n\n        vector<int> d(n, INF);\n        vector<bool> used(n);\n        d[0] = 0;\n        int res = 0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(make_pair(0, 0));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(d[v] < p.first) {\n                continue;\n            }\n            used[v] = true;\n            res += d[v];\n            for(auto& e : g[v]) {\n                if(!used[e.to] && e.weight < d[e.to]) {\n                    d[e.to] = e.weight;\n                    que.push(make_pair(d[e.to], e.to));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 101\n#define INF (1<<21)\n\nint n,bri[MAX][MAX];\n\nvoid prim(){\n  bool visit[MAX];\n  int cost[MAX],d[MAX];\n\n  for(int i = 0 ; i < n ; i++){\n    visit[i] = false;\n    cost[i] = INF;\n  }\n\n  cost[0] = 0;\n  d[0] = -1;\n\n  while(true){\n    int u ,mincost = INF;\n    for(int i = 0 ; i < n ; i++){\n      if(!visit[i]&&cost[i] < mincost){\n\tmincost = cost[i];\n\tu = i;\n      }\n    }\n    if(mincost == INF) break;\n    visit[u] = true;\n\n    for(int j = 0 ; j < n ; j++){\n      if(visit[j] || bri[u][j] == INF) continue;\n      if(bri[u][j] < cost[j]){\n\tcost[j] = bri[u][j];\n\td[j] = u;\n      }\n    } \n  }\n\n  int sum = 0;\n  for(int i = 0 ; i < n ; i++){\n    if(d[i] == -1) continue;\n    sum += bri[i][d[i]];\n  }\n\n  cout << sum << endl;\n}\n\nint main(){\n  int m,a,b,c;\n\n  while(cin >> n >> m , n + m){\n    for(int i = 0 ; i < MAX ; i++)\n      for(int j = 0 ; j < MAX ; j++)\n\tbri[i][j] = INF;\n\n    for(int i = 0 ; i < m ; i++){\n\tcin >> a >> b >> c;\n\tbri[a][b] = bri[b][a] = c;\n    }\n\n    prim();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nclass S{\n\tpublic:\n\tint x,now,bef;\n\tS(int x,int now,int bef):x(x),now(now),bef(bef){}\n\tbool operator<(const S&a)const{\n\t\treturn now>a.now;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tint to[111][111]={0};\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t\n\t\t\tto[a][b]=c;\n\t\t\tto[b][a]=c;\n\t\t}\n\t\t\n\t\tpriority_queue<S> que;\n\t\tque.push(S(0,0,-1));\n\t\t\n\t\tint ans=0;\n\t\t\n\t\tint visit[111]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\t\n\t\t\tS u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.x]==1)continue;\n\t\t\tvisit[u.x]=1;\n\t\t\t\n\t\t\tif(u.bef!=-1){\n\t\t\t\tans += to[u.x][u.bef];\n\t\t\t}\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\tif(to[u.x][i]==0)continue;\n\t\t\t\tque.push( S(i ,to[u.x][i]+u.now ,u.x) );\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstruct Bridge\n{\n  int a, b, cost;\n};\n\nint n, m, ans, parent[10001];\nBridge bridge[10001];\n\nint bridge_comp(const void *a, const void *b)\n{\n  return ((Bridge *)a)->cost - ((Bridge *)b)->cost;\n}\n\nint root(int a)\n{\n  if (parent[a] == a) return a;\n  else return (parent[a] = root(parent[a]));\n}\n\nint main()\n{\n  while((cin >> n >> m), n && m)\n  {\n    for (int i = 0; i < n; i++)\n      parent[i] = i;\n    for (int i = 0; i < m; i++)\n      cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n    qsort(bridge, m, sizeof(Bridge), bridge_comp);\n    ans = 0;\n    for (int i = 0; i < m; i++)\n    {\n      if ((n = root(bridge[i].a)) != root(bridge[i].b))\n      {\n\tparent[root(bridge[i].b)] = n;\n\tans += bridge[i].cost;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nstruct edge\n{\n\tint from, to, cost;\n\n\tedge( int from, int to, int cost )\n\t:\tfrom( from ), to( to ), cost( cost )\n\t{}\n};\n\nint n, m;\nstd::vector<edge> es;\n\nint par[100], rank[100];\n\nvoid init()\n{\n\trep( i, n )\n\t\tpar[i] = i, rank[i] = 0;\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( x == par[x] )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] > rank[y] )\n\t\tpar[y] = x;\n\telse\n\t{\n\t\tpar[x] = y;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[y];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &n, &m ), n|m )\n\t{\n\t\tes.clear();\n\t\tinit();\n\t\trep( i, m )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d%d%d\", &a, &b, &c );\n\t\t\tes.push_back( edge( a, b, c ) );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), []( const edge& e1, const edge& e2 ){ return e1.cost < e2.cost; } );\n\n\t\tint ans = 0;\n\t\trep( i, es.size() )\n\t\t{\n\t\t\tedge& e = es[i];\n\t\t\tif( !same( e.from, e.to ) )\n\t\t\t{\n\t\t\t\tans += e.cost;\n\t\t\t\tunite( e.from, e.to );\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nstruct union_find {\n\tstd::vector<int> data;\n\npublic:\n\tunion_find(int n) : data(n, -1) {}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x == y) return false;\n\t\tif(data[x] > data[y]) std::swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn true;\n\t}\n\tint find(int k) {\n\t\tif(data[k] < 0) return k;\n\t\treturn data[k] = find(data[k]);\n\t}\n};\n\nint main() {\n\tusing P = std::pair<int, std::pair<int, int>>;\n\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint ans = 0;\n\t\tstd::vector<P> vec;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n\n\t\t\tvec.push_back({c, {a, b}});\n\t\t}\n\t\tsort(begin(vec), end(vec));\n\t\t\n\t\tunion_find uf(n);\n\t\tfor(auto v: vec) {\n\t\t\tif(uf.unite(v.second.first, v.second.second)) ans += v.first;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\n\nconst int INF = 100000000;\n\nstruct edge {\n    int to, cost;\n    bool operator<(const edge& r)const{\n        return cost>r.cost;\n    }\n};\n\n// state = edge\n// struct state {\n//     int from, d;\n// };\nvector<vector<edge> > G;\nint V;\n\nbool used[111];\nint prim(){\n    int sum=0;\n    int es=0;\n    memset(used,0,sizeof(used));\n    priority_queue<edge> q;\n    q.push({0,0});\n    while(es!=G.size()){\n        edge e=q.top(); q.pop();\n        es++;\n        used[e.to]=1;\n        int from=e.to;\n        //cout<<\" \"<<from<<endl;\n        sum+=e.cost;\n        FOR(i,0,G[from].size()){\n            if(!used[G[from][i].to])\n                q.push(G[from][i]);\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int m;\n    while(1){\n        cin>>V>>m;\n        if(!(m||V))break;\n        G=vector<vector<edge> >(V);\n        FOR(i,0,m){\n            int a,b,cost;cin>>a>>b>>cost;\n            G[a].push_back({b,cost});\n            G[b].push_back({a,cost});\n        }\n        cout<<prim()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n\nusing namespace std;\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; -i)\n#define INF (1 << 20)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint N, M;\nint cost[101][101];\nint mincost[101];\nbool used[101];\n\nint prim() {\n\n\trep(i, N) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile(true) {\n\t\tint v = -1;\n\t\trep(u, N) if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\trep(u, N) mincost[u] = min(mincost[u], cost[v][u]);\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, 101) rep(j, 101) cost[i][j] = INF;\n\t\trep(i, M) {\n\t\t\tint a, b, Cost;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &Cost);\n\t\t\tcost[a][b] = cost[b][a] = Cost;\n\t\t}\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 10000\n\nint par[MAX_N];\nint rank[MAX_N];\n\n#define MAX_E 100\nstruct edge { int u, v, cost; };\nedge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find(int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init_union_find(V);\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    edge e = es[i];\n    if(!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(cin >> V >> E && (V||E)) {\n    E *= 2;\n    for(int i=0; i<E; i+=2) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      es[i].u = a, es[i].v = b, es[i].cost = c;\n      es[i].u = b, es[i].v = a, es[i].cost = c;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF (1e9)\n#define cost first\n#define node second\nusing namespace std;\ntypedef pair <int, int> P;\nint n,m;\nvector<P> G[101];\n\nint prim(){\n  int res = 0;\n  bool visited[101]={};\n  int D[101];\n  for(int i=0;i<n;i++) D[i] = INF;\n  priority_queue <P, vector<P>, greater<P> > Q;\n  Q.push(P(0,0));\n  while(!Q.empty()){\n    P t = Q.top(); Q.pop();\n    if(visited[t.node]) continue;\n    visited[t.node] = true;\n    res += t.cost;\n    for(int i=0;i<G[t.node].size();i++){\n      int nnode = G[t.node][i].node;\n      int ncost = G[t.node][i].cost;\n      if(D[nnode] > ncost) Q.push(P(ncost,nnode)),D[nnode]=ncost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m ==0) break;\n    for(int i=0;i<m;i++) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      G[a].push_back((P){c,b});\n      G[b].push_back((P){c,a});\n    }\n    cout << prim()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Edge\n{\n  int to, cost;\n};\nbool operator<(const Edge& lht, const Edge& rht)\n{\n  return lht.cost > rht.cost;\n}\n\n#define MN 100\n\nint N, M;\nbool done[MN];\n\nint main()\n{\nloop:\n  fill(done, done + MN, false);\n  vector<Edge> edges[MN];\n  cin >> N >> M;\n  if(!N)\n    return 0;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, c;\n    cin >> a >> b >> c;\n    edges[a].push_back({b, c});\n    edges[b].push_back({a, c});\n  }\n\n  priority_queue<Edge> q;\n  q.push({0, 0});\n  int cost = 0;\n  while(!q.empty())\n  {\n    auto e = q.top(); q.pop();\n    if(done[e.to])\n      continue;\n    cost += e.cost;\n    done[e.to] = true;\n    for(auto ee: edges[e.to])\n      q.push(ee);\n  }\n  cout << cost << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\n\nconst int INF = 100000000;\n\nstruct edge {\n    int to, cost;\n    bool operator<(const edge& r)const{\n        return cost>r.cost;\n    }\n};\n\n// state = edge\n// struct state {\n//     int from, d;\n// };\nvector<vector<edge> > G;\nint V;\n\nbool used[111];\nint prim(){\n    int sum=0;\n    int es=0;\n    memset(used,0,sizeof(used));\n    priority_queue<edge> q;\n    q.push({0,0});\n    while(es!=G.size()){\n        edge e=q.top(); q.pop();\n        if(used[e.to])continue;\n        es++;\n        used[e.to]=1;\n        int from=e.to;\n        //cout<<\" \"<<from<<endl;\n        sum+=e.cost;\n        FOR(i,0,G[from].size()){\n            if(!used[G[from][i].to])\n            q.push(G[from][i]);\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int m;\n    while(1){\n        cin>>V>>m;\n        if(!(m||V))break;\n        G=vector<vector<edge> >(V);\n        FOR(i,0,m){\n            int a,b,cost;cin>>a>>b>>cost;\n            G[a].push_back({b,cost});\n            G[b].push_back({a,cost});\n        }\n        cout<<prim()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n\n#define mp make_pair\n#define pb push_back\n#define REP(i,a,n) for(int i = a;i < (n);i++)\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define all(s) s.begin(), s.end()\n#define rall(s) s.rbegin(), s.rend()\n#define range(x,min,max) ((min) <= (x) && (x) <= (max))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VII;\ntypedef pair<int,int> PII;\n\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nvector<Edge> es;\nVI parent;\nVI rank;\n\nvoid init(int n){\n\trep(i,n){\n\t\tparent.pb(i);\n\t\trank.pb(0);\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x){\n\t\treturn x;\n\t}\n\treturn parent[x] = find(parent[x]);\n}\n\nbool unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn false;\n\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}else{\n\t\tparent[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n\treturn true;\n}\t\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\n\twhile(1){\n\t\tint n, m;\n\t\tint ans = 0;\n\n\t\tcin >> n >> m;\n\n\t\tif(n == 0 && m == 0) break;\n\n\t\trep(i,m){\n\t\t\tEdge e;\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\t\tes.pb(e);\n\t\t}\n\n\t\tinit(n);\n\t\tsort(all(es), comp);\n\t\t\n\t\trep(i,es.size()){\n\t\t\tEdge e = es[i];\n\t\t\tif(!unite(e.from, e.to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += e.cost;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t\tparent.clear();\n\t\trank.clear();\n\t\tes.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;cin>>n>>m,n;cout<<s<<endl){\n\t\tfor(i=0;i<m;i++)cin>>a[i]>>b[i]>>node[i].first,node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<iostream>\n\nusing namespace std;\n\nstruct edge{int u,v,cost;};\n\nint par[101],rank[101];\nedge es[200];\nint V,E;\n\nvoid init_union_find(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x] < rank[y])par[x]=y;\n  else par[y]=x,rank[x]+=(rank[x]==rank[y]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nbool comp(const edge& e1,const edge& e2){return e1.cost < e2.cost;}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v))unite(e.u,e.v),res+=e.cost;\n  }\n  return res;\n}\n\nint main(void){\n  int a,b,c;\n\n  while(cin >> V >> E && V){\n    for(int i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a,es[i].v=b,es[i].cost=c;\n    }\n    cout << kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N) : par(N){\n        for(int i = 0; i < N; i++){\n            par[i] = -1;\n        }\n    }\n    int root(int x){\n        if(par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    void unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        else{\n            if(par[rx] > par[ry]) swap(rx, ry);\n            par[rx] += par[ry];\n            par[ry] = rx;\n       }\n    }\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n    void check(){\n        for(auto x : par){\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint n, m;\nvector<pair<int, P>> G; // {cost, {vertex_1, vertex_2}}\n\n\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    while(cin >> n >> m){\n        if(n == 0 and m == 0) break;\n    \n        G.resize(m);\n\n        for(int i = 0; i < m; i++){\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            G[i] = {cost, {a, b}};\n        }\n\n        sort(G.begin(), G.end());\n\n        UnionFind uf(n);\n\n        int ans = 0;\n        for(int i = 0; i < m; i++){\n            pair<int, P> A = G[i];\n            int c = A.first;\n            int u = A.second.first;\n            int v = A.second.second;\n            if(uf.root(u) == uf.root(v)) continue;\n\n            ans += c;\n            uf.unite(u, v);\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define C first\n#define S second.first\n#define Z second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 100;\n\nint n;\nbool ok[N][N];\nint c[N][N];\n\nbool check();\n\nint main(void){\n    for(int m, res; cin >> n >> m, n; cout << res << endl){\n        res = 0;\n        rep(i, n) rep(j, n) ok[i][j] = false, c[i][j] = 0;\n\n        vector< pair<int, pii> > in;\n        while(m--){\n            int a, b, cost; cin >> a >> b >> cost;\n\n            ok[a][b] = ok[b][a] = true;\n            c[a][b] = c[b][a] = cost;\n            in.pb(mp(cost, mp(a, b)));\n        }\n        sort(ALL(in), greater< pair<int, pii> >());\n\n        rep(i, in.size()){\n            int a = in[i].S, b = in[i].Z;\n            ok[a][b] = false;\n            ok[b][a] = false;\n\n            if(!check()){\n                ok[a][b] = true;\n                ok[b][a] = true;\n            }\n        }\n\n        rep(i, n) for(int j = i + 1; j < n; j++) if(ok[i][j]) res += c[i][j];\n    }\n\n    return 0;\n}\n\nbool check(){\n    vector<bool> used(n);\n    \n    queue<int> q;\n    q.push(0);\n\n    while(!q.empty()){\n        int cur = q.front(); q.pop();\n        if(used[cur]) continue;\n        used[cur] = true;\n\n        rep(next, n) if(ok[cur][next]) q.push(next);\n    }\n\n    return !count(ALL(used), false);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_INT 10000\n#define PII pair<int, int>\n#define VPII vector<PII >\n\nint solve(int n, const vector<VPII >& adjacent) {\n  vector<bool> used(n, false);\n  int result = 0;\n  priority_queue<PII, VPII, greater<PII > > q;\n  for (auto v : adjacent[0]) q.push(v);\n  used[0] = true;\n  while(q.size() > 0) {\n    PII current = q.top(); q.pop();\n    if (!used[current.second]) {\n      used[current.second] = true;\n      result += current.first;\n      for (auto v : adjacent[current.second]) q.push(v);\n    }\n  }\n\n  return result;\n}\n\nint main() {\n  int n, m;\n  while (cin >> n >> m, n != 0) {\n    vector<VPII > adjacent(n);\n    for (int i = 0; i < m; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      adjacent[a].push_back(make_pair(c, b));\n      adjacent[b].push_back(make_pair(c, a));\n    }\n    cout << solve(n, adjacent) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V >> E&&V) {\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost(100,vector<int>(100,0));\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\nprim.connect(b,a);\n      cost[a][b] = cost_t;\n      cost[b][a] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       auto top = que.top();\n       que.pop();\n       if(frag[top.second] == false){\n\t cost_sum += top.first;\n\t frag[top.second] = true;\n\t current = top.second;\n\t break;\n\t }\n     }  \n  }\n  return cost_sum;\n}\n       \n       \n       \n     \n     \n     \n     "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nstruct unionfind {\n    int par[100], rank[100];\n    unionfind(int n) {\n        for (int i=0; i<n; i++) {\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x) {\n        if (par[x]==x) {\n            return x;\n        } else {\n            return par[x]=find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x=find(x);\n        y=find(y);\n        if (x==y) return;\n        if (rank[x]<rank[y]) {\n            par[x]=y;\n        } else {\n            par[y]=x;\n            if (rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y) {\n        return find(x)==find(y);\n    }\n};\nstruct edge {\n    int u, v, cost;\n    edge(){}\n    edge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n};\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost<e2.cost;\n}\nint main() {\n    int n, m;\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        unionfind uf(n);\n        edge bridge[m];\n        for (int i=0; i<m; i++) {\n            int a, b, cost; scanf(\"%d%d%d\",&a,&b,&cost);\n            bridge[i]=edge(a,b,cost);\n        }\n        sort(bridge,bridge+m,comp);\n        int res=0;\n        for (int i=0; i<m; i++) {\n            edge e=bridge[i];\n            if (!uf.same(e.u,e.v)) {\n                uf.unite(e.u,e.v);\n                res+=e.cost;\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\nusing namespace std;\n\nint n,m,sum;\nint P[110],a[10010],b[10010],cost[10010];\npair<int,int> bridge[10010];\nvoid init(int N) {\n\tfor(int i=0; i<N; ++i) P[i] = i;\n}\nint root(int a) {\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nint main() {\n\tcin >> n >> m;\n\twhile(n!=0 && m!=0) {\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> cost[i];\n\t\t\tbridge[i].first = cost[i];\n\t\t\tbridge[i].second = i;\n\t\t}\n\t\tsort(bridge,bridge+m);\n\t\tinit(n);\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tif(P[b[bridge[i].second]] == b[bridge[i].second]) {\n\t\t\t\tif(P[a[bridge[i].second]] != b[bridge[i].second]) {\n\t\t\t\t\tP[b[bridge[i].second]] = a[bridge[i].second];\n\t\t\t\t\troot(b[bridge[i].second]);\n\t\t\t\t\tsum += bridge[i].first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tcin >> n >> m;\n\t\tsum =0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n  int from, to, cost;\n  Edge() : from(0), to(0), cost(0) { }\n  Edge(int from, int to, int cost) : from(from), to(to), cost(cost) { }\n};\n\nstruct UnionFind {\n  vector<int> data;\n\n  UnionFind(int n) : data(n, -1) { }\n\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n\n  int root(int i) {\n    return data[i] < 0 ? i : data[i] = root(data[i]);\n  }\n\n  void join(int i, int j) {\n    data[root(i)] += data[root(j)];\n    data[root(j)] = root(i);\n  }\n};\n\nint main() {\n  for(int n, m; cin >> n >> m && n; ) {\n    vector<Edge> edges(m);\n\n    for(int i = 0; i < m; i++) {\n      cin >> edges[i].from >> edges[i].to >> edges[i].cost;\n    }\n\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n      return a.cost < b.cost;\n    });\n\n    int cost = 0;\n    UnionFind uf(n);\n\n    for(auto it = edges.begin(); it != edges.end(); it++) {\n      if(!uf.same(it->from, it->to)) {\n        uf.join(it->from, it->to);\n        cost += it->cost;\n      }\n    }\n\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint cost[100][100];\nint mincost[100];\nbool used[100];\nconst int INF = 1e6;\nint main(void){\n  int n,m;\n  while(cin>>n>>m){\n    if(n==0) break;\n    REP(i,n){\n      REP(j,n)cost[i][j] = INF;\n      mincost[i]=INF;\n      used[i] = false;\n    }\n    REP(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      cost[a][b] = cost[b][a] = c;\n    }\n    mincost[0] = 0;\n    int ans = 0;\n    while(true){\n      int v = -1;\n      REP(u,n)\n        if(!used[u]&&(v==-1||mincost[u]<mincost[v]))\n          v = u;\n      if(v==-1) break;\n      ans += mincost[v];\n      used[v] = true;\n      REP(u,n)mincost[u] = min(mincost[u],cost[v][u]);\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#define INF 9999999\nusing namespace std;\nint n,m,t[100][100],a,b,c,d,flg[10],sum,mini,miniNo;\nvoid prim(){\n\tint visited[100],mini,miniNo;\n\tint cost[100],pi[100];\n\tfor(int i=0;i<n;i++){\n\t\tvisited[i]=0;\n\t\tcost[i]=INF;\n\t}\n\tcost[0]=0;\n\tpi[0]=-1;\n\twhile(1){\n\t\tmini=INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mini>cost[i]&&visited[i]==0){\n\t\t\t\tminiNo=i;\n\t\t\t\tmini=cost[i];\n\t\t\t}\n\t\t}\n\t\tif(mini==INF)break;\n\t\tvisited[miniNo]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(t[miniNo][i]!=INF&&visited[i]==0){\n\t\t\t\tif(t[miniNo][i]<cost[i]){\n\t\t\t\t\tcost[i]=t[miniNo][i];\n\t\t\t\t\tpi[i]=miniNo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint total=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(pi[i]==-1)continue;\n\t\ttotal+=t[i][pi[i]];\n\t}\n\tcout<<total<<endl;\n}\nint main(){\n\twhile(1){\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tt[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\tt[a][b]=t[b][a]=c;\n\t\t}\n\t\tprim();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n\n  bool merge(int x, int y){\n    int root_x = find(x);\n    int root_y = find(y);\n    if(root_x != root_y){\n      if(data[root_y] < data[root_x]){\n\tswap(root_x, root_y);\n      }\n      data[root_x] += data[root_y];\n      data[root_y] = root_x;\n    }\n    \n    return root_x != root_y;\n  }\n  \n  int find(int x){\n    if(data[x] < 0){\n      return x;\n    }else{\n      return find(data[x]);\n    }\n  }\n\n  bool is_same(int x, int y){\n    return find(x) == find(y);\n  }\n  \n  int size(int x){\n    return -find(x);\n  }\n};\n\ntypedef pair<long long int, pair<long long int, long long int> > Edge;\n\ninline Edge make_edge(int a, int b, int c){\n  return make_pair(c, make_pair(a, b));\n}\n\nint main(int argc, char* argv[]){\n\n  while( true ) {\n\n    long long int n, m;\n    cin >> n >> m;\n    if ( n == 0 ) break;\n\n    priority_queue< Edge, vector< Edge >, greater< Edge > > q;\n\n    for ( long long int i = 0; i < m; i++ ) {\n\n      long long int a, b, c;\n      cin >> a >> b >> c;\n      q.push(make_edge(a, b, c));\n    }\n\n    \n    UnionFind uf(n);\n    long long int costs = 0;\n    while(!q.empty()){\n      Edge edge = q.top(); q.pop();\n      const int from = edge.second.first;\n      const int to = edge.second.second;\n\n      if(!uf.is_same(from, to)){\n\tuf.merge(from, to);\n\t//\tcout << edge.first << endl;\n\tcosts += edge.first;\n      }\n    }\n \n    cout << costs << endl;\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint edge_dist;\n\tint cost;\n\tEdge() : edge_dist(0), cost(0) {}\n\tEdge(int _dist, int _cost) : edge_dist(_dist), cost(_cost) {}\n};\n\nbool operator==(const Edge &a, const Edge &b){\n\treturn (a.cost == b.cost);\n}\nbool operator!=(const Edge &a, const Edge &b){\n\treturn !(a == b);\n}\nbool operator<(const Edge &a, const Edge &b){\n\treturn (a.cost < b.cost);\n}\nbool operator>=(const Edge &a, const Edge &b){\n\treturn !(a < b);\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn (a.cost > b.cost);\n}\nbool operator<=(const Edge &a, const Edge &b){\n\treturn !(a > b);\n}\nclass Prim{\n\tvector< int > vlist; //??¢?´¢?????? -> 1 / else -> 0\n\tvector< vector< Edge > > edge;\n\tvector< Edge > tree;\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > priq;\n\t\npublic:\n\t\n\tvoid Init(int size){\n\t\tvlist.clear();\n\t\tedge.clear();\n\t\t\n\t\tvlist.resize(size);\n\t\tedge.resize(size);\n\t}\n\t\n\tvoid Put(int s, int t, int cost){\n\t\tedge[s].push_back(Edge(t, cost));\n\t}\n\t\n\tint Run(){\n\t\tint sum_cost = 0;\n\t\t\n\t\tvlist[0] = 1;\n\t\tfor(vector< Edge >::iterator it = edge[0].begin(); it != edge[0].end(); ++it){\n\t\t\tpriq.push(*it);\n\t\t}\n\t\t\n\t\twhile(!priq.empty()){\n\t\t\t\n\t\t\tEdge ed = priq.top();\n\t\t\tpriq.pop();\n\t\t\t\n\t\t\tif(vlist[ed.edge_dist])continue;\n\t\t\t\n\t\t\ttree.push_back(ed);\n\t\t\tvlist[ed.edge_dist] = 1;\n\t\t\tsum_cost += ed.cost;\n\t\t\t\n\t\t\tfor(vector< Edge >::iterator it = edge[ed.edge_dist].begin(); it != edge[ed.edge_dist].end(); ++it){\n\t\t\t\tif(vlist[(*it).edge_dist] == 0){\n\t\t\t\t\tpriq.push(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum_cost;\n\t}\n};\n\nint main(){\n\t\n\tint v, e, s, t, w;\n\tPrim prim;\n\t\n\twhile(cin >> v >> e, v || e){\n\t\t\n\t\tprim.Init(v);\n\t\t\n\t\tfor(int i = 0; i < e; ++i){\n\t\t\tcin >> s >> t >> w;\n\t\t\t\n\t\t\tprim.Put(s, t, w);\n\t\t\tprim.Put(t, s, w);\n\t\t}\n\t\t\n\t\tcout << prim.Run() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nint n, m;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) : from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) {\n\t\treturn (cost_ == rhs.cost_) ? from_ < rhs.from_ : cost_ < rhs.cost_;\n\t}\n};\n\nstd::vector<edge> edges;\n\nclass Union_find {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion_find() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n >> m;\n\t\tif (n + m == 0)\n\t\t\tbreak;\n\t\tedges.clear();\n\t\tUnion_find uni;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\tedges.emplace_back(a, b, c);\n\t\t}\n\t\tstd::sort(edges.begin(), edges.end());\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        vector<vector<P> > V(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            V[a].push_back(P(c, b));\n            V[b].push_back(P(c, a));\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que;\n        vector<int> used(N);\n        que.push(P(0, 0));\n\n        int sum = 0;\n        while (que.size()) {\n            P p = que.top(); que.pop();\n            int now = p.second;\n            int cost = p.first;\n\n            if (used[now]) continue;\n            used[now] = true;\n            sum += cost;\n\n            for (auto i : V[now]) {\n                que.push(i);\n            }\n        }\n\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 100;\nusing namespace std;\nbool visited[MAXN];\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\npriority_queue<pair<int,edge>,vector<P>,greater<P> > que;\nint main(){\n  int n,m;\n  while(cin >> n >> m && n + m != 0){\n\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n    UnionFind u(m);\n    int cost = 0;\n    for (int i = 0; i < n-1; ++i){\n      edge top = que.top().second;\n      int topCost = que.top().first;\n      que.pop();\n      if(u.unionSet(top.from,top.to)){\n\tcost += topCost;\n      }\n    }\n    cout << cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n// g++ -std=c++14 main.cpp\n//\n\n//#include \"main.hpp\"\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\n\nint par[100010];\nint rnk[100010];\nll sze[100010];\n\n// 初期化\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        rnk[i] = 0;\n        sze[i] = 1;\n    }\n}\n\n// 親探し\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\n// 併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rnk[x] < rnk[y]) {\n        sze[y] = sze[x] + sze[y];\n        par[x] = y;\n    }\n    else {\n        sze[x] = sze[x] + sze[y];\n        par[y] = x;\n        if (rnk[x] == rnk[y]) rnk[x]++;\n    }\n    \n}\n\n// 同じ木にあるか\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main(void){\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == m && m == 0) return 0;\n        \n        vector<tuple<int, int, int> > br;\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            br.emplace_back(c, a, b);\n        }\n        \n        sort(br.begin(), br.end());\n        \n        init(n);\n        int ans = 0;\n        for (int i = 0; i < br.size(); i++) {\n            if (!same(get<1>(br[i]), get<2>(br[i]))) {\n                unite(get<1>(br[i]), get<2>(br[i]));\n                ans += get<0>(br[i]);\n            }\n        }\n        \n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\n\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\n/***** Kruskal *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_E = 10000;\nedge es[MAX_E];\nint V, E;\n\nint kruskal(void){\n\tsort(es, es + E, comp);\n\tunion_find_init(V);\n\n\tint res = 0;\n\tfor(int i=0; i<E; ++i){\n\t\tedge e = es[i];\n\t\tif(!same(e.from, e.to)){\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/***** /Kruskal *****/\n\nint main(void) {\n\twhile (cin >> V >> E, V) {\n\t\tE *= 2;\n\t\tfor (int i = 0; i < E / 2; i++) {\n\t\t\tint a, b, cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tes[i].from = a;\n\t\t\tes[i].to = b;\n\t\t\tes[i].cost = cost;\n\t\t\tes[i].from = b;\n\t\t\tes[i].to = a;\n\t\t\tes[i].cost = cost;\n\t\t}\n\n\t\tint res = kruskal();\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = init; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nclass UnionFind\n{\n  private:\n    vector<int> par;\n    vector<int> sizes;\n\n  public:\n    UnionFind(int N) : par(N), sizes(N, 1)\n    {\n        rep(i, N) par[i] = i;\n    }\n\n    int find(int x)\n    {\n        if (x == par[x])\n            return x;\n\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y)\n            return;\n\n        if (sizes[x] < sizes[y])\n            swap(x, y);\n\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    bool same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[find(x)];\n    }\n};\n\nint main()\n{\n    int N, M;\n    while (cin >> N >> M, N)\n    {\n        vector<T> edges;\n\n        rep(i, M)\n        {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n\n            edges.push_back(make_tuple(cost, a, b));\n        }\n\n        sort(edges.begin(), edges.end());\n\n        UnionFind uf(N);\n\n        int ans = 0;\n\n        for(auto e : edges)\n        {\n            int to, from, cost;\n            tie(cost, to, from) = e;\n\n            if(uf.same(from, to)) continue;\n\n            uf.unite(from, to);\n\n            ans += cost;\n\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define FOR(i,a,b)   for(ll i = (a); i < (b); i++ )\n#define REP(i, n)    FOR(i,0,n)\ntypedef pair< int, int >   cp2;\ntypedef pair< int, cp2 >   cp3;\n#define fi first\n#define se second\n#define sec  se.fi\n#define thr  se.se\nconst ll mod = 1000000007;\n//              123456789\n\n\n \n\n///////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////\n\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n\n\n\npriority_queue< cp3, vector<cp3>, greater<cp3> >p;\ncp3 now;\n\nint g[112];\n\nint find( int key ){\n\t//cout<<key<<\" \"<<g[key]<<endl;\n\tif( g[key] < 0 ) return key;\n\treturn g[key] = find( g[key] );\n}\n\nvoid unite( int x, int y ){\n\tx = find( x );\n\ty = find( y );\n\tif( x == y ) return;\n\t\n\tif( g[x] < g[y] ) swap( x, y );\n\tif( g[x] == g[y] ) g[y]--;//??±??????x???????????????\n\t//g[y] += g[x];\t\t //????????°???x??????????°???????\n\tg[x] = y;\n}\n\nint a, b;\nint c;\nint N;\nint M;\nint ans;\n\nint main(){\n\t\n\twhile( cin>>N>>M, N && M){\n\t\t\n\t\tans = 0;\n\t\tfill( g, g+112, -1 );\n\t\n\t\tREP( i, M ){\n\t\t\tscanf(\"%d %d %d\",&a, &b, &c);\n\t\t\tp.push( cp3( c, cp2(a, b) ) );\t\n\t\t}\n\t\n\t\twhile( !p.empty() ){\n\t\t\tnow = p.top();\n\t\t\tp.pop();\n\t\t\t\n\t\t\tif( find(now.sec) != find(now.thr) ){\n\t\t\t\tunite( now.sec, now.thr );\n\t\t\t\tans += now.fi;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n && !m)\n\t\t\tbreak;\n\t\tint bridge[100][100];\n\t\tint a,b,cost;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tbridge[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tbridge[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tif(bridge[a][b] > cost){\n\t\t\t\tbridge[a][b] = cost;\n\t\t\t\tbridge[b][a] = cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツフツδ債イツド\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint dis = bridge[i][k]+bridge[k][j];\n\t\t\t\t\tif(dis < bridge[i][j]){\n\t\t\t\t\t\tbridge[i][j] = dis;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint min[10000];\n\t\tint pos = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i<j){\n\t\t\t\t\tmin[pos++] = bridge[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(min,min+pos-1);\n\t\tint sum = 0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tsum+=min[i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100)\n\nstruct edge { int from, to, cost; };\n\nbool comp ( const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint par[MAX_N];\t\t/// 親\nint rank[MAX_N];\t/// 木の深さ\n\n/// n要素で初期化\nvoid init ( int n )\n{\n\tfor (int i = 0; i < n; ++i) {\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n/// 木の根を求める\nint find ( int x ) \n{\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n/// xとyの属する集合を合併\nvoid unite ( int x, int y )\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif (x == y) { return; }\n\n\tif (rank[x] < rank[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y]) { ++rank[x]; }\n\t}\n}\n\n/// xとyが同じ集合に属するか否か\nbool same ( int x, int y )\n{\n\treturn find(x) == find(y);\n}\n\nusing namespace std;\n\nint main ( void )\n{\n\tint n, m;\n\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tedge e;\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\t\tes.push_back(e);\n\t\t}\n\n\t\tsort(es.begin(), es.end(), comp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.from, e.to)) {\n\t\t\t\tunite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing Weight = int;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge() {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) { return e.weight < f.weight; }\npair<Weight, Edges> kruskal(int N, Edges es) {\n\tUnionFind uf(N);\n\tWeight total = 0; Edges T;\n\tfor(auto &e : es) if(!uf.same(e.src, e.dst)) {\n\t\tT.push_back(e); total += e.weight; uf.unite(e.src, e.dst);\n\t}\n\treturn make_pair(total, T);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n + m) {\n\t\tEdges es;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tes.push_back({ a, b, c });\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tauto res = kruskal(n, es);\n\t\tcout << res.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m && n + m != 0){\n    priority_queue<pair<int,edge>,vector<P>,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n\n    UnionFind u(m);\n    int cost = 0;\n    for (int i = 0; i < n-1; ++i){\n      edge top = que.top().second;\n      int topCost = que.top().first;\n      que.pop();\n      if(u.unionSet(top.from,top.to)){\n\tcost += topCost;\n      }\n    }\n    cout << cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Node\n{\n\tpublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\n\tpublic:\n\tint p,c,dc;\n\n\tTrl(int p, int c, int dc):p(p),c(c),dc(dc){}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c>t.c;\n\t}\n};\n\n\nint main()\n{\n\tint n,m;\n\tint a,b,c;\n\twhile(cin >> n >> m , (n||m))\n\t{\n\t\tNode node[100];\n\t\twhile(m--)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tnode[a].to.push_back(b);\n\t\t\tnode[b].to.push_back(a);\n\t\t\tnode[a].c.push_back(c);\n\t\t\tnode[b].c.push_back(c);\n\t\t}\n\t\t\n\t\tint total = 0;\n\t\tbool visit[100] = {false};\n\t\tpriority_queue<Trl> q;\n\t\tq.push(Trl(0,0,0));\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tTrl t=q.top(); q.pop();\n\t\t\tif(visit[t.p]) continue;\n\n\t\t\tvisit[t.p] = true;\n\t\t\ttotal += t.dc;\n\n\t\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next = node[t.p].to[i];\n\t\t\t\tint tc   = node[t.p].c[i];\n\t\t\t\tif(visit[next]) continue;\n\t\t\t\t\n\t\t\t\tq.push(Trl(next,tc,tc));\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconstexpr int INF = 1e8;\nconstexpr int N_MAX = 100;\nconstexpr int M_MAX = 500;\nbool visited[N_MAX] = {}; \nint n, m;\n\nstruct Edge {\n    int to_;\n    int cost_;\n    Edge(int to, int cost) : to_(to), cost_(cost) {}\n};\n\nauto clear(vector<vector<Edge>> &g) -> void {\n    for (int i = 0; i < N_MAX; ++i) {\n        visited[i] = false;\n    }\n\n    for(auto& e : g) {\n        g.clear();\n    }\n}\n\nauto prim(vector<vector<Edge>> &g) -> int {\n    auto comp = [](auto lhs, auto rhs){return lhs.first > rhs.first;};\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> que(comp);\n    int ans = 0;\n    que.push(make_pair(0, 0));\n    while (!que.empty()) {\n        auto p = que.top();\n        que.pop();\n        if (visited[p.second]) continue;\n        visited[p.second] = true;\n        auto edges = g[p.second];\n        ans += p.first;\n        for(const auto &e : edges) {\n            if (!visited[e.to_]) {\n                que.push(make_pair(e.cost_, e.to_));\n            }\n        }\n    }\n    return ans;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    while (cin>>n>>m, n || m) {\n        vector<vector<Edge>> g(n);\n        clear(g);\n        for (int i = 0; i < m; ++i) {\n            int a, b, cost;\n            cin>>a>>b>>cost;\n            g[a].push_back(Edge(b, cost));\n            g[b].push_back(Edge(a, cost));\n        }\n        cout<<prim(g)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Graph {\nprivate:\n  const static int INF = 1000000; \n  std::vector<std::vector<int> > edge_;\n  unsigned int size_;\npublic:\n  Graph(unsigned int size);\n  Graph& connect(int from, int to, int weight);\n  std::vector<int> neighbours(int node) const;\n  unsigned int size() const;\n};\n\nconst int Graph::INF;\n\nGraph::Graph(unsigned int size) {\n  size_ = size;\n  edge_ = std::vector<std::vector<int> > (size_, std::vector<int>(size_, INF));\n}\n\nGraph& Graph::connect(int from, int to, int weight = 1) {\n  edge_[from][to] = weight;\n  return *this;\n}\n\nstd::vector<int> Graph::neighbours(int node) const {\n  std::vector<int> neighbours;\n  for (int i = 0; i < static_cast<int>(size_); ++i)\n    if (edge_[node][i] < INF) neighbours.push_back(i);\n\n  return neighbours;\n}\n\nunsigned int Graph::size() const {\n  return size_;\n}\n\n\nGraph creat_graph(int n, int m);\nint search_prim(Graph prim, int n);\n\nvector<int> ans;\nvector<vector<int>> cost;\n\nint main(){\n  int n,m;\n \n  \n  while(cin >> n >> m, n){     \n    Graph prim = creat_graph(n,m);   /*creat graph*/\n    ans.push_back(search_prim(prim,n));   /*make answer*/\n  }\n  \n  for(int i: ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n\n\n Graph creat_graph(int n,int m){\n    Graph prim(n);\n    int a,b,cost_t;\n\n    for(int i=0; i<m; i++){\n      cin >> a >> b >> cost_t;\n      prim.connect(a,b);\n      cost[a][b] = cost_t;\n      cost[a][b] = cost_t;\n    }\n    return prim;\n  }\n    \nint search_prim(Graph prim, int n){\n  int current,cost_sum;\n  typedef pair<int, int> PII;\n  vector<bool> frag(n,false);\n  priority_queue < PII, vector < pair <int, int> >, greater < pair <int, int> > > que;\n  /*cost,next_node*/\n  \n  cost_sum = 0;\n  current = 0;\n  frag[0] = true;\n  for(int k=0; k<n-1; ++k){\n     vector<int> near = prim.neighbours(current);\n\n     for(int j:near){\n       que.push(PII(cost[current][j],j));\n     }\n\n     while(1){\n       if(frag[que.top().second] == false){\n\t cost_sum += que.top().first;\n\t frag[que.top().second] = true;\n\t current = que.top().second;\n\t break;\n\t }\n     }\n     que.pop();\n  }\n  return cost_sum;\n}\n       \n       \n       \n     "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct UF {\n  vector<int> p;\n  UF(int n) : p(n,-1) {}\n  int rt(int x) { return p[x]<0 ? x : p[x]=rt(p[x]); }\n  bool cat(int x, int y) {\n    x=rt(x); y=rt(y);\n    if(x==y) return false;\n    if(p[x]<p[y]) swap(x,y);\n    p[y]+=p[x];\n    p[x]=y;\n    return true;\n  }\n};\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    int n,m; scanf(\"%d%d\", &n, &m);\n    if(n==0) break;\n    vector<pair<int,pair<int,int> > > edges(m);\n    for(int i = 0; i < m; i++) {\n      int a,b,c; scanf(\"%d%d%d\", &a, &b, &c);\n      edges[i] = make_pair(c,make_pair(a,b));\n    }\n    sort(edges.begin(), edges.end());\n    UF uf(n);\n    long long cost_sum = 0;\n    for(int i = 0; i < m; i++) {\n      if(uf.cat(edges[i].second.first, edges[i].second.second)) {\n        cost_sum += edges[i].first;\n      }\n    }\n    printf(\"%lld\\n\", cost_sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n\n#define MAXV 100\n#define INF 100000000\n\nint cost[MAXV][MAXV];\nint mincost[MAXV];\nbool used[MAXV];\nint V;\n\nint prim(){\n\tfor(int i=0;i<V;++i){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n\t\t}\n\n\t\tif(v==-1) break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\n\t\tfor(int u=0;u<V;u++){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n     \n\tint m;\n\tint a,b,cot;\n\n\twhile(1){\n\t\t cin>>V>>m;\n\t\t if(V==0&&m==0) break;\n\t\n\t\t  for(int i=0;i<V;i++){\n\t\t\t   for(int j=0;j<V;j++){\n\t\t\t\t   cost[i][j]=INF;\n\t\t\t   }\n\t\t   }\n\n\t\t   for(int i=0;i<m;i++){\n\t\t\t   cin>>a>>b>>cot;\n\t\t\t   cost[a][b]=cot;\n\t\t\t   cost[b][a]=cot;\n\t\t   }\n\n\t\t   cout<<prim()<<endl;\n\t  }\n\n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\n#define NONE 0\n\nint prim(int n, vector< vector<int> >v)\n{\n  set<int>selected;\n  set<int>::iterator it;\n  int mincost,mini;\n  int i;\n  int ans=0;\n\n  selected.insert(0);\n\n  while(selected.size()!=n){\n    mincost=INT_MAX;\n    mini=NONE;\n\n    for(it=selected.begin();it!=selected.end();it++){\n      for(i=0;i<n;i++){\n\tif(selected.find(i)!=selected.end())continue;\n\tif(v[*it][i]==NONE)continue;\n\tif(v[*it][i]>=mincost)continue;\n\tmincost=v[*it][i];\n\tmini=i;\n      }\n    }\n\n    if(mini==NONE)break;\n    selected.insert(mini);\n    ans+=mincost;\n  }\n\n  return ans;\n}\n\nint main()\n{\n  int n,m,a,b,cost;\n  int i;\n  while(cin>>n>>m,n|m){\n    vector< vector<int> >v(n,vector<int>(n,NONE));\n    for(i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      v[a][b]=v[b][a]=cost;\n    }\n    cout<<prim(n,v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint par[128];\nint rank[128];\nstruct edge{\n\tint from,to,cst;\n};\nbool cmp(const edge& left, const edge& right){\n\treturn left.cst < right.cst;\n}\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return ;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\nedge Data[128];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\trep(i,m){\n\t\t\tscanf(\"%d%d%d\",&Data[i].from,&Data[i].to,&Data[i].cst);\n\t\t}\n\t\tsort(Data,Data+m,cmp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\trep(i,m){\n\t\t\tedge next = Data[i];\n\t\t\tif(!same(next.from, next.to)){\n\t\t\t\tunite(next.from,next.to);\n\t\t\t\tans += next.cst;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nvector<int> city(200,-1);\nint getId(int i){\n\tif(i==city[i]) return i;\n\telse return getId(city[i]);\n}\nint main(){\n\tfor(;;){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n+m==0) break;\n\t\tpriority_queue< pair< int, pair<int,int> >, vector< pair< int, pair<int,int> > >, greater< pair< int, pair<int,int> > > > bridge;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcity[i]=i;\n\t\t}\n\t\tfor(int x,y,c;m--;){\n\t\t\tcin>>x>>y>>c;\n\t\t\tbridge.push(make_pair(c, make_pair(x,y)));\n\t\t}\n\t\tint total=0;\n\t\tfor(;bridge.size();){\n\t\t\tint cost = bridge.top().first;\n\t\t\tpair<int,int> br = bridge.top().second;\n\t\t\tbridge.pop();\n\t\t\tif(getId(br.first) != getId(br.second)){\n\t\t\t\tcity[getId(br.first)] = getId(br.second);\n\t\t\t\ttotal += cost;\n\t\t\t}\n\t\t}\n\t\tcout<<total<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n//disjoint-set\nint parent[100];\n\nvoid init(int n){\n  for(int i=0; i<n; i++) parent[i]=i;\n}\n\nint root(int a){\n  if (parent[a] == a) return a;\n  return (parent[a] = root(parent[a]));\n}\n\nbool same_set_p(int a,int b){\n  return root(a) == root(b);\n}\n\nvoid unite(int a,int b){\n  parent[root(a)] = root(b);\n}\n\n//graph\nclass Edge{\npublic:\n  int cost,a,b;\n  Edge(int c=0,int d=0,int e=0):cost(c),a(d),b(e){}\n  bool operator< (const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n//main\nint n,m;\nEdge graph[10000];\n\nint main(){\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(int i=0; i<m; i++){\n      int a,b,cost;\n      scanf(\"%d %d %d\",&a,&b,&cost);\n      graph[i] = Edge(cost,a,b);\n    }\n\n    sort(graph,graph+m);\n\n    int answer=0;\n    init(n);\n\n    for(int i=0; i<m; i++){\n      Edge e = graph[i];\n      if(!same_set_p(e.a,e.b)){\n\tanswer += e.cost;\n\tunite(e.a,e.b);\n      }\n    }\n\n    printf(\"%d\\n\",answer);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tvector<int> ary;\n\tvector<int> rank;\n\npublic:\n\tUnionFind( int n ) : ary( n ), rank( n, 0 )\n\t{\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tary[i] = i;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( ary[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ary[x] = find( ary[x] );\n\t\t}\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tvoid unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tary[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tary[y] = x;\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nstruct Edge\n{\n\tint from, to, cost;\n\n\tEdge()\n\t{\n\t\treturn;\n\t}\n\n\tEdge( int f, int t, int c ) : from( f ), to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const Edge &a ) const\n\t{\n\t\treturn cost < a.cost;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Edge > E( m );\n\n\t\tEACH( e, E )\n\t\t{\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\t}\n\n\t\tsort( ALL( E ) );\n\n\t\tint res = 0;\n\t\tUnionFind uf( n );\n\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tauto &e = E[i];\n\n\t\t\tif ( uf.same( e.from, e.to ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuf.unite( e.from, e.to );\n\n\t\t\tres += e.cost;\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector< set< pair<int, int> > > cost(100,set< pair<int,int> >());\n\nint prim()\n{\n\tint res=0;\n\tset<int> v;\n\tv.insert(0);\n\twhile(v.size()<n)\n\t{\n\t\tpair<int, int> mini(100000007, -1);\n\t\tfor(set<int>::iterator it=v.begin();it!=v.end();it++)\n\t\t{\n\t\t\tfor(set<  pair<int, int> >::iterator it2=cost[*it].begin();it2!=cost[*it].end();it2++)\n\t\t\t\tif(v.find((*it2).second)==v.end())\n\t\t\t\t{\n\t\t\t\t\tif(mini.first>(*it2).first)\n\t\t\t\t\t\tmini=(*it2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tv.insert(mini.second);\n\t\tres+=mini.first;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a].insert(pair<int, int>(c, b));\n\t\t\tcost[b].insert(pair<int, int>(c, a));\n\t\t}\n\t\tcout << prim() << endl;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tcost[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\nusing namespace std;\n#define INF 1000000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=100;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(int V){\n    for(int i=0; i<V; ++i){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    int res=0;\n\n    while(true){\n        int v=-1;\n        for(int u=0; u<V; ++u){\n            if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n        }\n        if(v==-1) break;\n        used[v]=true;\n        res+=mincost[v];\n        for(int u=0; u<V; ++u){\n            mincost[u]=min(mincost[u],cost[v][u]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0&&m==0) break;\n        for(int i=0;i<n;++i)for(int j=0;j<n;++j) cost[i][j]=INF;\n        for(int i=0; i<m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            cost[a][b]=cost[b][a]=c;\n        }\n        cout << prim(n) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint N, M , A[10010], B[10010], COST[10010];\nint P[10010];\nint Rank[10010];\npair<int, int> bridge[10010];\n\nvoid init(int N){\n\tfor(int i = 0; i < N; ++i){\n\t\tP[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint root(int a){\n\tif(P[a] == a) return a;\n\treturn (P[a] = root(P[a]));\n}\n\nbool IsSameSet(int a, int b){\n\treturn root(a) == root(b);\n}\n\nvoid unite(int a, int b){\n\tP[root(a)] = root(b);\n}\n\nvoid link(int a, int b){\n\tif(Rank[a] > Rank[b]){\n\t\tP[b] = a;\n\t} else {\n\t\tP[a] = b;\n\t\tif(Rank[a] == Rank[b]) Rank[a]++;\n\t}\n}\n\nint main(){\n\tint a,b;\n\twhile(cin >> N >> M, N > 0 && M > 0){\n\t\tinit(N);\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin >> A[i] >> B[i] >> COST[i];\n\t\t\tbridge[i].first = COST[i];\n\t\t\tbridge[i].second = i;\n\t\t}\t\t\n\t\tsort(bridge, bridge + M);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < M; ++i){\n\t\t\tint a = A[bridge[i].second];\n\t\t\tint b = B[bridge[i].second];\n\t\t\tif(IsSameSet(a,b)) continue;\n\t\t\tunite(a,b);\n\t\t\tsum += bridge[i].first;\n\t\t}\n\t\tcout << sum << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main(){\n\tint m,n,a,b,cost;\n\twhile(cin >> m >> n) {\n\t\tif(m==0 && n==0) break;\n\t\tint adj[110][110] = {};\n\t\trep(i,m) {\n\t\t\trep(j,m) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tadj[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\trep(i,n) {\n\t\t\tcin >> a >> b >> cost;\n\t\t\tadj[a][b] = cost;\n\t\t\tadj[b][a] = cost;\n\t\t}\n\t\tbool used[100] = {};\n\t\tint cost[100];\n\t\tfill(cost,cost+100,INT_MAX);\n\t\tcost[0] = 0;\n\t\tint ret = 0;\n\t\twhile(1) {\n\t\t\tint v = -1;\n\t\t\trep(i,m) {\n\t\t\t\tif(!used[i] && (v == -1 || cost[v] > cost[i])) {\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tret += cost[v];\n\t\t\trep(i,m) {\n\t\t\t\tcost[i] = min(cost[i], adj[v][i]);\n\t\t\t}\n\t\t}\n\t\tcout <<  ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAX 5010\nusing namespace std;\n\nclass edge{\npublic:\n    int start;\n    int goal;\n    int cost;\n    edge(){\n        start = 0;\n        goal = 0;\n        cost = MAX;\n    }\n};\nbool operator< (const edge &edge1, const edge &edge2){\n    return edge1.cost < edge2.cost;\n}\nbool operator> (const edge &edge1, const edge &edge2){\n    return edge1.cost > edge2.cost;\n}\n\nint P[101];\nvoid init(int N){\n    for(int i=0;i<=N;i++)\n        P[i] = i;\n}\nint root(int a){\n    if(P[a]==a)\n        return a;\n    return(P[a] = root(P[a]));\n}\nbool is_same_set(int a, int b){\n    return root(a) == root(b);\n}\nvoid unit(int a, int b){\n    P[root(a)] = root(b);\n}\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n!=0){\n        init(n);\n        int total = 0;\n        vector<edge> v;\n        for(int i=0;i<m;i++){\n            edge tmp;\n            cin >> tmp.start >> tmp.goal >> tmp.cost;\n            v.push_back(tmp);\n        }\n        priority_queue<edge, vector<edge>, greater<edge> > p(v.begin(),v.end());\n        for(int i=0;i<m;i++){\n            edge tmp = p.top();\n            p.pop();\n            if(!is_same_set(tmp.start,tmp.goal)){\n                total += tmp.cost;\n                unit(tmp.start,tmp.goal);\n            }\n        }\n        cout << total << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORR(i,a,b) for(int i=(a);i>(b);i--)\n#define REP(i,n)  FOR(i,0,n)\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//debug\n//-------------------------------------------\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define VISITED 1\n#define NOT_VISITED 0\n#define INF 1<<21\n\n//typedef\n//-------------------------------------------\ntypedef long long ll;\nint g[101][101];\nint visited[101];\nint d[101];\nint n, m;\n\nint prim() {\n    d[0] = 0;\n\n    while(true) {\n        int min = INF;\n        int u = -1;\n        REP(i, n) {\n            if (visited[i] != VISITED && d[i] < min) {\n                min = d[i];\n                u = i;\n            }\n        }\n        if (u < 0) break;\n\n        visited[u] = VISITED;\n\n        REP(v, n) {\n            if (visited[v] != VISITED && g[u][v] != 0) {\n                if (g[u][v] < d[v]) {\n                    d[v] = g[u][v];\n                    // visited[v] = VISITED;\n                }\n            }\n        }\n    }\n    int sum = 0;\n    REP(i, n) sum += d[i];\n    return sum;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true) {\n        cin >> n >> m;\n        if (!n && !m) break;\n        REP(i, n) {\n            visited[i] = NOT_VISITED;\n            d[i] = INF;\n        }\n        REP(i, m) {\n            int s, d, c;\n            cin >> s >> d >> c;\n            g[s][d] = c;\n            g[d][s] = c;\n        }\n        cout << prim() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000\n#define MAX 101\n\nusing namespace std;\nint cost[MAX][MAX];\nint mincost[MAX];\nbool used[MAX];\nint V;\nint prim(){\n  for(int i = 0 ; i < V ; ++i ){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(true){\n    int v = -1;\n    for(int u = 0 ; u < V ; ++u ){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n    }\n    if(v == -1)break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0 ; u < V ; u++ ){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\nint main(){\n  int m;\n  while( cin >> V >> m ,V+m){\n  for(int i = 0 ; i < V ; i++ ){\n    for(int j = 0 ; j < V ; j++ ){\n      cost[i][j] = INF;\n    }\n  }\n  for(int i = 0 ; i < m ; i++ ){\n    int a,b,c;\n    cin >> a >> b >> c;\n    cost[a][b] = cost[b][a] = c;\n  }\n  cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstruct data{\n    int a, b, cost;\n};\n\nbool cmp(data d1, data d2){\n    return d1.cost < d2.cost;\n}\n\nstruct UF{\n    vector<int> par;\n    vector<int> sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        rep(i, 0, n) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nsigned main(){\n    int n, m;\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        vector<data> d(m);\n        rep(i, 0, m){\n            cin >> d[i].a >> d[i].b >> d[i].cost;\n        }\n        sort(all(d), cmp);\n        UF uf;\n        uf.init(n);\n        int ans = 0;\n        rep(i, 0, m){\n            int u = d[i].a, v = d[i].b;\n            if(!uf.same(u, v)){\n                uf.unite(u, v);\n                ans += d[i].cost;\n            }\n        }\n        cout << ans << endl;\n    }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define  MAX 101\n\n\nstruct Dis\n{\n    int pa[MAX];\n    int used[MAX];\n    int n;\n    Dis(int n):n(n)\n    {\n        for(int i=0;i<n;i++)\n        {\n            pa[i]=i;\n            used[i]=0;\n        }\n    }\n    void use(int i)\n    {\n        used[i]=1;\n    }\n    int root(int a)\n    {\n        if(pa[a]==a)\n            return a;\n        return pa[a]=root(pa[a]);\n    }\n    bool is_same_set(int a,int b)\n    {\n        return root(a)==root(b);\n    }\n    void unite(int n,int m)\n    {\n        use(n);\n        use(m);\n        pa[root(n)]=root(m);\n    }\n    bool is_connected()\n    {\n        int rt=-1;\n        for(int i=0;i<n;i++)\n        {\n            if(rt>=0 &&used[i] && rt!=root(i))\n                return false;\n            if(used[i])\n                rt=root(i);\n        }\n        return rt!=-1;\n    }\n};\n\nint br[6000][3];\n\nint getMin(int m)\n{\n    int tmp=-1;\n    for(int i=0;i<m;i++)\n    {\n        if(br[i][2]!=-1)\n        {\n            if(tmp==-1 || br[tmp][2]>=br[i][2])\n            {\n                tmp=i;\n            }\n        }\n    }\n    if(tmp!=-1)\n    {\n        return tmp;\n    }\n}\n\nint main(void)\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)==2 && n && m)\n    {\n        Dis dis(n);\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",br[i],br[i]+1,br[i]+2);\n        }\n        int nc=0;\n        int cost=0;\n        while(nc<n)\n        {\n            int min=getMin();\n            int a=br[min][0];\n            int b=br[min][1];\n            if(!dis.is_same_set(a,b))\n            {\n                dis.unite(a,b);\n                nc++;\n                cost+=br[min][2];\n                br[min][2]=-1;\n            }\n        }\n        printf(\"%d\\n\",cost);\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#define MAX_V 1000\n#define INF 1<<29\n#define cl(a,b) for(int i=0;i<a;i++)for(int j=0;j<b;j++)cost[i][j] = INF;\n#define de(a)  for(int i=0;i<a;i++){cout << mincost[i] << \" \"; if(i == a-1){cout << endl;}}\n#define de2(a,b) for(int I=0;I<a;I++){for(int j=0;j<b;j++){cout << cost[I][j] << \" \";}cout << endl;}cout << endl;\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nbool connect[10000];\n\nint prime()\n{\n  for(int i=0;i<V;++i)\n    {\n      mincost[i]=INF;\n      used[i]=false;\n    }\n  mincost[0] = 0;\n  int res = 0;\n  while(true)\n    {\n      int v = -1; \n      for(int u = 0; u<V ; u++ )\n\t{\n\t  if(connect[u] && !used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t    {\n\t      v = u;\n\t    }\n\t}\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n      for(int u = 0; u < V; u++)\n\t{\n\t  mincost[u] = min(mincost[u],cost[v][u]);\t  \n\t}\n    }\n  return res;\n}\n\nint main()\n{\n  int n,m,a,b;\n  while(true)\n    {\n      cin >> n >> m;\n      if(n == 0 && m == 0)break;\n      cl(n,n);\n      memset(connect,false,sizeof(connect));\n      V = n; // VÍ¸_\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> a >> b;\n\t  cin >> cost[a][b];\n\t  cost[b][a] = cost[a][b];\n\t  connect[a] = true;\n\t  connect[b] = true;\n\t}\n      cout << prime() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\nusing namespace std;\nusing LL = long long;\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nconst double PI = acos(-1);\n\nint V;\nint E;\nstruct edge { int from, to, cost; };\n\ntypedef pair<int, int> PP;\n\nvector<edge> e;\n\nint Par[100000];\nint Rank[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> V >> E&&V&&E) {\n\t\te.erase(e.begin(), e.end());\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// ????????????????????£?¨?\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    // ???????????±????????????????????£??\\??????????????????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d %d %d\", &a, &b, &d);\n      adjlist[a].push_back(make_pair(d, b));\n      adjlist[b].push_back(make_pair(d, a));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = kruskal(n, adjlist);\n    cout << length << endl;\n  }\n\n  return 0;\n}\n\n// UnionFind??¨ ??????????????????\n\nclass UnionFindTree{\nprivate:\n  int m_size, unite_count;\n  vector<int> parent;\n  vector<int> rank;\n  int find(int a);\npublic:\n  void init(int size);\n  void unite(int a, int b);\n  bool same(int a, int b);\n  bool isConnected(void);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  m_size = size;\n  unite_count = 0;\n  parent.clear();\n  rank.clear();\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n  }\n  return;\n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  unite_count++;\n  if(rank[x] < rank[y]){ parent[x] = y; }\n  else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// UF??¨??§?????????????????????????????¨???????????????????????????\nbool UnionFindTree::isConnected(void){\n  return unite_count == m_size - 1;\n}\n\n// ??????????????????\n// v: ????????°, adjlist: ??£??\\?????????(first: ???????????????, second: ?????????)\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist){\n  int length = 0; // ??¨????????????\n\n  // ?????????????????????\n  vector<pair<int, pair<int, int> > > edge; // first: ???????????????, second: ???????????????\n  for(int i = 0; i < v; i++)\n    for(int j = 0; j < adjlist[i].size(); j++)\n      edge.push_back(make_pair(adjlist[i][j].first, make_pair(i, adjlist[i][j].second)));\n  sort(edge.begin(), edge.end());\n\n  // UF??¨?????£?¨???¨?????????\n  UnionFindTree uf;\n  uf.init(v);\n\n  // ???????????????????????????????????????????????????????????£?????????????????§?????????\n  for(int i = 0; i < edge.size() && !uf.isConnected(); i++){\n    // i??????????°???????????????????\n    int cost = edge[i].first;\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.same(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    uf.unite(a, b);\n    length += cost;\n  }\n\n  // ?????????: ??¨????????????\n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,a) REP(i,0,a)\nusing namespace std;\n\nint par[101]; // parent\nint ranks[101]; // depth of tree\n\nvoid init(int n) {\n    rep(i, n) {\n        par[i] = i;\n        ranks[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    }\n    else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (ranks[x] < ranks[y]) {\n        par[x] = y;\n    }\n    else {\n        par[y] = x;\n        if (ranks[x] == ranks[y]) ranks[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct edge {int u; int v; int cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\n// Entry point\nint main(void){\n    while (1) {\n        int N,M;\n        cin >> N >> M;\n        if (N == 0) break;\n        \n        edge es[M];\n        rep(i,M) cin >> es[i].u >> es[i].v >> es[i].cost;\n        sort(es, es+M, comp);\n        \n        init(N);\n        int ans = 0;\n        rep(i,M) {\n            edge e = es[i];\n            if (!same(e.u, e.v)) {\n                unite(e.u, e.v);\n                ans += e.cost;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 1000000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=100;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(int V){\n\tfor(int i=0; i<V; ++i){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\t\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int u=0; u<V; ++u){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n\t\t}\n\t\tif(v==-1) break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int u=0; u<V; ++u){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=0;i<n;++i)for(int j=0;j<n;++j) cost[i][j]=INF;\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tcout << prim(n) << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n//disjoint-set\nint parent[100];\n\nvoid init(int n){\n  for(int i=0; i<n; i++) parent[i]=i;\n}\n\nint root(int a){\n  if (parent[a] == a) return a;\n  return (parent[a] = root(parent[a]));\n}\n\nbool same_set_p(int a,int b){\n  return root(a) == root(b);\n}\n\nvoid unite(int a,int b){\n  parent[root(a)] = root(b);\n}\n\n//graph\nclass Edge{\npublic:\n  int cost,a,b;\n  Edge(int c=0,int d=0,int e=0):cost(c),a(d),b(e){}\n  bool operator< (const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n//main\nint n,m;\nEdge graph[100];\n\nint main(){\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(int i=0; i<m; i++){\n      int a,b,cost;\n      scanf(\"%d %d %d\",&a,&b,&cost);\n      graph[i] = Edge(cost,a,b);\n    }\n\n    sort(graph,graph+m);\n\n    int answer=0;\n    init(n);\n\n    for(int i=0; i<m; i++){\n      Edge e = graph[i];\n      if(!same_set_p(e.a,e.b)){\n\tanswer += e.cost;\n\tunite(e.a,e.b);\n      }\n    }\n\n    printf(\"%d\\n\",answer);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      int edge[n][n];\n      memset(edge,-1,sizeof(edge));\n      for(int i=0;i<m;i++)\n\t{\n\t  int a,b,cost;\n\t  cin>>a>>b>>cost;\n\t  edge[a][b]=cost;\n\t  edge[b][a]=cost;\n\t}\n      bool closed[n];\n      int cnt=n-1;\n      int ans=0;\n      memset(closed,false,sizeof(closed));\n      closed[0]=true;\n      priority_queue<pair<int,int>, vector<pair<int,int> > ,greater<pair<int,int> > > qu;\n      for(int i=0;i<n;i++)\n\t{\n\t  if(edge[0][i]!=-1)\n\t    qu.push(make_pair(i,edge[0][i]));\n\t}\n      while(true)\n\t{\n\t  int pos=qu.top().first;\n\t  int cost=qu.top().second;\n\t  qu.pop();\n\t  if(closed[pos])\n\t    continue;\n\t  closed[pos]=true;\n\t  ans+=cost;\n\t  cnt--;\n\t  if(cnt<=0)\n\t    break;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(!closed[i]&&edge[pos][i]!=-1)\n\t\tqu.push(make_pair(i,edge[pos][i]));\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  int *par, *rank;\n\npublic:\n  UnionFind() {}\n  UnionFind(int n) {\n    par = new int[n];\n    rank = new int[n];\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) {\n        ++rank[x];\n      }\n    }\n  }\n};\n\n\nint main() {\n  int n, m;\n  while(cin >> n >> m && (n|m)) {\n    pair<int,pair<int,int> > es[m];\n    for(int i = 0; i < m; ++i) {\n      cin >> es[i].second.first\n          >> es[i].second.second\n          >> es[i].first;\n    }\n    sort(es, es+m);\n    UnionFind uf(n);\n    int res = 0;\n    for(int i = 0; i < m; ++i) {\n      int a = es[i].second.first;\n      int b = es[i].second.second;\n      if(!uf.same(a,b)) {\n        res += es[i].first;\n        uf.unite(a,b);\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nclass UnionFind {\npublic:\n\tUnionFind(size_t n) : parent(n, -1) {}\n\n\tvoid init(size_t n)\n\t{\n\t\tparent.assign(n, -1);\n\t}\n\n\tint root(int x)\n\t{\n\t\tint x_parent = parent[x];\n\t\tif (x_parent < 0)\n\t\t{\n\t\t\treturn x;\n\t\t} else\n\t\t{\n\t\t\treturn parent[x] = root(x_parent);\n\t\t}\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tint x_parent = root(x);\n\t\tint y_parent = root(y);\n\t\tif (x_parent == y_parent)\n\t\t{\n\t\t\treturn false;\n\t\t} else if (x_parent < y_parent)\n\t\t{\n\t\t\tparent[x_parent] += parent[y_parent];\n\t\t\tparent[y_parent] = x_parent;\n\t\t\treturn true;\n\t\t} else\n\t\t{\n\t\t\tparent[y_parent] += parent[x_parent];\n\t\t\tparent[x_parent] = y_parent;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x)\n\t{\n\t\treturn -parent[root(x)];\n\t}\n\nprivate:\n\t// negative(parent): num of members\n\t// positive(child) : parent index\n\tstd::vector<int> parent;\n};\n\nstruct Edge\n{\n\tint a;\n\tint b;\n\tint cost;\n\n\tbool operator<(const Edge& rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\tint ans_sum;\n\tUnionFind uf(500);\n\tpriority_queue<Edge> que;\n\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0)\n\t\t\treturn 0;\n\n\t\tans_sum = 0;\n\t\tuf.init(m);\n\t\tque = priority_queue<Edge>();\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tque.push(Edge{ a, b, cost });\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tEdge e = que.top(); que.pop();\n\t\t\tif (uf.unite(e.a, e.b))\n\t\t\t{\n\t\t\t\tans_sum += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans_sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint data[101][101];\n\nint prim( int n )\n{\n\tvector<int> key( n, numeric_limits<int>::max() );\n\tkey[0] = 0;\n\tvector<int> pq;\n\tvector<bool> inQueue( n, true );\n\tfor( int i = 0;i < n;i++ ){\n\t\tpq.push_back( key[i] );\n\t}\n\n\twhile( !pq.empty() ){\n\t\tvector<int>::iterator it = min_element( pq.begin(), pq.end() );\n\t\tint u = distance( pq.begin(), it );\n\t\tpq.erase( it );\n\t\tinQueue[u] = false;\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tif( data[u][i] ){\n\t\t\t\tif( inQueue[i] ){\n\t\t\t\t\tint w = data[u][i];\n\t\t\t\t\tif( w < key[i] ){\n\t\t\t\t\t\tkey[i] = w;\n\t\t\t\t\t\tpq[i] = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint answer = 0;\n\tfor( int i = 0;i < n;i++ ){\n\t\tanswer += key[i];\n\t}\n\n\treturn answer;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n,m;\n\tint a,b,cost;\n\n\twhile( cin >> n >> m && n != 0 ){\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0;i < m;i++ ){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tdata[a][b] = cost;\n\t\t\tdata[b][a] = cost;\n\t\t}\n\n\t\tint answer = prim( n );\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\n\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** Union-Find *****/\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\n/***** /Union-Find *****/\n\n/***** Kruskal *****/\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_E = 10000;\nedge es[MAX_E];\nint V, E;\n\nint kruskal(void){\n\tsort(es, es + E, comp);\n\tunion_find_init(V);\n\n\tint res = 0;\n\tfor(int i=0; i<E; ++i){\n\t\tedge e = es[i];\n\t\tif(!same(e.from, e.to)){\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/***** /Kruskal *****/\n\nint main(void) {\n\twhile (cin >> V >> E, V) {\n\t\tE *= 2;\n\t\tfor (int i = 0; i < E / 2; i++) {\n\t\t\tint a, b, cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tes[i * 2].from = a;\n\t\t\tes[i * 2].to = b;\n\t\t\tes[i * 2].cost = cost;\n\t\t\tes[i * 2 + 1].from = b;\n\t\t\tes[i * 2 + 1].to = a;\n\t\t\tes[i * 2 + 1].cost = cost;\n\t\t}\n\n\t\tint res = kruskal();\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct edge\n{\n\tint from;\n\tint to;\n\tint cost;\n\n\tedge (int from, int to, int cost) : from(from),to(to),cost(cost) {}\n};\n\nbool cmp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nint par[101];\nint rank[101];\n\nvoid init(int n)\n{\n\trep(i,n)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif(par[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t{\n\t\tpar[x] = y;\n\t}\n\telse\n\t{\n\t\tpar[y] = x;\n\t\t\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x,int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tint n,m;\n\twhile(cin >> n >> m)\n\t{\n\t\tif(n == 0 && m == 0) break;\n\t\t\t\n\t\t\n\t\tvector<edge> v;\n\n\t\trep(i,m)\n\t\t{\n\t\t\tint t1,t2,temp;\n\t\t\tcin >> t1 >> t2 >> temp;\n\n\t\t\tv.push_back(edge(t1,t2,temp));\n\t\t}\n\n\t\tsort(v.begin(),v.end(),cmp);\n\n\t\tinit(n);\n\t\tint res = 0;\n\t\t\n\n\t\trep(i,m)\n\t\t{\n\t\t\tedge e = v[i];\n\n\t\t\tif(!same(e.from,e.to))\n\t\t\t{\n\t\t\t\tunite(e.from,e.to);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout  << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100)\n\nstruct edge { int from, to, cost; };\n\nbool comp ( const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint par[MAX_N];\t\t/// 親\nint rank[MAX_N];\t/// 木の深さ\n\n/// n要素で初期化\nvoid init ( int n )\n{\n\tfor (int i = 0; i < n; ++i) {\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n/// 木の根を求める\nint find ( int x ) \n{\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n/// xとyの属する集合を合併\nvoid unite ( int x, int y )\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif (x == y) { return; }\n\n\tif (rank[x] < rank[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y]) { ++rank[x]; }\n\t}\n}\n\n/// xとyが同じ集合に属するか否か\nbool same ( int x, int y )\n{\n\treturn find(x) == find(y);\n}\n\nusing namespace std;\n\nint main ( void )\n{\n\tint n, m;\n\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tedge e;\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\t\tbool hit = false;\n\t\t\tfor (int j = 0; j < es.size() && !hit; ++j) {\n\t\t\t\tif ((e.from == es[j].from && e.to == es[j].to) ||\n\t\t\t\t\t(e.from == es[j].to && e.to == es[j].from)) {\n\t\t\t\t\t\tes[j].cost = min(es[j].cost, e.cost);\n\t\t\t\t\t\thit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hit) {\n\t\t\t\tes.push_back(e);\n\t\t\t}\n\t\t}\n\n\t\tsort(es.begin(), es.end(), comp);\n\t\tinit(n);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.from, e.to)) {\n\t\t\t\tunite(e.from, e.to);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int UF_SIZE = 128;\nint UF[UF_SIZE];\n\nvoid UF_init() {\n\tfor(int i = 0; i < UF_SIZE; i++) {\n\t\tUF[i] = i;\n\t}\n}\n\nint UF_indx(int a) {\n\tif(a == UF[a])\n\t\treturn a;\n\telse\n\t\treturn UF_indx(UF[a]);\n}\n\nint UF_merge(int a, int b) {\n\tUF[UF_indx(a)] = UF_indx(b);\n}\n\nstruct bridge {\n\tint a, b;\n\tint cost;\n\tbridge(int a_, int b_, int cost_) {\n\t\ta = a_; b = b_;\n\t\tcost = cost_;\n\t}\n\n\tbool operator<(const bridge obj) const {\n\t\treturn cost < obj.cost;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(1) {\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0)\n\t\t\tbreak;\n\t\tvector<bridge> v;\n\t\tUF_init();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tint cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tv.push_back(bridge(a, b, cost));\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tif(UF_indx(v[i].a) != UF_indx(v[i].b)) {\n\t\t\t\tUF_merge(v[i].a, v[i].b);\n\t\t\t\tans += v[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//最小全域木したよ!!\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF ( 1 << 30 )\n#define fr first\n#define sc second\n#define MAX_V 100\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> Pii;\nvector<vector<Pi> > info;\nbool used[MAX_V];\nint prim(){\n  int total = 0;\n  fill_n(used,MAX_V,false);\n  priority_queue< Pi , vector<Pi> , greater<Pi> > que;\n  que.push(Pi(0,0));\n  while(!que.empty()){\n    Pi p = que.top();\n    que.pop();\n    if(used[p.sc]++) continue;\n    total += p.fr;\n    for(int i = 0 ; i < info[p.sc].size() ; i++ ) que.push(info[p.sc][i]);\n  }\n  return total;\n}\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    info.resize(n);\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      info[a].push_back(Pi(cost,b));\n      info[b].push_back(Pi(cost,a));\n    }\n    cout << prim() << endl;\n    info.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint P[10010];\nint N, M, A[10010], B[10010], COST[10010];\npair<int, int> bridge[10010];\nvoid init(int n) {\n for (int i=0; i<n; ++i) { P[i] = i; }\n}\nint root(int a) {\n if (P[a] == a) return a;\n return (P[a] = root(P[a]));\n}\nbool is_same_set(int a, int b) {\n return root(a) == root(b);\n}\nvoid unite(int a, int b) {\n P[root(a)] = root(b);\n}\n\nint main() {\n while ((cin >> N >> M) && N>0) {\n  for (int i=0; i<M; ++i) {\n   cin >> A[i] >> B[i] >> COST[i];\n   bridge[i].first = COST[i];\n   bridge[i].second = i;\n  }\n  sort(bridge, bridge+M);\n  init(N);\n  int sum = 0;\n  for (int i=0; i<M; ++i) {\n   int cost = bridge[i].first;\n   int a = A[bridge[i].second];\n   int b = B[bridge[i].second];\n   if (is_same_set(a,b)) { continue; }\n   unite(a, b);\n   sum += cost;\n  }\n  cout << sum << endl;\n }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<map>\n#include<functional>\nusing namespace std;\nint main()\n{\n\tconst int N = 100, INVALID_VALUE = 999;\n\tint cost[N][N],n,m,i,j,a,b,c,s;\n\tbool isUsed[N] = {false};\n\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tfor(j=0;j<n;++j) cost[i][j] = INVALID_VALUE;\n\t\t\tisUsed[i] = false;\n\t\t}\n\t\tfor(i=0;i<m;++i) scanf(\"%d%d%d\",&a,&b,&c), cost[a][b] = cost[b][a] = c;\n\n\t\ttypedef pair<int,int>PII;\t\n\t\tpriority_queue<PII,vector<PII>,greater<PII> >q;\n\t\tPII p;\n\t\tq.push(make_pair(0,0));\n\t\ts = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tp = q.top(); q.pop();\n\t\t\tif(isUsed[p.second]) continue;\n\t\t\tisUsed[p.second] = true;\n\t\t\ts += p.first;\n\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tc=cost[i][p.second];\n\t\t\t\tif(c!=INVALID_VALUE) q.push(make_pair(c,i));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++) \n#define INF 1010001000\n\ntypedef pair<int, int> i_i;\ntypedef struct Edge{ int fr, to, co; } Edge;\n\nint n, m;\nint par[101], rank[101];\n\nvoid init(int n);\nint find(int x);\nvoid unite(int x, int y);\nbool same(int x, int y);\nint kruskal(Edge e[]);\nbool cmp(const Edge &e1, const Edge &e2);\n\nint main()\n{\n    while (cin >> n >> m, (n|m)) {\n        Edge e[m];\n        loop(i, m) {\n            cin >> e[i].fr >> e[i].to >> e[i].co;\n        }\n        cout << kruskal(e) << endl;\n    }\n    return 0;\n}\n\nint kruskal(Edge e[])\n{\n    sort(e, &e[m], cmp);\n    int ans = 0;\n    init(n);\n    loop(i, m) {\n        if (!same(e[i].fr, e[i].to)) {\n            ans += e[i].co;\n            unite(e[i].fr, e[i].to);\n        }\n    }\n    return ans;\n}\n\nvoid init(int n)\n{\n    loop(i, n) {\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x)\n{\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n        return ;\n    }\n    if (rank[x] < rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank[x] == rank[y]) {\n            rank[x]++;\n        }\n    }\n}\n\nbool same(int x, int y)\n{\n    return find(x) == find(y);\n}\n                \nbool cmp(const Edge &e1, const Edge &e2)\n{\n    return e1.co < e2.co;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define TOSHI_MAX 100\n#define COST_MAX 100000\nusing namespace std;\n\nint prim(int data[TOSHI_MAX][TOSHI_MAX], int toshiNum) {\n  bool visited[toshiNum];\n  int cost[toshiNum];\n  for(int i = 0; i < toshiNum; i++) {\n    visited[i] = false;\n    cost[i] = COST_MAX;\n  }\n  cost[0] = 0;\n  while(1) {\n    int min = COST_MAX;\n    int p;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && cost[i] < min) {\n\tmin = cost[i];\n\tp = i;\n      }\n    }\n    if(min == COST_MAX) break;\n\n    visited[p] = true;\n    for(int i = 0; i < toshiNum; i++) {\n      if(!visited[i] && data[p][i] < cost[i]) {\n\tcost[i] = data[p][i];\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int i = 0; i < toshiNum; i++) {\n    if(cost[i] != COST_MAX) ans += cost[i];\n  }\n\n  return ans;\n}\n\nint main() {\n  while(1) {\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    int data[TOSHI_MAX][TOSHI_MAX];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tdata[i][j] = COST_MAX;\n      }\n    }\n\n    for(int i = 0; i < m; i++) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      data[a][b] = data[b][a] = cost;\n    }\n\n    cout << prim(data, n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nstruct uft{\n    vector<ll> par;\n    uft(ll n) {\n        par.resize(n);\n        rep(i,n)par[i]=i;\n    }\n\n    ll find(ll a){\n        if(par[a]==a){\n            return a;\n        }else {\n            return find(par[a]);\n        }\n    }\n\n    void unite(ll a,ll b){\n        par[find(a)]=find(b);\n    }\n\n    bool same(ll a,ll b){\n        return find(a) == find(b);\n    }\n};\n\nstruct edge{\n    ll s,t,w;\n};\n\nbool sortw(edge a,edge b) {\n    return a.w < b.w;\n}\n\nvoid q(ll v, ll e) {\n    vector<edge> edges;\n    rep(i,e){\n        ll s,t,w;\n        cin>>s>>t>>w;\n        edges.push_back(edge{s,t,w});\n    }\n    sort(edges.begin(),edges.end(),sortw);\n    ll sum=0;\n    uft uni(v);\n    rep(i,e){\n        if(!uni.same(edges[i].s,edges[i].t)) {\n            uni.unite(edges[i].s,edges[i].t);\n            sum+=edges[i].w;\n        }\n    }\n    cout<<sum<<endl;\n}\n\nint main() {\n    while(true){\n        ll v,e;\n        cin>>v>>e;\n        if(v==0&&e==0)break;\n        q(v,e);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct edge{ int from,to,cost; };\n\nint rnk[100],par[100];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int a,int b){\n\ta = find(a);\n\tb = find(b);\n\tif(a == b) return;\n\tif(rnk[a] > rnk[b]){\n\t\tpar[b] = a;\n\t}else{\n\t\tpar[a] = b;\n\t\tif(rnk[a] == rnk[b]) rnk[b]++;\n\t}\n}\n\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tvector<edge> es;\n\t\tint sum = 0;\n\t\tcin >> n >> m;\n\t\tif(!n) break;\n\t\tinit(n);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tes.push_back({a,b,c});\n\t\t}\n\t\tsort(es.begin(),es.end(),comp);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(find(es[i].to) != find(es[i].from)){\n\t\t\t\tunite(es[i].to,es[i].from);\n\t\t\t\tsum += es[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n#define int ll\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define rALL(obj) (obj).rbegin(), (obj).rend()\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconst ll MOD = 1e9+7;\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\ntypedef int Weight;\nstruct Edge {  //src:辺の始点,dst:辺の終点,weight:辺の重さ\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : //辺は重さが重いものを\"小さい\"と定義する\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n//引数 g:隣接リスト,r:最小全域木の始点\n//戻値 total:最小全域木の重み,T:最小全域木の辺集合\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );    //始め、-1とrを結ぶ辺があると考える\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();++f) if(!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\nsigned main(){\n  int v,e;\n  while(cin >> v >> e,v){\n    Graph g(v);\n    REP(i,e){\n      int s,t;\n      int w;\n      cin >> s >> t >> w;\n      g[s].push_back(Edge(s,t,w));\n      g[t].push_back(Edge(t,s,w));\n    }\n      cout << prim(g).first << endl;\n  }\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tint from, to, cost;\n\tREP(i, m){\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second; q.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second]){\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint Par[100],Rank[100];\nvoid Init(int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tPar[i]=i;\n\t\tRank[i]=0;\n\t}\n}\nint Find(int x) {\n\tif(Par[x]==x) {\n\t\treturn x;\n\t}else {\n\t\treturn Par[x]=Find(Par[x]);\n\t}\n}\nvoid Unite(int x,int y) {\n\tx=Find(x);\n\ty=Find(y);\n\tif(x==y) return;\n\tif(Rank[x]<Rank[y]) {\n\t\tPar[x]=y;\n\t}else {\n\t\tPar[y]=x;\n\t\tif(Rank[x]==Rank[y])Rank[x]++;\n\t}\n}\nbool Same(int x,int y) {\n\treturn Find(x)==Find(y);\n}\nstruct Edge {\n\tint from,to,cost;\n\tEdge(int _f,int _t,int _c) {from=_f,to=_t,cost=_c;}\n\tbool operator < (const Edge& E) const {return cost<E.cost;}\n};\nint main() {\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n) {\n\t\tvector<Edge> es;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&cost);\n\t\t\tes.push_back(Edge(a,b,cost));\n\t\t}\n\t\tsort(es.begin(),es.end());\n\t\tInit(n);\n\t\tint sum=0;\n\t\tfor(int i=0;i<es.size();i++) {\n\t\t\tif(!Same(es[i].from,es[i].to)) {\n\t\t\t\tUnite(es[i].from,es[i].to);\n\t\t\t\tsum+=es[i].cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 9999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<int> mincost;\nvector< vector<SEdge> > Edge;\nbool used[128];\n\nint Prim()\n{\n\tfill(used, used + V, false);\n\tfill(mincost.begin(), mincost.end(), INF);\n\tmincost[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, 0));\n\tint res = 0;\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(mincost[v] < p.first || used[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int i = 0; i < Edge[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = Edge[v][i];\n\t\t\tif(mincost[e.To] > e.Cost)\n\t\t\t{\n\t\t\t\tmincost[e.To] = e.Cost;\n\t\t\t\tPQue.push(P(mincost[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V >> E, V || E)\n\t{\n\t\tmincost.clear();\n\t\tmincost.resize(V);\n\t\tfor(int i = 0; i < Edge.size(); ++i)\n\t\t{\n\t\t\tEdge[i].clear();\n\t\t}\n\t\tEdge.clear();\n\t\tEdge.resize(V);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tcin >> From >> To >> Cost;\n\t\t\tSEdge e1, e2;\n\t\t\te1.To = To;\n\t\t\te2.To = From;\n\t\t\te1.Cost = e2.Cost = Cost;\n\t\t\tEdge[From].push_back(e1);\n\t\t\tEdge[To].push_back(e2);\n\t\t}\n\t\tcout << Prim() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n\n// int N, M, A[10010], B[10010], COST[10010];\n// pair<int, int> bridge[10010];\nint P[10010];//村のrootが保存\n\nvoid init(int N){\n  for(int i=0; i< N; ++i){\n    P[i]= i;\n  }\n}\n\nint root(int a){//aのroot(代表元)を決める\n  if(P[a]==a) return a;//aはroot\n  return (P[a] = root(P[a]));//aの親のrootを求め,aの親とする\n}\nbool is_same_set(int a, int b){\n  return root(a) == root(b);\n}\nvoid unite(int a, int b){\n   P[root(a)] = root(b);\n}\n\n\nint main(){\n  int N, M, A[10010], B[10010], COST[10010];\n  pair<int, int> bridge[10010];\n  int allcost = 0;\n  int bridgenum = 0;\n  //root決める\n  while(cin >> N >> M  && N>0){\n    init(N);\n    for (int i = 0; i < M; ++i)\n    {\n      cin >> A[i] >> B[i] >> COST[i];\n      bridge[i].first = COST[i];\n      bridge[i].second = i ;\n    }\n    sort(bridge,bridge+M);\n    for (int i = 0; i < M; ++i)\n    {\n      int cost = bridge[i].first;\n      int a = A[bridge[i].second];\n      int b = B[bridge[i].second];\n\n      if (bridgenum == M-1)\n      {\n        unite(a,b);\n      }\n      if(is_same_set(a,b)){\n\n      }else{\n        unite(a,b);\n        allcost += cost;\n        cout <<  allcost << endl;\n        bridgenum += 1;\n      }\n\n\n      // 「a から b に cost の橋がかかっている」と表示\n    }\n    cout <<  allcost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nint par[101],rank[101];\nstruct edge{int u,v,cost;};\n\nusing namespace std;\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n}\n  else {\n    return par[x]=find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  \n  if(rank[x] < rank[y]){\n    par[x]=y;\n  }\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[101];\nint V,E;\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int i,a,b,c;\n\n  while(cin >> V >> E,V,E){\n    for(i=0;i<E;i++){\n      cin >> a >> b >> c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n    }\n    printf(\"%d\\n\",kruskal());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tvector<bool> done(n, false);\n\tREP(i, m){\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t\tnode[to].PB(MP(cost, from));\n\t}\n\tPQPII q;\n\tVI costs(n, INF);\n\tcosts[0] = 0;\n\tq.emplace(0, 0);\n\tint result = 0;\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second] && !done[p.second]){\n\t\t\t\tdone[u] = true;\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n >> m, n | m;){\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(void)\n{\n\tint a,s,d[101],f[101],g[101],h,i,j,size[101],ban[101];\n\tint z,x,q;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tban[i]=i;\n\t\tsize[i]=1;\n\t}\n\tfor(i=0;i<s;i++) scanf(\"%d %d %d\",&d[i],&f[i],&g[i]);\n\tfor(i=0;i<s;i++){\n\t\tif(d[i]>f[i]) h=d[i]; d[i]=f[i]; f[i]=h;\n\t\tfor(j=i+1;j<s;j++){\n\t\t\tif(g[i]>g[j]){\n\t\t\t\th=g[i]; g[i]=g[j]; g[j]=h;\n\t\t\t\th=d[i]; d[i]=d[j]; d[j]=h;\n\t\t\t\th=f[i]; f[i]=f[j]; f[j]=h;\n\t\t\t}\n\t\t}\n\t}\n\t/*for(i=0;i<s;i++)\n\t\tprintf(\"%d %d %d\\n\",d[i],f[i],g[i]);*/\n\tfor(i=0;i<s;i++){\n\t//\tprintf(\"%d %d %d\\n\\n\",d[i],f[i],g[i]);\n\t\tz=d[i]; x=f[i];\n\t\twhile(ban[z]!=z) z=ban[z];\n\t\twhile(ban[x]!=x) x=ban[x];\n\t\tif(z!=x){\n\t\t\tq+=g[i];\n\t\t\tif(size[z]>size[x]) ban[x]=z;\n\t\t\telse if(size[z]<=size[x]) ban[z]=x;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",q);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\tBridge(const Bridge& b) : from(b.from), to(b.to), cost(b.cost) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tbridge[i] = Bridge();\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n/*\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n*/\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(city[current.to] && city[current.from])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n\n  while(cin >> n >> m && n + m != 0){\n    priority_queue< pair<int,edge>,vector<P>,greater<P> > que;\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      que.push(make_pair(c,edge(a,b)));\n    }\n    UnionFind u(m);\n    int cost = 0;\n    for (int i = 0; i < m; ++i){\n      edge top = que.top().second;\n      int topCost = que.top().first;\n      que.pop();\n      if(u.unionSet(top.from,top.to)){\n\tcost += topCost;\n      }\n    }\n    cout << cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> ii;\n\nstruct Node {\n    bool d;\n    vector<ii> tos;\n};\n\nint n, m;\nvector<Node> ns;\n\nint prim() {\n    for (int i = 0; i < n; i++) {\n        ns[i].d = false;\n    }\n    priority_queue<ii, vector<ii>, greater<ii> > q;\n    q.push(make_pair(0, 0));\n    int ans = 0;\n    while (!q.empty()) {\n        ii p = q.top();\n        q.pop();\n        int i = p.second;\n        if (ns[i].d) {\n            continue;\n        }\n        ns[i].d = true;\n        ans += p.first;\n        for (vector<ii>::iterator it = ns[i].tos.begin(); it != ns[i].tos.end(); it++) {\n            q.push(make_pair(it->second, it->first));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> n >> m, n|m) {\n        ns.clear();\n        ns.resize(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            ns[a].tos.push_back(make_pair(b, c));\n            ns[b].tos.push_back(make_pair(a, c));\n        }\n        cout << prim() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m),n+m){\n    int  cost[n][n];\n    bool f[n];\n    memset(cost, 0, sizeof(cost));\n    memset(f, 0, sizeof(f));\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      cost[a][b] = cost[b][a] = c;\n    }\n    f[0] = true;\n    int ans = 0;\n    REP(i,n-1){\n      int m = INT_MAX;\n      int ii,jj;\n      for(int i=0; i<n; i++){\n\tfor(int j=i+1; j<n; j++){\n\t  if(f[i] ^ f[j] && cost[i][j] != 0){\n\t    if(m > cost[i][j]){\n\t      ii = i; jj = j;\n\t      m = cost[i][j];\n\t    }\n\t  }\n\t}\n      }\n      f[ii] = f[jj] = true;\n      ans += m;\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tbreak;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile( 1 )\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif((bridge[i].to == next && !city[bridge[i].from]) || \n\t\t\t\t   (bridge[i].from == next && !city[bridge[i].to]))\n\t\t\t\t{\n\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include <bits/stdc++.h>\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define-----------------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i < n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << endl\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define FOREACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define INF 1 << 25\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define sq(n) (n) * (n)\n\n//typedef----------------------------------------------------------------------------------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\n//const------------------------------------------------------------------------------------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos( -1.0 );\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint n, m;\nint cost[ 100 ][ 100 ];\nbool visit[ 100 ];\nint a, b, c;\n\n//function---------------------------------------------------------------------------------------------------------------------\n\nint main() {\n\twhile ( scanf( \"%d %d\", &n, &m ) != 0 ) {\n\t\tif ( n == 0 && m == 0 )\n\t\t\treturn 0;\n\t\trep( i, n ) {\n\t\t\trep( j, n ) {\n\t\t\t\tcost[ i ][ j ] = INF;\n\t\t\t\tif ( i == j )\n\t\t\t\t\tcost[ i ][ j ] = 0;\n\t\t\t}\n\t\t\tvisit[ i ] = false;\n\t\t}\n\t\trep( i, m ) {\n\t\t\tscanf( \"%d %d %d\", &a, &b, &c );\n\t\t\tcost[ a ][ b ] = c;\n\t\t\tcost[ b ][ a ] = c;\n\t\t}\n\t\tint ans = 0;\n\t\tvisit[ 0 ] = true;\n\t\tFOR( i, 1, n ) {\n\t\t\tint min_cost = INF;\n\t\t\tint can_visit;\n\t\t\trep( j, n ) {\n\t\t\t\tif ( !visit[ j ] )\n\t\t\t\t\tcontinue;\n\t\t\t\trep( k, n ) {\n\t\t\t\t\tif ( cost[ j ][ k ] < min_cost && !visit[ k ] ) {\n\t\t\t\t\t\tmin_cost = cost[ j ][ k ];\n\t\t\t\t\t\tcan_visit = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += min_cost;\n\t\t\tvisit[ can_visit ] = true;\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint data[101][101];\n\nint prim( int n )\n{\n\tvector<int> key( n, numeric_limits<int>::max() );\n\tkey[0] = 0;\n\tvector<int> pq;\n\tvector<bool> inQueue( n, true );\n\tfor( int i = 0;i < n;i++ ){\n\t\tpq.push_back( key[i] );\n\t}\n\n\twhile( !pq.empty() ){\n\t\tvector<int>::iterator it = min_element( pq.begin(), pq.end() );\n\t\tint u = distance( pq.begin(), it );\n\t\tpq.erase( it );\n\t\tinQueue[u] = false;\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tif( data[u][i] ){\n\t\t\t\tif( inQueue[i] ){\n\t\t\t\t\tint w = data[u][i];\n\t\t\t\t\tif( w < key[i] ){\n\t\t\t\t\t\tkey[i] = w;\n\t\t\t\t\t\tpq[i] = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint answer = 0;\n\tfor( int i = 0;i < n;i++ ){\n\t\tanswer += key[i];\n\t}\n\n\treturn answer;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n,m;\n\tint a,b,cost;\n\n\twhile( cin >> n >> m && n != 0 ){\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0;i < m;i++ ){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tdata[a][b] = cost;\n\t\t\tdata[b][a] = cost;\n\t\t}\n\n\t\tint answer = prim( n );\n\t\tcout << answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_V = 1000;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\nconst int INF = 10000000;\n\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    // Xツづ可堕ョツつウツづ按つ「ツ陳クツ点ツづ個つ、ツつソXツつゥツづァツづ個陛督づ個コツスツトツつェツ催渉ャツづ可づ按づゥツ点ツづーツ探ツつキ\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t  v = u;\n\t}\n\tif(v == -1)\n\t\tbreak;\n\tused[v] = true;\n\tres += mincost[v];\n\t\n\tfor(int u = 0; u < V; u++){\n\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t}\n\n  }\n  return res;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tfill(cost[i],cost[i]+MAX_V,INF);\n\t\t}\n\t\tV=n;\n\t\tint a,b,c;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\tcost[a][b]=c;\n\t\t\tcost[b][a]=c;\n\t\t}\n\t\tcout<<prim()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#define MAX_V 1000\n#define INF 1<<29\n#define cl(a,b) for(int i=0;i<a;i++)for(int j=0;j<b;j++)cost[i][j] = INF;\n#define de(a)  for(int i=0;i<a;i++){cout << mincost[i] << \" \"; if(i == a-1){cout << endl;}}\n#define de2(a,b) for(int I=0;I<a;I++){for(int j=0;j<b;j++){cout << cost[I][j] << \" \";}cout << endl;}cout << endl;\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n bool connect[10000];\n\nint prime()\n{\n  for(int i=0;i<V;++i)\n    {\n      mincost[i]=INF;\n      used[i]=false;\n    }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  //de(10);\n  \n\n  //de2(10,10);\n  \n\n  while(true)\n    {\n      int v = -1; \n      for(int u = 0; u<V ; u++ )\n\t{\n\t  if(connect[u] && !used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t    {\n\t      v = u;\n\t      //cout << \"v = \" << v << endl;\n\t    }\n\t}\n\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n\n      for(int u = 0; u < V; u++)\n\t{\n\t  if(!connect[u]){}\n\t  else{\n\t  mincost[u] = min(mincost[u],cost[v][u]);\n\t  //cout << \"mincost[u] = \" << mincost[u] << \", cost[v][u] = \" << cost[v][u] << endl;\n\t  }\n\t}\n    }\n  return res;\n}\n\n\n\nint main()\n{\n\n  int n,m,a,b;\n \n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n == 0 && m == 0)break;\n      cl(m,m);\n      memset(connect,false,sizeof(connect));\n\n      V = m;\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> a >> b;\n\t  cin >> cost[a][b];\n\t  cost[b][a] = cost[a][b];\n\t  connect[a] = true;\n\t  connect[b] = true;\n\t}\n      /*     \n for(int i=0;i<m;i++)\n\t{\n\t  if(!connect[i])\n\t    {\n\n\n\t    }\n\t}\n      */\n\n\n      cout << prime() << endl;\n\n\n\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// テ」ツつーテ」ツδゥテ」ツδ陛ァツ板ィテ」ツδ佚」ツδε」ツδ?\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// テヲツ慊?・ツーツ湘・ツ?ィテ・ツ淞淌ヲツ慊ィ(Minimum Spanning Tree) by Prim Algorithm\n/*\n  g : テ」ツつーテ」ツδゥテ」ツδ?\n  r : テヲツ慊?・ツ按敕」ツ?ォテ・ツ青ォテ」ツつ?ゥツ?づァツつケ\n*/\npair<Weight, Edges> MST(const Graph &g, int r = 0) {\n    int n = g.size(); Edges T; Weight total = 0;\n    vector<bool> visited(n);\n    priority_queue<Edge> q;\n    q.push(Edge(-1, r, 0));\n    while (q.size()) {\n        Edge e = q.top(); q.pop();\n        if (visited[e.dst]) continue;\n        T.push_back(e);\n        total += e.weight;\n        visited[e.dst] = true;\n        for(auto& f: g[e.dst]) if (!visited[f.dst]) q.push(f);\n    }\n    return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n){\n        Graph g(n);\n        rep(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            g[a].emplace_back(a,b,c);\n            g[b].emplace_back(b,a,c);\n        }\n        cout << MST(g).first << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n  int from, to, cost;\n  Edge() : from(0), to(0), cost(0) { }\n  Edge(int from, int to, int cost) : from(from), to(to), cost(cost) { }\n};\n\nstruct UnionFind {\n  vector<int> data;\n\n  UnionFind(int n) : data(n, -1) { }\n\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n\n  int root(int i) {\n    return data[i] < 0 ? i : data[i] = root(data[i]);\n  }\n\n  void join(int i, int j) {\n    data[root(i)] += data[root(j)];\n    data[root(j)] = root(i);\n  }\n};\n\nint main() {\n  for(int n, m; cin >> n >> m && n; ) {\n    vector<Edge> edges(m);\n\n    for(int i = 0; i < m; i++) {\n      cin >> edges[i].from >> edges[i].to >> edges[i].cost;\n    }\n\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n      return a.cost < b.cost;\n    });\n\n    int cost = 0;\n    UnionFind uf(n);\n\n    for(auto it = edges.begin(); it != edges.end(); it++) {\n      if(!uf.same(it->from, it->to)) {\n        uf.join(it->from, it->to);\n        cost += it->cost;\n      }\n    }\n\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n\n\n// int N, M, A[10010], B[10010], COST[10010];\n// pair<int, int> bridge[10010];\nint P[10010];//村のrootが保存\n\nvoid init(int N){\n  for(int i=0; i< N; ++i){\n    P[i]= i;\n  }\n}\n\nint root(int a){//aのroot(代表元)を決める\n  if(P[a]==a) return a;//aはroot\n  return (P[a] = root(P[a]));//aの親のrootを求め,aの親とする\n}\nbool is_same_set(int a, int b){\n  return root(a) == root(b);\n}\nvoid unite(int a, int b){\n   P[root(a)] = root(b);\n}\n\n\nint main(){\n  int N, M, A[10010], B[10010], COST[10010];\n  pair<int, int> bridge[10010];\n\n  //root決める\n  while(cin >> N >> M  && N>0){\n    int allcost = 0;\n    // int bridgenum = 0;\n    init(N);\n    for (int i = 0; i < M; ++i)\n    {\n      cin >> A[i] >> B[i] >> COST[i];\n      bridge[i].first = COST[i];\n      bridge[i].second = i ;\n    }\n    sort(bridge,bridge+M);\n    for (int i = 0; i < M; ++i)\n    {\n      int cost = bridge[i].first;\n      int a = A[bridge[i].second];\n      int b = B[bridge[i].second];\n\n      // if (bridgenum == M-1)\n      // {\n      //   unite(a,b);\n      //   // allcost += cost;\n      // }\n      if(is_same_set(a,b)){\n\n      }else{\n        unite(a,b);\n        allcost += cost;\n        // cout <<  allcost << endl;\n        // bridgenum += 1;\n      }\n      // 「a から b に cost の橋がかかっている」と表示\n    }\n    cout <<  allcost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\tBridge(const Bridge& b) : from(b.from), to(b.to), cost(b.cost) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tbridge[i] = Bridge();\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(city[current.to] && city[current.from])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint prim(int a[101][101], int n)\n{\n\tint r = 0, mcost[101];\n\tbool vis[101];\n\t\n\tfill(mcost, mcost+101, inf);\n\tfill(vis, vis+101, false);\n\tmcost[0] = 0;\n\t\n\twhile(1){\n\t\tint v = -1;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!vis[i] && (v == -1 || mcost[v] > mcost[i])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tvis[v] = true;\n\t\tr += mcost[v];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmcost[i] = min(mcost[i], a[v][i]);\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint n, m, a[101][101], s, t, u;\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfill(&a[0][0], &a[100][100], inf);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile(m--){\n\t\t\tcin >> s >> t >> u;\n\t\t\ta[s][t] = a[t][s] = u;\n\t\t}\n\t\t\n\t\tcout << prim(a, n) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      int edge[n][n];\n      memset(edge,-1,sizeof(edge));\n      for(int i=0;i<m;i++)\n\t{\n\t  int a,b,cost;\n\t  cin>>a>>b>>cost;\n\t  edge[a][b]=cost;\n\t  edge[b][a]=cost;\n\t}\n      bool closed[n];\n      memset(closed,false,sizeof(closed));\n      int cnt=n-1;\n      int ans=0;\n      closed[0]=true;\n      priority_queue<pair<int,int>, vector<pair<int,int> > ,greater<pair<int,int> > > qu;\n      for(int i=0;i<n;i++)\n\t{\n\t  if(edge[0][i]!=-1)\n\t    qu.push(make_pair(edge[0][i],i));\n\t}\n      while(true)\n\t{\n\t  int pos=qu.top().second;\n\t  int cost=qu.top().first;\n\t  //  cout<<\"#\"<<pos<<\" \"<<cost<<endl;\n\t  qu.pop();\n\t  if(closed[pos])\n\t    continue;\n\t  closed[pos]=true;\n\t  ans+=cost;\n\t  cnt--;\n\t  if(cnt<=0)\n\t    break;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if(edge[pos][i]!=-1)\n\t\tqu.push(make_pair(edge[pos][i],i));\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<queue>\n\nconst int MAXN = 105;\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge{\n  edge(int from,int to):from(from),to(to){}\n  int from,to;\n};\n\nbool operator<(edge a,edge b){\n  if(a.from != b.from)return a.from < b.from;\n  else return a.to < b.to;\n}\n\ntypedef pair<int,edge> P;\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n | m) != 0){\n    vector<P> road;\n\n    for (int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      road.push_back(make_pair(c,edge(a,b)));\n    }\n    sort(road.begin(),road.end());\n    UnionFind u(MAXN);\n    int ans = 0;\n    int z = road.size();\n    for (int i = 0; i < z; ++i){\n      edge top = road[i].second;\n      int cost = road[i].first;\n      if(!u.findSet(top.to,top.from)){\n\t//cout << \"cost:\" << cost << \" \" << top.to << \" \" << top.from << endl;\n\tans += cost;\n\tu.unionSet(top.to, top.from);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct UF {\n  int *p;\n  UF(int N):p(new int[N]) {fill(p,p+N,-1);}\n  ~UF(){delete[] p;}\n  int rt(int x){return p[x]<0?x:(p[x]=rt(p[x])); }\n  bool cat(int x,int y) {\n    if((x=rt(x))==(y=rt(y)))return false;\n    if(p[x]<p[y])swap(x,y);\n    p[y]+=p[x];\n    p[x]=y;\n    return true;\n  }\n};\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    int n,m; scanf(\"%d%d\", &n, &m);\n    if(n==0) break;\n    pair<int,pair<int,int> > *edges = new pair<int,pair<int,int> >[m];\n    for(int i = 0; i < m; i++) {\n      scanf(\"%d%d%d\", &edges[i].second.first, &edges[i].second.second, &edges[i].first);\n    }\n    sort(edges,edges+m);\n    long long costsum = 0;\n    UF uf(n);\n    for(int i = 0; i < m; i++) {\n      if(uf.cat(edges[i].second.first,edges[i].second.second)) {\n        costsum += edges[i].first;\n      }\n    }\n    printf(\"%lld\\n\", costsum);\n    delete[] edges;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n    os<<'[';\n    rep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n    return os<<']';\n}\n\nconst int MAX_V = 100;\nconst int INF = 987654321;\n\ntypedef int weight;\nstruct edge { int from, to; weight cost; };\nbool operator>(const edge & a, const edge & b) { return a.cost > b.cost; };\nint V;\nvector<edge> adj[MAX_V];\n\npair<weight, vector<edge> > prim() {\n\tpriority_queue<edge, vector<edge>, greater<edge> > que;\n\tque.push((edge){-1, 0, 0});\n\tbool visited[MAX_V];\n    fill(visited, visited + V, false);\n\tvector<edge> tree;\n\tweight wgh = 0;\n\twhile (!que.empty()) {\n\t\tedge e = que.top();\n\t\tque.pop();\n\t\tif (visited[e.to]) continue;\n\t\tvisited[e.to] = true;\n\t\tif (e.from >= 0) {\n\t\t\ttree.pb(e);\n\t\t\twgh += e.cost;\n\t\t}\n\t\ttr(i, adj[e.to]) que.push(*i);\n\t}\n\n\treturn mp(wgh, tree);\n}\n\nint main() {\n    for(int n, m; cin >> n >> m, (n | m) != 0;) {\n        rep(i, MAX_V) adj[i].clear();\n        rep(i, m) {\n            int a, b, cost; cin >> a >> b >> cost;\n            adj[a].pb((edge){a, b, cost});\n            adj[b].pb((edge){b, a, cost});\n        }\n        V = n;\n        cout << prim().fst << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing pii = pair<int, int>; using vi = vector<int>;\nstatic const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nstatic const int MOD = (int)(1e9 + 7);\n\nusing Weight = int;\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INF) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n, m; cin >> n >> m&&n;) {\n\t\tGraph g(n);\n\t\trep(i, 0, m) {\n\t\t\tint a, b, cost; cin >> a >> b >> cost;\n\t\t\tg[a].emplace_back(a, b, cost);\n\t\t\tg[b].emplace_back(b, a, cost);\n\t\t}\n\t\tauto k = kruskal(g);\n\t\tcout << k.first << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n\n#define MAX_V 110\n#define INF 1000000\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v){\n    os << \"{ \";\n    for(typename vector<T>::const_iterator it=v.begin(); it!=v.end(); ++it)\n        os << '\\\"' << *it << '\\\"' << (it+1==v.end() ? \"\" : \", \");\n    os << \" }\";\n    return os;\n}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n#define vv(type,w,h,init) vector<vector<type>>(h,vector<type>(w,init))\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef unsigned uint;\ntypedef unsigned long ul;\ntypedef unsigned long long ull;\n\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define mp make_pair\n\nstring const resstr[] = {\"Impossible\",\"Possible\",\"No\",\"Yes\"};\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prom(){\n\tfor(int i=0; i < V; ++i){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0; u < V; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\trep(u,V)\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\t\n\t}\n\treturn res;\n}\n\nint main(){\n\tint E;\n\twhile(cin >> V >> E, V+E){\n\t\trep(i, V)\n\t\t\trep(j, V) cost[i][j] = INF;\n\t\n\t\trep(i, E){\n\t\t\tint a, b ,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\tcout << prom() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nint n, m;\npriority_queue<IP, vector<IP>, greater<IP> > que;\n\n#define N 103\nint parent[N];\n\nint root(int x) {\n  if(x == parent[x]) return x;\n  return parent[x] = root(parent[x]);\n}\n\nvoid unite(int x, int y) {\n  int px = root(x), py = root(y);\n  if(px < py) {\n    parent[py] = px;\n  } else if(px > py) {\n    parent[px] = py;\n  }\n}\n\nint main() {\n  while(cin >> n >> m && n && m) {\n    rep(i, m) {\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      que.push(IP(cost, P(a, b)));\n    }\n    rep(i, n) parent[i] = i;\n    int ans = 0;\n    while(!que.empty()) {\n      IP e = que.top(); que.pop();\n      int cost = e.first, a = e.second.first, b = e.second.second;\n      if(root(a) != root(b)) {\n        unite(a, b);\n        ans += cost;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> rank;\n\t\n\tUnionFind() {}\n\tUnionFind(int n) {\n\t\tinit(n);\n\t}\n\t\n\tint operator[] (int x) {\n\t\treturn find(x);\n\t}\n\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n || m) {\n\t\t\n\t\tpriority_queue<pip, vector<pip>, greater<pip> > pq;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tpq.push(pip(c, pii(a, b)));\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tint ans = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tpip now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint c = now.fi;\n\t\t\tint u = now.se.fi, v = now.se.se;\n\t\t\t\n\t\t\tif (uf.same(u, v)) continue;\n\t\t\tans += c;\n\t\t\tuf.unite(u, v);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 100\n\nint par[MAX_N];\nint rank[MAX_N];\n\n#define MAX_E 100\nstruct edge { int u, v, cost; };\nedge es[MAX_E];\n\nint V, E;\n\nvoid init_union_find(int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x) {\n  if(par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x] ++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init_union_find(V);\n  int res = 0;\n  for(int i=0; i<E; i++) {\n    edge e = es[i];\n    if(!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n\n  while(cin >> V >> E && (V||E)) {\n    for(int i=0; i<E; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      es[i].u = a, es[i].v = b, es[i].cost = c;\n    }\n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define mp make_pair\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\ntypedef priority_queue<ll> PQ;\ntypedef priority_queue<ll, VL, greater<ll>> PQG;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\n\nll V, E;\nstruct Edge {\n    ll from, to, cost;\n};\nvector<Edge> Edges;\n\n//通常\nstruct UnionFind {\n    VL par, rank;\n    UnionFind(int size) { init(size); }\n    void init(int size) {\n        par.clear();\n        rank.clear();\n        REP(i, size) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int root(int x) {\n        if(par[x] == x)\n            return x;\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]) {\n            swap(x, y);\n        } else {\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        par[y] = x;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nsigned main() {\n    while(1) {\n        cin >> V >> E;\n        if(V == 0 && E == 0) break;\n        REP(i, E) {\n            LCIN(s, t, w);\n            Edges.push_back({s, t, w});\n        }\n        sort(All(Edges),\n             [](const Edge &x, const Edge &y) { return x.cost < y.cost; });\n        auto uf = UnionFind(V);\n        ll ans = 0;\n        REP(i, E) {\n            Edge e = Edges[i];\n            if(!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                ans += e.cost;\n            }\n        }\n        cout << ans << \"\\n\";\n        Edges.clear();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Bridge\n{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tBridge() : from(0), to(0), cost(0) {}\n\tBridge(const Bridge& b) : from(b.from), to(b.to), cost(b.cost) {}\n\n\tbool operator > (const Bridge& b) const\n\t{\n\t\treturn cost > b.cost;\n\t}\n\n\tbool operator < (const Bridge& b) const\n\t{\n\t\treturn cost < b.cost;\n\t}\n};\n\n\n\nint nCity, nBridge;\n\nBridge bridge[100];\nbool city[100];\n\nint main()\n{\n\twhile( 1 )\n\t{\n\t\t//load data\n\t\tcin >> nCity >> nBridge;\n\t\tif(nCity == 0 && nBridge == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tbridge[i] = Bridge();\n\t\t\tcin >> bridge[i].from >> bridge[i].to >> bridge[i].cost;\n\t\t}\n\n\t\tfor(int i=0; i<nCity; i++)\n\t\t{\n\t\t\tcity[i] = false;\n\t\t}\n\n\t\t//set initial node to queue\n\t\tpriority_queue<Bridge, vector<Bridge>, greater<Bridge> > que;\n\t\tfor(int i=0; i<nBridge; i++)\n\t\t{\n\t\t\tif(bridge[i].from == 0 || bridge[i].to == 0)\n\t\t\t{\n\t\t\t\tque.push(bridge[i]);\n\t\t\t}\n\t\t}\n\n\t\tcity[0] = true;\n\n\t\t//iteration\n\t\tint totalCost = 0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\t//end check\n\t\t\tbool isEnd = true;\n\t\t\tfor(int i=0; i<nCity; i++)\n\t\t\t{\n\t\t\t\tif(!city[i])\n\t\t\t\t{\n\t\t\t\t\tisEnd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isEnd)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check highest priority node\n\t\t\tBridge current = que.top();\n\t\t\tque.pop();\n\n\t\t\ttotalCost += current.cost;\n\n\t\t\tint next = 0;\n\t\t\tif(!city[current.to])\n\t\t\t{\n\t\t\t\tcity[current.to] = true;\n\t\t\t\tnext = current.to;\n\t\t\t}\n\t\t\n\t\t\tif(!city[current.from])\n\t\t\t{\n\t\t\t\tcity[current.from] = true;\n\t\t\t\tnext = current.from;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<nBridge; i++)\n\t\t\t{\n\t\t\t\tif(bridge[i].to == next || bridge[i].from == next)\n\t\t\t\t{\n\t\t\t\t\tif(!city[bridge[i].to] || !city[bridge[i].from])\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(bridge[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", totalCost);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint use[100],m,n,c;\nstruct poi { int n,f[100];};\nstruct bri { int a,b,c; };\nbri b[5000],g;\npoi p[100];\nvoid check(int v) {\n\tint i; c++;\n\tfor (i=0;i<p[v].n;i++) if (p[v].f[i]>-1) if (use[p[v].f[i]]==0) {use[p[v].f[i]]=1; check(p[v].f[i]);}\n\t}\n\nint main() {\n\tint i,j,s,x,y;\n    while(cin >> n >> m) {\n\t\tif (n==0) break;\n\t\tfor (i=0;i<100;i++) p[i].n=0;\n\t\tfor (s=0,i=0;i<m;i++) { cin >> b[i].a >> b[i].b >> b[i].c;\n\t\t p[b[i].a].f[p[b[i].a].n]=b[i].b;  p[b[i].a].n++;\n\t\t p[b[i].b].f[p[b[i].b].n]=b[i].a;  p[b[i].b].n++;  \n\t\t s+=b[i].c;}\n\t\tfor (i=m-1;i>0;i--) for (j=0;j<i;j++) if (b[j].c<b[j+1].c) { g=b[j]; b[j]=b[j+1]; b[j+1]=g;}\n\t\tfor (i=0;i<m;i++) {\n\t\t\tfor (j=0;j<p[b[i].a].n;j++) if (p[b[i].a].f[j]==b[i].b) { x=j; p[b[i].a].f[j]=-1; }\n\t\t\tfor (j=0;j<p[b[i].b].n;j++) if (p[b[i].b].f[j]==b[i].a) { y=j; p[b[i].b].f[j]=-1; }\n\t\t\tfor (j=0;j<n;j++) use[j]=0; \n\t\t\tuse[0]=1; c=0; check(0); \n\t\t\tif (c==n) s-=b[i].c; else { p[b[i].a].f[x]=b[i].b; p[b[i].b].f[y]=b[i].a;}\n\t\t}  \n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nint N,M;\nconst int MAX_V = 10000;\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\n\nll Prim(){\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  ll res =0;\n\n  while(1){\n    int v = -1;\n    for(ll u = 0; u < V; ++u){\n      if( !used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n\n    if( v == -1){\n      break;\n    }\n    used[v] = true;\n    res += mincost[v];\n    for(ll u = 0; u < V; ++u){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N >> M && N && M){\n    ll a,b,c;\n    V = N;\n    cost = vector<vector<ll>>(V,vector<ll>(V,inf));\n    rep(i,M){\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    cout << Prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n#define INF 999999\n\nint n, m;\nint a, b, c;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nvoid init()\n{\n\trep(i,100) rep(j,100)\n\t{\n\t\tcost[i][j] = INF;\n\t}\n}\n\nint prim()\n{\n\trep(i,n)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\trep(u,n)\n\t\t{\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\n\t\tinit();\n\n\t\trep(i,m)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tprintf(\"%d?\\n\", prim());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Dset {\n  Dset *parent;\n  int rank;\n\n  Dset() {\n    clear();\n  }\n\n  void clear() {\n    parent = NULL;\n    rank = 0;\n  }\n\n  Dset *find() {\n    if (!parent) {\n      return this;\n    } else {\n      parent = parent->find();\n      return parent;\n    }\n  }\n\n  bool merge(Dset *a) {\n    Dset *myRoot = find();\n    Dset *yourRoot = a->find();\n    if (myRoot->rank < yourRoot->rank) {\n      myRoot->parent = yourRoot;\n    } else if (myRoot->rank > yourRoot->rank) {\n      yourRoot->parent = myRoot;\n    } else if (myRoot != yourRoot) {\n      yourRoot->parent = myRoot;\n      myRoot->rank++;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\nstruct Bridge {\n  int a;\n  int b;\n  int cost;\n  \n  bool operator<(const Bridge &obj) const {\n    return (cost < obj.cost);\n  }\n};\n\nint main() {\n  int n, m, ans;\n  Bridge bridge[100];\n  Dset x[100];\n  while (1) {\n    cin >> n >> m;\n    if (!n && !m) break;\n    for (int i=0; i<m; i++) {\n      cin >> bridge[i].a >> bridge[i].b >> bridge[i].cost;\n    }\n    sort(bridge, bridge+m);\n    for (int i=0; i<m; i++) {\n      x[i].clear();\n    }\n    ans = 0;\n    for (int i=0; i<m; i++) {\n      if (x[bridge[i].a].merge(&x[bridge[i].b])) {\n        ans += bridge[i].cost;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\nconst int INF = (1<<30)-1;\nint main(){\n  int n,m,a,b,c,sum,ma,hiku;\n  priority_queue<PA,vector<PA>,greater<PA> > pq;\n  while(cin >> n >> m,n!=0||m!=0){\n    sum = 0;\n    vector<PA> vec[100];\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      vec[a].push_back(PA(c,b));\n      vec[b].push_back(PA(c,a));\n      sum += c;\n    }\n    bool town[100]={false};\n    hiku = 0;\n    pq.push(PA(0,0));\n    while(!pq.empty()){\n      PA p = pq.top();\n      pq.pop();\n      if(town[p.second]) continue;\n      \n      hiku += p.first;\n      town[p.second] = true;\n      \n      for(int i=0;i<vec[p.second].size();i++){\n\tint to = vec[p.second][i].second;\n\tif(!town[to]) pq.push(PA(vec[p.second][i].first,to));\n      }\n      \n    }\n    printf(\"%d\\n\",hiku);\n  }\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int b[100],m,n,x,y,z;\n  int sm;\n  vector<pair<int,pair<int,int> > > a;\n  while(cin>>n>>m&&n+m){\n    a.clear();\n    for(i=0;i<m;i++){\n      cin>>x>>y>>z;\n      a.push_back(make_pair(z,make_pair(x,y)));\n    }\n    sort(a.begin(),a.end());\n    memset(b,-1,sizeof(b));\n    sm=0;\n    for(i=0;i<m;i++){\n      z=a[i].first;\n      x=a[i].second.first;\n      y=a[i].second.second;\n      if(0){\n      }else if(b[x]==-1&&b[y]==-1){\n\tb[x]=b[y]=i;\n\tsm+=z;\n      }else if(b[x]==-1||b[y]==-1){\n\tb[x]=b[y]=max(b[x],b[y]);\n\tsm+=z;\n      }else if(b[x]!=b[y]){\n\tfor(j=0;j<n;j++){\n\t  if(j!=y&&b[j]==b[y])\n\t    b[j]=b[x];\n\t}\n\tb[y]=b[x];\n\tsm+=z;\n      }\n    }\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n && !m)\n\t\t\tbreak;\n\t\tint bridge[100][100];\n\t\tint a,b,cost;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tbridge[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tbridge[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> b >> cost;\n\t\t\tbridge[a][b] = cost;\n\t\t\tbridge[b][a] = cost;\n\t\t}\n\t\t\n\t\t//ツフツδ債イツド\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint dis = bridge[i][k]+bridge[k][j];\n\t\t\t\t\tif(dis < bridge[i][j]){\n\t\t\t\t\t\tbridge[i][j] = dis;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint min[10000];\n\t\tint pos = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i<j){\n\t\t\t\t\tmin[pos++] = bridge[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(min,min+pos-1);\n\t\tint sum = 0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tsum+=min[i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct Edge {\n\tint src, dst, cost;\n\tEdge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n\tEdge(){}\n\tbool operator< (const Edge& e)const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nstruct UnionFind{\n\tvi par, rank;\n\tUnionFind(int n) : par(n), rank(n, 0) {\n\t\trep(i, n)\n\t\t\tpar[i] = i;\n\t}\n\n\tint find(int a){\n\t\treturn par[a] == a ? a : (par[a] = find(par[a]));\n\t}\n\n\tbool same(int a, int b){\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid unite(int a, int b){\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a == b)\n\t\t\treturn;\n\n\t\tif(rank[a] < rank[b])\n\t\t\tpar[a] = b;\n\t\telse\n\t\t\tpar[b] = a;\n\t\trank[a] += rank[a] == rank[b];\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tvector<Edge> E(m);\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tE[i] = Edge(a, b, c);\n\t\t}\n\t\tsort(E.begin(), E.end());\n\n\t\tint cost = 0;\n\t\tUnionFind uf(n);\n\t\trep(i, m){\n\t\t\tif(!uf.same(E[i].src, E[i].dst)){\n\t\t\t\tuf.unite(E[i].src, E[i].dst);\n\t\t\t\tcost += E[i].cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long ll;\n// using i32=int;using i64=long long;using ll =i64;\n// using uint=unsigned int;using ull=unsigned long long;\n// template<typename T> using matrix=vector<vector<T> >;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\nCost prim(Graph g,int s){\n\tconst int V=g.size();\n\tvector<bool> visited(V);\n\tpriority_queue<Edge,vector<Edge>,greater<Edge>> que;que.push(Edge(-1,s,0));\n\tCost res=0;\n\twhile(!que.empty()){\n\t\tEdge task=que.top();que.pop();\n\t\tint pos=task.t;\n\t\tif(visited[pos])continue;\n\t\tvisited[pos]=true;\n\t\tres+=task.c;\n\t\tfor(Edge e:g[pos])if(!visited[e.t])que.push(e);\n\t}\n\treturn res;\n}\n\n\nll INF=1LL<<58;\nclass Main{\npublic:\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint N,M;cin >>N >>M;if(N==0)break;\n\t\t\tGraph g(N);\n\t\t\tREP(i,M){\n\t\t\t\tint f,t,c;cin >> f >> t >> c;\n\t\t\t\tg[f].push_back(Edge(f,t,c));\n\t\t\t\tg[t].push_back(Edge(t,f,c));\n\t\t\t}\n\t\t\tcout << prim(g,0)<<endl;\n\t\t}\n\t}\n};\nint main(){\n  \tMain().run();\n  \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n// UnionFind??¨ ??????????????????\nclass UnionFindTree{\npublic:\n  UnionFindTree();\n  UnionFindTree(int size);\n  void init(int size);\n  void unite(int a, int b);\n  bool same(int a, int b);\n  bool isConnected(void);\nprivate:\n  int m_size, unite_count;\n  vector<int> parent;\n  vector<int> rank;\n  int find(int a);\n};\n\n// ?????????????????????\nUnionFindTree::UnionFindTree(){};\nUnionFindTree::UnionFindTree(int size){ init(size); };\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  m_size = size;\n  unite_count = 0;\n  parent.clear();\n  rank.clear();\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n  }\n  return;\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  unite_count++;\n  if(rank[x] < rank[y]){ parent[x] = y; }\n  else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// UF??¨??§?????????????????????????????¨???????????????????????????\nbool UnionFindTree::isConnected(void){\n  return unite_count == m_size - 1;\n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// ?????????????????? ?????????\n// v: ????????°, adjlist: ??£??\\?????????(first: ???????????????, second: ?????????)\nvector<pair<int, pair<int, int> > > kruskal_pre(int v, vector<vector<pair<int, int> > > adjlist){\n  vector<pair<int, pair<int, int> > > edge; // first: ???????????????, second: ???????????????\n  for(int i = 0; i < v; i++)\n    for(int j = 0; j < adjlist[i].size(); j++)\n      edge.push_back(make_pair(adjlist[i][j].first, make_pair(i, adjlist[i][j].second)));\n  sort(edge.begin(), edge.end());\n\n  return edge; // ?????????: ???????????????????????????\n}\n\n// ?????????????????¬??????\n// v: ????????°, edge: ???????????????????????????(first: ???????????????, second: ???????????????)\nint kruskal(int v, vector<pair<int, pair<int, int> > > edge){\n  int length = 0; // ??¨????????????\n  UnionFindTree uf(v); // UF??¨?????£?¨???¨?????????\n\n  // ???????????????????????????????????????????????????????????£?????????????????§?????????\n  for(int i = 0; i < edge.size() && !uf.isConnected(); i++){\n    // i??????????°???????????????????\n    int cost = edge[i].first;\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.same(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    uf.unite(a, b);\n    length += cost;\n  }\n\n  return length; // ?????????: ??¨????????????\n}\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n    \n    int a, b, cost;\n    vector<pair<int, pair<int, int> > > edgelist(n);\n    for(int i = 0; i < m; i++){\n      cin >> a >> b >> cost;\n      edgelist.push_back(make_pair(cost, make_pair(a, b)));\n    }\n    sort(edgelist.begin(), edgelist.end());\n    \n    cout << kruskal(n, edgelist) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, n) for (int i = s; i < n; ++i)\n#define rep(i, n) REP(i, 0, n)\n#define SORT(c) sort((c).begin(), (c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n#define DEBUG false\n\n#define MAX_V 100\n#define INF INT_MAX\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prim(){\n    for(int i=0;i<V;++i){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    int res=0;\n    while(true){\n        int v=-1;\n        rep(u,V){\n            if(!used[u] && (v==-1 || mincost[u] <mincost[v])) v=u;\n        }\n        if(v==-1) break;\n        used[v]= true;\n        res+=mincost[v];\n        rep(u,V){\n            mincost[u]=min(mincost[u],cost[v][u]);\n        }\n    }\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0&&m==0){\n            break;\n        }\n        V=n;    \n    rep(i,MAX_V){\n        rep(j,MAX_V){\n            cost[i][j]=INF;\n        }\n    }\n    int a,b,c;\n    rep(i,m){\n        cin>>a>>b>>c;\n        cost[a][b]=c;\n        cost[b][a]=c;\n    }\n    cout<<prim()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\n-- templete\n\nnewUF n = newArray (0,n-1) (-1)\n\nroot uf i = do\n  c <- readArray uf i\n  if c==(-1) then return i else root uf c >>= writeArray uf i >> readArray uf i\n\nsame uf i j = (==) <$> root uf i <*> root uf j\n\nunite uf i j = root uf i >>= writeArray uf j\n\nkruskal n es = runST $ do\n    uf <- newUF n :: ST s (STUArray s Int Int)\n    cost <- newSTRef 0\n    forM_ es $ \\(c, (a, b)) -> do\n      s <- same uf a b\n      unless s $ do\n          modifySTRef cost (+c)\n          unite uf a b\n    readSTRef cost\n\ntype Edge = (Int, (Int,Int))\nedge a b cost = (cost, (a, b))\n\nmain = do\n    [n, m] <- getInts\n    when (n/=0 || m/=0) $ do\n        es <- sortBy (compare) . map (apply3 edge) <$> replicateM m getInts\n        print $ kruskal n es\n        main\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Data.Array.Unboxed\n\nmain :: IO ()\nmain = do\n  [n,m] <- getl $ wrds toInt\n  unless (n == 0 && m == 0) $ do\n    solve n <$> replicateM m (getl $ wrds toInt) >>= print\n    main\n    \nsolve :: Int -> [[Int]] -> Int\nsolve n xs = mst am [0] [1..n-1] 0\n  where\n    ia = listArray ((0,0),(n-1,n-1)) $ repeat 10000 :: UArray (Int,Int) Int\n    am = foldl (\\ar [i,j,c] -> ar // [((i,j),c),((j,i),c)]) ia xs\n\nmst :: UArray (Int,Int) Int -> [Int] -> [Int] -> Int -> Int\nmst am us [] mnc = mnc\nmst am us vs mnc = mst am (nu:us) (vs \\\\ [nu]) (mnc+tc)\n  where\n    (tc,nu) = minimum [(am ! (u,v), v)|u <- us, v <- vs]\n\ntoInt :: String -> Int\ntoInt s = read s\n\nwrds :: (String -> a) -> String -> [a]\nwrds f = map f . words\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\n-- templete\n\nnewUF n = newArray (0,n-1) (-1)\n\nroot uf i = do\n  c <- readArray uf i\n  if c==(-1) then return i else root uf c >>= writeArray uf i >> readArray uf i\n\nsame uf i j = (==) <$> root uf i <*> root uf j\n\nunite uf i j = root uf i >>= writeArray uf j\n\nkruskal n es = runST $ do\n    uf <- newUF n :: ST s (STUArray s Int Int)\n    cost <- newSTRef 0\n    forM_ es $ \\(c, (a, b)) -> do\n      s <- same uf a b\n      unless s $ do\n          modifySTRef cost (+c)\n          unite uf a b\n    readSTRef cost\n\ntype Edge = (Int, (Int,Int))\nedge a b cost = (cost, (a, b))\n\nmain = do\n    [n, m] <- getInts\n    when (n/=0 || m/=0) $ do\n        es <- sort . map (apply3 edge) <$> replicateM m getInts\n        print $ kruskal n es\n        main\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\nmain :: IO ()\nmain = do\n  nm <- getLine\n  if nm == \"0 0\"\n    then return ()\n    else do\n      let [n,m] = map (read :: String -> Int) (words nm)\n      ls <- replicateM m getLine\n      let ls' = lastSort (map (map (read :: String -> Int)) (map words ls))\n          points = [(x,x) | x <- [0..(n-1)]]\n          ans = solve points ls'\n      putStrLn $ show ans\n      main\n\nlastSort :: [[Int]] -> [[Int]]\nlastSort [] = []\nlastSort (x:xs) = (lastSort lower) ++ [x] ++ (lastSort higher)\n  where lower = filter (\\y -> (last y) <= (last x)) xs\n        higher = filter (\\y -> (last y) > (last x)) xs\n\nsolve :: [(Int,Int)] -> [[Int]] -> Int\nsolve points ls' = foldl f 0 (loop points ls' [])\n  where f :: Int -> [Int] -> Int\n        f acc ls = acc + (last ls)\n\nloop :: [(Int,Int)] -> [[Int]] -> [[Int]] -> [[Int]]\n--loop points bridges used\nloop _ [] used = used\nloop points ([p1,p2,cost]:bs) used\n  | isConect p1 p2 points = loop points bs used\n  | otherwise = loop (update points [p1,p2,cost]) bs ([p1,p2,cost]:used)\n  where\n    getBelong :: Int -> [(Int,Int)] -> Int\n    getBelong i (p:ps)\n      | i == (fst p) = (snd p)\n      | otherwise = getBelong i ps\n      \n    isConect :: Int -> Int -> [(Int,Int)] -> Bool\n    isConect p1 p2 points = ((getBelong p1 points) == (getBelong p2 points))\n    \n    update :: [(Int,Int)] -> [Int] -> [(Int,Int)]\n    update [] _ = []\n    update ((n,b):ps) [i1,i2,cost]\n      | b == belong2 = (n,belong1):(update ps [i1,i2,cost])\n      | otherwise = (n,b):(update ps [i1,i2,cost])\n      where belong1 = getBelong i1 points\n            belong2 = getBelong i2 points"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(a,b) (((a)<(b))?(a):(b))\n#define INF 10000000\n\nint cost[100][500];\nint mincost[500];\nint used[500];\n\nint main(void)\n{\n\tint n, m,a,b,c;\n\tint i,j;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0 && m == 0)break;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i == j)cost[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tfor ( i = 0; i < n; i++) {\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = 0;\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\n\t\twhile (1) {\n\t\t\tint v = -1;\n\t\t\tint u;\n\t\t\tfor (u = 0; u < n; u++) {\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t\t}\n\t\t\tif (v == -1)break;\n\t\t\tused[v] = 1;\n\t\t\tres += mincost[v];\n\n\t\t\tfor (u = 0; u < n; u++)\n\t\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 10000000\n\nint cost[100][500];\nint mincost[500];\nint used[500];\n\nint main(void)\n{\n\tint n, m,a,b,c;\n\tint i,j;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0 && m == 0)break;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (i == j)cost[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = 0;\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\n\t\twhile (1) {\n\t\t\tint v = -1;\n\t\t\tint u;\n\t\t\tfor (u = 0; u < n; u++) {\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t\t}\n\t\t\tif (v == -1)break;\n\t\t\tused[v] = 1;\n\t\t\tres += mincost[v];\n\n\t\t\tfor (u = 0; u < n; u++)\n\t\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint N,M,t[101],i,j,r;\ntypedef struct e{int f,t,c;}e;\ne B[101];\nint cmp(const void *a,const void *b){e x=*(e*)a,y=*(e*)b;return x.c-y.c;}\nvoid in(n){for(;n--;)t[n]=n;}\nint p(n){return t[n]==n?n:p(t[n]);}\nvoid u(a,b){t[p(a)]=p(b);}\nint s(a,b){return p(a)==p(b);}\n\nmain()\n{\n\tfor(;scanf(\"%d%d\",&N,&M)&&N;)\n\t{\n\t\tin(N);\n\t\tfor(i=r=0;i<M;i++)\n\t\t\tscanf(\"%d%d%d\",&B[i].f,&B[i].t,&B[i].c);\n\t\tqsort(B,M,sizeof(e),cmp);\n\t\tfor(i=0;i<M;i++)\n\t\t\tif(!s(B[i].f,B[i].t))\n\t\t\t{\n\t\t\t\tu(B[i].f,B[i].t);\n\t\t\t\tr+=B[i].c;\n\t\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes;\n\t\tint mincost[100] = {0};\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost;\n\n\t\t// initialize cost table\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// load\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d;\n\t\t}\n\n\t\t// node 0 is determined\n\t\tdetermined[0] = 1;\n\t\tundeterminednodes = n-1;\n\n\t\t// initialize mincost\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tif(!determined[i]) {\n\t\t\t\tmincost[i] = cost[0][i];\n\t\t\t} else {\n\t\t\t\tmincost[i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\t// select the nearest undetermined node\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the node is determined\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\n\t\t\t// update mincost\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint n, m;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nint prim(int start) {\n    int x, p, step, sum = 0;\n\n    for (x = 0; x < n; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= n; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < n; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tsum += minimum;\n\tfor (x = 0 ; x < n; x++)\n\t    if (vertex[x].state == 0)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n    return sum;\n}\n\nint main(void) {\n    int i, j;\n    int from, to, cost;\n     \n    while (1) {\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n        if (n == 0) break;\n         \n        for (i = 0; i < n; i++)\n            for (j = 0; j < n; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &from, &to, &cost);\n            W[from][to] = cost;\n\t    W[to][from] = cost;\n        }\n\n\tprintf(\"%d\\n\", prim(0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000\nint cost[101][101],mincost[101],used[101],V;\n\nint prim(void);\nint min(int,int);\n\nint main(void){\n  int e,i,j,a,b,cos;\n\n  while(scanf(\"%d %d\",&V,&e),V,e){\n    for(i=0;i<V;i++){\n      for(j=0;j<V;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n    for(i=0;i<e;i++){\n      scanf(\"%d %d %d\",&a,&b,&cos);\n      cost[a][b]=cos;\n    }\n    printf(\"%d\\n\",prim());\n}\n  return 0;\n}\n\nint prim(void){\n  int i,u,v;\n  for(i=0;i<V;i++){\n    mincost[i]=INF;\n    used[i]=0;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(1){\n    v=-1;\n    \n    for(u=0;u<V;u++)\n      if(!used[u] && (v==-1 || mincost[v]>mincost[u]))v=u;\n    \n    if(v==-1)break;\n    used[v]=1;\n    res+=mincost[v];\n    \n    for(u=0;u<V;u++)\n      mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  \n  return res;\n}\n\nint min(int x,int y){\n  return x<y?x:y;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF (1000000000)\n\nint v[100];\nint dist[100];\nint cost[100][100];\nint n, m;\n\nint prim(void)\n{\n    int i, j;\n    int temp;\n    int res;\n    \n    for (i = 0; i < n; i++){\n        v[i] = 0;\n    }\n    \n    res = 0;\n    dist[0] = 0;\n    while (1){\n        temp = -1;\n        for (i = 0; i < n; i++){\n            if (v[i] == 0 && (temp == -1 || dist[i] < dist[temp])){\n                temp = i;\n            }\n        }\n        \n        if (temp == -1){\n            break;\n        }\n        \n        v[temp] = 1;\n        \n        res += dist[temp];\n        \n        for (i = 0; i < n; i++){\n            dist[i] = dist[i] > cost[temp][i] ? cost[temp][i] : dist[i];\n        }\n    }\n    \n    return (res);\n}\n\nint main(void)\n{\n    int i, j;\n    int a, b, tcost;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            dist[i] = INF;\n            for (j = 0; j < n; j++){\n                cost[i][j] = INF;\n            }\n            cost[i][i] = 0;\n        }\n        \n        for (i = 0; i < m; i++){\n            scanf(\"%d%d%d\", &a, &b, &tcost);\n            cost[a][b] = cost[b][a] = tcost;\n        }\n        \n        printf(\"%d\\n\", prim());\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000\nint edge[101][101],mincost[101],used[101],V;\n\nint prim(void);\nint min(int,int);\n\nint main(void){\n  int e,i,j,a,b,cost;\n\n  while(scanf(\"%d %d\",&V,&e),V,e){\n    for(i=0;i<V;i++){\n      for(j=0;j<V;j++){\n\tedge[i][j]=edge[j][i]=INF;\n      }\n    }\n    \n    for(i=0;i<e;i++){\n      scanf(\"%d %d %d\",&a,&b,&cost);\n      edge[a][b]=edge[b][a]=cost;\n    }\n    printf(\"%d\\n\",prim());\n}\n  return 0;\n}\n\nint prim(void){\n  int i,u,v;\n  for(i=0;i<V;i++){\n    mincost[i]=INF;\n    used[i]=0;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(1){\n    v=-1;\n    \n    for(u=0;u<V;u++)\n      if(!used[u] && (v==-1 || mincost[v]>mincost[u]))v=u;\n    \n    if(v==-1)break;\n    used[v]=1;\n    res+=mincost[v];\n    \n    for(u=0;u<V;u++)\n      mincost[u]=min(mincost[u],edge[v][u]);\n  }\n  \n  return res;\n}\n\nint min(int x,int y){\n  return x<y?x:y;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0000\nTitle\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define TOWN 100\n#define MAXBRIDGE (TOWN*(TOWN-1)/2)\nint n,m;\nstruct b_st {int a;  //from\n  int b;             //to\n  int cost;} bridge[MAXBRIDGE];\nint c_f[TOWN];\n//\ncomp(void *a,void *b)\n{\n  return(((struct b_st *)a)->cost - ((struct b_st *)b)->cost);\n}\nint nearest(int * t_cost)\n{\n  int i;\n\n  for(i=0;i<m;i++)\n    if(c_f[bridge[i].a]+c_f[bridge[i].b]==1)\n      {\n\t*t_cost += bridge[i].cost;\n#ifdef DEBUG\n\tprintf(\"%d %d %d\\n\",bridge[i].a,bridge[i].b,bridge[i].cost);\n#endif\n\tif(c_f[bridge[i].a])\n\t  return(bridge[i].b);\n\telse\n\t  return(bridge[i].a);\n     }\n}\nint total_cost()\n{\n  int i,t,t_cost;\n  \n  c_f[0]=1;t_cost=0;\n  for(i=1;i<n;i++)\n    {\n      t=nearest(&t_cost);\n      c_f[t]=1;\n    }\n  return(t_cost);\n}\nmain()\n{\n  int i;\n  int ret;\n\n  while(EOF!=scanf(\"%d %d\",&n,&m) && (n||m))\n    {\n      for(i=0;i<m;i++)\n\tscanf(\"%d %d %d\",&(bridge[i].a),&(bridge[i].b),&(bridge[i].cost));\n      memset(c_f,0,sizeof(c_f));\n      qsort(bridge,m,sizeof(struct b_st),(__compar_fn_t)comp);\n      ret=total_cost();\n      printf(\"%d\\n\",ret);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];j,s,t,m,n,*p;main(i){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[i][j]=d[j][i]=s)scanf(\"%d%d%d\",&i,&j,&s);for(s=i=0;++i-n;s+=d[t=m][n])for(d[t][j=m=n]=0;j--;*p&&d[m][n]>*p?m=j:0)p=d[j]+n,*p=fmin(*p,p[t-n]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint N,M,t[101],i,j,r;\ntypedef struct e{int f,t,c;}e;\ne B[101];\nint cmp(const void *a,const void *b){e x=*(e*)a,y=*(e*)b;return x.c-y.c;}\nvoid in(n){for(;n--;)t[n]=n;}\nint p(n){return t[n]==n?n:p(t[n]);}\nvoid u(a,b){t[p(a)]=p(b);}\nint s(a,b){return p(a)==p(b);}\n\nmain()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tin(N);\n\t\tfor(i=r=0;i<M;i++)\n\t\t\tscanf(\"%d%d%d\",&B[i].f,&B[i].t,&B[i].c);\n\t\tqsort(B,M,sizeof(e),cmp);\n\t\tfor(i=0;i<M;i++)\n\t\t\tif(!s(B[i].f,B[i].t))\n\t\t\t{\n\t\t\t\tu(B[i].f,B[i].t);\n\t\t\t\tr+=B[i].c;\n\t\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0180: Demolition of Bridges\n// 2017.8.9\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x77777777\n#define MAX 100\n#define EMAX 500\nint n;\ntypedef struct { int b, c; } ND;\nND d[MAX + 2][MAX + 2];\nint w[MAX + 2];\nint visited[MAX];\n\nint qsize;\ntypedef struct { int a, b, c; } QUE;\nQUE que[EMAX + 1];\n\n#define PARENT(i) ((i)/2)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nstatic void min_heapify(int i)\n{\n\tint l, r, smallest;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].c < que[i].c) smallest = l; else smallest = i;\n\tif (r < qsize && que[r].c < que[smallest].c) smallest = r;\n\tif (smallest != i) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + smallest, sizeof(QUE));\n\t\tmemcpy(que + smallest, &t, sizeof(QUE));\n\t\tmin_heapify(smallest);\n\t}\n}\n\nint deq(QUE *q)\n{\n\tif (qsize == 0) return -1;\n\tmemcpy(q, &que[0], sizeof(QUE));\n\tmemcpy(que, que + --qsize, sizeof(QUE));\n\tmin_heapify(0);\n\treturn 1;\n}\n\nvoid enq(QUE *q)\n{\n\tint i;\n\n\ti = qsize++;\n\tmemcpy(que + i, q, sizeof(QUE));\n\twhile (i > 0 && que[PARENT(i)].c > que[i].c) {\n\t\tQUE t;\n\t\tmemcpy(&t, que + i, sizeof(QUE)), memcpy(que + i, que + PARENT(i), sizeof(QUE));\n\t\tmemcpy(que + PARENT(i), &t, sizeof(QUE));\n\t\ti = PARENT(i);\n\t}\n}\n\n\nint main()\n{\n\tint m, a, b, c;\n\tint i, k, ans;\n\tQUE q;\n\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n, &m); if (!n) return 0;\n\t\tmemset(w, 0, sizeof(w));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\td[a][w[a]].b = b, d[a][w[a]++].c = c;\n\t\t\td[b][w[b]].b = a, d[b][w[b]++].c = c;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, k = 1, qsize = 0;\n\t\tfor (i = 0; i < w[0]; i++) q.a = 0, q.b = d[0][i].b, q.c = d[0][i].c, enq(&q);\n\t\twhile (k < n) {\n\t\t\tdo deq(&q);\n\t\t\twhile (visited[q.a] && visited[q.b]);\n\t\t\tk++;\n\t\t\ta = visited[q.a] ? q.b : q.a;\n\t\t\tvisited[a] = 1, ans += q.c;\n\t\t\tfor (i = 0; i < w[a]; i++) {\n\t\t\t\tb = d[a][i].b;\n\t\t\t\tif (!visited[b]) q.a = a, q.b = b, q.c = d[a][i].c, enq(&q);\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint N,M,t[101],i,j,r;\ntypedef struct e{int f,t,c;}e;\ne B[101];\nint cmp(const void *a,const void *b){e x=*(e*)a,y=*(e*)b;return x.c-y.c;}\nvoid in(n){for(;n--;)t[n]=n;}\nint p(n){return t[n]=t[n]==n?n:p(t[n]);}\nvoid u(a,b){t[p(a)]=p(b);}\nint s(a,b){return p(a)==p(b);}\n\nmain()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N,M;)\n\t{\n\t\tin(N);\n\t\tfor(i=r=0;i<M;i++)\n\t\t\tscanf(\"%d%d%d\",&B[i].f,&B[i].t,&B[i].c);\n\t\tqsort(B,M,sizeof(e),cmp);\n\t\tfor(i=0;i<M;i++)\n\t\t\tif(!s(B[i].f,B[i].t))\n\t\t\t{\n\t\t\t\tu(B[i].f,B[i].t);\n\t\t\t\tr+=B[i].c;\n\t\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint a,b;\n\tint cost;\n} bridge_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst bridge_t* a=(const bridge_t*)x;\n\tconst bridge_t* b=(const bridge_t*)y;\n\tif((a->cost)>(b->cost))return 1;\n\tif((a->cost)<(b->cost))return -1;\n\treturn 0;\n}\n\nint tosi_num,bridge_num;\nbridge_t* bridge_list;\n\nint tosi_uf[100];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<100;i++)tosi_uf[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\tint rank_a=0,rank_b=0;\n\twhile(tosi_uf[a]>0) {\n\t\tnext=tosi_uf[a]-1;\n\t\ttosi_uf[a]=tosi_uf[next];\n\t\ta=next;\n\t\trank_a++;\n\t}\n\twhile(tosi_uf[b]>0) {\n\t\tnext=tosi_uf[b]-1;\n\t\ttosi_uf[b]=tosi_uf[next];\n\t\tb=next;\n\t\trank_b++;\n\t}\n\tif(a!=b) {\n\t\tif(rank_a<=rank_b)tosi_uf[a]=b+1;\n\t\telse tosi_uf[b]=a+1;\n\t}\n}\n\nint uf_isgroup(int a,int b) {\n\tint next;\n\twhile(tosi_uf[a]>0) {\n\t\tnext=tosi_uf[a]-1;\n\t\ttosi_uf[a]=tosi_uf[next];\n\t\ta=next;\n\t}\n\twhile(tosi_uf[b]>0) {\n\t\tnext=tosi_uf[b]-1;\n\t\ttosi_uf[b]=tosi_uf[next];\n\t\tb=next;\n\t}\n\treturn (a==b)?1:0;\n}\n\nint main(void) {\n\tint i,j;\n\tint result;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&tosi_num,&bridge_num);\n\t\tif(tosi_num==0 && bridge_num==0)break;\n\t\tbridge_list=malloc(bridge_num*sizeof(bridge_t));\n\t\tif(bridge_list==NULL)return 1;//error\n\t\tfor(i=0;i<bridge_num;i++) {\n\t\t\tscanf(\"%d%d%d\",\n\t\t\t\t&bridge_list[i].a,&bridge_list[i].b,\n\t\t\t\t&bridge_list[i].cost);\n\t\t}\n\t\tqsort(bridge_list,bridge_num,sizeof(bridge_t),qsort_comp);\n\t\tuf_init();\n\t\tresult=0;\n\t\tfor(i=0,j=1;i<bridge_num && j<tosi_num;i++) {\n\t\t\tif(!uf_isgroup(bridge_list[i].a,bridge_list[i].b)) {\n\t\t\t\tuf_merge(bridge_list[i].a,bridge_list[i].b);\n\t\t\t\tresult+=bridge_list[i].cost;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tfree(bridge_list);\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint n,m,i,j,x,y,ans,order[100000],buc[101],brig[100000][3],node[10000];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nint main(){\n\tbuc[0]=-1;\n\twhile(scanf(\"%d %d\",&n,&m)*n){\n\t\tfor(i=1;i<101;i++)buc[i]=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d %d\",&brig[i][0],&brig[i][1],&brig[i][2]);\n\t\t\tif(brig[i][0]>brig[i][1])swap(&brig[i][0],&brig[i][1]);\n\t\t\tbuc[brig[i][2]]++;\n\t\t}\n\t\tfor(i=1;i<101;i++)buc[i]+=buc[i-1];\n\t\tfor(i=m-1;i>=0;i--){\n\t\t\torder[buc[brig[i][2]]]=i;\n\t\t\tbuc[brig[i][2]]--;\n\t\t}\n\t\tfor(i=0;i<n;i++)node[i]=i;\n\t\t\n\t\tm=n-1;i=0;ans=0;\n\t\twhile(m>0){\n\t\t\tx=node[brig[order[i]][0]];\n\t\t\ty=node[brig[order[i]][1]];\n\t\t\tif(x!=y){\n\t\t\t\tm--;ans+=brig[order[i]][2];\n\t\t\t\tfor(j=0;j<n;j++){if(node[j]==y)node[j]=x;}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];j,s,t,m,n,*p;main(i){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[i][j]=d[j][i]=s)scanf(\"%d%d%d\",&i,&j,&s);for(s=i=0;++i-n;s+=d[n][t=m])for(d[j=m=n][t]=0;j--;*p&&d[n][m]>*p?m=j:0)p=d[n]+j,*p=fmin(*p,d[t][j]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[110],b[110],c[110],r[110],i,j,k,s,t;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int p[110]={0};\n    for(i=s=0;i<m;i++){\n      scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n      for(j=r[i]=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    for(i=0;i<m;i++){//printf(\"%d\\n\",c[r[i]]);\n      for(j=a[r[i]]+1;p[j];j=p[j]);\n      for(k=b[r[i]]+1;p[k];k=p[k]);\n      if(j-k){\n\tp[j]=k;\n\ts+=c[r[i]];\n      }\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "c[100][100];n,m;u,t,l,x,y;main(){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",l)){int d[100]={0};for(memset(c,9,40000);m--;c[u][l]=c[l][u]=t)scanf(\"%d%d%d\",&u,&l,&t);x=y=l=0;for(u=n;u--;x=t)for(d[x]=1,l+=y,y=x[*c]=**c,m=n;m--;m[*c]<y&&(t=m,y=m[*c]))!d[m]&&c[x][m]<m[*c]&&(m[*c]=c[x][m]);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(x,y) ((x<y)?(x):(y))\nint main(){\n\tint n,m,c[105][105],i,j,a,b,x;\n\tint used[105],v[105],ans;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0)break;\n\t\tfor(i=0;i<n;i++)for(j=0;j<n;j++)c[i][j]=10000000;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&x);\n\t\t\tc[a][b]=c[b][a]=x;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tv[i]=10000000;\n\t\t\tused[i]=0;\n\t\t}\n\t\tans=0;v[0]=0;\n\t\twhile(1){\n\t\t\tx=-1;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(used[i]==0 && (x==-1 || v[i]<v[x]))x=i;\n\t\t\t}\n\t\t\tif(x==-1)break;\n\t\t\tused[x]=1;\n\t\t\tans+=v[x];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tv[i]=min(v[i],c[x][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint a,b;\n\tint cost;\n} bridge_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst bridge_t* a=(const bridge_t*)x;\n\tconst bridge_t* b=(const bridge_t*)y;\n\tif((a->cost)>(b->cost))return 1;\n\tif((a->cost)<(b->cost))return -1;\n\treturn 0;\n}\n\nint tosi_num,bridge_num;\nbridge_t* bridge_list;\n\nint tosi_uf[100];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<100;i++)tosi_uf[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\tint rank_a=0,rank_b=0;\n\twhile(tosi_uf[a]>0) {\n\t\tnext=tosi_uf[a]-1;\n\t\tif(tosi_uf[next]>0)tosi_uf[a]=tosi_uf[next];\n\t\ta=next;\n\t\trank_a++;\n\t}\n\twhile(tosi_uf[b]>0) {\n\t\tnext=tosi_uf[b]-1;\n\t\tif(tosi_uf[next]>0)tosi_uf[b]=tosi_uf[next];\n\t\tb=next;\n\t\trank_b++;\n\t}\n\tif(a!=b) {\n\t\tif(rank_a<=rank_b)tosi_uf[a]=b+1;\n\t\telse tosi_uf[b]=a+1;\n\t}\n}\n\nint uf_isgroup(int a,int b) {\n\tint next;\n\twhile(tosi_uf[a]>0) {\n\t\tnext=tosi_uf[a]-1;\n\t\tif(tosi_uf[next]>0)tosi_uf[a]=tosi_uf[next];\n\t\ta=next;\n\t}\n\twhile(tosi_uf[b]>0) {\n\t\tnext=tosi_uf[b]-1;\n\t\tif(tosi_uf[next]>0)tosi_uf[b]=tosi_uf[next];\n\t\tb=next;\n\t}\n\treturn (a==b)?1:0;\n}\n\nint main(void) {\n\tint i,j;\n\tint result;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&tosi_num,&bridge_num);\n\t\tif(tosi_num==0 && bridge_num==0)break;\n\t\tbridge_list=malloc(bridge_num*sizeof(bridge_t));\n\t\tif(bridge_list==NULL)return 1;//error\n\t\tfor(i=0;i<bridge_num;i++) {\n\t\t\tscanf(\"%d%d%d\",\n\t\t\t\t&bridge_list[i].a,&bridge_list[i].b,\n\t\t\t\t&bridge_list[i].cost);\n\t\t}\n\t\tqsort(bridge_list,bridge_num,sizeof(bridge_t),qsort_comp);\n\t\tuf_init();\n\t\tresult=0;\n\t\tfor(i=0,j=1;i<bridge_num && j<tosi_num;i++) {\n\t\t\tif(!uf_isgroup(bridge_list[i].a,bridge_list[i].b)) {\n\t\t\t\tuf_merge(bridge_list[i].a,bridge_list[i].b);\n\t\t\t\tresult+=bridge_list[i].cost;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tfree(bridge_list);\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,i,j,k,x,y,co;\n\tint a[5000],b[5000],cost[5000];\n\tint size[100],root[100];\n\tint wk,sum;\n\t\n\twhile(1)\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0 && m==0)\tbreak;\n\t\tfor(i=0;i<m;i++)\t{\n\t\t\tscanf(\"%d %d %d\",&a[i],&b[i],&cost[i]);\n\t\t}\n\t\tfor(i=0;i<m-1;i++)\t{\n\t\t\tfor(j=i+1;j<m;j++)\t{\n\t\t\t\tif(cost[i]>cost[j])\t{\n\t\t\t\t\twk=cost[i];\tcost[i]=cost[j];\tcost[j]=wk;\n\t\t\t\t\twk=a[i];\ta[i]=a[j];\ta[j]=wk;\t\n\t\t\t\t\twk=b[i];\tb[i]=b[j];\tb[j]=wk;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\troot[i]=i;\n\t\t\tsize[i]=1;\n\t\t}\n\t\tsum=0;\n\t\tfor(i=0;i<m;i++)\t{\n\t\t\tx=a[i];\ty=b[i];\tco=cost[i];\n\t\t\twhile(root[x]!=x)\tx=root[x];\n\t\t\twhile(root[y]!=y)\ty=root[y];\n\t\t\tif(x!=y)\t{\n\t\t\t\tsum+=co;\n\t\t\t\tif(size[x]>size[y])\t{\n\t\t\t\t\troot[y]=x;\n\t\t\t\t}\n\t\t\t\telse if(size[x]<size[y])\t{\n\t\t\t\t\troot[x]=y;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troot[x]=y;\n\t\t\t\t\tsize[y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[11000],b[11000],c[11000],r[11000],i,j,k,s,t;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int p[110]={0};\n    for(i=s=0;i<m;i++){\n      scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n      for(j=r[i]=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    for(i=0;i<m;i++){//printf(\"%d\\n\",c[r[i]]);\n      for(j=a[r[i]]+1;p[j];j=p[j]);\n      for(k=b[r[i]]+1;p[k];k=p[k]);\n      if(j-k){\n\tp[j]=k;\n\ts+=c[r[i]];\n      }\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint n, m;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nint prim(int start) {\n    int x, p, step, sum = 0;\n\n    for (x = 0; x < n; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= n; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < n; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tsum += minimum;\n\tfor (x = 0 ; x < n; x++)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n    return sum;\n}\n\nint main(void) {\n    int i, j;\n    int from, to, cost;\n     \n    while (1) {\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n        if (n == 0) break;\n         \n        for (i = 0; i < n; i++)\n            for (j = 0; j < n; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &from, &to, &cost);\n            W[from][to] = cost;\n\t    W[to][from] = cost;\n        }\n\n\tprintf(\"%d\\n\", prim(0));\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\t\n\t\t\tKruskal.V = n;\n\t\t\tKruskal.E = m;\n\t\t\tKruskal.es = new Edge[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tKruskal.es[i] = new Edge(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tint ans = Kruskal.kruskal();\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n\nclass Kruskal {\n\tstatic Edge[] es;\n\tstatic int V;\n\tstatic int E;\n\t\n\tpublic static int kruskal() {\n\t\tArrays.sort(es,new Comp());\n\t\tinit(V);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif(!same(e.u,e.v)) {\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int[] par ;\n\tstatic int[] rank ;\n\t\n\tstatic void init(int n) {\n\t\tpar = new int[V];\n\t\trank = new int[V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x) {\n\t\tif(par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\t\n}\n\nclass Edge {\n\tint u;\n\tint v;\n\tint cost;\n\tEdge(int a, int b, int c) {\n\t\tu = a;\n\t\tv = b;\n\t\tcost = c;\n\t}\n}\n\n\nclass Comp implements Comparator<Edge> {\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn o1.cost - o2.cost;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] cost = new int[m][3];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tcost[i][j] = scanner.nextInt();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t\tArrays.sort(cost, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\t\treturn a[2] - b[2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = cost[i][0];\n\t\t\t\tint b = cost[i][1];\n\t\t\t\ta = root(a, p);\n\t\t\t\tb = root(b, p);\n\t\t\t\tif (a == b) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmerge(a, b, p);\n\t\t\t\tans += cost[i][2];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate static void merge(int a, int b, int[] p) {\n\t\t/*a = root(a, p);\n\t\tb = root(b, p);*/\n\t\tp[a] = b;\n\t}\n\n\tprivate static int root(int a, int[] p) {\n\t\tif (a == p[a]) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn p[a] = root(p[a], p);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n, m;\n\tstatic int[][] cost;\n\tstatic int[] mincost;\n\tstatic boolean[] used;\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)return false;\n\t\tcost = new int[n][n];\n\t\tmincost = new int[n];\n\t\tused = new boolean[n];\n\t\tfor(int[] formatting: cost)Arrays.fill(formatting, 1<<29);\n\t\tArrays.fill(mincost, 1<<29);\n\t\tArrays.fill(used, false);\n\t\tfor(int i = 0; i < m; i++){\t\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tcost[a][b] = c;\n\t\t\tcost[b][a] = c;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\t\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmincost[i] = Math.min(mincost[i], cost[v][i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tif((n|m)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n][n];\n\t\t\tint mincost[]=new int[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tint total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt();\n\t\t\t\tint t=in.nextInt();\n\t\t\t\tint c=in.nextInt();\n\t\t\t\tcost[s][t]=c;\n\t\t\t\tcost[t][s]=c;\n\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\ttotal+=mincost[v];\n\t\t\t\tuse[v]=true;\n\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\twhile(true){\n\t\t\tshort n=scan.nextShort(),m=scan.nextShort();\n\t\t\tif(n==0) break;\n\t\t\tUnionFind uni = new UnionFind(n);\n\t\t\tList<edge> list = new ArrayList<edge>();\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tlist.add(new edge(scan.nextShort(),scan.nextShort(),scan.nextShort()));\n\t\t\tCollections.sort(list);\n\n\t\t\tint res=0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tedge e = list.get(i);\n\t\t\t\tif(!uni.isSame(e.from,e.to)){\n\t\t\t\t\tuni.unite(e.from, e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t\tout.flush();\n\t}\n}\n\nclass edge implements Comparable<Object> {\n\tshort from,to,cost;\n\tedge(short f,short t,short c){\n\t\tfrom=f;\n\t\tto=t;\n\t\tcost=c;\n\t}\n\t@Override\n\tpublic int compareTo(Object o) {\n\t\treturn this.cost-((edge)o).cost;\n\t}\n}\n\nclass UnionFind {\n\n\tint[] par,rank;\n\n\tUnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tboolean isSame(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint prim(int cost[][],int mincost[],boolean used[],int V){\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tmincost[i] = Integer.MAX_VALUE;\n\t\t\tused[i] = false;\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t\t}\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m==0)break;\n\t\t\tint cost[][] = new int [n][n];\n\t\t\tint mincost[] = new int [n];\n\t\t\tboolean used[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t}\n\t\t\tSystem.out.println(prim(cost,mincost,used,n));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint prim(int cost[][],int mincost[],boolean used[],int V){\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tmincost[i] = Integer.MAX_VALUE;\n\t\t\tused[i] = false;\n\t\t\tfor(int j = 0;j < V;j++){\n\t\t\t\tif(cost[i][j] == 0){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t\t}\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m==0)break;\n\t\t\tint cost[][] = new int [n][n];\n\t\t\tint mincost[] = new int [n];\n\t\t\tboolean used[] = new boolean[n];\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t}\n\t\t\tSystem.out.println(prim(cost,mincost,used,n));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x; this.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn min<=x&&x<X && min<=y&&y<Y;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t\tstatic void DE(char[][] c,int sx,int sy,int ex,int ey){\n\t\t\tout.println(\"--------------------\");\n\t\t\tfor(int y=sy; y<ey; y++){\n\t\t\t\tfor(int x=sx; x<ex; x++)out.print(c[x][y]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tout.println(\"--------------------\");\n\t\t}\n\t\tstatic void DE(int[][] c,int sx,int sy,int ex,int ey){\n\t\t\tout.println(\"--------------------\");\n\t\t\tfor(int y=sy; y<ey; y++){\n\t\t\t\tfor(int x=sx; x<ex; x++)out.print(c[x][y]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tout.println(\"--------------------\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0180();\n\t}\n\t\n\tvoid AOJ0180(){\n\t\twhile(sc.hasNext()){\n\t\t\tint MAX=sc.nextInt(),M=sc.nextInt();\n\t\t\tif((MAX|M)==0)\tbreak;\n\t\t\tint[][] g=new int[MAX][MAX];\n\t\t\tfor(int i=0; i<MAX; i++){\n\t\t\t\tfor(int j=0; j<MAX; j++)\tg[i][j]=(i==j?0:INF);\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tg[a][b]=c;\tg[b][a]=c;\n\t\t\t}\n\t\t\tint[] mincost=new int[MAX];\n\t\t\tboolean[] used=new boolean[MAX];\n\t\t\tArrays.fill(mincost, INF);\n\t\t\tmincost[0]=0;\n\t\t\tint res=0;\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0; u<MAX; u++){\n\t\t\t\t\tif(!used[u] && (v==-1||mincost[u]<mincost[v]))\tv=u;\n\t\t\t\t}\n\t\t\t\tif(v==-1)\tbreak;\n\t\t\t\tused[v]=true;\n\t\t\t\tres+=mincost[v];\n\t\t\t\tfor(int u=0; u<MAX; u++)\tmincost[u]=min(mincost[u],g[v][u]);\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\tvoid AOJ0189(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tfinal int MAX=10;\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[][] g=new int[MAX][MAX];\n\t\t\tfor(int i=0; i<MAX; i++){\n\t\t\t\tfor(int j=0; j<MAX; j++)\tg[i][j]=(i==j?0:INF);\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tg[a][b]=c;\tg[b][a]=c;\n\t\t\t}\n\t\t\tfor(int k=0; k<MAX; k++){\n\t\t\t\tfor(int j=0; j<MAX; j++){\n\t\t\t\t\tfor(int i=0; i<MAX; i++)\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i=0; i<MAX; i++){\n\t\t\t\tfor(int j=0; j<MAX; j++)\tout.print(g[j][i]+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint m=INF,t=INF;\n\t\t\tfor(int i=0; i<MAX; i++){\n\t\t\t\tif(g[i][0]>=INF)\tbreak;\n\t\t\t\tint temp=0;\n\t\t\t\tfor(int j=0; j<MAX; j++){\n\t\t\t\t\ttemp+=(g[i][j]<INF?g[i][j]:0);\n\t\t\t\t}\n\t\t\t\tm=(t>temp?i:m);\n\t\t\t\tt=(t>temp?temp:t);\n\t\t\t}\n\t\t\tout.println(m+\" \"+t);\n\t\t}\n\t}\n\t\n\tvoid AOJ0184(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] ans=new int[7];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint in=sc.nextInt(),p=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tin-=10;\n\t\t\t\t\tif(in<0){\n\t\t\t\t\t\tans[p]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(++p>=6){\n\t\t\t\t\t\tans[6]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<7; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tvoid AOJ0183(){\n\t\twhile(sc.hasNext()){\n\t\t\tint[][] b=new int[3][3],w=new int[3][3];\n\t\t\tfor(int y=0; y<3; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tif(line.equals(\"0\"))\tSystem.exit(0);\n\t\t\t\tfor(int x=0; x<3; x++){\n\t\t\t\t\tb[x][y]=(line.charAt(x)=='b'?1:0);\n\t\t\t\t\tw[x][y]=(line.charAt(x)=='w'?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"NA\";\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tif(b[i][0]+b[i][1]+b[i][2]==3){\n\t\t\t\t\tans=\"b\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(w[i][0]+w[i][1]+w[i][2]==3){\n\t\t\t\t\tans=\"w\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(b[0][i]+b[1][i]+b[2][i]==3){\n\t\t\t\t\tans=\"b\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(w[0][i]+w[1][i]+w[2][i]==3){\n\t\t\t\t\tans=\"w\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans.equals(\"NA\")){\n\t\t\t\tout.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b[0][0]+b[1][1]+b[2][2]==3 || b[2][0]+b[1][1]+b[0][2]==3)\tans=\"b\";\n\t\t\tif(w[0][0]+w[1][1]+w[2][2]==3 || w[2][0]+w[1][1]+w[0][2]==3)\tans=\"w\";\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// DP\n\tvoid AOJ1126(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++)\tc[x][y]=line.charAt(x);\n\t\t\t}\n\t\t\tString[][] dp=new String[W][H];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++)\tdp[i][j]=\"\";\n\t\t\t}\n\t\t\tString ans=\"\";\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tif(Character.isDigit(c[x][y])){\n\t\t\t\t\t\tdp[x][y]=max1126((x-1>=0?dp[x-1][y]:\"\"),(y-1>=0?dp[x][y-1]:\"\"))+Character.digit(c[x][y], 10);\n\t\t\t\t\t\tans=max1126(ans,dp[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tString max1126(String a,String b){\n\t\tif(a==\"\")\treturn b;\n\t\tif(b==\"\")\treturn a;\n\t\twhile(a.charAt(0)=='0'){\n\t\t\tif(a.length()<=1){\n\t\t\t\ta=\"\";\n\t\t\t\tbreak;\n\t\t\t}else\ta=a.substring(1);\n\t\t}\n\t\twhile(b.charAt(0)=='0'){\n\t\t\tif(b.length()<=1){\n\t\t\t\tb=\"\";\n\t\t\t\tbreak;\n\t\t\t}else\tb=b.substring(1);\n\t\t}\n\t\tif(a==\"\")\treturn b;\n\t\tif(b==\"\")\treturn a;\n\t\tif(a.length()>b.length())\treturn a;\n\t\tif(b.length()>a.length())\treturn b;\n\t\tfor(int i=0; i<a.length(); i++){\n\t\t\tif(a.charAt(i)>b.charAt(i))\treturn a;\n\t\t\tif(a.charAt(i)<b.charAt(i))\treturn b;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\t// TODO TLE\n\tvoid AOJ0185(){\n\t\tArrayList<Integer> prime=SieveList(1000000);\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(),ans=0;\n\t\t\tif(n==0)\tbreak;\n\t\t\tfor(int i=0; i<prime.size(); i++){\n\t\t\t\tif(prime.get(i)>=n)\tbreak;\n\t\t\t\tfor(int j=i; j<prime.size(); j++){\n\t\t\t\t\tint temp=prime.get(i)+prime.get(j);\n\t\t\t\t\tif(temp>=n){\n\t\t\t\t\t\t//if(temp==n)\tout.println(\"  \"+prime.get(i)+\" + \"+prime.get(j)+\" = \"+temp);\n\t\t\t\t\t\tans+=(temp==n?1:0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ0174(){\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='0')\tbreak;\n\t\t\tint a=0,b=0;\n\t\t\tfor(int i=1; i<c.length; i++){\n\t\t\t\tif(c[i]=='A')\ta++;\n\t\t\t\telse if(c[i]=='B')\tb++;\n\t\t\t}\n\t\t\ta+=(a>b?1:0);\tb+=(b>a?1:0);\n\t\t\tout.println(a+\" \"+b);\n\t\t}\n\t}\n\t\n\tvoid AOJ0173(){\n\t\tfor(int i=0; i<9; i++){\n\t\t\tString s=sc.next();\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\tout.println(s+\" \"+(a+b)+\" \"+(a*200+b*300));\n\t\t}\n\t}\n\t\n\t\n\t// 途中\n\tvoid AOJ0121(){\n\t\twhile(sc.hasNext()){\n\t\t\tint[] b=new int[8];\n\t\t\tfor(int i=0; i<8; i++)\tb[i]=sc.nextInt();\n\t\t\tLinkedList<int[]> open=new LinkedList<int[]>();\n\t\t\topen.add(b);\n\t\t\tHashSet<int[]> close=new HashSet<int[]>();\n\t\t\tclose.add(b);\n\t\t\tint ans=0;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tint[] now=open.poll();\n\t\t\t\tif(solve121(now))\tbreak;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint[] temp=now.clone();\n\t\t\t\t\tint temp2=temp[i+1];\n\t\t\t\t\ttemp[i+1]=temp[i];\n\t\t\t\t\ttemp[i]=temp2;\n\t\t\t\t\tif(close.contains(temp))\tcontinue;\n\t\t\t\t\tif(solve121(temp)){\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(temp);\n\t\t\t\t\tclose.add(temp);\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tboolean solve121(int[] b){\n\t\tfor(int i=0; i<8; i++)\tif(b[i]!=i)\treturn false;\n\t\treturn true;\n\t}\n\tboolean cont121(int[] a,int[] b){\n\t\tfor(int i=0; i<8; i++)\tif(a[i]!=b[i])\treturn false;\n\t\treturn true;\n\t}\n\t\n\tvoid AOJ1104(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint x=1,y=1,d=2;\n\t\t\t// 右-1 左+1\n\t\t\twhile(true){\n\t\t\t\tString s=sc.next();\n\t\t\t\tif(s.equals(\"STOP\"))\tbreak;\n\t\t\t\telse if(s.equals(\"FORWARD\")){\n\t\t\t\t\tint n=sc.nextInt();\n\t\t\t\t\tx=max(1,min(W,x+n*vx[d]));\n\t\t\t\t\ty=max(1,min(H,y+n*vy[d]));\n\t\t\t\t}else if(s.equals(\"BACKWARD\")){\n\t\t\t\t\tint n=sc.nextInt();\n\t\t\t\t\tx=max(1,min(W,x+n*-1*vx[d]));\n\t\t\t\t\ty=max(1,min(H,y+n*-1*vy[d]));\n\t\t\t\t}else if(s.equals(\"RIGHT\"))\td=(d==0?3:d-1);\n\t\t\t\telse if(s.equals(\"LEFT\"))\td=(d==3?0:d+1);\n\t\t\t\t//out.println(\"D\"+x+\" \"+y+\" \"+d);\n\t\t\t}\n\t\t\tout.println(x+\" \"+y);\n\t\t}\n\t}\n\t\n\tvoid AOJ1114(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint[][] b=new int[5][5];\n\t\t\tfor(int y=0; y<5; y++){\n\t\t\t\tfor(int x=0; x<5; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=0; i<5; i++){\n\t\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\t\tif(b[i][j]==1)\tans=max(ans,solve1114(i,j,b));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint solve1114(int x,int y,int[][] b){\n\t\tint ans=0;\n\t\tfor(int i=0; i+x<5; i++){\n\t\t\tif(b[i+x][y]==0)\tbreak;\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j+y<5; j++){\n\t\t\t\tfor(int k=0; k<=i; k++){\n\t\t\t\t\tfor(int l=0; l<=j; l++){\n\t\t\t\t\t\tif(b[k+x][l+y]==0){\n\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flag)\tbreak;\n\t\t\t\tans=max(ans,(i+1)*(j+1));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint step=0;\n\t// バックトラック（TLE）\n\tvoid Old2AOJ1126(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++)\tc[x][y]=line.charAt(x);\n\t\t\t}\n\t\t\tString ans=\"\";\n\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tif(Character.isDigit(c[x][y])){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]) && c[x-1][y]!='0')\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]) && c[x][y-1]!='0')\tcontinue;\n\t\t\t\t\t\tif(c[x][y]=='0')\tcontinue;\n\t\t\t\t\t\tString temp=solve1126(x,y,\"\"+c[x][y],c,W,H);\n\t\t\t\t\t\tans=compara1126(temp,ans)?temp:ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\t// debug\n\t\tout.println(step+\"steps\");\n\t}\n\tString solve1126(int x,int y,String ans,char[][] c,int W,int H){\n\t\tString r=ans;\n\t\t// debug\n\t\tstep++;\n\t\t//out.println(ans);\n\t\tfor(int i=1; i<3; i++){\n\t\t\tint xx=x+vx[i], yy=y+vy[i];\n\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\tString temp=solve1126(xx,yy,ans+c[xx][yy],c,W,H);\n\t\t\t\tr=compara1126(r,temp)?r:temp;\n\t\t\t\tout.println(temp);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t// 第一引数aの方が大きい時のみtrue\n\tboolean compara1126(String a,String b){\n\t\tif(a.length()>b.length())\treturn true;\n\t\tif(a.length()==b.length()){\n\t\t\tfor(int i=0; i<a.length(); i++){\n\t\t\t\tif(a.charAt(i)>b.charAt(i))\treturn true;\n\t\t\t\tif(a.charAt(i)<b.charAt(i))\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 横型探索（MLE）\n\tvoid OldAOJ1126(){\n\t\tint step=0;\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tString ans=\"\";\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tString[][] close=new String[W][H];\n\t\t\tLinkedList<C1126> open=new LinkedList<C1126>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(Character.isDigit(line.charAt(x))){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]))\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]))\tcontinue;\n\t\t\t\t\t\topen.add(new C1126(x,y,\"\"+c[x][y]));\n\t\t\t\t\t\tclose[x][y]=\"\"+c[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1126 now=open.poll();\n\t\t\t\t// debug\n\t\t\t\tout.println(\"ANS\"+ans+\" NOW\"+now.ans);\n\t\t\t\tans=now.compara(ans)?new String(now.ans):ans;\n\t\t\t\tfor(int i=1; i<3; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\t\t\tC1126 temp=new C1126(xx,yy,now.ans+c[xx][yy]);\n\t\t\t\t\t\tif(close[xx][yy]==null){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}else if(temp.compara(close[xx][yy])){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.println(step+\"step\");\n\t}\n\tclass C1126{\n\t\tint x,y;\tString ans;\n\t\tC1126(int x,int y,String ans){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t\tif(ans.length()>0){\n\t\t\t\tint i=0;\n\t\t\t\twhile(ans.charAt(i)=='0'){\n\t\t\t\t\tif(++i>=ans.length()-1)\tbreak;\n\t\t\t\t\tans=ans.substring(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ans=ans;\n\t\t}\n\t\tboolean compara(String ans){\n\t\t\tif(this.ans.length()>ans.length())\treturn true;\n\t\t\tif(this.ans.length()==ans.length()){\n\t\t\t\tfor(int i=0; i<ans.length(); i++){\n\t\t\t\t\tif(ans.charAt(i)<this.ans.charAt(i))\treturn true;\n\t\t\t\t\tif(ans.charAt(i)>this.ans.charAt(i))\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ0165(){\n\t\tfinal int MAX=1000000;\n\t\tboolean[] prime=Sieve(MAX);\n\t\tint[] prime2=new int[MAX+1];\n\t\tfor(int i=2; i<=MAX; i++)\tprime2[i]=(prime[i]?prime2[i-1]+1:prime2[i-1]);\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint p=sc.nextInt(), m=sc.nextInt();\n\t\t\t\tint min=max(1,p-m), max=min(MAX, p+m);\n\t\t\t\tans+=prime2[max]-prime2[min-1]-1;\n\t\t\t}\n\t\t\tout.println(max(0,ans));\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt();\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// TODO 果樹園　RE　横型\n\tvoid AOJ0118(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(), ans=0;\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X+2][Y+2];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug\n\t\t\t//Point.DE(c, 0, 0, X, Y);\n\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\t\tif(c[x][y]=='&')\tcontinue;\n\t\t\t\t\tans++;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\tc[x][y]='&';\n\t\t\t\t\tchar mark=c[x][y];\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\t\t\tif(!Point.ok(xx,yy,X,Y))\tcontinue;\n\t\t\t\t\t\t\tif(c[xx][yy]==mark){\n\t\t\t\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\t\t\t\tc[xx][yy]='&';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Point.DE(c, 0, 0, X, Y);\n\t\t\t\t\t//out.println(\"ANS\"+ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// Red and Black 横型探索\n\tvoid AOJ1130(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(),sx=0,sy=0,ans=0;\n\t\t\tif(X==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line[x];\n\t\t\t\t\tif(line[x]=='@'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tboolean[][] close=new boolean[X][Y];\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tans++;\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]=='.' && !close[now.x+vx[i]][now.y+vy[i]]){\n\t\t\t\t\t\topen.add(new Point(now.x+vx[i], now.y+vy[i]));\n\t\t\t\t\t\tclose[now.x+vx[i]][now.y+vy[i]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// TODO デパート　TLE MLE WA\n\tvoid AOJ0223(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(),\tY=sc.nextInt();\n\t\t\tif(X==0)\tbreak;\n\t\t\tint tx=sc.nextInt(), ty=sc.nextInt(), kx=sc.nextInt(), ky=sc.nextInt();\n\t\t\tint[][] b=new int[X+1][Y+1];\n\t\t\tfor(int y=1; y<=Y; y++){\n\t\t\t\tfor(int x=1; x<=X; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<C0223> open=new LinkedList<C0223>();\n\t\t\topen.add(new C0223(tx,ty,kx,ky,0));\n\t\t\tint[][][][] close2=new int[X+1][Y+1][X+1][Y+1];\n\t\t\tclose2[tx][ty][kx][ky]=-1;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC0223 now=open.poll();\n\t\t\t\tif(now.ans()){\n\t\t\t\t\tans=now.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.sec>=99)\tbreak;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(0<now.tx+vx[i]&&now.tx+vx[i]<=X && 0<now.ty+vy[i]&&now.ty+vy[i]<=Y && 0<now.kx-vx[i]&&now.kx-vx[i]<=X && 0<now.ky-vy[i]&&now.ky-vy[i]<=Y){\n\t\t\t\t\t\ttx=now.tx;\tty=now.ty;\tkx=now.kx;\tky=now.ky;\n\t\t\t\t\t\tif(b[tx+vx[i]][ty+vy[i]]==0){\n\t\t\t\t\t\t\ttx+=vx[i];\tty+=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[kx-vx[i]][ky-vy[i]]==0){\n\t\t\t\t\t\t\tkx-=vx[i];\tky-=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"TEMP:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t//if(tx==kx && ty==ky)\tans=ans<0?now.sec+1:min(ans,now.sec+1);\n\t\t\t\t\t\tif(close2[tx][ty][kx][ky]==0 || close2[tx][ty][kx][ky]>now.sec+1){\n\t\t\t\t\t\t\t//out.println(\"ADD:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t\topen.add(new C0223(tx,ty,kx,ky,now.sec+1));\n\t\t\t\t\t\t\tclose2[tx][ty][kx][ky]=now.sec+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tclass C0223{\n\t\tint tx,ty,kx,ky,sec;\n\t\tC0223(int tx, int ty, int kx, int ky, int sec){\n\t\t\tthis.tx=tx;\tthis.ty=ty;\tthis.kx=kx;\tthis.ky=ky;\tthis.sec=sec;\n\t\t}\n\t\tboolean ans(){\n\t\t\tif(this.tx==this.kx && this.ty==this.ky)\treturn true;\n\t\t\telse\treturn false;\n\t\t}\n\t}\n\t\n\t\n\t// TODO WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\t\n\t// レゴ　横型探索\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[W+1][H+1];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug\n\t\t\t//de0207(b,W,H);\n\t\t\tint c=b[sx][sy];\n\t\t\tif(c==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\tboolean[][] close=new boolean[W+1][H+1];\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tclose[sx][sy]=true;\n\t\t\tString ans=\"NG\";\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W+1, H+1, 1))\tcontinue;\n\t\t\t\t\tif(b[xx][yy]!=c)\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\tif(xx==gx && yy==gy){\n\t\t\t\t\t\tans=\"OK\";\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tArrayList<Integer> SieveList(int N){\n\t\tArrayList<Integer> prime=new ArrayList<Integer>();\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[0]=false;\tlist[1]=false;\n\t\tprime.add(2);\n\t\tfor(int j=4; j<=N; j+=2)\tlist[j]=false;\n\t\tfor(int i=3; i<=N; i+=2){\n\t\t\tif(list[i]){\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)\tlist[j]=false;\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\t\n\tboolean[] Sieve(int N){\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[0]=false;\tlist[1]=false;\n\t\tfor(int j=4; j<=N; j+=2)\tlist[j]=false;\n\t\tfor(int i=3; i*i<=N; i+=2)\tif(list[i])\tfor (int j=i+i; j<=N; j+=i)\tlist[j]=false;\n\t\treturn list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0)     return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\t\n\tpublic static class Edge implements Comparable<Edge>{\n\t\tint start;\n\t\tint end;\n\t\tint cost;\n\t\t\n\t\tpublic Edge(int start, int end, int cost) {\n\t\t\tsuper();\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint nodes, edges;\n\t\t\t\n\t\t\tnodes = sc.nextInt();\n\t\t\tedges = sc.nextInt();\n\t\t\t\n\t\t\tif(nodes == 0 && edges == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tEdge[] array = new Edge[edges];\n\t\t\tfor(int i = 0; i < edges; i++){\n\t\t\t\tarray[i] = new Edge(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(array);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tList<Edge> list = new LinkedList<Edge>();\n\t\t\tUnionFind uf = new UnionFind(nodes);\n\t\t\tfor(Edge e : array){\n\t\t\t\tif(count >= nodes){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!uf.same(e.start, e.end)){\n\t\t\t\t\tlist.add(e);\n\t\t\t\t\tcount++;\n\t\t\t\t\tuf.unite(e.start, e.end);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(Edge e : list){\n\t\t\t\tsum += e.cost;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++) Arrays.fill(map[i], Integer.MAX_VALUE);\n\t\t\tint p, q;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp = sc.nextInt();\n\t\t\t\tq = sc.nextInt();\n\t\t\t\tmap[p][q] = sc.nextInt();\n\t\t\t\tmap[q][p] = map[p][q];\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tlist.add(0);\n\t\t\tint sum = 0;\n\t\t\tint r = 0;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tq = Integer.MAX_VALUE;\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tp = list.get(j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(list.contains(k)==false && q>map[p][k]){\n\t\t\t\t\t\t\tq = map[p][k];\n\t\t\t\t\t\t\tr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.add(r);\n\t\t\t\tsum += q;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass br implements Comparable<br> {\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\n\t\tbr(int a, int b, int c) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(br t) {\n\t\t\treturn this.c - t.c;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n//\t\t\tint[][] map = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tArrays.fill(map[i], 12345);\n\t\t\t}\n\t\t\tPriorityQueue<br> l = new PriorityQueue<br>();\n\t\t\t// LinkedList<br> l = new LinkedList<br>();\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tl.add(new br(a, b, c));\n\t\t\t}\n\t\t\tint count = n - 1;\n\t\t\tint ans = 0;\n\n\t\t\tint p[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif (count == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbr s = l.poll();\n\n\t\t\t\tint a = s.a;\n\n\t\t\t\tint pa = p[a];\n\t\t\t\twhile (p[pa] != pa) {\n\t\t\t\t\tint z = pa;\n\t\t\t\t\tpa = p[pa];\n\t\t\t\t\tp[z] = pa;\n\t\t\t\t}\n\t\t\t\tint b = s.b;\n\t\t\t\tint pb = p[b];\n\t\t\t\twhile (p[pb] != pb) {\n\t\t\t\t\tint z = pb;\n\t\t\t\t\tpb = p[pb];\n\t\t\t\t\tp[z] = pb;\n\t\t\t\t}\n\n\t\t\t\tif (pb == pa) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tp[pa] = pb;\n\t\t\t\t\tcount--;\n\t\t\t\t\tans += s.c;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\twhile(true){\n\t\t\tshort n=scan.nextShort(),m=scan.nextShort();\n\t\t\tif(n==0) break;\n\t\t\tUnionFind uni = new UnionFind(n);\n\t\t\tList<edge> list = new ArrayList<edge>();\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tlist.add(new edge(scan.nextShort(),scan.nextShort(),scan.nextShort()));\n\t\t\tCollections.sort(list);\n\n\t\t\tint res=0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tedge e = list.get(i);\n\t\t\t\tif(!uni.isSame(e.from,e.to)){\n\t\t\t\t\tuni.unite(e.from, e.to);\n\t\t\t\t\tres+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t\tout.flush();\n\t}\n}\n\nclass edge implements Comparable {\n\tshort from,to,cost;\n\tedge(short f,short t,short c){\n\t\tfrom=f;\n\t\tto=t;\n\t\tcost=c;\n\t}\n\t@Override\n\tpublic int compareTo(Object o) {\n\t\treturn this.cost-((edge)o).cost;\n\t}\n}\n\nclass UnionFind {\n\n\tint[] par,rank;\n\n\tUnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tboolean isSame(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Stellar Performance of the Debunkey Family\npublic class Main{\n\n\tstatic  class UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\n\t\t// merge the set contains x and the set contains y\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t// decide if x and y belong to the same set\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\t// return size of the set contains x\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\t// return the number of sets\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tstatic class E implements Comparable<E>{\n\t\tint s, t, cost;\n\t\tpublic E(int s, int t, int cost) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\twhile(m--!=0)q.add(new E(sc.nextInt(),sc.nextInt(),sc.nextInt()));\n\t\t\tUnionFind u = new UnionFind(n);\n\t\t\tint s = 0;\n\t\t\twhile(u.num>1){\n\t\t\t\tE e = q.poll();\n\t\t\t\tif(!u.find(e.s, e.t)){\n\t\t\t\t\tu.union(e.s, e.t);\n\t\t\t\t\ts+=e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tKruscal g = new Kruscal(n);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg.addBidirectionalEdge(a,b,c);\n\t\t\t}\n\t\t\tSystem.out.println(g.minCost());\n\t\t}\n\t}\n\n}\n\nclass Kruscal {\n\tint n;\n\tArrayList<Edge> graph = new ArrayList<Edge>();\n\n\tpublic Kruscal(int n) {\n\t\tthis.n = n;\n\t}\n\n\tpublic void addBidirectionalEdge(int u,int v,int cost) {\n\t\tgraph.add(new Edge(cost,u,v));\n\t}\n\n\tpublic int minCost() {\n\t\tCollections.sort(graph);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tint ans = 0;\n\t\tint connected = 1;\n\t\tfor(int i=0;i<graph.size();i++) {\n\t\t\tEdge e = graph.get(i);\n\t\t\tif (!uf.isConnected(e.from, e.to)) {\n\t\t\t\tuf.union(e.from, e.to);\n\t\t\t\tconnected++;\n\t\t\t\tans+=e.cost;\n\t\t\t\tif (connected==n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint cost;\n\t\tint from;\n\t\tint to;\n\t\tpublic Edge(int cost,int from,int to) {\n\t\t\tthis.cost = cost;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.cost == o.cost) {\n\t\t\t\treturn 0;\n\t\t\t}else if(this.cost > o.cost) {\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.cost + \",\" + this.from + \",\" + this.to;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tprivate int[] data;\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tArrays.fill(data, -1);\n\t\t}\n\t\tpublic void union(int x,int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x!=y) {\n\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\tint tmp = y;\n\t\t\t\t\ty = x;\n\t\t\t\t\tx = tmp;\n\t\t\t\t}\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t}\n\t\tpublic boolean isConnected(int x,int y) {\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tprivate int root(int x) {\n\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t}\n\t\tpublic int size(int x) {\n\t\t\treturn -data[root(x)];\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(data);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK=8*1024*1024;\n\t\tnew Thread(null, new AOJ0180(), \"RUN!\", STACK).start();\n\t}\n\t\n\tclass AOJ0180 implements Runnable{\n\t\tAOJ0180(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),E=sc.nextInt();\n\t\t\t\tif((N|E)==0)\tbreak;\n\t\t\t\tsolve(N,E);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N,int E){\n\t\t\tint[][] g=new int[N][N];\n\t\t\tfor(int i=0; i<N; i++)for(int j=0; j<N; j++)g[i][j]=1<<29;\n\t\t\tfor(int i=0; i<E; i++){\n\t\t\t\tint u=sc.nextInt(),v=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tg[u][v]=c;\n\t\t\t\tg[v][u]=c;\n\t\t\t}\n\t\t\t//System.out.println(prim(g,N));\n\t\t\tSystem.out.println(new kruskal(g,N).solve());\n\t\t}\n\t\t\n\t\tclass kruskal{\n\t\t\tArrayList<Edge> es;\n\t\t\tint E,N;\n\t\t\tfinal int INF=1<<29;\n\t\t\tkruskal(int[][] g,int N){\n\t\t\t\tthis.N=N;\n\t\t\t\tes=new ArrayList<kruskal.Edge>();\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\t\tif(-1*INF<g[i][j] && g[i][j]<INF)\tes.add(new Edge(i,j,g[i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.E=es.size();\n\t\t\t}\n\t\t\tint solve(){\n\t\t\t\tCollections.sort(es);\n\t\t\t\tUnionFind uf=new UnionFind(N);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int i=0; i<E; i++){\n\t\t\t\t\tEdge e=es.get(i);\n\t\t\t\t\tif(!uf.isSame(e.u, e.v)){\n\t\t\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t\t\t\tret+=e.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tclass Edge implements Comparable<Edge>{\n\t\t\t\tint u,v,cost;\n\t\t\t\tEdge(int u,int v,int cost){\n\t\t\t\t\tthis.u=u;\tthis.v=v;\tthis.cost=cost;\n\t\t\t\t}\n\t\t\t\t@Override public int compareTo(Edge e){\n\t\t\t\t\treturn this.cost-e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass UnionFind{\n\t\t\tint[] par,rank;\n\t\t\tUnionFind(int n){\n\t\t\t\tpar=new int[n];\n\t\t\t\trank=new int[n];\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tpar[i]=i;\n\t\t\t\t\trank[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 木の根を求める\n\t\t\tint find(int x){\n\t\t\t\tif(par[x]==x)\treturn x;\n\t\t\t\telse\t\t\treturn par[x]=find(par[x]);\n\t\t\t}\n\t\t\t\n\t\t\t// xとyの属する集合を併合\n\t\t\tvoid unite(int x,int y){\n\t\t\t\tx=find(x);\n\t\t\t\ty=find(y);\n\t\t\t\tif(x==y)\treturn;\n\t\t\t\t\n\t\t\t\tif(rank[x]<rank[y]){\n\t\t\t\t\tpar[x]=y;\n\t\t\t\t}else{\n\t\t\t\t\tpar[y]=x;\n\t\t\t\t\tif(rank[x]==rank[y])\t++rank[x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// xとyが同じ集合に属するか否か\n\t\t\tboolean isSame(int x,int y){\n\t\t\t\treturn find(x)==find(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint prim(int[][] g,int N){\n\t\t\tfinal int INF=1<<29;\n\t\t\tint[] mincost=new int[N];\n\t\t\tboolean[] used=new boolean[N];\n\t\t\tfor(int i=0; i<N; i++)\tmincost[i]=INF;\n\t\t\t\n\t\t\tmincost[0]=0;\n\t\t\tint ret=0;\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0; u<N; u++){\n\t\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v]))\tv=u;\n\t\t\t\t}\n\t\t\t\tif(v < 0)\tbreak;\n\t\t\t\tused[v]=true;\n\t\t\t\tret+=mincost[v];\n\t\t\t\t\n\t\t\t\tfor(int u=0; u<N; u++)\tmincost[u]=min(mincost[u], g[v][u]);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic PriorityQueue<Edge> pq=new PriorityQueue<>();\n\tstatic int n, m;\n\tstatic int[] par;\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint u, v, cost;\n\t\tEdge(int u, int v, int cost){\n\t\t\tthis.u=u;\n\t\t\tthis.v=v;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn this.cost-e.cost;\n\t\t}\n\t}\n\t\n\tstatic void init(int N) {//初期化\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\t\n\tstatic int root(int x) {//親を求める\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\treturn par[x]=root(par[x]);\n\t}\n\t\n\tstatic boolean same(int x, int y) {//判定(同グループかどうか)\n\t\treturn (root(x)==root(y));\n\t}\n\t\n\tstatic void unite(int x, int y) {//まとめる\n\t\tpar[root(x)]=root(y);\n\t}\n\t\n\tstatic int kraskal() {\n\t\tinit(n);\n\t\tint res=0;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tEdge e=pq.poll();\n\t\t\tif(!same(e.u, e.v)) {\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres+=e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tif(n+m==0) break;\n\t\t\t\tpar=new int[m];\n\t\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tint w=sc.nextInt();\n\t\t\t\t\tpq.add(new Edge(a, b, w));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(kraskal());\n\t\t\t}\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic PriorityQueue<Edge> pq=new PriorityQueue<>();\n\tstatic int n, m;\n\tstatic int[] par;\n\t\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint u, v, cost;\n\t\tEdge(int u, int v, int cost){\n\t\t\tthis.u=u;\n\t\t\tthis.v=v;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn this.cost-e.cost;\n\t\t}\n\t}\n\t\n\tstatic void init(int N) {//初期化\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\t\n\tstatic int root(int x) {//親を求める\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\treturn par[x]=root(par[x]);\n\t}\n\t\n\tstatic boolean same(int x, int y) {//判定(同グループかどうか)\n\t\treturn (root(x)==root(y));\n\t}\n\t\n\tstatic void unite(int x, int y) {//まとめる\n\t\tpar[root(x)]=root(y);\n\t}\n\t\n\tstatic int kraskal() {\n\t\tinit(n);\n\t\tint res=0;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tEdge e=pq.poll();\n\t\t\tif(!same(e.u, e.v)) {\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres+=e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tif(n+m==0) break;\n\t\t\t\tpar=new int[n];\n\t\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tint w=sc.nextInt();\n\t\t\t\t\tpq.add(new Edge(a, b, w));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(kraskal());\n\t\t\t\tpq.clear();\n\t\t\t}\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[m][3];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmap[i][0] = scanner.nextInt();\n\t\t\t\tmap[i][1] = scanner.nextInt();\n\t\t\t\tmap[i][2] = scanner.nextInt();\n\t\t\t}\n\t\t\tArrays.sort(map, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[2] - o2[2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = root(map[i][0], p);\n\t\t\t\tint b = root(map[i][1], p);\n\t\t\t\tif (a != b) {\n\t\t\t\t\tans += map[i][2];\n\t\t\t\t\tp[a] = b;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate static int root(int a, int[] p) {\n\t\tif (a == p[a]) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn root(p[a], p);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tEdge[] es = new Edge[m];\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tes[i] = new Edge(s, e, d);\n\t\t\t}\n\t\t\tArrays.sort(es, new Comparator<Edge>() {\n\t\t\t\tpublic int compare(Edge a, Edge b) {\n\t\t\t\t\treturn a.d - b.d;\n\t\t\t\t}\n\t\t\t});\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = es[i].s;\n\t\t\t\tint b = es[i].e;\n\t\t\t\tint d = es[i].d;\n\t\t\t\tif (!uf.same(a, b)) {\n\t\t\t\t\tuf.unite(a, b);\n\t\t\t\t\tsum += d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\nclass Edge {\n\tpublic int s;\n\tpublic int e;\n\tpublic int d;\n\n\tEdge(int s, int e, int d) {\n\t\tthis.s = s;\n\t\tthis.e = e;\n\t\tthis.d = d;\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic int rank[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tpublic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //£sñ\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\tstatic void solve(){\n\t\t//v@ÅÀ\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //èÏÝ\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //¢è\n\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\t\tX.add(0);\n\n\t\t//¢èÌWªóÉÈéÜÅ\n\t\twhile(!Y.isEmpty()){\n\t\t\t//System.out.println(\"X:\" + X);\n\t\t\t//System.out.println(\"Y:\" + Y);\n\n\t\t\t//Å¬RXgÌ×Úm[hð²×é\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\t//System.out.println(n1 + \" \" + n2);\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\n\t\t}\n\n\t\tSystem.out.println(sum);  //oÍ\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint prim(int cost[][],int mincost[],boolean used[],int V){\n\t\tfor(int i = 0;i < V;i++){\n\t\t\tmincost[i] = Integer.MAX_VALUE;\n\t\t\tused[i] = false;\n\t\t}\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t\t}\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int u = 0;u < V;u++){\n\t\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n+m==0)break;\n\t\t\tint cost[][] = new int [n][n];\n\t\t\tint mincost[] = new int [n];\n\t\t\tboolean used[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tif(i == j)cost[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tcost[a][b] = sc.nextInt();\n\t\t\t\tcost[b][a] = cost[a][b];\n\t\t\t}\n\t\t\tSystem.out.println(prim(cost,mincost,used,n));\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tstatic int n, m;\n\tstatic int[][] node;\n\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(n == 0 && m == 0)  return false;\n\n\t\tnode = new int[n][n];  //£sñ\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) node[i][j] = 0;\n\t\t\t\telse     node[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint node1 = sc.nextInt();\n\t\t\tint node2 = sc.nextInt();\n\t\t\tint cost = sc.nextInt();\n\n\t\t\tnode[node1][node2] = cost;\n\t\t\tnode[node2][node1] = cost;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t//v@\n\tstatic void solve(){\n\t\tint sum =0;\n\t\tHashSet<Integer> X = new HashSet<Integer>();  //èÏÝW\n\t\tHashSet<Integer> Y = new HashSet<Integer>();  //¢èW\n\n\t\t//WÌú»\n\t\tX.add(0);\n\t\tfor(int i=1; i<n; i++){\n\t\t\tY.add(i);\n\t\t}\n\n\t\t//¢èÌWªóÉÈéÜÅ\n\t\twhile(!Y.isEmpty()){\n\n\t\t\t//Å¬RXgÌ×Úm[hð²×é\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_num = -1, min_num2 = -1;\n\n\t\t\tfor(Iterator<Integer> i1 = X.iterator(); i1.hasNext();){\n\t\t\t\tint n1 = i1.next();\n\t\t\t\tfor (Iterator<Integer> i2 = Y.iterator(); i2.hasNext();){\n\t\t\t\t\tint n2 = i2.next();\n\t\t\t\t\tif(node[n1][n2] == -1)  continue;\n\n\t\t\t\t\tif(min > node[n1][n2]){\n\t\t\t\t\t\tmin = node[n1][n2];\n\t\t\t\t\t\tmin_num = n1;\n\t\t\t\t\t\tmin_num2 = n2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += node[min_num][min_num2];\n\t\t\tY.remove(min_num2);\n\t\t\tX.add(min_num2);\n\t\t}\n\n\t\tSystem.out.println(sum);  //oÍ\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ();\n\t}\n\t\n\tclass  AOJ{\n\t\tArrayList<Integer> gets;\n\t\tArrayList<Integer> never;\n\t\tpublic AOJ(){\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\twhile(true){\n\t\t\t\tint n = in.nextInt();//n-1までの街数\n\t\t\t\tint m = in.nextInt();//橋の数\n\t\t\t\tif(n+m==0)break;\n\t\t\t\tint[][] edge = new int[n][n];\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=0;s<n;s++)edge[i][s]=Integer.MAX_VALUE;\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tint a=in.nextInt();\n\t\t\t\t\tint b=in.nextInt();\n\t\t\t\t\tedge[a][b]=in.nextInt();\n\t\t\t\t\tedge[b][a]=edge[a][b];\n\t\t\t\t}\n\t\t\t\tint result=0;\n\t\t\t\tint min[] = new int[n];\n\t\t\t\tboolean[] sw = new boolean[n];\n\t\t\t\tArrays.fill(min,Integer.MAX_VALUE);\n\t\t\t\tsw[0] = true;\n\t\t\t\tfor(int i=1;i<n;i++)if(!sw[i]&&min[i]>edge[i][0])min[i]=edge[i][0];\n\t\t\t\twhile(true){\n\t\t\t\t\tint target = -1;\n\t\t\t\t\tfor(int s=0;s<n;s++){\n\t\t\t\t\t\tif(!sw[s]&&(target==-1||min[target]>min[s])){\n\t\t\t\t\t\t\ttarget=s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(target==-1)break;\n\t\t\t\t\tresult+=min[target];\n\t\t\t\t\tsw[target]=true;\n\t\t\t\t\tfor(int i=0;i<n;i++)if(!sw[i]&&min[i]>edge[i][target])min[i]=edge[i][target];\n\t\t\t\t}\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tfinal int INF = 1 << 29;\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint [][] cost = new int[n][n];\n\t\t\tint [] mincost = new int[n];\n\t\t\tboolean [] used = new boolean[n];\n\t\t\tfor(int i =0 ; i < n ;i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(i == j){\n\t\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint from = sc.nextInt();\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tint value = sc.nextInt();\n\t\t\t\tcost[from][to] = value;\n\t\t\t\tcost[to][from] = value;\n\t\t\t}\n\n\t\t\tfor(int i= 0; i < n; ++i){\n\t\t\t\tmincost[i] = INF;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\n\t\t\tmincost[0] = 0;\n\t\t\tint res = 0;\n\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\n\t\t\t\tfor(int u = 0; u < n; u++){\n\t\t\t\t\tif(! used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\t\t\tv = u;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(v == -1) break;\n\t\t\t\tused[v] = true;\n\t\t\t\tres += mincost[v];\n\n\t\t\t\tfor(int u = 0; u < n; u++){\n\t\t\t\t\tmincost[u] = Math.min(mincost[u], cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tArrayList<ArrayList<Edge>> map = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmap.add(new ArrayList<Edge>());\n\t\t\t}\n\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\n\t\t\t\tmap.get(a).add(new Edge(a,b,cost));\n\t\t\t\tmap.get(b).add(new Edge(b,a,cost));\n\t\t\t}\n\n\t\t\tSystem.out.println(kruskal(map));\n\t\t}\n\t}\n\n\tstatic int kruskal(ArrayList<ArrayList<Edge>> g){\n\t\tint n = g.size();\n\t\tUnionFind uf = new UnionFind(n);\n\t\tPriorityQueue<Edge> open = new PriorityQueue<Edge>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(Edge e : g.get(i)) if(i < e.to) open.add(e);\n\t\t}\n\n\t\tint cost = 0;\n\t\tHashSet<Edge> closed = new HashSet<Edge>();\n\t\twhile(closed.size() < n - 1 && !open.isEmpty()){\n\t\t\tEdge e = open.poll();\n\t\t\tif(uf.unionSet(e.from,e.to)){\n\t\t\t\tclosed.add(e);\n\t\t\t\tcost += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n}\n\nclass UnionFind{\n\tint[] data;\n\n\tUnionFind(int n){\n\t\tdata = new int[n];\n\t\tArrays.fill(data,-1);\n\t}\n\n\tboolean unionSet(int x,int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x]){\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tboolean findSet(int x,int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\n\tint size(int x){\n\t\treturn -data[root(x)];\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint from,to,cost;\n\n\tEdge(int from,int to,int cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(Edge e){\n\t\treturn this.cost - e.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\tLinkedList<E> list;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist=new LinkedList<E>();\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a=sc.nextInt();\n\t\t\t\tint b=sc.nextInt();\n\t\t\t\tint cost=sc.nextInt();\n\t\t\t\tlist.add(new E(a, b, cost));\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tE[] es=list.toArray(new E[0]);\n\t\tArrays.sort(es);\n\t\tinit();\n\t\tint wt=0;\n\t\tfor(E e : es){\n\t\t\tif(find(e.v1)!=find(e.v2)){\n\t\t\t\tunion(e.v1, e.v2);\n\t\t\t\twt+=e.w;\n\t\t\t}\n\t\t}\n\t\tprintln(\"\"+wt);\n\t}\n\n\tclass E implements Comparable<E>{\n\t\tint v1, v2, w;\n\n\t\tE(int v1, int v2, int w){\n\t\t\tthis.v1=v1;\n\t\t\tthis.v2=v2;\n\t\t\tthis.w=w;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(E e){\n\t\t\treturn w-e.w;\n\t\t}\n\t}\n\n\tint[] p, rank;\n\n\tvoid init(){\n\t\tp=new int[n];\n\t\trank=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tp[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(p[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn p[x]=find(p[x]);\n\t}\n\n\tvoid union(int x, int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]>rank[y]){\n\t\t\tp[y]=x;\n\t\t}else{\n\t\t\tp[x]=y;\n\t\t\tif(rank[x]==rank[y])\n\t\t\t\trank[y]++;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n,m;\n    int[][] cost;\n    int[] p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            cost = new int[m][3];\n            for(int i=0; i<m; i++)for(int j=0; j<3; j++) cost[i][j] = sc.nextInt();\n\n            init();\n\n            Arrays.sort(cost, new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[2] - b[2];\n                    }\n                });\n\n            int ans = 0;\n            for(int i=0; i<m; i++){\n                int a = cost[i][0], b = cost[i][1];\n                a = root(a); b = root(b);\n                if(a==b) continue;\n                merge(a,b);\n                ans += cost[i][2];\n            }\n\n            System.out.println(ans);\n        }\n    }\n\n    void init(){\n        p = new int[n];\n        for(int i=0; i<n; i++) p[i] = i;\n    }\n\n    int root(int a){\n        if(a==p[a]) return a;\n        else return p[a] = root(p[a]);\n    }\n\n    void merge(int a, int b){\n        a = root(a); b = root(b);\n        p[a] = b;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK=8*1024*1024;\n\t\tnew Thread(null, new AOJ0180(), \"RUN!\", STACK).start();\n\t}\n\t\n\tclass AOJ0180 implements Runnable{\n\t\tAOJ0180(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),E=sc.nextInt();\n\t\t\t\tif((N|E)==0)\tbreak;\n\t\t\t\tsolve(N,E);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N,int E){\n\t\t\tint[][] g=new int[N][N];\n\t\t\tfor(int i=0; i<N; i++)for(int j=0; j<N; j++)g[i][j]=1<<29;\n\t\t\tfor(int i=0; i<E; i++){\n\t\t\t\tint u=sc.nextInt(),v=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tg[u][v]=c;\n\t\t\t\tg[v][u]=c;\n\t\t\t}\n\t\t\tSystem.out.println(prim(g,N));\n\t\t}\n\t\t\n\t\tfinal int INF=1<<29;\n\t\tint prim(int[][] g,int N){\n\t\t\tint[] mincost=new int[N];\n\t\t\tboolean[] used=new boolean[N];\n\t\t\tfor(int i=0; i<N; i++)\tmincost[i]=INF;\n\t\t\t\n\t\t\tmincost[0]=0;\n\t\t\tint ret=0;\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0; u<N; u++){\n\t\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v]))\tv=u;\n\t\t\t\t}\n\t\t\t\tif(v < 0)\tbreak;\n\t\t\t\tused[v]=true;\n\t\t\t\tret+=mincost[v];\n\t\t\t\t\n\t\t\t\tfor(int u=0; u<N; u++)\tmincost[u]=min(mincost[u], g[v][u]);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,m,r;(n=s.nextInt())>0;System.out.println(r)){List<int[]>x=new ArrayList<int[]>();for(r=0,m=s.nextInt();m-->0;)x.add(new int[]{s.nextInt(),s.nextInt(),s.nextInt()});Collections.sort(x,new Comparator<int[]>(){public int compare(int[]a,int[]b){return a[2]-b[2];}});U u=new U(n);for(int[]e:x)if(!u.s(e[0],e[1])){u.u(e[0],e[1]);r+=e[2];}}}static class U{int[] p,r;U(int n){p=new int[n];r=new int[n];for(int i=0;i<n;++i)p[i]=i;}int f(int x){return(p[x]==x)?x:(p[x]=f(p[x]));}void u(int x,int y){x=f(x);y=f(y);if(x==y)return;if(r[x]<r[y]){p[x]=y;}else{p[y]=x;if(r[x]==r[y])++r[x];}}boolean s(int x,int y){return f(x)==f(y);}}}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * Stellar Performance of the Debunkey Family (Prim)\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0 0\")) {\n\n\t\t\tint n = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint m = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tGraph graph = main.new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tgraph.addEdge(br.readLine());\n\t\t\t}\n\t\t\tSystem.out.println(graph.prim());\n\n\t\t}\n\n\t}\n\n\tclass Graph {\n\n\t\tfinal int INFINITY = Integer.MAX_VALUE;\n\t\tfinal int UNREACHABLE = -1;\n\n\t\tint length;\n\t\tint[][] adjacency;\n\n\t\tGraph(int n) {\n\n\t\t\tlength = n;\n\t\t\tadjacency = new int[length][length];\n\t\t\tfor (int i = 0; i < length; ++i) {\n\t\t\t\tfor (int j = 0; j < length; ++j) {\n\t\t\t\t\tadjacency[i][j] = INFINITY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tvoid addEdge(String info) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tint b = Integer.parseInt(st.nextToken());\n\t\t\tint c = Integer.parseInt(st.nextToken());\n\n\t\t\tadjacency[a][b] = c;\n\t\t\tadjacency[b][a] = c;\n\n\t\t}\n\n\t\tint prim() {\n\n\t\t\tboolean[] checked = new boolean[length];\n\t\t\tint total, next;\n\n\t\t\tnext = 0;\n\t\t\ttotal = 0;\n\t\t\tchecked[next] = true;\n\n\t\t\twhile (next != UNREACHABLE) {\n\n\t\t\t\tnext = -1;\n\t\t\t\tint min = INFINITY;\n\t\t\t\tfor (int i = 0; i < length; ++i) {\n\t\t\t\t\tif (checked[i]) {\n\t\t\t\t\t\tfor (int j = 0; j < length; ++j) {\n\t\t\t\t\t\t\tif (!checked[j] && min > adjacency[i][j]) {\n\t\t\t\t\t\t\t\tmin = adjacency[i][j];\n\t\t\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (next != UNREACHABLE) {\n\t\t\t\t\ttotal += min;\n\t\t\t\t\tchecked[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Island {\n\t\tIsland parent;\n\t\t\n\t\tIsland () {\n\t\t\tthis.parent = this;\n\t\t}\n\t}\n\n\tstatic class Bridge implements Comparable<Bridge>{\n\t\tint number;\n\t\tint cost;\n\t\tIsland v1, v2;\n\n\t\tBridge (int number, int cost, Island v1, Island v2) {\n\t\t\tthis.number = number;\n\t\t\tthis.cost = cost;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tpublic int compareTo(Bridge o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tIsland island[];\n\t\tBridge bridge[];\n\t\tint sum;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tisland = new Island[n];\n\t\t\tbridge = new Bridge[m];\n\t\t\tsum = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tisland[i] = new Island();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v1 = sc.nextInt();\n\t\t\t\tint v2 = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tbridge[i] = new Bridge(i, cost, island[v1], island[v2]);\n\t\t\t}\n\t\t\tArrays.sort(bridge);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (!find(bridge[i].v1).equals(find(bridge[i].v2))) {\n\t\t\t\t\tsum += bridge[i].cost;\n\t\t\t\t\tunion(bridge[i].v1, bridge[i].v2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tpublic static Island find(Island v) {\n\t\tif (v.parent.equals(v)) {\n\t\t\treturn v;\n\t\t}\n\t\treturn find(v.parent);\n\t}\n\t\n\tpublic static void union(Island v1, Island v2) {\n\t\tIsland v3 = find(v1);\n\t\tIsland v4 = find(v2);\n\t\t\n\t\tv3.parent = v4;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic void solve() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) {\n\t\t\t\tout.flush();\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<Edge>[] edges = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tedges[i] = new ArrayList<Edge>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tedges[a].add(new Edge(a, b, cost));\n\t\t\t\tedges[b].add(new Edge(b, a, cost));\n\t\t\t}\n\t\t\t\n\t\t\tint ans = prim(n, edges);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tstatic int prim(int n, List<Edge>[] edges) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tq.add(new Edge(0, 0, 0));\n\n\t\tint totalCost = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tEdge e = q.poll();\n\t\t\tif (fixed[e.target]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfixed[e.target] = true;\n\t\t\ttotalCost += e.cost;\n\t\t\tq.addAll(edges[e.target]);\n\t\t}\n\t\t\n\t\treturn totalCost;\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint source, target, cost;\n\n\t\tpublic Edge(int source, int target, int cost) {\n\t\t\tthis.source = source;\n\t\t\tthis.target = target;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic int compareTo(Edge e) {\n\t\t\treturn this.cost - e.cost;\n\t\t}\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a < b ? b : a;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte()) {\n\t\t\treturn buffer[ptr++];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic double nextDouble() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tdouble d = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\tlong t = 0;\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\td *= 10;\n\t\t\t\td += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\tif (t != 0) {\n\t\t\t\t\td = d / t;\n\t\t\t\t}\n\t\t\t\treturn minus ? -d : d;\n\t\t\t} else if (b == '.') {\n\t\t\t\tt = 1;\n\t\t\t\tb = readByte();\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tt *= 10;\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\nimport static java.util.Arrays.fill;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tList<E> es = new ArrayList<E>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tE e = new E(a, b, c);\n\t\t\t\tes.add(e);\n\t\t\t}\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tCollections.sort(es);\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor (E e: es) {\n\t\t\t\tif (uf.root(e.a) != uf.root(e.b)) {\n\t\t\t\t\tuf.link(e.a, e.b);\n\t\t\t\t\tans += e.c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tstatic class E implements Comparable<E> {\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t\tE(int a, int b, int c) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\treturn c - o.c;\n\t\t}\n\t}\n\npublic class UnionFind {\n\tint[] data;\n\tpublic UnionFind(int n) {\n\t\tdata = new int[n];\n\t\tfill(data, -1);\n\t}\n\tboolean link(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tdata[y] += data[x];\n\t\t\t\tdata[x] = y;\n\t\t\t} else {\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\t\t\t\n\t\t\tUF uf = new UF(n);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tfor (int i=0;i<m;i++) q.add(new E(sc.nextInt(), sc.nextInt(), sc.nextInt()));\n\t\t\t\n\t\t\tint c = 0;\n\t\t\tfor (;! q.isEmpty();) {\n\t\t\t\tE cur = q.remove();\n\t\t\t\tif (uf.same(cur.f, cur.t)) continue;\n\t\t\t\tuf.unite(cur.f,  cur.t);\n\t\t\t\tc += cur.c;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E> {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.f = f;\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\t// TODO ティツ?ェテ・ツ仰陛ァツ板淌ヲツ按静」ツ?陛」ツつ古」ツ?淌」ツδ。テ」ツつステ」ツδε」ツδ嘉」ツδサテ」ツつケテ」ツつソテ」ツδ?\n\t\t\treturn c - o.c;\n\t\t}\n\t\t\n\t}\n\t\n\tclass UF {\n\t\tint[] par, rank;\n\t\t\n\t\tpublic UF(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i=0;i<n;i++) par[i] = i;\n\t\t}\n\t\t\n\t\t//テ、ツサツ」ティツ。ツィテ・ツ?ε」ツつ津ヲツアツづ」ツつ?」ツつ?\n\t\tint find(int x) {\n\t\t\tif( par[x] == x ) return x;\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\t//ティツヲツ?ァツエツ?テ」ツ?ィyテ」ツつ津、ツスツオテ・ツ青暗」ツ?凖」ツつ?\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif( x == y ) return;\n\t\t\t\n\t\t\tif( rank[x] < rank[y]  ) par[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif( rank[x] == rank[y] ) rank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//テ・ツ青古、ツクツ?」ツ?ョテゥツ崢?・ツ青暗」ツ?ォテ・ツ青ォテ」ツ?セテ」ツつ古」ツつ凝」ツ?凝ィツェツソテ」ツ?ケテ」ツつ凝ッツシツ師rueテ」ツ?ェテ」ツつ悦テ」ツ?ィyテ」ツ?ッテ・ツ青古」ツ?佚ゥツ崢?・ツ青暗ッツシツ掲alseテ」ツ?ェテ」ツつ嘉ァツ閉ーテ」ツ?ェテ」ツつ?\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) a[i, j] = -1;\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                a[int.Parse(line2[0]), int.Parse(line2[1])] = int.Parse(line2[2]);\n            }\n            Console.WriteLine(getStlist(a));\n        }\n    }\n    public static int getStlist(int[,] a)\n    {\n        var s = new List<int>();\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 1001;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n    class hasi {\n        public int c1=-1, c2=-1;\n        public bool used = false;\n        public int cost = -1;\n        public hasi(int c1, int c2, int cost){this.cost = cost; this.c1=c1;this.c2=c2;}\n        public int transPortFrom(int start) {\n            if (start == c1) { return c2; }\n            if (start == c2) { return c1; }\n            else { return -1; }\n        }\n\n    }\n\n    class city {\n        public bool check = false;\n         public int id;\n        public hasi fromHasi = null;\n    }\n\n\n    class ClassMain {\n\n       \n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] nm = line.Split(' ').Select(int.Parse).ToArray();\n                if (nm[0] == 0) { break; }\n                city[] cities = new city[nm[0]];\n                for (int i = 0; cities.Length > i; i++) { \n                    cities[i]= new city();\n                    cities[i].id = i; \n                }\n                hasi[] hasis = new hasi[nm[1]];\n\n                for (int i = 0; i < nm[1]; i++) {\n                    int[] inputs =\n                        Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    hasis[i]=new hasi(inputs[0],inputs[1],inputs[2]);\n\n                }\n\n                doDijkstra(cities, hasis);\n\n                int sumcost = 0;\n                for (int i = 0; i < hasis.Length; i++) {\n                    if (hasis[i].used) { sumcost += hasis[i].cost; }\n                }\n                Console.WriteLine(sumcost);\n            }\n        }\n\n\n        public static void doDijkstra(city[] cities, hasi[] hasis) {\n            cities[0].check = true;\n            while (true) {\n                //Check.\n                int min = int.MaxValue;\n                hasi addHashi = null;\n                for (int i = 0; i < cities.Length; i++) {\n                    city acity = cities[i];\n                    if (acity.check == false) { continue; }\n                    \n                    for (int j = 0; j < hasis.Length; j++) {\n                        int transTo = hasis[j].transPortFrom(acity.id);\n                        if (transTo < 0) { continue; }\n                        if (cities[transTo].check) { continue; }\n                        if (hasis[j].cost < min) {\n                            min = hasis[j].cost;\n                            addHashi = hasis[j];\n                        }\n                    }\n                }\n                cities[addHashi.c1].check = true;\n                cities[addHashi.c2].check = true;\n                addHashi.used = true;\n\n                bool endflg = true;\n                for (int i = 0; i < cities.Length; i++) {\n                    if(cities[i].check==false){endflg = false;}\n                }\n                if (endflg) { return; }\n            }//endWile\n        }//end dijkstra\n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) a[i, j] = -1;\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                a[int.Parse(line2[0]), int.Parse(line2[1])] = int.Parse(line2[2]);\n            }\n            Console.WriteLine(getStlist(a));\n        }\n    }\n    public static int getStlist(int[,] a)\n    {\n        var s = new List<int>();\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 999999;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (i == j) a[i, j] = 0;\n                    else a[i, j] = -1;\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                var w1 = int.Parse(line2[0]);\n                var w2 = int.Parse(line2[1]);\n                var w3 = int.Parse(line2[2]);\n                a[w1, w2] = w3; a[w2, w1] = w3;\n            }\n            var s = new List<int>();\n            var res = getStlist(a, s);\n            Console.WriteLine(res);\n        }\n    }\n    public static int getStlist(int[,] a, List<int> s)\n    {\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 999999;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n    class hasi {\n        public int c1=-1, c2=-1;\n        public bool used = false;\n        public int cost = -1;\n        public hasi(int c1, int c2, int cost){this.cost = cost; this.c1=c1;this.c2=c2;}\n        public int transPortFrom(int start) {\n            if (start == c1) { return c2; }\n            if (start == c2) { return c1; }\n            else { return -1; }\n        }\n\n    }\n\n    class city {\n        public bool check = false;\n         public int id;\n        public hasi fromHasi = null;\n    }\n\n\n    class ClassMain {\n\n       \n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] nm = line.Split(' ').Select(int.Parse).ToArray();\n                if (nm[0] == 0) { break; }\n                city[] cities = new city[nm[0]];\n                for (int i = 0; cities.Length > i; i++) { \n                    cities[i]= new city();\n                    cities[i].id = i; \n                }\n                hasi[] hasis = new hasi[nm[1]];\n\n                for (int i = 0; i < nm[1]; i++) {\n                    int[] inputs =\n                        Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    hasis[i]=new hasi(inputs[0],inputs[1],inputs[2]);\n\n                }\n\n                doDijkstra(cities, hasis);\n\n                int sumcost = 0;\n                for (int i = 0; i < hasis.Length; i++) {\n                    if (hasis[i].used) { sumcost += hasis[i].cost; }\n                }\n                Console.WriteLine(sumcost);\n            }\n        }\n\n\n        public static void doDijkstra(city[] cities, hasi[] hasis) {\n            cities[0].check = true;\n            while (true) {\n                //Check.\n                city checkNow = null;\n                int min = int.MaxValue;\n                hasi addHashi = null;\n                for (int i = 0; i < cities.Length; i++) {\n                    city acity = cities[i];\n                    if (acity.check == false) { continue; }\n                    \n                    for (int j = 0; j < hasis.Length; j++) {\n                        int transTo = hasis[j].transPortFrom(acity.id);\n                        if (transTo < 0) { continue; }\n                        if (cities[transTo].check) { continue; }\n                        if (hasis[j].cost < min) {\n                            min = hasis[j].cost;\n                            addHashi = hasis[j];\n                        }\n                    }\n                }\n                cities[addHashi.c1].check = true;\n                cities[addHashi.c2].check = true;\n                addHashi.used = true;\n\n                bool endflg = true;\n                for (int i = 0; i < cities.Length; i++) {\n                    if(cities[i].check==false){endflg = false;}\n                }\n                if (endflg) { return; }\n            }//endWile\n        }//end dijkstra\n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\n\nnamespace Test1 {\n\n\n\n    class hasi {\n        public int c1=-1, c2=-1;\n        public bool used = false;\n        public int cost = -1;\n        public hasi(int c1, int c2, int cost){this.cost = cost; this.c1=c1;this.c2=c2;}\n        public int transPortFrom(int start) {\n            if (start == c1) { return c2; }\n            if (start == c2) { return c1; }\n            else { return -1; }\n        }\n\n    }\n\n    class city {\n        public bool check = false;\n        public int cost = int.MaxValue;\n        public int id;\n        public hasi fromHasi = null;\n    }\n\n\n    class ClassMain {\n\n       \n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] nm = line.Split(' ').Select(int.Parse).ToArray();\n                if (nm[0] == 0) { break; }\n                city[] cities = new city[nm[0]];\n                for (int i = 0; cities.Length > i; i++) { \n                    cities[i]= new city();\n                    cities[i].id = i; \n                }\n                hasi[] hasis = new hasi[nm[1]];\n\n                for (int i = 0; i < nm[1]; i++) {\n                    int[] inputs =\n                        Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    hasis[i]=new hasi(inputs[0],inputs[1],inputs[2]);\n\n                }\n\n                doDijkstra(cities, hasis);\n\n                int sumcost = 0;\n                for (int i = 0; i < hasis.Length; i++) {\n                    if (hasis[i].used) { sumcost += hasis[i].cost; }\n                }\n                Console.WriteLine(sumcost);\n            }\n        }\n\n\n        public static void doDijkstra(city[] cities, hasi[] hasis) {\n            cities[0].cost = 0;\n            while (true) {\n                //Check.\n                city checkNow = null;\n                int min = int.MaxValue;\n                for (int i = 0; i < cities.Length; i++) {\n                    city acity = cities[i];\n                    if (acity.check == true) { continue; }\n                    if (acity.cost < min) {\n                        min = acity.cost;\n                        checkNow = acity;\n                    }\n                }\n                if (checkNow == null) { break; }\n                //Console.WriteLine(\"checked\"+checkNow.id);\n                checkNow.check = true;\n                if (checkNow.fromHasi != null) { checkNow.fromHasi.used = true; }\n                //end check.\n\n                //Edges and reload costs.\n                for (int i = 0; i < hasis.Length; i++) {\n                    hasi ahasi = hasis[i];\n                    int transTo = ahasi.transPortFrom(checkNow.id);\n                    if (transTo < 0) { continue; }\n                    else {\n                        city toCity = cities[transTo];\n                        int newCost = checkNow.cost + ahasi.cost;\n                        if (newCost < toCity.cost) {\n                            toCity.cost = newCost;\n                            toCity.fromHasi = ahasi;\n                        }\n                    }\n\n                }\n            }//endWile\n        }//end dijkstra\n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                {\n                    if (i == j) a[i, j] = 0;\n                    else a[i, j] = -1;\n                }\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                a[int.Parse(line2[0]), int.Parse(line2[1])] = int.Parse(line2[2]);\n            }\n            Console.WriteLine(getStlist(a));\n        }\n    }\n    public static int getStlist(int[,] a)\n    {\n        var s = new List<int>();\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 999999;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) a[i, j] = -1;\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                a[int.Parse(line2[0]), int.Parse(line2[1])] = int.Parse(line2[2]);\n            }\n            Console.WriteLine(getStlist(a));\n        }\n    }\n    public static int getStlist(int[,] a)\n    {\n        var s = new List<int>();\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 9999;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) a[i, j] = -1;\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                var w1 = int.Parse(line2[0]);\n                var w2 = int.Parse(line2[1]);\n                var w3 = int.Parse(line2[2]);\n                a[w1, w2] = w3; a[w2, w1] = w3;\n            }\n            Console.WriteLine(getStlist(a));\n        }\n    }\n    public static int getStlist(int[,] a)\n    {\n        var s = new List<int>();\n        var n = a.GetLength(0);\n        var a1 = 0;\n        var totalmincost = 0;\n        while (true)\n        {\n            s.Add(a1);\n            if (s.Count() == n) return totalmincost;\n            var nexta1 = -1; var mincost = 999999;\n            foreach (var x in s)\n                for (int i = 0; i < n; i++)\n                    if (!s.Contains(i) && a[x, i] != -1 && a[x, i] < mincost) { nexta1 = i; mincost = a[x, i]; }\n                    else a1 = nexta1;\n            totalmincost += mincost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0180\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RIntAr();\n                if (nm.Sum() == 0) break;\n\n                Graph gh = new Graph();\n                for (int i = 0 ; i < nm[0] ; i++) gh.Adj.Add(i, new Graph.Node(new List<int>()));\n\n                for (int i = 0 ; i < nm[1] ; i++)\n                {\n                    var tmp = RIntAr();\n                    gh.AddVertex(tmp[0], tmp[1], tmp[2]);\n                    gh.AddVertex(tmp[1], tmp[0], tmp[2]);\n                }\n\n                Console.WriteLine(gh.Prim());\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public class Graph\n    {\n        public class Node\n        {\n            public List<KeyValuePair<int, int>> Vertex { get; internal set; }\n            public int D { get; internal set; }\n            public int F { get; internal set; }\n            public bool IsVisited { get; internal set; }\n            public int Group { get; internal set; }\n            public int Depth { get; internal set; }\n            public int Distance { get; internal set; }\n\n            public Node(List<int> v)\n            {\n                Vertex = v.Select(x => new KeyValuePair<int, int>(x, -1)).ToList();\n                Depth = -1;\n                Group = -1;\n                Distance = int.MaxValue;\n            }\n\n            public Node(List<KeyValuePair<int, int>> v)\n            {\n                Vertex = v;\n                Depth = -1;\n                Group = -1;\n                Distance = int.MaxValue;\n            }\n\n        }\n\n        public Dictionary<int, Node> Adj { get; set; }\n        public int Count { get { return Adj.Count; } }\n\n        public Graph()\n        {\n            Adj = new Dictionary<int, Node>();\n        }\n\n        public void AddVertex(int index, int v, int cost)\n        {\n            if (!Adj[index].Vertex.Contains(new KeyValuePair<int, int>(v, cost)))\n            {\n                Adj[index].Vertex.Add(new KeyValuePair<int, int>(v, cost));\n            }\n        }\n\n\n        /// <summary>\n        /// 指定した頂点をセットする\n        /// </summary>\n        /// <param name=\"index\">頂点u</param>\n        /// <param name=\"item\">頂点uに接続する頂点</param>\n        public void SetGraph(int index, int[] item)\n        {\n            if (item == null)\n            {\n                Adj.Add(index, new Node(new List<int>()));\n            }\n            else\n            {\n                Adj.Add(index, new Node(item.ToList()));\n            }\n        }\n\n        public void SetGraph(int index, List<KeyValuePair<int, int>> item)\n        {\n            if (item == null)\n            {\n                Adj.Add(index, new Node(new List<int>()));\n            }\n            else\n            {\n                Adj.Add(index, new Node(item));\n            }\n        }\n\n        public void SetGraph(int index, int v, int c)\n        {\n            if (!Adj.ContainsKey(index))\n            {\n                SetGraph(index);\n            }\n            Adj[index].Vertex.Add(new KeyValuePair<int, int>(v, c));\n        }\n\n        public void SetGraph(int index)\n        {\n            if (!Adj.ContainsKey(index))\n            {\n                Adj.Add(index, new Node(new List<KeyValuePair<int, int>>()));\n            }\n        }\n\n\n        /// <summary>\n        /// 行列を0で初期化する\n        /// </summary>\n        public void Clear() { Adj.Clear(); }\n\n        /// <summary>\n        /// 深さ優先探索\n        /// </summary>\n        private int Time = 0;\n        public void DFS(int v)\n        {\n            Adj[v].D = ++Time;\n            Adj[v].IsVisited = true;\n            foreach (KeyValuePair<int, int> vertex in Adj[v].Vertex)\n            {\n                if (!Adj[vertex.Key].IsVisited) DFS(vertex.Key);\n            }\n            Adj[v].F = ++Time;\n        }\n\n        /// <summary>\n        /// 訪問済フラグをクリアする\n        /// </summary>\n        private void InitVisitFlag()\n        {\n            foreach (KeyValuePair<int, Node> item in Adj) item.Value.IsVisited = false;\n        }\n\n        /// <summary>\n        /// 幅優先探索\n        /// </summary>\n        /// <param name=\"v\"></param>\n        public void BFS(int v)\n        {\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[v].Depth = 0;\n            Adj[v].IsVisited = true;\n            que.Enqueue(Adj[v]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (!Adj[vertex.Key].IsVisited)\n                    {\n                        Adj[vertex.Key].IsVisited = true;\n                        Adj[vertex.Key].Depth = node.Depth + 1;\n                        que.Enqueue(Adj[vertex.Key]);\n\n                    }\n                }\n            }\n\n        }\n\n        /// <summary>\n        /// 頂点間の最小頂点数を返す\n        /// </summary>\n        /// <param name=\"start\">始点</param>\n        /// <param name=\"end\">終点</param>\n        /// <returns>\n        /// 始点と終点の距離\n        /// 始点と終点が連結されていない場合は-1を返す\n        /// </returns>\n        public int GetDistance(int start, int end)\n        {\n            InitVisitFlag();\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[start].IsVisited = true;\n            Adj[start].Depth = 0;\n\n            if (start == end) return Adj[start].Depth;\n            que.Enqueue(Adj[start]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (!Adj[vertex.Key].IsVisited)\n                    {\n                        Adj[vertex.Key].IsVisited = true;\n                        Adj[vertex.Key].Depth = node.Depth + 1;\n\n                        if (vertex.Key == end) return Adj[vertex.Key].Depth;\n                        que.Enqueue(Adj[vertex.Key]);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        /// <summary>\n        /// 連結である頂点に同一のグループ番号をセットする\n        /// </summary>\n        public void SetGroup()\n        {\n            int group = 0;\n            foreach (KeyValuePair<int, Node> item in Adj)\n            {\n                if (item.Value.Group < 0)\n                {\n                    _SetGroup(item.Key, group);\n                }\n                group++;\n            }\n        }\n\n        private void _SetGroup(int key, int group)\n        {\n\n            Queue<Node> que = new Queue<Node>();\n\n            Adj[key].Group = group;\n            que.Enqueue(Adj[key]);\n\n            while (que.Count() != 0)\n            {\n                Node node = que.Dequeue();\n                foreach (KeyValuePair<int, int> vertex in node.Vertex)\n                {\n                    if (Adj[vertex.Key].Group < 0)\n                    {\n                        Adj[vertex.Key].Group = group;\n                        que.Enqueue(Adj[vertex.Key]);\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 最小全域木のコストを求める（プリム法）\n        /// </summary>\n        /// <returns></returns>\n        class Edge : IComparable<Edge>\n        {\n            public int NextV { get; set; }\n            public int Cost { get; set; }\n\n            public Edge(int nextV, int cost)\n            {\n                NextV = nextV;\n                Cost = cost;\n            }\n\n            public int CompareTo(Edge other)\n            {\n                return -1 * Cost.CompareTo(other.Cost);\n            }\n        }\n        public int Prim()\n        {\n            PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n            int totalCost = 0;\n            pq.Enqueue(new Edge(Adj.First().Key, 0));\n\n            while (pq.Count > 0)\n            {\n                Edge e = pq.Dequeue();\n                if (!Adj[e.NextV].IsVisited)\n                {\n                    Adj[e.NextV].IsVisited = true;\n                    totalCost += e.Cost;\n                    foreach (KeyValuePair<int, int> vertex in Adj[e.NextV].Vertex)\n                    {\n                        pq.Enqueue(new Edge(vertex.Key, vertex.Value));\n                    }\n                }\n\n            }\n\n            return totalCost;\n\n        }\n\n        /// <summary>\n        /// 始点からの距離をセットする（ダイクストラ法）\n        /// </summary>\n        /// <param name=\"s\">始点</param>\n        class Candidate : IComparable<Candidate>\n        {\n            public int V { get; set; }\n            public int Distance { get; set; }\n\n            public Candidate(int v, int d) { Distance = d; V = v; }\n            public int CompareTo(Candidate other) { return -1 * Distance.CompareTo(other.Distance); }\n        }\n        public void Dijkstra(int s)\n        {\n            Adj[s].Distance = 0;\n            PriorityQueue<Candidate> pq = new PriorityQueue<Candidate>();\n            pq.Enqueue(new Candidate(s, Adj[s].Distance));\n\n            while (pq.Count > 0)\n            {\n\n                Candidate c = pq.Dequeue();\n                int v = c.V;\n                int d = c.Distance;\n\n                if (Adj[v].Distance < c.Distance)\n                {\n                    continue;\n                }\n\n                foreach (KeyValuePair<int, int> nextV in Adj[v].Vertex)\n                {\n                    if (Adj[nextV.Key].Distance > Adj[v].Distance + nextV.Value)\n                    {\n                        Adj[nextV.Key].Distance = Adj[v].Distance + nextV.Value;\n                        pq.Enqueue(new Candidate(nextV.Key, Adj[nextV.Key].Distance));\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    public class PriorityQueue<T> where T : IComparable<T>\n\n    {\n\n        private List<T> Buffer { get; set; }\n\n        public int Count { get { return Buffer.Count; } }\n\n        public PriorityQueue() { Buffer = new List<T>(); }\n        public PriorityQueue(int capacity) { Buffer = new List<T>(capacity); }\n\n\n        /// <summary>\n        /// ヒープ化されている配列リストに新しい要素を追加する。\n        /// </summary>\n        public void Enqueue(T item)\n        {\n            int n = Buffer.Count;\n            Buffer.Add(item);\n\n            while (n != 0)\n            {\n                int i = (n - 1) / 2;\n                if (Buffer[n].CompareTo(Buffer[i]) > 0)\n                {\n                    T tmp = Buffer[n]; Buffer[n] = Buffer[i]; Buffer[i] = tmp;\n                }\n                n = i;\n            }\n        }\n\n        /// <summary>\n        /// ヒープから最大値を取り出し、削除する。\n        /// </summary>\n        public T Dequeue()\n        {\n            T ret = Buffer[0];\n            int n = Buffer.Count - 1;\n            Buffer[0] = Buffer[n];\n            Buffer.RemoveAt(n);\n\n            for (int i = 0, j ; (j = 2 * i + 1) < n ;)\n            {\n                if ((j != n - 1) && (Buffer[j].CompareTo(Buffer[j + 1]) < 0))\n                    j++;\n                if (Buffer[i].CompareTo(Buffer[j]) < 0)\n                {\n                    T tmp = Buffer[j]; Buffer[j] = Buffer[i]; Buffer[i] = tmp;\n                }\n                i = j;\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// ヒープから最大値を参照する。\n        /// </summary>\n        public T Peek()\n        {\n            if (Count == 0) throw new InvalidOperationException();\n            return this.Buffer[0];\n        }\n    }\n\n}\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var nm=Arr.shift().split(\" \").map(Number);\n   var n=nm[0];\n   var m=nm[1];\n   if(n==0 && m==0)break;\n   var N=[];\n   for(var i=0;i<n;i++){\n      N[i]=[];\n      for(var j=0;j<n;j++){\n         N[i][j]=Infinity;\n         if(i==j)N[i][j]=0;\n      }\n   }\n   var arr=[];\n   for(var i=0;i<m;i++){\n      var abc=Arr.shift().split(\" \").map(Number);\n      var a=abc[0];\n      var b=abc[1];\n      var c=abc[2];\n      N[a][b]=c;\n      N[b][a]=c;\n   }\n   var city=[0];\n   var cost=0;\n   while(true){\n      if(city.length==n)break;\n      var min=Infinity;\n      var select=-1;\n      for(var i=0;i<city.length;i++){\n         for(var j=0;j<n;j++){\n            if(city.indexOf(j)!=-1)continue;\n            if(N[city[i]][j]<min){\n               select=j;\n               min=N[city[i]][j];\n            }\n         }\n      }\n      if(select!=-1){\n         cost+=min;\n         city.push(select);\n      }\n   }\n   console.log(cost);\n}"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\nc=(1..n).map{{}}\nm.times{a,b,t=gets.split.map &:to_i;c[a][b]=c[b][a]=t}\nd=[s=0]\n(y,z=d.flat_map{|i|[*c[i].select{|k,v|d-[k]==d}]}.min_by{|k,v|v};s+=z;d<<y)while[*0..n-1]!=d.sort\np s\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\nc=(1..n).map{{}}\nm.times{a,b,t=gets.split.map &:to_i;c[a][b]=c[b][a]=t}\nd=[s=0]\n(y,z=d.flat_map{|i|[*c[i].select{|k,v|d-[k]==d}]}.min_by{|k,v|v};s+=z;d<<y)until d[n-1]\np s\nend"
  },
  {
    "language": "Ruby",
    "code": "Infinity = 1000000\n\ndef decreaseKey q, v, w\n  q.size.times do |i|\n    if q[i][0] == v\n      q[i][1] = w\n      break\n    end\n  end\nend\n\ndef inQueue q, v\n  q.size.times do |i|\n    return true if q[i][0] == v\n  end\n  false\nend\n\ndef prim graph\n  n = graph.size\n  key = Array.new(n, Infinity)\n  key[0] = 0\n  q = Array.new\n  n.times do |i|\n    q << [i, key[i]]\n  end\n\n  until q.empty?\n    #最少のキー値を持つノードを取り出す\n    u = -1\n    min = Infinity\n    q.size.times do |i|\n      if q[i][1] < min\n        min = q[i][1]\n        u = q[i][0]\n      end\n    end\n    q.size.times do |i|\n      if q[i][0] == u\n        q.delete_at(i)\n        break\n      end\n    end\n\n    #そのノードから接続しているすべてのノードについて、キー値を更新する\n    n.times do |v|\n      next if graph[u][v] == Infinity\n      if inQueue(q, v)\n        w = graph[u][v]\n        #キー値を更新したら、キュー格納値のキーを更新\n        if w < key[v]\n          key[v] = w\n          decreaseKey(q, v, w)\n        end\n      end\n    end\n  end\n  key\nend\n\nloop do\n  n,m = $stdin.gets.chomp.split(\" \").map(&:to_i)\n  break if (n|m) == 0\n  graph = Array.new(n).map{Array.new(n, Infinity)}\n  m.times do |i|\n    a,b,cost = $stdin.gets.chomp.split(\" \").map(&:to_i)\n    graph[a][b] = cost\n    graph[b][a] = cost\n  end\n  p prim(graph).inject(:+)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n### main\n\nwhile true\n  n, m = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && m == 0\n\n  edges = []\n\n  m.times.each do\n    edge = gets.strip.split(' ').map{|s| s.to_i}\n    edges << edge\n  end\n\n  edges.sort! do |a, b|\n    (cmp2 = a[2] <=> b[2]) != 0 ? cmp2 :\n      (cmp0 = a[0] <=> b[0]) != 0 ? cmp0 : a[1] <=> b[1]\n  end\n\n  nd0, nd1, c = edges.shift\n\n  con = Set.new([nd0, nd1])\n  cost = c\n\n  while con.length < n && ! edges.empty?\n    for e in edges\n      nd0, nd1, c = e\n\n      inc0 = con.include? nd0\n      inc1 = con.include? nd1\n\n      if inc0 || inc1\n        if ! inc0\n          con << nd0\n          cost += c\n        elsif ! inc1\n          con << nd1\n          cost += c\n        end\n        edges.delete e\n        break\n      end\n    end\n  end\n\n  puts cost\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop do\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tg = Graph.new\n\tnodes = (1..n).map { g.add_node }\n\t(1..m).each do\n\t\ti, j, c = gets.split.map &:to_i\n\t\tg.add_edge(nodes[i], nodes[j], {:length => c})\n\tend\n\tp g.prim(nodes[0])\nend"
  },
  {
    "language": "Ruby",
    "code": "until (given = $<.gets.split.map(&:to_i)) == [0, 0]\n  n, m = given\n  bridges = m.times.map {$<.gets.split.map(&:to_i)}.sort_by(&:last)\n  city = Array.new(n, false)\n  city[0] = true\n  appearance = 1\n  total_cost = 0\n  \n  while appearance < n\n    bridges.each_index do |i|\n      a, b, cost = bridges[i]\n      if city[a] or city[b]\n        if !city[a]\n          city[a] = true\n          appearance += 1\n          total_cost += cost\n        elsif !city[b]\n          city[b] = true\n          appearance += 1\n          total_cost += cost\n        end\n        bridges.delete_at(i)\n        break\n      end\n    end\n  end\n  \n  puts total_cost\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def root a\n\treturn a if @p[a] == a\n\treturn (@p[a] = root(@p[a]))\nend\n\ndef isSameSet a, b\n\treturn root(a) == root(b)\nend\n\ndef unite a, b\n\t@p[root(a)] = root(b)\nend\n\nwhile true\n\tn,m = gets.split(\" \").map{|e|e.to_i}\n\tbreak if n==0 && m==0\n\tcost=0\n\t@p=[]\n\tn.times{|t|@p.push t}\n\tinfo=[]\n\tm.times{\n\t\ta,b,c=gets.split(\" \").map{|e|e.to_i}\n\t\tinfo.push [c,a,b]\n\t}\n\tinfo.sort!\n\n\tinfo.each{|e|\n\t\tif !isSameSet(e[2],e[1])\n\t\t\tunite(e[2],e[1])\n\t\t\tcost+=e[0]\n\t\tend\n\t}\n\n\tp cost\nend"
  },
  {
    "language": "Go",
    "code": "// Find the minimum spanning tree by the Kruskal algorithm\n// -------------------------------------------------------\n// Kruskal(G):\n//     A = ∅\n//     foreach v ∈ G.V:\n//        MAKE-SET(v)\n//     foreach (u, v) in G.E ordered by weight(u, v), increasing:\n//         if FIND-SET(u) ≠ FIND-SET(v):\n//             A = A ∪ {(u, v)}\n//             UNION(u, v)\n//     return A\n//\n// Ref: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"fmt\"\n\t)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar (\n\tmatrix [][]int\n)\n\ntype Edge struct {\n\ta, b, cost, added int\n}\ntype ByCost []Edge\n\nvar edges ByCost\n\nfunc (a ByCost) Len() int           { return len(a) }\nfunc (a ByCost) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByCost) Less(i, j int) bool { return a[i].cost < a[j].cost }\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tn, _ := strconv.Atoi(buf[0])\n\t\tm, _ := strconv.Atoi(buf[1])\n\t\tif n == 0 && m == 0 {\n\t\t\tbreak\n\t\t}\n\t\tmatrix = make([][]int, n)\n\t\tfor i := range matrix {\n\t\t\tmatrix[i] = make([]int, n)\n\t\t}\n\t\tfor i := 0; i < m; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf_ := strings.Split(scanner.Text(), \" \")\n\t\t\ta, _ := strconv.Atoi(buf_[0])\n\t\t\tb, _ := strconv.Atoi(buf_[1])\n\t\t\tcost, _ := strconv.Atoi(buf_[2])\n\t\t\tmatrix[a][b] = cost\n\t\t\tmatrix[b][a] = cost\n\t\t}\n\t\tsum := Kruskal(n)\n\t\tfmt.Println(sum)\n\t\tif len(edges) > 0 {\n\t\t\tedges = []Edge{}\n\t\t}\n\t}\n}\n\nfunc Kruskal_func(size, edge_num int) int {\n\tfor i := 0; i < size; i++ {\n\t\tfor j := 0; j < size; j++ {\n\t\t\tif matrix[i][j] > 0 {\n\t\t\t\ttmp := Edge{i, j, matrix[i][j], 0}\n\t\t\t\tedges = append(edges, tmp)\n\t\t\t}\n\t\t}\n\t}\n\tsort.Sort(ByCost(edges))\n\tUF_Init(edge_num)\n\tfor i := 0; i < edge_num; i++ {\n\t\ta := edges[i].a\n\t\tb := edges[i].b\n\t\tif UF_Find(a) != UF_Find(b) {\n\t\t\tedges[i].added = 1\n\t\t\tUF_Union(UF_Find(a), UF_Find(b))\n\t\t}\n\t}\n\tsum := 0\n\tfor i := 0; i < edge_num; i++ {\n\t\tif edges[i].added != 0 {\n\t\t\t// log.Printf(\"edge(%d,%d) is added\\n\", edges[i].a, edges[i].b)\n\t\t\tsum += edges[i].cost\n\t\t}\n\t}\n\treturn sum\n}\n\nfunc Kruskal(size int) int {\n\tedge_num := 0\n\tfor i := 0; i < size; i++ {\n\t\tfor j := 0; j < size; j++ {\n\t\t\tif matrix[i][j] > 0 {\n\t\t\t\tedge_num++\n\t\t\t}\n\t\t}\n\t}\n\treturn Kruskal_func(size, edge_num)\n}\n\n/*** Union-Find functions ***/\nvar UF_Parent []int\nvar UF_Rank []int\n\nfunc UF_Init(n int) {\n\tUF_Parent = make([]int, n)\n\tUF_Rank = make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tUF_Parent[i] = i\n\t\tUF_Rank[i] = 0\n\t}\n}\nfunc UF_Union(a, b int) {\n\tif UF_Rank[a] < UF_Rank[b] {\n\t\tUF_Parent[a] = b\n\t} else {\n\t\tUF_Parent[b] = a\n\t}\n\tif UF_Rank[a] == UF_Rank[b] {\n\t\tUF_Rank[a]++\n\t}\n}\nfunc UF_Find(a int) int {\n\tif UF_Parent[a] == a {\n\t\treturn a\n\t}\n\treturn UF_Find(UF_Parent[a])\n}\n/*** Union-Find functions ***/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nint N, M;\nvoid main() {\n    while(true) {\n        int[] input = readln.split.to!(int[]);\n        if (input == [0, 0]) break;\n        N = input[0];\n        M = input[1];\n        Edge[] edges = new Edge[M];\n        foreach(int i; 0..M) {\n            input = readln.split.to!(int[]);\n            int a = input[0];\n            int b = input[1];\n            edges[i] = Edge(input[2], min(a, b), max(a, b));\n        }\n        sort!(\"a.cost<b.cost\")(edges);\n        int[] usedNode = [0];\n        int ans = 0;\n        foreach(int i; 1..N) {\n            for (int j=0; j<edges.length; j++) {\n                bool flg1 = usedNode.canFind(edges[j].from);\n                bool flg2 = usedNode.canFind(edges[j].to);\n                if (flg1 && !flg2) {\n                    usedNode ~= edges[j].to;\n                    ans += edges[j].cost;\n                    break;\n                } else if (!flg1 && flg2)  {\n                    usedNode ~= edges[j].from;\n                    ans += edges[j].cost;\n                    break;\n                }\n            }\n        }\n        ans.writeln;\n    }\n}\nstruct Edge {\n    int cost;\n    int from, to;\n    this(int cost, int from, int to) {\n        this.cost = cost;\n        this.from = from;\n        this.to = to;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\n\nconst int N = 101;\n\nint[N][N] cost;\nint[N] minCost, used;\n\nvoid main(){\n\tint n, m, a, b, c, ans;\n\twhile (readf(\"%d %d\\n\", &n, &m), n || m) {\n\t\tminCost[] = int.max;\n\t\tused[] = false;\n\t\tforeach (i; 0..n) cost[i][] = int.max;\n\t\tforeach (i; 0..m) {\n\t\t\treadf(\"%d %d %d\\n\", &a, &b, &c);\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t}\n\t\tminCost[0] = ans = 0;\n\t\t\n\t\t// Prim\n\t\twhile (1) {\n\t\t\tint v = -1;\n\t\t\tforeach (i; 0..n)\n\t\t\t\tif (!used[i] && (v == -1 || minCost[i] < minCost[v]))\n\t\t\t\t\tv = i;\n\n\t\t\tif (v == -1) break;\n\n\t\t\tused[v] = true;\n\t\t\tans += minCost[v];\n\t\t\tforeach (i; 0..n) minCost[i] = min(minCost[i], cost[v][i]);\n\t\t}\n\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush,heappop\nfrom operator import itemgetter\nparent = []\nrank = []\n\ndef init(n):\n    global parent, rank\n    parent = range(n+1)\n    rank = [0] * (n + 1)\n    \ndef find(v):\n    global parent, rank\n    if parent[v] == v:\n        return v\n    else:\n        parent[v] = find(parent[v])\n        return parent[v]\n\ndef union(x,y):\n    global parent, rank\n    xr = find(x)\n    yr = find(y)\n    if rank[xr] > rank[yr]:\n        parent[yr] = xr\n    elif rank[xr] < rank[yr]:\n        parent[xr] = yr\n    else:\n        parent[yr] = xr\n        rank[xr] += 1\n\ndef kruskal(v,e):\n    visited = [False] * v\n    hq = []\n    t = []\n    init(v)\n    for a,b,c in e:\n        heappush(hq,(c,(a,b)))\n    while len(t) < v-1:        \n        c,(a,b) = heappop(hq)\n        if find(a) == find(b):\n            continue\n        t.append((c,(a,b)))\n        union(a,b)\n    return sum(map(itemgetter(0),t))\n\nwhile True:\n    n,m = map(int,raw_input().split())\n    if n|m == 0:\n        break    \n    e = [map(int,raw_input().split()) for _ in xrange(m)]\n    print kruskal(n,e)"
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            if s == a:\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n            elif s == b:\n                if not a in route:\n                    if not a in cost or c < cost[a]:\n                        cost[a] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            b = b if s == a else a\n            if not b in route:\n                if not b in cost or c < cost[b]:\n                    cost[b] = c\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "par = [0]*101\nrank = [0]*101\ndef init_union_find(V):\n    for i in xrange(V):\n        par[i] = i\n        rank[i] = 0\n        \ndef find(x):\n    if par[x] == x: return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n    \ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if (x == y): return\n    \n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if(rank[x] == rank[y]): rank[x] += 1\n\ndef same(x,y):\n    return find(x) == find(y)\n    \n# Entry point\nwhile 1:\n    n,m = map(int,raw_input().split())\n    if n == 0: break\n    edge = [map(int,raw_input().split()) for i in xrange(m)]\n    edge = sorted(edge, key = lambda x: x[2])\n    \n    init_union_find(n)\n    ans = 0\n    for i in xrange(m):\n        e = edge[i]\n        if not same(e[0],e[1]):\n            unite(e[0],e[1])\n            ans += e[2]\n    print ans\n    \n    \n    "
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n            if s in k:\n                a, b = k\n                a, b = a, b if s == a else b, a\n                if not b in route:\n                    if not b in cost or c < cost[b]:\n                        cost[b] = c\n                        del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "# AOJ 0180 Demolition of Bridges\n# Python3 2018.6.22\n\n# UNION-FIND library\nclass UnionSet:\n\tdef __init__(self, nmax):\n\t\tself.size = [1]*nmax\n\t\tself.id = [i for i in range(nmax+1)]\n\tdef root(self, i):\n\t\twhile i != self.id[i]:\n\t\t\tself.id[i] = self.id[self.id[i]]\n\t\t\ti = self.id[i]\n\t\treturn i\n\tdef connected(self, p, q): return self.root(p) == self.root(q)\n\tdef unite(self, p, q):\n\t\ti, j = self.root(p), self.root(q)\n\t\tif i == j: return\n\t\tif self.size[i] < self.size[j]:\n\t\t\tself.id[i] = j\n\t\t\tself.size[j] += self.size[i]\n\t\telse:\n\t\t\tself.id[j] = i\n\t\t\tself.size[i] += self.size[j]\n# UNION-FIND library\n\n# 最小全域木。V:総ノード数、E:枝情報(a,b,cost)\ndef kruskal(V, edge):\n\tedge2 = sorted(edge, key=lambda x:(x[2]))\n\tu = UnionSet(V)\n\tans = 0\n\tfor e in edge2:\n\t\tif not u.connected(e[0], e[1]):\n\t\t\tu.unite(e[0], e[1])\n\t\t\tans += e[2]\n\treturn ans;\n\nwhile 1:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\tedge = []\n\tfor i in range(m):\n\t\ts, t, w = map(int, input().split())\n\t\tedge.append((s, t, w))\n\tprint(kruskal(n, edge))\n"
  },
  {
    "language": "Python",
    "code": "def f(n, ans):\n    for k, c in dic.items():\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n        elif b == n:\n            if not a in cost or c < cost[a]:\n                cost[a] = c\n    for k, c in sorted(cost.items(), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans += c\n            del dic[k]\n            return f(k, ans)\n    return ans\n            \nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    dic = {}\n    s, b, c = map(int, raw_input().split())\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = map(int, raw_input().split())\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    print f(s, 0)"
  },
  {
    "language": "Python",
    "code": "\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n+1) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef kr(edge,N):\n    res = 0\n    node = []\n    G = UnionFind(N)\n    for cost, p, q, in edge:\n        if not G.same(p, q):\n            G.union(p, q)\n            res += cost\n    return res\n\ndef solve():\n    n,m=map(int,input().split())\n    if n==0 and m==0:\n        exit()\n    edge=[]\n    for _ in range(m):\n        a,b,cost=map(int,input().split())\n        edge.append((cost,a,b))\n    edge.sort()\n    ans=kr(edge,n)\n    print(ans)\n    return solve()\nif __name__==\"__main__\":\n  solve()\n\n"
  },
  {
    "language": "Python",
    "code": "def f(n, ans):\n    for k, c in dic.items():\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n    for k, c in sorted(cost.items(), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans += c\n            del cost[k]\n            return f(k, ans)\n    return ans\n            \nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    dic = {}\n    s, b, c = map(int, raw_input().split())\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = map(int, raw_input().split())\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    print f(s, 0)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        r = x\n        \n        while not self.par[r]<0:\n            r = self.par[r]\n        \n        t = x\n        \n        while t!=r:\n            tmp = t\n            t = self.par[t]\n            self.par[tmp] = r\n        \n        return r\n    \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        \n        if rx==ry:\n            return\n        \n        if self.rank[rx]<=self.rank[ry]:\n            self.par[ry] += self.par[rx]\n            self.par[rx] = ry\n            \n            if self.rank[rx]==self.rank[ry]:\n                self.rank[ry] += 1\n        else:\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nwhile True:\n    n, m = map(int, input().split())\n    \n    if n==0 and m==0:\n        exit()\n        \n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    edges.sort(key=lambda t: t[2])\n    uf = Unionfind(n)\n    ans = 0\n    \n    for a, b, c in edges:\n        if not uf.is_same(a, b):\n            uf.unite(a, b)\n            ans += c\n    \n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            b = b if s == a else a\n        if not b in route:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    else:\n        return ans\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    else:\n        print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "INF=10000\n\ndef prim():\n    mincost=[INF]*n\n    used=[False]*n\n    mincost[0]=0\n    res=0\n    while True:\n        v=-1\n        for u in range(n):\n            if  not used[u] and (v==-1 or mincost[u]<mincost[v]):\n                v=u\n        if v==-1:\n            break\n        used[v]=True\n        res+=mincost[v]\n        for u in range(n):\n            mincost[u]=min(mincost[u],cost[v][u])\n    return res\n\nwhile True:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    cost=[[INF]*n for i in range(n)]\n    for i in range(m):\n        a,b,d=map(int,raw_input().split())\n        cost[a][b]=d\n        cost[b][a]=d\n    print prim()"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    n, m = (int(s) for s in input().split())\n    if not n:\n        break\n\n    result = 0\n    bridges = sorted(\n        (tuple(int(s) for s in input().split()) for i in range(m)),\n        key=lambda x: x[2])\n    tree = UnionFind(n)\n\n    for a, b, cost in bridges:\n        if not tree.same(a, b):\n            result += cost\n            tree.unite(a, b)\n    print(result)"
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        a, b = k\n        if s == a:\n            if not b in route:\n                if not b in cost or c < cost[b]:\n                    cost[b] = c\n        elif s == b:\n            if not a in route:\n                if not a in cost or c < cost[a]:\n                    cost[a] = c\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    else:\n        return ans\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    else:\n        print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "def f(s, cost, route, ans):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    for k, c in data.items():\n        if s in k:\n            a, b = k\n            b = b if s == a else a\n            if not b in route:\n                if not b in cost or c < cost[b]:\n                    cost[b] = c\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans)\n    else:\n        return ans\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    else:\n        print f(0, {0:0}, [], 0)"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef f(s, cost, route, ans, data):\n    route.append(s)\n    ans += cost[s]\n    del cost[s]\n    _data = copy.deepcopy(data)\n    for k, c in _data.items():\n        if s in k:\n            a, b = k\n            a, b = a, b if s == a else b, a\n            if not b in route:\n                if not b in cost or c < cost[b]:\n                    cost[b] = c\n                    del data[(a, b)]\n    if cost:\n        s = sorted(cost.items(), key=lambda x: x[1])[0][0]\n        return f(s, cost, route, ans, data)\n    return ans\n\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    data = {}\n    for i in range(m):\n        a, b, c = map(int, raw_input().split())\n        data[(a, b)] = c\n    print f(0, {0:0}, [], 0, data)"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n  def __init__(self, size):\n    self.table = [-1 for _ in xrange(size)]\n\n  def find(self, x):\n    while self.table[x] >= 0: x = self.table[x]\n    return x\n\n  def union(self, x, y):\n    s1 = self.find(x)\n    s2 = self.find(y)\n    if s1 != s2:\n      if self.table[s1] >= self.table[s2]:\n        self.table[s1] += self.table[s2]\n        self.table[s2] = s1\n      else:\n        self.table[s2] += self.table[s1]\n        self.table[s1] = s2\n      return True\n    return False\n\ndef hash(n, s, g):\n  return n*s+g\n\ndef dehash(n, hs):\n  return [(hs-hs%n)/n, hs%n]\n\ndef kruskal(n, path):\n  path = sorted(path.items(), key=lambda x:x[1])\n  selected = {}\n  union = UnionFind(n)\n  for i in xrange(len(path)):\n    k,v = path[i]\n    s,g = dehash(n, k)\n    if union.union(s, g):\n      selected[k] = v\n  return selected\n\n# main\nwhile True:\n  n,m = map(int, raw_input().split())\n  if n==m==0:\n    break\n  path = {}\n  for _ in xrange(m):\n    a,b,c = map(int, raw_input().split())\n    path[hash(n, a, b)] = c\n  result = kruskal(n, path)\n  sumcost = 0\n  for v in result.values():\n    sumcost += v\n  print sumcost"
  },
  {
    "language": "Python",
    "code": "# AOJ 0180 Demolition of Bridges\n# Python3 2018.6.22\n\n# UNION-FIND library\nMAX = 105\nid, size = [0]*MAX, [0]*MAX\n\ndef init(n):\n\tfor i in range(n): id[i], size[i] = i, 1\n\t\ndef root(i):\n\twhile i != id[i]:\n\t\tid[i] = id[id[i]]\n\t\ti = id[i]\n\treturn i\n\t\ndef connected(p, q): return root(p) == root(q)\n\t\ndef unite(p, q):\n\ti, j = root(p), root(q)\n\tif i == j: return\n\tif size[i] < size[j]:\n\t\tid[i] = j\n\t\tsize[j] += size[i]\n\telse:\n\t\tid[j] = i\n\t\tsize[i] += size[j]\n# UNION-FIND library\n\n# 最小全域木。V:総ノード数、E:枝情報(a,b,cost)\ndef kruskal(V, edge):\n\tee = sorted(edge, key=lambda x:(x[2]))\n\tinit(V)\n\tans = 0\n\tfor e in ee:\n\t\tif not connected(e[0], e[1]):\n\t\t\tunite(e[0], e[1])\n\t\t\tans += e[2]\n\treturn ans;\n\nwhile 1:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\tedge = []\n\tfor i in range(m):\n\t\ts, t, w = map(int, input().split())\n\t\tedge.append((s, t, w))\n\tprint(kruskal(n, edge))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0180\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple\ninput = stdin.readline\n\n\nclass DisjointSet(object):\n    def __init__(self, size):\n        self.rank = []\n        self.p = []\n        for i in range(size):\n            self.makeSet(i)\n\n    def makeSet(self, x):\n        self.p.insert(x, x)\n        self.rank.insert(x, 0)\n\n    def same(self, x, y):\n        return self.findSet(x) == self.findSet(y)\n\n    def unite(self, x, y):\n        self.link(self.findSet(x), self.findSet(y))\n\n    def link(self, x, y):\n        if self.rank[x] > self.rank[y]:\n            self.p[y] = x\n        else:\n            self.p[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def findSet(self, x):\n        if x != self.p[x]:\n            self.p[x] = self.findSet(self.p[x])\n        return self.p[x]\n\n\ndef kruskal(V, E, es):\n    # V: ???????????° (0??????)\n    # E: ??¨????????°\n    es.sort(key=lambda x: x.c)\n    uf = DisjointSet(V)\n    res = 0\n\n    for i in range(E):\n        e = es[i]\n        if not uf.same(e.u, e.v):\n            uf.unite(e.u, e.v)\n            res += e.c\n    return res\n\n\nedge = namedtuple('edge', ['u', 'v', 'c'])\ndef main(args):\n    while True:\n        n, m = map(int, input().split())\n        if n == 0 and m == 0:\n            break\n\n        es = []\n        for _ in range(m):\n            s, t, w = map(int, input().split())\n            es.append(edge(s, t, w))\n\n        result = kruskal(n, m, es)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "def f(n, ans):\n    for k, c in dic.items():\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n        elif b == n:\n            if not a in cost or c < cost[a]:\n                cost[a] = c\n    for k, c in sorted(cost.items(), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans += c\n            del cost[k]\n            return f(k, ans)\n    return ans\n            \nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    dic = {}\n    s, b, c = map(int, raw_input().split())\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = map(int, raw_input().split())\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    print f(s, 0)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N, M = map(int, readline().split())\n    if N == 0:\n        return False\n    *p, = range(N)\n    def root(x):\n        if x == p[x]:\n            return x\n        p[x] = y = root(p[x])\n        return y\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px == py:\n            return 0\n        if px < py:\n            p[py] = px\n        else:\n            p[px] = py\n        return 1\n\n    E = []\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        E.append((c, a, b))\n    E.sort()\n    ans = 0\n    for c, a, b in E:\n        if unite(a-1, b-1):\n            ans += c\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nclass UnionFind():\n    def __init__(self,n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self,x): #根を見つける、繋ぎ直す\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def unite(self,x,y): #x,yの含むグループを併合する\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def same(self,x,y):#xとyが同じグループにいるか判定\n        return self.find(x) == self.find(y)\n\ndef solve(N,M):\n    edges = [tuple(map(int,input().split())) for _ in range(M)]\n    edges.sort(key = lambda x:x[2])\n    uf = UnionFind(N)\n\n    ans = 0\n    for a,b,c in edges:\n        if uf.same(a,b):\n            continue\n        else:\n            uf.unite(a,b)\n            ans += c\n    print(ans)\n\ndef main():\n    while True:\n        N,M = map(int,input().split())\n        if N == 0:\n            return\n        solve(N,M)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def f(n):\n    for k, c in dic.items():\n        a, b = k\n        if a == n:\n            if not b in cost or c < cost[b]:\n                cost[b] = c\n        elif b == n:\n            if not a in cost or c < cost[a]:\n                cost[a] = c\n    for k, c in sorted(cost.items(), key=lambda x: x[1]):\n        if not k in res:\n            res.append(k)\n            ans.append(c)\n            f(k)\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n == m == 0: break\n    dic = {}\n    s, b, c = map(int, raw_input().split())\n    dic[(s, b)] = c\n    for i in range(m-1):\n        a, b, c = map(int, raw_input().split())\n        dic[(a, b)] = c\n    cost = {}\n    res = [s]\n    ans = []\n    f(s)\n    print sum(ans)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef get_par(x, par_lst):\n  if x == par_lst[x]:\n    return x\n  p = get_par(par_lst[x], par_lst)\n  par_lst[x] = p\n  return p\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0:\n    break\n  que = []\n  for _ in range(m):\n    a, b, c = map(int, input().split())\n    heappush(que, (c, a, b))\n  \n  par_lst = [i for i in range(n)]\n  ans = 0\n  while que:\n    c, a, b = heappop(que)\n    pa, pb = get_par(a, par_lst), get_par(b, par_lst)\n    if pa != pb:\n      par_lst[pa] = pb\n      ans += c\n  print(ans)\n"
  }
]