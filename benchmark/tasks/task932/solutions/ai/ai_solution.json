[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_WORKERS 200005\n\ntypedef struct Worker {\n    int salary;\n    int boss;\n    int* subordinates;\n    int subordinate_count;\n    int subordinate_capacity;\n} Worker;\n\nWorker workers[MAX_WORKERS];\nint worker_count = 0;\n\nvoid init_worker(int worker_id, int boss, int salary) {\n    workers[worker_id].salary = salary;\n    workers[worker_id].boss = boss;\n    workers[worker_id].subordinates = malloc(sizeof(int) * 10);\n    workers[worker_id].subordinate_count = 0;\n    workers[worker_id].subordinate_capacity = 10;\n\n    if (boss != -1) {\n        Worker* parent = &workers[boss];\n        if (parent->subordinate_count == parent->subordinate_capacity) {\n            parent->subordinate_capacity *= 2;\n            parent->subordinates = realloc(parent->subordinates, sizeof(int) * parent->subordinate_capacity);\n        }\n        parent->subordinates[parent->subordinate_count++] = worker_id;\n    }\n}\n\nvoid salary_increase(int worker_id, int amount) {\n    workers[worker_id].salary += amount;\n    \n    for (int i = 0; i < workers[worker_id].subordinate_count; i++) {\n        salary_increase(workers[worker_id].subordinates[i], amount);\n    }\n}\n\nlong long calculate_total_salary(int worker_id) {\n    long long total = workers[worker_id].salary;\n    \n    for (int i = 0; i < workers[worker_id].subordinate_count; i++) {\n        total += calculate_total_salary(workers[worker_id].subordinates[i]);\n    }\n    \n    return total;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    for (int i = 0; i < N; i++) {\n        int boss, salary;\n        scanf(\"%d %d\", &boss, &salary);\n        init_worker(i, boss, salary);\n        worker_count++;\n    }\n\n    while (Q--) {\n        int type, v, x;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &v, &x);\n            salary_increase(v, x);\n        } else if (type == 2) {\n            scanf(\"%d\", &v);\n            printf(\"%lld\\n\", calculate_total_salary(v));\n        } else {\n            scanf(\"%d %d %d\", &v, &x, &worker_count);\n            init_worker(worker_count, v, x);\n            worker_count++;\n        }\n    }\n\n    for (int i = 0; i < worker_count; i++) {\n        free(workers[i].subordinates);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int id;\n    long long salary;\n    struct Node *parent;\n    struct Node *first_child;\n    struct Node *next_sibling;\n} Node;\n\nNode *nodes[200001] = {NULL};\n\nvoid add_child(Node *parent, Node *child) {\n    child->parent = parent;\n    child->next_sibling = parent->first_child;\n    parent->first_child = child;\n}\n\nvoid update_salaries(Node *node, long long x) {\n    if (node == NULL) return;\n    node->salary += x;\n    Node *child = node->first_child;\n    while (child != NULL) {\n        update_salaries(child, x);\n        child = child->next_sibling;\n    }\n}\n\nlong long calculate_total(Node *node) {\n    if (node == NULL) return 0;\n    long long total = node->salary;\n    Node *child = node->first_child;\n    while (child != NULL) {\n        total += calculate_total(child);\n        child = child->next_sibling;\n    }\n    return total;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    Node *root = malloc(sizeof(Node));\n    root->id = 0;\n    root->salary = 0;\n    root->parent = NULL;\n    root->first_child = NULL;\n    root->next_sibling = NULL;\n    nodes[0] = root;\n\n    for (int i = 1; i < N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        Node *node = malloc(sizeof(Node));\n        node->id = i;\n        node->salary = 0;\n        node->first_child = NULL;\n        node->next_sibling = NULL;\n        nodes[i] = node;\n        add_child(nodes[p], node);\n    }\n\n    int next_id = N;\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            int v;\n            long long x;\n            scanf(\"%d %lld\", &v, &x);\n            update_salaries(nodes[v], x);\n        } else if (type == 2) {\n            int v;\n            scanf(\"%d\", &v);\n            printf(\"%lld\\n\", calculate_total(nodes[v]));\n        } else if (type == 3) {\n            int p;\n            long long s;\n            scanf(\"%d %lld\", &p, &s);\n            Node *node = malloc(sizeof(Node));\n            node->id = next_id;\n            node->salary = s;\n            node->first_child = NULL;\n            node->next_sibling = NULL;\n            nodes[next_id] = node;\n            add_child(nodes[p], node);\n            next_id++;\n        }\n    }\n\n    for (int i = 0; i < next_id; i++) {\n        free(nodes[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Node {\n    long long salary;\n    vector<int> children;\n};\n\nvector<Node> tree;\nvector<int> in, out;\nint current_time = 0;\n\nvoid dfs(int u) {\n    in[u] = current_time++;\n    for (int v : tree[u].children) {\n        dfs(v);\n    }\n    out[u] = current_time - 1;\n}\n\nclass FenwickTree {\nprivate:\n    vector<long long> tree;\npublic:\n    FenwickTree(int size) : tree(size + 2) {}\n\n    void update(int idx, long long delta) {\n        for (++idx; idx < tree.size(); idx += idx & -idx)\n            tree[idx] += delta;\n    }\n\n    long long query(int idx) {\n        long long res = 0;\n        for (++idx; idx > 0; idx -= idx & -idx)\n            res += tree[idx];\n        return res;\n    }\n\n    long long range_query(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    tree.resize(N);\n    in.resize(N);\n    out.resize(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> tree[i].salary;\n    }\n\n    vector<int> parent(N, -1);\n    for (int i = 1; i < N; ++i) {\n        cin >> parent[i];\n        tree[parent[i]].children.push_back(i);\n    }\n\n    dfs(0);\n\n    FenwickTree ft(current_time);\n    for (int i = 0; i < N; ++i) {\n        ft.update(in[i], tree[i].salary);\n    }\n\n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int v; long long x;\n            cin >> v >> x;\n            ft.update(in[v], x);\n        } else if (type == 2) {\n            int v;\n            cin >> v;\n            cout << ft.range_query(in[v], out[v]) << '\\n';\n        } else if (type == 3) {\n            int p; long long s;\n            cin >> p >> s;\n            int new_node = tree.size();\n            tree.push_back({s, {}});\n            in.push_back(0);\n            out.push_back(0);\n            tree[p].children.push_back(new_node);\n            parent.push_back(p);\n            dfs(new_node);\n            ft.update(in[new_node], s);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Node {\n        int parent;\n        List<Integer> children = new ArrayList<>();\n        long salary;\n        long lazy;\n\n        Node(int parent, long salary) {\n            this.parent = parent;\n            this.salary = salary;\n            this.lazy = 0;\n        }\n    }\n\n    static Node[] tree;\n    static int[] in;\n    static int[] out;\n    static int time = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n        tree = new Node[N + Q + 2]; // Extra space for new workers\n        in = new int[N + Q + 2];\n        out = new int[N + Q + 2];\n\n        tree[0] = new Node(-1, scanner.nextLong());\n        for (int i = 1; i < N; i++) {\n            int p = scanner.nextInt();\n            long s = scanner.nextLong();\n            tree[i] = new Node(p, s);\n            tree[p].children.add(i);\n        }\n\n        dfs(0);\n\n        int currentWorkers = N;\n        List<Long> results = new ArrayList<>();\n\n        for (int q = 0; q < Q; q++) {\n            int type = scanner.nextInt();\n            if (type == 1) {\n                int v = scanner.nextInt();\n                long x = scanner.nextLong();\n                updateRange(v, x);\n            } else if (type == 2) {\n                int v = scanner.nextInt();\n                results.add(queryRange(v));\n            } else if (type == 3) {\n                int p = scanner.nextInt();\n                long s = scanner.nextLong();\n                tree[currentWorkers] = new Node(p, s);\n                tree[p].children.add(currentWorkers);\n                dfsReset(currentWorkers);\n                currentWorkers++;\n            }\n        }\n\n        for (long res : results) {\n            System.out.println(res);\n        }\n    }\n\n    static void dfs(int u) {\n        in[u] = ++time;\n        for (int v : tree[u].children) {\n            dfs(v);\n        }\n        out[u] = time;\n    }\n\n    static void dfsReset(int u) {\n        in[u] = ++time;\n        for (int v : tree[u].children) {\n            dfsReset(v);\n        }\n        out[u] = time;\n    }\n\n    static void updateRange(int v, long x) {\n        tree[v].salary += x;\n        for (int child : tree[v].children) {\n            updateRange(child, x);\n        }\n    }\n\n    static long queryRange(int v) {\n        long sum = tree[v].salary;\n        for (int child : tree[v].children) {\n            sum += queryRange(child);\n        }\n        return sum;\n    }\n}",
    "timestamp": "2025-08-05 23:25:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static class Worker {\n        int salary;\n        List<Integer> subordinates;\n        int boss;\n\n        Worker(int salary, int boss) {\n            this.salary = salary;\n            this.subordinates = new ArrayList<>();\n            this.boss = boss;\n        }\n    }\n\n    static List<Worker> workers;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n\n        workers = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int salary = sc.nextInt();\n            int boss = sc.nextInt();\n            workers.add(new Worker(salary, boss));\n\n            if (boss != -1) {\n                workers.get(boss).subordinates.add(i);\n            }\n        }\n\n        for (int q = 0; q < Q; q++) {\n            int type = sc.nextInt();\n\n            if (type == 1) {\n                int v = sc.nextInt();\n                int x = sc.nextInt();\n                increaseSalary(v, x);\n            } else if (type == 2) {\n                int v = sc.nextInt();\n                System.out.println(calculateTotalSalary(v));\n            } else {\n                int boss = sc.nextInt();\n                int salary = sc.nextInt();\n                addWorker(boss, salary);\n            }\n        }\n    }\n\n    static void increaseSalary(int v, int x) {\n        workers.get(v).salary += x;\n        for (int sub : workers.get(v).subordinates) {\n            increaseSalary(sub, x);\n        }\n    }\n\n    static long calculateTotalSalary(int v) {\n        long total = workers.get(v).salary;\n        for (int sub : workers.get(v).subordinates) {\n            total += calculateTotalSalary(sub);\n        }\n        return total;\n    }\n\n    static void addWorker(int boss, int salary) {\n        workers.add(new Worker(salary, boss));\n        int newWorkerIndex = workers.size() - 1;\n        workers.get(boss).subordinates.add(newWorkerIndex);\n    }\n}",
    "timestamp": "2025-08-05 23:26:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass CompanySalaryManager {\nprivate:\n    vector<int> salaries;\n    vector<vector<int>> subordinates;\n    unordered_map<int, int> worker_index;\n    int next_worker_id;\n\npublic:\n    CompanySalaryManager(int N) {\n        salaries.resize(N);\n        subordinates.resize(N);\n        next_worker_id = N;\n    }\n\n    void initialize_salary(int worker, int salary) {\n        salaries[worker] = salary;\n        worker_index[worker] = worker;\n    }\n\n    void add_subordinate(int boss, int subordinate) {\n        subordinates[boss].push_back(subordinate);\n    }\n\n    void increase_salary(int worker, int amount) {\n        dfs_increase_salary(worker, amount);\n    }\n\n    int calculate_total_salary(int worker) {\n        return dfs_calculate_salary(worker);\n    }\n\n    int add_new_worker(int boss, int salary) {\n        int new_worker = next_worker_id++;\n        salaries.push_back(salary);\n        subordinates.push_back({});\n        subordinates[boss].push_back(new_worker);\n        worker_index[new_worker] = new_worker;\n        return new_worker;\n    }\n\nprivate:\n    void dfs_increase_salary(int worker, int amount) {\n        salaries[worker] += amount;\n        for (int subordinate : subordinates[worker]) {\n            dfs_increase_salary(subordinate, amount);\n        }\n    }\n\n    int dfs_calculate_salary(int worker) {\n        int total_salary = salaries[worker];\n        for (int subordinate : subordinates[worker]) {\n            total_salary += dfs_calculate_salary(subordinate);\n        }\n        return total_salary;\n    }\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    CompanySalaryManager manager(N);\n\n    for (int i = 0; i < N; ++i) {\n        int salary;\n        cin >> salary;\n        manager.initialize_salary(i, salary);\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        int boss, subordinate;\n        cin >> boss >> subordinate;\n        manager.add_subordinate(boss, subordinate);\n    }\n\n    while (Q--) {\n        int query_type;\n        cin >> query_type;\n\n        if (query_type == 1) {\n            int worker, amount;\n            cin >> worker >> amount;\n            manager.increase_salary(worker, amount);\n        } else if (query_type == 2) {\n            int worker;\n            cin >> worker;\n            cout << manager.calculate_total_salary(worker) << endl;\n        } else if (query_type == 3) {\n            int boss, salary;\n            cin >> boss >> salary;\n            manager.add_new_worker(boss, salary);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class WorkerTree:\n    def __init__(self):\n        self.tree = {0: (0, set())}\n        self.salaries = {0: 0}\n\n    def add_worker(self, boss_id, salary):\n        worker_id = len(self.salaries)\n        if boss_id in self.tree:\n            self.tree[boss_id][1].add(worker_id)\n        self.tree[worker_id] = (boss_id, set())\n        self.salaries[worker_id] = salary\n\n    def increase_salary(self, worker_id, increment):\n        stack = [worker_id]\n        while stack:\n            current = stack.pop()\n            self.salaries[current] += increment\n            stack.extend(self.tree[current][1])\n\n    def get_total_salary(self, worker_id):\n        total_salary = 0\n        stack = [worker_id]\n        while stack:\n            current = stack.pop()\n            total_salary += self.salaries[current]\n            stack.extend(self.tree[current][1])\n        return total_salary\n\ndef process_queries(N, initial_salaries, hierarchy, Q, queries):\n    worker_tree = WorkerTree()\n\n    for i in range(1, N):\n        worker_tree.add_worker(hierarchy[i], initial_salaries[i])\n\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            worker_tree.increase_salary(query[1], query[2])\n        elif query[0] == 2:\n            results.append(worker_tree.get_total_salary(query[1]))\n        elif query[0] == 3:\n            worker_tree.add_worker(query[1], query[2])\n\n    return results\n\n# Example usage (pseudocode):\n# process_queries(N, salaries, hierarchy, Q, queries)",
    "timestamp": "2025-08-13 15:06:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass AtcoderCompany {\n    static class Worker {\n        int salary;\n        List<Worker> subordinates;\n        \n        Worker(int salary) {\n            this.salary = salary;\n            this.subordinates = new ArrayList<>();\n        }\n    }\n\n    Map<Integer, Worker> workers;\n    \n    public AtcoderCompany(int[] p, int[] salaries) {\n        workers = new HashMap<>();\n        for (int i = 0; i < p.length; i++) {\n            workers.put(i, new Worker(salaries[i]));\n        }\n        for (int i = 1; i < p.length; i++) {\n            workers.get(p[i]).subordinates.add(workers.get(i));\n        }\n    }\n    \n    public void increaseSalary(int v, int x) {\n        Worker worker = workers.get(v);\n        increaseSalaryRecursively(worker, x);\n    }\n    \n    private void increaseSalaryRecursively(Worker worker, int x) {\n        worker.salary += x;\n        for (Worker subordinate : worker.subordinates) {\n            increaseSalaryRecursively(subordinate, x);\n        }\n    }\n    \n    public int calculateTotalSalary(int v) {\n        Worker worker = workers.get(v);\n        return calculateTotalSalaryRecursively(worker);\n    }\n    \n    private int calculateTotalSalaryRecursively(Worker worker) {\n        int total = worker.salary;\n        for (Worker subordinate : worker.subordinates) {\n            total += calculateTotalSalaryRecursively(subordinate);\n        }\n        return total;\n    }\n    \n    public void addWorker(int boss, int salary) {\n        Worker newWorker = new Worker(salary);\n        workers.put(workers.size(), newWorker);\n        workers.get(boss).subordinates.add(newWorker);\n    }\n    \n    public List<Integer> processQueries(int[][] queries) {\n        List<Integer> result = new ArrayList<>();\n        for (int[] query : queries) {\n            switch (query[0]) {\n                case 1:\n                    increaseSalary(query[1], query[2]);\n                    break;\n                case 2:\n                    result.add(calculateTotalSalary(query[1]));\n                    break;\n                case 3:\n                    addWorker(query[1], query[2]);\n                    break;\n            }\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 15:07:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Worker {\n    int salary;\n    int total_salary;\n    struct Worker** subordinates;\n    int sub_count;\n} Worker;\n\nWorker* create_worker(int salary) {\n    Worker* worker = (Worker*)malloc(sizeof(Worker));\n    worker->salary = salary;\n    worker->total_salary = salary;\n    worker->subordinates = NULL;\n    worker->sub_count = 0;\n    return worker;\n}\n\nvoid adjust_salary(Worker* worker, int increment) {\n    worker->total_salary += increment * (worker->sub_count + 1);\n    worker->salary += increment;\n    for (int i = 0; i < worker->sub_count; i++) {\n        adjust_salary(worker->subordinates[i], increment);\n    }\n}\n\nint calculate_total_salary(Worker* worker) {\n    return worker->total_salary;\n}\n\nvoid add_subordinate(Worker* boss, Worker* subordinate) {\n    boss->sub_count++;\n    boss->subordinates = (Worker**)realloc(boss->subordinates, boss->sub_count * sizeof(Worker*));\n    boss->subordinates[boss->sub_count - 1] = subordinate;\n    boss->total_salary += subordinate->total_salary;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    Worker** workers = (Worker**)malloc(N * sizeof(Worker*));\n    workers[0] = create_worker(0);\n\n    for (int i = 1; i < N; i++) {\n        int p_i, salary;\n        scanf(\"%d %d\", &p_i, &salary);\n        workers[i] = create_worker(salary);\n        add_subordinate(workers[p_i], workers[i]);\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int query_type;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            int v_i, x_i;\n            scanf(\"%d %d\", &v_i, &x_i);\n            adjust_salary(workers[v_i], x_i);\n        } else if (query_type == 2) {\n            int v_i;\n            scanf(\"%d\", &v_i);\n            printf(\"%d\\n\", calculate_total_salary(workers[v_i]));\n        } else if (query_type == 3) {\n            int boss, salary;\n            scanf(\"%d %d\", &boss, &salary);\n            Worker* new_worker = create_worker(salary);\n            add_subordinate(workers[boss], new_worker);\n            workers = (Worker**)realloc(workers, (N + 1) * sizeof(Worker*));\n            workers[N] = new_worker;\n            N++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        free(workers[i]->subordinates);\n        free(workers[i]);\n    }\n    free(workers);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:07:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct Node {\n    int salary;\n    vector<int> children;\n};\n\nclass Company {\n    vector<Node> employees;\n    unordered_map<int, int> salaries;\n\npublic:\n    Company(int N, vector<int>& p, vector<int>& initial_salaries) {\n        employees.resize(N);\n        for (int i = 0; i < N; ++i) {\n            employees[i].salary = initial_salaries[i];\n            if (p[i] != -1) {\n                employees[p[i]].children.push_back(i);\n            }\n        }\n    }\n\n    void increaseSalary(int v, int x) {\n        dfsIncrease(v, x);\n    }\n\n    int calculateTotalSalary(int v) {\n        return dfsCalculate(v);\n    }\n\n    void addWorker(int p, int salary) {\n        int new_worker_id = employees.size();\n        employees.resize(new_worker_id + 1);\n        employees[new_worker_id].salary = salary;\n        employees[p].children.push_back(new_worker_id);\n    }\n\nprivate:\n    void dfsIncrease(int v, int x) {\n        employees[v].salary += x;\n        for (int child : employees[v].children) {\n            dfsIncrease(child, x);\n        }\n    }\n\n    int dfsCalculate(int v) {\n        int total_salary = employees[v].salary;\n        for (int child : employees[v].children) {\n            total_salary += dfsCalculate(child);\n        }\n        return total_salary;\n    }\n};\n\nint main() {\n    int N, Q;\n    cin >> N;\n    vector<int> p(N), initial_salaries(N);\n    for (int i = 0; i < N; ++i) cin >> p[i];\n    for (int i = 0; i < N; ++i) cin >> initial_salaries[i];\n    Company company(N, p, initial_salaries);\n\n    cin >> Q;\n    while (Q--) {\n        int query_type;\n        cin >> query_type;\n        if (query_type == 1) {\n            int v, x;\n            cin >> v >> x;\n            company.increaseSalary(v, x);\n        } else if (query_type == 2) {\n            int v;\n            cin >> v;\n            cout << company.calculateTotalSalary(v) << endl;\n        } else if (query_type == 3) {\n            int p, salary;\n            cin >> p >> salary;\n            company.addWorker(p, salary);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 15:07:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Worker:\n    def __init__(self, salary):\n        self.salary = salary\n        self.subordinates = []\n\nclass SalaryTree:\n    def __init__(self):\n        self.workers = [None]\n        \n    def add_worker(self, boss_id, salary):\n        new_worker = Worker(salary)\n        self.workers.append(new_worker)\n        new_worker_id = len(self.workers) - 1\n        \n        if boss_id >= 0:\n            self.workers[boss_id].subordinates.append(new_worker_id)\n        \n        return new_worker_id\n    \n    def increase_salary(self, worker_id, x):\n        def dfs(curr_id):\n            self.workers[curr_id].salary += x\n            for sub_id in self.workers[curr_id].subordinates:\n                dfs(sub_id)\n        \n        dfs(worker_id)\n    \n    def calculate_total_salary(self, worker_id):\n        def dfs(curr_id):\n            total = self.workers[curr_id].salary\n            for sub_id in self.workers[curr_id].subordinates:\n                total += dfs(sub_id)\n            return total\n        \n        return dfs(worker_id)\n\ndef solve_queries(queries):\n    salary_tree = SalaryTree()\n    results = []\n    \n    # Add president with initial salary\n    salary_tree.add_worker(-1, 0)\n    \n    for query in queries:\n        if query[0] == 1:  # Increase salary\n            _, v, x = query\n            salary_tree.increase_salary(v, x)\n        elif query[0] == 2:  # Calculate total salary\n            _, v = query\n            results.append(salary_tree.calculate_total_salary(v))\n        elif query[0] == 3:  # Add new worker\n            _, boss, salary = query\n            salary_tree.add_worker(boss, salary)\n    \n    return results",
    "timestamp": "2025-08-13 15:07:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom sys import stdin\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n\n    N = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n\n    parent = [-1] * (N + 1)  # 1-based\n    children = defaultdict(list)\n    salary = [0] * (N + 1)\n\n    for i in range(1, N + 1):\n        p_i = int(data[idx])\n        idx += 1\n        s_i = int(data[idx])\n        idx += 1\n        parent[i] = p_i\n        if p_i != -1:\n            children[p_i].append(i)\n        salary[i] = s_i\n\n    # Euler Tour for in and out times\n    in_time = [0] * (N + 1)\n    out_time = [0] * (N + 1)\n    time = 1\n    stack = [(1, True)]\n    while stack:\n        node, is_first_visit = stack.pop()\n        if is_first_visit:\n            in_time[node] = time\n            time += 1\n            stack.append((node, False))\n            # Push children in reverse order to process in order\n            for child in reversed(children[node]):\n                stack.append((child, True))\n        else:\n            out_time[node] = time - 1\n\n    # Fenwick Tree for range updates and queries\n    class FenwickTree:\n        def __init__(self, size):\n            self.size = size\n            self.tree = [0] * (self.size + 2)\n\n        def update(self, index, delta):\n            while index <= self.size:\n                self.tree[index] += delta\n                index += index & -index\n\n        def query(self, index):\n            res = 0\n            while index > 0:\n                res += self.tree[index]\n                index -= index & -index\n            return res\n\n        def range_update(self, l, r, delta):\n            self.update(l, delta)\n            self.update(r + 1, -delta)\n\n        def range_query(self, l, r):\n            return self.query(r) - self.query(l - 1)\n\n    ft_salary = FenwickTree(N + 2)\n    ft_count = FenwickTree(N + 2)\n\n    # Initialize salaries\n    for i in range(1, N + 1):\n        ft_salary.update(in_time[i], salary[i])\n        ft_count.update(in_time[i], 1)\n\n    output = []\n    current_max_node = N\n\n    for _ in range(Q):\n        query = data[idx]\n        idx += 1\n        if query == '1':\n            v_i = int(data[idx])\n            idx += 1\n            x_i = int(data[idx])\n            idx += 1\n            l = in_time[v_i]\n            r = out_time[v_i]\n            ft_salary.range_update(l, r, x_i)\n        elif query == '2':\n            v_i = int(data[idx])\n            idx += 1\n            l = in_time[v_i]\n            r = out_time[v_i]\n            total = ft_salary.range_query(l, r)\n            output.append(str(total))\n        elif query == '3':\n            p_i = int(data[idx])\n            idx += 1\n            s_i = int(data[idx])\n            idx += 1\n            current_max_node += 1\n            parent.append(p_i)\n            children[p_i].append(current_max_node)\n            # Update Euler Tour (recompute in_time and out_time)\n            # For simplicity, we'll recompute the entire tour (not efficient for large N)\n            # In practice, a more efficient method is needed\n            in_time.append(0)\n            out_time.append(0)\n            time = 1\n            stack = [(1, True)]\n            in_time = [0] * (current_max_node + 1)\n            out_time = [0] * (current_max_node + 1)\n            while stack:\n                node, is_first_visit = stack.pop()\n                if is_first_visit:\n                    in_time[node] = time\n                    time += 1\n                    stack.append((node, False))\n                    for child in reversed(children[node]):\n                        stack.append((child, True))\n                else:\n                    out_time[node] = time - 1\n            # Update Fenwick Trees\n            ft_salary.update(in_time[current_max_node], s_i)\n            ft_count.update(in_time[current_max_node], 1)\n\n    print('\\n'.join(output))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:07:50"
  }
]