[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N, Q;\nint p[100010];\nint a[100010];\nvector<int> child[100010];\n\nvoid upgrade(int v, int x, int d) {\n  a[v] += x;\n  if (d > 0) {\n    for (auto y : child[v]) {\n      upgrade(y, x, d-1);\n    }\n  }\n}\n\nvoid solve1() {\n  int v, d, x;\n  cin >> v >> d >> x;\n  upgrade(v, x, d);\n}\n\nint sum(int v, int d) {\n  int ans = a[v];\n  if (d > 0) {\n    for (auto y : child[v]) {\n      ans += sum(y, d-1);\n    }\n  }\n  return ans;\n}\n\nvoid solve2() {\n  int v, d;\n  cin >> v >> d;\n  cout << sum(v, d) << endl; \n}\n\nvoid solve3() {\n  int pr, ar;\n  cin >> pr >> ar;\n  p[N] = pr;\n  a[N] = ar;\n  child[pr].push_back(N);\n  N++;\n}\n\nvoid solve() {\n  //cerr << \"aaa\" << endl;\n  int x;\n  cin >> x;\n  if (x == 1) {\n    solve1();\n  } else if (x == 2) {\n    solve2();\n  } else {\n    solve3();\n  }\n}\n\nint main () {\n  cin >> N >> Q;\n  for (auto i = 0; i < N; ++i) {\n    cin >> p[i] >> a[i];\n    if (p[i] != -1) {\n      child[p[i]].push_back(i);\n    }\n  }\n  for (auto i = 0; i < Q; ++i) {\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t//\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\t//child[b] += child[go];\n\t}\n\t//en[b] = ord;\n\t//child[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 50; i++){\n\t\tinit();\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V, int ME> class BIT_r {\npublic:\n\tV bit[2][1<<ME];\n\tBIT_r(){clear();};\n\tvoid clear() {ZERO(bit);};\n\t\n\tvoid update(int entry, V val0, V val1) {\n\t\tentry++;\n\t\twhile(entry <= 1<<ME) bit[0][entry-1]+=val0, bit[1][entry-1] += val1, entry += entry & -entry;\n\t}\n\tV total(int entry) {\n\t\tint e=entry++;\n\t\tV v0=0,v1=0;\n\t\twhile(entry>0) v0+=bit[0][entry-1], v1+=bit[1][entry-1], entry -= entry & -entry;\n\t\treturn e*v0+v1;\n\t}\n\tvoid add(int L, int R, V val) { // add val to L<=x<=R\n\t\tupdate(L,val,-val*(L-1));\n\t\tupdate(R+1,-val,val*R);\n\t}\n};\nBIT_r<ll,23> bt;\n\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tFOR(i,N) bt.add(i+1,i+1,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tbt.add(V[i]+1,V[i]+D[i]+1,X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<bt.total(V[i]+D[i]+1)-bt.total(V[i])<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tbt.add(N+1,N+1,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tll sval[4*SZ]; int slazy[4*SZ]; int scnt[4*SZ];\n\tvoid clear() {\n\t\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\t}\n\tvoid spush(int x) {\n\t\tif(slazy[x]==0) return;\n\t\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\t\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\t\tslazy[x]=0;\n\t}\n\tvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\n\tvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\t\tif(l==r) {\n\t\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n\t}\n\tvoid smod(int x,int l,int r,int L,int R,int BY) {\n\t\tif(L<=l&&r<=R) {\n\t\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\t\tslazy[x]+=BY;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n\t}\n\tll sget(int x,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {\n\t\t\treturn sval[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; ll ret=0;\n\t\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\t\treturn ret;\n\t\t}\n\t}\n} S;\nS s[MAXB];\n\n\nint nb;\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tnb=(nemp+SZ-1)/SZ;\n\tREP(i,nb) s[i].clear();\n\tREP(i,nemp) if(alive[i]) s[pos[i]/SZ].sborn(0,0,SZ-1,pos[i]%SZ,oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n \nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\treturn s[pos[idx]/SZ].sget(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ);\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].sget(0,0,SZ-1,l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n \nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\ts[pos[idx]/SZ].smod(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ,by);\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].smod(0,0,SZ-1,l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].sborn(0,0,SZ-1,pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=0,qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=0,qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\tprintf(\"%.9lf\\n\",double(clock() - begin) / CLOCKS_PER_SEC);\n\t}\n}\n \nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\t//child[b] += child[go];\n\t}\n\t//en[b] = ord;\n\t//child[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 220; i++){\n\t\tdfs2(0);\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[55001];\nvi child[55001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(470001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<long long> a(n);\n\tvector<long long> aa(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %lld\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = false;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (!has3) {\n\t\tvector<vector<int>> dict(N);\n\t\tvector<BIT<long long>> bits;\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], bar[i], baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t} else if (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<long long(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0LL;\n\t\t\t}\n\t\t\tlong long ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], foo[i] + bar[i] + 1, baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[1300005], fw2[1300005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tassert(N <= 400000);\n\tassert(Q <= 50000);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, min(N - 1, a + v), x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 220; i++){\n\t\tdfs2(0);\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nvoid small1() {\n\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<int(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%d\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else if (!has3) {\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\twhile (q--) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t == 1) {\n\t\t\t\tint v, d, x;\n\t\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\t\tadd(v, d, x);\n\t\t\t} else if (t == 2) {\n\t\t\t\tint v, d;\n\t\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], foo[i] + bar[i] + 1, baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V, int ME> class BIT_r {\npublic:\n\tV bit[2][1<<ME];\n\tBIT_r(){clear();};\n\tvoid clear() {ZERO(bit);};\n\t\n\tvoid update(int entry, V val0, V val1) {\n\t\tentry++;\n\t\twhile(entry <= 1<<ME) bit[0][entry-1]+=val0, bit[1][entry-1] += val1, entry += entry & -entry;\n\t}\n\tV total(int entry) {\n\t\tint e=entry++;\n\t\tV v0=0,v1=0;\n\t\twhile(entry>0) v0+=bit[0][entry-1], v1+=bit[1][entry-1], entry -= entry & -entry;\n\t\treturn e*v0+v1;\n\t}\n\tvoid add(int L, int R, V val) { // add val to L<=x<=R\n\t\tupdate(L,val,-val*(L-1));\n\t\tupdate(R+1,-val,val*R);\n\t}\n};\nBIT_r<ll,23> bt;\n\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tFOR(i,N) bt.add(i+1,i+1,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tbt.add(V[i]+1,min(V[i]+D[i]+1,N),X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<bt.total(min(V[i]+D[i]+1,N))-bt.total(V[i])<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tbt.add(N+1,N+1,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[100000];\nvector<int> G[100000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[3000000],part[3000000];\n \nvoid init(){\n    n = 524288;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i,i + 1,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[900005], fw2[900005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[55001];\nvi child[55001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(470001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 220; i++){\n\t\tdfs2(0);\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntypedef long long int64;\n\n\nconst int backet = 632;\n\nint N, Q;\nint64 C[800000];\nvector< int > g[800000];\nint T[400000], X[400000], Y[400000], Z[400000];\nbool live[800000];\n\nint in[800000], out[800000], ptr;\n\n\nvector< int > upquery[800000];\n\nvoid dfs(int idx)\n{\n  in[idx] = ptr++;\n  for(int to : g[idx]) dfs(to);\n  out[idx] = ptr;\n}\n\n\nint64 lazy[800001], add, sub;\n\nvoid update(int idx, int depth = 0)\n{\n  for(auto &q : upquery[idx]) {\n    add += Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] += Z[q];\n  }\n  sub += lazy[depth];\n  C[idx] += add - sub;\n  for(auto &to : g[idx]) {\n    if(!live[to]) update(to, depth + 1);\n  }\n  sub -= lazy[depth];\n  for(auto &q : upquery[idx]) {\n    add -= Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] -= Z[q];\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if(~a) g[a].push_back(i);\n    C[i] = b;\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &T[i], &X[i], &Y[i]);\n    if(T[i] == 1) scanf(\"%d\", &Z[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(T[i] == 3) {\n      live[sz] = true;\n      g[X[i]].push_back(sz);\n      C[sz] = Y[i];\n      ++sz;\n    }\n  }\n\n  dfs(0);\n\n  sz = N;\n  for(int i = 0; i < Q; i += backet) {\n    int left = i, right = min(Q, i + backet);\n\n\n    for(int j = 0; j < sz; j++) upquery[j].clear();\n    for(int j = left; j < right; j++) {\n      if(T[j] == 1) upquery[X[j]].push_back(j);\n    }\n    update(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> L(n);\n\tvector<int> R(n);\n\tvector<int> depth(n);\n\tvector<int> depth2(n);\n\tint now = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\tL[u] = now;\n\t\ta[now] = aa[u];\n\t\tdepth[now] = d;\n\t\tnow++;\n\t\tfor (int v : g[u]) {\n\t\t\tdfs(v, d + 1);\n\t\t}\n\t\tR[u] = now;\n\t};\n\tdfs(0, 0);\n\n\tauto lb = [&](vector<int> &v, int val) {\n\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdict[i / S].push_back(depth[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(dict[i].begin(), dict[i].end());\n\t\tbits.emplace_back(dict[i].size());\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\tbits[i / S].addRange(depth2[i], depth2[i] + 1, a[i]);\n\t}\n\n\tauto add = [&](int u, int k, int x) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\ta[l] += x;\n\t\t\t\t\tbits[l / S].addRange(depth2[l], depth2[l] + 1, x);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t};\n\n\tauto sum = [&](int u, int k) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\tlong long ret = 0;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\tret += a[l];\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\twhile (q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, d, x;\n\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\tadd(v, d, x);\n\t\t} else if (t == 2) {\n\t\t\tint v, d;\n\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\tprintf(\"ans:%lld\\n\", sum(v, d));\n\t\t} else {\n\t\t\tabort();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long int64;\n\nint N, Q;\nvector< int > g[800000];\nint A[800000], B[800000], C[800000], D[800000];\nint64 cost[800000];\n\n\nvoid add(int idx, int x, int depth)\n{\n  cost[idx] += x;\n  if(depth > 0) for(int to : g[idx]) add(to, x, depth - 1);\n}\n\nint64 sum(int idx, int depth)\n{\n  int64 ret = cost[idx];\n  if(depth > 0) for(int to : g[idx]) ret += sum(to, depth - 1);\n  return (ret);\n}\n\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  if(N > 5000 || Q > 5000) throw (0);\n  for(int i = 0; i < N; i++) {\n    int par;\n    scanf(\"%d %lld\", &par, &cost[i]);\n    if(~par) g[par].push_back(i);\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    if(A[i] == 1) scanf(\"%d\", &D[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(A[i] == 1) {\n      add(B[i], D[i], C[i]);\n    } else if(A[i] == 2) {\n      printf(\"%lld\\n\", sum(B[i], C[i]));\n    } else if(A[i] == 3) {\n      cost[sz] = C[i];\n      g[B[i]].push_back(sz++);\n    }\n\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tif (n >= MAX)exit(1);\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\ta--;\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,q;\nint par[452521], a[452521];\nvi children[452521];\n\nvoid dfs1(int p,int d,int x){\n  a[p] += x;\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      dfs1(to,d,x);\n    }\n  }\n}\nll dfs2(int p,int d){\n  ll ret = a[p];\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      ret += dfs2(to,d);\n    }\n  }\n  return ret;\n}\n\nconst int MAX = 1<<2;\nll dat[2*MAX];\nll lazy[2*MAX];\nvoid push(int k,int a,int b){\n  if(lazy[k]!=0){\n    dat[k] += lazy[k] * (b-a);\n    if(k<MAX-1){\n      lazy[2*k+1] += lazy[k];\n      lazy[2*k+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n}\nvoid add(int l,int r,int v,int a,int b,int k){\n  push(k,a,b);\n  if(r<=a || b<=l){\n    return;\n  }\n  if(l<=a && b<=r){\n    lazy[k] += v;\n    push(k,a,b);\n  }else{\n    int m = (a+b)/2;\n    add(l,r,v,a,m,2*k+1);\n    add(l,r,v,m,b,2*k+2);\n    dat[k] = dat[2*k+1] + dat[2*k+2];\n  }\n}\nll sum(int l,int r,int a,int b,int k){\n  push(k,a,b);\n  if(r<=a || b<=l)return 0ll;\n  if(l<=a && b<=r){\n    return dat[k];\n  }else{\n    int m = (a+b)/2;\n    return sum(l,r,a,m,2*k+1) + sum(l,r,m,b,2*k+2);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&q);\n  REP(i,n)scanf(\"%d%d\",par+i,a+i);\n  if(false && n<=5000 && q<=5000){\n    // 170\n    // naive\n    REP(i,n)if(par[i]>=0){\n      children[par[i]].push_back(i);\n    }\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        dfs1(v,d,x);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",dfs2(v,d));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = ar;\n        n++;\n      }\n    }\n  }else{\n    // 240\n    REP(i,n)assert(par[i]+1 == i);\n    REP(i,n)dat[i+MAX-1] = a[i];\n    FORR(i,0,MAX-1)dat[i] = dat[2*i+1] + dat[2*i+2];\n    set<int> haschild;\n    int fn = n;\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        if(v < fn){\n          add(v,min(fn,v+d+1),x,0,MAX,0);\n          for(int xx : haschild){\n            int nd = xx - v;\n            if(nd >= 0 && nd < d){\n              for(int c : children[xx]){\n                dfs1(c,d-nd-1,x);\n              }\n            }\n          }\n        }else{\n          dfs1(v,d,x);\n        }\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        if(v < fn){\n          ll ans = sum(v,v+d+1,0,MAX,0);\n          for(int x : haschild){\n            int nd = x - v;\n            if(nd >= 0 && nd < d){\n              for(int c : children[x]){\n                ans += dfs2(c,d-nd-1);\n              }\n            }\n          }\n          printf(\"%lld\\n\",ans);\n        }else{\n          printf(\"%lld\\n\",dfs2(v,d));\n        }\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = ar;\n        if(pr < fn)haschild.insert(pr);\n        n++;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n//http://kagamiz.hatenablog.com/entry/2012/12/18/220849から引用 (ごめんなさい！！！)\nstatic const int MAX_SIZE = 1 << 19; //segment tree のサイズ。\n\ntypedef long long Int;\ntypedef long long ll;\nInt all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nInt sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nint n, q;\nvector<int> et[500000];\nint a[500000];\n\nvoid dfsAdd(int id, int remDep, int val) {\n\ta[id] += val;\n\tif (remDep == 0) return;\n\t\n\tfor (int i = 0; i < et[id].size(); i++) {\n\t\tdfsAdd(et[id][i], remDep - 1, val);\n\t}\n}\n\nint dfsSum(int id, int remDep) {\n\t//cout << \"id = \" << id << endl;\n\t//cout << \"et[id].size() = \" << et[id].size() << endl;\n\tif (remDep == 0) return a[id];\n\t\n\tint ret = 0;\n\tfor (int i = 0; i < et[id].size(); i++) {\n\t\tret += dfsSum(et[id][i], remDep - 1);\n\t}\n\treturn ret + a[id];\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> q;\n\tfor (i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x >> a[i];\n\t\tif (x != -1) { et[x].push_back(i); }\n\t}\n\t\n\tif (n <= 5000 && q <= 5000) {\t//subtask1\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tint type, x, y, z;\n\t\t\tcin >> type;\n\t\t\t\n\t\t\tif (type == 1) {\n\t\t\t\tcin >> x >> y >> z;\n\t\t\t\tdfsAdd(x, y, z);\n\t\t\t}\n\t\t\telse if (type == 2) {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tcout << dfsSum(x, y) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tet[x].push_back(n);\n\t\t\t\ta[n] = y;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\t//subtask2\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tint type, x, y, z;\n\t\t\tcin >> type;\n\t\t\t\n\t\t\tif (type == 1) {\n\t\t\t\tcin >> x >> y >> z;\n\t\t\t\tadd(x, x + y + 1, z);\n\t\t\t}\n\t\t\telse if (type == 2) {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tcout << sum(x, x + y + 1) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> x >> y;\n\t\t\t\t//a[n] = y;\n\t\t\t\tadd(n, n + 1, y);\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstruct SegmentTree\n{\n  vector< int64 > add, seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n\n  void update(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += 1LL * x;\n      return;\n    }\n    update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    seg[k] = seg[2 * k + 1] + seg[2 * k + 2];\n    int mid = (l + r) >> 1;\n    seg[k] += add[2 * k + 1] * (mid - l);\n    seg[k] += add[2 * k + 2] * (r - mid);\n  }\n\n  void update(int a, int b, int x)\n  {\n    update(a, b, x, 0, 0, sz);\n  }\n\n  int64 query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (0LL);\n    if(a <= l && r <= b) return (seg[k] + add[k] * (r - l));\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) +\n            query(a, b, 2 * k + 2, (l + r) >> 1, r) + add[k] * (min(b, r) - max(a, l)));\n  }\n\n  int64 query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nstruct SegmentTree2D\n{\n  vector< SegmentTree > add, seg;\n  vector< vector< int > > vs;\n  int sz;\n\n  SegmentTree2D(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    vs.resize(2 * sz - 1);\n  }\n\n  void set(int k, int height)\n  {\n    vs[k + sz - 1].push_back(height);\n  }\n\n  void build()\n  {\n    for(int k = sz - 1; k < vs.size(); k++) {\n      sort(begin(vs[k]), end(vs[k]));\n    }\n    for(int k = sz - 2; k >= 0; k--) {\n      vs[k].resize(vs[2 * k + 1].size() + vs[2 * k + 2].size());\n      merge(begin(vs[2 * k + 1]), end(vs[2 * k + 1]),\n            begin(vs[2 * k + 2]), end(vs[2 * k + 2]),\n            begin(vs[k]));\n    }\n    for(int k = 0; k < vs.size(); k++) {\n      add.emplace_back(SegmentTree(vs[k].size()));\n      seg.emplace_back(SegmentTree(vs[k].size()));\n    }\n  }\n\n  inline int lb(int k, int height)\n  {\n    return (lower_bound(begin(vs[k]), end(vs[k]), height) - begin(vs[k]));\n  }\n\n  int update(int a, int b, int Low, int High, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return (0);\n    } else if(a <= l && r <= b) {\n      int latte = lb(k, Low), malta = lb(k, High);\n      add[k].update(latte, malta, x);\n      return (malta - latte);\n    } else {\n      int p = update(a, b, Low, High, x, 2 * k + 1, l, (l + r) >> 1) +\n              update(a, b, Low, High, x, 2 * k + 2, (l + r) >> 1, r);\n      int q = lb(k, Low);\n      seg[k].update(q, q + p, x);\n      return (p);\n    }\n  }\n\n  void update(int a, int b, int Low, int High, int x)\n  {\n    update(a, b, Low, High, x, 0, 0, sz);\n  }\n\n  pair< int64, int > query(int a, int b, int low, int high, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return {0, 0};\n    if(a <= l && r <= b) {\n      int latte = lb(k, low), malta = lb(k, high);\n      auto vv = seg[k].query(latte, malta) + add[k].query(latte, malta);\n      return {vv, malta - latte};\n    }\n    auto s = query(a, b, low, high, 2 * k + 1, l, (l + r) >> 1);\n    auto t = query(a, b, low, high, 2 * k + 2, (l + r) >> 1, r);\n\n    int latte = s.second + t.second;\n    int malta = lb(k, low);\n    auto q = add[k].query(malta, latte + malta);\n    return {s.first + t.first + q, latte};\n  }\n\n  int64 query(int a, int b, int low, int high)\n  {\n    return (query(a, b, low, high, 0, 0, sz).first);\n  }\n};\n\n\nint N, Q, cost[800000];\nvector< int > g[800000];\nint A[800000], B[800000], C[800000], D[800000];\n\n\nint in[800000], out[800000], dep[800000], ptr;\n\n\nvoid rec(int idx, int depth = 0)\n{\n  dep[idx] = depth;\n  in[idx] = ptr++;\n  for(int to : g[idx]) rec(to, depth + 1);\n  out[idx] = ptr;\n}\n\n\nint main()\n{\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++) {\n    int par;\n    cin >> par >> cost[i];\n    if(~par) g[par].push_back(i);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    cin >> A[i] >> B[i] >> C[i];\n    if(A[i] == 1) cin >> D[i];\n/*\n    if(A[i] == 3) {\n      g[B[i]].push_back(sz);\n      cost[sz] = C[i];\n      B[i] = sz++;\n    }\n*/\n  }\n\n  rec(0);\n  SegmentTree2D tree(sz);\n  for(int i = 0; i < sz; i++) tree.set(in[i], dep[i]);\n  tree.build();\n  for(int i = 0; i < sz; i++) {\n    tree.update(in[i], in[i] + 1, dep[i], dep[i] + 1, cost[i]);\n  }\n\n  for(int i = 0; i < Q; i++) {\n    if(A[i] == 1) {\n      tree.update(in[B[i]], out[B[i]], dep[B[i]], dep[B[i]] + C[i] + 1, D[i]);\n    } else if(A[i] == 2) {\n      cout << tree.query(in[B[i]], out[B[i]], dep[B[i]], dep[B[i]] + C[i] + 1) << endl;\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V> class SegTree_3 {\npublic:\n\tint NV;\n\tvector<V> tot,each;\n\tvoid init(int count) {\n\t\tNV=1;\n\t\twhile((1<<NV)<=count*2) NV++;\n\t\ttot.resize(NV*2,0);\n\t\teach.resize(NV*2,0);\n\t};\n\t\n\tll getval(int x,int y,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(r<=x || y<=l) return 0;\n\t\tif(x<=l && r<=y) return tot[k];\n\t\treturn getval(x,y,l,(l+r)/2,k*2)+getval(x,y,(l+r)/2,r,k*2+1)+each[k]*(min(y,r)-max(x,l));\n\t}\n\t\n\tvoid update(int x,int y, V v,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(l>=r) return;\n\t\tif(x<=l && r<=y) {\n\t\t\teach[k]+=v;\n\t\t\ttot[k]+=v*(r-l);\n\t\t}\n\t\telse if(l < y && x < r) {\n\t\t\tupdate(x,y,v,l,(l+r)/2,k*2);\n\t\t\tupdate(x,y,v,(l+r)/2,r,k*2+1);\n\t\t\ttot[k]=tot[2*k]+tot[2*k+1]+each[k]*(r-l);\n\t\t}\n\t}\n};\nSegTree_3<ll> bit[505050];\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tSegTree_3<ll> st;\n\t\tst.init(1<<20);\n\t\tFOR(i,N) st.update(i+1,i+2,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tst.update(V[i]+1,V[i]+D[i]+2,X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<st.getval(V[i]+1,V[i]+D[i]+2)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tst.update(N+1,N+2,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\n/*  ※！注意！※\n\t1-indexじゃないとWA！\n\tMAX_Vはギリギリにしないように！   */\nconst LL MAX_V = 412345;\nconst LL MAX_LOG_V = 20;\nstd::vector<LL>G[MAX_V];\t\t// グラフの隣接リスト表現\nLL root;\t\t\t\t\t\t// 根ノードの番号\nLL parent[MAX_LOG_V][MAX_V];\t// 親を2^k回のぼって到達する頂点（根を通り過ぎる場合は-1とする）\nLL depth[MAX_V];\t\t\t\t// 根からの深さ\nclass LCA\n{\npublic:\n\tvoid dfs(LL v, LL p, LL d);\n\tvoid init(LL V);\n\tLL lca(LL u, LL v);\n};\nvoid LCA::dfs(LL v, LL p, LL d)\n{\n\tdepth[v] = d;\n\tfor (auto i : G[v])\n\t{\n\t\tif (i != p) { dfs(i, v, d + 1); }\n\t}\n}\nvoid LCA::init(LL V)\t\t\t\t// 初期化\n{\n\t// parent[0]とdepthを初期化する\n\tdfs(root, -1, 0);\n}\n\nLL N, Q, p[412345], a[412345], query[51234], v[51234], d[51234], x[51234], pr[51234], ar[51234];\nLCA tree;\n\nint main()\n{\n\tin >> N >> Q;\n\trep(i, N)\n\t{\n\t\tin >> p[i + 1] >> a[i + 1];\n\t\tG[p[i + 1]].push_back(i + 1);\n\t}\n\trep(i, Q)\n\t{\n\t\tin >> query[i];\n\t\tif (query[i] == 1)\n\t\t{\n\t\t\tin >> v[i] >> d[i] >> x[i];\n\t\t}\n\t\tif (query[i] == 2)\n\t\t{\n\t\t\tin >> v[i] >> d[i];\n\t\t}\n\t\tif (query[i] == 3)\n\t\t{\n\t\t\tin >> pr[i] >> ar[i];\n\t\t}\n\t}\n\n\tif (N > 5000 || Q > 5000) { return 0; }\n\ttree.init(N);\n\trep(i, Q)\n\t{\n\t\tif (query[i] == 1)\n\t\t{\n\t\t\tfor (LL j = v[i] + 1; j <= N; ++j)\n\t\t\t{\n\t\t\t\tif (depth[j] - depth[v[i]] <= d[i])\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (query[i] == 2)\n\t\t{\n\n\t\t}\n\t\tif (query[i] == 3)\n\t\t{\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tll sval[4*SZ]; int slazy[4*SZ]; int scnt[4*SZ];\n\tvoid clear() {\n\t\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\t}\n\tvoid spush(int x) {\n\t\tif(slazy[x]==0) return;\n\t\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\t\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\t\tslazy[x]=0;\n\t}\n\tvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\n\tvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\t\tif(l==r) {\n\t\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n\t}\n\tvoid smod(int x,int l,int r,int L,int R,int BY) {\n\t\tif(L<=l&&r<=R) {\n\t\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\t\tslazy[x]+=BY;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n\t}\n\tll sget(int x,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {\n\t\t\treturn sval[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; ll ret=0;\n\t\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid save(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tval[l]=sval[x]; cnt[l]=scnt[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; save(2*x+1,l,m,val,cnt); save(2*x+2,m+1,r,val,cnt);\n\t\t}\n\t}\n\tvoid load(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tsval[x]=val[l],scnt[x]=cnt[l];\n\t\t} else {\n\t\t\tint m=l+(r-l)/2; load(2*x+1,l,m,val,cnt); load(2*x+2,m+1,r,val,cnt);\n\t\t\tscalc(x);\n\t\t}\n\t}\n} S;\nS s[MAXB];\n\n\nint nb;\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tnb=(nemp+SZ-1)/SZ;\n\tREP(i,nb) s[i].clear();\n\tREP(i,nemp) if(alive[i]) s[pos[i]/SZ].sborn(0,0,SZ-1,pos[i]%SZ,oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n\nll tval[SZ]; int tcnt[SZ];\nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\t//return s[pos[idx]/SZ].sget(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ);\n\treturn tval[pos[idx]%SZ];\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].sget(0,0,SZ-1,l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\t}\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n\nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\t//s[pos[idx]/SZ].smod(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ,by);\n\ttval[pos[idx]%SZ]+=by;\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].smod(0,0,SZ-1,l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].sborn(0,0,SZ-1,pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=rand()%min(n,10),qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=rand()%min(n,10),qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\t//REP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]); exit(0);\n\t\tll chk=0; REP(i,nq) if(qt[i]==2) chk+=ans[i];\n\t\tprintf(\"%.9lf %lld\\n\",double(clock() - begin) / CLOCKS_PER_SEC,chk);\n\t}\n}\n \nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\nll lazy[2000001];\nll sum[2000001];\n\nvoid build(int id, int l, int r)\n{\n\tif(r-l<2)\n\t{\n\t\tsum[id]=a[l];\n\t\tlazy[id]=0;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(id*2,l,mid);\n\tbuild(id*2+1,mid,r);\n\tsum[id]=sum[id*2]+sum[id*2+1];\n}\n\nvoid push(int id, int l, int r)\n{\n\tif(lazy[id]!=0)\n\t{\n\t\tsum[id]+=ll(r-l)*lazy[id];\n\t\tif(r-l>=2)\n\t\t{\n\t\t\tlazy[2*id]+=lazy[id];\n\t\t\tlazy[2*id+1]+=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n}\n\nvoid update(int id, int l, int r, int ql, int qr, int v)\n{\n\tpush(id,l,r);\n\tif(l>=qr||ql>=r) return ;\n\tif(ql<=l&&r<=qr)\n\t{\n\t\tlazy[id]+=v;\n\t\tpush(id,l,r);\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tupdate(id*2,l,mid,ql,qr,v);\n\tupdate(id*2+1,mid,r,ql,qr,v);\n\tsum[id]=sum[id*2]+sum[id*2+1];\n}\n\nll query(int id, int l, int r, int ql, int qr)\n{\n\tpush(id,l,r);\n\tif(l>=qr||ql>=r) return 0;\n\tif(ql<=l&&r<=qr) return sum[id];\n\tint mid=(l+r)>>1;\n\treturn (query(id*2,l,mid,ql,qr)+query(id*2+1,mid,r,ql,qr));\n}\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tupdate(1,0,460000,i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tupdate(1,0,460000,cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\tassert(d>=0);\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<query(1,0,460000,u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tupdate(1,0,460000,u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}*/\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tLazySegmentTree seg(n+q);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, Q;\n  cin >> N >> Q;\n  if(N > 5000 || Q > 5000) return 0;\n  vector<vint> graph(N);\n  vint a(N);\n  rep(i, N) {\n    int p;\n    cin >> p >> a[i];\n    if(~p) graph[p].push_back(i);\n  }\n  while(Q--) {\n    int w, x, y, z;\n    cin >> w >> x >> y;\n    if(w == 1) {\n      cin >> z;\n      queue<pint> que;\n      que.emplace(x, y);\n      while(!que.empty()) {\n\tint v, d; tie(v, d) = que.front(); que.pop();\n\ta[v] += z;\n\tif(d == 0) continue;\n\tfor(int to : graph[v]) {\n\t  que.emplace(to, d-1);\n\t}\n      }\n    } else if(w == 2) {\n      int sum = 0;\n      queue<pint> que;\n      que.emplace(x, y);\n      while(!que.empty()) {\n\tint v, d; tie(v, d) = que.front(); que.pop();\n\tsum += a[v];\n\tif(d == 0) continue;\n\tfor(int to : graph[v]) {\n\t  que.emplace(to, d-1);\n\t}\n      }\n      cout << sum << endl;\n    } else if(w == 3) {\n      graph[x].push_back(N++);\n      graph.push_back(vint());\n      a.push_back(y);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntypedef long long int64;\n\n\nconst int backet = 333;\n\nint N, Q;\nint64 C[800000];\nvector< int > g[800000];\nint T[400000], X[400000], Y[400000], Z[400000];\nbool live[800000];\n\nint in[800000], out[800000], ptr;\n\n\nvector< int > upquery[800000];\n\nvoid dfs(int idx)\n{\n  in[idx] = ptr++;\n  for(int to : g[idx]) dfs(to);\n  out[idx] = ptr;\n}\n\n\nint64 lazy[800001], add, sub;\n\nvoid update(int idx, int depth = 0)\n{\n  for(auto &q : upquery[idx]) {\n    add += Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] += Z[q];\n  }\n  sub += lazy[depth];\n  C[idx] += add - sub;\n  for(auto &to : g[idx]) {\n    if(!live[to]) update(to, depth + 1);\n  }\n  sub -= lazy[depth];\n  for(auto &q : upquery[idx]) {\n    add -= Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] -= Z[q];\n  }\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if(~a) g[a].push_back(i);\n    C[i] = b;\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &T[i], &X[i], &Y[i]);\n    if(T[i] == 1) scanf(\"%d\", &Z[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(T[i] == 3) {\n      live[sz] = true;\n      g[X[i]].push_back(sz);\n      C[sz] = Y[i];\n      ++sz;\n    }\n  }\n\n  dfs(0);\n\n  sz = N;\n  for(int i = 0; i < Q; i += backet) {\n    int left = i, right = min(Q, i + backet);\n\n\n    for(int j = 0; j < sz; j++) upquery[j].clear();\n    for(int j = left; j < right; j++) {\n      if(T[j] == 1) upquery[X[j]].push_back(j);\n    }\n    update(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nvoid small1() {\n\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = 0;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<int(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%d\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else if (!has3) {\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\twhile (q--) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t == 1) {\n\t\t\t\tint v, d, x;\n\t\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\t\tadd(v, d, x);\n\t\t\t} else if (t == 2) {\n\t\t\t\tint v, d;\n\t\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], foo[i] + bar[i] + 1, baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=450;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tint n,id;\n\tll val[2*SZ]; int lazy[2*SZ]; int cnt[2*SZ];\n\n\tinline void push(int x) {\n\t\tif(lazy[x]==0) return;\n\t\tapply(2*x,lazy[x]);\n\t\tapply(2*x+1,lazy[x]);\n\t\tlazy[x]=0;\n\t}\n\tinline void calc(int x) {\n\t\tcnt[x]=cnt[2*x]+cnt[2*x+1];\n\t\tval[x]=val[2*x]+val[2*x+1]+(ll)cnt[x]*lazy[x];\n\t}\n\tinline void apply(int x,int by) {\n\t\tval[x]+=(ll)by*cnt[x];\n\t\tlazy[x]+=by;\n\t}\n\tinline void build(int _id,int _n,int* sval,int* scnt) {\n\t\tid=_id; n=_n; assert(n<=SZ);\n\t\tREP(i,n) val[n+i]=scnt[i]?sval[i]:0,cnt[n+i]=scnt[i];\n\t\tfor(int i=n-1;i>0;--i) calc(i);\n\t}\n\tvoid incrange(int l,int r,int by) {\n\t\t//printf(\"%d: incrange(%d,%d,%d)\\n\",id,l,r,by);\n\t\tl+=n,r+=n;\n\t\tint oldl=l,oldr=r;\n\t\t{ int h=0; while((l>>h)>1) ++h; for(;h>0;--h) push(l>>h); }\n\t\t{ int h=0; while((r>>h)>1) ++h; for(;h>0;--h) push(r>>h); }\n\t\tfor(++r;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) apply(l++,by);\n\t\t\tif(r&1) apply(--r,by);\n\t\t}\n\t\tfor(int idx=oldl>>1;idx>0;idx>>=1) calc(idx);\n\t\tfor(int idx=oldr>>1;idx>0;idx>>=1) calc(idx);\n\t\t//if(id==1) { FOR(i,1,2*n) printf(\"\\t%d: val=%lld lazy=%d cnt=%d\\n\",i,val[i],lazy[i],cnt[i]); }\n\t}\n\tvoid setpoint(int idx,int sval) {\n\t\t//printf(\"%d: setpoint(%d,%d)\\n\",id,idx,sval);\n\t\tidx+=n;\tcnt[idx]=1,val[idx]=sval;\n\t\tfor(idx>>=1;idx>0;idx>>=1) calc(idx);\n\t}\n\tll get(int l,int r) {\n\t\t//printf(\"%d: get(%d,%d)\\n\",id,l,r);\n\t\tl+=n,r+=n;\n\t\t{ int h=0; while((l>>h)>1) ++h; for(;h>0;--h) push(l>>h); }\n\t\t{ int h=0; while((r>>h)>1) ++h; for(;h>0;--h) push(r>>h); }\n\t\tll ret=0;\n\t\tfor(++r;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) ret+=val[l++];\n\t\t\tif(r&1) ret+=val[--r];\n\t\t}\n\t\t//printf(\"=%lld\\n\",ret);\n\t\treturn ret;\n\t}\n} S;\nS s[MAXB];\n\n\npair<int,int> tmp[SZ];\nint tval[SZ],tcnt[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t\tREP(j,cnt) tval[j]=oval[tmp[j].second],tcnt[j]=alive[tmp[j].second]?1:0; s[i/SZ].build(i/SZ,min(SZ,nemp-i),tval,tcnt);\n\t}\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n \nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\treturn s[pos[idx]/SZ].get(pos[idx]%SZ,pos[idx]%SZ);\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].get(l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n \nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\ts[pos[idx]/SZ].incrange(pos[idx]%SZ,pos[idx]%SZ,by);\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].incrange(l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].setpoint(pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=0,qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=0,qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\tprintf(\"%.9lf\\n\",double(clock() - begin) / CLOCKS_PER_SEC);\n\t}\n}\n \nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\t/*for (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\ta--;\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[100000];\nvector<int> G[100000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[1050000],part[1050000];\n \nvoid init(){\n    int nn = 1;\n    while(nn < n) nn *= 2;\n    n = nn;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i,i + 1,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[5001];\nvi child[5001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(400001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (false) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n \nint n;\nint q;\n \nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n \n#define MAX 800002\n \nvector<int> v[MAX];\n \nlong long int cost[MAX];\n \nvector<query> Q;\n \nbool ex[MAX];\n \nvector<pair<int, long long int> > ev[MAX];\n \nlong long int ans[MAX];\n \n \nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n \nint dep[MAX];\n \nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n \nBIT B;\n \nlong long int flag[MAX];\n \ninline void dfs(int b,long long int cur_add=0){\n\t/*if (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n \nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n \nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n \ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n \ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n \n \ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n \n \nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntypedef long long int64;\n\n\nconst int backet = 1000;\n\nint N, Q;\nint64 C[800000];\nvector< int > g[800000];\nint T[400000], X[400000], Y[400000], Z[400000];\nbool live[800000];\n\nint in[800000], out[800000], ptr;\n\n\nvector< int > upquery[800000];\n\nvoid dfs(int idx)\n{\n  in[idx] = ptr++;\n  for(int to : g[idx]) dfs(to);\n  out[idx] = ptr;\n}\n\n\nint64 lazy[800001], add, sub;\n\nvoid update(int idx, int depth = 0)\n{\n  for(auto &q : upquery[idx]) {\n    add += Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] += Z[q];\n  }\n  sub += lazy[depth];\n  C[idx] += add - sub;\n  for(auto &to : g[idx]) {\n    if(!live[to]) update(to, depth + 1);\n  }\n  sub -= lazy[depth];\n  for(auto &q : upquery[idx]) {\n    add -= Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] -= Z[q];\n  }\n  upquery[idx].clear();\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if(~a) g[a].push_back(i);\n    C[i] = b;\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &T[i], &X[i], &Y[i]);\n    if(T[i] == 1) scanf(\"%d\", &Z[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(T[i] == 3) {\n      live[sz] = true;\n      g[X[i]].push_back(sz);\n      C[sz] = Y[i];\n      ++sz;\n    }\n  }\n\n  dfs(0);\n\n  sz = N;\n  for(int i = 0; i < Q; i += backet) {\n    int left = i, right = min(Q, i + backet);\n\n\n    for(int j = left; j < right; j++) {\n      if(T[j] == 1) upquery[X[j]].push_back(j);\n    }\n    update(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[400000];\nvector<int> G[400000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[3000000],part[3000000];\n \nvoid init(){\n    n = 524288;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i + 1,i + 2,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[55001];\nvi child[55001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(470001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\t//init();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\nll lazy[2000001];\nll sum[2000001];\n\nvoid build(int id, int l, int r)\n{\n\tif(r-l<2)\n\t{\n\t\tsum[id]=a[l];\n\t\tlazy[id]=0;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(id*2,l,mid);\n\tbuild(id*2+1,mid,r);\n\tsum[id]=sum[id*2]+sum[id*2+1];\n}\n\nvoid push(int id, int l, int r)\n{\n\tif(lazy[id]!=0)\n\t{\n\t\tsum[id]+=ll(r-l)*lazy[id];\n\t\tif(r-l>=2)\n\t\t{\n\t\t\tlazy[2*id]+=lazy[id];\n\t\t\tlazy[2*id+1]+=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n}\n\nvoid update(int id, int l, int r, int ql, int qr, int v)\n{\n\tpush(id,l,r);\n\tif(l>=qr||ql>=r) return ;\n\tif(ql<=l&&r<=qr)\n\t{\n\t\tlazy[id]+=v;\n\t\tpush(id,l,r);\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tupdate(id*2,l,mid,ql,qr,v);\n\tupdate(id*2+1,mid,r,ql,qr,v);\n\tsum[id]=sum[id*2]+sum[id*2+1];\n}\n\nll query(int id, int l, int r, int ql, int qr)\n{\n\tpush(id,l,r);\n\tif(l>=qr||ql>=r) return 0;\n\tif(ql<=l&&r<=qr) return sum[id];\n\tint mid=(l+r)>>1;\n\treturn (query(id*2,l,mid,ql,qr)+query(id*2+1,mid,r,ql,qr));\n}\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\tif(n<=5000&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tupdate(1,0,460000,i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tupdate(1,0,460000,cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\tassert(d>=0);\n\t\td=min(d,cnt-1-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<query(1,0,460000,u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tupdate(1,0,460000,u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\t//init();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tif (q > 50000)exit(1);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tif (n >= MAX)exit(1);\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[100000];\nvector<int> G[100000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[3000000],part[3000000];\n \nvoid init(){\n    n = 524288;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i + 1,i + 2,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\t/*for (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[55001];\nvi child[55001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(400001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nvoid small1() {\n\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<long long> a(n);\n\tvector<long long> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %lld\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = false;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<long long(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0LL;\n\t\t\t}\n\t\t\tlong long ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else if (!has3) {\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\twhile (q--) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t == 1) {\n\t\t\t\tint v, d, x;\n\t\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\t\tadd(v, d, x);\n\t\t\t} else if (t == 2) {\n\t\t\t\tint v, d;\n\t\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], foo[i] + bar[i] + 1, baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 220; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tsum += v[j].size();\n\t\t}\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(470001);\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int MN=400000;\n\nint N,Q;\nint A[MN];\nvint G[MN];\n\nint tt,tin[MN],tout[MN],dep[MN];\nvoid dfs(int v,int d){\n    tin[v]=tt++;\n    dep[v]=d;\n    for(auto u:G[v]){\n        dfs(u,d+1);\n    }\n    tout[v]=tt;\n}\n\nvoid task1(){\n    rep(i,Q){\n        tt=0;\n        dfs(0,0);\n        int t;\n        scanf(\"%lld\",&t);\n        if(t==1){\n            int v,d,x;\n            scanf(\"%lld%lld%lld\",&v,&d,&x);\n            rep(j,N){\n                if(dep[j]<dep[v]||dep[v]+d<dep[j])continue;\n                if(tin[v]<=tin[j]&&tin[j]<tout[v])A[j]+=x;\n            }\n        }\n        else if(t==2){\n            int v,d;\n            scanf(\"%lld%lld\",&v,&d);\n            int ans=0;\n            rep(j,N){\n                if(dep[j]<dep[v]||dep[v]+d<dep[j])continue;\n                if(tin[v]<=tin[j]&&tin[j]<tout[v])ans+=A[j];\n            }\n            printf(\"%lld\\n\",ans);\n        }\n        else{\n            int p,a;\n            scanf(\"%lld%lld\",&p,&a);\n            G[p].pb(N);\n            A[N]=a;\n            N++;\n        }\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&Q);\n    for(int i=0;i<N;i++){\n        int p;\n        scanf(\"%lld%lld\",&p,&A[i]);\n        if(p!=-1){\n            G[p].pb(i);\n        }\n    }\n\n    if(N<=5000&&Q<=5000)task1();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t}\n\tLazySegmentTree seg(n+q);\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tu--;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> L(n);\n\tvector<int> R(n);\n\tvector<int> depth(n);\n\tvector<int> depth2(n);\n\tint now = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\tL[u] = now;\n\t\ta[now] = aa[u];\n\t\tdepth[now] = d;\n\t\tnow++;\n\t\tfor (int v : g[u]) {\n\t\t\tdfs(v, d + 1);\n\t\t}\n\t\tR[u] = now;\n\t};\n\tdfs(0, 0);\n\n\tauto lb = [&](vector<int> &v, int val) {\n\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdict[i / S].push_back(depth[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(dict[i].begin(), dict[i].end());\n\t\tbits.emplace_back(dict[i].size());\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t}\n\n\tauto add = [&](int u, int k, int x) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\ta[l] += x;\n\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t};\n\n\tauto sum = [&](int u, int k) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\tlong long ret = 0;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\twhile (q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, d, x;\n\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\tadd(v, d, x);\n\t\t} else if (t == 2) {\n\t\t\tint v, d;\n\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[900005], fw2[900005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\t//child[b] += child[go];\n\t}\n\t//en[b] = ord;\n\t//child[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 50; i++){\n\t\tinit();\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V, int ME> class BIT_r {\npublic:\n\tV bit[2][1<<ME];\n\tBIT_r(){clear();};\n\tvoid clear() {ZERO(bit);};\n\t\n\tvoid update(int entry, V val0, V val1) {\n\t\tentry++;\n\t\twhile(entry <= 1<<ME) bit[0][entry-1]+=val0, bit[1][entry-1] += val1, entry += entry & -entry;\n\t}\n\tV total(int entry) {\n\t\tint e=entry++;\n\t\tV v0=0,v1=0;\n\t\twhile(entry>0) v0+=bit[0][entry-1], v1+=bit[1][entry-1], entry -= entry & -entry;\n\t\treturn e*v0+v1;\n\t}\n\tvoid add(int L, int R, V val) { // add val to L<=x<=R\n\t\tupdate(L,val,-val*(L-1));\n\t\tupdate(R+1,-val,val*R);\n\t}\n};\nBIT_r<ll,23> bt;\n\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=0) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tFOR(i,N) bt.add(i+1,i+1,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tbt.add(V[i]+1,min(V[i]+D[i]+1,N),X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<bt.total(min(V[i]+D[i]+1,N))-bt.total(V[i])<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tbt.add(N+1,N+1,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(500001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\tassert(d>=0);\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[55001];\nvi child[55001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(470001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\t//child[b] += child[go];\n\t}\n\t//en[b] = ord;\n\t//child[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 50; i++){\n\t\tinit();\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<long long> a(n);\n\tvector<long long> aa(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %lld\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = false;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (!has3) {\n\t\tvector<vector<int>> dict(N);\n\t\tvector<BIT<long long>> bits;\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], bar[i], baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t} else if (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<long long(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0LL;\n\t\t\t}\n\t\t\tlong long ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], min(now, foo[i] + bar[i] + 1), baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[900005], fw2[900005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\tb = min(b, N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tif (n >= MAX)exit(1);\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\t//subtusk 2 only! 240 points!\n\tllint i,a,b,c,d,N,Q,ans;\n\tvector<llint> kyu;\n\tscanf(\"%lld %lld\",&N,&Q);\n\tfor(i=0;i<N;i++){\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\tif(a!=i-1){return 0;}//降参\n\t\tkyu.pub(b);\n\t}\n\tfor(;Q>0;Q--){\n\t\tscanf(\"%lld\",&a);\n\t\tif(a==1){\n\t\t\tscanf(\"%lld %lld %lld\",&b,&c,&d);\n\t\t\tkyu[b]+=d;\n\t\t\tif(b+c<kyu.size()){ kyu[b+c]+=d; }\n\t\t}\n\t\tif(a==2){\n\t\t\tscanf(\"%lld %lld\",&b,&c);\n\t\t\tans=kyu[b];\n\t\t\tif(b+c<kyu.size()){ans+=kyu[b+c];}\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t}\n\t\tif(a==3){\n\t\t\tscanf(\"%lld %lld\",&b,&c);\n\t\t\tkyu.pub(c);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=1000;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n\nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n\nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n\nint pos[MAXEMP];\nint sd[MAXEMP];\nll sval[4*MAXEMP]; int slazy[4*MAXEMP]; int scnt[4*MAXEMP];\n\nvoid spush(int x) {\n\tif(slazy[x]==0) return;\n\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\tslazy[x]=0;\n}\nvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\nvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\tif(l==r) {\n\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2;\n\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\tscalc(x);\n\t}\n\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n}\nvoid smod(int x,int l,int r,int L,int R,int BY) {\n\tif(L<=l&&r<=R) {\n\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\tslazy[x]+=BY;\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2;\n\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\tscalc(x);\n\t}\n\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n}\nll sget(int x,int l,int r,int L,int R) {\n\tif(L<=l&&r<=R) {\n\t\treturn sval[x];\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2; ll ret=0;\n\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\treturn ret;\n\t}\n}\n\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\tREP(i,nemp) if(alive[i]) sborn(0,0,nemp-1,pos[i],oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n\nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\treturn sget(0,0,nemp-1,pos[idx],pos[idx]);\n}\n\nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn sget(0,0,nemp-1,l,r-1);\n}\n\nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n\nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\tsmod(0,0,nemp-1,pos[idx],pos[idx],by);\n}\n\nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn smod(0,0,nemp-1,l,r-1,by);\n}\n\nvoid update(int lid,int rid,int ld,int rd,int by) {\n\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n\nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\tsborn(0,0,nemp-1,pos[idx],oval[idx]);\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n\n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) printf(\"%lld\\n\",query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1));\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 500000;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nconst int BLOCK = 5000;\n// NlogN to recalculate \n// Q*(Q+1)/2 == NlogN\n\ntemplate<class T, int SZ> struct BIT {\n    T bit[SZ];\n    void upd(int a, int b) { for (;a<SZ;a+=(a&-a)) bit[a] += b; }\n    T sum(int a) { T res = 0; for (;a;a-=(a&-a)) res += bit[a]; return res; }\n};\n\nint N,Q,p[MX],a[MX],depth[MX];\n\nint co;\nvi child[MX], fake[MX], tmp;\nvector<array<int,3>> inc, qnum[MX];\nvpi qtree[MX], upd[MX];\nBIT<ll,MX> B[3];\n\nvl ans;\n\npi bound[MX];\n\nint ord;\nvoid genBound(int x) {\n    bound[x].f = ord++;\n    trav(t,child[x]) genBound(t);\n    bound[x].s = ord-1;\n}\n\nvoid dfs(int x) {\n    trav(y,qtree[x]) ans[y.s] -= B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] -= y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,y.s);\n    \n    B[0].upd(depth[x],a[x]); B[1].upd(depth[x],1);\n    a[x] += B[2].sum(MX-1)-B[2].sum(depth[x]-1);\n    trav(t,child[x]) dfs(t);\n    \n    trav(y,qtree[x]) ans[y.s] += B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] += y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,-y.s);\n}\n\nvoid calc() {\n    inc.clear();\n    F0R(i,2) B[i] = BIT<ll,MX>();\n    dfs(0);\n    F0R(i,co) {\n        qnum[i].clear();\n        qtree[i].clear();\n        upd[i].clear();\n    }\n    // deal with inc ... \n    trav(t,tmp) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    FOR(t,N,co) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    tmp.clear();\n    ord = 0; genBound(0);\n    FOR(i,1,co) assert(bound[i] != mp(0,0));\n    N = co; \n}\n\nbool above(int a, int b) {\n    return bound[a].f <= bound[b].f && bound[b].s <= bound[a].s;\n}\n\nvoid dfs0(int v, int d, int x) {\n    if (depth[v] > d) return;\n    if (v >= N) a[v] += x;\n    trav(t,fake[v]) dfs0(t,d,x);\n}\n\nll dfs1(int v, int d) {\n    if (depth[v] > d) return 0;\n    ll sum = (v >= N ? a[v] : 0);\n    trav(t,fake[v]) sum += dfs1(t,d);\n    return sum;\n}\n\nint main() {\n    setIO(); re(N,Q);\n    F0R(i,N) {\n        re(p[i],a[i]);\n        if (i) {\n            tmp.pb(p[i]); fake[p[i]].pb(i);\n            depth[i] = depth[p[i]]+1;\n        } else depth[i] = 1;\n    }\n    co = N; N = 0; calc();\n    // ps(N); F0R(i,N) ps(i,bound[i]); exit(0);\n    for (int i = 0; i < Q; i += BLOCK) {\n        FOR(j,i,min(i+BLOCK,Q)) {\n            int t; re(t);\n            if (t == 1) {\n                int v,d,x; re(v,d,x); d += depth[v];\n                if (v >= N) dfs0(v,d,x);\n                else {\n                    trav(t,tmp) if (above(v,t)) dfs0(t,d,x);\n                    inc.pb({v,d,x}); upd[v].pb({d,x});\n                }\n            } else if (t == 2) {\n                int v,d; re(v,d); d += depth[v];\n                ans.pb(0);\n                if (v >= N) {\n                    ans.back() += dfs1(v,d);\n                } else {\n                    // ps(\"HA\",t,v,d,tmp);\n                    trav(t,tmp) if (above(v,t)) {\n                        // ps(\"ZZ\",sz(ans),t,d);\n                        ans.back() += dfs1(t,d);\n                    }\n                    qtree[v].pb({d,sz(ans)-1});\n                    trav(t,inc) {\n                        if (above(t[0],v)) {\n                            qnum[v].pb({min(t[1],d),t[2],sz(ans)-1});\n                        } else if (above(v,t[0])) {\n                            qnum[t[0]].pb({min(t[1],d),t[2],sz(ans)-1});\n                        }\n                    }\n                }\n            } else {\n                re(p[co],a[co]); \n                depth[co] = depth[p[co]]+1;\n                fake[p[co]].pb(co);\n                if (p[co] < N && find(all(tmp),p[co]) == tmp.end()) {\n                    tmp.pb(p[co]);\n                }\n                co ++;\n            }\n        }\n        calc();\n        // ps(\"CLR\");\n    }\n    trav(t,ans) ps(t);\n    // F0R(i,N) ps(\"HA\",i,a[i]);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tLazySegmentTree seg(n+q);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[100000];\nvector<int> G[100000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[3000000],part[3000000];\n \nvoid init(){\n    int nn = 1;\n    while(nn < n) nn *= 2;\n    n = nn;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i,i + 1,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(500001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(min(u,u+d),max(u,u+d)+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(min(u,u+d),max(u,u+d)+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> L(n);\n\tvector<int> R(n);\n\tvector<int> depth(n);\n\tvector<int> depth2(n);\n\tint now = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\tL[u] = now;\n\t\ta[now] = aa[u];\n\t\tdepth[now] = d;\n\t\tnow++;\n\t\tfor (int v : g[u]) {\n\t\t\tdfs(v, d + 1);\n\t\t}\n\t\tR[u] = now;\n\t};\n\tdfs(0, 0);\n\n\tauto lb = [&](vector<int> &v, int val) {\n\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdict[i / S].push_back(depth[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(dict[i].begin(), dict[i].end());\n\t\tbits.emplace_back(dict[i].size());\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t}\n\n\tauto add = [&](int u, int k, int x) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\ta[l] += x;\n\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t};\n\n\tauto sum = [&](int u, int k) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\tlong long ret = 0;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\twhile (q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, d, x;\n\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\tadd(v, d, x);\n\t\t} else if (t == 2) {\n\t\t\tint v, d;\n\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\tprintf(\"ans:%lld\\n\", sum(v, d));\n\t\t} else {\n\t\t\tabort();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t}\n\tLazySegmentTree seg(n+q);\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int MN=400000;\n\nint N,Q;\nint A[MN];\nvint G[MN];\n\nint tt,tin[MN],tout[MN],dep[MN];\nvoid dfs(int v,int d){\n    tin[v]=tt++;\n    dep[v]=d;\n    for(auto u:G[v]){\n        dfs(u,d+1);\n    }\n    tout[v]=tt;\n}\n\nvoid task1(){\n    rep(i,Q){\n        tt=0;\n        dfs(0,0);\n        int t;\n        scanf(\"%lld\",&t);\n        if(t==1){\n            int v,d,x;\n            scanf(\"%lld%lld%lld\",&v,&d,&x);\n            rep(j,N){\n                if(dep[j]<dep[v]||dep[v]+d<dep[j])continue;\n                if(tin[v]<=tin[j]&&tin[j]<tout[v])A[j]+=x;\n            }\n        }\n        else if(t==2){\n            int v,d;\n            scanf(\"%lld%lld\",&v,&d);\n            int ans=0;\n            rep(j,N){\n                if(dep[j]<dep[v]||dep[v]+d<dep[j])continue;\n                if(tin[v]<=tin[j]&&tin[j]<tout[v])ans+=A[j];\n            }\n            printf(\"%lld\\n\",ans);\n        }\n        else{\n            int p,a;\n            scanf(\"%lld%lld\",&p,&a);\n            G[p].pb(N);\n            A[N]=a;\n            N++;\n        }\n    }\n}\n\nstruct LUZ{\n    int n;\n    vint dat,put;\n    void init(int N){\n        n=1;\n        while(n<N)n*=2;\n        dat.resize(2*n);\n        put.resize(2*n);\n    }\n    inline void push(int k,int l,int r){\n        dat[k]+=(r-l)*put[k];\n        if(k<n-1){\n            put[k*2+1]+=put[k];\n            put[k*2+2]+=put[k];\n        }\n        put[k]=0;\n    }\n    void add(int a,int b,int x){\n        add(a,b,x,0,0,n);\n    }\n    void add(int a,int b,int x,int k,int l,int r){\n        push(k,l,r);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            put[k]=x;\n            push(k,l,r);\n            return;\n        }\n        add(a,b,x,k*2+1,l,(l+r)/2);\n        add(a,b,x,k*2+2,(l+r)/2,r);\n        dat[k]=dat[k*2+1]+dat[k*2+2];\n    }\n    int query(int a,int b){\n        return query(a,b,0,0,n);\n    }\n    int query(int a,int b,int k,int l,int r){\n        push(k,l,r);\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&r<=b)return dat[k];\n        return query(a,b,k*2+1,l,(l+r)/2)+query(a,b,k*2+2,(l+r)/2,r);\n    }\n};\n\n\nvoid task2(){\n    LUZ seg;\n    seg.init(N+Q);\n    rep(i,N)seg.add(i,i+1,A[i]);\n    rep(i,Q){\n        int t;\n        scanf(\"%lld\",&t);\n        if(t==1){\n            int v,d,x;\n            scanf(\"%lld%lld%lld\",&v,&d,&x);\n            int r=v+d+1;\n            chmin(r,N);\n            seg.add(v,r,x);\n        }\n        else if(t==2){\n            int v,d;\n            scanf(\"%lld%lld\",&v,&d);\n            int r=v+d+1;\n            chmin(r,N);\n            printf(\"%lld\\n\",seg.query(v,r));\n        }\n        else{\n            int p,a;\n            scanf(\"%lld%lld\",&p,&a);\n            if(p+1!=N)return;\n            seg.add(N,N+1,a);\n            N++;\n        }\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&Q);\n    bool flag=true;\n    for(int i=0;i<N;i++){\n        int p;\n        scanf(\"%lld%lld\",&p,&A[i]);\n        if(p!=-1){\n            G[p].pb(i);\n        }\n        flag&=p+1==i;\n    }\n\n    if(N<=5000&&Q<=5000)task1();\n    if(flag)task2();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<long long> a(n);\n\tvector<long long> aa(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %lld\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = false;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (!has3) {\n\t\tvector<vector<int>> dict(N);\n\t\tvector<BIT<long long>> bits;\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], bar[i], baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t} else if (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<long long(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0LL;\n\t\t\t}\n\t\t\tlong long ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], min(now, foo[i] + bar[i] + 1), baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], min(now, foo[i] + bar[i] + 1)));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n\nstruct sum_seg{\n\tvector<long long int> lazy;\n\tvector<long long int> seg;\n\tint SS;\n\tsum_seg(){\n\t}\n\tvoid resize(int n){\n\t\tn *= 4;\n\t\tlazy.assign(n, 0);\n\t\tseg.assign(n, 0);\n\t\tSS = seg.size();\n\t}\n\tvoid update(int b,int rng){\n\t\tif (b * 2 + 2 < SS){\n\t\t\tlazy[b * 2 + 1] += lazy[b];\n\t\t\tlazy[b * 2 + 2] = lazy[b];\n\t\t}\n\t\tseg[b] += lazy[b]*rng;\n\t\tlazy[b] = 0;\n\t}\n\tinline void add(int b, int l, int r, int ll, int rr, int x){\n\t\tupdate(b,r-l);\n\t\tif (rr <= l || r <= ll){\n\t\t\treturn;\n\t\t}\n\t\tif (ll <= l&&r <= rr){\n\t\t\tlazy[b] += x;\n\t\t\tupdate(b,r-l);\n\t\t\treturn;\n\t\t}\n\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, rr, x);\n\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, rr, x);\n\t\tseg[b] = seg[b * 2 + 1]+ seg[b * 2 + 2];\n\t}\n\tinline int query(int b, int l, int r, int ll,int rr){\n\t\tupdate(b,r-l);\n\t\tif (r <= ll || ll < l)return -1;\n\t\tif (ll <= l&&r <= rr){\n\t\t\treturn seg[b];\n\t\t}\n\t\treturn query(b * 2 + 1, l, (l + r) >> 1, ll,rr) +query(b * 2 + 2, (l + r) >> 1, r, ll,rr);\n\t}\n}; \n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nvector<query> Q;\n\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nint star[MAX];\nint en[MAX];\nint dep[MAX];\nint child[MAX];\n\n\nint ord;\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nvector<int> seg[MAX * 4];\nsum_seg S[MAX * 4];\n\ninline void add(int b, int l, int r, int ll, int x){\n\tif (l <= ll&&ll < r){\n\t\tseg[b].push_back(x);\n\t\tif (l + 1 < r){\n\t\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, x);\n\t\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, x);\n\t\t}\n\t}\n}\ninline void init(int b, int l, int r){\n\tint siz = seg[b].size();\n\tsort(seg[b].begin(), seg[b].end());\n\tS[b].resize(siz);\n\tif (l + 1 < r){\n\t\tinit(b * 2 + 1, l, (l + r) >> 1);\n\t\tinit(b * 2 + 2, (l + r) >> 1, r);\n\t}\n}\ninline void add1(int b, int l, int r, int ll, int rr, int lll,int rrr,int x){\n\tif (r <= ll || rr <= l){\n\t\treturn;\n\t}\n\tif (ll <= l&&r <= rr){\n\t\tlll = upper_bound(seg[b].begin(), seg[b].end(), lll - 1) - seg[b].begin();\n\t\trrr = upper_bound(seg[b].begin(), seg[b].end(), rrr) - seg[b].begin();\n\t\tif (lll >= rrr)return;\n\t\tS[b].add(0, 0, seg[b].size(), lll, rrr, x);\n\t\treturn;\n\t}\n\tadd1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr, x);\n\tadd1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr, x);\n}\ninline long long int Q1(int b, int l, int r, int ll, int rr, int lll, int rrr){\n\tif (r <= ll || rr <= l)return 0;\n\tif (ll <= l&&r <= rr){\n\t\tlll = upper_bound(seg[b].begin(), seg[b].end(),lll-1) - seg[b].begin();\n\t\trrr = upper_bound(seg[b].begin(), seg[b].end(), rrr) - seg[b].begin();\n\t\tif (lll >= rrr)return 0;\n\t\treturn S[b].query(0, 0, seg[b].size(), lll, rrr);\n\t}\n\treturn Q1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr) + Q1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr);\n}\n\nlong long int cost[MAX];\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tcost[n] = ar;\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tfor (int i = 0; i < n; i++){\n\t\tadd(0, 0, n, dep[i],star[i]);\n\t}\n\tinit(0, 0, n);\n\tfor (int i = 0; i < n; i++){\n\t\tadd1(0, 0, n, dep[i], dep[i]+1,star[i],star[i]+1,cost[i]);\n\t}\n\tfor (int i = 0; i < Q.size(); i++){\n\t\tif (Q[i].ty == 1){\n\t\t\tadd1(0, 0, n, dep[Q[i].v], min(n, dep[Q[i].v] + Q[i].d + 1), star[Q[i].v], en[Q[i].v], Q[i].x);\n\t\t\tcontinue;\n\t\t}\n\t\tif (Q[i].ty == 2){\n\t\t\tlong long int QQ = Q1(0, 0, n, dep[Q[i].v], min(n, dep[Q[i].v] + Q[i].d + 1), star[Q[i].v], en[Q[i].v]);\n\t\t\tprintf(\"%lld\\n\", QQ);\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tputs(\"e\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(500001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\tassert(d>0);\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> L(n);\n\tvector<int> R(n);\n\tvector<int> depth(n);\n\tvector<int> depth2(n);\n\tint now = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\tL[u] = now;\n\t\ta[now] = aa[u];\n\t\tdepth[now] = d;\n\t\tnow++;\n\t\tfor (int v : g[u]) {\n\t\t\tdfs(v, d + 1);\n\t\t}\n\t\tR[u] = now;\n\t};\n\tdfs(0, 0);\n\n\tauto lb = [&](vector<int> &v, int val) {\n\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdict[i / S].push_back(depth[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(dict[i].begin(), dict[i].end());\n\t\tbits.emplace_back(dict[i].size());\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t}\n\n\tauto add = [&](int u, int k, int x) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\ta[l] += x;\n\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t};\n\n\tauto sum = [&](int u, int k) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\tlong long ret = 0;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\twhile (q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, d, x;\n\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\tadd(v, d, x);\n\t\t} else if (t == 2) {\n\t\t\tint v, d;\n\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t} else {\n\t\t\tabort();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\nbool vis[MAX];\ninline void dfs2(int b,int d=0){\n\tif (vis[b])exit(1);\n\tvis[b] = true;\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 500000;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nconst int BLOCK = 6000;\n// NlogN to recalculate \n// Q*(Q+1)/2 == NlogN\n\ntemplate<class T, int SZ> struct BIT {\n    T bit[SZ];\n    void upd(int a, int b) { ckmin(a,SZ-1); for (;a<SZ;a+=(a&-a)) bit[a] += b; }\n    T sum(int a) { ckmin(a,SZ-1); T res = 0; for (;a;a-=(a&-a)) res += bit[a]; return res; }\n};\n\nint N,Q,p[MX],depth[MX],a[MX];\n\nint co;\nvi child[MX], fake[MX], tmp;\nvector<array<int,3>> inc, qnum[MX];\nvpi qtree[MX], upd[MX];\nBIT<ll,MX> B[3];\n\nvl ans;\n\npi bound[MX];\n\nint ord;\nvoid genBound(int x) {\n    bound[x].f = ord++;\n    trav(t,child[x]) genBound(t);\n    bound[x].s = ord-1;\n}\n\nvoid dfs(int x) {\n    trav(y,qtree[x]) ans[y.s] -= B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] -= y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,y.s);\n    \n    B[0].upd(depth[x],a[x]); B[1].upd(depth[x],1);\n    a[x] += B[2].sum(MX-1)-B[2].sum(depth[x]-1);\n    trav(t,child[x]) dfs(t);\n    \n    trav(y,qtree[x]) ans[y.s] += B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] += y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,-y.s);\n}\n\nvoid calc() {\n    inc.clear();\n    F0R(i,2) B[i] = BIT<ll,MX>();\n    dfs(0);\n    F0R(i,co) {\n        qnum[i].clear();\n        qtree[i].clear();\n        upd[i].clear();\n    }\n    // deal with inc ... \n    trav(t,tmp) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    FOR(t,N,co) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    tmp.clear();\n    ord = 0; genBound(0);\n    FOR(i,1,co) assert(bound[i] != mp(0,0));\n    N = co; \n}\n\nbool above(int a, int b) {\n    return bound[a].f <= bound[b].f && bound[b].s <= bound[a].s;\n}\n\nvoid dfs0(int v, int d, int x) {\n    if (depth[v] > d) return;\n    if (v >= N) a[v] += x;\n    trav(t,fake[v]) dfs0(t,d,x);\n}\n\nll dfs1(int v, int d) {\n    if (depth[v] > d) return 0;\n    ll sum = (v >= N ? a[v] : 0);\n    trav(t,fake[v]) sum += dfs1(t,d);\n    return sum;\n}\n\nint main() {\n    setIO(); re(N,Q);\n    F0R(i,N) {\n        re(p[i],a[i]);\n        if (i) {\n            tmp.pb(p[i]); fake[p[i]].pb(i);\n            depth[i] = depth[p[i]]+1;\n        } else depth[i] = 1;\n    }\n    co = N; N = 0; calc();\n    for (int i = 0; i < Q; i += BLOCK) {\n        FOR(j,i,min(i+BLOCK,Q)) {\n            int t; re(t);\n            if (t == 1) {\n                int v,d,x; re(v,d,x); d += depth[v];\n                if (v >= N) dfs0(v,d,x);\n                else {\n                    trav(t,tmp) if (above(v,t)) dfs0(t,d,x);\n                    inc.pb({v,d,x}); upd[v].pb({d,x});\n                }\n            } else if (t == 2) {\n                int v,d; re(v,d); d += depth[v];\n                ans.pb(0);\n                if (v >= N) {\n                    ans.back() += dfs1(v,d);\n                } else {\n                    trav(t,tmp) if (above(v,t)) {\n                        // ps(\"ZZ\",sz(ans),t,d);\n                        ans.back() += dfs1(t,d);\n                    }\n                    qtree[v].pb({d,sz(ans)-1});\n                    trav(t,inc) {\n                        if (above(t[0],v)) {\n                            qnum[v].pb({min(t[1],d),t[2],sz(ans)-1});\n                        } else if (above(v,t[0])) {\n                            qnum[t[0]].pb({min(t[1],d),t[2],sz(ans)-1});\n                        }\n                    }\n                }\n            } else {\n                re(p[co],a[co]); \n                depth[co] = depth[p[co]]+1;\n                fake[p[co]].pb(co);\n                if (p[co] < N && find(all(tmp),p[co]) == tmp.end()) tmp.pb(p[co]);\n                co ++;\n            }\n        }\n        calc();\n    }\n    trav(t,ans) ps(t);\n    // F0R(i,N) ps(\"HA\",i,a[i]);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvector<int> v[111111];\nll d[111111];\n\nvoid dfs(int x,int y,int t,int c) {\n  if(c>t) return;\n  d[x]+=y;\n  rep(i,v[x].size()) dfs(v[x][i],y,t,c+1);\n}\n\nll dfs(int x,int t,int c) {\n  if(c>t) return 0;\n  ll sum=0;\n  rep(i,v[x].size()) sum+=dfs(v[x][i],t,c+1);\n  return sum+d[x];\n}\n\nvoid Main() {\n  int n,T;\n  cin >> n >> T;\n  rep(i,n) {\n    int x,y;\n    cin >> x >> y;\n    if(x!=-1) v[x].pb(i);\n    d[i]=y;\n  }\n  while(T--) {\n    int w,x,y,z;\n    cin >> w;\n    if(w==1) {\n      cin >> x >> y >> z;\n      dfs(x,z,y,0);\n    } else if(w==2) {\n      cin >> x >> y;\n      pr(dfs(x,y,0));\n    } else {\n      cin >> x >> y;\n      v[x].pb(n);\n      d[n++]=y;\n    }\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,q;\nint par[452521], a[452521];\nvi children[452521];\n\nvoid dfs1(int p,int d,int x){\n  a[p] += x;\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      dfs1(to,d,x);\n    }\n  }\n}\nll dfs2(int p,int d){\n  ll ret = a[p];\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      ret += dfs2(to,d);\n    }\n  }\n  return ret;\n}\n\nconst int MAX = 1<<19;\nll dat[2*MAX];\nll lazy[2*MAX];\nvoid push(int k,int a,int b){\n  if(lazy[k]!=0){\n    dat[k] += lazy[k] * (b-a);\n    if(k<MAX-1){\n      lazy[2*k+1] += lazy[k];\n      lazy[2*k+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n}\nvoid add(int l,int r,int v,int a,int b,int k){\n  push(k,a,b);\n  if(r<=a || b<=l){\n    return;\n  }\n  if(l<=a && b<=r){\n    lazy[k] += v;\n    push(k,a,b);\n  }else{\n    int m = (a+b)/2;\n    add(l,r,v,a,m,2*k+1);\n    add(l,r,v,m,b,2*k+2);\n    dat[k] = dat[2*k+1] + dat[2*k+2];\n  }\n}\nll sum(int l,int r,int a,int b,int k){\n  push(k,a,b);\n  if(r<=a || b<=l)return 0ll;\n  if(l<=a && b<=r){\n    return dat[k];\n  }else{\n    int m = (a+b)/2;\n    return sum(l,r,a,m,2*k+1) + sum(l,r,m,b,2*k+2);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&q);\n  REP(i,n)scanf(\"%d%d\",par+i,a+i);\n  if(n<=5000 && q<=5000){\n    // 170\n    // naive\n    REP(i,n)if(par[i]>=0){\n      children[par[i]].push_back(i);\n    }\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        dfs1(v,d,x);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",dfs2(v,d));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = ar;\n        n++;\n      }\n    }\n  }else{\n    // 240\n    REP(i,n)assert(par[i]+1 == i);\n    REP(i,n)dat[i+MAX-1] = a[i];\n    FORR(i,0,MAX-1)dat[i] = dat[2*i+1] + dat[2*i+2];\n    set<int> haschild;\n    int fn = n;\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        if(v < fn){\n          add(v,min(fn,v+d+1),x,0,MAX,0);\n          for(int xx : haschild){\n            int nd = xx - v;\n            if(nd >= 0 && nd < d){\n              for(int c : children[xx]){\n                dfs1(c,d-nd-1,x);\n              }\n            }\n          }\n        }else{\n          dfs1(v,d,x);\n        }\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        if(v < fn){\n          ll ans = sum(v,v+d+1,0,MAX,0);\n          for(int x : haschild){\n            int nd = x - v;\n            if(nd >= 0 && nd < d){\n              for(int c : children[x]){\n                ans += dfs2(c,d-nd-1);\n              }\n            }\n          }\n          printf(\"%lld\\n\",ans);\n        }else{\n          printf(\"%lld\\n\",dfs2(v,d));\n        }\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = ar;\n        if(pr < fn)haschild.insert(pr);\n        n++;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstruct SegmentTree\n{\n  vector< int64 > add, seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n\n  void update(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += 1LL * x;\n      return;\n    }\n    update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    seg[k] = seg[2 * k + 1] + seg[2 * k + 2];\n    int mid = (l + r) >> 1;\n    seg[k] += add[2 * k + 1] * (mid - l);\n    seg[k] += add[2 * k + 2] * (r - mid);\n  }\n\n  void update(int a, int b, int x)\n  {\n    update(a, b, x, 0, 0, sz);\n  }\n\n  int64 query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (0LL);\n    if(a <= l && r <= b) return (seg[k] + add[k] * (r - l));\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) +\n            query(a, b, 2 * k + 2, (l + r) >> 1, r) + add[k] * (min(b, r) - max(a, l)));\n  }\n\n  int64 query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nstruct SegmentTree2D\n{\n  vector< SegmentTree > add, seg;\n  vector< vector< int > > vs;\n  int sz;\n\n  SegmentTree2D(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    vs.resize(2 * sz - 1);\n  }\n\n  void set(int k, int height)\n  {\n    vs[k + sz - 1].push_back(height);\n  }\n\n  void build()\n  {\n    for(int k = sz - 1; k < vs.size(); k++) {\n      sort(begin(vs[k]), end(vs[k]));\n    }\n    for(int k = sz - 2; k >= 0; k--) {\n      vs[k].resize(vs[2 * k + 1].size() + vs[2 * k + 2].size());\n      merge(begin(vs[2 * k + 1]), end(vs[2 * k + 1]),\n            begin(vs[2 * k + 2]), end(vs[2 * k + 2]),\n            begin(vs[k]));\n    }\n    for(int k = 0; k < vs.size(); k++) {\n      add.emplace_back(SegmentTree(vs[k].size()));\n      seg.emplace_back(SegmentTree(vs[k].size()));\n    }\n  }\n\n  inline int lb(int k, int height)\n  {\n    return (lower_bound(begin(vs[k]), end(vs[k]), height) - begin(vs[k]));\n  }\n\n  int update(int a, int b, int Low, int High, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return (0);\n    } else if(a <= l && r <= b) {\n      int latte = lb(k, Low), malta = lb(k, High);\n      add[k].update(latte, malta, x);\n      return (malta - latte);\n    } else {\n      int p = update(a, b, Low, High, x, 2 * k + 1, l, (l + r) >> 1) +\n              update(a, b, Low, High, x, 2 * k + 2, (l + r) >> 1, r);\n      int q = lb(k, Low);\n      seg[k].update(q, q + p, x);\n      return (p);\n    }\n  }\n\n  void update(int a, int b, int Low, int High, int x)\n  {\n    update(a, b, Low, High, x, 0, 0, sz);\n  }\n\n  pair< int64, int > query(int a, int b, int low, int high, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return {0, 0};\n    if(a <= l && r <= b) {\n      int latte = lb(k, low), malta = lb(k, high);\n      auto vv = seg[k].query(latte, malta) + add[k].query(latte, malta);\n      return {vv, malta - latte};\n    }\n    auto s = query(a, b, low, high, 2 * k + 1, l, (l + r) >> 1);\n    auto t = query(a, b, low, high, 2 * k + 2, (l + r) >> 1, r);\n\n    int latte = s.second + t.second;\n    int malta = lb(k, low);\n    auto q = add[k].query(malta, latte + malta);\n    return {s.first + t.first + q, latte};\n  }\n\n  int64 query(int a, int b, int low, int high)\n  {\n    return (query(a, b, low, high, 0, 0, sz).first);\n  }\n};\n\n\nint N, Q, cost[800000];\nvector< int > g[800000];\nint A[800000], B[800000], C[800000], D[800000];\n\n\nint in[800000], out[800000], dep[800000], ptr;\n\n\nvoid rec(int idx, int depth = 0)\n{\n  dep[idx] = depth;\n  in[idx] = ptr++;\n  for(int to : g[idx]) rec(to, depth + 1);\n  out[idx] = ptr;\n}\n\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int par;\n    scanf(\"%d %d\", &par, &cost[i]);\n    if(~par) g[par].push_back(i);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    if(A[i] == 1) scanf(\"%d\", &D[i]);\n  }\n\n  rec(0);\n  SegmentTree2D tree(sz);\n  for(int i = 0; i < sz; i++) tree.set(in[i], dep[i]);\n  tree.build();\n  for(int i = 0; i < sz; i++) {\n    tree.update(in[i], in[i] + 1, dep[i], dep[i] + 1, cost[i]);\n  }\n\n  for(int i = 0; i < Q; i++) {\n    if(A[i] == 1) {\n      tree.update(in[B[i]], out[B[i]], dep[B[i]], dep[B[i]] + C[i] + 1, D[i]);\n    } else if(A[i] == 2) {\n      printf(\"%lld\\n\", tree.query(in[B[i]], out[B[i]], dep[B[i]], dep[B[i]] + C[i] + 1));\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 220; i++){\n\t\tdfs2(0);\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n\nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n\nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n\nint pos[MAXEMP];\nint sd[MAXEMP];\nll sval[4*MAXEMP]; int slazy[4*MAXEMP]; int scnt[4*MAXEMP];\n\nvoid spush(int x) {\n\tif(slazy[x]==0) return;\n\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\tslazy[x]=0;\n}\nvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\nvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\tif(l==r) {\n\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2;\n\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\tscalc(x);\n\t}\n\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n}\nvoid smod(int x,int l,int r,int L,int R,int BY) {\n\tif(L<=l&&r<=R) {\n\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\tslazy[x]+=BY;\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2;\n\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\tscalc(x);\n\t}\n\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n}\nll sget(int x,int l,int r,int L,int R) {\n\tif(L<=l&&r<=R) {\n\t\treturn sval[x];\n\t} else {\n\t\tspush(x);\n\t\tint m=l+(r-l)/2; ll ret=0;\n\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\treturn ret;\n\t}\n}\n\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\tREP(i,nemp) if(alive[i]) sborn(0,0,nemp-1,pos[i],oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n\nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\treturn sget(0,0,nemp-1,pos[idx],pos[idx]);\n}\n\nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn sget(0,0,nemp-1,l,r-1);\n}\n\nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n\nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\tsmod(0,0,nemp-1,pos[idx],pos[idx],by);\n}\n\nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn smod(0,0,nemp-1,l,r-1,by);\n}\n\nvoid update(int lid,int rid,int ld,int rd,int by) {\n\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n\nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\tsborn(0,0,nemp-1,pos[idx],oval[idx]);\n}\n\nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n\n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n\nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=rand()%i; REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=rand()%min(50,nemp),qd[i]=rand()%100,qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=rand()%min(50,nemp),qd[i]=rand()%100;\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=rand()%nemp,oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\tprintf(\"%.9lf\\n\",double(clock() - begin) / CLOCKS_PER_SEC);\n\t}\n}\n\nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, Q;\n  cin >> N >> Q;\n  if(N > 5000 || Q > 500) return 0;\n  vector<vint> graph(N);\n  vint a(N);\n  rep(i, N) {\n    int p;\n    cin >> p >> a[i];\n    if(~p) graph[p].push_back(i);\n  }\n  while(Q--) {\n    int w, x, y, z;\n    cin >> w >> x >> y;\n    if(w == 1) {\n      cin >> z;\n      queue<pint> que;\n      que.emplace(x, y);\n      while(!que.empty()) {\n\tint v, d; tie(v, d) = que.front(); que.pop();\n\ta[v] += z;\n\tif(d == 0) continue;\n\tfor(int to : graph[v]) {\n\t  que.emplace(to, d-1);\n\t}\n      }\n    } else if(w == 2) {\n      int sum = 0;\n      queue<pint> que;\n      que.emplace(x, y);\n      while(!que.empty()) {\n\tint v, d; tie(v, d) = que.front(); que.pop();\n\tsum += a[v];\n\tif(d == 0) continue;\n\tfor(int to : graph[v]) {\n\t  que.emplace(to, d-1);\n\t}\n      }\n      cout << sum << endl;\n    } else if(w == 3) {\n      graph[x].push_back(N++);\n      graph.push_back(vint());\n      a.push_back(y);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntypedef long long int64;\n\n\nconst int backet = 2000;\n\nint N, Q;\nint64 C[800000];\nvector< int > g[800000];\nint T[400000], X[400000], Y[400000], Z[400000];\nbool live[800000];\n\nint in[800000], out[800000], ptr;\n\n\nvector< int > upquery[800000];\n\nvoid dfs(int idx)\n{\n  in[idx] = ptr++;\n  for(int to : g[idx]) dfs(to);\n  out[idx] = ptr;\n}\n\n\nint64 lazy[800001], add, sub;\n\nvoid update(int idx, int depth = 0)\n{\n  for(auto &q : upquery[idx]) {\n    add += Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] += Z[q];\n  }\n  sub += lazy[depth];\n  C[idx] += add - sub;\n  for(auto &to : g[idx]) {\n    if(!live[to]) update(to, depth + 1);\n  }\n  sub -= lazy[depth];\n  for(auto &q : upquery[idx]) {\n    add -= Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] -= Z[q];\n  }\n  upquery[idx].clear();\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if(~a) g[a].push_back(i);\n    C[i] = b;\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &T[i], &X[i], &Y[i]);\n    if(T[i] == 1) scanf(\"%d\", &Z[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(T[i] == 3) {\n      live[sz] = true;\n      g[X[i]].push_back(sz);\n      C[sz] = Y[i];\n      ++sz;\n    }\n  }\n\n  dfs(0);\n\n  sz = N;\n  for(int i = 0; i < Q; i += backet) {\n    int left = i, right = min(Q, i + backet);\n\n\n    for(int j = left; j < right; j++) {\n      if(T[j] == 1) upquery[X[j]].push_back(j);\n    }\n    update(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tint n,id;\n\tll val[2*SZ]; int lazy[2*SZ]; int cnt[2*SZ];\n\n\tinline void push(int x) {\n\t\tif(lazy[x]==0) return;\n\t\tapply(2*x,lazy[x]);\n\t\tapply(2*x+1,lazy[x]);\n\t\tlazy[x]=0;\n\t}\n\tinline void calc(int x) {\n\t\tcnt[x]=cnt[2*x]+cnt[2*x+1];\n\t\tval[x]=val[2*x]+val[2*x+1]+(ll)cnt[x]*lazy[x];\n\t}\n\tinline void apply(int x,int by) {\n\t\tval[x]+=(ll)by*cnt[x];\n\t\tlazy[x]+=by;\n\t}\n\tinline void build(int _id,int _n,int* sval,int* scnt) {\n\t\tid=_id; n=_n; assert(n<=SZ);\n\t\tREP(i,n) val[n+i]=scnt[i]?sval[i]:0,cnt[n+i]=scnt[i];\n\t\tfor(int i=n-1;i>0;--i) calc(i);\n\t}\n\tvoid incrange(int l,int r,int by) {\n\t\t//printf(\"%d: incrange(%d,%d,%d)\\n\",id,l,r,by);\n\t\tl+=n,r+=n;\n\t\tint oldl=l,oldr=r;\n\t\t{ int h=0; while((l>>h)>1) ++h; for(;h>0;--h) push(l>>h); }\n\t\t{ int h=0; while((r>>h)>1) ++h; for(;h>0;--h) push(r>>h); }\n\t\tfor(++r;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) apply(l++,by);\n\t\t\tif(r&1) apply(--r,by);\n\t\t}\n\t\tfor(int idx=oldl>>1;idx>0;idx>>=1) calc(idx);\n\t\tfor(int idx=oldr>>1;idx>0;idx>>=1) calc(idx);\n\t\t//if(id==1) { FOR(i,1,2*n) printf(\"\\t%d: val=%lld lazy=%d cnt=%d\\n\",i,val[i],lazy[i],cnt[i]); }\n\t}\n\tvoid setpoint(int idx,int sval) {\n\t\t//printf(\"%d: setpoint(%d,%d)\\n\",id,idx,sval);\n\t\tidx+=n;\n\t\t{ int h=0; while((idx>>h)>1) ++h; for(;h>0;--h) push(idx>>h); }\n\t\tcnt[idx]=1,val[idx]=sval;\n\t\tfor(idx>>=1;idx>0;idx>>=1) calc(idx);\n\t}\n\tll get(int l,int r) {\n\t\t//printf(\"%d: get(%d,%d)\\n\",id,l,r);\n\t\tl+=n,r+=n;\n\t\t{ int h=0; while((l>>h)>1) ++h; for(;h>0;--h) push(l>>h); }\n\t\t{ int h=0; while((r>>h)>1) ++h; for(;h>0;--h) push(r>>h); }\n\t\tll ret=0;\n\t\tfor(++r;l<r;l>>=1,r>>=1) {\n\t\t\tif(l&1) ret+=val[l++];\n\t\t\tif(r&1) ret+=val[--r];\n\t\t}\n\t\t//printf(\"=%lld\\n\",ret);\n\t\treturn ret;\n\t}\n} S;\nS s[MAXB];\n\n\npair<int,int> tmp[SZ];\nint tval[SZ],tcnt[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t\tREP(j,cnt) tval[j]=oval[tmp[j].second],tcnt[j]=alive[tmp[j].second]?1:0; s[i/SZ].build(i/SZ,min(SZ,nemp-i),tval,tcnt);\n\t}\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n \nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\treturn s[pos[idx]/SZ].get(pos[idx]%SZ,pos[idx]%SZ);\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].get(l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n \nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\ts[pos[idx]/SZ].incrange(pos[idx]%SZ,pos[idx]%SZ,by);\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].incrange(l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].setpoint(pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=0,qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=0,qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\t//printf(\"%d %d\\n\",n,nq);\n\t\t//REP(i,n) printf(\"%d %d\\n\",par[i],oval[i]);\n\t\t//REP(i,nq) if(qt[i]==1) printf(\"%d %d %d %d\\n\",qt[i],qemp[i],qd[i],qby[i]); else if(qt[i]==2) printf(\"%d %d %d\\n\",qt[i],qemp[i],qd[i]); else if(qt[i]==3) printf(\"%d %d %d\\n\",qt[i],par[qemp[i]],oval[qemp[i]]);\n\t\t//REP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]); exit(0);\n\t\tprintf(\"%.9lf\\n\",double(clock() - begin) / CLOCKS_PER_SEC);\n\t}\n}\n \nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\t//init();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[400000];\nvector<int> G[400000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\nint all[3000000],part[3000000];\n \nvoid init(){\n    n = 524288;\n}\n \nvoid add(int a,int b,int x,int k,int l,int r){\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n        all[k] += x;\n        return;\n    }\n    part[k] += (min(b,r) - max(a,l)) * x;\n    add(a,b,x,k * 2 + 1,l,(l + r) / 2);\n    add(a,b,x,k * 2 + 2,(l + r) / 2,r);\n}\n \nint get(int a,int b,int k,int l,int r){\n    int res = 0;\n    if(a <= l && r <= b) return all[k] * (r - l) + part[k];\n    if(b <= l || r <= a) return 0;\n    res += all[k] * (min(b,r) - max(a,l));\n    res += get(a,b,k * 2 + 1,l,(l + r) / 2);\n    res += get(a,b,k * 2 + 2,(l + r) / 2,r);\n    return res;\n}\n\nsigned main(){\n\tcin >> n >> q;\n\tbool flag = true;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p + 1 != i) flag = false;\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tif(n <= 5000 && q <= 5000){\n\t\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\t}else if(flag){\n\t\tint num = n;\n\t\tinit();\n\t\tfor(int i = 0;i < num;i++) add(i,i + 1,a[i],0,0,n);\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t == 1){\n\t\t\t\tint v,d,x;\n\t\t\t\tcin >> v >> d >> x;\n\t\t\t\tadd(v,v + d + 1,x,0,0,n);\n\t\t\t}else if(t == 2){\n\t\t\t\tint v,d;\n\t\t\t\tcin >> v >> d;\n\t\t\t\tcout << get(v,v + d + 1,0,0,n) << endl;\n\t\t\t}else{\n\t\t\t\tint pr,ar;\n\t\t\t\tcin >> pr >> ar;\n\t\t\t\tadd(num,num + 1,ar,0,0,n);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V> class SegTree_3 {\npublic:\n\tint NV;\n\tvector<V> tot,each;\n\tvoid init(int count) {\n\t\tNV=1;\n\t\twhile((1<<NV)<=count*2) NV++;\n\t\ttot.resize(NV*2,0);\n\t\teach.resize(NV*2,0);\n\t};\n\t\n\tll getval(int x,int y,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(r<=x || y<=l) return 0;\n\t\tif(x<=l && r<=y) return tot[k];\n\t\treturn getval(x,y,l,(l+r)/2,k*2)+getval(x,y,(l+r)/2,r,k*2+1)+each[k]*(r-l);\n\t}\n\t\n\tvoid update(int x,int y, V v,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(l>=r) return;\n\t\tif(x<=l && r<=y) {\n\t\t\teach[k]+=v;\n\t\t\ttot[k]+=v*(r-l);\n\t\t}\n\t\telse if(l < y && x < r) {\n\t\t\tupdate(x,y,v,l,(l+r)/2,k*2);\n\t\t\tupdate(x,y,v,(l+r)/2,r,k*2+1);\n\t\t\ttot[k]=tot[2*k]+tot[2*k+1]+each[k]*(r-l);\n\t\t}\n\t}\n};\nSegTree_3<ll> bit[505050];\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tSegTree_3<ll> st;\n\t\tst.init(1<<20);\n\t\tFOR(i,N) st.update(i+1,i+2,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tst.update(V[i]+1,V[i]+D[i]+2,X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<st.getval(V[i]+1,V[i]+D[i]+2)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tst.update(N+1,N+2,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,q;\nint par[452521], a[452521];\nvi children[452521];\n\nvoid dfs1(int p,int d,int x){\n  a[p] += x;\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      dfs1(to,d,x);\n    }\n  }\n}\nll dfs2(int p,int d){\n  ll ret = a[p];\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      ret += dfs2(to,d);\n    }\n  }\n  return ret;\n}\n\nconst int MAX = 1<<19;\nll dat[2*MAX];\nll lazy[2*MAX];\nvoid push(int k){\n  if(lazy[k]!=0){\n    dat[k] += lazy[k];\n    if(k<MAX-1){\n      lazy[2*k+1] += lazy[k];\n      lazy[2*k+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n}\nvoid add(int l,int r,int v,int a,int b,int k){\n  push(k);\n  if(r<=a || b<=l)return;\n  if(l<=a && b<=r){\n    lazy[k] += v;\n  }else{\n    int m = (a+b)/2;\n    add(l,r,v,a,m,2*k+1);\n    add(l,r,v,m,b,2*k+2);\n  }\n}\nll sum(int l,int r,int a,int b,int k){\n  push(k);\n  if(r<=a || b<=l)return 0ll;\n  if(l<=a && b<=r){\n    return dat[k];\n  }else{\n    int m = (a+b)/2;\n    return sum(l,r,a,m,2*k+1) + sum(l,r,m,b,2*k+2);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&q);\n  REP(i,n)scanf(\"%d%d\",par+i,a+i);\n  if(n<=5000 && q<=5000){\n    // 170\n    // naive\n    REP(i,n)if(par[i]>=0){\n      children[par[i]].push_back(i);\n    }\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        dfs1(v,d,x);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",dfs2(v,d));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = ar;\n        n++;\n      }\n    }\n  }else{\n    // 240\n    REP(i,n)assert(par[i]+1 == i);\n    REP(i,n)dat[i+MAX-1] = a[i];\n    FORR(i,0,MAX-1)dat[i] = dat[2*i+1] + dat[2*i+2];\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        add(v,v+d+1,x,0,MAX,0);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",sum(v,v+d+1,0,MAX,0));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        add(n,n+1,ar,0,MAX,0);\n        n++;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[400001];\nint par[400001];\nint a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nint h[5001];\nvi child[5001];\nvoid dfs(int u)\n{\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tint cnt = n;\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tint pp; cin>>pp;\n\t\t\t\tint x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\tint p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(int j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tLazySegmentTree seg(400001);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\tassert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tint cnt = n;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tint z; cin>>z;\n\t\t\tassert(z==cnt-1);\n\t\t\tint v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tint u; cin>>u;\n\t\tint d; cin>>d;\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\nstd::vector<int32_t> parent[100000];\nstd::vector<int32_t> child[100000];\nint32_t V[100000];\nvoid add(int32_t i, int32_t d, int32_t v)\n{\n\tV[i] += v;\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tadd(c, d - 1, v);\n\t\t}\n\t}\n}\nint64_t sum(int32_t i, int32_t d)\n{\n\tint64_t res = V[i];\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tres += sum(c, d - 1);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tif ((int64_t)(N*Q)>1000000000) {\n\t\treturn 0;\n\t}\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tint p, v;\n\t\tin >> p >> V[i];\n\t\tif (p != -1) { parent[i].push_back(p); child[p].push_back(i); }\n\t}\n\tfor (int32_t loop = 0; loop < Q; ++loop)\n\t{\n\t\tint type;\n\t\tin >> type;\n\t\tif (type == 1) {\n\t\t\tint p, d, v;\n\t\t\tin >> p >> d >> v;\n\t\t\tadd(p, d, v);\n\t\t}\n\t\telse if (type == 2) {\n\t\t\tint p, d;\n\t\t\tin >> p >> d;\n#ifdef _DEBUG\n\t\t\tout << \"OUTPUT:\";\n#endif\n\t\t\tout << sum(p, d) << endl;\n\t\t}\n\t\telse if (type == 3) {\n\t\t\tint p;\n\t\t\tin >> p >> V[N];\n\t\t\tif (p != -1) { parent[N].push_back(p); child[p].push_back(N); }\n\t\t\t++N;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t ask(const std::string& s) {\n#ifdef _DEBUG\n#endif\n\tint32_t t;\n\tout << \"? \" << s << std::endl;\n\tin >> t;\n\treturn t;\n}\n\nconstexpr int32_t N = 200;//頂点数\nstd::vector<int32_t> graph[N];//木\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t t; in >> t;\n\tstd::string s(N,'0');\n\tint32_t count = 0;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\ts[i] = '1';\n\t\tfor (int32_t j = i+1; j < N; ++j)\n\t\t{\n\t\t\ts[j] = '1';\n\n\t\t\tt = ask(s);\n\t\t\tif (t == 1) {\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\t++count;\n\t\t\t\tif (count >= N-1) {\n\t\t\t\t\tgoto res_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts[j] = '0';\n\t\t}\n\t\ts[i] = '0';\n\t}\nres_out:\n\tout << '!';\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tfor (auto& j : graph[i]) {\n\t\t\tout << \" (\" << i << ',' << j << ')';\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = true;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = false;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[1300005], fw2[1300005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tassert(N <= 400000);\n\tassert(Q <= 50000);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, min(N - 1, a + v)));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(500001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\td=max(d,0LL);\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V> class SegTree_3 {\npublic:\n\tint NV;\n\tvector<V> tot,each;\n\tvoid init(int count) {\n\t\tNV=1;\n\t\twhile((1<<NV)<=count*2) NV++;\n\t\ttot.resize(NV*2,0);\n\t\teach.resize(NV*2,0);\n\t};\n\t\n\tll getval(int x,int y,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(r<=x || y<=l) return 0;\n\t\tif(x<=l && r<=y) return tot[k];\n\t\treturn getval(x,y,l,(l+r)/2,k*2)+getval(x,y,(l+r)/2,r,k*2+1)+each[k]*(r-l);\n\t}\n\t\n\tvoid update(int x,int y, V v,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(l>=r) return;\n\t\tif(x<=l && r<=y) {\n\t\t\teach[k]+=v;\n\t\t\ttot[k]+=v*(r-l);\n\t\t}\n\t\telse if(l < y && x < r) {\n\t\t\tupdate(x,y,v,l,(l+r)/2,k*2);\n\t\t\tupdate(x,y,v,(l+r)/2,r,k*2+1);\n\t\t\ttot[k]=tot[2*k]+tot[2*k+1]+each[k]*(min(y,r)-max(x,l));\n\t\t}\n\t}\n};\nSegTree_3<ll> bit[505050];\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tSegTree_3<ll> st;\n\t\tst.init(1<<20);\n\t\tFOR(i,N) st.update(i+1,i+2,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tst.update(V[i]+1,V[i]+D[i]+2,X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<st.getval(V[i]+1,V[i]+D[i]+2)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tst.update(N+1,N+2,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tassert(0);\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[1300005], fw2[1300005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tassert(N <= 400000);\n\tassert(Q <= 50000);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, (long long)(a - 1) * v);\n\tupd2(b + 1, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 500000;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nconst int BLOCK = 6000;\n// NlogN to recalculate \n// Q*(Q+1)/2 == NlogN\n\ntemplate<class T, int SZ> struct BIT {\n    T bit[SZ];\n    void upd(int a, int b) { for (;a<SZ;a+=(a&-a)) bit[a] += b; }\n    T sum(int a) { T res = 0; for (;a;a-=(a&-a)) res += bit[a]; return res; }\n};\n\nint N,Q,p[MX],a[MX],depth[MX];\n\nint co;\nvi child[MX], fake[MX], tmp;\nvector<array<int,3>> inc, qnum[MX];\nvpi qtree[MX], upd[MX];\nBIT<ll,MX> B[3];\n\nvl ans;\n\npi bound[MX];\n\nint ord;\nvoid genBound(int x) {\n    bound[x].f = ord++;\n    trav(t,child[x]) genBound(t);\n    bound[x].s = ord-1;\n}\n\nvoid dfs(int x) {\n    trav(y,qtree[x]) ans[y.s] -= B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] -= y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,y.s);\n    \n    B[0].upd(depth[x],a[x]); B[1].upd(depth[x],1);\n    a[x] += B[2].sum(MX-1)-B[2].sum(depth[x]-1);\n    trav(t,child[x]) dfs(t);\n    \n    trav(y,qtree[x]) ans[y.s] += B[0].sum(y.f);\n    trav(y,qnum[x]) ans[y[2]] += y[1]*B[1].sum(y[0]);\n    trav(y,upd[x]) B[2].upd(y.f,-y.s);\n}\n\nvoid calc() {\n    inc.clear();\n    F0R(i,2) B[i] = BIT<ll,MX>();\n    dfs(0);\n    F0R(i,co) {\n        qnum[i].clear();\n        qtree[i].clear();\n        upd[i].clear();\n    }\n    // deal with inc ... \n    trav(t,tmp) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    FOR(t,N,co) {\n        child[t].insert(child[t].end(),all(fake[t]));\n        fake[t].clear();\n    }\n    tmp.clear();\n    ord = 0; genBound(0);\n    FOR(i,1,co) assert(bound[i] != mp(0,0));\n    N = co; \n}\n\nbool above(int a, int b) {\n    return bound[a].f <= bound[b].f && bound[b].s <= bound[a].s;\n}\n\nvoid dfs0(int v, int d, int x) {\n    if (depth[v] > d) return;\n    if (v >= N) a[v] += x;\n    trav(t,fake[v]) dfs0(t,d,x);\n}\n\nll dfs1(int v, int d) {\n    if (depth[v] > d) return 0;\n    ll sum = (v >= N ? a[v] : 0);\n    trav(t,fake[v]) sum += dfs1(t,d);\n    return sum;\n}\n\nint main() {\n    setIO(); re(N,Q);\n    F0R(i,N) {\n        re(p[i],a[i]);\n        if (i) {\n            tmp.pb(p[i]); fake[p[i]].pb(i);\n            depth[i] = depth[p[i]]+1;\n        } else depth[i] = 1;\n    }\n    co = N; N = 0; calc();\n    // ps(N); F0R(i,N) ps(i,bound[i]); exit(0);\n    for (int i = 0; i < Q; i += BLOCK) {\n        FOR(j,i,min(i+BLOCK,Q)) {\n            int t; re(t);\n            if (t == 1) {\n                int v,d,x; re(v,d,x); d += depth[v];\n                if (v >= N) dfs0(v,d,x);\n                else {\n                    trav(t,tmp) if (above(v,t)) dfs0(t,d,x);\n                    inc.pb({v,d,x}); upd[v].pb({d,x});\n                }\n            } else if (t == 2) {\n                int v,d; re(v,d); d += depth[v];\n                ans.pb(0);\n                if (v >= N) {\n                    ans.back() += dfs1(v,d);\n                } else {\n                    // ps(\"HA\",t,v,d,tmp);\n                    trav(t,tmp) if (above(v,t)) {\n                        // ps(\"ZZ\",sz(ans),t,d);\n                        ans.back() += dfs1(t,d);\n                    }\n                    qtree[v].pb({d,sz(ans)-1});\n                    trav(t,inc) {\n                        if (above(t[0],v)) {\n                            qnum[v].pb({min(t[1],d),t[2],sz(ans)-1});\n                        } else if (above(v,t[0])) {\n                            qnum[t[0]].pb({min(t[1],d),t[2],sz(ans)-1});\n                        }\n                    }\n                }\n            } else {\n                re(p[co],a[co]); \n                depth[co] = depth[p[co]]+1;\n                fake[p[co]].pb(co);\n                if (p[co] < N && find(all(tmp),p[co]) == tmp.end()) {\n                    tmp.pb(p[co]);\n                }\n                co ++;\n            }\n        }\n        calc();\n        // ps(\"CLR\");\n    }\n    trav(t,ans) ps(t);\n    // F0R(i,N) ps(\"HA\",i,a[i]);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[500005], fw2[500005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tfor (int i = p; i <= 500000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\treturn query(b) * b + query2(b) - (query(a) * a + query2(a));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(1000001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntypedef long long int64;\n\n\nconst int backet = 500;\n\nint N, Q;\nint64 C[800000];\nvector< int > g[800000];\nint T[400000], X[400000], Y[400000], Z[400000];\nbool live[800000];\n\nint in[800000], out[800000], ptr;\n\n\nvector< int > upquery[800000];\n\nvoid dfs(int idx)\n{\n  in[idx] = ptr++;\n  for(int to : g[idx]) dfs(to);\n  out[idx] = ptr;\n}\n\n\nint64 lazy[800001], add, sub;\n\nvoid update(int idx, int depth = 0)\n{\n  for(auto &q : upquery[idx]) {\n    add += Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] += Z[q];\n  }\n  sub += lazy[depth];\n  C[idx] += add - sub;\n  for(auto &to : g[idx]) {\n    if(!live[to]) update(to, depth + 1);\n  }\n  sub -= lazy[depth];\n  for(auto &q : upquery[idx]) {\n    add -= Z[q];\n    lazy[min(800000, depth + Y[q] + 1)] -= Z[q];\n  }\n  upquery[idx].clear();\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  for(int i = 0; i < N; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    if(~a) g[a].push_back(i);\n    C[i] = b;\n  }\n\n  for(int i = 0; i < Q; i++) {\n    scanf(\"%d %d %d\", &T[i], &X[i], &Y[i]);\n    if(T[i] == 1) scanf(\"%d\", &Z[i]);\n  }\n\n  int sz = N;\n  for(int i = 0; i < Q; i++) {\n    if(T[i] == 3) {\n      live[sz] = true;\n      g[X[i]].push_back(sz);\n      C[sz] = Y[i];\n      ++sz;\n    }\n  }\n\n  dfs(0);\n\n  sz = N;\n  for(int i = 0; i < Q; i += backet) {\n    int left = i, right = min(Q, i + backet);\n\n\n    for(int j = left; j < right; j++) {\n      if(T[j] == 1) upquery[X[j]].push_back(j);\n    }\n    update(0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[1300005], fw2[1300005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 1300000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(long long a, long long b) {\n\ta--;\n\tb = min(b, (long long)N - 1);\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\nint deg[MAX];\n\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < deg[b]; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\t//child[b] += child[go];\n\t}\n\t//en[b] = ord;\n\t//child[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t\tdeg[p]++;\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tif (pr >= n)exit(1);\n\t\t\tv[pr].push_back(n);\n\t\t\tdeg[pr]++;\n\t\t\tn++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 120; i++){\n\t\tdfs2(0);\n\t}\n\treturn 0;\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q, A[500005];\nlong long fw[900005], fw2[900005];\nvector<int> children[500005];\n\nlong long dfs(int x, int l, int a) {\n\tA[x] += a;\n\tlong long ans = A[x];\n\tif (l == 0) return ans;\n\tfor (int i = 0; i < children[x].size(); i++) ans += dfs(children[x][i], l - 1, a);\n\treturn ans;\n}\n\nvoid upd(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw[i] += v;\n}\n\nlong long query(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw[i];\n\treturn ans;\n}\n\nvoid upd2(int p, long long v) {\n\tp++;\n\tif (p == 0) return;\n\tfor (int i = p; i <= 900000; i += (i & (-i))) fw2[i] += v;\n}\n\nlong long query2(int p) {\n\tp++;\n\tlong long ans = 0;\n\tfor (int i = p; i > 0; i-= (i & (-i))) ans += fw2[i];\n\treturn ans;\n}\n\nvoid update(int a, int b, int v) {\n\tupd(a, v);\n\tupd(b + 1, -v);\n\tupd2(a, -(long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(a - 1) * v);\n\tupd2(b + 1, (long long)(b - a + 1) * v);\n}\n\nlong long sum(int a, int b) {\n\ta--;\n\treturn query(b) * b + query2(b) - ((a == -1) ? 0 : (query(a) * a + query2(a)));\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tbool fail = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, s;\n\t\tscanf(\"%d%d\", &p, &s);\n\t\tupdate(i, i, s);\n\t\tif (p != -1) children[p].push_back(i);\n\t\tA[i] = s;\n\t\tif (i != p + 1) fail = 1;\n\t}\n\tif (N <= 5000 && Q <= 5000) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tdfs(a, v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", dfs(a, v, 0));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tchildren[a].push_back(N);\n\t\t\t\tA[N] = s;\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t} else if (!fail) {\n\t\twhile (Q--) {\n\t\t\tint q;\n\t\t\tscanf(\"%d\", &q);\n\t\t\tif (q == 1) {\n\t\t\t\tint a, v, x;\n\t\t\t\tscanf(\"%d%d%d\", &a, &v, &x);\n\t\t\t\tupdate(a, a + v, x);\n\t\t\t} else if (q == 2) {\n\t\t\t\tint a, v;\n\t\t\t\tscanf(\"%d%d\", &a, &v);\n\t\t\t\tprintf(\"%lld\\n\", sum(a, a + v));\n\t\t\t} else {\n\t\t\t\tint a, s;\n\t\t\t\tscanf(\"%d%d\", &a, &s);\n\t\t\t\tassert(a == N - 1);\n\t\t\t\tupdate(N, N, s);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 2) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<int> a(n);\n\tvector<int> aa(n);\n\tvector<vector<int>> dict(N);\n\tvector<BIT<long long>> bits;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %d\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> L(n);\n\tvector<int> R(n);\n\tvector<int> depth(n);\n\tvector<int> depth2(n);\n\tint now = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\tL[u] = now;\n\t\ta[now] = aa[u];\n\t\tdepth[now] = d;\n\t\tnow++;\n\t\tfor (int v : g[u]) {\n\t\t\tdfs(v, d + 1);\n\t\t}\n\t\tR[u] = now;\n\t};\n\tdfs(0, 0);\n\n\tauto lb = [&](vector<int> &v, int val) {\n\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdict[i / S].push_back(depth[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tsort(dict[i].begin(), dict[i].end());\n\t\tbits.emplace_back(dict[i].size());\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t}\n\n\tauto add = [&](int u, int k, int x) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\ta[l] += x;\n\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t};\n\n\tauto sum = [&](int u, int k) {\n\t\tint l = L[u];\n\t\tint r = R[u];\n\t\tint bottom = depth[l];\n\t\tint top = depth[l] + k + 1;\n\t\tlong long ret = 0;\n\t\twhile (l < r) {\n\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\tl += S;\n\t\t\t} else {\n\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\twhile (q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, d, x;\n\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\tadd(v, d, x);\n\t\t} else if (t == 2) {\n\t\t\tint v, d;\n\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t} else {\n\t\t\tabort();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n//http://kagamiz.hatenablog.com/entry/2012/12/18/220849から引用 (ごめんなさい！！！)\nstatic const int MAX_SIZE = 1 << 20; //segment tree のサイズ。\n\ntypedef long long Int;\ntypedef long long ll;\nInt all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nInt sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nint n, q;\nvector<int> et[500000];\nint a[500000];\n\nvoid dfsAdd(int id, int remDep, int val) {\n\ta[id] += val;\n\tif (remDep == 0) return;\n\t\n\tfor (int i = 0; i < et[id].size(); i++) {\n\t\tdfsAdd(et[id][i], remDep - 1, val);\n\t}\n}\n\nint dfsSum(int id, int remDep) {\n\t//cout << \"id = \" << id << endl;\n\t//cout << \"et[id].size() = \" << et[id].size() << endl;\n\tif (remDep == 0) return a[id];\n\t\n\tint ret = 0;\n\tfor (int i = 0; i < et[id].size(); i++) {\n\t\tret += dfsSum(et[id][i], remDep - 1);\n\t}\n\treturn ret + a[id];\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> q;\n\tfor (i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x >> a[i];\n\t\tif (x != -1) { et[x].push_back(i); }\n\t}\n\t\n\tif (n <= 5000 && q <= 5000) {\t//subtask1\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tint type, x, y, z;\n\t\t\tcin >> type;\n\t\t\t\n\t\t\tif (type == 1) {\n\t\t\t\tcin >> x >> y >> z;\n\t\t\t\tdfsAdd(x, y, z);\n\t\t\t}\n\t\t\telse if (type == 2) {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tcout << dfsSum(x, y) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tet[x].push_back(n);\n\t\t\t\ta[n] = y;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\t//subtask2\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tint type, x, y, z;\n\t\t\tcin >> type;\n\t\t\t\n\t\t\tif (type == 1) {\n\t\t\t\tcin >> x >> y >> z;\n\t\t\t\tadd(x, x + y + 1, z);\n\t\t\t}\n\t\t\telse if (type == 2) {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tcout << sum(x, x + y + 1) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> x >> y;\n\t\t\t\t//a[n] = y;\n\t\t\t\tadd(n, n + 1, y);\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\tdfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\t/*init();\n\t\tfor (int j = 0; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,q,a[100000];\nvector<int> G[100000];\n\nvoid add(int v,int d,int x){\n\ta[v] += x;\n\tif(d == 0) return;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tadd(G[v][i],d - 1,x);\n\t}\n}\n\nint sum(int v,int d){\n\tint s = a[v];\n\tif(d == 0) return s;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\ts += sum(G[v][i],d - 1);\n\t}\n\treturn s;\n}\n\n\n\nsigned main(){\n\tcin >> n >> q;\n\tif(n > 5000 || q > 5000) return 0;\n\tfor(int i = 0;i < n;i++) {\n\t\tint p;\n\t\tcin >> p >> a[i];\n\t\tif(p != -1) G[p].pb(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tint t;\n\t\tcin >> t;\n\t\tif(t == 1){\n\t\t\tint v,d,x;\n\t\t\tcin >> v >> d >> x;\n\t\t\tadd(v,d,x);\n\t\t}else if(t == 2){\n\t\t\tint v,d;\n\t\t\tcin >> v >> d;\n\t\t\tcout << sum(v,d) << endl;\n\t\t}else{\n\t\t\tint pr,ar;\n\t\t\tcin >> pr >> ar;\n\t\t\tG[pr].pb(n);\n\t\t\ta[n++] = ar;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,ON,Q;\nint P[504040];\nint A[504040];\nint dep[504040];\nint T[50505],V[50505],D[50505],X[50505];\n\nvector<int> E[505050];\n\ntemplate<class V> class SegTree_3 {\npublic:\n\tint NV;\n\tvector<V> tot,each;\n\tvoid init(int count) {\n\t\tNV=1;\n\t\twhile((1<<NV)<=count*2) NV++;\n\t\ttot.resize(NV*2,0);\n\t\teach.resize(NV*2,0);\n\t};\n\t\n\tll getval(int x,int y,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(r<=x || y<=l) return 0;\n\t\tif(x<=l && r<=y) return tot[k];\n\t\treturn getval(x,y,l,(l+r)/2,k*2)+getval(x,y,(l+r)/2,r,k*2+1)+each[k]*(r-l);\n\t}\n\t\n\tvoid update(int x,int y, V v,int l=0,int r=-1,int k=1) {\n\t\tif(r==-1) r=NV;\n\t\tif(l>=r) return;\n\t\tif(x<=l && r<=y) {\n\t\t\teach[k]+=v;\n\t\t\ttot[k]+=v*(r-l);\n\t\t}\n\t\telse if(l < y && x < r) {\n\t\t\tupdate(x,y,v,l,(l+r)/2,k*2);\n\t\t\tupdate(x,y,v,(l+r)/2,r,k*2+1);\n\t\t\ttot[k]=tot[2*k]+tot[2*k+1]+each[k]*(r-l);\n\t\t}\n\t}\n};\nSegTree_3<ll> bit[505050];\nll add(int cur,int left,int v) {\n\tif(left<0) return 0;\n\tll ret=0;\n\tA[cur]+=v;\n\tret+=A[cur];\n\tFORR(e,E[cur]) ret+=add(e,left-1,v);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tint type2=1;\n\tFOR(i,N) {\n\t\tcin>>P[i]>>A[i];\n\t\tif(P[i]+1!=i) type2=0;\n\t\tif(i) E[P[i]].push_back(i);\n\t}\n\t\n\tif(N<=5000 && Q<=5000) {\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tadd(V[i],D[i],X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<add(V[i],D[i],0)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tE[P[N]].push_back(N);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t}\n\telse if(type2) {\n\t\tSegTree_3<ll> st;\n\t\tst.init(1<<20);\n\t\tFOR(i,N) st.update(i+1,i+2,A[i]);\n\t\tFOR(i,Q) {\n\t\t\tcin>>T[i]>>V[i]>>D[i];\n\t\t\tif(T[i]==1) {\n\t\t\t\tcin>>X[i];\n\t\t\t\tst.update(V[i]+1,V[i]+D[i]+1,X[i]);\n\t\t\t}\n\t\t\telse if(T[i]==2) {\n\t\t\t\tcout<<st.getval(V[i]+1,V[i]+D[i]+1)<<endl;\n\t\t\t}\n\t\t\telse if(T[i]==3) {\n\t\t\t\tP[N]=V[i];\n\t\t\t\tA[N]=D[i];\n\t\t\t\tst.update(N+1,N+2,A[N]);\n\t\t\t\tN++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\treturn;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tll sval[4*SZ]; int slazy[4*SZ]; int scnt[4*SZ];\n\tvoid clear() {\n\t\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\t}\n\tvoid spush(int x) {\n\t\tif(slazy[x]==0) return;\n\t\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\t\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\t\tslazy[x]=0;\n\t}\n\tvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\n\tvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\t\tif(l==r) {\n\t\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n\t}\n\tvoid smod(int x,int l,int r,int L,int R,int BY) {\n\t\tif(L<=l&&r<=R) {\n\t\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\t\tslazy[x]+=BY;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n\t}\n\tll sget(int x,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {\n\t\t\treturn sval[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; ll ret=0;\n\t\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid save(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tval[l]=sval[x]; cnt[l]=scnt[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; save(2*x+1,l,m,val,cnt); save(2*x+2,m+1,r,val,cnt);\n\t\t}\n\t}\n\tvoid load(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tsval[x]=val[l],scnt[x]=cnt[x];\n\t\t} else {\n\t\t\tint m=l+(r-l)/2; load(2*x+1,l,m,val,cnt); load(2*x+2,m+1,r,val,cnt);\n\t\t\tscalc(x);\n\t\t}\n\t}\n} S;\nS s[MAXB];\n\n\nint nb;\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tnb=(nemp+SZ-1)/SZ;\n\tREP(i,nb) s[i].clear();\n\tREP(i,nemp) if(alive[i]) s[pos[i]/SZ].sborn(0,0,SZ-1,pos[i]%SZ,oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n\nll tval[SZ]; int tcnt[SZ];\nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\t//return s[pos[idx]/SZ].sget(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ);\n\treturn tval[pos[idx]%SZ];\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].sget(0,0,SZ-1,l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\t}\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n\nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\t//s[pos[idx]/SZ].smod(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ,by);\n\ttval[pos[idx]%SZ]+=by;\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].smod(0,0,SZ-1,l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].sborn(0,0,SZ-1,pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=0,qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=0,qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\t//REP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]); exit(0);\n\t\tll chk=0; REP(i,nq) if(qt[i]==2) chk+=ans[i];\n\t\tprintf(\"%.9lf %lld\\n\",double(clock() - begin) / CLOCKS_PER_SEC,chk);\n\t}\n}\n \nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntemplate<class T>\nstruct BIT {\n\tstruct Node {\n\t\tT sum0 = 0;\n\t\tT sum1 = 0;\n\t};\n\n\tvector<Node> nodes;\n\n\tBIT(int n) : nodes(n + 1) {}\n\n\tT sumRange(int k) {\n\t\tk++;\n\t\tT s0 = 0;\n\t\tT s1 = 0;\n\t\tint x = k;\n\t\twhile (k > 0) {\n\t\t\ts0 += nodes[k].sum0;\n\t\t\ts1 += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn s0 + s1 * x;\n\t}\n\n\tT sumRange(int l, int r) {\n\t\treturn sumRange(r - 1) - sumRange(l - 1);\n\t}\n\n\tT sumPoint(int k) {\n\t\tk++;\n\t\tT ret = 0;\n\t\twhile (k > 0) {\n\t\t\tret += nodes[k].sum1;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid addPoint(int k, T v) {\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 += v;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tvoid addRange(int l, int r, T value) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd(l, value);\n\t\tadd(r, -value);\n\t}\n\n\tvoid add(int k, T v1) {\n\t\tT v0 = v1 * k;\n\t\tk++;\n\t\twhile (k < nodes.size()) {\n\t\t\tnodes[k].sum0 -= v0;\n\t\t\tnodes[k].sum1 += v1;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tconst int S = 500;\n\tconst int N = (n + S - 1) / S;\n\n\tvector<vector<int>> g(n);\n\tvector<long long> a(n);\n\tvector<long long> aa(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d %lld\", &p, &aa[i]);\n\t\tif (p != -1) {\n\t\t\tg[p].push_back(i);\n\t\t}\n\t}\n\tvector<int> type(q);\n\tvector<int> foo(q), bar(q), baz(q);\n\tbool has3 = false;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &type[i]);\n\t\tif (type[i] == 1) {\n\t\t\tscanf(\"%d %d %d\", &foo[i], &bar[i], &baz[i]);\n\t\t} else if (type[i] == 2) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t} else if (type[i] == 3) {\n\t\t\tscanf(\"%d %d\", &foo[i], &bar[i]);\n\t\t\thas3 = true;\n\t\t}\n\t}\n\n\tif (!has3) {\n\t\tvector<vector<int>> dict(N);\n\t\tvector<BIT<long long>> bits;\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tvector<int> depth(n);\n\t\tvector<int> depth2(n);\n\t\tint now = 0;\n\t\tfunction<void(int, int)> dfs = [&](int u, int d) {\n\t\t\tL[u] = now;\n\t\t\ta[now] = aa[u];\n\t\t\tdepth[now] = d;\n\t\t\tnow++;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t}\n\t\t\tR[u] = now;\n\t\t};\n\t\tdfs(0, 0);\n\n\t\tauto lb = [&](vector<int> &v, int val) {\n\t\t\treturn lower_bound(v.begin(), v.end(), val) - v.begin();\n\t\t};\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdict[i / S].push_back(depth[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsort(dict[i].begin(), dict[i].end());\n\t\t\tbits.emplace_back(dict[i].size());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdepth2[i] = lb(dict[i / S], depth[i]);\n\t\t\tbits[i / S].addPoint(depth2[i], a[i]);\n\t\t}\n\n\t\tauto add = [&](int u, int k, int x) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tbits[l / S].addRange(b, t, x);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\ta[l] += x;\n\t\t\t\t\t\tbits[l / S].addPoint(depth2[l], x);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tauto sum = [&](int u, int k) {\n\t\t\tint l = L[u];\n\t\t\tint r = R[u];\n\t\t\tint bottom = depth[l];\n\t\t\tint top = depth[l] + k + 1;\n\t\t\tlong long ret = 0;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l % S == 0 && l + S <= r) {\n\t\t\t\t\tint b = lb(dict[l / S], bottom);\n\t\t\t\t\tint t = lb(dict[l / S], top);\n\t\t\t\t\tret += bits[l / S].sumRange(b, t);\n\t\t\t\t\tl += S;\n\t\t\t\t} else {\n\t\t\t\t\tif (bottom <= depth[l] && depth[l] < top) {\n\t\t\t\t\t\tret += a[l] + bits[l / S].sumPoint(depth2[l]);\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\n\t\twhile (q--) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t == 1) {\n\t\t\t\tint v, d, x;\n\t\t\t\tscanf(\"%d %d %d\", &v, &d, &x);\n\t\t\t\tadd(v, d, x);\n\t\t\t} else if (t == 2) {\n\t\t\t\tint v, d;\n\t\t\t\tscanf(\"%d %d\", &v, &d);\n\t\t\t\tprintf(\"%lld\\n\", sum(v, d));\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t} else if (n <= 5000 && q <= 5000) {\n\t\tfunction<void(int, int, int)> add = [&](int u, int x, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taa[u] += x;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tadd(v, x, d - 1);\n\t\t\t}\n\t\t};\n\t\tfunction<long long(int, int)> sum = [&](int u, int d) {\n\t\t\tif (d < 0) {\n\t\t\t\treturn 0LL;\n\t\t\t}\n\t\t\tlong long ret = aa[u];\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tret += sum(v, d - 1);\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tadd(foo[i], baz[i], bar[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", sum(foo[i], bar[i]));\n\t\t\t} else {\n\t\t\t\tg[foo[i]].push_back(g.size());\n\t\t\t\tg.emplace_back();\n\t\t\t\taa.push_back(bar[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBIT<long long> bit(n + q);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit.addPoint(i, aa[i]);\n\t\t}\n\t\tint now = n;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (type[i] == 1) {\n\t\t\t\tbit.addRange(foo[i], foo[i] + bar[i] + 1, baz[i]);\n\t\t\t} else if (type[i] == 2) {\n\t\t\t\tprintf(\"%lld\\n\", bit.sumRange(foo[i], foo[i] + bar[i] + 1));\n\t\t\t} else {\n\t\t\t\tbit.addPoint(now, bar[i]);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\ntypedef vector<ll>::iterator vit;\n\nvi adj[400001];\nll par[400001];\nll a[400001];\n\nclass LazySegmentTree {\nprivate:\n\tll size_;\n\tvector<long long> v, lazy;\n\tvoid update(ll a, ll b, long long x, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(ll a, ll b, ll k, ll l, ll r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(ll n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.assign(size_ * 4, 0);\n\t\tlazy.assign(size_ * 4, 0);\n\t}\n\tinline void push(ll k, ll l, ll r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] += lazy[k] * ll(r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] += lazy[k];\n\t\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(ll l, ll r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(ll l, ll r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nll h[55001];\nvi child[55001];\nvoid dfs(ll u)\n{\n\tfor(ll i=0;i<adj[u].size();i++)\n\t{\n\t\tll v =adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n}\nLazySegmentTree seg(500001);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, q; cin>>n>>q;\n\t/*\n\tif(n<=5000&&q<=5000)\n\t{\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tcin>>par[i]>>a[i];\n\t\t\tif(par[i]!=-1) adj[par[i]].pb(i);\n\t\t}\n\t\tfor(ll i = 0; i < n; i++)\n\t\t{\n\t\t\tll p = i;\n\t\t\twhile(par[p]!=-1)\n\t\t\t{\n\t\t\t\tchild[par[p]].pb(i);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tll cnt = n;\n\t\tfor(ll i = 0; i < q; i++)\n\t\t{\n\t\t\tll t; cin>>t;\n\t\t\tif(t==3)\n\t\t\t{\n\t\t\t\tll pp; cin>>pp;\n\t\t\t\tll x; cin>>x;\n\t\t\t\tpar[cnt] = pp;\n\t\t\t\ta[cnt]=x;\n\t\t\t\th[cnt]=h[pp]+1;\n\t\t\t\tll p = cnt;\n\t\t\t\twhile(par[p]!=-1)\n\t\t\t\t{\n\t\t\t\t\tchild[par[p]].pb(cnt);\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll u,d;\n\t\t\tcin>>u>>d;\n\t\t\tif(t==2)\n\t\t\t{\n\t\t\t\tll ans=a[u];\t\t\t\t\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\tans+=a[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<ans<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll x; cin>>x;\n\t\t\t\ta[u]+=x;\n\t\t\t\tfor(ll j=0;j<child[u].size();j++)\n\t\t\t\t{\n\t\t\t\t\tll v=child[u][j];\n\t\t\t\t\tif(h[v]-h[u]<=d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[v]+=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t*/\n\tfor(ll i = 0; i < n; i++)\n\t{\n\t\tcin>>par[i]>>a[i];\n\t\t//assert(par[i]==i-1);\n\t\tseg.update(i,i+1,a[i]);\n\t}\n\tll cnt = n;\n\tfor(ll i = 0; i < q; i++)\n\t{\n\t\tll t; cin>>t;\n\t\tif(t==3)\n\t\t{\n\t\t\tll z; cin>>z;\n\t\t\t//assert(z==cnt-1);\n\t\t\tll v; cin>>v;\n\t\t\tseg.update(cnt,cnt+1,v);\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tll u; cin>>u;\n\t\tll d; cin>>d;\n\t\td=min(d,cnt-u);\n\t\tif(t==2)\n\t\t{\n\t\t\tcout<<seg.query(u,u+d+1)<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll x; cin>>x;\n\t\t\tseg.update(u,u+d+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n\nstruct sum_seg{\n\tvector<long long int> lazy;\n\tvector<long long int> seg;\n\tint SS;\n\tsum_seg(){\n\t}\n\tvoid resize(int n){\n\t\tn *= 4;\n\t\tlazy.assign(n, 0);\n\t\tseg.assign(n, 0);\n\t\tSS = seg.size();\n\t}\n\tvoid update(int b,int rng){\n\t\tif (b * 2 + 2 < SS){\n\t\t\tlazy[b * 2 + 1] += lazy[b];\n\t\t\tlazy[b * 2 + 2] = lazy[b];\n\t\t}\n\t\tseg[b] += lazy[b]*rng;\n\t\tlazy[b] = 0;\n\t}\n\tinline void add(int b, int l, int r, int ll, int rr, int x){\n\t\tupdate(b,r-l);\n\t\tif (rr <= l || r <= ll){\n\t\t\treturn;\n\t\t}\n\t\tif (ll <= l&&r <= rr){\n\t\t\tlazy[b] += x;\n\t\t\tupdate(b,r-l);\n\t\t\treturn;\n\t\t}\n\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, rr, x);\n\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, rr, x);\n\t\tseg[b] = seg[b * 2 + 1]+ seg[b * 2 + 2];\n\t}\n\tinline int query(int b, int l, int r, int ll,int rr){\n\t\tupdate(b,r-l);\n\t\tif (r <= ll || ll < l)return -1;\n\t\tif (ll <= l&&r <= rr){\n\t\t\treturn seg[b];\n\t\t}\n\t\treturn query(b * 2 + 1, l, (l + r) >> 1, ll,rr) +query(b * 2 + 2, (l + r) >> 1, r, ll,rr);\n\t}\n}; \n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nvector<query> Q;\n\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nint star[MAX];\nint en[MAX];\nint dep[MAX];\nint child[MAX];\n\n\nint ord;\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nvector<int> seg[MAX * 4];\nsum_seg S[MAX * 4];\n\ninline void add(int b, int l, int r, int ll, int x){\n\tif (l <= ll&&ll < r){\n\t\tseg[b].push_back(x);\n\t\tif (l + 1 < r){\n\t\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, x);\n\t\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, x);\n\t\t}\n\t}\n}\ninline void init(int b, int l, int r){\n\tint siz = seg[b].size();\n\tsort(seg[b].begin(), seg[b].end());\n\tS[b].resize(siz);\n\tif (l + 1 < r){\n\t\tinit(b * 2 + 1, l, (l + r) >> 1);\n\t\tinit(b * 2 + 2, (l + r) >> 1, r);\n\t}\n}\ninline void add1(int b, int l, int r, int ll, int rr, int lll,int rrr,int x){\n\tif (r <= ll || rr <= l){\n\t\treturn;\n\t}\n\tif (ll <= l&&r <= rr){\n\t\tS[b].add(0, 0, seg[b].size(), lll, rrr, x);\n\t\treturn;\n\t}\n\tadd1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr, x);\n\tadd1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr, x);\n}\ninline long long int Q1(int b, int l, int r, int ll, int rr, int lll, int rrr){\n\tif (r <= ll || rr <= l)return 0;\n\tif (ll <= l&&r <= rr){\n\t\treturn S[b].query(0, 0, seg[b].size(), lll, rrr);\n\t}\n\treturn Q1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr) + Q1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr);\n}\n\nlong long int cost[MAX];\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tcost[n] = ar;\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tfor (int i = 0; i < n; i++){\n\t\tadd(0, 0, n, dep[i],star[i]);\n\t}\n\tinit(0, 0, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\n\nstruct sum_seg{\n\tvector<long long int> lazy;\n\tvector<long long int> seg;\n\tint SS;\n\tsum_seg(){\n\t}\n\tvoid resize(int n){\n\t\tn *= 4;\n\t\tlazy.assign(n, 0);\n\t\tseg.assign(n, 0);\n\t\tSS = seg.size();\n\t}\n\tvoid update(int b,int rng){\n\t\tif (b * 2 + 2 < SS){\n\t\t\tlazy[b * 2 + 1] += lazy[b];\n\t\t\tlazy[b * 2 + 2] = lazy[b];\n\t\t}\n\t\tseg[b] += lazy[b]*rng;\n\t\tlazy[b] = 0;\n\t}\n\tinline void add(int b, int l, int r, int ll, int rr, int x){\n\t\tupdate(b,r-l);\n\t\tif (rr <= l || r <= ll){\n\t\t\treturn;\n\t\t}\n\t\tif (ll <= l&&r <= rr){\n\t\t\tlazy[b] += x;\n\t\t\tupdate(b,r-l);\n\t\t\treturn;\n\t\t}\n\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, rr, x);\n\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, rr, x);\n\t\tseg[b] = seg[b * 2 + 1]+ seg[b * 2 + 2];\n\t}\n\tinline int query(int b, int l, int r, int ll,int rr){\n\t\tupdate(b,r-l);\n\t\tif (r <= ll || ll < l)return -1;\n\t\tif (ll <= l&&r <= rr){\n\t\t\treturn seg[b];\n\t\t}\n\t\treturn query(b * 2 + 1, l, (l + r) >> 1, ll,rr) +query(b * 2 + 2, (l + r) >> 1, r, ll,rr);\n\t}\n}; \n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 500002\n\nvector<int> v[MAX];\n\nvector<query> Q;\n\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nint star[MAX];\nint en[MAX];\nint dep[MAX];\nint child[MAX];\n\n\nint ord;\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nvector<int> seg[MAX * 4];\nsum_seg S[MAX * 4];\n\ninline void add(int b, int l, int r, int ll, int x){\n\tif (l <= ll&&ll < r){\n\t\tseg[b].push_back(x);\n\t\tif (l + 1 < r){\n\t\t\tadd(b * 2 + 1, l, (l + r) >> 1, ll, x);\n\t\t\tadd(b * 2 + 2, (l + r) >> 1, r, ll, x);\n\t\t}\n\t}\n}\ninline void init(int b, int l, int r){\n\tint siz = seg[b].size();\n\tsort(seg[b].begin(), seg[b].end());\n\tS[b].resize(siz);\n\tif (l + 1 < r){\n\t\tinit(b * 2 + 1, l, (l + r) >> 1);\n\t\tinit(b * 2 + 2, (l + r) >> 1, r);\n\t}\n}\ninline void add1(int b, int l, int r, int ll, int rr, int lll,int rrr,int x){\n\tif (r <= ll || rr <= l){\n\t\treturn;\n\t}\n\tif (ll <= l&&r <= rr){\n\t\tlll = upper_bound(seg[b].begin(), seg[b].end(), lll - 1) - seg[b].begin();\n\t\trrr = upper_bound(seg[b].begin(), seg[b].end(), rrr) - seg[b].begin();\n\t\tif (lll >= rrr)return;\n\t\tS[b].add(0, 0, seg[b].size(), lll, rrr, x);\n\t\treturn;\n\t}\n\tadd1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr, x);\n\tadd1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr, x);\n}\ninline long long int Q1(int b, int l, int r, int ll, int rr, int lll, int rrr){\n\tif (r <= ll || rr <= l)return 0;\n\tif (ll <= l&&r <= rr){\n\t\tlll = upper_bound(seg[b].begin(), seg[b].end(),lll-1) - seg[b].begin();\n\t\trrr = upper_bound(seg[b].begin(), seg[b].end(), rrr) - seg[b].begin();\n\t\tif (lll >= rrr)return 0;\n\t\treturn S[b].query(0, 0, seg[b].size(), lll, rrr);\n\t}\n\treturn Q1(b * 2 + 1, l, (l + r) >> 1, ll, rr, lll, rrr) + Q1(b * 2 + 2, (l + r) >> 1, r, ll, rr, lll, rrr);\n}\n\nlong long int cost[MAX];\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tcost[n] = ar;\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tfor (int i = 0; i < n; i++){\n\t\tadd(0, 0, n, dep[i],star[i]);\n\t}\n\tinit(0, 0, n);\n\tfor (int i = 0; i < n; i++){\n\t\tadd1(0, 0, n, dep[i], dep[i]+1,star[i],star[i]+1,cost[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n \n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n \nconst int MAXN=400000;\nconst int MAXQ=50000;\nconst int MAXEMP=MAXN+MAXQ;\nconst int SZ=400;\nconst int MAXB=(MAXEMP+SZ-1)/SZ;\n \nint n,nq,nemp;\nint par[MAXEMP],oval[MAXEMP]; bool alive[MAXEMP];\nint qt[MAXQ],qemp[MAXQ],qd[MAXQ],qby[MAXQ];\n \nint chead[MAXEMP],cnxt[MAXEMP];\nint d[MAXEMP],lid[MAXEMP],rid[MAXEMP],emp[MAXEMP],nid;\nvoid dfs(int at) {\n\td[at]=par[at]==-1?0:d[par[at]]+1; emp[nid]=at,lid[at]=nid++;\n\tfor(int to=chead[at];to!=-1;to=cnxt[to]) dfs(to);\n\trid[at]=nid-1;\n}\n \nint pos[MAXEMP];\nint sd[MAXEMP];\n\ntypedef struct S {\n\tll sval[4*SZ]; int slazy[4*SZ]; int scnt[4*SZ];\n\tvoid clear() {\n\t\tmemset(sval,0,sizeof(sval)); memset(slazy,0,sizeof(slazy)); memset(scnt,0,sizeof(scnt));\n\t}\n\tvoid spush(int x) {\n\t\tif(slazy[x]==0) return;\n\t\tsval[2*x+1]+=slazy[x]*scnt[2*x+1]; slazy[2*x+1]+=slazy[x];\n\t\tsval[2*x+2]+=slazy[x]*scnt[2*x+2]; slazy[2*x+2]+=slazy[x];\n\t\tslazy[x]=0;\n\t}\n\tvoid scalc(int x) { scnt[x]=scnt[2*x+1]+scnt[2*x+2]; sval[x]=sval[2*x+1]+sval[2*x+2]; }\n\tvoid sborn(int x,int l,int r,int IDX,int VAL) {\n\t\tif(l==r) {\n\t\t\tsval[x]=VAL,slazy[x]=0,scnt[x]=1;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(IDX<=m) sborn(2*x+1,l,m,IDX,VAL); else sborn(2*x+2,m+1,r,IDX,VAL);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"sborn(%d,%d,%d,%d,%d) -> %d %lld\\n\",x,l,r,IDX,VAL,scnt[x],sval[x]);\n\t}\n\tvoid smod(int x,int l,int r,int L,int R,int BY) {\n\t\tif(L<=l&&r<=R) {\n\t\t\tsval[x]+=(ll)scnt[x]*BY;\n\t\t\tslazy[x]+=BY;\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2;\n\t\t\tif(L<=m) smod(2*x+1,l,m,L,R,BY);\n\t\t\tif(m+1<=R) smod(2*x+2,m+1,r,L,R,BY);\n\t\t\tscalc(x);\n\t\t}\n\t\t//printf(\"smod(%d,%d,%d,%d,%d,%d) -> %d %lld %d\\n\",x,l,r,L,R,BY,scnt[x],sval[x],slazy[x]);\n\t}\n\tll sget(int x,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {\n\t\t\treturn sval[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; ll ret=0;\n\t\t\tif(L<=m) ret+=sget(2*x+1,l,m,L,R);\n\t\t\tif(m+1<=R) ret+=sget(2*x+2,m+1,r,L,R);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid save(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tval[l]=sval[x]; cnt[l]=scnt[x];\n\t\t} else {\n\t\t\tspush(x);\n\t\t\tint m=l+(r-l)/2; save(2*x+1,l,m,val,cnt); save(2*x+2,m+1,r,val,cnt);\n\t\t}\n\t}\n\tvoid load(int x,int l,int r,ll *val,int *cnt) {\n\t\tif(l==r) {\n\t\t\tsval[x]=val[l],scnt[x]=cnt[x];\n\t\t} else {\n\t\t\tint m=l+(r-l)/2; load(2*x+1,l,m,val,cnt); load(2*x+2,m+1,r,val,cnt);\n\t\t\tscalc(x);\n\t\t}\n\t}\n} S;\nS s[MAXB];\n\n\nint nb;\npair<int,int> tmp[SZ];\nvoid build() {\n\tfor(int i=0;i<nemp;i+=SZ) {\n\t\tint cnt=min(SZ,nemp-i);\n\t\tREP(j,cnt) tmp[j]=MP(d[emp[i+j]],emp[i+j]);\n\t\tsort(tmp,tmp+cnt);\n\t\tREP(j,cnt) sd[i+j]=tmp[j].first,pos[tmp[j].second]=i+j;\n\t}\n\tnb=(nemp+SZ-1)/SZ;\n\tREP(i,nb) s[i].clear();\n\tREP(i,nemp) if(alive[i]) s[pos[i]/SZ].sborn(0,0,SZ-1,pos[i]%SZ,oval[i]);\n\t//REP(i,nemp) printf(\"%d: emp=%d d=%d pos=%d oval=%d\\n\",i,emp[i],d[emp[i]],pos[emp[i]],oval[emp[i]]);\n\t//REP(i,nemp) printf(\" %d\",sd[i]); puts(\"\");\n}\n\nll tval[SZ]; int tcnt[SZ];\nll query1(int idx,int ld,int rd) {\n\t//printf(\"query1(%d,%d,%d)\\n\",idx,ld,rd);\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return 0;\n\t//return s[pos[idx]/SZ].sget(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ);\n\treturn tval[pos[idx]%SZ];\n}\n \nll queryb(int idx,int ld,int rd) {\n\t//printf(\"queryb(%d,%d,%d)\\n\",idx,ld,rd);\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return 0;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\t//printf(\"->%d..%d (%d,%d)\\n\",l,r-1,bl,br);\n\treturn s[idx].sget(0,0,SZ-1,l%SZ,(r-1)%SZ);\n}\n \nll query(int lid,int rid,int ld,int rd) {\n\t//printf(\"query(%d..%d,%d..%d)\\n\",lid,rid,ld,rd);\n\tll ret=0;\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) ret+=query1(emp[lid++],ld,rd);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) ret+=query1(emp[--rid],ld,rd);\n\t}\n\twhile(lid<rid) ret+=queryb(lid/SZ,ld,rd),lid+=SZ;\n\treturn ret;\n}\n\nvoid update1(int idx,int ld,int rd,int by) {\n\tif(!alive[idx]||d[idx]<ld||d[idx]>=rd) return;\n\t//s[pos[idx]/SZ].smod(0,0,SZ-1,pos[idx]%SZ,pos[idx]%SZ,by);\n\ttval[pos[idx]%SZ]+=by;\n}\n \nvoid updateb(int idx,int ld,int rd,int by) {\n\tint bl=idx*SZ,br=min(nemp,(idx+1)*SZ);\n\tint l=lower_bound(sd+bl,sd+br,ld)-sd;\n\tif(l>=br||sd[l]>=rd) return;\n\tint r=lower_bound(sd+bl,sd+br,rd)-sd;\n\treturn s[idx].smod(0,0,SZ-1,l%SZ,(r-1)%SZ,by);\n}\n \nvoid update(int lid,int rid,int ld,int rd,int by) {\n\tif(lid<rid&&lid%SZ!=0) {\n\t\tint b=lid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&lid%SZ!=0) update1(emp[lid++],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\tif(lid<rid&&rid%SZ!=0) {\n\t\tint b=rid/SZ;\n\t\ts[b].save(0,0,SZ-1,tval,tcnt);\n\t\twhile(lid<rid&&rid%SZ!=0) update1(emp[--rid],ld,rd,by);\n\t\ts[b].load(0,0,SZ-1,tval,tcnt);\n\t}\n\twhile(lid<rid) updateb(lid/SZ,ld,rd,by),lid+=SZ;\n}\n \nvoid born(int idx) {\n\tassert(!alive[idx]); alive[idx]=true;\n\ts[pos[idx]/SZ].sborn(0,0,SZ-1,pos[idx]%SZ,oval[idx]);\n}\n \nll ans[MAXQ];\nvoid solve() {\n\tREP(i,nemp) chead[i]=-1; REP(i,nemp) if(par[i]!=-1) cnxt[i]=chead[par[i]],chead[par[i]]=i;\n\tnid=0; dfs(0); build();\n \n\tREP(i,nq) {\n\t\tif(qt[i]==1) update(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1,qby[i]);\n\t\tif(qt[i]==2) ans[i]=query(lid[qemp[i]],rid[qemp[i]]+1,d[qemp[i]],d[qemp[i]]+qd[i]+1);\n\t\tif(qt[i]==3) born(qemp[i]);\n\t}\n}\n \nvoid run() {\n\tscanf(\"%d%d\",&n,&nq); nemp=n;\n\tREP(i,n) scanf(\"%d%d\",&par[i],&oval[i]),alive[i]=true;\n\tREP(i,nq) {\n\t\tscanf(\"%d\",&qt[i]);\n\t\tif(qt[i]==1) scanf(\"%d%d%d\",&qemp[i],&qd[i],&qby[i]);\n\t\tif(qt[i]==2) scanf(\"%d%d\",&qemp[i],&qd[i]);\n\t\tif(qt[i]==3) scanf(\"%d%d\",&par[nemp],&oval[nemp]),alive[nemp]=false,qemp[i]=nemp++;\n\t}\n\tsolve();\n\tREP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]);\n}\n \nvoid stress() {\n\tREP(x,10) {\n\t\tn=MAXN; nq=MAXQ;\n\t\tpar[0]=-1; FOR(i,1,n) par[i]=i<n/10?i-1:(rand()*1000+rand())%(n/10); REP(i,n) oval[i]=rand()%1000+1,alive[i]=true; nemp=n;\n\t\tREP(i,nq) {\n\t\t\tqt[i]=rand()%3+1;\n\t\t\tif(qt[i]==1) qemp[i]=0,qd[i]=rand()%(n/10),qby[i]=rand()%1000+1;\n\t\t\tif(qt[i]==2) qemp[i]=0,qd[i]=rand()%(n/10);\n\t\t\tif(qt[i]==3) qemp[i]=nemp,par[nemp]=(rand()*1000+rand())%(n/10),oval[nemp]=rand()%1000+1,alive[nemp]=false,++nemp;\n\t\t}\n\t\tclock_t begin = clock();\n\t\tsolve();\n\t\t//REP(i,nq) if(qt[i]==2) printf(\"%lld\\n\",ans[i]); exit(0);\n\t\tll chk=0; REP(i,nq) if(qt[i]==2) chk+=ans[i];\n\t\tprintf(\"%.9lf %lld\\n\",double(clock() - begin) / CLOCKS_PER_SEC,chk);\n\t}\n}\n \nint main() {\n\tstress();\n\t//run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\nBIT B;\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\t/*if (ex[b] == false)return;\n\tcur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tB.resize(2*MAX);\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tint cur=n;\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, cur,ar));\n\t\t\tv[pr].push_back(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\tcur = n;\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\tint rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}\n\t\tinit();\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,q;\nint par[452521], a[452521];\nvi children[452521];\n\nvoid dfs1(int p,int d,int x){\n  a[p] += x;\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      dfs1(to,d,x);\n    }\n  }\n}\nll dfs2(int p,int d){\n  ll ret = a[p];\n  if(d>0){\n    d--;\n    for(int to : children[p]){\n      ret += dfs2(to,d);\n    }\n  }\n  return ret;\n}\n\nconst int MAX = 1<<19;\nll dat[2*MAX];\nll lazy[2*MAX];\nvoid push(int k){\n  if(lazy[k]!=0){\n    dat[k] += lazy[k];\n    if(k<MAX-1){\n      lazy[2*k+1] += lazy[k];\n      lazy[2*k+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n}\nvoid add(int l,int r,int v,int a,int b,int k){\n  push(k);\n  if(r<=a || b<=l)return;\n  if(l<=a && b<=r){\n    lazy[k] += v;\n  }else{\n    int m = (a+b)/2;\n    add(l,r,v,a,m,2*k+1);\n    add(l,r,v,m,b,2*k+2);\n  }\n}\nll sum(int l,int r,int a,int b,int k){\n  push(k);\n  if(r<=a || b<=l)return 0ll;\n  if(l<=a && b<=r){\n    return dat[k];\n  }else{\n    int m = (a+b)/2;\n    return sum(l,r,a,m,2*k+1) + sum(l,r,m,b,2*k+2);\n  }\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&q);\n  REP(i,n)scanf(\"%d%d\",par+i,a+i);\n  if(n<=5000 && q<=5000){\n    // 170\n    // naive\n    REP(i,n)if(par[i]>=0){\n      children[par[i]].push_back(i);\n    }\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        dfs1(v,d,x);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",dfs2(v,d));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        children[pr].push_back(n);\n        par[n] = pr;\n        a[n] = pr;\n        n++;\n      }\n    }\n  }else{\n    // 240\n    REP(i,n)assert(par[i]+1 == i);\n    REP(i,n)dat[i+MAX-1] = a[i];\n    FORR(i,0,MAX-1)dat[i] = dat[2*i+1] + dat[2*i+2];\n    while(q--){\n      int t;\n      scanf(\"%d\",&t);\n      if(t==1){\n        int v,d,x;\n        scanf(\"%d%d%d\",&v,&d,&x);\n        add(v,v+d+1,x,0,MAX,0);\n      }else if(t==2){\n        int v,d;\n        scanf(\"%d%d\",&v,&d);\n        printf(\"%lld\\n\",sum(v,v+d+1,0,MAX,0));\n      }else{\n        int pr,ar;\n        scanf(\"%d%d\",&pr,&ar);\n        add(n,n+1,ar,0,MAX,0);\n        n++;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\nint q;\n\nstruct query{\n\tint ty;\n\tint v;\n\tint d;\n\tint x;\n\tquery(int ty_,int v_,int d_,int x_=0){\n\t\tty = ty_;\n\t\tv = v_;\n\t\td = d_;\n\t\tx = x_;\n\t}\n};\n\n#define MAX 800002\n\nvector<int> v[MAX];\n\nlong long int cost[MAX];\n\nvector<query> Q;\n\nbool ex[MAX];\n\nvector<pair<int, long long int> > ev[MAX];\n\nlong long int ans[MAX];\n\n\nstruct ASK{\n\tint id;\n\tint d;\n\tASK(int id_, int d_){\n\t\tid = id_;\n\t\td = d_;\n\t}\n};\nvector<ASK> ask[MAX];\n\nint dep[MAX];\n\nstruct BIT{\n\tvector<long long int> bit;\n\tvoid resize(int N){\n\t\tbit.assign(N, 0);\n\t}\n\tvoid add(int i, long long int j){\n\t\ti++;\n\t\twhile (i < bit.size()){\n\t\t\tbit[i] += j;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tlong long int sum(int i){\n\t\tlong long int r = 0;\n\t\ti++;\n\t\twhile (i){\n\t\t\tr += bit[i];\n\t\t\ti -= i&-i;\n\t\t}\n\t\treturn r;\n\t}\n};\n\n\nlong long int flag[MAX];\n\ninline void dfs(int b,long long int cur_add=0){\n\tif (ex[b] == false)return;\n\t/*cur_add += flag[dep[b]];\n\tfor (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add += ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] -= ev[b][i].second;\n\t}\n\tcost[b] += cur_add;*/\n\tint siz = v[b].size();\n\tfor (int i = 0; i < siz; i++){\n\t\tdfs(v[b][i],cur_add);\n\t}\n\t/*for (int i = 0; i < ev[b].size(); i++){\n\t\tcur_add -= ev[b][i].second;\n\t\tflag[dep[b] + ev[b][i].first + 1] += ev[b][i].second;\n\t}\n\tev[b].clear();*/\n}\n\nlong long int sum[MAX];\nint us[MAX];\nint u_s;\nint mx_dep;\n\nint child[MAX];\nint star[MAX];\nint en[MAX];\nint ord;\n\ninline void adding_all(int b){\n\tif (us[dep[b]] != u_s){\n\t\tus[dep[b]] = u_s;\n\t\tsum[dep[b]] = 0;\n\t}\n\tsum[dep[b]] += cost[b];\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tadding_all(v[b][i]);\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n}\n\ninline void dfs3(int b, bool del=false){\n\tif (ex[b] == false)return;\n\tu_s++;\n\tmx_dep = 0;\n\tif (v[b].size() == 0){\n\t\tfor (int i = 0; i < ask[b].size(); i++){\n\t\t\tans[ask[b][i].id] += cost[b];\n\t\t}\n\t\treturn;\n\t}\n\tint mx = -1;\n\tint node = 0;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (mx < child[v[b][i]]){\n\t\t\tmx = child[v[b][i]];\n\t\t\tnode = v[b][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tdfs3(v[b][i]);\n\t\t}\n\t}\n\tdfs3(node, true);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] != node){\n\t\t\tadding_all(v[b][i]);\n\t\t}\n\t}\n\tmx_dep = max(mx_dep, dep[b]);\n\tfor (int i = dep[b]+1; i <= mx_dep; i++){\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 0; i < ask[b].size(); i++){\n\t\tint go = dep[b] + ask[b][i].d;\n\t\tgo = min(go, mx_dep);\n\t\tans[ask[b][i].id] = sum[go];\n\t}\n}\nvoid init(){\n\tdfs(0);\n\t//dfs3(0);\n}\n\n\ninline void dfs2(int b,int d=0){\n\tstar[b] = ord;\n\tord++;\n\tdep[b] = d;\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tint go = v[b][i];\n\t\tdfs2(go,d+1);\n\t\tchild[b] += child[go];\n\t}\n\ten[b] = ord;\n\tchild[b]++;\n}\n\n\nint main(){\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++){\n\t\tex[i] = true;\n\t\tint p, a;\n\t\tscanf(\"%d%d\", &p, &a);\n\t\tif (p >= 0){\n\t\t\tv[p].push_back(i);\n\t\t}\n\t\tcost[i] = a;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1){\n\t\t\tint vv, d,xx;\n\t\t\tscanf(\"%d%d%d\", &vv, &d,&xx);\n\t\t\tQ.push_back(query(ty, vv, d,xx));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 2){\n\t\t\tint vv,dd;\n\t\t\tscanf(\"%d%d\", &vv,&dd);\n\t\t\tQ.push_back(query(ty, vv,dd));\n\t\t\tcontinue;\n\t\t}\n\t\tif (ty == 3){\n\t\t\tint pr, ar;\n\t\t\tscanf(\"%d%d\", &pr, &ar);\n\t\t\tQ.push_back(query(3, n,ar));\n\t\t\tv[pr].push_back(n);\n\t\t\tn++;\n\t\t}\n\t}\n\tdfs2(0);\n\tint SQ = 220;\n\tfor (int i = 0; i < q; i+=SQ){\n\t\t/*int rig = min(q, i + SQ);\n\t\tfor (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tev[Q[j].v].push_back(make_pair(Q[j].d, Q[j].x));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\task[Q[j].v].push_back(ASK(j,Q[j].d));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tex[Q[j].v] = true;\n\t\t\tcost[Q[j].v] = Q[j].d;\n\t\t}*/\n\t\tinit();\n\t\t/*for (int j = i; j < rig; j++){\n\t\t\tif (Q[j].ty == 1){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v]-dep[Q[j].v]<=Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tcost[Q[jj].v] -= Q[j].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Q[j].ty == 2){\n\t\t\t\tfor (int jj = j + 1; jj < rig; jj++){\n\t\t\t\t\tif (Q[jj].ty == 1){\n\t\t\t\t\t\tint v1 = Q[j].v;  //\n\t\t\t\t\t\tint v2 = Q[jj].v;\n\t\t\t\t\t\tif (star[v1] <= star[v2] && en[v2] <= en[v1]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (star[v2] <= star[v1] && en[v1] <= en[v2]){\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Q[jj].ty == 3){\n\t\t\t\t\t\tif (dep[Q[jj].v] - dep[Q[j].v] <= Q[j].d&&star[Q[j].v] <= star[Q[jj].v] && en[Q[jj].v] <= en[Q[j].v]){\n\t\t\t\t\t\t\tans[j] -= cost[Q[jj].v];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), Q = ni();\n\t\tint[] par = new int[2*n];\n\t\tlong[] a = new long[2*n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar[i] = ni();\n\t\t\ta[i] = ni();\n\t\t}\n\t\tint[][] qs = new int[Q][];\n\t\tint nx = n;\n\t\tfor(int z = 0;z < Q;z++){\n\t\t\tint t = ni();\n\t\t\tif(t == 1){\n\t\t\t\tqs[z] = new int[]{1, ni(), ni(), ni()};\n\t\t\t}else if(t == 2){\n\t\t\t\tqs[z] = new int[]{2, ni(), ni()};\n\t\t\t}else if(t == 3){\n\t\t\t\tqs[z] = new int[]{3, ni(), ni()};\n\t\t\t\tpar[nx] = qs[z][1];\n\t\t\t\tnx++;\n\t\t\t}\n\t\t}\n\t\tint fn = n;\n\t\tn = nx;\n\t\tpar = Arrays.copyOf(par, n);\n\t\tint[][] g = parentToG(par);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] ord = pars[1], dep = pars[2];\n\t\tint[][] spar = logstepParents(par);\n\t\t\n\t\tint nm = fn;\n\t\tfor(int[] q : qs){\n\t\t\tif(q[0] == 1){\n\t\t\t\tint v = q[1], d = q[2], x = q[3];\n\t\t\t\tfor(int i = 0;i < nm;i++){\n\t\t\t\t\tif(dep[v] <= dep[i] && dep[i] <= dep[v] + d && ancestor(i, dep[i]-dep[v], spar) == v){\n\t\t\t\t\t\ta[i] += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(q[0] == 2){\n\t\t\t\tint v = q[1], d = q[2];\n\t\t\t\tlong sum = 0;\n\t\t\t\tfor(int i = 0;i < nm;i++){\n\t\t\t\t\tif(dep[v] <= dep[i] && dep[i] <= dep[v] + d && ancestor(i, dep[i]-dep[v], spar) == v){\n\t\t\t\t\t\tsum += a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(sum);\n\t\t\t}else{\n\t\t\t\ta[nm] = q[2];\n\t\t\t\tnm++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tint sa = a, sb = b;\n\t\tfor (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer\n\t\t\t\t.numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {\n\t\t\tif ((low ^ high) >= t) {\n\t\t\t\tif (spar[k][sa] != spar[k][sb]) {\n\t\t\t\t\tlow |= t;\n\t\t\t\t\tsa = spar[k][sa];\n\t\t\t\t\tsb = spar[k][sb];\n\t\t\t\t} else {\n\t\t\t\t\thigh = low | t - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn spar[0][sa];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {\n\t\t\tif ((m & 1) == 1)\n\t\t\t\ta = spar[i][a];\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\n\t\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q; //現在の頂点数はまさにN\n            var P = new BIT(T + 1);\n            var R = new BIT(T + 1);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N, a + cin.Nextint);\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N, a + cin.Nextint);\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var P = new BIT(N + Q + 10);\n            var R = new BIT(N + Q + 10);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var P = new BIT(N + Q + 1);\n            var R = new BIT(N + Q + 1);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q + 1;\n            var E = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[v + d + 1] -= x;\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q;\n            var E = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[Math.Min(T - 1, v + d + 1)] -= x;//ここや\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];//ここのMが配列外参照しそう\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n \n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;           \n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q;\n            var E = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[v + d + 1] -= x;//ここや\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];//ここのMが配列外参照しそう\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var P = new BIT(N + Q + 1);\n            var R = new BIT(N + Q + 1);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N + Q - 1, a + cin.Nextint);\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N + Q - 1, a + cin.Nextint);\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var P = new BIT(N + Q + 1);\n            var R = new BIT(N + Q + 1);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N + Q, a + cin.Nextint);\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = Math.Min(N + Q, a + cin.Nextint);\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q + 1;\n            var E = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[Math.Min(T - 1,v)] += x;\n                    E[Math.Min(v + d + 1, T - 1)] -= x;\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q + 1;\n            var E = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[Math.Min(v + d + 1, T - 1)] -= x;\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var P = new BIT(2 * (N + Q) + 10000);\n            var R = new BIT(2 * (N + Q) + 10000);\n            for (int i = 1; i <= N; i++)\n            {\n                P.Add(i, -i * M[i - 1]); P.Add(i + 1, (i + 1) * M[i - 1]);\n                R.Add(i, M[i - 1]); R.Add(i + 1, -M[i - 1]);\n            }\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    int x = cin.Nextint;\n                    P.Add(a, -a * x); P.Add(b + 1, (b + 1) * x);\n                    R.Add(a, x); R.Add(b + 1, -x);\n                }\n                else if (q == 2)\n                {\n                    int a = cin.Nextint + 1;\n                    int b = a + cin.Nextint;\n                    WriteLine(P.Sum(b + 1) - P.Sum(a) + (b + 1) * R.Sum(b + 1) - a * R.Sum(a));\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    N++;\n                    P.Add(N, -N * ar); P.Add(N + 1, (N + 1) * ar);\n                    R.Add(N, ar); R.Add(N + 1, -ar);\n                }\n            }\n\n\n            return;\n        }\n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\nclass BIT //[1, n]\n{\n    int n;\n    long[] bit;\n\n    public BIT(int N)\n    {\n        n = N;\n        bit = new long[n + 1];\n    }\n\n    public void Add(int i, long x)\n    {\n        while (i <= n)\n        {\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [1, i] sum\n    public long Sum(int i)\n    {\n        long s = 0;\n        while (i > 0)\n        {\n            s = s + bit[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n\n    //[a, b] sum\n    public long Sum(int a, int b)\n    {\n        return Sum(b) - Sum(a - 1);\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q + 1;\n            var E = new int[2 * T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[v + d + 1] -= x;\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if (v + d < j) continue;\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];\n                        }\n                    }\n                    WriteLine(sum);\n                    E = new int[T];\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n\n    List<int>[] G;\n    int[] M;\n    int N;\n    long sum;\n    void Solve()\n    {\n        N = cin.Nextint;\n        int Q = cin.Nextint;\n        M = new int[N + Q];\n        G = Enumerable.Range(0, N + Q).Select(i => new List<int>()).ToArray();\n        bool flag = true;\n        for (int i = 0; i < N; i++)\n        {\n            int p = cin.Nextint;\n            if (p != i - 1) flag = false;\n            int a = cin.Nextint;\n            M[i] = a;\n            if (p == -1) continue;\n            G[p].Add(i);\n        }\n\n        if (flag)\n        {\n            var T = N + Q + 1;\n            var E  = new int[T];\n            for (int i = 0; i < Q; i++)\n            {\n                int q = cin.Nextint;\n                if (q == 1)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    int x = cin.Nextint;\n                    E[v] += x;\n                    E[v + d + 1] -= x;\n                }\n                else if (q == 2)\n                {\n                    int v = cin.Nextint;\n                    int d = cin.Nextint;\n                    sum = 0;\n                    for (int j = 0; j < T; j++)\n                    {\n                        if(j != 0)\n                        {\n                            E[j] += E[j - 1];\n                        }\n                        if (v <= j && j <= v + d)\n                        {\n                            sum += E[j] + M[j];\n                        }\n                    }\n                    WriteLine(sum);\n                }\n                else\n                {\n                    int pr = cin.Nextint;\n                    int ar = cin.Nextint;\n                    M[N] = ar;\n                    N++;\n                }\n            }\n\n            return;\n        }\n\n\n          \n\n        for (int i = 0; i < Q; i++)\n        {\n            int q = cin.Nextint;\n            if (q == 1)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                int x = cin.Nextint;\n                Dfsmore(0, v, d, x);\n            }\n            else if (q == 2)\n            {\n                int v = cin.Nextint;\n                int d = cin.Nextint;\n                sum = 0;\n                Dfssum(0, v, d);\n                WriteLine(sum);\n            }\n            else\n            {\n                int pr = cin.Nextint;\n                int ar = cin.Nextint;\n                M[N] = ar;\n                G[pr].Add(N);\n                N++;\n            }\n        }\n    }\n    void Dfsmore(int depth, int u, int d, int x)\n    {\n        if (depth <= d)\n        {\n            M[u] += x;\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfsmore(depth + 1, v, d, x);\n        }\n    }\n    void Dfssum(int depth, int u, int d)\n    {\n        if (depth <= d)\n        {\n            sum += M[u];\n        }\n        if (depth == d) return;\n        foreach (var v in G[u])\n        {\n            Dfssum(depth + 1, v, d);\n        }\n    }\n}\n\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "Lisp",
    "code": "(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (q (read))\n         (as (make-array (+ n q) :element-type 'uint31 :initial-element 0))\n         (graph (make-array (+ n q) :element-type 'list :initial-element nil))\n         (c n))\n    (assert (<= n 5000))\n    (dotimes (i n)\n      (let ((p (read-fixnum))\n            (a (read-fixnum)))\n        (setf (aref as i) a)\n        (unless (= -1 p)\n          (push i (aref graph p)))))\n    (dotimes (_ q)\n      (ecase (read-fixnum)\n        (1 (let ((v (read-fixnum))\n                 (d (read-fixnum))\n                 (x (read-fixnum)))\n             (sb-int:named-let dfs ((v v) (depth 0))\n               (when (<= depth d)\n                 (incf (aref as v) x)\n                 (dolist (child (aref graph v))\n                   (dfs child (+ depth 1)))))))\n        (2 (let ((v (read-fixnum))\n                 (d (read-fixnum))\n                 (res 0))\n             (sb-int:named-let dfs ((v v) (depth 0))\n               (when (<= depth d)\n                 (incf res (aref as v))\n                 (dolist (child (aref graph v))\n                   (dfs child (+ depth 1)))))\n             (println res)))\n        (3 (let ((pr (read-fixnum))\n                 (ar (read-fixnum)))\n             (push c (aref graph pr))\n             (setf (aref as c) ar)\n             (incf c)))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"15\n12\n30\n8\n\"\n          (run \"6 7\n-1 6\n0 5\n0 4\n2 3\n2 2\n1 1\n2 0 1\n1 0 2 1\n2 2 1\n3 3 3\n2 0 3\n3 3 4\n2 1 1\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"8\n9\n8\n31\n49\n\"\n          (run \"7 9\n-1 1\n0 5\n0 7\n0 8\n1 3\n4 1\n5 1\n2 1 1\n2 1 2\n1 1 2 3\n1 4 1 1\n2 3 1\n2 0 2\n3 6 1\n3 7 11\n2 0 15\n\" nil))))\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nint N, Q;\nint[][] adj;\nint[] parent;\nlong[] salary;\n\nvoid dfs(int n, int prev, int s, int d) {\n    salary[n] += s;\n    if (d > 0) foreach (m; adj[n]) if (m != prev) dfs(m, n, s, d-1);\n}\nlong dfs2(int n, int prev, int d) {\n    long ret = salary[n];\n    if (d > 0) foreach (m; adj[n]) if (m != prev) ret += dfs2(m, n, d-1);\n    return ret;\n}\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    N = s[0];\n    Q = s[1];\n    adj = new int[][](N);\n    salary = new long[](N);\n    fill(salary, 0);\n    parent = new int[](N);\n    parent[0] = -1;\n    foreach (i; 0..N) {\n        s = readln.split.map!(to!int);\n        if (s[0] >= 0) adj[s[0]] ~= i;\n        adj[i] ~= s[0];\n        parent[i] = s[0];\n        salary[i] = s[1];\n    }\n\n\n\n    foreach (i; 0..Q) {\n        s = readln.split.map!(to!int);\n        if (s[0] == 1) {\n            dfs(s[1], parent[s[1]], s[3], s[2]);\n        }\n        else if (s[0] == 2) {\n            dfs2(s[1], parent[s[1]], s[2]).writeln;\n        }\n        else {\n            N += 1;\n            adj ~= [s[1]];\n            adj[s[1]] ~= N-1;\n            parent ~= s[1];\n            salary ~= s[2];\n        }\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "N,Q = map(int,input().split())\nsalary = [0] * N\nbuka = {-1 : []}\nfor n in range(N):\n\tp,a = map(int,input().split())\n\tsalary[n] = a\n\tbuka[n] = []\n\tbuka[p].append(n)\nfor q in range(Q):\n\tline = list(map(int,input().split()))\n\tif line[0] == 1:\n\t\tv,d,x = line[1:]\n\t\tuplist = [v]\n\t\tfor i in range(d + 1):\n\t\t\tu2 = []\n\t\t\tfor j in uplist:\n\t\t\t\tsalary[j] += x\n\t\t\t\tu2 = u2 + buka[j]\n\t\t\tuplist = u2[:]\n\telif line[0] == 2:\n\t\tv,d = line[1:]\n\t\tans = 0\n\t\tsalist = [v]\n\t\tfor i in range(d + 1):\n\t\t\ts2 = []\n\t\t\tfor j in salist:\n\t\t\t\tans = ans + salary[j]\n\t\t\t\ts2 = s2 + buka[j]\n\t\t\tsalist = s2[:]\n\t\tprint(ans)\n\telif line[0] == 3:\n\t\tn = n + 1\n\t\tp,r = line[1:]\n\t\tbuka[n] =[]\n\t\tbuka[p].append(n)\n\t\tsalary.append(r)"
  },
  {
    "language": "Python",
    "code": "N,Q = map(int,input().split())\nsalary = [0] * N\nbuka = {-1 : []}\nfor n in range(N):\n\tp,a = map(int,input().split())\n\tsalary[n] = a\n\tbuka[n] = []\n\tbuka[p].append(n)\nfor q in range(Q):\n\tline = list(map(int,input().split()))\n\tif line[0] == 1:\n\t\tv,d,x = line[1:]\n\t\tuplist = [v]\n\t\tfor i in range(d + 1):\n\t\t\tu2 = []\n\t\t\tfor j in uplist:\n\t\t\t\tsalary[j] += x\n\t\t\t\tu2 = u2 + buka[j]\n\t\t\tuplist = u2[:]\n\telif line[0] == 2:\n\t\tv,d = line[1:]\n\t\tans = 0\n\t\tsalist = [v]\n\t\tfor i in range(d + 1):\n\t\t\ts2 = []\n\t\t\tfor j in salist:\n\t\t\t\tans = ans + salary[j]\n\t\t\t\ts2 = s2 + buka[j]\n\t\t\tsalist = s2[:]\n\t\tprint(ans)\n\telif line[0] == 3:\n\t\tn = n + 1\n\t\tp,r = line[1:]\n\t\tbuka[n] =[]\n\t\tbuka[p].append(n)\n\t\tsalary.append(r)"
  },
  {
    "language": "Python",
    "code": "N,Q = map(int,raw_input().split())\nsalary = [0] * N\nbuka = {-1 : []}\nfor n in range(N):\n\tp,a = map(int,raw_input().split())\n\tsalary[n] = a\n\tbuka[n] = []\n\tbuka[p].append(n)\nfor q in range(Q):\n\tline = list(map(int,raw_input().split()))\n\tif line[0] == 1:\n\t\tv,d,x = line[1:]\n\t\tuplist = [v]\n\t\tfor i in range(d + 1):\n\t\t\tu2 = []\n\t\t\tfor j in uplist:\n\t\t\t\tsalary[j] += x\n\t\t\t\tu2 = u2 + buka[j]\n\t\t\tuplist = u2[:]\n\telif line[0] == 2:\n\t\tv,d = line[1:]\n\t\tans = 0\n\t\tsalist = [v]\n\t\tfor i in range(d + 1):\n\t\t\ts2 = []\n\t\t\tfor j in salist:\n\t\t\t\tans = ans + salary[j]\n\t\t\t\ts2 = s2 + buka[j]\n\t\t\tsalist = s2[:]\n\t\tprint ans\n\telif line[0] == 3:\n\t\tn = n + 1\n\t\tp,r = line[1:]\n\t\tbuka[n] =[]\n\t\tbuka[p].append(n)\n\t\tsalary.append(r)"
  },
  {
    "language": "Python",
    "code": "N,Q = map(int,raw_input().split())\nsalary = [0] * N\nbuka = {-1 : []}\nfor n in range(N):\n\tp,a = map(int,raw_input().split())\n\tsalary[n] = a\n\tbuka[n] = []\n\tbuka[p].append(n)\nfor q in range(Q):\n\tline = list(map(int,raw_input().split()))\n\tif line[0] == 1:\n\t\tv,d,x = line[1:]\n\t\tuplist = [v]\n\t\tfor i in range(d + 1):\n\t\t\tu2 = []\n\t\t\tfor j in uplist:\n\t\t\t\tsalary[j] += x\n\t\t\t\tu2 = u2 + buka[j]\n\t\t\tuplist = u2[:]\n\telif line[0] == 2:\n\t\tv,d = line[1:]\n\t\tans = 0\n\t\tsalist = [v]\n\t\tfor i in range(d + 1):\n\t\t\ts2 = []\n\t\t\tfor j in salist:\n\t\t\t\tans = ans + salary[j]\n\t\t\t\ts2 = s2 + buka[j]\n\t\t\tsalist = s2[:]\n\t\tprint ans\n\telif line[0] == 3:\n\t\tn = n + 1\n\t\tp,r = line[1:]\n\t\tbuka[n] =[]\n\t\tbuka[p].append(n)\n\t\tsalary.append(r)\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn solve_linear(q: usize, mut a: Vec<i64>) {\n    for _ in 0 .. q {\n        let kind: usize = get();\n        match kind {\n            1 => {\n                let v: usize = get();\n                let d: usize = get();\n                let x = get();\n                if v + d < a.len() {\n                    a[v + d] += x;\n                }\n                a[v] += x;\n            },\n            2 => {\n                let v: usize = get();\n                let d: usize = get();\n                let mut tot = a[v];\n                if v + d < a.len() {\n                    tot += a[v + d];\n                }\n                println!(\"{}\", tot);\n            },\n            3 => {\n                let pr: i32 = get();\n                let ar = get();\n                assert!(pr + 1 == a.len() as i32);\n                a.push(ar);\n            },\n            _ => panic!(),\n        }\n    }\n}\n\nfn solve() {\n    let n = get();\n    let q = get();\n    let mut par = vec![0; n];\n    let mut a = vec![0; n];\n    for i in 0 .. n {\n        par[i] = get();\n        a[i] = get();\n    }\n    let mut is_linear = true;\n    for i in 0 .. n {\n        if par[i] != i as i32 - 1 {\n            is_linear = false;\n        }\n    }\n    if is_linear {\n        solve_linear(q, a);\n        return;\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]