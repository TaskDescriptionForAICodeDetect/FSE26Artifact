[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 50\n\nint H, W;\nint damage[MAX_SIZE][MAX_SIZE];\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint is_valid_pos(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint check_typhoon_damage(int sx, int sy) {\n    int temp_damage[MAX_SIZE][MAX_SIZE];\n    memcpy(temp_damage, damage, sizeof(damage));\n\n    for (int x = sx - 1; x <= sx + 1; x++) {\n        for (int y = sy - 1; y <= sy + 1; y++) {\n            if (is_valid_pos(x, y)) {\n                if (temp_damage[x][y] == 0) temp_damage[x][y] = 1;\n                else if (temp_damage[x][y] == 1) temp_damage[x][y] = 2;\n                else if (temp_damage[x][y] == 2) temp_damage[x][y] = 3;\n            }\n        }\n    }\n\n    for (int x = 0; x < H; x++) {\n        for (int y = 0; y < W; y++) {\n            if (temp_damage[x][y] != damage[x][y]) \n                return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &damage[i][j]);\n        }\n    }\n\n    int min_code = INT_MAX;\n    int start_x = -1, start_y = -1, trans_x = -1, trans_y = -1;\n\n    for (int sx = 0; sx < H; sx++) {\n        for (int sy = 0; sy < W; sy++) {\n            for (int dx = 0; dx < H; dx++) {\n                for (int dy = 0; dy < W; dy++) {\n                    if (check_typhoon_damage(sx, sy)) {\n                        int curr_code = 10000 * dx + dy;\n                        if (curr_code <= 10000 * sx + sy && curr_code < min_code) {\n                            min_code = curr_code;\n                            start_x = sx;\n                            start_y = sy;\n                            trans_x = dx;\n                            trans_y = dy;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", start_x, start_y, trans_x, trans_y);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_H 500\n#define MAX_W 500\n\nint H, W;\nint D[MAX_H][MAX_W];\nint delta_i[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint delta_j[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint is_valid(int i, int j) {\n    return i > 0 && i < H - 1 && j > 0 && j < W - 1;\n}\n\nvoid simulate(int si, int sj, int *ti, int *tj) {\n    int ci = si, cj = sj;\n    int next_i, next_j;\n    int moved = 1;\n\n    while (moved) {\n        moved = 0;\n        for (int d = 0; d < 8; d++) {\n            next_i = ci + delta_i[d];\n            next_j = cj + delta_j[d];\n            if (is_valid(next_i, next_j)) {\n                int valid = 1;\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        int ni = next_i + di;\n                        int nj = next_j + dj;\n                        if (D[ni][nj] == 0) {\n                            valid = 0;\n                            break;\n                        }\n                    }\n                    if (!valid) break;\n                }\n                if (valid) {\n                    for (int di = -1; di <= 1; di++) {\n                        for (int dj = -1; dj <= 1; dj++) {\n                            int ni = next_i + di;\n                            int nj = next_j + dj;\n                            D[ni][nj]--;\n                        }\n                    }\n                    ci = next_i;\n                    cj = next_j;\n                    moved = 1;\n                    break;\n                }\n            }\n        }\n    }\n    *ti = ci;\n    *tj = cj;\n}\n\nvoid find_start_end(int *si, int *sj, int *ti, int *tj) {\n    for (int i = 1; i < H - 1; i++) {\n        for (int j = 1; j < W - 1; j++) {\n            int valid = 1;\n            for (int di = -1; di <= 1; di++) {\n                for (int dj = -1; dj <= 1; dj++) {\n                    if (D[i + di][j + dj] == 0) {\n                        valid = 0;\n                        break;\n                    }\n                }\n                if (!valid) break;\n            }\n            if (valid) {\n                int temp_si = i, temp_sj = j;\n                int temp_D[MAX_H][MAX_W];\n                memcpy(temp_D, D, sizeof(temp_D));\n                int temp_ti, temp_tj;\n                simulate(temp_si, temp_sj, &temp_ti, &temp_tj);\n                int ok = 1;\n                for (int x = 0; x < H; x++) {\n                    for (int y = 0; y < W; y++) {\n                        if (temp_D[x][y] != 0) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (!ok) break;\n                }\n                if (ok) {\n                    *si = temp_si;\n                    *sj = temp_sj;\n                    *ti = temp_ti;\n                    *tj = temp_tj;\n                    return;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    int si, sj, ti, tj;\n    find_start_end(&si, &sj, &ti, &tj);\n\n    printf(\"%d %d %d %d\\n\", si, sj, ti, tj);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Point {\n    int i, j;\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> D(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> D[i][j];\n        }\n    }\n\n    vector<vector<int>> diff(H, vector<int>(W, 0));\n    for (int i = 1; i < H - 1; ++i) {\n        for (int j = 1; j < W - 1; ++j) {\n            int max_prev = 0;\n            for (int di = -1; di <= 1; ++di) {\n                for (int dj = -1; dj <= 1; ++dj) {\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (D[ni][nj] > max_prev) {\n                        max_prev = D[ni][nj];\n                    }\n                }\n            }\n            if (max_prev > 0) {\n                diff[i][j] = D[i][j] - (max_prev - 1);\n            } else {\n                diff[i][j] = D[i][j];\n            }\n        }\n    }\n\n    Point s = {-1, -1}, t = {-1, -1};\n    bool found_s = false;\n    for (int i = 1; i < H - 1; ++i) {\n        for (int j = 1; j < W - 1; ++j) {\n            if (diff[i][j] == 1) {\n                s.i = i;\n                s.j = j;\n                found_s = true;\n                break;\n            }\n        }\n        if (found_s) break;\n    }\n\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<Point> q;\n    q.push(s);\n    visited[s.i][s.j] = true;\n    Point last = s;\n\n    int di[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    int dj[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n    while (!q.empty()) {\n        Point current = q.front();\n        q.pop();\n        last = current;\n\n        for (int k = 0; k < 8; ++k) {\n            int ni = current.i + di[k];\n            int nj = current.j + dj[k];\n            if (ni >= 1 && ni < H - 1 && nj >= 1 && nj < W - 1 && !visited[ni][nj] && diff[ni][nj] > 0) {\n                visited[ni][nj] = true;\n                q.push({ni, nj});\n            }\n        }\n    }\n\n    t = last;\n\n    if (10000 * t.i + t.j > 10000 * s.i + s.j) {\n        swap(s, t);\n    }\n\n    cout << s.i << \" \" << s.j << \" \" << t.i << \" \" << t.j << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static int[][] D;\n    static int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1},\n                                 {0, -1},          {0, 1},\n                                 {1, -1},  {1, 0}, {1, 1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        D = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                D[i][j] = sc.nextInt();\n            }\n        }\n\n        int maxDamage = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (D[i][j] > maxDamage) {\n                    maxDamage = D[i][j];\n                }\n            }\n        }\n\n        List<int[]> candidates = new ArrayList<>();\n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                if (D[i][j] == maxDamage) {\n                    candidates.add(new int[]{i, j});\n                }\n            }\n        }\n\n        int[] s = null;\n        int[] t = null;\n        for (int[] candidate : candidates) {\n            int i = candidate[0];\n            int j = candidate[1];\n            boolean valid = true;\n            for (int di = -1; di <= 1; di++) {\n                for (int dj = -1; dj <= 1; dj++) {\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (D[ni][nj] < maxDamage - 1) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (!valid) break;\n            }\n            if (valid) {\n                t = new int[]{i, j};\n                break;\n            }\n        }\n\n        if (t == null) {\n            for (int[] candidate : candidates) {\n                int i = candidate[0];\n                int j = candidate[1];\n                boolean valid = true;\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        int ni = i + di;\n                        int nj = j + dj;\n                        if (D[ni][nj] < maxDamage) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (!valid) break;\n                }\n                if (valid) {\n                    t = new int[]{i, j};\n                    break;\n                }\n            }\n        }\n\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(t);\n        visited[t[0]][t[1]] = true;\n        int[] sCandidate = t;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int ci = current[0];\n            int cj = current[1];\n            sCandidate = current;\n\n            for (int[] dir : directions) {\n                int ni = ci + dir[0];\n                int nj = cj + dir[1];\n                if (ni >= 1 && ni < H - 1 && nj >= 1 && nj < W - 1 && !visited[ni][nj]) {\n                    if (D[ni][nj] == D[ci][cj] - 1) {\n                        visited[ni][nj] = true;\n                        queue.add(new int[]{ni, nj});\n                    }\n                }\n            }\n        }\n\n        s = sCandidate;\n        System.out.println(s[0] + \" \" + s[1] + \" \" + t[0] + \" \" + t[1]);\n    }\n}",
    "timestamp": "2025-08-05 21:59:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TyphoonSolution {\n    static int H, W;\n    static int[][] damage;\n    static int[][] dirs = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        damage = new int[H][W];\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                damage[i][j] = sc.nextInt();\n            }\n        }\n\n        for (int si = 1; si < H-1; si++) {\n            for (int sj = 1; sj < W-1; sj++) {\n                for (int ti = 1; ti < H-1; ti++) {\n                    for (int tj = 1; tj < W-1; tj++) {\n                        if (10000 * ti + tj <= 10000 * si + sj && checkTyphoonDamage(si, sj, ti, tj)) {\n                            System.out.println(si + \" \" + sj + \" \" + ti + \" \" + tj);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    static boolean checkTyphoonDamage(int si, int sj, int ti, int tj) {\n        int[][] tempDamage = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            tempDamage[i] = Arrays.copyOf(damage[i], W);\n        }\n\n        for (int di = -1; di <= 1; di++) {\n            for (int dj = -1; dj <= 1; dj++) {\n                int ni = si + di;\n                int nj = sj + dj;\n                tempDamage[ni][nj]++;\n            }\n        }\n\n        for (int di = -1; di <= 1; di++) {\n            for (int dj = -1; dj <= 1; dj++) {\n                int ni = ti + di;\n                int nj = tj + dj;\n                tempDamage[ni][nj]--;\n            }\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (tempDamage[i][j] != damage[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:59:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool is_valid(int y, int x, int H, int W) {\n    return y >= 0 && y < H && x >= 0 && x < W;\n}\n\nbool check_typhoon_damage(const vector<vector<int>>& grid, int sy, int sx, int H, int W) {\n    vector<vector<int>> damage_pattern = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};\n    \n    for (int dy = -1; dy <= 1; dy++) {\n        for (int dx = -1; dx <= 1; dx++) {\n            int ny = sy + dy;\n            int nx = sx + dx;\n            \n            if (!is_valid(ny, nx, H, W)) return false;\n            \n            if (damage_pattern[dy+1][dx+1] == 0) continue;\n            \n            if (grid[ny][nx] == 0) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<int>> grid(H, vector<int>(W));\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int best_s_i = -1, best_s_j = -1, best_t_i = -1, best_t_j = -1;\n    int min_score = INT_MAX;\n    \n    for (int sy = 0; sy < H; sy++) {\n        for (int sx = 0; sx < W; sx++) {\n            if (!check_typhoon_damage(grid, sy, sx, H, W)) continue;\n            \n            for (int ty = 0; ty < H; ty++) {\n                for (int tx = 0; tx < W; tx++) {\n                    if (10000 * ty + tx > 10000 * sy + sx) continue;\n                    \n                    vector<vector<int>> temp_grid = grid;\n                    \n                    for (int dy = -1; dy <= 1; dy++) {\n                        for (int dx = -1; dx <= 1; dx++) {\n                            int ny = sy + dy;\n                            int nx = sx + dx;\n                            \n                            if (!is_valid(ny, nx, H, W)) continue;\n                            \n                            if (temp_grid[ny][nx] > 0) {\n                                temp_grid[ny][nx]--;\n                            }\n                        }\n                    }\n                    \n                    bool all_zero = true;\n                    for (int i = 0; i < H; i++) {\n                        for (int j = 0; j < W; j++) {\n                            if (temp_grid[i][j] != 0) {\n                                all_zero = false;\n                                break;\n                            }\n                        }\n                        if (!all_zero) break;\n                    }\n                    \n                    if (all_zero) {\n                        int current_score = 10000 * sy + sx;\n                        if (current_score < min_score) {\n                            min_score = current_score;\n                            best_s_i = sy;\n                            best_s_j = sx;\n                            best_t_i = ty;\n                            best_t_j = tx;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << best_s_i << \" \" << best_s_j << \" \" << best_t_i << \" \" << best_t_j << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_typhoon_path(H, W, damage_status):\n    # Initialize variables\n    max_damage = ['no damage', 'minor damage', 'half-destroyed', 'destroyed']\n    position_damage = []\n\n    # Store the highest damage value with its position\n    for i in range(H):\n        for j in range(W):\n            damage_level = max_damage.index(damage_status[i][j])\n            position_damage.append((damage_level, i, j))\n\n    starting_positions = []\n    ending_positions = []\n\n    # Traverse through all positions to determine valid start and end points\n    for level, i, j in position_damage:\n        if 0 < i < H-1 and 0 < j < W-1:\n            if level == 3:  # area destroyed\n                starting_positions.append((i, j))\n            if level == 1:  # minor damage area\n                ending_positions.append((i, j))\n    \n    # Find valid location pair that satisfies condition\n    for s_i, s_j in starting_positions:\n        for t_i, t_j in ending_positions:\n            if 10000 * t_i + t_j <= 10000 * s_i + s_j:\n                return s_i, s_j, t_i, t_j\n\n# Read input values\nH, W = map(int, input().split())\ndamage_status = [input().split() for _ in range(H)]\n\n# Output the typhoon path\nprint(*find_typhoon_path(H, W, damage_status))",
    "timestamp": "2025-08-13 08:19:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine(); // Consume the remaining line break\n        \n        int[][] damage = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                damage[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int[] start = new int[]{0, 0, Integer.MAX_VALUE};\n        int[] end = new int[]{0, 0, -1};\n\n        for (int i = 1; i < H - 1; i++) {\n            for (int j = 1; j < W - 1; j++) {\n                int maxDamage = 0;\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        maxDamage = Math.max(maxDamage, damage[i + di][j + dj]);\n                    }\n                }\n                if (10000 * i + j < 10000 * start[0] + start[1]) {\n                    start[0] = i;\n                    start[1] = j;\n                    start[2] = maxDamage;\n                }\n                if (maxDamage > end[2] || (maxDamage == end[2] && 10000 * i + j > 10000 * end[0] + end[1])) {\n                    end[0] = i;\n                    end[1] = j;\n                    end[2] = maxDamage;\n                }\n            }\n        }\n        \n        System.out.println(start[0] + \" \" + start[1] + \" \" + end[0] + \" \" + end[1]);\n    }\n}",
    "timestamp": "2025-08-13 08:19:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nchar damage[MAX_H][MAX_W];\ntypedef struct {\n    int row, col;\n} Point;\n\nPoint start, tempLow;\nint minPos = INT_MAX;\n\nint dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint score(char status) {\n    switch (status) {\n        case 'N': return 0;\n        case 'M': return 1;\n        case 'H': return 2;\n        case 'D': return 3;\n        default: return 0;\n    }\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", damage[i]);\n    }\n\n    for (int i = 1; i < H - 1; i++) {\n        for (int j = 1; j < W - 1; j++) {\n            int initialScore = score(damage[i][j]);\n            int totalScore = initialScore;\n            for (int dir = 0; dir < 8; dir++) {\n                int ni = i + dx[dir];\n                int nj = j + dy[dir];\n                totalScore += score(damage[ni][nj]);\n            }\n            if (totalScore > initialScore) {\n                int startPos = 10000 * i + j;\n                if (startPos < minPos) {\n                    minPos = startPos;\n                    start.row = i;\n                    start.col = j;\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i < H - 1; i++) {\n        for (int j = 1; j < W - 1; j++) {\n            int initialScore = score(damage[i][j]);\n            int totalScore = initialScore;\n            for (int dir = 0; dir < 8; dir++) {\n                int ni = i + dx[dir];\n                int nj = j + dy[dir];\n                totalScore += score(damage[ni][nj]);\n            }\n            if (totalScore == initialScore && damage[i][j] != 'N') {\n                int tempLowPos = 10000 * i + j;\n                if (tempLowPos < minPos) {\n                    tempLow.row = i;\n                    tempLow.col = j;\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", start.row, start.col, tempLow.row, tempLow.col);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:19:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_typhoon_problem(H, W, damage_grid):\n    def is_valid_position(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    def apply_damage(r, c, grid):\n        for dr in range(-1, 2):\n            for dc in range(-1, 2):\n                nr, nc = r + dr, c + dc\n                if is_valid_position(nr, nc):\n                    if grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                    elif grid[nr][nc] == 1:\n                        grid[nr][nc] = 2\n                    elif grid[nr][nc] == 2:\n                        grid[nr][nc] = 3\n        return grid\n\n    def check_typhoon_path(start_r, start_c, end_r, end_c):\n        original_grid = [row[:] for row in damage_grid]\n        test_grid = [row[:] for row in damage_grid]\n\n        # Apply typhoon damage from start point\n        test_grid = apply_damage(start_r, start_c, test_grid)\n\n        # Apply typhoon damage from end point\n        test_grid = apply_damage(end_r, end_c, test_grid)\n\n        # Compare grids\n        return test_grid == original_grid\n\n    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]\n\n    for s_r in range(1, H-1):\n        for s_c in range(1, W-1):\n            for t_r in range(s_r-1, s_r+2):\n                for t_c in range(s_c-1, s_c+2):\n                    if (t_r, t_c) == (s_r, s_c):\n                        continue\n                    if not is_valid_position(t_r, t_c):\n                        continue\n                    if 10000 * t_r + t_c > 10000 * s_r + s_c:\n                        continue\n                    \n                    is_valid = check_typhoon_path(s_r, s_c, t_r, t_c)\n                    if is_valid:\n                        return f\"{s_r} {s_c} {t_r} {t_c}\"\n\n    return \"\"\n\n# Read input\nH, W = map(int, input().split())\ndamage_grid = [list(map(int, input().split())) for _ in range(H)]\n\n# Solve and print result\nresult = solve_typhoon_problem(H, W, damage_grid)\nprint(result)",
    "timestamp": "2025-08-13 08:19:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    H, W = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(H)]\n    \n    # Directions: 8 neighborhood\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1),  (1, 0), (1, 1)]\n    \n    # Find all possible centers (1 <= i < H-1, 1 <= j < W-1)\n    possible_centers = []\n    for i in range(1, H-1):\n        for j in range(1, W-1):\n            possible_centers.append((i, j))\n    \n    # Check all possible paths\n    for s_i, s_j in possible_centers:\n        visited = set()\n        queue = [(s_i, s_j, [(s_i, s_j)])]\n        visited.add((s_i, s_j))\n        \n        while queue:\n            ci, cj, path = queue.pop(0)\n            \n            # Check if current center is a possible t_i, t_j\n            # The condition is that the damage pattern matches the path\n            # So simulate the damage along the path and compare with the grid\n            temp_grid = [[0 for _ in range(W)] for _ in range(H)]\n            for (ti, tj) in path:\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        ni, nj = ti + di, tj + dj\n                        if 0 <= ni < H and 0 <= nj < W:\n                            if temp_grid[ni][nj] < 4:\n                                temp_grid[ni][nj] += 1\n            \n            match = True\n            for i in range(H):\n                for j in range(W):\n                    if temp_grid[i][j] != grid[i][j]:\n                        match = False\n                        break\n                if not match:\n                    break\n            \n            if match:\n                t_i, t_j = path[-1]\n                if 10000 * t_i + t_j <= 10000 * s_i + s_j:\n                    print(s_i, s_j, t_i, t_j)\n                    return\n            \n            # Explore next possible moves\n            for di, dj in directions:\n                ni, nj = ci + di, cj + dj\n                if 1 <= ni < H-1 and 1 <= nj < W-1 and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    new_path = path.copy()\n                    new_path.append((ni, nj))\n                    queue.append((ni, nj, new_path))\n    \n    # If no solution found (should not happen as per problem statement)\n    print(-1, -1, -1, -1)\n\nsolve()",
    "timestamp": "2025-08-13 08:19:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint H, W;\nvector<vector<int>> damage;\n\nbool isValid(int i, int j) {\n    return i > 0 && i < H - 1 && j > 0 && j < W - 1;\n}\n\nvoid applyTyphoon(int i, int j, bool apply) {\n    for (int di = -1; di <= 1; ++di) {\n        for (int dj = -1; dj <= 1; ++dj) {\n            if (apply)\n                damage[i + di][j + dj]--;  // Reverse typhoon's damage\n            else\n                damage[i + di][j + dj]++;  // Simulate typhoon's damage\n        }\n    }\n}\n\nbool verify(int start_i, int start_j, int end_i, int end_j) {\n    for (int i = end_i; i <= start_i; ++i) {\n        for (int j = end_j; j <= start_j; ++j) {\n            if (isValid(i, j)) {\n                applyTyphoon(i, j, true);\n            }\n        }\n    }\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (damage[i][j] != 0) {\n                for (int a = end_i; a <= start_i; ++a) {\n                    for (int b = end_j; b <= start_j; ++b) {\n                        if (isValid(a, b)) {\n                            applyTyphoon(a, b, false);  // Revert changes\n                        }\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin >> H >> W;\n    damage.resize(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> damage[i][j];\n        }\n    }\n\n    for (int start_i = 1; start_i < H - 1; ++start_i) {\n        for (int start_j = 1; start_j < W - 1; ++start_j) {\n            for (int end_i = 1; end_i <= start_i; ++end_i) {\n                for (int end_j = 1; end_j <= start_j; ++end_j) {\n                    if (verify(start_i, start_j, end_i, end_j)) {\n                        cout << start_i << \" \" << start_j << \" \" << end_i << \" \" << end_j << endl;\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:44:57"
  }
]