[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\n\nobject Main {\n  def cross(x0:Double, y0:Double, x1:Double, y1:Double) = x0*y1-x1*y0\n  def inner(x0:Double, y0:Double, x1:Double, y1:Double) = x0*x1+y0*y1\n  def norm(x:Double, y:Double) = x*x+y*y\n\n  def dir(x0:Double,y0:Double,x1:Double,y1:Double) =\n    if(cross(x0,y0,x1,y1) > (1e-10)) (-1)\n    else if(cross(x0,y0,x1,y1) < -(1e-10)) 1\n    else if(inner(x0,y0,x1,y1) < -(1e-10)) 1\n    else if(norm(x0,y0) < norm(x1,y1)) 0\n    else 0\n\n  def intersect(x0:Double,y0:Double,x1:Double,y1:Double,x2:Double,y2:Double,x3:Double,y3:Double) = {\n   (dir(x2-x0,y2-y0,x1-x0,y1-y0) * dir(x3-x0,y3-y0,x1-x0,y1-y0) <= 0) &&\n    (dir(x1-x2,y1-y2,x3-x2,y3-y2) * dir(x0-x2,y0-y2,x3-x2,y3-y2) <= 0)\n  }\n\n  def main(args:Array[String]) = {\n    val n = readInt\n    for(i<-0 until n) {\n      val s = readLine.split(\" \").map(_.toDouble)\n      if(intersect(s(0),s(1),s(2),s(3),s(4),s(5),s(6),s(7))) println(1)\n      else println(0)\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main {\n\n  case class Point(x: Double = 0, y: Double = 0) {\n\n    def +(p: Point): Point = Point(this.x + p.x, this.y + p.y)\n\n    def -(p: Point): Point = Point(this.x - p.x, this.y - p.y)\n\n    def *(a: Double): Point = Point(this.x * a, this.y * a)\n\n    def /(a: Double): Point = {\n      assert(a == 0)\n      Point(this.x / a, this.y / a)\n    }\n\n    def norm(): Double = this.x * this.x + this.y * this.y\n\n    def abs(): Double = scala.math.sqrt(norm())\n\n    def <(p: Point): Boolean = this.x < p.x && this.y < p.y\n\n\n    def ==(p: Point): Boolean = scala.math.abs(this.x - p.x) < Cgl0A.EPS &&\n      scala.math.abs(this.y - p.y) < Cgl0A.EPS\n\n\n  }\n\n  case class Segment(p1: Point, p2: Point)\n\n  case class Line(p1: Point, p2: Point)\n\n  type GeoVector = Point\n\n  object Cgl0A {\n    val EPS: Double = scala.math.pow(10, -10)\n\n    // 内積\n    def dot(a: Point, b: Point): Double = a.x * b.x + a.y * b.y\n\n    def isOrthogonal(a: GeoVector, b: GeoVector): Boolean = dot(a, b) == 0.0\n\n    def isOrthogonal(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isOrthogonal(a1 - a2, b1 - b2)\n    }\n\n    def isOrthogonal(s1: Segment, s2: Segment): Boolean = {\n      dot(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    // 外積\n    def cross(a: Point, b: Point): Double = a.x * b.y - a.y * b.x\n\n    def isParallel(a: GeoVector, b: GeoVector): Boolean = cross(a, b) == 0.0\n\n    def isParallel(a1: Point, a2: Point, b1: Point, b2: Point): Boolean = {\n      isParallel(a1 - a2, b1 - b2)\n    }\n\n    def isParallel(s1: Segment, s2: Segment): Boolean = {\n      cross(s1.p2 - s1.p1, s2.p2 - s2.p1) == 0.0\n    }\n\n    def project(s: Segment, p: Point): Point = {\n      val base: GeoVector = s.p2 - s.p1\n      val r: Double = Cgl0A.dot(p - s.p1, base) / base.norm()\n      s.p1 + base * r\n    }\n\n    def reflect(s: Segment, p: Point): Point = {\n      p + (project(s, p) - p) * 2.0\n    }\n\n    def getDistance(a: Point, b: Point): Double = (a - b).abs()\n\n    def getDistanceLP(l: Line, a: Point): Double = {\n      scala.math.abs(cross(l.p2 - l.p1, a - l.p1) / (l.p2 - l.p1).abs())\n    }\n\n    def getDistanceSP(s: Segment, a: Point): Double = {\n      if (dot(s.p2 - s.p1, a - s.p1) < 0.0) (a - s.p1).abs()\n      else if (dot(s.p1 - s.p2, a - s.p2) < 0.0) (a - s.p2).abs()\n      else getDistanceLP(s.asInstanceOf[Line], a)\n    }\n\n    val COUNTER_CLOCKWISE: Int = 1\n    val CLOCKWISE: Int = -1\n    val ONLINE_BACK: Int = 2\n    val ONLINE_FRONT: Int = -2\n    val ON_SEGMENT: Int = 0\n\n    def ccw(p0: Point, p1: Point, p2: Point): Int = {\n      val a: GeoVector = p1 - p0\n      val b: GeoVector = p2 - p0\n\n      if (cross(a, b) > EPS) COUNTER_CLOCKWISE\n      else if (cross(a, b) < -1 * EPS) CLOCKWISE\n      else if (dot(a, b) < -1 * EPS) ONLINE_BACK\n      else if (a.norm() < b.norm()) ONLINE_FRONT\n      else ON_SEGMENT\n\n    }\n\n    def intersect(p1: Point, p2: Point, p3: Point, p4: Point): Boolean = {\n      Cgl0A.ccw(p1, p2, p3) * Cgl0A.ccw(p1, p2, p4) <= 0 &&\n        Cgl0A.ccw(p3, p4, p1) * Cgl0A.ccw(p3, p4, p2) <= 0\n    }\n    def intersect(s1: Segment, s2: Segment): Boolean = {\n      Cgl0A.intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n    }\n\n  }\n\n\n  def main(args: Array[String]): Unit = {\n    val q = StdIn.readLine().toInt\n    (0 until q).foreach { i =>\n      val a = StdIn.readLine().split(' ').map(_.toDouble)\n      val p1 = Point(a(0), a(1))\n      val p2 = Point(a(2), a(3))\n      val p3 = Point(a(4), a(5))\n      val p4 = Point(a(6), a(7))\n\n      if(Cgl0A.intersect(p1, p2, p3, p4)) println(\"1\")\n      else println(\"0\")\n\n\n    }\n\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define eps 1e-9\n#define double long long\nusing namespace std;\nstruct point{\n\tdouble x,y;\n\tvoid read(){scanf(\"%lld%lld\",&x,&y);}\n\tvoid write(){printf(\"%.9f %.9f\\n\",x,y);}\n\tpoint(double X=0.0,double Y=0.0):x(X),y(Y){}\n\tpoint operator +(const point a)const{return point(x+a.x,y+a.y);}\n\tpoint operator -(const point a)const{return point(x-a.x,y-a.y);}\n\tpoint operator *(double a)const{return point(x*a,y*a);}\n\tpoint operator /(double a)const{return point(x/a,y/a);} \n};\ndouble dis(point a){return a.x*a.x+a.y*a.y;}\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\ndouble cross3(point o,point a,point b){return cross(a-o,b-o);}\nbool jiao(point a,point b,point c,point d)\n{\n\tif(min(a.x,b.x)>max(c.x,d.x) || min(a.y,b.y)>max(c.y,d.y)) return false;\n\tif(min(c.x,d.x)>max(a.x,b.x) || min(c.y,d.y)>max(a.y,b.y)) return false;\n\tif(cross3(a,b,c)*cross3(a,b,d)>0) return false;\n\tif(cross3(c,d,a)*cross3(c,d,b)>0) return false;\n\treturn true;\n}\npoint p1,p2,p3,p4;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tp1.read();p2.read();p3.read();p4.read();\n\t\tprintf(\"%d\\n\",jiao(p1,p2,p3,p4));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Computational_Geometry\n{\n\tconst long double eps=1e-10;\n\tstruct Vector2\n\t{\n\t\tlong double x,y;\n\t\tVector2(long double X=0.0,long double Y=0.0):x(X),y(Y) {}\n\t\tVector2 *read() {scanf(\"%Lf%Lf\",&x,&y); return this;}\n\t\tvoid print() {printf(\"%.10Lf %.10Lf\",x,y); return;}\n\t\tinline Vector2 operator - () const{return Vector2(-x,-y);}\n\t\tinline Vector2 operator + (const Vector2 &A) const{return Vector2(x+A.x,y+A.y);}\n\t\tinline Vector2 operator - (const Vector2 &A) const{return Vector2(x-A.x,y-A.y);}\n\t\tinline Vector2 operator * (const long double &k) const{return Vector2(x*k,y*k);}\n\t\tinline Vector2 operator / (const long double &k) const{return Vector2(x/k,y/k);}\n\t\tinline long double operator * (const Vector2 &A) const{return x*A.x+y*A.y;}\n\t\tinline long double operator ^ (const Vector2 &A) const{return x*A.y-y*A.x;}\n\t\tinline long double norm2() const{return x*x+y*y;}\n\t\tinline long double norm() const{return sqrtl(x*x+y*y);}\n\t\tinline bool operator < (const Vector2 &A) const{return (x<A.x-eps)||(x<=A.x+eps)&&(y<A.y-eps);}\n\t\tinline bool operator == (const Vector2 &A) const{return fabsl(x-A.x)<=eps&&fabsl(y-A.y)<=eps;}\n\t\tinline bool operator << (const Vector2 &A) const{return (y<-eps)^(A.y<-eps)?A.y<-eps:((*this^A)>eps)||((*this^A)>=-eps)&&(x>=-eps)&&(A.x<-eps);}\n\t\tinline Vector2 trans(long double a_11,long double a_12,long double a_21,long double a_22) const{return Vector2(x*a_11+y*a_12,x*a_21+y*a_22);}\n\t};\n\t#define Point Vector2\n\t\n\tPoint Projection(Point P,Point L1,Point L2)\n\t{\n\t\tlong double k1=(L2-L1)*(P-L1),k2=(L2-L1).norm2();\n\t\treturn L1+((L2-L1)*(k1/k2));\n\t}\n\t\n\tPoint Reflection(Point P,Point L1,Point L2)\n\t{\n\t\tlong double k1=(L2-L1)*(P-L1),k2=(L2-L1).norm2();\n\t\tPoint mid=L1+(L2-L1)*(k1/k2);\n\t\treturn mid*2-P;\n\t}\n\t\n/*\n\tCOUNTER_CLOCKWISE 1\n\tCLOCKWISE 2\n\tONLINE_BACK 3\n\tONLINE_FRONT 4\n\tON_SEGMENT 5\n*/\n\tint Counter_Clockwise(Point S,Point T1,Point T2)\n\t{\n\t\tif(((T1-S)^(T2-S))>eps) return 1;\n\t\telse if(((T1-S)^(T2-S))<-eps) return 2;\n\t\telse if(((T1-S)*(T2-S))<-eps) return 3;\n\t\telse if(((T2-S).norm2()-(T1-S).norm2())>eps) return 4;\n\t\telse return 5;\n\t}\n\t\n\tint Parallel(Point S1,Point T1,Point S2,Point T2)\n\t{\n\t\treturn fabs((T1-S1)^(T2-S2))<=eps;\n\t}\n\tint Orthogonal(Point S1,Point T1,Point S2,Point T2)\n\t{\n\t\treturn fabs((T1-S1)*(T2-S2))<=eps;\n\t}\n/*\n\tPARALLEL 1\n\tORTHOGONAL 2\n\tOTHER 3\n*/\n\tint Parallel_Orthogonal(Point S1,Point T1,Point S2,Point T2)\n\t{\n\t\tif(Parallel(S1,T1,S2,T2)) return 1;\n\t\telse if(Orthogonal(S1,T1,S2,T2)) return 2;\n\t\telse return 3;\n\t}\n\t\n\tint Counter_Clockwise_Bool(Point S,Point T1,Point T2)\n\t{\n\t\tif(((T1-S)^(T2-S))>eps) return 1;\n\t\telse if(((T1-S)^(T2-S))<-eps) return -1;\n\t\telse if(((T1-S)*(T2-S))<-eps) return -1;\n\t\telse if(((T2-S).norm2()-(T1-S).norm2())>eps) return 1;\n\t\telse return 0;\n\t}\n\tint Intersection(Point S1,Point T1,Point S2,Point T2)\n\t{\n\t\treturn Counter_Clockwise_Bool(S1,T1,S2)*Counter_Clockwise_Bool(S1,T1,T2)<=0&&Counter_Clockwise_Bool(S2,T2,S1)*Counter_Clockwise_Bool(S2,T2,T1)<=0;\n\t}\n};\nusing namespace Computational_Geometry;\nPoint P,P0,P1,S0,S1,T0,T1;\nint Q;\nint main()\n{\n\tscanf(\"%d\",&Q);\n\twhile(Q--)\n\t{\n\t\tS0.read(),T0.read(),S1.read(),T1.read();\n\t\tprintf(\"%d\\n\",Intersection(S0,T0,S1,T1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct vec{\n    double x,y;\n    vec operator-(vec b){\n        vec& a = *this;\n        vec c;\n        c.x=a.x-b.x;c.y=a.y-b.y;\n        return c;\n    }\n};\n\nconst double eps = 0.0000001;\n\ndouble inner_product(vec& a, vec& b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble outer_product(vec& a, vec& b){\n    return a.x*b.y-a.y*b.x;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = outer_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isInterSection(vec (&p)[4]){\n    switch(ccw(p[0],p[1],p[2])*ccw(p[0],p[1],p[3])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n    switch(ccw(p[2],p[3],p[0])*ccw(p[2],p[3],p[1])){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return false;\n    }\n   return true;\n}\n\nint main(void){\n    vec p[4];\n    int q;\n    cin >> q;\n    while(q--){\n        for(auto& v : p) cin >> v.x >> v.y;\n        if(isInterSection(p)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2) // P0, P1, P2 counter_clockwise.\n{\n\tdouble d1 = (p1.x - p0.x) * (p2.y - p0.y);\n\tdouble d2 = (p2.x - p0.x) * (p1.y - p0.y);\n\tif(d1 == d2) return 0;\n\treturn (d1 > d2 ? 1 : -1);\n}\n\ndouble inpro(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vx) + (v1.vy * v2.vy);\n}\n\ndouble det2(const Vector &v1, const Vector &v2)\n{\n\treturn (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\nbool crit(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n\tif((p0.x > p2.x) && (p0.x > p3.x) && (p1.x > p2.x) && (p1.x > p3.x)) return true;\n\tif((p0.x < p2.x) && (p0.x < p3.x) && (p1.x < p2.x) && (p1.x < p3.x)) return true;\n\n\tif((p0.y > p2.y) && (p0.y > p3.y) && (p1.y > p2.y) && (p1.y > p3.y)) return true;\n\tif((p0.y < p2.y) && (p0.y < p3.y) && (p1.y < p2.y) && (p1.y < p3.y)) return true;\n\treturn false;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n\t\tVector V01 = set_v(P0, P1), V23 = set_v(P2, P3);\n\t\tif(ccw(P0, P1, P2) * ccw(P0, P1, P3) > 0 || ccw(P2, P3, P0) * ccw(P2, P3, P1) > 0){\n\t\t\tprintf(\"0\\n\");\n\t\t}else {\n\t\t\tif(det2(V01, V23) == 0 && crit(P0, P1, P2, P3)){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t}\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// Geometry {{{\nconst long double EPS = 1e-10;\nconst long double PI = acos(-1);\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Real {\n    long double x;\n\n    Real(long double x = 0) : x(x) {}\n    Real(const Real& rhs) { x = rhs.x; }\n\n    Real operator+(const Real& rhs) const { return Real(x + rhs.x); }\n    Real& operator+=(const Real& rhs) { return x += rhs.x, *this; }\n    Real operator-(const Real& rhs) const { return Real(x - rhs.x); }\n    Real& operator-=(const Real& rhs) { return x -= rhs.x, *this; }\n    Real operator*(const Real& rhs) const { return Real(x * rhs.x); }\n    Real& operator*=(const Real& rhs) { return x *= rhs.x, *this; }\n    Real operator/(const Real& rhs) const { return Real(x / rhs.x); }\n    Real& operator/=(const Real& rhs) { return x /= rhs.x, *this; }\n    Real operator-() const { return Real(-x); }\n    Real& operator++() { return ++x, *this; }\n    Real& operator--() { return --x, *this; }\n    Real operator++(int) { Real tmp(x); return ++x, tmp; }\n    Real operator--(int) { Real tmp(x); return --x, tmp; }\n    bool operator==(const Real& rhs) const { return fabs(x - rhs.x) < EPS; }\n    bool operator!=(const Real& rhs) const { return !(*this == rhs); }\n    bool operator<(const Real& rhs) const { return (*this == rhs) ? false : x < rhs.x; }\n    bool operator>(const Real& rhs) const { return (*this == rhs) ? false : x > rhs.x; }\n    bool operator<=(const Real& rhs) const { return (*this == rhs) ? true : x < rhs.x; }\n    bool operator>=(const Real& rhs) const { return (*this == rhs) ? true : x > rhs.x; }\n\n    friend istream& operator>>(istream& is, Real& rhs) {\n        is >> rhs.x;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Real& rhs) {\n        os << rhs.x;\n        return os;\n    }\n\n    friend Real pow(const Real& n, const Real& p) { return pow(n.x, p.x); }\n    friend Real pow(Real n, intmax_t p) {\n        Real ret = 1;\n        for (; p > 0; p >>= 1) {\n            if (p & 1) ret *= n;\n            n *= n;\n        }\n        return ret;\n    }\n    friend Real abs(const Real& rhs) { return abs(rhs.x); }\n    friend Real sin(const Real& rhs) { return sin(rhs.x); }\n    friend Real cos(const Real& rhs) { return cos(rhs.x); }\n    friend Real tan(const Real& rhs) { return tan(rhs.x); }\n    friend Real asin(const Real& rhs) { return asin(rhs.x); }\n    friend Real acos(const Real& rhs) { return acos(rhs.x); }\n    friend Real atan(const Real& rhs) { return atan(rhs.x); }\n    friend Real atan2(const Real& lhs, const Real& rhs) { return atan2(lhs.x, rhs.x); }\n    friend Real sqrt(const Real& rhs) { return sqrt(rhs.x); }\n    friend Real ceil(const Real& rhs) { return ceil(rhs.x); }\n    friend Real floor(const Real& rhs) { return floor(rhs.x); }\n    friend Real round(const Real& rhs) { return round(rhs.x); }\n};\n\nusing real_t = Real;\n\nstruct Point {\n    real_t x, y;\n\n    Point(real_t x = 0, real_t y = 0) : x(x), y(y) {}\n\n    Point operator+(const Point& rhs) const { return Point(x + rhs.x, y + rhs.y); }\n    Point operator-(const Point& rhs) const { return Point(x - rhs.x, y - rhs.y); }\n    Point operator*(const real_t& rhs) const { return Point(x * rhs, y * rhs); }\n    Point operator/(const real_t& rhs) const { return Point(x / rhs, y / rhs); }\n    Point operator-() const { return Point(-x, -y); }\n    bool operator==(const Point& rhs) const { return x == rhs.x && y == rhs.y; }\n    bool operator!=(const Point& rhs) const { return !(*this == rhs); }\n    bool operator<(const Point& rhs) const { return (x == rhs.x) ? y < rhs.y : x < rhs.x; }\n    bool operator>(const Point& rhs) const { return (x == rhs.x) ? y > rhs.y : x > rhs.x; }\n    bool operator<=(const Point& rhs) const { return (*this == rhs) ? true : *this < rhs; }\n    bool operator>=(const Point& rhs) const { return (*this == rhs) ? true : *this > rhs; }\n\n    friend istream& operator>>(istream& is, Point& rhs) {\n        is >> rhs.x >> rhs.y;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Point& rhs) {\n        os << rhs.x << ' ' << rhs.y;\n        return os;\n    }\n};\n\nusing Vector = Point;\n\nreal_t norm(const Vector& a) { return a.x * a.x + a.y * a.y; }\nreal_t len(const Vector& a) { return sqrt(norm(a)); }\nreal_t dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\nreal_t cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n    Point p1, p2;\n\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator==(const Segment& rhs) const { return p1 == rhs.p1 && p2 == rhs.p2; }\n    bool operator!=(const Segment& rhs) const { return !(*this == rhs); }\n\n    friend istream& operator>>(istream& is, Segment& rhs) {\n        is >> rhs.p1 >> rhs.p2;\n        return is;\n    }\n    friend ostream& operator<<(ostream& os, const Segment& rhs) {\n        os << rhs.p1 << ' ' << rhs.p2;\n        return os;\n    }\n};\n\nusing Line = Segment;\n\nreal_t len(const Segment& s) { return len(s.p1 - s.p2); }\n\nbool isParallel(const Vector& a, const Vector& b) {\n    return cross(a, b) == 0.0;\n}\nbool isParallel(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(const Segment& s1, const Segment& s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isOrthogonal(const Vector& a, const Vector& b) {\n    return dot(a, b) == 0.0;\n}\nbool isOrthogonal(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(const Segment& s1, const Segment& s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(const Segment& s, const Point& p) {\n    const Vector base = s.p2 - s.p1;\n    const Vector hypo = p - s.p1;\n    const real_t r = dot(hypo, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > 0.0) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < 0.0) return CLOCKWISE;\n    if (dot(a, b) < 0) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint reflect(const Segment& s, const Point& p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\nreal_t getDistancePP(const Point& p1, const Point& p2) {\n    return len(p2 - p1);\n}\n\nreal_t getDistanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / len(l.p2 - l.p1));\n}\n\nreal_t getDistanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return getDistancePP(p, s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return getDistancePP(p, s.p2);\n    return getDistanceLP(s, p);\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n\n    var(size_t, Q);\n\n    while (Q--) {\n        var(Segment, s1, s2);\n        output((intersect(s1, s2)) ? 1 : 0);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nbool are_crossing(complex<double> a1, complex<double> a2, complex<double> b1, complex<double> b2){\n    double ta = (a1.real() - a2.real()) * (b1.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b1.real());\n    double tb = (a1.real() - a2.real()) * (b2.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b2.real());\n    double tc = (b1.real() - b2.real()) * (a1.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a1.real());\n    double td = (b1.real() - b2.real()) * (a2.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a2.real());\n    return (ta*tb <= 0.0 && tc*td <= 0.0);\n}\n\nint main(){\n    int q;\n    cin >> q;\n    double re, im;\n    vector< complex<double> > v(4);\n    for(int i=0;i<q;i++){\n        for(int j=0;j<4;j++){\n            cin >> re >> im;\n            v[j].real(re);\n            v[j].imag(im);\n        }\n        cout << are_crossing(v[0], v[1], v[2], v[3]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>eps) return 1;\n\t\tif(Getmp<-eps) return 2;\n\t\tif(IP(Ge1,Ge2)<eps) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tif(four_JUD(Gex.first,Gex.second,Gey.first,Gey.second)){\n\t\t\tint Ge1=PJUD(Gex.first,Gey.first,Gex.second),Ge2=PJUD(Gex.first,Gey.second,Gex.second),Ge3=PJUD(Gey.first,Gex.first,Gey.second),Ge4=PJUD(Gey.first,Gex.second,Gey.second);\n\t\t\tcout<<Ge1<<' '<<Ge2<<' '<<Ge3<<' '<<Ge4<<endl;\n\t\t\tif((Ge1==3||Ge1==4)&&(Ge2==3||Ge2==4)&&(Ge3==3||Ge3==4)&&(Ge4==3||Ge4==4)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif(LJUD(Gex,Gey)==2) return 0;\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tbool four_JUD(point Gea,point Geb,point Gec,point Ged){\n\t\tint Ge1=PJUD(Gea,Geb,Gec),Ge2=PJUD(Gea,Geb,Ged);\n\t\tif(Ge1!=1&&Ge1!=2&&Ge2!=1&&Ge2!=2) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n幾何\nhttps://gist.github.com/zeptometer/3719669\n複素数平面による幾何ライブラリ←もっと短くなる可能生アリ\nhttp://osrehun.hatenadiary.jp/entry/2016/12/31/145827\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n//+++++++++++円++++++++++++++++//\n\n//円cと直線lの交点\n//abs(l,c.p)<c.r+EPSが必要\npair<P,P> crossPoint(const Line &l,const Circle &c){\n    P pr=project(c.p,l);\n    V e=(l.b-l.a)/(abs(l.b-l.a));\n    DD base=sqrt(c.r*c.r-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//線分sと円cの交点\nvector<P> crossPointSC(const Segment &s,const Circle &c){\n    vector<P> ret;\n    if(dis(c.p,s)>=c.r+EPS) return ret;\n    auto p=crossPoint(s,c);\n    if(dot(p.first-s.a,s.b-s.a)>0 && dot(p.first-s.b,s.a-s.b)>0) ret.push_back(p.first);\n    if(dot(p.second-s.a,s.b-s.a)>0 && dot(p.second-s.b,s.a-s.b)>0) ret.push_back(p.second);\n    if(xy(s.a,s.b)) sort(ret.begin(),ret.end(),xy);\n    else sort(ret.rbegin(),ret.rend(),xy);\n    return ret;\n}\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(const Circle &a,const Circle &b){\n    DD d=abs(a.p-b.p);\n    if(d>a.r+b.r+EPS) return 4;\n    if(eq(d,a.r+b.r)) return 3;\n    if(eq(d,abs(a.r-b.r))) return 1;\n    if(d<abs(a.r-b.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\nvector<P> crossPoint(const Circle &a,const Circle &b){\n    vector<P> ret;\n    if(abs(a.p-b.p)<a.r+b.r+EPS) return ret;\n    DD d=abs(a.p-b.p);\n    DD s=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    DD t=arg(b.p-a.p);\n    if(eq(s,0)) ret.emplace_back(a.p+polar(a.r,t+s));\n    else ret.emplace_back(a.p+polar(a.r,t+s)),ret.emplace_back(a.p+polar(a.r,t-s));\n    return ret;\n}\n\n//pがcの外にあるかの判定が必要\nvector<P> TanLine(const P &p,const Circle &c){\n    vector<P> ret;\n    DD d=abs(p-c.p);\n    if(d<=c.r-EPS) return ret;\n    if(eq(d,c.r)){\n        ret.push_back(p);\n        return ret;\n    } \n    return crossPoint(c,Circle(p,sqrt(d*d-c.r*c.r)));\n}\n//https://ei1333.github.io/luzhiled/snippets/geometry/template.html\n//↑すごい。丸写し\n//円c1,c2の共通接線\n//接点をつないで線にしている(１個だけ追加するときに注意)\nvector<Line> TanLine(Circle a,Circle b){\n    vector<Line> ret;\n    if(a.r<b.r) swap(a,b);\n    DD g=abs(a.p-b.p);\n    if(eq(g,0)) return ret;\n    V u=(b.p-a.p)/g;\n    V v=rotate(u,PI*0.5);\n    for(DD s:{-1,1}){\n        DD h=(a.r+s*b.r)/g;\n        if(eq(1-h*h,0)){\n            ret.emplace_back(a.p+u*a.r,a.p+(u+v)*a.r);\n        }else if(1-h*h>0){\n            V uu=u*h,vv=v*sqrt(1-h*h);\n            ret.emplace_back(a.p+(uu+vv)*a.r,b.p-(uu+vv)*b.r*s);\n            ret.emplace_back(a.p+(uu-vv)*a.r,b.p-(uu-vv)*b.r*s);\n        }\n    }\n    return ret;\n}\n\n/*+++++++++++++++++++三角形+++++++++++++++++*/\n//外心\n//isParallel()を使って判定を忘れずに\nP circumcenter(const P &a,const P &b,const P &c){\n    P ab=(a+b)/2.0,bc=(b+c)/2.0;\n    Segment s(ab,ab+polar(1.0,arg(b-a)+PI*0.5));\n    Segment t(bc,bc+polar(1.0,arg(c-b)+PI*0.5));\n    return crossPoint(s,t);\n}\n\n/*+++++++++++++++++++多角形+++++++++++++++++++*/\n//IN:2 ON:1 OUT:0\n//点がどの位置にあるか\nint contains(const P &p,const Polygon &g){\n    int n=(int)g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        V a=g[i]-p,b=g[(i+1)%n]-p;\n        if(eq(cross(a,b),0) && dot(a,b)<EPS) return 1;\n        if(imag(a)>imag(b)) swap(a,b);\n        if(imag(a)<EPS && EPS<imag(b) && cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n//凸性判定\nbool isConvex(const Polygon &g){\n    int n=(int)g.size();\n    int flag=0;\n    int t;\n    for(int i=0;i<n;i++){\n        V a(g[(i+1)%n]-g[i]),b(g[(i+2)%n]-g[i]);\n        if(cross(a,b)>EPS) t=1;\n        else if(cross(a,b)<-EPS) t=-1;\n        else continue;\n        if(flag==-t) return false;\n        flag=t;\n    }\n    return true;\n}\n\n//凸包　アンドリューのアルゴリズム\n//https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp←螺旋本より早そう\n//j=1:返上の点を含まない　j=-1:含む\n//反時計回りの多角形を返す\n//sはソートされる\nPolygon ConvexHull(Polygon &s,const int j){\n    int sz=(int)s.size();\n    if(sz<3) return s;\n    sort(s.begin(),s.end(),yx);\n\n    int n=0;\n    Polygon res(2*sz);\n    for(int i=0;i<sz;i++){\n        while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    int t=n+1;\n    for(int i=sz-2;i>=0;i--){\n        while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    res.resize(n-1);\n    return res;\n}\n\n//符号付き面積\n//反時計回りの図形なら正\n//https://imagingsolution.net/math/calc_n_point_area/\nDD Area(const Polygon &g){\n    DD ret=0.0;\n    int n=(int)g.size();\n    for(int i=0;i<n;i++){\n        ret+=cross(g[i],g[(i+1)%n]);\n    }\n    return ret/2.0L;\n}\n\n//反時計回り\n//理解が浅い←大体分かった（本当か？）\nDD Diameter(Polygon g){\n    g=ConvexHull(g,1);\n    int gz=g.size();\n    int m=0,M=0;\n    for(int i=1;i<gz;i++){\n        if(imag(g[i])<imag(g[m])) m=i;\n        if(imag(g[i])>imag(g[M])) M=i;\n    }\n    DD ret=0;\n    int sm=m,sM=M;\n    while(m!=sM || M!=sm){\n        ret=max(ret,norm(g[m]-g[M]));\n        if(cross(g[(m+1)%gz]-g[m],g[(M+1)%gz]-g[M])<0) m=(m+1)%gz;\n        else M=(M+1)%gz;\n    }\n    return sqrt(ret);\n}\n\n//凸多角形gをlで切断\n//l.p1-l.p2の左側\n//gは反時計回り→反時計回りで返す\n//時計回り→時計回り\nPolygon ConvexCut(const Polygon &g,const Line &l){\n    Polygon ret;\n    int gz=(int)g.size();\n    for(int i=0;i<gz;i++){\n        P now=g[i],next=g[(i+1)%gz];\n        if(ccw(l.a,l.b,now)>=0) ret.push_back(now);\n        if(ccw(l.a,l.b,now)*ccw(l.a,l.b,next)<0){\n            ret.push_back(crossPoint(Line(now,next),l));\n        }\n    }\n    return ret;\n}\n\ninline DD calc(const P &a,const P &b,const DD &r,const bool triangle){\n    if(triangle) return cross(a,b);\n    else return r*r*arg(b-a);\n}\n\nDD calcArea(const DD &r,const P &a,const P &b){\n    if(eq(abs(a-b),0)) return 0;\n    bool ina=abs(a)<r+EPS;\n    bool inb=abs(b)<r+EPS;\n    if(ina && inb) return cross(a,b);\n    auto cr=crossPointSC(Segment(a,b),Circle((0,0),r));\n    if(cr.empty()) return calc(a,b,r,false);\n    auto s=cr[0],t=cr.back();\n    return calc(s,t,r,true)+calc(a,s,r,ina)+calc(t,b,r,inb);\n}\n\n//円と多角形の共通部分の面積\n//http://drken1215.hatenablog.com/entry/2020/02/02/091000\nDD Area(const Circle &c,const Polygon &g){\n    DD ret=0.0;\n    int gz=g.size();\n    if(gz<3) return ret;\n    for(int i=0;i<gz;i++){\n        P a=g[i]-c.p,b=g[(i+1)%gz]-c.p;\n        ret+=calcArea(c.r,g[i]-c.p,g[(i+1)%gz]-c.p);\n    }\n    return ret/2.0;\n}\n\n//++++なんか凄いの+++++++++++++++\n\n//最近点対\nDD RecClosetPair(Polygon::iterator it,const int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    DD x=real(it[m]);\n    DD d=min(RecClosetPair(it,m),RecClosetPair(it+m,n-m));\n    inplace_merge(it,it+m,it+n,yx);\n    Polygon v;\n    for(int i=0;i<n;i++){\n        if(abs(real(it[i])-x)>=d) continue;\n        for(int j=0;j<v.size();j++){\n            DD dy=imag(it[i])-imag(v[v.size()-1-j]);\n            if(dy>=d) break;\n            DD dx=real(it[i])-real(v[v.size()-1-j]);\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        v.push_back(it[i]);\n    }\n    return d;\n}\n\nDD ClosetPair(Polygon g){\n    sort(g.begin(),g.end(),xy);\n    return RecClosetPair(g.begin(),g.size());\n}\n\n\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n\n    int Q;\n    cin>>Q;\n    while(Q--){\n        int x[4],y[4];\n        vector<P> p;\n        for(int i=0;i<4;i++) cin>>x[i]>>y[i],p.emplace_back(x[i],y[i]);\n        if(intersect(p[0],p[1],p[2],p[3])) cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(p2) < std::norm(p3)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0;\n}\n\n#endif\n\n#include <iostream>\nusing namespace std;\nint q, xa, ya, xb, yb; Segment s1, s2;\nint main() {\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> xa >> ya >> xb >> yb; s1 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tcin >> xa >> ya >> xb >> yb; s2 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tif (intersect(s1, s2, true)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum DIRECTION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE};\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nDIRECTION get_direction(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    return ONLINE;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_direction(s1.p1, s2) == get_direction(s1.p2, s2)) {\n        return false;\n    }\n    if (get_direction(s2.p1, s1) == get_direction(s2.p2, s2)) {\n        return false;\n    }\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nint get_direction(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return  1;\n    if (cross < -1e-10) return -1;\n    return 0;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_direction(s1.p1, s2) == 0 && get_direction(s1.p2, s2) == 0) {\n        Vector base = s2.p2 - s2.p1;\n        Vector a1   = s1.p1 - s2.p1;\n        Vector a2   = s1.p1 - s2.p1;\n        double norm_b  = get_dot(base, base);\n        double norm_a1 = get_dot(a1, a1);\n        double norm_a2 = get_dot(a2, a2);\n        if (norm_b < norm_a1 && norm_b < norm_a2) return false;\n        return true;\n    }\n    if (get_direction(s1.p1, s2) * get_direction(s1.p2, s2) > 0) {\n        return false;\n    }\n    if (get_direction(s2.p1, s1) *  get_direction(s2.p2, s1) > 0) {\n        return false;\n    }\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <vector>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn ~ccw(l.p1, l.p2, p) & 1;\n\t// ONLINE_BACK or ONLINE_FRONT or ON_SEGMENT\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn ccw(s.p1, s.p2, p) == ON_SEGMENT;\n}\n\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(std::abs(c1.p - c2.p), c1.r + c2.r)) return OUT;\n\tif (LT(std::abs(c1.p - c2.p), c2.r)) return IN;\n\tif (LT(std::abs(c1.p - c2.p), c1.r)) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\n\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\twhile (q--){\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << intersectSS(s1, s2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x=0, double y=0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/ a, y/ a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x, y*y; }\n    bool operator < (const Point &p) const {\n\treturn x != p.x ? x<p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p0, p1;\n};\n\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble norm(Vector a) {\n    return a.x*a.x + a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\n/*\n  ???????????§??????????????¨??????????????°??????\n  |a*b|=|a||b|sin(theta)\n */\ndouble cross(Vector a, Vector b){ \n    return a.x*b.y - a.y*b.x;\n}\n\n/*const?????????????????????????????????*/\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ON_SEGMENT = 0;\nconst int ONLINE_FRONT = 2;\nconst int ONLINE_BACK = 2;\n\nint ccw(Point p0, Point p1, Point p2){\n    if (cross(p1-p0, p2-p0) > EPS) return COUNTER_CLOCKWISE;\n    else if (cross(p1-p0, p2-p0) < -EPS) return CLOCKWISE;\n    else if (dot(p1-p0,p2-p0) < -EPS) return ONLINE_BACK;\n    else if (norm(p1-p0) < norm(p2-p0)) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\n/*\n  intersect\n  ?????¨?????????????????¢???????????£????????????????????????\n  ????????????????¨?????????????????¨???????????????????????????°OK\n*/\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return ((ccw(p0,p1, p2) * ccw(p0,p1,p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2,p3,p1) <=0));\n}\n\nint main() {\n    int n,i,d;\n    \n    Point p0, p1, p2,p3;\n    cin >> n;\n    for(i=0;i<n;i++){\n\tcin >>  p0.x>> p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n\tif (intersect(p0,p1,p2,p3)) cout << \"1\" << endl;\n\telse cout << \"0\" << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n\n    \n    if(a1*b2==a2*b1)return false;//平行の判定\n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    if(a*x1+b*y1+c==0){//(x1,y1)が直線上にある.\n        *x2=x1;\n        *y2=y1;\n        return;\n    }\n    \n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    //cout<<a1<<\" \"<<b1<<\" \"<<c1<<endl;\n    //cout<<a2<<\" \"<<b2<<\" \"<<c2<<endl;\n    if(is_parallel==false){\n        if( (a1*b2==b1*a2&&c1==c2) || (a1==0 && (b1*c2)==(c1*b2)) || (b1==0 && (a1*c2)==(c1*a2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return /*2*M_PI- */ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    \n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    if(x1==x2&&y1==y2)return 0.0;\n    if(x3==x2&&y3==y2)return 0.0;\n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    double ret = 2*M_PI-( angle+(M_PI-angle2) );\n    if(ret<0)ret+=2*M_PI;\n    if(ret>=2*M_PI)ret-=2*M_PI;\n    \n    \n    \n    return ret;\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用前に sort(a, a+n); をおこなう*/\n/*使用注意 他と仕様が違う*/\n/*点にpairを使っている*/\n\n\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double> >b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n//-------------------------------------------------------------------------------------\n/* 2点(x1,y1) (x2,y2)を通る直線に点(px,py)から引いた垂線の直線との交点(x, y)を返す */\nvoid intersection_of_the_normal_to_the_straight_line_passing_through_the_two_points(double px,double py,double x1, double y1,double x2, double y2,double *x, double *y){\n    double a,b,c;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    *x = px-(a*px+b*py+c)/(a*a+b*b)*a;\n    *y = py-(a*px+b*py+c)/(a*a+b*b)*b;\n}\n                                      \nint main(){\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    double a,b,c,d,e,f;\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        //straight_line_passing_through_the_two_points(x0, y0, x1, y1, &a, &b, &c);\n        //straight_line_passing_through_the_two_points(x2, y2, x3, y3, &d, &e, &f);\n        cout<<line_segment_cross_decision(x0, y0, x1, y1, x2, y2, x3, y3)<<endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>0) return 1;\n\t\tif(Getmp<0) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tif(EXTLEN(Gex.first,Gex.second)>=EXTLEN(Getmp,Gex.first)&&EXTLEN(Gey.first,Gey.second)>=EXTLEN(Getmp,Gey.first)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\ndouble x,xx,y,yy,xxx,yyy;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <complex>\n#include <vector>\n#include <cmath>\n\nconst double EPS=1e-10;\n\n#define equals(a, b) (fabs((a)-b(b))<EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0) :\n        c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base) / norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p+(project(s,p)-p)*2.0;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main() {\n    int q;\n    cin>>q;\n    while(q-->0) {\n        double x1,y1;\n        double x2,y2;\n        double x3,y3;\n        double x4,y4;\n        cin>>x1>>y1;\n        cin>>x2>>y2;\n        cin>>x3>>y3;\n        cin>>x4>>y4;\n        Segment s1=Segment({Point(x1,y1),Point(x2,y2)});\n        Segment s2=Segment({Point(x3,y3),Point(x4,y4)});\n        if(intersect(s1,s2)) {\n            cout<<\"1\"<<endl;\n        }\n        else cout<<\"0\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\n//円周率\nstatic const double pi = 3.141592653589793;\n//幾何の問題で入力が多い時に使用\n#define scan(x) scanf(\"%ld\", &x)\n\n//誤差チェッカー\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n//点を表わす構造体\nstruct Point\n{\npublic:\n    double x, y;\n    Point(double _x, double _y) : x(_x), y(_y) {}\n    /*\n    以下ベクトルに対する演算子の定義\n    +:ベクトルの足し算\n    -:ベクトルの引き算\n    *:スカラー倍\n    /:スカラーの逆数倍\n    */\n    Point operator+(const Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(const double k) { return Point(x * k, y * k); }\n    Point operator/(const double k) { return Point(x / k, y / k); }\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n    //ベクトルの比較(x軸方向のベクトルから比較)\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator>(const Point &p) const\n    {\n        return x != p.x ? x > p.x : y > p.y;\n    }\n    bool operator==(const Point &p) const\n    {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    bool operator!=(const Point &p) const\n    {\n        return (!equals(x, p.x)) || (!equals(y, p.y));\n    }\n};\n//ベクトルとして扱う場合\ntypedef Point Vector;\n//線分を表わす構造体\nstruct Segment\n{\n    Point p1, p2;\n    Segment(Point _p1, Point _p2) : p1(_p1), p2(_p2) {}\n};\n//直線として扱う場合\ntypedef Segment Line;\n//ベクトルのノルム\ndouble norm(Vector a)\n{\n    return a.x * a.x + a.y * a.y;\n}\n//ベクトルの大きさ\ndouble abs(Vector a)\n{\n    return sqrt(norm(a));\n}\n//ベクトルの内積\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n//内積≓0かどうかによるベクトルの直交判定(様々な引数で答えられるように複数用意)\nbool Orthogonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);\n}\nbool Orthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return Orthogonal(a1 - a2, b1 - b2);\n}\nbool Orthogonal(Segment s1, Segment s2)\n{\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n//外積≓0かどうかによるベクトルの平行判定(様々な引数で答えられるように複数用意)\nbool Parallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);\n}\nbool Parallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return Parallel(a1 - a2, b1 - b2);\n}\nbool Parallel(Segment s1, Segment s2)\n{\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n//直線sに対して点ｐから垂線を引いたときの交点x(直線sに対する点pの射影)を求める\nPoint Project(Line s, Point p)\n{\n    Vector base = s.p2 - s.p1, hypo = p - s.p1;\n    double scalar = (dot(base, hypo) / norm(base));\n    return s.p1 + base * scalar;\n}\n//直線sに対して点pと線対称の位置にある点p'を求める\nPoint Reflect(Line s, Point p)\n{\n    return p + (Project(s, p) - p) * 2.0;\n}\n//点と点の距離\ndouble GetDist(Point a, Point b)\n{\n    return abs(a - b);\n}\n//直線と点の距離\ndouble GetDistLP(Line l, Point p)\n{\n    return abs(Project(l, p) - p);\n}\n//線分と点の距離\ndouble GetDistSP(Segment s, Point p)\n{\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n        return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n        return abs(p - s.p2);\n    return GetDistLP(s, p);\n}\n//Counter-Clockwise(AOJ:CGL_1_Cより)\nstatic const int COUNTER_CLOCKWISE = 1; //反時計回り\nstatic const int CLOCKWISE = -1;        //時計回り\nstatic const int ONLINE_BACK = 2;       //線分の後ろにある\nstatic const int ONLINE_FRONT = -2;     //線分の前にある\nstatic const int ON_SEGMENT = 0;        //線分上にある\n//線分p0p1と点p2の位置関係を求める\nint CCW(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0, b = p2 - p0; //a:p0->p1,b:p0->p2\n    if (cross(a, b) > EPS)\n        return COUNTER_CLOCKWISE; //外積が正なら反時計回り(sinθ>0)\n    if (cross(a, b) < -EPS)\n        return CLOCKWISE; //外積が負なら時計回り(sinθ<0)\n    if (dot(a, b) < -EPS)\n        return ONLINE_BACK; //外積が0かつ内積が負(cosθ<0)\n    if (a.norm() < b.norm())\n        return ONLINE_FRONT; //p2がp0p1に含まれないときp0p2=p0p1+p1p2となり|a|^2<|b|^2が成立\n    return ON_SEGMENT;       //最後にp0p2p1が残る\n}\n//2本の線分の交差判定(点と線分で2種類用意)\nbool Intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (CCW(p1, p2, p3) * CCW(p1, p2, p4) <= 0 && CCW(p3, p4, p1) * CCW(p3, p4, p2) <= 0);\n}\nbool Intersect(Segment s1, Segment s2)\n{\n    return Intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//線分と線分の距離\ndouble GetDist(Segment s1, Segment s2)\n{\n    //線分が交差していた場合、距離は0.0\n    if (Intersect(s1, s2))\n        return 0.0;\n    return min(min(GetDistSP(s1, s2.p1), GetDistSP(s1, s2.p2)), min(GetDistSP(s2, s1.p1), GetDistSP(s2, s1.p2)));\n}\n//座標cを中心とする半径rの円を表わす構造体\nstruct Circle\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point _c, double _r) : c(_c), r(_r) {}\n};\n\n//多角形は点の列として扱う\ntypedef vector<Point> Polygon;\nint main()\n{\n    cout << fixed << setprecision(30);\n    /*\n    double a1, a2, b1, b2;\n    cin >> a1 >> a2 >> b1 >> b2;\n    Point p1(a1, a2), p2(b1, b2);\n    Segment s(p1, p2);\n    */\n    ll q;\n    cin >> q;\n    loop(i, q)\n    {\n        vector<double> p(8);\n        loop(j, 8) cin >> p[j];\n        Point p1(p[0], p[1]), p2(p[2], p[3]);\n        Point p3(p[4], p[5]), p4(p[6], p[7]);\n        Segment s1(p1, p2), s2(p3, p4);\n        if (Intersect(s1, s2))\n            putout(1);\n        else\n            putout(0);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#include <random>\n#include <bitset>\n\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, double> pld;\ntypedef pair<double, double> pdd;\ntypedef pair<double, ll> pdl;\ntypedef pair<int, char> pic;\ntypedef vector<ll> vl;\ntypedef vector<int> vi;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> llgreaterq;\ntypedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;\ntypedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;\ntypedef priority_queue<vi, vector<vi>, greater<vi>> vigreaterq;\ntypedef priority_queue<vl, vector<vl>, greater<vl >> vlgreaterq;\n#define bit(x,v) ((ll)x << v)\n#define rep(x,v) for(ll x=0;x<v;x++)\n#define rep2(x,f,v) for(ll x=f;x<v;x++)\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (std::abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define all(a) a.begin(),a.end()\n#define all0(a) memset(a,0,sizeof(a))\nconst ll INF = 1000000007;\nconst int MAX = 2000010;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[200010];\nint lank[200010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nint same(int x, int y) {\n\treturn parent(x) == parent(y);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (lank[px] < lank[py]) {\n\t\tpr[py] = px;\n\t\tlank[px] += lank[py] + 1;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t\tlank[py] += lank[px] + 1;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char>* a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char>* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll* a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char>* a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char>* a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nll n;\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode* parent, * left, * right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node* t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node* t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node* t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node* t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]) {\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H / 2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\n\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,-1,0,1 };\nstd::vector<int> find_all(const std::string str, const std::string subStr) {\n\tstd::vector<int> result;\n\n\tint subStrSize = subStr.size();\n\tint pos = str.find(subStr);\n\n\twhile (pos != std::string::npos) {\n\t\tresult.push_back(pos);\n\t\tpos = str.find(subStr, pos + 1);\n\t}\n\n\treturn result;\n}\n//ll memo[100010];\n//ll next[100010];\n//ll dm[100010];\n//int f[100010];\n//ll rec(int x) {\n//\n//\tif (~memo[x]) return memo[x];\n//\tif (x == n) { \n//\t\tdm[n] = 1;\n//\t\treturn 1; \n//\t}\n//\tll *res = &memo[x];\n//\t*res = 0;\n//\tset<int> st;\n//\tst.insert(f[x]);\n//\tfor (int i = x + 1; i <= n; i++)\n//\t{\n//\t\tif (~memo[i]) {\n//\t\t\t*res += memo[i] + 1;\n//\t\t\t*res %= INF;\n//\t\t\tbreak;\n//\t\t}\n//\n//\t\t*res += rec(i);\n//\t\t*res %= INF;\n//\t\tif (st.find(f[i]) != st.end()) {break; }\n//\t\tst.insert(f[i]);\n//\t}\n//\n//\treturn *res;\n//}\n#define bit(x,v) ((ll)x << v)\n\nclass BIT {\n\n\tstatic const int MAX_N = 1000010;\npublic:\n\tBIT() { memset(bit, 0, sizeof(bit)); }\n\tint bit[MAX_N + 1], n;\n\tint sum(int i) {\n\t\tint s = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, int x) {\n\t\twhile (i <= n)\n\t\t{\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tvoid clear() {\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\tint a[MAX_N];\n\tvoid bable_swap_count() {\n\t\tll ans = 0;\n\t\tfor (size_t j = 0; j < n; j++)\n\t\t{\n\t\t\tans += j - sum(a[j]);\n\t\t\tadd(a[j], 1);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\tint search(int s, int x) {\n\n\t\tll half = (s + x) / 2;\n\t\tll sh = sum(x);\n\n\t\tll sl = sum(half);\n\n\t\tll st = sum(s);\n\t\tif (sh - sl == 0) {\n\t\t\treturn x;\n\t\t}\n\t\tif (sh - sl < x - half) {\n\t\t\treturn search(half, x);\n\t\t}\n\n\t\tif (sl - st == 0) {\n\t\t\treturn half;\n\t\t}\n\n\t\tif (sl - st < half - s) {\n\t\t\treturn search(s, half);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint lankSearch(int lank) {\n\t\treturn lankSearch(lank, 0, MAX_N);\n\t}\n\tint lankSearch(int lank, int s, int t) {\n\n\t\tll half = (s + t) / 2;\n\n\t\tll v = sum(half);\n\t\tll v1 = sum(t);\n\t\tll v2 = sum(s);\n\t\tif (lank == 1) {\n\t\t\tif (s + 1 >= t) return t;\n\t\t\telse if (v - v2 > 0) {\n\t\t\t\treturn lankSearch(lank, s, half);\n\t\t\t}\n\t\t\telse return lankSearch(lank, half, t);\n\t\t}\n\n\t\tif ((v - v2) < lank) {\n\t\t\treturn lankSearch(lank - (v - v2), half, t);\n\t\t}\n\t\tif ((v - v2) >= lank) {\n\t\t\treturn lankSearch(lank, s, half);\n\t\t}\n\n\t\treturn -1;\n\t}\n};\n\nclass BIT2 {\n\n\tstatic const int MAX_N = 1000010;\npublic:\n\tBIT2() { memset(bit, 0, sizeof(bit)); }\n\tll bit[MAX_N + 1], n;\n\tll gmax(int i) {\n\t\tll s = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\ts = max(bit[i], s);\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid add(int i, ll x) {\n\t\twhile (i <= n)\n\t\t{\n\t\t\tbit[i] = max(bit[i], x);\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tvoid clear() {\n\t\tmemset(bit, 0, sizeof(bit));\n\t}\n\n};\nvector<ll> getp(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\t\tres.push_back(2);\n\t\twhile (n % 2 == 0)n /= 2;\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\twhile (n % i == 0)n /= i;\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<ll> getp2(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tif (n % 2 == 0) {\n\n\t\twhile (n % 2 == 0) { n /= 2; res.push_back(2); }\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\n\t\t\twhile (n % i == 0) { n /= i; res.push_back(i); }\n\t\t}\n\t}\n\tif (n != 1) res.push_back(n);\n\treturn res;\n}\nvector<pll> getp3(ll n) {\n\n\tvector<pll> res;\n\tll a = 2;\n\tint cnt = 0;\n\tif (n % 2 == 0) {\n\t\tres.push_back(make_pair(2, 0));\n\t\twhile (n % 2 == 0) { n /= 2; res[cnt].second++; }\n\t\tcnt++;\n\t}\n\n\tfor (ll i = 3; i * i <= n; i += 2)\n\t{\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(make_pair(i, 0));\n\t\t\twhile (n % i == 0) { n /= i; res[cnt].second++; }\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (n != 1) res.push_back(make_pair(n, 1));\n\treturn res;\n}\nvector<ll> getDivisors(ll n) {\n\n\tvector<ll> res;\n\tll a = 2;\n\tres.push_back(1);\n\tfor (ll i = 2; i * i <= n; i++)\n\t{\n\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (n / i != i)\n\t\t\t\tres.push_back(n / i);\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct ve {\npublic:\n\tvector<ve> child;\n\tint _t = INF;\n\tve(int t) :_t(t) {}\n\tve(ve _left, ve _right) {\n\t\t_t = _left._t + _right._t;\n\t\tchild.push_back(_left);\n\t\tchild.push_back(_right);\n\t}\n\tbool operator<(const ve& t) const {\n\t\treturn _t > t._t;\n\t}\n};\n\nvector<bool> elas(ll n) {\n\tvector<bool> r(n);\n\tfor (ll i = 3; i < n; i += 2)\n\t{\n\t\tr[i] = 1;\n\t}\n\tr[0] = 0;\n\tr[1] = 0;\n\tr[2] = 1;\n\tfor (ll i = 3; i * i < n; i += 2)\n\t{\n\t\tif (!r[i]) continue;\n\t\tll ti = i * 2;\n\t\twhile (ti < n)\n\t\t{\n\t\t\tr[ti] = false;\n\t\t\tti += i;\n\t\t}\n\t}\n\treturn r;\n}\nbool isprime(ll v) {\n\tfor (ll i = 2; i * i <= v; i++)\n\t{\n\t\tif (v % i == 0) return false;\n\t}\n\treturn true;\n}\n\nll lcm(vector<ll> v) {\n\tif (v.size() == 0) return 0;\n\tll t = v[0];\n\tfor (size_t i = 1; i < v.size(); i++)\n\t{\n\t\tt = v[i] * t / gcd(v[i], t);\n\t}\n\treturn t;\n}\nll eulerphi(ll n) {\n\tauto p = getp(n);\n\tdouble u = n;\n\tfor (auto v : p) {\n\t\tu *= (double)(v - 1) / (double)v;\n\t}\n\treturn u;\n}\n\ndouble revs(double x) {\n\tll dig = 0;\n\tstringstream st;\n\tst << std::fixed << setprecision(0) << x;\n\tstring v = st.str();\n\treverse(v.begin(), v.end());\n\treturn stod(v);\n}\nbool chkparindrome(double x) {\n\tstringstream st;\n\tst << std::fixed << setprecision(0) << x;\n\tstring p = st.str();\n\tfor (size_t i = 0; i < p.size() / 2; i++)\n\t{\n\t\tif (p[i] != p[p.size() - i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nll digitC(double x) {\n\tstringstream st;\n\tst << fixed << setprecision(0) << x;\n\treturn st.str().size();\n}\nll digitSum(double x) {\n\tstringstream st;\n\tst << std::fixed << x;\n\tstring p = st.str();\n\tll rs = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t{\n\t\tif (p[i] == '.') break;\n\t\trs += p[i] - '0';\n\t}\n\treturn rs;\n}\npdd recs(int x) {\n\n\tif (x == 0) return make_pair(1, 2);\n\tpdd d = recs(x - 1);\n\tauto nu = d.second * 2.0 + d.first;\n\tauto de = d.second;\n\treturn make_pair(de, nu);\n}\nll caldig(ll a) {\n\tll r = 0;\n\twhile (a > 0) { a /= 10; r++; }\n\treturn r;\n}\nint chav(char v) {\n\tif (v <= 'Z') return v - 'A';\n\treturn v - 'a' + 26;\n}\nchar itoch(int i) {\n\tif (i < 26) return i + 'A';\n\treturn (i - 26) + 'a';\n}\nint crmp[1000][1000];\nint countR(ll base, ll x, ll y, int deep) {\n\n\tif (~crmp[x][y]) {\n\t\treturn deep - crmp[x][y];\n\t}\n\tcrmp[x][y] = deep;\n\tdouble nu = sqrt(base) + x;\n\tdouble de = (base - (x * x)) / y;\n\tll u = nu / de;\n\tll nx = x - (u * de);\n\treturn countR(base, -nx, de, deep + 1);\n}\n\nbool isPermutation(ll x, ll y) {\n\tint c1[10];\n\tint c2[10];\n\tmemset(c1, 0, sizeof(c1));\n\tmemset(c2, 0, sizeof(c2));\n\twhile (x > 0)\n\t{\n\t\tc1[x % 10]++;\n\t\tx /= 10;\n\t}\n\twhile (y > 0)\n\t{\n\t\tc2[y % 10]++;\n\t\ty /= 10;\n\t}\n\n\tfor (size_t i = 0; i < 10; i++)\n\t{\n\t\tif (c1[i] != c2[i]) return false;\n\t}\n\treturn true;\n}\n\ndouble heron(ll a, ll b, ll c) {\n\tdouble s = (double)(a + b + c) / 2.0;\n\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\ndouble calcThreePS(double x1, double y1, double x2, double y2, double x3, double y3) {\n\treturn abs((x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1) / 2.0);\n}\ntypedef vector<vl> mat;\nclass Matrix1 {\n\npublic:\n\tstatic const int M = INF;\n\tint n;\n\tmat mul(mat& A, mat& B) {\n\t\tmat C(A.size(), vl(B[0].size()));\n\t\tfor (size_t i = 0; i < A.size(); i++)\n\t\t{\n\t\t\tfor (size_t k = 0; k < B.size(); k++)\n\t\t\t{\n\t\t\t\tfor (size_t j = 0; j < B[0].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tC[i][j] = (C[i][j] + A[i][k] * B[k][j]) % M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn C;\n\t}\n\n\tmat pow(mat A, ll n) {\n\t\tmat B(A.size(), vl(A.size()));\n\t\tfor (size_t i = 0; i < A.size(); i++)\n\t\t{\n\t\t\tB[i][i] = 1;\n\t\t}\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) B = mul(B, A);\n\t\t\tA = mul(A, A);\n\t\t\tn >>= 1;\n\t\t}\n\n\n\t\treturn B;\n\t}\n\n};\nll m;\nll stringDivRm(string s, ll k) {\n\n\tll v = 0;\n\t\n\tfor (size_t i = 0; i < s.size(); i++)\n\t{\n\t\tv *= 10;\n\t\tv += s[i] - '0';\n\t\tv %= k;\n\t}\n\treturn v;\n}\n\nll repPow(ll b, ll x,ll md) {\n\tll res = 1;\n\tll v = b;\n\n\twhile (x > 0)\n\t{\n\t\tif (x & 1) {\n\t\t\tres *= v;\n\t\t\tres %= md;\n\t\t}\n\t\tv *= v;\n\t\tv %= md;\n\t\tx >>= 1;\n\t}\n\n\treturn res;\n}\nll repPow(ll b, ll x) {\n\treturn repPow(b, x, INF);\n}\nll uar[1000010];\nll upr(ll u, ll r) {\n\treturn (fac[u] * finv[u-r]) % INF;\n}\nll partitionMemo[20010][110];\nll partitionNum(ll v, ll k) {\n\tif (k == 1) return 1;\n\tif (v <= 1) return 1;\n\tif (~partitionMemo[v][k]) return partitionMemo[v][k];\n\tll r = 0;\n\tif (v < k) {\n\t\tr = partitionNum(v,v);\n\t}\n\telse\n\t\tr = partitionNum(v, k - 1) + partitionNum(v - k, k);\n\tr %= INF;\n\n\treturn partitionMemo[v][k] = r;\n}\n\nclass SetTree1 {\n\npublic:\n\tstatic const int MAX_N = 100000;\n\tstatic const int MAX_Q = 100000;\n\tint N, Q;\n\tstatic const int DAT_SIZE = (1 << 18) - 1;\n\tint A[MAX_N];\n\tchar T[MAX_Q];\n\n\tll data[DAT_SIZE];\n\tvoid init(int _n) {\n\t\tmemset(data, 0, sizeof(data));\n\t\tint p = 1;\n\t\twhile (p < _n)\n\t\t{\n\t\t\tp <<= 1;\n\t\t}\n\t\tN = p;\n\t\tQ = N - 1;\n\t}\n\tvoid update(int a, int b) {\n\n\t\tfor (size_t i = a; i <= b; i++)\n\t\t{\n\t\t\tupdate(Q + i);\n\t\t}\n\t}\n\tvoid update(int a) {\n\n\t\tint x = data[a];\n\t\twhile (a > 0)\n\t\t{\n\t\t\tif (a % 2 == 0)a--;\n\t\t\ta >>= 1;\n\t\t\tdata[a] += x;\n\t\t}\n\t}\n\tvoid add(int a, int b, int x) {\n\t\tadd(a, b + 1, x, 0,0,N);\n\t}\n\tvoid add(int a, int b, int x, int k, int l, int r) {\n\t\tif (a <= l && r <= b) {\n\t\t\tdata[k] += x;\n\t\t}\n\t\telse if (l < b && a < r) {\n\t\t\tdata[k] += (min(b, r) - max(a, l)) * x;\n\t\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\t}\n\t}\n\tll sum(int a, int b) {\n\t\treturn sum(a, b + 1, 0, 0, N);\n\t}\n\tll sum(int a, int b, int k, int l, int r) {\n\t\tif (b <= l || r <= a) return 0;\n\t\telse if (a <= l && r <= b) {\n\t\t\treturn data[k];\n\t\t}\n\t\telse {\n\t\t\tll res = 0;\n\t\t\tres += sum(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tres += sum(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n};\nclass Segment;\nclass Circle;\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\tstatic double dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\tstatic double cross(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tstatic bool isOrthogonal(Point a, Point b) {\n\t\treturn EQ(dot(a, b), 0.0);\n\t}\n\tstatic bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(a1 - a2, b1 - b2);\n\t}\n\tstatic bool isOrthogonal(Segment s1, Segment s2);\n\n\tstatic bool isPalallel(Point a, Point b) {\n\t\treturn EQ(cross(a, b), 0.0);\n\t}\n\tstatic bool isPalallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isPalallel(a1 - a2, b1 - b2);\n\t}\n\tstatic bool isPalallel(Segment s1, Segment s2);\n\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\tstatic const int CLOCKWISE = -1;\n\tstatic const int ONLINE_BACK = 2;\n\tstatic const int ONLINE_FRONT = -2;\n\tstatic const int ON_SEGMENT = 0;\n\tstatic int ccw(Point p0, Point p1, Point p2) {\n\t\tPoint a = p1 - p0;\n\t\tPoint b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\n\tstatic bool intersect(Point p1, Point p2, Point p3, Point p4) {\n\t\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n\t}\n\tstatic bool intersect(Segment s1, Segment s2);\n\tstatic Point project(Segment s, Point p);\n\n\tstatic Point reflect(Segment s, Point p);\n\n\tstatic Point getDistance(Point a, Point b) {\n\t\treturn (a - b).abs();\n\t}\n\n\tstatic double getDistanceLP(Segment s, Point p);\n\n\tstatic double getDistanceSP(Segment s, Point p);\n\n\tstatic double getDistance(Segment s1, Segment s2);\n\n\tstatic Point getIntersection(Segment s1, Segment s2);\n\n\tstatic pair<Point, Point> crossPoints(Circle c, Segment s);\n\n\tstatic int contains(vector<Point> g, Point p) {\n\t\tint n = g.size();\n\t\tbool x = false;\n\t\trep(i, n) {\n\t\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\t\t// 線の上に載っているか\n\t\t\tif (std::abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\n\t\t\t// pを基準として上下にあるか\n\t\t\t// または外積が正か?(→にあるか)\n\t\t\tif (a.y > b.y) swap(a, b);\n\t\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t\t}\n\t\treturn x ? 2 : 0;\n\t}\n\n\tstatic vector<Point> andrewScan(vector<Point> s) {\n\t\tvector<Point> u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(all(s));\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\n\t\tfor (int i = 2; i < s.size(); i++) {\n\n\t\t\tfor (int _n = u.size(); _n >= 2 && ccw(u[_n - 2], u[_n - 1], s[i]) != CLOCKWISE; _n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\n\t\t\tfor (int _n = l.size(); _n >= 2 && ccw(l[_n - 2], l[_n - 1], s[i]) != CLOCKWISE; _n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\n\t\treverse(all(l));\n\t\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\t{\n\t\t\tl.push_back(u[i]);\n\t\t}\n\n\t\treturn l;\n\t}\n\n\tstatic double getArea(vector<Point> g) {\n\t\tdouble res = 0;\n\t\trep(i, n) {\n\t\t\tint ne = (i + 1) % n;\n\t\t\tres += cross(g[i], g[ne]);\n\t\t}\n\t\treturn res / 2.0;\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\tPoint p1tp2() { return p2 - p1; }\n\tPoint p2tp1() { return p1 - p2; }\n\tdouble norm() {\n\t\treturn (p2 - p1).norm();\n\t}\n};\n\nbool Point::isOrthogonal(Segment s1, Segment s2) {\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool Point::isPalallel(Segment s1, Segment s2) {\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool Point::intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint Point::project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tdouble r = Point::dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint Point::reflect(Segment s, Point p) {\n\treturn (project(s, p) * 2) - p;\n}\ndouble Point::getDistanceLP(Segment s, Point p) {\n\treturn std::abs(cross(s.p2 - s.p1, p - s.p1) / (s.p2 - s.p1).abs());\n}\ndouble Point::getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble Point::getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)\n\t\t,getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2) });\n}\nPoint Point::getIntersection(Segment s1, Segment s2) {\n\t// (s1.p1 - s2.p1).norm()\n\tauto bs = s1.p2 - s1.p1;\n\tauto n1 = s2.p1 - s1.p1;\n\tauto n2 = s2.p2 - s1.p1;\n\tauto c1 = std::abs(cross(n1, bs)) / bs.norm();\n\tauto c2 = std::abs(cross(n2, bs)) / bs.norm();\n\treturn s2.p1 + (s2.p2 - s2.p1) * (c1 / (c1 + c2));\n\t// c1:c2=t:1-t\n\t// c2t=(1-t)c1\n\t// t/(1-t)=c1/(c1+c2)\n\t// \n}\n\n\ndouble arg(Point p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\tstatic pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\t\tdouble d = (c1.c - c2.c).abs(); // 中心点どうしの距離\n\t\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\t\tdouble t = arg(c2.c - c1.c);\n\t\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n\n\t}\n};\n\npair<Point, Point> Point::crossPoints(Circle c, Segment s) {\n\tauto pp = project(s, c.c);\n\tauto f = (pp - c.c).norm();\n\tauto mu = sqrt(c.r * c.r - f);\n\tauto e = s.p1tp2() / s.p1tp2().abs();\n\treturn make_pair(pp + e * mu, pp - e * mu);\n\n}\n\nll count(vector<ll> v, ll x) {\n\tll res = 0;\n\tll si = v.size();\n\trep(i, v.size()) {\n\t\tll p = lower_bound(all(v), x / v[i] + (x % v[i] > 0 ? 1 : 0)) - v.begin();\n\t\tif (i < p) p--;\n\t\tres += max(p - i,0LL);\n\t}\n\treturn res;\n}\nvoid solv() {\n\n\tcin >> n;\n\trep(i, n) {\n\t\tSegment s;\n\t\tcin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n\t\tSegment s2;\n\t\tcin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tif (Point::intersect(s, s2)) {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse\n\t\t\tcout << 0 << endl;\n\t}\n\n}\t\n\nint main() {\n\t//COMinit();\n\tsolv();\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\nusing namespace std;\n\ntypedef complex<double> Point, Vector;\ntypedef pair<Point, Point> Segment, Line;\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\ndouble dot(Vector a, Vector b){\n    return a.X * b.X + a.Y * b.Y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.first, s1.second, s2.first, s2.second);\n}\n\nint main(){\n    int q; cin>>q;\n    while(q--){\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n\n        cout << intersect(s1, s2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); ++i)\nusing namespace std;\n\nconst double EPS = 1e-10;\nbool eq(double a, double b) {return fabs(a - b) < EPS;}\n\nstruct Point {\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n    Point operator + (Point &p);\n    Point operator - (Point &p);\n    Point operator * (double k);\n    Point operator / (double k);\n    bool operator == (const Point &p) const;\n    double norm();\n    double abs();\n    void print();\n} typedef Vec;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n    Segment(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n} typedef Line;\n\nstruct Circle {\n    Point o; double r;\n    Circle(Point o, double r) : o(o), r(r) {}\n    Circle(double x, double y, double r) : o(Point(x, y)), r(r) {}\n};\n\ndouble norm(Vec a);\ndouble abs(Vec a);\n\ndouble dot(Vec a, Vec b);\ndouble cross(Vec a, Vec b);\n\nint ccw(Point a, Point b, Point c);\nbool intersect(Point a1, Point a2, Point b1, Point b2);\nbool intersect(Segment s1, Segment s2);\n\nbool isOrthogonal(Vec a, Vec b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\n\nbool isParallel(Vec a, Vec b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\n\nint main() {\n    int q; cin >> q;\n    while(q--) {\n        double x, y, x2, y2;\n        cin >> x >> y >> x2 >> y2;\n        Line s(x, y, x2, y2);\n        cin >> x >> y >> x2 >> y2;\n        Line s2(x, y, x2, y2);\n        cout << intersect(s, s2) << '\\n';\n    }\n    return 0;\n}\n\nPoint Point::operator + (Point &p) {return Point(x + p.x, y + p.y);}\nPoint Point::operator - (Point &p) {return Point(x - p.x, y - p.y);}\nPoint Point::operator * (double k) {return Point(x * k, y * k);}\nPoint Point::operator / (double k) {return Point(x / k, y / k);}\nbool Point::operator == (const Point &p) const {return eq(x, p.x) && eq(y, p.y);}\ndouble Point::norm() {return x * x + y * y;}\ndouble Point::abs() {return sqrt(norm());}\nvoid Point::print() {printf(\"%.10lf %.10lf\\n\", x, y);}\n\ndouble norm(Vec a) {return a.x * a.x + a.y * a.y;}\ndouble abs(Vec a) {return sqrt(norm(a));}\n\ndouble dot(Vec a, Vec b) {return a.x * b.x + a.y * b.y;}\ndouble cross(Vec a, Vec b) {return a.x * b.y - a.y * b.x;}\n\nint ccw(Point a, Point b, Point c) {\n    b = b - a;\n    c = c - a;\n    if(cross(b, c) > EPS) return 1; // COUNTER_CLOCKWISE\n    if(cross(b, c) < -EPS) return -1; // CLOCKWISE\n    if(dot(b, c) < -EPS) return 2; // ONLINE_BACK\n    if(norm(b) < norm(c)) return -2; // ONLINE_FRONT\n    return 0; // ON_SEGMENT\n}\nbool intersect(Point a1, Point a2, Point b1, Point b2) {\n    return (ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {return intersect(s1.p1, s1.p2, s2.p1, s2.p2);}\n\nbool isOrthogonal(Vec a, Vec b) {return eq(dot(a, b), 0.0);}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {return isOrthogonal(a1 - a2, b1 - b2);}\nbool isOrthogonal(Segment s1, Segment s2) {return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);}\n\nbool isParallel(Vec a, Vec b) {return eq(cross(a, b), 0.0);}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {return isParallel(a1 - a2, b1 - b2);}\nbool isParallel(Segment s1, Segment s2) {return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);}\n\nPoint project(Segment s, Point p) {\n    Vec base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return base * r + s.p1;\n};\nPoint reflect(Segment s, Point p) {return (project(s, p) - p) * 2.0 + p;}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(double xx=0,double yy=0){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble abs(){\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm(){\n\t\treturn x*x+y*y;\n\t}\n};\n\nstruct Segment{\n\tP p1,p2;\n\tSegment(P pp1=P(),P pp2=P()){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef P Vector;\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<-EPS)return -1;\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main(void){\n\tint q;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tSegment s1,s2;\n\t\tscanf(\"%lf %lf\",&s1.p1.x,&s1.p1.y);\n\t\tscanf(\"%lf %lf\",&s1.p2.x,&s1.p2.y);\n\t\tscanf(\"%lf %lf\",&s2.p1.x,&s2.p1.y);\n\t\tscanf(\"%lf %lf\",&s2.p2.x,&s2.p2.y);\n\t\tprintf(\"%d\\n\",intersect(s1,s2)?1:0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)<abs(c)+eps)return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n    \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n// ------ Defines ------ //\n#define Point complex<long double>\n#define px real()\n#define py imag()\n// ------ Classes ------ //\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p1x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tLine(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p1x, p2y)) {};\n\tfriend bool operator==(const Line& s1, const Line& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Line& s1, const Line& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint prj(const Segment& a, const Point& b) {\n\tPoint c = a.p2 - a.p1;\n\treturn a.p2 + c * dot(b - a.p1, norm(c));\n}\nPoint rfl(const Segment& a, const Point& b) {\n\treturn b + (prj(a, b) - b) * 2.0L;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ------ Main ------ //\nint q, xp1, yp1, xp2, yp2, xq1, yq1, xq2, yq2;\nint main() {\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d\", &xp1, &yp1, &xp2, &yp2, &xq1, &yq1, &xq2, &yq2);\n\t\tprintf(\"%d\\n\", its(Segment(xp1, yp1, xp2, yp2), Segment(xq1, yq1, xq2, yq2)) ? 1 : 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE_BACK,\n              ONLINE_FRONT, ON_SEGMENT};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    POSITION s2p1_s1 = get_position(s2.p1, s1);\n    POSITION s2p2_s1 = get_position(s2.p2, s1);\n    POSITION s1p1_s2 = get_position(s1.p1, s2);\n    POSITION s1p2_s2 = get_position(s1.p2, s2);\n    if (s2p1_s1 == ON_SEGMENT || s2p2_s1 == ON_SEGMENT) return true;\n    if (s1p1_s2 == ON_SEGMENT || s1p2_s2 == ON_SEGMENT) return true;\n    if (s2p1_s1 == ONLINE_FRONT) {\n        if (s2p2_s1 == ONLINE_BACK) return true;\n        return false;\n    }\n    if (s2p1_s1 == ONLINE_BACK) {\n        if (s2p2_s1 == ONLINE_FRONT) return true;\n        return false;\n    }\n    if (s2p1_s1 == s2p2_s1) return false;\n    if (s1p1_s2 == s1p2_s2) return false;\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define per(i, a, b) for(int i = (a); i >= (b); --i)\n#define debug(x) cerr << #x << ' ' << x << endl;\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1e9+7;\nconst int MAXN = 2e5 + 7;\nconst double EPS=1e-8;\ninline int sign(double a){return a<-EPS?-1:a>EPS;}\ninline int cmp(double a,double b){return sign(a-b);}\n//点\nstruct P{\n    double x,y;\n    P(){}\n    P(double _x,double _y):x(_x),y(_y){}\n    P operator + (P p){return P(x+p.x,y+p.y);}\n    P operator - (P p){return P(x-p.x,y-p.y);}\n    P operator * (double k){return P(x*k,y*k);}\n    P operator / (double k){return P(x/k,y/k);}\n    double dot(P p){return x*p.x+y*p.y;}\n    double det(P p){return x*p.y-y*p.x;}\n    double distTo(P p){return (*this-p).abs();}\n    double alpha(){return atan2(y,x);}\n    void read(){scanf(\"%lf%lf\", &x, &y);}\n    void write(){printf(\"%.10lf %.10lf\\n\", x, y);}\n    double abs(){return sqrt(abs2());}\n    double abs2(){return x*x+y*y;}\n    P rot90(){return P(-y,x);}\n    P unit(){return *this/abs();}\n    int quad(){return sign(y)==1||(sign(y)==0&&sign(x)>=0);}\n    P rot(double an){return P(x*cos(an)-y*sin(an),x*sin(an)+y*cos(an));}\n    bool operator < (P p)const{int c=cmp(x,p.x);if(c)return c==-1;return cmp(y,p.y)==-1;}\n    bool operator == (P o)const{return cmp(x,o.x)==0&&cmp(y,o.y)==0;}\n};\n\nint main(int argc, char const *argv[])\n{\n    P p0, p1, p2, p3;\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        p0.read(); p1.read(); p2.read(); p3.read();\n        if(min(max(p0.x, p1.x), max(p2.x, p3.x)) < max(min(p0.x, p1.x), min(p2.x, p3.x)))   printf(\"0\\n\");\n        else if(min(max(p0.y, p1.y), max(p2.y, p3.y)) < max(min(p0.y, p1.y), min(p2.y, p3.y)))  printf(\"0\\n\");\n        else {\n            if(sign((p1-p0).det(p2-p0)) == sign((p1-p0).det(p3-p0))) {\n                if(sign((p1-p0).det(p2-p0)) == 0)    printf(\"1\\n\");\n                else    printf(\"0\\n\");\n            }\n            else if(sign((p3-p2).det(p0-p2)) == sign((p3-p2).det(p1-p2)))   printf(\"0\\n\");\n            else    printf(\"1\\n\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\n// common\n#define X real()\n#define Y imag()\n\nusing Vector2 = complex<double>;\nusing Line = pair<Vector2, Vector2>;\nusing Segment = pair<Vector2, Vector2>;\nconst double EPS = 1e-10;\nconst double PI = 3.14159265359;\n\nbool equals(double a, double b){\n    if(abs(a - b) < EPS){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\n// struct\n\nstruct Circle{\n    Vector2 c;\n    double r;\n    Circle(Vector2 c, double r){\n        this->c = c;\n        this->r = r;\n    }\n};\n\n// Vector2\ndouble dot(Vector2 a, Vector2 b){\n    return (a.X * b.X + a.Y * b.Y);\n}\n\ndouble cross(Vector2 a, Vector2 b){\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nint ccw(Vector2 p1, Vector2 p2, Vector2 p3){\n    Vector2 a = p2 - p1;\n    Vector2 b = p3 - p1;\n    double dotValue = dot(a, b);\n    double crossValue = cross(a, b);\n    if(crossValue > EPS) return 1;  // anticlockwise\n    if(crossValue < -EPS) return -1;    // clockwise\n    if(dotValue < -EPS) return 2;   // p2-p1-p3\n    if(norm(a) < norm(b)) return -2;    // p1-p2-p3\n    return 0;   // p1-p3-p2\n}\n\nbool intersect(Segment s1, Segment s2){\n    if(ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) > 0){\n        return false;\n    }\n    if(ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) > 0){\n        return false;\n    }\n    return true;\n}\n\nint main(){\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1(Vector2(x0, y0), Vector2(x1, y1));\n        Segment s2(Vector2(x2, y2), Vector2(x3, y3));\n        bool ans = intersect(s1, s2);\n        if(ans){\n            cout << 1 << endl;\n        }\n        else{\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{ONLINE_BACK = -2, CLOCKWISE = -1, ON_SEGMENT = 0,\n              COUNTER_CLOCKWISE = 1, ONLINE_FRONT = 2};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_position(s2.p1, s1) * get_position(s2.p2, s1) <= 0 &&\n        get_position(s1.p1, s2) * get_position(s1.p2, s2) <= 0) {\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(0,vec(a),vec(b))==0;}\nbool parallel(L a,L b) {return sdet(0,vec(a),vec(b))==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(0,vec(a),vec(b));\n\treturn (1-u)*a.s+u*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)) h=l.s;\n\tif(sdot(l.t,l.s,p)) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << (sgn(dss(s1,s2))==0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n\nint main(){\n    \n    int x0, x1, x2, x3, y0, y1, y2, y3;\n    int n, t0, t1, t2, t3;\n    \n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        t0 = (y0-y2)*(x3-x2) - (y3-y2)*(x0-x2);\n        t1 = (y1-y2)*(x3-x2) - (y3-y2)*(x1-x2);\n        t2 = (y2-y0)*(x1-x0) - (y1-y0)*(x2-x0);\n        t3 = (y3-y0)*(x1-x0) - (y1-y0)*(x3-x0);\n            \n        if (t0*t1 <= 0 && t2*t3 <= 0) cout << 1 << endl;\n        else                        cout << 0 << endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nstatic const long double EPS = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2; // p2→p0→p1\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point{\n    public: \n    long double x,y;\n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    Point operator + (Point p) const { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) const { return Point(x-p.x, y-p.y); }\n    Point operator * (long double a) const { return Point(x*a, y*a); }\n    Point operator / (long double a) const { return Point(x/a, y/a); }\n    bool operator < (const Point &p) const { return (x != p.x ? x < p.x : y < p.y); }\n    bool operator == (const Point &p) const { return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS; }\n    long double abs() const { return sqrt(norm()); }\n    long double norm() const { return x*x + y*y; }\n    long double dot(Point p) const { return x*p.x + y*p.y; }\n    long double cross(Point p) const { return x*p.y - y*p.x; }\n};\n\n\nint ccw(Point p0, Point p1, Point p2){\n    Point a = p1 - p0;\n    Point b = p2 - p0;\n    if(a.cross(b) > EPS) return COUNTER_CLOCKWISE;\n    if(a.cross(b) < -EPS) return CLOCKWISE;\n    if(a.dot(b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3){\n    return ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    long double x[8];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<8;j++) cin >> x[j];\n        Point p[4];\n        for(int j=0;j<4;j++) p[j] = Point(x[2*j], x[2*j+1]);\n        cout << intersect(p[0], p[1], p[2], p[3]) << endl; \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n  static bool crossing(P p1,P p2,P q1,P q2)\n  {\n    if((p2-p1).sign(q2-q1)==0) return on_seg(p1,p2,q1) || on_seg(p1,p2,q2);\n    double x=(q2-q1).det(q1-p1)/(q2-q1).det(p2-p1);\n    double y=(p2-p1).det(p1-q1)/(p2-p1).det(q2-q1);\n    return x<=1 && x>=0 && y<=1 && y>=0;\n  }\n};\n\n\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct point\n{\n    double x,y;\n};\npoint vt(point a,point b)\n{\n    point vt;\n    vt.x=b.x-a.x;\n    vt.y=b.y-a.y;\n    return vt;\n}\ndouble tichcheo(point a,point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\nint test1(point a,point b,point c,point d)\n{\n    if ((a.x==c.x&&a.y==c.y)||(a.x==d.x&&a.y==d.y)||(c.x==b.x&&c.y==b.y)||(d.x==b.x&&d.y==b.y)) return 1;\n    else return 0;\n}\nint test2(double a,double b,double c,double d)\n{\n    if (a>b) {\n        swap(a,b);\n    }\n    if (c>d)\n    {\n        swap(c,d);\n    }\n    if (max(a,c)<=min(b,d)) return 1;\n    else return 0;\n}\nint test(point a,point b,point c,point d)\n{\n    point ab=vt(a,b);\n    point bc=vt(b,c);\n    point bd=vt(b,d);\n    if ((tichcheo(ab,bc)*tichcheo(ab,bd))<=0&&tichcheo(ab,bc)!=tichcheo(ab,bd)) return 1;\n    else if (tichcheo(ab,bd)==0&&tichcheo(ab,bc)==0)\n    {\n        /*cout<<test2(a.x,b.x,c.x,d.x)<<endl;\n        cout<<test2(a.y,b.y,c.y,d.y)<<endl;\n        cout<<test2(c.x,d.x,a.x,b.x)<<endl;\n        cout<<test2(c.y,d.y,a.y,b.y)<<endl;*/\n        if ((test2(a.x,b.x,c.x,d.x)==1)&&(test2(a.y,b.y,c.y,d.y)==1)&&(test2(c.x,d.x,a.x,b.x)==1)&&(test2(c.y,d.y,a.y,b.y)==1)) return 1;\n        else return 0;\n        /*cout<<(test2(a.x,b.x,c.x,d.x)&&test2(a.y,b.y,c.y,d.y))<<endl;\n        cout<<(test2(c.x,d.x,a.x,b.x)&&test2(c.y,d.y,a.y,b.y))<<endl;\n        return 1;*/\n    }\n    else return 0;\n}\nint q;\nint main()\n{\n    cin>>q;\n    while (q--)\n    {\n        point p0,p1,p2,p3;\n        cin>>p0.x>>p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n        if (test1(p0,p1,p2,p3))\n        {\n            cout<<\"1\\n\";\n        }\n        else\n        if (test(p0,p1,p2,p3)==1&&test(p2,p3,p0,p1)==1) cout<<\"1\\n\";\n        else cout<<\"0\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\nint main(){\nint n;\ncin>>n;\ndouble a1,a2,a3,a4,a5,a6,a7,a8;\nPoint p0,p1,p2,p3;\nVector v01,v31,v02,v03,v23,v21,v20;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8;\np0.x=a1,p0.y=a2;\n//cout<<a2<<endl;\np1.x=a3,p1.y=a4;\np2.x=a5,p2.y=a6;\np3.x=a7,p3.y=a8;\nv01=p0-p1;\nv02=p0-p2;\nv03=p0-p3;\nv23=p2-p3;\nv21=p2-p1;\nv20=p2-p0;\nv31=p3-p1;\nif(fabs(cross(v01,v02))<EPS && fabs(cross(v01,v03))<EPS){\nif(dot(p0-p3,p0-p2)>EPS && dot(p1-p3,p1-p2)>EPS &&dot(p0-p3,p1-p3)>EPS) cout<<\"0\"<<endl;\nelse cout<<\"1\"<<endl;\n//cout<<dot(p0-p3,p0-p2)<<\" \"<<dot(p1-p3,p1-p2)<<endl;\n}\nelse if(cross(v01,v02)*cross(v01,v03)<=0 && cross(v23,v21)*cross(v23,v20)<=0) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof(a))\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=1e4+200;\nconst int inf=0x3f3f3f3f;\nconst double EPS=1e-8;\n//typedef pair<int,int> PA;\ndouble add(double a,double b){//考虑误差的加法运算\n    if(abs(a+b)<EPS*(abs(a)+abs(b))) return  0;\n    return a+b;\n}\nclass Point{\npublic:\n\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){\n    }\n    Point operator+ (Point p){\n        return Point(add(x,p.x),add(y,p.y));\n    }\n    Point operator -(Point p){\n        return Point(add(x,-p.x),add(y,-p.y));\n    }\n    Point operator *(double d){\n        return Point(x*d,y*d);\n    }\n    double operator *(Point p){\n        return add(x*p.x,y*p.y);//外积\n    }\n    double operator ^(Point p){//内积\n        return add(x*p.y,-y*p.x);\n    }\n    double dot(Point p){//外积 p1.p2  outside\n        return add(x*p.x,y*p.y);\n    }\n    double det(Point p){//内积 p1*p2    inner\n        return add(x*p.y,-y*p.x);\n    }\n    double len(){\n        return sqrt(add(x*x,y*y));\n    }\n};\nPoint operator *(double d,Point p){\n    return Point(p.x*d,p.y*d);\n}\nPoint getProjection(Point p1,Point p2,Point q){//q 在线段p1,p2上的投影坐标\n    double d1=1.0/(p2-p1).len();\n    Point ans=(q-p1)*(p2-p1)*(p2-p1)*d1*d1;\n    return ans+p1;\n}\nPoint getReflection(Point p1,Point p2,Point q){//q 关于线段p1 p2的 反射坐标\n    return 2.0*getProjection(p1,p2,q)-q;\n}\ndouble getDistance(Point a,Point b){//两点之间距离\n    return (b-a).len();\n}\nint sgn(double x){\n    if(abs(x)<EPS)  return 0;\n    if(x<0) return -1;\n    else return 1;\n}\nclass Line{\npublic:\n    Point s,e;\n    Line(){}\n    Line(Point s,Point e):s(s),e(e){}\n};\nint getLineState(Line la,Line lb){\n    if(sgn((la.e-la.s)^(lb.e-lb.s))==0){\n        return 2;//平行\n    }//两向量平行 内积为0\n    else if(sgn((la.e-la.s)*(lb.e-lb.s))==0){\n        return 1;//垂直\n    }\n    else return 0;\n}\nint getPointState(Point p,Point p1,Point p2){//返回 p2 关于p 在p1的什么方向\n        int a=sgn((p1-p)^(p2-p));\n        int b=sgn((p1-p)*(p2-p));\n        if(a>0){//\n            puts(\"COUNTER_CLOCKWISE\");\n        }\n        else if(a<0){\n            puts(\"CLOCKWISE\");\n        }\n        else if(b<0){\n            puts(\"ONLINE_BACK\");\n        }\n        else if(b>0&&sgn((p1-p).dot(p2-p1))>0){\n            puts(\"ONLINE_FRONT\");\n        }\n        else{\n            puts(\"ON_SEGMENT\");\n        }\n        return 0;\n\n}\nint direction(Point p,Point p1,Point p2){\n    return sgn((p1-p)^(p2-p));//1代表 p2在p1的逆时针方向  0共线 ，-1是p2在p1的顺时针方向\n}\nbool onSge(Line l,Point q){\n    return ((l.s-q)^(l.e-q))==0&&((l.s-q)*(l.e-q))<=0;\n}\nbool inter(Line la,Line lb){\n    int d1=direction(lb.s,lb.e,la.s);\n    int d2=direction(lb.s,lb.e,la.e);\n    int d3=direction(la.s,la.e,lb.s);\n    int d4=direction(la.s,la.e,lb.e);\n    if(d1*d2<0&&d3*d4<0)\n        return true;\n    else if(d1==0&&onSge(lb,la.s))\n        return true;\n    else if(d2==0&&onSge(lb,la.e))\n        return true;\n    else if(d3==0&&onSge(la,lb.s))\n        return true;\n    else if(d4==0&&onSge(la,lb.e))\n        return true;\n    else\n        return false;\n\n//    return\n//    max(la.s.x,la.e.x)>=min(lb.s.x,lb.e.x) &&\n//    max(lb.s.x,lb.e.x)>=min(la.s.x,la.e.x) &&\n//    max(la.s.y,la.e.y)>=min(lb.s.y,lb.e.y) &&\n//    max(lb.s.y,lb.e.y)>=min(la.s.y,lb.e.y) &&\n//    sgn((lb.s-la.e)^(la.s-la.e))*sgn((lb.e-la.e)^(la.s-la.e))<=0&&\n//    sgn((la.s-lb.e)^(lb.s-lb.e))*sgn((la.e-lb.e)^(lb.s-lb.e))<=0;\n}\ntypedef Point P;\nint main(){\n    int q;\n    P p0,p1,p2,p3;\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p0.x,&p0.y,&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y);\n        int state=inter(Line(p0,p1),Line(p2,p3));\n        printf(\"%d\\n\",state);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n\tdouble dot(const Point &o) const { return x * o.x + y * o.y; }\n\n\tdouble atan() const { return atan2(y, x); }\n\n\tdouble norm() const { return sqrt(dot(*this)); }\n\n\tdouble distance(const Point &o) const { return (o - (*this)).norm(); }\n\n\tdouble area(const Point &a,const Point &b) {\n\t\tPoint p = a - (*this), p2 = b - (*this); \n\t\treturn p.cross(p2);\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const {\n\t\tPoint p = a - (*this), p2 = b - (*this);\n\t\treturn fabs(p.cross(p2)) / 2.0;\n\t}\t\n\n\t//??????ab?????????????????????????????????????????????????????????\n\tint between(const Point &a,const Point &b) {\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)  return ((a.x <= x) && (x <= b.x)) || ((a.x >= x) && (x >= b.x));\n\t\telse return ((a.y <= y) && (y <= b.y)) || ((a.y >= y) && (y >= b.y));\n\t}      \n\n\tdouble distance_seg(const Point& a,const Point& b) {\n\t\tif((b-a).dot(*this-a) < EPS) {\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS) {\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }\n\n\tbool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }\n\n\tbool isIntersect(Seg &s) {\n\t\tif(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t}\n\n\tbool distance(Seg &s) {\n\t\tif((*this).isIntersect(s)) return 0.0;\n\n\t\treturn min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));\n\t}\n\n\tPoint getCrossPoint(Seg &s) {\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n\tPoint project(Point &p) {\n\t\tPoint base = b - a;\n\t\tdouble t = base.dot(p-a) / base.dot(base);\n\t\treturn a + base * t;\n\t}\n\n\tPoint reflect(Point &p) {\n\t\treturn p + (project(p) - p) * 2.0;\n\t}\n};\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tSeg s1, s2;\n\trep(i, q) {\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\n\t\tif(s1.isIntersect(s2)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n\nconst int get_diff(const std::vector<std::pair<int, int>> &point, const int &p0, const int &p1){\n\tint X = point.at(p0 + 1).first - point.at(p0).first;\n\tint Y = point.at(p0 + 1).second - point.at(p0).second;\n\treturn (X * point.at(p1).second - Y * (point.at(p1).first - point.at(p0).first) - X * point.at(p0).second);\n}\nconst bool sub_inter(const int &p0, const int &p1, const int &p2){\n\treturn ((p2 - p0) * (p2 - p1) <= 0);\n}\nconst bool inter_x(const std::vector<std::pair<int, int>> &point){\n\tbool result = false;\n\tfor (auto i = 0; i < 2; ++i){\n\t\tfor (auto j = 0; j < 2; ++j){\n\t\t\tresult = result || sub_inter(point.at(2 * i).first, point.at(2 * i + 1).first, point.at(3 - 2 * i - j).first);\n\t\t}\n\t}\n\treturn result;\n}\nconst bool inter_y(const std::vector<std::pair<int, int>> &point){\n\tbool result = false;\n\tfor (auto i = 0; i < 2; ++i){\n\t\tfor (auto j = 0; j < 2; ++j){\n\t\t\tresult = result || sub_inter(point.at(2 * i).second, point.at(2 * i + 1).second, point.at(3 - 2 * i - j).second);\n\t\t}\n\t}\n\treturn result;\n}\nbool judge(const std::vector<std::pair<int, int>> &point){\n\tif (point.at(0).first != point.at(1).first and point.at(2).first != point.at(3).first){\n\t\tif ((point.at(0).first - point.at(1).first) * (point.at(2).second - point.at(3).second) - (point.at(0).second - point.at(1).second) * (point.at(2).first- point.at(3).first) != 0 ){\n\t\t\tif ((get_diff(point, 0, 2) * get_diff(point, 0, 3) <= 0) and (get_diff(point, 2, 0) * get_diff(point, 2, 1) <= 0)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else{\n\t\t\tif (inter_x(point) and inter_y(point)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}else if (point.at(2).first != point.at(3).first){\n\t\tif ((point.at(0).first - point.at(2).first) * (point.at(0).first - point.at(3).first) <= 0 and (get_diff(point, 2, 0) * get_diff(point, 2, 1) <= 0)){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else if (point.at(0).first != point.at(1).first){\n\t\tif ((point.at(2).first - point.at(0).first) * (point.at(2).first - point.at(1).first) <= 0 and (get_diff(point, 0, 2) * get_diff(point, 0, 3) <= 0)){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif (point.at(0).first == point.at(2).first){\n\t\t\tif (inter_y(point)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main(){\n\tint q;\n\tstd::cin >> q;\n\tfor (auto i = 0; i < q; ++i){\n\t\tstd::vector<std::pair<int, int>> point;\n\t\tfor (auto j  = 0; j < 4; ++j){\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\tpoint.push_back(std::make_pair(x, y));\n\t\t}\n\t\tif (judge(point)){\n\t\t\tstd::cout << \"1\\n\";\n\t\t}else{\n\t\t\tstd::cout << \"0\\n\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#define ESP (1e-10)\nusing namespace std;\n\ntypedef struct Point {\n\tdouble x; \n\tdouble y;\n\n\tPoint() { }\n\n\tPoint(double x, double y) :x(x), y(y) { }\n\n\tPoint operator+(Point& p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator-(Point& p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n};\n\ntypedef Point Vector;\n\n struct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(const Point& a,const Point& b) : p1(a),p2(b) { }\n};\n\n typedef Line Segment;\n\ndouble abs(Point p1, Point p2) {\n\tdouble norm = (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);\n\treturn sqrt(norm);\n}\n\ndouble product(Vector v1, Vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\n\ndouble cross(Vector p1, Vector p2) {\n\treturn p1.x*p2.y - p1.y*p2.x;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector v0 = p1 - p0;\n\tVector v1 = p2 - p0;\n\tif (cross(v0, v1) > ESP) return 1;   //p0,p1,p2??????????¨???????\n\tif (cross(v0, v1) < -ESP) return -1;   //p0,p1,p2???????¨???????\n\tif (product(v0, v1) < -ESP) return 2;  //p2,p0,p1????????§????????´??????\n\tif (abs(p0, p1) < abs(p0, p2)) return -2;  //p0,p1,p2????????§????????´??????\n\treturn 0;   //p2?????????(p0,p1)???\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn (ccw(p0, p1, p2)*ccw(p0, p1, p3) <= 0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n\t//?????????????????????????????¶\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble DistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)/abs(l.p1,l.p2));\n}\n\ndouble DistanceSP(Segment s, Point p) {\n\tif (product(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p, s.p1);\n\tif (product(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p, s.p2);\n\treturn DistanceLP(s, p);\n}\n\ndouble DistanceSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(DistanceSP(s1, s2.p1), DistanceSP(s1,s2.p2)), min(DistanceSP(s2, s1.p1), DistanceSP(s2, s1.p2)));\n}\n\nint main() {\n\tSegment s0,s1;\n\tint q; \n\tcin >> q;\n\tfor (int i = 0;i < q;i++) {\n\t\tcin >> s0.p1.x; cin >> s0.p1.y;\n\t\tcin >> s0.p2.x; cin >> s0.p2.y;\n\t\tcin >> s1.p1.x; cin >> s1.p1.y;\n\t\tcin >> s1.p2.x; cin >> s1.p2.y;\n\t\tcout << intersect(s0, s1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nstruct point2d{\n  double x, y;\n  point2d(){}\n  point2d(double x, double y): x(x), y(y){}\n  point2d operator+(const point2d &r) const{\n    return point2d(x + r.x, y + r.y);\n  }\n  point2d operator-(const point2d &r) const{\n    return point2d(x - r.x, y - r.y);\n  }\n  point2d& operator+=(const point2d &r){\n    *this = *this + r;\n    return *this;\n  }\n  point2d& operator-=(const point2d &r){\n    *this = *this - r;\n    return *this;\n  }\n  bool operator==(const point2d &r) const{\n    return abs(x - r.x) < EPS && abs(y - r.y) < EPS;\n  }\n  bool operator!=(const point2d &r) const{\n    return !(*this == r);\n  }\n  bool operator<(const point2d &r) const{\n    if(abs(x - r.x) >= EPS)return x < r.x;\n    return y < r.y;\n  }\n};\n\npoint2d operator*(double x, const point2d &p){\n  return point2d(x * p.x, x * p.y);\n}\n\npoint2d operator/(const point2d &p, double x){\n  return point2d(p.x / x, p.y / x);\n}\n\ndouble norm(const point2d &a){\n  return sqrt(a.x * a.x + a.y * a.y);\n}\n\ndouble dis(const point2d &a, const point2d &b){\n  point2d c = a - b;\n  return norm(c);\n}\n\ndouble inner_product(const point2d &a, const point2d &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble outer_product(const point2d &a, const point2d &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble cosine(const point2d &a, const point2d &b){\n  return inner_product(a, b) / norm(a) / norm(b);\n}\n\nstruct plane2d{\n  double a, b, c;\n  double norm;\n  plane2d(){}\n  plane2d(double a, double b, double c): a(a), b(b), c(c){}\n  plane2d(const point2d &p, const point2d &q){\n    point2d l = p - q;\n    a = l.y, b = - l.x;\n    c = - a * p.x - b * p.y;\n    build();\n  }\n  void build(){\n    norm = sqrt(a * a + b * b);\n  }\n  double dis(const point2d &p){\n    return abs(a * p.x + b * p.y + c) / norm;\n  }\n  double val(const point2d &p){\n    return a * p.x + b * p.y + c;\n  }\n};\n\nbool intersection(const point2d &p1, const point2d &p2, const point2d &p3, const point2d &p4){\n  plane2d pl1(p1, p2), pl2(p3, p4);\n  if(abs(pl1.val(p3)) < EPS && min(p1.x, p2.x) <= p3.x && p3.x <= max(p1.x, p2.x) &&\n      min(p1.y, p2.y) <= p3.y && p3.y <= max(p1.y, p2.y))return true;\n  if(abs(pl1.val(p4)) < EPS && min(p1.x, p2.x) <= p4.x && p4.x <= max(p1.x, p2.x) &&\n      min(p1.y, p2.y) <= p4.y && p4.y <= max(p1.y, p2.y))return true;\n  if(abs(pl2.val(p1)) < EPS && min(p3.x, p4.x) <= p1.x && p1.x <= max(p3.x, p4.x) &&\n      min(p3.y, p4.y) <= p1.y && p1.y <= max(p3.y, p4.y))return true;\n  if(abs(pl2.val(p2)) < EPS && min(p3.x, p4.x) <= p2.x && p2.x <= max(p3.x, p4.x) &&\n      min(p3.y, p4.y) <= p2.y && p2.y <= max(p3.y, p4.y))return true;\n  return pl1.val(p3) * pl1.val(p4) <= - EPS && pl2.val(p1) * pl2.val(p2) <= - EPS;\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(q);\n  rep(i, q){\n    point2d p[4];\n    rep(j, 4)cin >> p[j].x >> p[j].y;\n    if(intersection(p[0], p[1], p[2], p[3]))cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)s; i < (int)(e); ++i)\n\n#define X real()\n#define Y imag()\n#define x(p) real(p)\n#define y(p) imag(p)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i-1+P.size())%P.size()]\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\ntypedef double D;\ntypedef complex<D> P;\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\n\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P&a, const P& b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; D r;\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return +1; //ccw\n  if(cross(b, c) < 0) return -1; //cw\n  if(dot(b, c) < 0)   return +2; //c-a-b on line\n  if(norm(b) < norm(c)) return -2; //a-b-c on line\n  return 0;\n}\n\nP projection(const L& l, const P& p) {\n  D t = dot(p - l[0], l[0] - l[1]) / norm(l[0]- l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\nP refrection(const L& l, const P& p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\n\nbool intersectSS(const L& a, const L& b) {\n  return ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n    && ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    vector<P> ps(4);\n    rep(i, 4) {\n      D x, y;\n      cin >> x >> y;\n      ps[i] = {x, y};\n    }\n    if(intersectSS(L{ps[0], ps[1]}, L{ps[2], ps[3]}))cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db eps = 1e-12, pi = acos(-1);\nint sign(db x) {return x < -eps ? -1 : x > eps;}\nint cmp(db x, db y) {return sign(x - y);}\nint intersect(db l1, db r1, db l2, db r2) {\n    if (l1 > r1) swap(l1, r1); if (l2 > r2) swap(l2, r2); return cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nint inmid(db k1, db k2, db k3) {return sign(k1 - k3) * sign(k2 - k3) <= 0;}//k3 in [k1,k2]?1:0\nstruct Point {\n    db x, y;\n    Point operator + (const Point & a)const {return Point{a.x + x, a.y + y};}\n    Point operator - (const Point & a)const {return Point{x - a.x, y - a.y};}\n    Point operator * (db a) const {return Point{x * a, y * a};}\n    Point operator / (db a) const {return Point{x / a, y / a};}\n    bool operator < (const Point p) const {int a = cmp(x, p.x); if (a) return a == -1; return cmp(y, p.y) == -1;}\n    bool operator == (const Point & a) const {return cmp(x, a.x) == 0 && cmp(y, a.y) == 0;}\n    int getP() const {return sign(y) == 1 || (sign(y) == 0 && sign(x) == -1);}\n    void input() {scanf(\"%lf%lf\", &x, &y);}\n};\ndb cross(Point p1, Point p2) {return p1.x * p2.y - p1.y * p2.x;}\ndb cross(Point p0, Point p1, Point p2) {return cross(p1 - p0, p2 - p0);}\ndb dot(Point p1, Point p2) {return p1.x * p2.x + p1.y * p2.y;}\nint inmid(Point k1, Point k2, Point k3) {return inmid(k1.x, k2.x, k3.x) && inmid(k1.y, k2.y, k3.y);}\nbool compareangle(Point p1, Point p2) {//Polar Angle Sort\n    return p1.getP() < p2.getP() || (p1.getP() == p2.getP() && sign(cross(p1, p2)) > 0);\n}\nint clockwise(Point p1,Point p2,Point p3){// k1 k2 k3 anticlockwise:1 clockwise:-1 others:0  \n    return sign(cross(p1,p2,p3));\n}\nstruct Line {\n    Point s, e;\n    void input() {scanf(\"%lf%lf%lf%lf\", &s.x, &s.y, &e.x, &e.y);}\n    Point vec() {return e - s;}\n    db length() {return sqrt(dot(s - e, s - e));}\n    db length2() {return dot(s - e, s - e);}\n};\nint onS(Line l, Point p) {// On Seg?\n    return inmid(l.s, l.e, p) && sign(cross(l.s - p, l.e - l.s)) == 0;\n}\nbool checkLL(Line l1, Line l2) {\n    return cmp(cross(l1.s, l2.s, l2.e), cross(l1.e, l2.s, l2.e)) != 0;\n}\nbool checkLS(Line l1, Line l2) {//Intersection of Line l1 and Seg l2?\n    return sign(cross(l2.s, l1.s, l1.e)) * sign(cross(l2.e, l1.s, l1.e)) <= 0;\n}\nint checkSS(Line l1, Line l2) {//Intersection of Two Seg?1:0\n    return intersect(l1.s.x, l1.e.x, l2.s.x, l2.e.x) && intersect(l1.s.y, l1.e.y, l2.s.y, l2.e.y) && checkLS(l1, l2) && checkLS(l2, l1);\n}\nPoint project(Line l, Point p) {\n    return l.s + l.vec() * dot(p - l.s, l.vec()) / l.length2();\n}\nPoint reflect(Line l, Point p) {//Mirror Point\n    return project(l, p) * 2 - p;\n}\nPoint getLL(Line l1, Line l2) {//Intersection Point of Line l1,l2\n    db w1 = cross(l2.s, l1.s, l2.e), w2 = cross(l2.s, l2.e, l1.e); return (l1.s * w2 + l1.e * w1) / (w1 + w2);\n}\ndb area(vector<Point> A) {//Anticlockwise\n    db ans = 0;\n    for (int i = 0; i < A.size(); i++) ans += cross(A[i], A[(i + 1) % A.size()]);\n    return ans / 2;\n}\nint contain(vector<Point>A, Point p) {//2:in 1:on 0:out\n    int ans = 0; A.push_back(A[0]);\n    for (int i = 1; i < A.size(); i++) {\n        Line l = {A[i - 1], A[i]};\n        if (onS(l, p)) return 1; if (cmp(l.s.y, l.e.y) > 0) swap(l.s, l.e);\n        if (cmp(l.s.y, p.y) >= 0 || cmp(l.e.y, p.y) < 0) continue;\n        if (sign(cross(l.e, l.s, p)) < 0)ans ^= 1;\n    }\n    return ans << 1;\n}\n\n\n\n\nint main() {\n    int T;cin>>T;while(T--){\n        Line l1,l2;l1.input();l2.input();\n        cout<<checkSS(l1,l2)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{ONLINE_BACK = -2, CLOCKWISE = -1, ON_SEGMENT = 0,\n              COUNTER_CLOCKWISE = 1, ONLINE_FRONT = 2};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_pos(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_pos(s2.p1, s1) * get_pos(s2.p2, s1) > 0) return false;\n    if (get_pos(s1.p1, s2) * get_pos(s1.p2, s2) > 0) return false;\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ndouble x,y,xx,yy,xxx,yyy,xxxx,yyyy;\nint q;\nint main(){\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>x>>y>>xx>>yy>>xxx>>yyy>>xxxx>>yyyy;\n\t\tint pd1=0,pd2=0,pd3=0,pd4=0,pd5=0;\n\t\txx-=x,yy-=y,xxx-=x,yyy-=y,xxxx-=x,yyyy-=y;\n\t\tif((xx*yyy-xxx*yy)*(xx*yyyy-xxxx*yy)<=0) pd1=1;\n\t\txx+=x,yy+=y,xxx+=x,yyy+=y,xxxx+=x,yyyy+=y;\n\t\t\n\t\tx-=xx,y-=yy,xxx-=xx,yyy-=yy,xxxx-=xx,yyyy-=yy;\n\t\tif((x*yyy-xxx*y)*(x*yyyy-xxxx*y)<=0) pd2=1;\n\t\tx+=xx,y+=yy,xxx+=xx,yyy+=yy,xxxx+=xx,yyyy+=yy;\n\t\t\n\t\tx-=xxx,y-=yyy,xx-=xxx,yy-=yyy,xxxx-=xxx,yyyy-=yyy;\n\t\tif((xxxx*y-x*yyyy)*(xxxx*yy-xx*yyyy)<=0) pd3=1;\n\t\tx+=xxx,y+=yyy,xx+=xxx,yy+=yyy,xxxx+=xxx,yyyy+=yyy;\n\t\t\n\t\tx-=xxxx,y-=yyyy,xx-=xxxx,yy-=yyyy,xxx-=xxxx,yyy-=yyyy;\n\t\tif((xxx*y-x*yyy)*(xxx*yy-xx*yyy)<=0) pd4=1;\n\t\tx+=xxxx,y+=yyyy,xx+=xxxx,yy+=yyyy,xxx+=xxxx,yyy+=yyyy;\n\t\t\n\t\tif(max(x,xx)>=min(xxx,xxxx)\n\t\t&& max(xxx,xxxx)>=min(x,xx)\n\t\t&& max(y,yy)>=min(yyy,yyyy)\n\t\t&& max(yyy,yyyy)>=min(y,yy)){\n\t\t\tpd5=1;\n\t\t}\n//\t\tcout<<pd1<<\" \"<<pd2<<\" \"<<pd3<<endl;\n\t\tif(pd1==0 || pd2==0 || pd3==0 || pd4==0 || pd5==0){\n\t\t\tcout<<\"0\"<<endl;\n\t\t}\n\t\telse cout<<\"1\"<<endl;\n\t}\n\treturn 0;\n}\n/*\n8\n0 0 4 0 1 1 1 -1\n0 0 4 0 2 1 3 -1\n0 0 4 0 3 1 2 -1\n0 0 4 0 4 3 2 -3\n0 0 4 0 5 1 6 -1\n0 0 4 0 5 0 7 0\n0 0 4 0 1 2 4 1\n0 0 4 0 1 -2 1 -4\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < (EPS))\n\n#define COUNTER_CLOCKWISE (1)\n#define CLOCKWISE (-1)\n#define ONLINE_BACK (2)\n#define ONLINE_FRONT (-2)\n#define ON_SEGMENT (0)\n\nstruct Point \n{\n  double x, y;\n  \n  Point() {}\n  \n  Point(double x, double y) : x(x), y(y) {}\n  \n  void input() { scanf(\"%lf %lf\", &x, &y); }\n  void output() { printf(\"%.10f %.10f\\n\", x, y); }\n  double abs() { return (sqrt(norm())); }\n  double norm() { return (x * x + y * y); }\n  \n  Point operator + (Point d) { return (Point(x + d.x, y + d.y)); }\n  Point operator - (Point d) { return (Point(x - d.x, y - d.y)); }\n  Point operator - () { return (Point(-x, -y)); }\n  Point operator * (double a) { return (Point(x * a, y * a)); }\n  Point operator / (double a) { return (Point(x / a, y / a)); }\n  \n};\n\nstruct Segment\n{\n  Point p1, p2;\n  \n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n  void input() { p1.input(); p2.input(); }\n  \n};\n\ntypedef Point Vector;\ntypedef vector < Point > Polygon;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b)\n{\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return (a.x * b.y - a.y * b.x);\n}\n\nPoint project(Line l, Point p)\n{\n  Vector base = l.p2 - l.p1;\n  return (l.p1 + base * (dot(p - l.p1, base) / base.norm()));\n}\n\nPoint reflect(Line l, Point p)\n{\n  return (-p + project(l, p) * 2.0);\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return (abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return ((p - s.p1).abs());\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return ((p - s.p2).abs());\n  return (getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n  return (0.0);\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  \n  if(cross(a, b) > EPS) return (COUNTER_CLOCKWISE);\n  if(cross(a, b) < -EPS) return (CLOCKWISE);\n  if(dot(a, b) < -EPS) return (ONLINE_BACK);\n  if(a.norm() < b.norm()) return (ONLINE_FRONT);\n  \n  return (ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return (intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\nmain()\n{\n  int n;\n\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    Segment s1, s2;\n    s1.input(); s2.input();\n    cout << intersect(s1, s2) << endl;\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    double x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(double nx) {\n        x = nx;\n    }\n    \n    void setY(double ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    double cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    // ベクトルの大きさを求める\n    double norm() const {\n        return sqrt(x * x + y * y);\n    }\n    \n    // 単位ベクトルを返す\n    Vector getUnit() const {\n        Vector v;\n        double n = norm();\n        if (n == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / n, y / n);\n        }\n        return v;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (double f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (double f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n    \n    bool operator == (const Vector& vec) {\n        if (x == vec.x && y == vec.y) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(double sx, double sy, double ex, double ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    // 指定の線分を含むか\n    // このメソッドは線分同士が平行の時しか使用しない\n    bool isInLine(const LineSegment& l) {\n        bool b1 = isPointInLine(l.getStart());\n        bool b2 = isPointInLine(l.getEnd());\n        if (b1 || b2) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    bool isPointInLine(const Vector& p) {\n        if (start == p) {\n            return true;\n        }\n        \n        Vector l1 = end - start;\n        Vector l2 = p - start;\n        Vector u1 = l1.getUnit();\n        Vector u2 = l2.getUnit();\n        \n        if (u1 == u2 && l2.norm() <= l1.norm()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        double c1 = l1.cross(l.getStart() - start);\n        double c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        double c3 = l2.cross(start - l.getStart());\n        double c4 = l2.cross(end - l.getStart());\n        \n        if (c1 * c2 == 0.0 && c3 * c4 == 0.0) { // 平行のとき\n            if (isInLine(l)) {\n                return 1;\n            }\n            return 0;\n        } else if ((c1 * c2 < 0.0 && c3 * c4 <= 0.0)\n                   || (c1 * c2 <= 0.0 && c3 * c4 < 0.0)\n                   || (c1 * c2 < 0.0 && c3 * c4 < 0.0)) { // 交差するとき\n            return 1;\n        } else { // 交差しないとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        double sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nint main()\n{\n  int q; cin >> q;\n  while(q--) {\n    Point p[4];\n    for(int i = 0; i < 4; i++) cin >> p[i].x >> p[i].y;\n    cout << intersect(p[0], p[1], p[2], p[3]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<utility>\nusing namespace std;\nconst double eps = 1e-10;\ntypedef complex<double> Point;\ntypedef Point Vector;\npair <Point,Point> Line1,Line2;\n\ndouble dot(Point& a,Point& b)\n{\n    return real(conj(a)*b);\n}\n\ndouble cross(Point& a, Point& b)\n{\n    return imag(conj(a)*b);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if (cross(t1, t2) > 0)   return +1;       // counter clockwise\n    if (cross(t1, t2) < 0)   return -1;       // clockwise\n    if (dot(t1, t2) < 0)     return +2;       // c--a--b on line\n    if (norm(t1) < norm(t2)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool isintersaction(pair <Point,Point> a, pair <Point,Point> b)\n{\n    return (ccw(a.first,b.first,b.second)*ccw(a.second,b.first,b.second) < 0 && ccw(b.first,a.first,a.second)*ccw(b.second,a.first,a.second) < 0);\n}\n\nint main()\n{\n    int vol;\n    scanf(\"%d\",&vol);\n    while(vol--)\n    {\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        scanf(\"%d%d%d%d%d%d%d%d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n        Line1 = make_pair(Point(x0, y0), Point(x1, y1)), Line2 = make_pair(Point(x2, y2), Point(x3, y3));\n        printf(\"%d\\n\",isintersaction(Line1, Line2));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace LCY{\n\t#define double long double\n\tconst double EPS=1e-10;\n\tinline int dcmp(double x){if(fabs(x)<EPS)return 0;return (x<0)?-1:1;}\n\tstruct Point{double x,y;Point(double _x=0,double _y=0){x=_x;y=_y;}};\n\tstruct Vector{double x,y;Vector(double _x=0,double _y=0){x=_x;y=_y;}};\n\t\n\tVector operator - (Point a,Point b){return Vector(a.x-b.x,a.y-b.y);}\n\tVector operator * (Vector a,double d){return Vector(a.x*d,a.y*d);}\n\tPoint operator + (Point a,Vector b){return Point(a.x+b.x,a.y+b.y);}\n\t\n\tinline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n\tinline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n\tinline double norm(Vector a){return dot(a,a);}\n\t\n\tstruct Line{\n\t\tPoint p1,p2;\n\t\tLine(Point _p1=Point(0,0),Point _p2=Point(0,0)){p1=_p1;p2=_p2;}\n\t};\n\tinline bool is_parallel(Line l1,Line l2){return dcmp(cross(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\tinline bool is_vertical(Line l1,Line l2){return dcmp(dot(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\t\n\tPoint project(Line l,Point p){\n\t\tVector base=l.p2-l.p1;\n\t\tdouble r=dot(p-l.p1,base)/norm(base);\n\t\treturn l.p1+base*r;\n\t}\n\tPoint reflect(Line l,Point p){\n\t\tPoint q=project(l,p);\n\t\tVector v=p-q;v.x=-v.x;v.y=-v.y;\n\t\treturn q+v;\n\t}\n\tint ccw(Vector v1,Vector v2){\n\t\tif(dcmp(cross(v1,v2))>0)return 1;//COUNTER_CLOCKWISE\n\t\telse if(dcmp(cross(v1,v2))<0)return 2;//CLOCKWISE\n\t\telse{\n\t\t\tif(dcmp(dot(v1,v2))<0)return 3;//ONLINE_BACK\n\t\t\telse{\n\t\t\t\tif(dcmp(norm(v1)-norm(v2))<0)return 4;//ONLINE_FRONT\n\t\t\t\telse return 5;//ON_SEGMENT\n\t\t\t}\n\t\t}\n\t}\n\tinline bool is_inter(Line l1,Line l2){\n\t\tbool flag=1;\n\t\tint t1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\tswap(l1,l2);\n\t\tt1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\treturn true;\n\t}\n}\nusing namespace LCY;\nint main(){\n\tint n;cin>>n;while(n--){\n\t\tPoint p1,p2,p3,p4;\n\t\tcin>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y>>p4.x>>p4.y;\n\t\tcout<<(is_inter(Line(p1,p2),Line(p3,p4)))<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() {return x * x + y * y; }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  cout << fixed;\n  for (int i = 0; i < n; i++) {\n    Segment s1, s2;\n    cin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y;\n    cin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n    if (intersect(s1, s2)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\nstatic const double EPS = 1e-14;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nint cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_intersect(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < 0)\n\t\t\t&& (cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < 0);\n}\n\nint ax, ay, bx, by;\nint n;\nvector<P> v;\nP A, B;\n//void solve() {\n//\tcin >> ax >> ay >> bx >> by;\n//\tA = P(ax, ay);\n//\tB = P(bx, by);\n//\tcin >> n;\n//\trep(i,0,n)\n//\t{\n//\t\tint x, y;\n//\t\tcin >> x >> y;\n//\t\tv.push_back(P(x, y));\n//\t}\n//\tint cnt = 0;\n//\tfor (int i = 1; i <= n; ++i) {\n//\t\tP p1 = v[i - 1], p2 = v[i % n];\n//\t\tif (is_intersect(A, B, p1, p2)) {\n//\t\t\tcnt++;\n//\t\t}\n//\t}\n//\tcout << cnt / 2 + 1 << endl;\n//}\n\nvoid solve() {\n\tint q;\n\tcin >> q;\n\trep(i,0,q)\n\t{\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tcout\n\t\t\t\t<< (is_intersect(P(x0, y0), P(x1, y1), P(x2, y2), P(x3, y3)) ?\n\t\t\t\t\t\t1 : 0) << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing ll = long long;\nusing namespace std;\nconst int INF = 1e9;\n\n//https://dai1741.github.io/maximum-algo-2012/cpp/geometry/geometries2d.h\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define EQ(n, m) (abs((n) - (m)) < EPS)\n\nD dot(P a, P b) {\n    return (conj(a) * b).X;\n}\nD cross(P a, P b) {\n    return (conj(a) * b).Y;\n}\n\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS)\n        return +1;\n    if (cross(b, c) < -EPS)\n        return -1;\n    if (dot(b, c) < -EPS)\n        return +2;\n    if (norm(b) < norm(c))\n        return -2;\n    return 0;\n}\n\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    P x = a2 - a1;\n    P y = b2 - b1;\n    return EQ(cross(x, y), 0.0);\n}\n\nbool is_orthogonal(P a1, P a2, P b1, P b2) {\n    P x = a2 - a1;\n    P y = b2 - b1;\n    return EQ(dot(x, y), 0.0);\n}\n\nbool isecLP(P a1, P a2, P b) {\n    return abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1, P b2) {\n    return !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nbool isecLS(P a1, P a2, P b1, P b2) {\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nbool isecSP(P a1, P a2, P b) {\n    return !ccw(a1, a2, b);\n}\n\nP proj(P a1, P a2, P p) {\n    return a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n\nP reflection(P a1, P a2, P p) {\n    return 2.0 * proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n    return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n    return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n    return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n    P r = proj(a1, a2, p);\n    if (isecSP(a1, a2, r))\n        return abs(r - p);\n    return min(abs(a1 - p), abs(a2 - p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n    if (isecSS(a1, a2, b1, b2))\n        return 0;\n    return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n               min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    D d1 = cross(b2 - b1, b1 - a1);\n    D d2 = cross(b2 - b1, a2 - a1);\n    if (EQ(d1, 0) && EQ(d2, 0))\n        return a1;\n    if (EQ(d2, 0))\n        throw \"kouten ga nai\";\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\nD distLC(P a1, P a2, P c, D r) {\n    return max(distLP(a1, a2, c) - r, 0.0);\n}\n\nD distSC(P a1, P a2, P c, D r) {\n    D dSqr1 = norm(c - a1), dSqr2 = norm(c - a2);\n    if (dSqr1 < r * r ^ dSqr2 < r * r)\n        return 0;\n    if (dSqr1 < r * r & dSqr2 < r * r)\n        return r - sqrt(max(dSqr1, dSqr2));\n    return max(distSP(a1, a2, c) - r, 0.0);\n}\n\nVP crosspointLC(P a1, P a2, P c, D r) {\n    VP ps;\n    P ft = proj(a1, a2, c);\n    if (!GE(r * r, norm(ft - c)))\n        return ps;\n\n    P dir = sqrt(max(r * r - norm(ft - c), 0.0)) / abs(a2 - a1) * (a2 - a1);\n    ps.push_back(ft + dir);\n    if (!EQ(r * r, norm(ft - c)))\n        ps.push_back(ft - dir);\n    return ps;\n}\n\nD distCC(P a, D ar, P b, D br) {\n    D d = abs(a - b);\n    return GE(d, abs(ar - br)) ? max(d - ar - br, 0.0) : abs(ar - br) - d;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n    VP ps;\n    P ab = b - a;\n    D d = abs(ab);\n    D crL = (norm(ab) + ar * ar - br * br) / (2 * d);\n    if (EQ(d, 0) || ar < abs(crL))\n        return ps;\n\n    P abN = ab * P(0, sqrt(ar * ar - crL * crL) / d);\n    P cp = a + crL / d * ab;\n    ps.push_back(cp + abN);\n    if (!EQ(norm(abN), 0))\n        ps.push_back(cp - abN);\n    return ps;\n}\n\nVP tangentPoints(P a, D ar, P p) {\n    VP ps;\n    D sin = ar / abs(p - a);\n    if (!LE(sin, 1))\n        return ps;\n    D t = M_PI_2 - asin(min(sin, 1.0));\n    ps.push_back(a + (p - a) * polar(sin, t));\n    if (!EQ(sin, 1))\n        ps.push_back(a + (p - a) * polar(sin, -t));\n    return ps;\n}\n\nvector<L> tangentLines(P a, D ar, P b, D br) {\n    vector<L> ls;\n    D d = abs(b - a);\n    rep(i, 2) {\n        D sin = (ar - (1 - i * 2) * br) / d;\n        if (!LE(sin * sin, 1))\n            break;\n        D cos = sqrt(max(1 - sin * sin, 0.0));\n        rep(j, 2) {\n            P n = (b - a) * P(sin, (1 - j * 2) * cos) / d;\n            ls.push_back(L(a + ar * n, b + (1 - i * 2) * br * n));\n            if (cos < EPS)\n                break;\n        }\n    }\n    return ls;\n}\n\nP circumcenter(P a, P b, P c) {\n    a = (a - c) * 0.5;\n    b = (b - c) * 0.5;\n    return c + crosspointLL(a, a * P(1, 1), b, b * P(1, 1));\n}\n\nVP circlesPointsRadius(P a, P b, D r) {\n    VP cs;\n    P abH = (b - a) * 0.5;\n    D d = abs(abH);\n    if (d == 0 || d > r)\n        return cs;\n    D dN = sqrt(r * r - d * d);\n    P n = abH * P(0, 1) * (dN / d);\n    cs.push_back(a + abH + n);\n    if (dN > 0)\n        cs.push_back(a + abH - n);\n    return cs;\n}\n\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n    P n = (l2 - l1) * P(0, 1);\n    P m = (b - a) * P(0, 0.5);\n    D rC = dot((a + b) * 0.5 - l1, n);\n    D qa = norm(n) * norm(m) - dot(n, m) * dot(n, m);\n    D qb = -rC * dot(n, m);\n    D qc = norm(n) * norm(m) - rC * rC;\n    D qd = qb * qb - qa * qc;\n\n    VP cs;\n    if (qd < -EPS)\n        return cs;\n    if (EQ(qa, 0)) {\n        if (!EQ(qb, 0))\n            cs.push_back((a + b) * 0.5 - m * (qc / qb / 2));\n        return cs;\n    }\n    D t = -qb / qa;\n    cs.push_back((a + b) * 0.5 + m * (t + sqrt(max(qd, 0.0)) / qa));\n    if (qd > EPS)\n        cs.push_back((a + b) * 0.5 + m * (t - sqrt(max(qd, 0.0)) / qa));\n    return cs;\n}\n\nP minEnclosingCircle(const VP &ps) {\n    P c;\n    double move = 0.5;\n    rep(i, 39) {\n        rep(t, 50) {\n            D max = 0;\n            int k = 0;\n            rep(j, ps.size()) if (max < norm(ps[j] - c)) {\n                max = norm(ps[j] - c);\n                k = j;\n            }\n            c += (ps[k] - c) * move;\n        }\n        move /= 2;\n    }\n    return c;\n}\n\nnamespace std {\nbool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n} // namespace std\n\nVP convexHull(VP ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    VP ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nbool isCcwConvex(const VP &ps) {\n    int n = ps.size();\n    rep(i, n) if (ccw(ps[i], ps[(i + 1) % n], ps[(i + 2) % n]) == -1) return false;\n    return true;\n}\n\nint inConvex(P p, const VP &ps) {\n    int n = ps.size();\n    int dir = ccw(ps[0], ps[1], p);\n    rep(i, n) {\n        int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n        if (!ccwc)\n            return 2;\n        if (ccwc != dir)\n            return 0;\n    }\n    return 1;\n}\n\nint inCcwConvex(const VP &ps, P p) {\n    int n = ps.size();\n    P g = (ps[0] + ps[n / 3] + ps[n * 2 / 3]) / 3.0;\n    if (g == p)\n        return 1;\n    P gp = p - g;\n\n    int l = 0, r = n;\n    while (l + 1 < r) {\n        int mid = (l + r) / 2;\n        P gl = ps[l] - g;\n        P gm = ps[mid] - g;\n        if (cross(gl, gm) > 0) {\n            if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0)\n                r = mid;\n            else\n                l = mid;\n        } else {\n            if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0)\n                l = mid;\n            else\n                r = mid;\n        }\n    }\n    r %= n;\n    D cr = cross(ps[l] - p, ps[r] - p);\n    return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n\nint inPolygon(const VP &ps, P p) {\n    int n = ps.size();\n    bool in = false;\n    rep(i, n) {\n        P a = ps[i] - p;\n        P b = ps[(i + 1) % n] - p;\n        if (EQ(cross(a, b), 0) && LE(dot(a, b), 0))\n            return 2;\n        if (a.Y > b.Y)\n            swap(a, b);\n        if ((a.Y * b.Y < 0 || (a.Y * b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0))\n            in = !in;\n    }\n    return in;\n}\n\nVP convexCut(const VP &ps, P a1, P a2) {\n    int n = ps.size();\n    VP ret;\n    rep(i, n) {\n        int ccwc = ccw(a1, a2, ps[i]);\n        if (ccwc != -1)\n            ret.push_back(ps[i]);\n        int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n        if (ccwc * ccwn == -1)\n            ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n    }\n    return ret;\n}\n\npair<int, int> convexDiameter(const VP &ps) {\n    int n = ps.size();\n    int i = min_element(ps.begin(), ps.end()) - ps.begin();\n    int j = max_element(ps.begin(), ps.end()) - ps.begin();\n    int maxI, maxJ;\n    D maxD = 0;\n    rep(_, 2 * n) {\n        if (maxD < norm(ps[i] - ps[j])) {\n            maxD = norm(ps[i] - ps[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if (cross(ps[i] - ps[(i + 1) % n], ps[(j + 1) % n] - ps[j]) <= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\n\nD area(const VP &ps) {\n    D a = 0;\n    rep(i, ps.size()) a += cross(ps[i], ps[(i + 1) % ps.size()]);\n    return a / 2;\n}\n\nP centroid(const VP &ps) {\n    int n = ps.size();\n    D aSum = 0;\n    P c;\n    rep(i, n) {\n        D a = cross(ps[i], ps[(i + 1) % n]);\n        aSum += a;\n        c += (ps[i] + ps[(i + 1) % n]) * a;\n    }\n    return 1 / aSum / 3 * c;\n}\n\nVP voronoiCell(P p, const VP &ps, const VP &outer) {\n    VP cl = outer;\n    rep(i, ps.size()) {\n        if (EQ(norm(ps[i] - p), 0))\n            continue;\n        P h = (p + ps[i]) * 0.5;\n        cl = convexCut(cl, h, h + (ps[i] - h) * P(0, 1));\n    }\n    return cl;\n}\n\nstruct Edge {\n    int from, to;\n    D cost;\n    Edge(int from, int to, D cost) : from(from), to(to), cost(cost) {}\n};\nstruct Graph {\n    int n;\n    vector<vector<Edge>> edges;\n    Graph(int n) : n(n), edges(n) {}\n    void addEdge(Edge e) {\n        edges[e.from].push_back(e);\n        edges[e.to].push_back(Edge(e.to, e.from, e.cost));\n    }\n};\n\nGraph segmentArrangement(const vector<L> &segs, VP &ps) {\n    int n = segs.size();\n    rep(i, n) {\n        ps.push_back(segs[i].first);\n        ps.push_back(segs[i].second);\n        rep(j, i) {\n            if (isecSS(segs[i].first, segs[i].second, segs[j].first, segs[j].second))\n                ps.push_back(crosspointLL(segs[i].first, segs[i].second, segs[j].first, segs[j].second));\n        }\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int m = ps.size();\n    Graph gr(m);\n    vector<pair<D, int>> list;\n    rep(i, n) {\n        list.clear();\n        rep(j, m) {\n            if (isecSP(segs[i].first, segs[i].second, ps[j]))\n                list.push_back(make_pair(norm(segs[i].first - ps[j]), j));\n        }\n        sort(list.begin(), list.end());\n        rep(j, list.size() - 1) {\n            int a = list[j].second;\n            int b = list[j + 1].second;\n            gr.addEdge(Edge(a, b, abs(ps[a] - ps[b])));\n        }\n    }\n    return gr;\n}\n\nGraph visibilityGraph(const VP &ps, const vector<VP> &objs) {\n    int n = ps.size();\n    Graph gr(n);\n    rep(i, n) rep(j, i) {\n        P a = ps[i], b = ps[j];\n        if (!EQ(norm(a - b), 0))\n            rep(k, objs.size()) {\n                const VP &obj = objs[k];\n                int inStA = inConvex(a, obj);\n                int inStB = inConvex(b, obj);\n                if ((inStA ^ inStB) % 2 || inStA * inStB != 1 && inConvex((a + b) * 0.5, obj) == 1)\n                    goto skip;\n                rep(l, obj.size()) {\n                    P cur = obj[l];\n                    P next = obj[(l + 1) % obj.size()];\n                    if (isecSS(a, b, cur, next) && !isecSP(cur, next, a) && !isecSP(cur, next, b))\n                        goto skip;\n                }\n            }\n        gr.addEdge(Edge(i, j, abs(a - b)));\n    skip : {}\n    }\n    return gr;\n}\nint main() {\n    int Q;\n    cin >> Q;\n    rep(i, Q) {\n        P p[4];\n        rep(j, 4) {\n            D x, y;\n            cin >> x >> y;\n            p[j] = P(x, y);\n        }\n\n        if (isecSS(p[0], p[1], p[2], p[3]))\n            cout << 1;\n        else\n            cout << 0;\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(O,a.t-a.s,b.t-b.s)==0;}\nbool parallel(L a,L b) {return sdet(O,a.t-a.s,b.t-b.s)==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(O,a.t-a.s,b.t-b.s);\n\treturn u*a.s+(1-u)*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h=l.s;\n\tif(sdot(l.t,l.s,p)<=0) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << (sgn(dss(s1,s2))==0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n?\n?\nusing namespace std;\n?\ntypedef double Real;\n?\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n?\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n?\nstruct Point{? \n??Real add(Real a, Real b){\n????if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n????return a+b;\n??}\n?\n??Real x, y;\n??Point(){}\n??Point(Real x,Real y) : x(x) , y(y){}\n?\n??Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n??Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n??Point operator * (Real d){return Point(x*d,y*d);}\n??Point operator / (Real d){return Point(x/d,y/d);}\n??bool operator == (Point p){return !sgn(dist(p));}\n??bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n??Real norm(){return sqr(x*x+y*y);}\n??Real dist(Point a){return (*this-a).norm();}\n??Real dot(Point a){return x*a.x+y*a.y;}\n??Real cross(Point a){return x*a.y-y*a.x;}\n??//点pを中心に角度r(radius)だけ半時計回りに回転する\n??Point rotate(Real r,Point p = Point(0,0)){\n????Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n????Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n????return Point(ta,tb);\n??}\n??Real arg(){\n????if(sgn(x)>0)return atan(y/x);\n????if(sgn(x)<0)return atan(y/x)+PI;\n????if(sgn(y)>0)return PI/2;\n????if(sgn(y)<0)return 3*PI/2;\n????return 0;\n??}\n};\n?\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n??b = b-a; c = c-a;\n??if (b.cross(c) > 0)?? return +1;?????? // counter clockwise\n??if (b.cross(c) < 0)?? return -1;?????? // clockwise\n??if (b.dot(c) < 0)???? return +2;?????? // c--a--b on line\n??if (b.norm() < c.norm()) return -2;??? // a--b--c on line\n??return 0;????????????????????????????? // a--c--b on line\n}\n?\nstruct Line{\n??Point a,b;\n?\n??Line(){}\n??Line(Point a,Point b):a(a),b(b){}\n?\n??bool on(Point c){return abs(ccw(a,b,c))!=1;}\n??Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n??bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n??bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n??bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n??//平行でない前提\n??Point intersectionPoint(Line l){\n????return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n??}\n?\n};\n?\nstruct Segment: public Line{\n??Point a,b;\n???\n??bool on(Point c){return ccw(a,b,c)==0;}\n??bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n?\n??Real dist(Point c){\n????if((b-a).dot(c-a)<EPS)return c.dist(a);\n????if((a-b).dot(c-b)<EPS)return c.dist(b);\n????return abs((b-a).cross(c-a))/b.dist(a);??? \n??}\n?\n??Point intersectionPoint(Segment s){\n????Point q=s.b-s.a;\n????Real d1=abs(q.cross(a-s.a));\n????Real d2=abs(q.cross(b-s.a));\n????Real t=d1/(d1+d2);\n????return a+(b-a)*t;\n??}\n?\n??//この線分が直線lの上に載っていない前提\n??bool isIntersection(Line l){\n????int p=ccw(a,b,l.a);\n????int q=ccw(a,b,l.b);\n????return (p==1 && q==-1)||(p==-1 && q==1);\n??}\n?\n??bool isIntersection(Segment s){\n????return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n????????ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n??}\n};\n?\nint main(void){\n?\n??int q;\n??cin >> q;\n??while(q--){\n????Segment a,b;\n????cin >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n????cin >> b.a.x >> b.a.y >> b.b.x >> b.b.y;\n????cout << a.isIntersection(b) << endl;\n??}\n?\n??return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\ntypedef struct _PT {\n  double x, y;\n  _PT() {}\n  _PT(double x, double y) : x(x), y(y) {} \n  _PT operator + (_PT p){\n     return _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n     return _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (double d){\n     return _PT(d*x, d*y);\n  }\n\n  double norm(void){\n    return sqrt(x*x + y*y);\n  }\n\n  double twiceNorm(void){\n    return x*x + y*y;\n  }\n\n  double dist(_PT p){ //pとの距離の2乗\n     return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n     return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n     return x == e.x? (y > e.y) : x > e.x;\n  }\n\n  double dot(_PT p){ //pとの内積\n     return x * p.x + y * p.y;\n  }\n  \n  double det(_PT p){ // (x,p)の外積\n     return x * p.y - p.x * y;\n  }\n}P;\n\nP intersection(P p1,P p2,P q1,P q2) { //線分 p1-p2とq1-q2の交点\n  \treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool on_seq(P p1,P p2,P q) { // 線分p1-p2上に点qがあるか\n    return (abs((p1 - q).det(p2 - q)) < eps) && ((p1 - q).dot(p2 - q) < eps);\n}\n\nint main(void) {\n\tlong N;\n\tcin >> N;\n\tREP(i,N) {\n\t\tP p1,p2,q1,q2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> q1.x >> q1.y >> q2.x >> q2.y;\n\t\tif (abs((p1-p2).det(q1-q2)) > eps) {\n\t\t\tP r = intersection(p1,p2,q1,q2);\n\t\t\tif (on_seq(p1,p2,r) && on_seq(q1,q2,r)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t\telse {\n\t\t\tif (on_seq(p1,p2,q1) || on_seq(p1,p2,q2) || on_seq(q1,q2,p1) || on_seq(q1,q2,p2)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <vector>\n\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\n//直線と直線の交差\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\n//線分と線分の交差\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  int x1,y1,x2,y2,x3,y3,x4,y4;\n  for(int i=0;i<n;i++){\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n    \n    P p1(x1,y1);\n    P p2(x2,y2);\n    L l1(p1,p2);\n\n    P p3(x3,y3);\n    P p4(x4,y4);\n\n    L l2(p3,p4);\n\n    cout << intersectSS(l1,l2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>eps) return 1;\n\t\tif(Getmp<-eps) return 2;\n\t\tif(IP(Ge1,Ge2)<eps) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tif(four_JUD(Gex.first,Gex.second,Gey.first,Gey.second)){\n\t\t\tint Ge1=PJUD(Gex.first,Gey.first,Gex.second),Ge2=PJUD(Gex.first,Gey.second,Gex.second),Ge3=PJUD(Gey.first,Gex.first,Gey.second),Ge4=PJUD(Gey.first,Gex.second,Gey.second);\n\t\t\tif(Ge1==4&&Ge2==4&&Ge3==4&&Ge4==4) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif(LJUD(Gex,Gey)==2) return 0;\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tbool four_JUD(point Gea,point Geb,point Gec,point Ged){\n\t\tint Ge1=PJUD(Gea,Geb,Gec),Ge2=PJUD(Gea,Geb,Ged);\n\t\tif(Ge1!=1&&Ge1!=2&&Ge2!=1&&Ge2!=2) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n            if(x1>x2)swap(x1, x2);\n            if(x3>x4)swap(x3, x4);\n            if(y1>y2)swap(y1, y2);\n            if(y3>y4)swap(y3, y4);\n            \n            if(x1<=x3&&x3<=x2){\n                if(y1<=y3&&y3<=y2)return 1;\n            }\n            if(x1<=x4&&x4<=x2){\n                if(y1<=y4&&y4<=y2)return 1;\n            }\n            \n            if(x3<=x1&&x1<=x3){\n                if(y3<=y1&&y1<=y3)return 1;\n            }\n            if(x3<=x2&&x2<=x3){\n                if(y3<=y2&&y2<=y3)return 1;\n            }\n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T> bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n// 実数\nusing Real = double;\n// 点\nusing Point = complex<Real>;\nconst Real EPS = 1e-10, PI = acos(-1);\n\n// 実数同士の比較\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point& p, const Real& d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\n// 点の入力\nistream& operator>>(istream& is, Point& p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n//// 点の出力\n//ostream &operator<<(ostream &os, Point &p) {\n//  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n//}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point& p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアンを度数に変換\nReal radian_to_degree(Real r) {\n    return (r * 180.0 / PI);\n}\n\n// 度数をラジアンに変換\nReal degree_to_radian(Real d) {\n    return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point& a, const Point& b, const Point& c) {\n    const Point v(b - a), w(c - a);\n    Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n    if (alpha > beta) swap(alpha, beta);\n    Real theta = (beta - alpha);\n    return min(theta, 2 * acos(-1) - theta);\n}\n\n// ソート x座標が小さい順に並べる x座標が同じならy座標が小さい順\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n// 2点を通る直線\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if (eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream& operator<<(ostream& os, Line& p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream& operator>>(istream& is, Line& a) {\n        return is >> a.a >> a.b;\n    }\n};\n\n// 2点を結ぶ線分\nstruct Segment : Line {\n    Segment() = default;\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n// 円\nstruct Circle {\n    // 中心\n    Point p;\n    // 半径\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\n// 点集合\nusing Points = vector< Point >;\n// ポリゴン 反時計回り\nusing Polygon = vector< Point >;   // 注意!! 凸多角形は反時計回りに与える.(保証されない場合は面積が負なら reverse をかける)\n// 線分集合\nusing Segments = vector< Segment >;\n// 直線集合\nusing Lines = vector< Line >;\n// 円集合\nusing Circles = vector< Circle >;\n\n// 外積\nReal cross(const Point& a, const Point& b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\n// 内積\nReal dot(const Point& a, const Point& b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// 点の回転方向\n//          +1\n//          \n//  +2   a   0   b  -2\n//\n//          -1\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\nint ccw(const Point& a, const Point& b, const Point& c) {\n    if (cross(b - a, c - a) > EPS) return +1;\n    if (cross(b - a, c - a) < -EPS) return -1;\n    if (dot(b - a, c - a) < -EPS) return +2;\n    if (norm(b - a) + EPS < norm(c - a)) return -2;\n    return 0;\n}\n\n// 線分同士の交差判定\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 直線同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\nPoint crosspoint(const Line& l, const Line& m) {\n    Real A = cross(l.b - l.a, m.b - m.a);\n    Real B = cross(l.b - l.a, l.b - m.a);\n    if (eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * B / (A + 1e-18);\n}\n\n// 線分同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment& l, const Segment& m) {\n    return crosspoint(Line(l), Line(m));\n}\n\nReal CalcDist(const Segment& s, const Point& p) {\n    double t = dot(s.b - s.a, p - s.a) / norm(s.b - s.a);\n    Point c = s.a + (s.b - s.a) * t;\n    Real res = 1000000.0;\n    if (t > -EPS && t < 1.0 + EPS) return sqrt(norm(p - c));\n    chmin(res, sqrt(norm(p - s.b)));\n    chmin(res, sqrt(norm(p - s.a)));\n    return res;\n}\n\nReal CalcDist(const Segment& a, const Segment& b) {\n    if (intersect(a, b)) return 0.0;\n    return min({CalcDist(a, b.a), CalcDist(a, b.b), CalcDist(b, a.a), CalcDist(b, a.b)});\n}\n\nint main() {\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; ++i) {\n        Point p0, p1, p2, p3;\n        cin >> p0 >> p1 >> p2 >> p3;\n        Segment seg1(p0, p1), seg2(p2, p3);\n\n        if (intersect(seg1, seg2)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (is_parallel(p0, p1, p2, p3)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace arithmetic {\n  template<typename T> class Addition {\n  public:\n    template<typename V> T operator+(const V& v) const {\n      return T(static_cast<const T&>(*this)) += v;\n    }\n  };\n\n  template<typename T> class Subtraction {\n  public:\n    template<typename V> T operator-(const V& v) const {\n      return T(static_cast<const T&>(*this)) -= v;\n    }\n  };\n\n  template<typename T> class Multiplication {\n  public:\n    template<typename V> T operator*(const V& v) const {\n      return T(static_cast<const T&>(*this)) *= v;\n    }\n  };\n\n  template<typename T> class Division {\n  public:\n    template<typename V> T operator/(const V& v) const {\n      return T(static_cast<const T&>(*this)) /= v;\n    }\n  };\n\n  template<typename T> class Modulus {\n  public:\n    template<typename V> T operator%(const V& v) const {\n      return T(static_cast<const T&>(*this)) %= v;\n    }\n  };\n}\n\ntemplate<typename T> class IndivisibleArithmetic : public arithmetic::Addition<T>, public arithmetic::Subtraction<T>, public arithmetic::Multiplication<T> {};\n\ntemplate<typename T> class Arithmetic : public IndivisibleArithmetic<T>, public arithmetic::Division<T> {};\n\ntemplate<typename T> class Ordered {\npublic:\n  template<typename V> bool operator==(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n  \n  template<typename V> bool operator!=(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v);\n  }\n\n  template<typename V> bool operator>(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this);\n  }\n\n  template<typename V> bool operator<=(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this));\n  }\n\n  template<typename V> bool operator>=(const V& v) const {\n    return !(static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n};\n\ntemplate<typename T> inline T gcd(T a, T b) {\n  return __gcd(a, b);\n}\n\ntemplate<typename T> inline T lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\n\ntemplate<typename T> inline T floor(T a, T b) {\n  return floor(a / b) * b <= a ? floor(a / b) : floor(a / b) - 1;\n}\n\ntemplate<typename T> inline T ceil(T a, T b) {\n  return floor(a + b - 1, b);\n}\n\ntemplate<typename T> inline T round(T a, T b) {\n  return floor(a + b / 2);\n}\n\ntemplate<typename T> inline T mod(T a, T b) {\n  return a - floor(a, b) * b;\n}\n\ntemplate<typename T> inline T factorial(T n) {\n  return n <= 1 ? 1 : factorial(n - 1) * n;\n}\n\nclass Real : public Arithmetic<Real>, public arithmetic::Modulus<Real>, public Ordered<Real> {\nprivate:\n  static long double EPS;\n  long double val;\n\n  operator long double() const {\n    return val;\n  }\n\npublic:\n  Real() {}\n\n  Real(long double val) : val(val) {}\n\n  Real operator-() const {\n    return -val;\n  }\n\n  template<typename T> Real operator+=(const T& r) {\n    val += static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator-=(const T& r) {\n    val -= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator*=(const T& r) {\n    val *= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator/=(const T& r) {\n    val /= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator%=(const T& r) {\n    return *this = mod(*this, static_cast<Real>(r));\n  }\n\n  template<typename T> Real operator-(const T& v) const {\n    return Real(*this) -= v;\n  }\n\n  template<typename T> bool operator<(const T r) const {\n    return val < static_cast<long double>(r) - EPS;\n  }\n\n  Real abs() const {\n    return std::abs(val);\n  }\n\n  Real sqrt() const {\n    return std::sqrt(val);\n  }\n\n  long double toLongDouble() const {\n    return val;\n  }\n};\n\nlong double Real::EPS = 1e-8;\n\ninline ostream& operator<<(ostream& os, const Real& a) {\n  os << fixed << setprecision(15) << a.toLongDouble();\n  return os;\n}\n\ninline istream& operator>>(istream& is, Real& a) {\n\tlong double n;\n\tis >> n;\n\ta = n;\n\treturn is;\n}\n\nReal floor(const Real& r) {\n  return floor(r.toLongDouble());\n}\n\nclass Point : public Arithmetic<Point> {\npublic:\n  Real x, y;\n\n  Point() {}\n\n  Point(const Real& x) : x(x), y(0) {}\n\n  Point(const Real& x, const Real& y) : x(x), y(y) {}\n\n  Point operator+=(const Point& p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n\n  Point operator-=(const Point& p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n\n  Point operator*=(const Point& p) {\n    Real xx = x * p.x - y * p.y;\n    y = x * p.y + y * p.x;\n    x = xx;\n    return *this;\n  }\n\n  Point operator*=(const Real& r) {\n    x *= r;\n    y *= r;\n    return *this;\n  }\n\n  Point operator/=(const Point& p) {\n    Real nrm = p.norm();\n    Real xx = (x * p.x + y * p.y) / nrm;\n    y = (y * p.x - x * p.y) / nrm;\n    x = xx;\n    return *this;\n  }\n\n  Point operator/=(const Real& r) {\n    x /= r;\n    y /= r;\n    return *this;\n  }\n\n  Real norm() const {\n    return x * x + y * y;\n  }\n\n  Real abs() const {\n    return norm().sqrt();\n  }\n\n  Point conj() const {\n    return Point(x, -y);\n  }\n};\n\ninline ostream& operator<<(ostream& os, const Point& point) {\n\tos << point.x << \" \" << point.y;\n\treturn os;\n}\n\ninline istream& operator>>(istream& is, Point& point) {\n  Real x, y;\n\tis >> x >> y;\n\tpoint = Point(x, y);\n\treturn is;\n}\n\nclass Line {\npublic:\n  Point a, b;\n\n  Line() {}\n\n  Line (const Point& a, const Point& b) : a(a), b(b) {}\n\n  bool operator==(const Line& line) const {\n    return ((line.vec() / vec()).y == 0) && (((line.a - a) / vec()).y == 0);\n  }\n\n  Point vec() const {\n    return b - a;\n  }\n};\n\ninline ostream& operator<<(ostream& os, const Line& line) {\n\tos << line.a << \" \" << line.b;\n\treturn os;\n}\n\ninline istream& operator>>(istream& is, Line& line) {\n  Point a, b;\n  is >> a >> b;\n  line = Line(a, b);\n  return is;\n}\n\nclass Segment : public Line {\npublic:\n  Segment() {}\n\n  Segment (const Point& a, const Point& b) : Line(a, b) {}\n};\n\nenum CCW{LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\n\nint ccw(const Segment& segment, const Point& point) {\n  Point p = (point - segment.a) / segment.vec();\n  if (p.y > 0) return LEFT;\n  if (p.y < 0) return RIGHT;\n  if (p.x < 0) return BACK;\n  if (p.x > 1) return FRONT;\n  return ON;\n}\n\ntemplate<bool strict = false> inline bool intersect(const Line& line1, const Line& line2) {\n  if (strict) return (line1.vec() / line2.vec()).y != 0;\n  return ((line1.vec() / line2.vec()).y != 0) || (line1 == line2);\n}\n\ntemplate<bool strict = false> inline bool intersect(const Line& line, const Segment& segment) {\n  Point p1 = segment.a / line.vec(), p2 = segment.b / line.vec();\n  if (strict) return p1.y * p2.y < 0;\n  return p1.y * p2.y <= 0;\n}\n\ntemplate<bool strict = false> inline bool intersect(const Segment& segment, const Line& line) {\n  return intersect(line, segment);\n}\n\ntemplate<bool strict = false> inline bool intersect(const Segment& segment1, const Segment& segment2) {\n  int ccw1 = ccw(segment1, segment2.a) | ccw(segment1, segment2.b);\n  int ccw2 = ccw(segment2, segment1.a) | ccw(segment2, segment1.b);\n  if (strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return ((ccw1 & ccw2) == (LEFT | RIGHT)) || ((ccw1 | ccw2) & ON);\n}\n\nint main() {\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    Segment segment1, segment2;\n    cin >> segment1 >> segment2;\n    if (intersect(segment1, segment2)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - x3.x);\n    double td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - x4.x);\n    return tc * td < 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << intersect(s1, s2) ? 1 : 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long lint;\ntypedef pair<int,int> P;\nconst int    INF=(int)1e9;\nconst int    MOD=(int)1e9+7;\nconst double EPS=(double)1e-10;\nconst int    dx[]={-1,0,0,1};\nconst int    dy[]={0,-1,1,0};\nstruct Accelerate_Cin{\n    Accelerate_Cin(){\n        cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);\n    };\n};\n\n//幾何学テンプレート\n\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\n//点\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0):x(x), y(y){};\n\n  Point operator + (Point p) {return Point (x+p.x, y+p.y);}\n  Point operator - (Point p) {return Point (x-p.x, y-p.y);}\n  Point operator * (double a) {return Point(a*x, a*y);}\n  Point operator / (double a) {return Point(x/a,y/a);}\n\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n\n  bool operator < (const Point &p)const{\n    return x!=p.x ? x<p.x:y<p.y;\n  }\n  bool operator > (const Point &p)const{\n    return x!=p.x ? x>p.x:y>p.y;\n  }\n  bool operator == (const Point &p)const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\n//ベクトル\ntypedef Point Vector;\n\n//内積\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\n\n//外積\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\n//線分\nstruct Segment{Point p1,p2;};\n\n//直線\ntypedef Segment Line;\n\n//円\nclass Circle{\npublic:\n  Point c;   //中心\n  double r;  //半径\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n//二つの線分の交差判定をする。\n\n//3点の位置関係を調べる。\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS)   return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)  return CLOCKWISE;\n  if(dot(a,b)<-EPS)    return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\nsigned main(){\n  int q;cin>>q;\n\n  for(int i=0;i<q;i++){\n    double x0,y0,x1,y1,x2,y2,x3,y3;cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    Point p0={x0,y0},p1={x1,y1},p2={x2,y2},p3={x3,y3};\n    cout<<intersect(p0,p1,p2,p3)<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double ta, tb, tc, td;\n    ta = (p3.x - p4.x) * (p1.y - p3.y) + (p3.y - p4.y) * (p3.x - p1.x);\n    tb = (p3.x - p4.x) * (p2.y - p3.y) + (p3.y - p4.y) * (p3.x - p2.x);\n    tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - p3.x);\n    td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - p4.x);\n    return ta * tb <= 0 && tc * td <= 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    return d < 0? -1 : 1;\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x=0, double y=0): x(x), y(y){\n    }\n};\n\ntypedef Vector Point;\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nbool intersect(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double c1 = cross(a2 - a1, b1 - a1);\n    double c2 = cross(a2 - a1, b2 - a1);\n    double c3 = cross(b2 - b1, a1 - b1);\n    double c4 = cross(b2 - b1, a2 - b1);\n    \n    return dcmp(c1 * c2) <= 0 && dcmp(c3 * c4) <= 0;\n}\n\nint main() {\n    Point points[4];\n    int q;\n    cin >> q;\n    for (int kase = 0; kase < q; kase++) {\n        for (int i = 0; i < 4; i++) {\n            cin >> points[i].x >> points[i].y;\n        }\n        Vector v1 = points[1] - points[0];\n        Vector v2 = points[3] - points[2];\n\n        int ans =  intersect(points[0], points[1], points[2], points[3])? 1 : 0;\n        \n        cout << ans << endl;\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\nbool crit(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n\t// det2(V01, V02) * det2(V01, V03) > 0 ? true : false.\n\tdouble d2 = (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);\n\tdouble d3 = (p1.x - p0.x) * (p3.y - p0.y) - (p3.x - p0.x) * (p1.y - p0.y);\n\treturn (d2 > 0 && d3 > 0) || (d2 < 0 && d3 < 0);\n}\n\nbool crit_discrete(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n    double d1 = (p0.x - p2.x) * (p0.x - p3.x);\n    double d2 = (p1.x - p2.x) * (p1.x - p3.x);\n    double d3 = (p0.y - p2.y) * (p0.y - p3.y);\n    double d4 = (p1.y - p2.y) * (p1.y - p3.y);\n    return (d1 > 0 && d2 > 0) || (d1 < 0 && d2 < 0) || (d3 > 0 && d4 > 0) || (d3 < 0 && d4 < 0);\n}\n\nint main()\n{\n    int q;\n    double d12, d13;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n        if(crit(P0, P1, P2, P3) || crit(P2, P3, P0, P1)){\n            printf(\"0\\n\");\n        }else{\n            if(crit_discrete(P0, P1, P2, P3)){\n                printf(\"0\\n\");\n            }else{\n                printf(\"1\\n\");\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals( A, B ) (fabs((A) - (B)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n    Point( double x = 0, double y = 0 ): x(x), y(y) {}\n    \n    Point operator + ( Point p ) { return Point( x + p.x, y + p.y ); }\n    Point operator - ( Point p ) { return Point( x - p.x, y - p.y ); }\n    Point operator * ( double a ) { return Point( a * x, a * y ); }\n    Point operator / ( double a ) { return Point( x / a, y / a ); }\n\n    double abs() { return sqrt( norm() ); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn ( x != p.x ) ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn equals( x, p.x ) && equals( y, p.y ); \n    }\n\n    double dot( Point a ) { return x * a.x + y * a.y; }\n    double cross( Point a ) { return x * a.y - y * a.x; }\n    double distance( Point a ) {\n\treturn (*this - a).abs();\n    }\n};\n\ntypedef Point Vector;\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Line {\npublic:\n    Point p1, p2;\n    Line( Point p1 = Point(), Point p2 = Point() ): p1(p1), p2(p2){}\n    // ?????´????????????( cos = 0 )\n    bool isOrthogonal( Line a ) {\n\treturn equals( 0.0, (p1 - p2).dot( a.p1 - a.p2 ) );\n    }\n    // ??????????????????( sin = 0 )\n    bool isParallel( Line a ) {\n\treturn equals( 0.0, (p1 - p2).cross( a.p1 - a.p2 ) );\n    }\n\n    Point projection( Point p ) {\n\tVector v12 = p2 - p1;\n\tdouble r = v12.dot( p - p1 ) / v12.norm();\n\treturn p1 + v12 * r;\n    }\n\n    Point reflection( Point p ) {\n\treturn p + ( projection( p ) - p ) * 2.0;\n    }\n\n    double distance( Point p ) {\n\tVector v12 = this->p2 -this->p1;\n\tVector v10 = p - this->p1;\n\t\n\treturn v12.cross( v12 ) / v12.abs();\n    }\n\n    double distanceSP( Point p ) {\n\tif ( (p - this->p1).dot( this->p2 - this->p1 ) < 0.0 ) {\n\t    return this->p1.distance( p );\n\t} else if ( (p - this->p2).dot( this->p1 - this->p2 ) < 0.0 ) {\n\t    return this->p2.distance( p );\n\t}\n\telse {\n\t    return distance( p );\n\t}\n    }\n\n    int ccw( Point p ) {\n\tVector a = p2 - p1;\n\tVector b = p - p1;\n\tif ( a.cross( b ) > EPS ) return COUNTER_CLOCKWISE;\n\telse if ( a.cross( b ) < -EPS ) return CLOCKWISE;\n\telse if ( a.dot( b ) < -EPS ) return ONLINE_BACK;\n\telse if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\telse return ON_SEGMENT;\n    }\n\n    bool intersect( Line l ) {\n\treturn ( ( ccw( l.p1 ) * ccw( l.p2 ) <= 0 && l.ccw( p1 ) * l.ccw( p2 ) <= 0 ) );\n    }\n};\n\ntypedef Line Segment;\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n\n    for ( int i = 0; i < q; i++ ) {\n\tPoint p0, p1, p2, p3;\n\tscanf(\"%lf %lf\", &p0.x, &p0.y);\n\tscanf(\"%lf %lf\", &p1.x, &p1.y);\n\tscanf(\"%lf %lf\", &p2.x, &p2.y);\n\tscanf(\"%lf %lf\", &p3.x, &p3.y);\n\tSegment s1 = Segment( p0, p1 );\n\tSegment s2 = Segment( p2, p3 );\n\t\n\tif ( s1.intersect( s2 ) ) printf(\"1\\n\");\n\telse printf(\"0\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\nvoid swap(ll *x,ll *y){\n  ll tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point {\npublic:\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point():x(0),y(0){}\n\n    Point operator + (Point p) {return Point(x + p.x,y + p.y);}\n    Point operator - (Point p ){return Point(x - p.x,y - p.y);}\n    Point operator * (double a){return Point(x*a,y*a);}\n    Point operator / (double a){return Point(x/a,y/a);}\n\n    double abs(){return sqrt(norm());}\n    double norm(){return x * x + y * y;}\n\n    bool operator < (const Point & p) const {\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n      return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n\n    void set(double x,double y) {\n      this->x = x;\n      this->y = y;\n    }\n\n    void rotateR(){\n      double xt = x;\n      double yt = y;\n      x = yt;\n      y = -xt;\n    }\n    void rotateL(){\n      double xt = x;\n      double yt = y;\n      x = -yt;\n      y = xt;\n    }\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble norm(Point a){\n  return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n  return sqrt(norm(a));\n}\n\nbool eq(Point a,Point b){\n  return abs(a-b) < EPS;\n}\n\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a,Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Point vec1,vec2;\n  vec1 = s.p2 - s.p1;\n  vec2 = p - s.p1;\n  return s.p1 + vec1 * dot(vec1,vec2) / vec1.norm();\n}\n\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p) - p)* 2;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(a.norm() < b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Point a,Point b){\n  return abs(a-b);\n}\n\n// Line : Point\ndouble getDistanceLP(Line l,Point p){\n  return abs((cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1)));\n}\n\n// Segment : Point\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2 - s.p1,p - s.p1) < 0.0){\n    return abs(p - s.p1);\n  }\n  if(dot(s.p1 - s.p2,p - s.p2) < 0.0){\n    return abs(p - s.p2);\n  }\n  return getDistanceLP(s,p);\n}\n\n\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)){\n    return 0.0;\n  }\n  double ans = INF;\n  chmin(ans,getDistanceSP(s1,s2.p1));\n  chmin(ans,getDistanceSP(s1,s2.p2));\n  chmin(ans,getDistanceSP(s2,s1.p1));\n  chmin(ans,getDistanceSP(s2,s1.p2));\n  return ans;\n}\n\nint main() {\n  ll q;\n  double x, y;\n  cin >> q;\n  vector<Point> p(4);\n  Segment s1,s2;\n  rep(i,q){\n    rep(j,4){\n      cin >> x >> y;\n      p[j] = Point(x,y);\n    }\n    s1.p1 = p[0];\n    s1.p2 = p[1];\n    s2.p1 = p[2];\n    s2.p2 = p[3];\n    if(intersect(s1,s2)){\n      cout << 1 << endl;\n    }else{\n      cout << 0 << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\tint\tp0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0;\n\tint n = 0;\n\tdouble u = 0, s = 0, t = 0;\n\n\tcin >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\t\tn = 0;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\t\t\n\t\tif (u != 0) {\n\t\t\ts = (double)((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = - (double)((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((p2x == p0x && p2y == p0y)| (p3x == p0x && p3y == p0y))\n\t\t\t\tn = 1;\n\n\t\t\tif (p1x - p0x != 0) {\n\t\t\t\tif ((p0x - p2x) * (p0x - p3x) <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t\telse if(((p2x - p0x) * (p2x - p1x) <= 0) | ((p3x - p0x) * (p3x - p1x) <= 0))\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif ((p0y - p2y) * (p0y - p3y) <= 0)\n\t\t\t\t\tn = 1;\t\t\t\n\t\t\t\telse if (((p2y - p0y) * (p2y - p1y) <= 0) | ((p3y - p0y) * (p3y - p1y) <= 0))\n\t\t\t\t\tn = 1;\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\n/*class Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};*/\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´???\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶??????\ndouble abs(Point p){return sqrt(norm(p));}\n//??????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//??????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???±\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°?\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????????????????????¢\n/*double getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}*/\n//????¨?????????????????¨??????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//??????????????????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nmain(){\n  int n;\n  seg a,b;\n  cin>>n;\n  while(n--){\n    cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cout<<intersect(a,b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef int scalar;\n\nclass point{\n\tpublic:\n\tscalar x,y;\n\tvoid input(void){\n\t\tcin >> x >> y;\n\t}\n\tvoid print(void){\n\t\tcout << x << \" \" << y;\n\t}\n\tpoint(scalar ax=0, scalar ay=0): x(ax), y(ay){};\n\tpoint operator =(point a){\n\t\tx = a.x;\n\t\ty = a.y;\n\t\treturn *this;\n\t}\n\tpoint operator +(point a){return point(x+a.x, y+a.y);}\n\tpoint operator -(point a){return point(x-a.x, y-a.y);}\n\t\n};\n\nint cross(point p, point q, point r, point s){\n\tpoint a,b,c;\n\tscalar det;\n\tscalar inv1,inv2,inv3,inv4;\n\tscalar t,tau;\n\ta = q - p;\n\tb = r - s;\n\tc = r - p;\n\tdet = a.x * b.y - b.x * a.y;\n\tinv1 = b.y;\n\tinv2 = -b.x;\n\tinv3 = -a.y;\n\tinv4 = a.x;\n\tt   = inv1 * c.x + inv2 * c.y;\n\ttau = inv3 * c.x + inv4 * c.y;\n\tif(det == 0){\n\t\tif(t == 0 && tau == 0)return 1;\n\t\telse return 0;\n\t}else{\n\t\tif(det < 0){\n\t\t\tif(det <= t && t <= 0 && det <= tau && tau <= 0)return 1;\n\t\t}else{\n\t\t\tif(0 <= t && t <= det && 0 <= tau && tau <= det)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint q;\n\tpoint p0, p1, p2, p3;\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tp0.input();\n\t\tp1.input();\n\t\tp2.input();\n\t\tp3.input();\n\t\tcout << cross(p0, p1, p2,p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE_BACK,\n              ONLINE_FRONT, ON_SEGMENT};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    POSITION s2p1_s1 = get_position(s2.p1, s1);\n    POSITION s2p2_s1 = get_position(s2.p2, s1);\n    if (s2p1_s1 == ON_SEGMENT || s2p2_s1 == ON_SEGMENT) return true;\n    if (s2p1_s1 == CLOCKWISE) {\n        if (s2p2_s1 == COUNTER_CLOCKWISE) return true;\n        return false;\n    }\n    if (s2p1_s1 == COUNTER_CLOCKWISE) {\n        if (s2p2_s1 == CLOCKWISE) return true;\n        return false;\n    }\n    if (s2p1_s1 == ONLINE_FRONT) {\n        if (s2p2_s1 == ONLINE_BACK) return true;\n        return false;\n    }\n    if (s2p1_s1 == ONLINE_BACK) {\n        if (s2p2_s1 == ONLINE_FRONT) return true;\n        return false;\n    }\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(0,vec(a),vec(b))==0;}\nbool parallel(L a,L b) {return sdet(0,vec(a),vec(b))==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(0,vec(a),vec(b));\n\treturn (1-u)*a.s+u*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h=l.s;\n\tif(sdot(l.t,l.s,p)<=0) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << (sgn(dss(s1,s2))==0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>eps) return 1;\n\t\tif(Getmp<-eps) return 2;\n\t\tif(IP(Ge1,Ge2)<eps) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tif(four_JUD(Gex.first,Gex.second,Gey.first,Gey.second)){\n\t\t\tint Ge1=PJUD(Gex.first,Gey.first,Gex.second),Ge2=PJUD(Gex.first,Gey.second,Gex.second),Ge3=PJUD(Gey.first,Gex.first,Gey.second),Ge4=PJUD(Gey.first,Gex.second,Gey.second);\n\t\t\tif((Ge1==3||Ge1==4)&&(Ge2==3||Ge2==4)&&(Ge3==3||Ge3==4)&&(Ge4==3||Ge4==4)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif(LJUD(Gex,Gey)==2) return 0;\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tbool four_JUD(point Gea,point Geb,point Gec,point Ged){\n\t\tint Ge1=PJUD(Gea,Geb,Gec),Ge2=PJUD(Gea,Geb,Ged);\n\t\tif(Ge1!=1&&Ge1!=2&&Ge2!=1&&Ge2!=2) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   //freopen(\"in.txt\",\"w\",stdout);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<=min(x[3],x[4])||min(x[1],x[2])>=max(x[3],x[4])\n      \t   ||max(y[1],y[2])<=min(y[3],y[4])||min(y[1],y[2])>=max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  int p=cross(Point(x[1]-x[2],y[1]-y[2]),Point(x[3]-y[3],x[4]-y[4]));  \n   \t  if(p==0)\n   \t  {\n   \t    int w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(w==0)\n   \t    {\n   \t    \tint ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tint e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tint eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tint eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<=0||e<=0||eee<=0||eeee<=0) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t  puts(\"1\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n        if ((z2 * conj(z1)).imag() * (z3 * conj(z1)).imag() > 0\n            || (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() > 0\n            || (x2 - x0) * (x2 - x1) > 0 && (x3 - x0) * (x3 - x1) > 0\n            || (y2 - y0) * (y2 - y1) > 0 && (y3 - y0) * (y3 - y1) > 0\n            )\n            cout << \"0\\n\";\n        else cout << \"1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,c??????????¨???¨?????????????????¶\n//-1: a,b,c???????¨???¨?????????????????¶\n// 2: c,a,b???????????´???????????¶\n//-2: a,b,c???????????´???????????¶\n// 0: a,c,b???????????´???????????¶\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//???????±??????????????????????\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight& weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\tint Q; cin >> Q;\n\tcout << setprecision(10) << fixed;\n\twhile (Q--) {\n\t\tLine l0(input_Point(), input_Point());\n\t\tLine l1(input_Point(), input_Point());\n\t\tauto a(is_ss2(l0, l1));\n\t\tif (a.empty())cout << 0 << endl;\n\t\telse cout << 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n};\n\n\ninline Point projectionOfLP(Line L, Point P){return L[0]+(Point(P-L[0])).dot(L[0]-L[1])/norm(L[0]-L[1])*(L[0]-L[1]);}\ninline Point reflectionOfLP(Line L, Point P){return P+2.0*(projectionOfLP(L, P)-P);}\ninline bool intersectionDeterminationOfLL(Line L, Line M){return abs(Point(L[1]-L[0]).det(M[1]-M[0]))>EPS||abs(Point(L[1]-L[0]).det(M[0]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLS(Line L, Line S){return(Point(L[1]-L[0]).det(S[0]-L[0]))\n*(Point(L[1]-L[0]).det(S[1]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLP(Line L, Point P){return abs(Point(L[1]-P).det(L[0]-P))<EPS;}\ninline bool intersectionDeterminationOfSS(Line S, Line T){return ccw(S[0],S[1],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool intersectionDeterminationOfSP(Line S, Point P){return abs(S[0]-P)+abs(S[1]-P)-abs(S[1]-S[0])<EPS;}\ninline double distanceOfLP(Line L, Point P){return abs(P-projectionOfLP(L,P));}\ninline double distanceOfLL(Line L, Line M){return intersectionDeterminationOfLL(L,M)?0.0:distanceOfLP(L,M[0]);}\ninline double distanceOfLS(Line L, Line S){return intersectionDeterminationOfLS(L,S)?0.0:min(distanceOfLP(L,S[0]),distanceOfLP(L,S[1]));}\ninline double distanceOfSP(Line S, Point P){Point r=projectionOfLP(S,P);return intersectionDeterminationOfSP(S,r)?abs(r-P):min(abs(S[0]-P),abs(S[1]-P));}\ninline double distanceOfSS(Line S, Line T){return intersectionDeterminationOfSS(S,T)?0.0:min(min(distanceOfSP(S,T[0]),distanceOfSP(S,T[1])),min(distanceOfSP(T,S[0]),distanceOfSP(T,S[1])));}\nPoint intersectionOfLL(Line L, Line M){\n  double A = Point(L[1]-L[0]).det(M[1]-M[0]);\n  double B = Point(L[1]-L[0]).det(L[1]-M[0]);\n  if(abs(A)<EPS && abs(B)<EPS) return M[0];\n  if(abs(A)<EPS) assert(false);\n  return M[0] + B / A * (M[1] - M[0]);\n}\n\ndouble x[2], y[2];\nint q;\nint main()\n{\n  cin >> q;\n  while(q--){\n    cin >> x[0] >> y[0] >> x[1] >> y[1];  Line L = Line(Point(x[0], y[0]), Point(x[1], y[1]));\n    cin >> x[0] >> y[0] >> x[1] >> y[1];  Line M = Line(Point(x[0], y[0]), Point(x[1], y[1]));\n    puts(intersectionDeterminationOfSS(L, M) ? \"1\" : \"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n \n// #define int long long\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP1(n) REP2(i_, n)\n#define REP2(i, n) REP3(i, 0, n)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (long long i = (a); i < (long long)(b); i += (long long)(s))\n#define RREP1(n) RREP2(i_, n)\n#define RREP2(i, n) RREP3(i, 0, n)\n#define RREP3(i, a, b) RREP4(i, a, b, 1)\n#define RREP4(i, a, b, s) for (long long i = (b) - 1; i >= (long long)(a);  i -= (long long)(s))\n#define rep(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define rrep(...) GET_MACRO(__VA_ARGS__, RREP4, RREP3, RREP2, RREP1)(__VA_ARGS__)\n#define fs first\n#define sc second\n#define all(c) std::begin(c), std::end(c)\n#define rall(c) (c).begin(), (c).end()\n#define pcnt(x) __builtin_popcountll(x)\n#define each(x, c) for (auto &&x : c)\n#define endl \"\\n\"\n#define y0 y0_\n#define y1 y1_\n#define yn yn_\n#define left left_\n#define right right_\n \n#define TMP_T template<typename T>\n#define TMP_TU template<typename T, typename U>\n#define TMP_Ts template<typename ...T>\n#define TMP_NTs template<size_t N, typename ...T>\n#define TMP_CT template<bool C, typename T = void>\n \n#ifndef DEBUG\n#define cerr no_output\nstruct NoOutput : ostream {\n  TMP_T ostream &operator<<(const T &){ return *this; }\n} no_output;\n#endif\n \nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nTMP_T using PQL = priority_queue<T, vector<T>, greater<T>>;\nTMP_T using PQG = priority_queue<T>;\nTMP_CT using enable_if_t = typename enable_if<C, T>::type;\n \nconst ll LLINF = 1e18 + 10;\n#ifndef int\nconst int INF = 1e9 + 10;\n#else\nconst int INF = LLINF;\n#endif\n \nconst int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[] = {0, -1, 0, 1, -1, -1, 1, 1};\n \nTMP_T inline constexpr T sq(T x){ return x * x; }\nTMP_TU inline T& chmin(T &x, U y){ if (x > y) x = y; return x; }\nTMP_TU inline T& chmax(T &x, U y){ if (x < y) x = y; return x; }\n \nTMP_NTs enable_if_t<(N >= sizeof...(T))> input_tuple(istream &, tuple<T...> &){}\nTMP_NTs enable_if_t<(N < sizeof...(T))> input_tuple(istream &is, tuple<T...> &x){ is >> get<N>(x); input_tuple<N + 1, T...>(is, x); }\nTMP_Ts ostream &operator>>(istream &is, tuple<T...> &x){ input_tuple<0, T...>(is, x); return is; }\nTMP_TU ostream &operator>>(istream &is, pair<T, U> &x){ return is >> x.first >> x.second; }\nTMP_NTs enable_if_t<(N >= sizeof...(T))> print_tuple(ostream &, const tuple<T...> &){}\nTMP_NTs enable_if_t<(N < sizeof...(T))> print_tuple(ostream &os, const tuple<T...> &x){ os << (N > 0 ? \" \" : \"\") << get<N>(x); print_tuple<N + 1, T...>(os, x); }\nTMP_Ts ostream &operator<<(ostream &os, const tuple<T...> &x){ print_tuple<0, T...>(os, x); return os; }\nTMP_TU ostream &operator<<(ostream &os, const pair<T, U> &x){ return os << x.first << \" \" << x.second; }\nTMP_T vector<T> reversed(const vector<T> &c){ auto d = c; reverse(all(d)); return d; }\nstring reversed(const string &s){ auto t = s; reverse(all(t)); return t; }\nTMP_T void unique(vector<T> &c){ sort(all(c)); c.erase(unique(all(c)), end(c)); }\nTMP_T vector<T> uniqued(const vector<T> &c){ auto d = c; unique(d); return d; }\n\n#undef TMP_T\n#undef TMP_TU\n#undef TMP_Ts\n#undef TMP_NTs\n#undef TMP_CT\n\nll gcd(ll a, ll b){ return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntuple<ll, ll, ll> extgcd(ll a, ll b){\n  if (b){\n    ll g, x, y;\n    tie(g, x, y) = extgcd(b, a % b);\n    return make_tuple(g, y, x - a / b * y);\n  }\n  return make_tuple(a, 1, 0);\n}\nll invmod(ll a, ll m = 1000000007){\n  ll g, x;\n  tie(g, x, ignore) = extgcd(a, m);\n  return g == 1 ? (x + m) % m : 0;\n}\n\ninline ll in(){ ll x; cin >> x; return x; }\n \nstruct prepare {\n  prepare(){\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n#ifndef DEBUG\n    cin.tie(nullptr);\n#endif\n  }\n} prepare_;\n/* }}} */\n/* geometry.cpp {{{ */\n/* object {{{ */\nusing Real = long double;\nusing Point = complex<Real>;\n\nstruct Line {\n  Point p, q;\n  Line(){}\n  Line(const Point &p, const Point &q): p(p), q(q){}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(const Point &p, Real r): p(p), r(r){}\n};\n\nusing Segment = Line;\nusing Polygon = vector<Point>;\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n/* }}} */\n/* const {{{ */\nconst Real EPS = 1e-8l;\nconst Real PI = acos(-1.0l);\n/* }}} */\n/* compare {{{ */\nint sgn(Real x){\n  return (x > EPS) - (x < -EPS);\n}\n\nint sgn(Real x, Real y){\n  return sgn(x - y);\n}\n/* }}} */\n/* input {{{ */\nistream &operator>>(istream &is, Point &p){\n  Real x, y;\n  is >> x >> y;\n  p.real(x), p.imag(y);\n  return is;\n}\n\nistream &operator>>(istream &is, Line &l){\n  return is >> l.p >> l.q;\n}\n\nistream &operator>>(istream &is, Circle &c){\n  return is >> c.p >> c.r;\n}\n\nistream &operator>>(istream &is, Polygon &g){\n  each(p, g) is >> p;\n  return is;\n}\n/* }}} */\n/* output {{{ */\nostream &operator<<(ostream &os, const Point &p){\n  return os << p.real() << \" \" << p.imag();\n}\n\nostream &operator<<(ostream &os, const Line &l){\n  return os << l.p << \" \" << l.q;\n}\n\nostream &operator<<(ostream &os, const Circle &c){\n  return os << c.p << \" \" << c.r;\n}\n\nostream &operator<<(ostream &os, const Polygon &g){\n  for (int i = 0; i < (int)g.size(); i++){\n    os << g[i];\n    if (i + 1 < (int)g.size()) os << endl;\n  }\n  return os;\n}\n/* }}} */\n/* dot, cross {{{ */\nReal dot(const Point &a, const Point &b){\n  return real(conj(a) * b);\n}\n\nReal cross(const Point &a, const Point &b){\n  return imag(conj(a) * b);\n}\n/* }}} */\n/* ccw {{{ */\nint ccw(const Point &a, const Point &b, const Point &c){\n  Point u = b - a, v = c - a;\n  if (sgn(cross(u, v)) > 0) return 1;\n  if (sgn(cross(u, v)) < 0) return -1;\n  if (sgn(dot(u, v)) < 0) return 2;\n  if (sgn(norm(u), norm(v)) < 0) return -2;\n  return 0;\n}\n/* }}} */\n/* orthogonal, parallel {{{ */\nbool orthogonal(const Line &l, const Line &m){\n  return sgn(dot(l.q - l.p, m.q - m.p)) == 0;\n}\n\nbool parallel(const Line &l, const Line &m){\n  return sgn(cross(l.q - l.p, m.q - m.p)) == 0;\n}\n/* }}} */\n/* intersect {{{ */\nbool intersectLL(const Line &l, const Line &m){\n  return !parallel(l, m) ? true : parallel(l, Line(l.p, m.p));\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n  return sgn(cross(l.q - l.p, s.p - l.p)) * sgn(cross(l.p - l.p, s.q - l.p)) <= 0;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n  return ~ccw(l.p, l.q, p) & 1;\n}\n\nbool intersectSS(const Segment &s, const Segment &t){\n  return ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0\n      && ccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n  return !ccw(s.p, s.q, p);\n}\n/* }}} */\n/* project, refrect {{{ */\nPoint project(const Line &l, const Point &p){\n  Real t = dot(p - l.p, l.p - l.q) / norm(l.p - l.q);\n  return l.p + t * (l.p - l.q);\n}\n\nPoint reflect(const Line &l, const Point &p){\n  return p + 2.0l * (project(l, p) - p);\n}\n/* }}} */\n/* distance {{{ */\nReal distanceLP(const Line &l, const Point &p){\n  return abs(p - project(l, p));\n}\n\nReal distanceLL(const Line &l, const Line &m){\n  return intersectLL(l, m) ? 0.0l : distanceLP(l, m.p);\n}\n\nReal distanceLS(const Line &l, const Segment &s){\n  if (intersectLS(l, s)) return 0.0l;\n  return min(distanceLP(l, s.p), distanceLP(l, s.q));\n}\n\nReal distanceSP(const Segment &s, const Point &p){\n  if (sgn(dot(s.q - s.p, p - s.p)) <= 0) return abs(s.p - p);\n  if (sgn(dot(s.p - s.q, p - s.q)) <= 0) return abs(s.q - p);\n  return distanceLP(s, p);\n}\n\nReal distanceSS(const Segment &s, const Segment &t){\n  if (intersectSS(s, t)) return 0.0l;\n  return min({\n    distanceSP(s, t.p), distanceSP(s, t.q),\n    distanceSP(t, s.p), distanceSP(t, s.q)\n  });\n}\n/* }}} */\n/* cross point {{{ */\nPoint crossPoint(const Line &l, const Line &m){\n  Real a = cross(l.q - l.p, m.q - m.p);\n  Real b = cross(l.q - l.p, l.q - m.p);\n  if (sgn(a) == 0 && sgn(b) == 0) return m.p;\n  if (sgn(a) == 0) assert(false);\n  return m.p + b / a * (m.q - m.p);\n}\n/* }}} */\n/* }}} */\n\nsigned main()\n{\n  int q;\n  Segment s, t;\n  cin >> q;\n  rep(q){\n    cin >> s >> t;\n    cout << intersectSS(s, t) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n*/\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n#define p(var) std::cout<<var<<std::endl\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define uniq(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\n\n/*-----8<-----template-----8<-----*/\n\n//点、ベクトル\nclass Point {\npublic:\n\tdouble x,y;\n\tPoint(double x=0., double y=0.) : x(x), y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x, y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x, y-p.y);}\n\tPoint operator * (Point p) {return Point(x*p.x, y*p.y);}\n\tPoint operator / (Point p) {return Point(x/p.x, y/p.y);}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x!=p.x ? x<p.x : y<p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n\t\n};\n//using Vector = Point;\ntypedef Point Vector;\n\n//線分、直線\nclass Segment {\npublic:\n\tPoint p1,p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n//using Line = Segment;\ntypedef Segment Line;\n\n//ベクトルの内積\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\ndouble equals(double a,double b){ return fabs(a-b)<EPS; }\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n\treturn isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n\treturn equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//平行判定\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n\treturn isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//射影\nPoint project(Segment s,Point p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/base.norm();\n\tPoint rp(r,r);\n\treturn base*rp + s.p1;\n}\n//反射\nPoint reflect(Segment s,Point p){\n\tPoint x2(2.,2.);\n\treturn p + (project(s,p)-p)*x2;\n}\n\n//p0,p1,p2が反時計回りになる\nstatic const int COUNTER_CLOCKWISE = 1;\n//p0,p1,p2が時計回りになる\nstatic const int CLOCKWISE = -1;\n//p2,p0,p1がこの順で同一直線状にある\nstatic const int ONLINE_BACK = 2;\n//p0,p1,p2がこの順で同一直線状にある\nstatic const int ONLINE_FRONT = -2;\n//p2が線分p0p1上にある\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-EPS)return CLOCKWISE;\n\tif(dot(a,b)<-EPS)return ONLINE_BACK;\n\tif(a.norm()<b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\n//端点が他方の線分上にある場合、線分二つが平行に重なる場合も交差しているとみなす\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//二点間の距離\ndouble getDistance(Point a,Point b){\n\treturn (a-b).abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(l.p2-l.p1, p-l.p1)) / (l.p2-l.p1).abs();\n}\n//点と線分の距離\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1, p-s.p1)<0.)return (p-s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2)<0.)return (p-s.p2).abs();\n\treturn getDistanceLP(s,p);\n}\n//線分と線分の距離\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.;\n\treturn min({getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2), getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)});\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2-s2.p1;\n\tdouble d1=fabs(cross(base, s1.p1-s2.p1));\n\tdouble d2=fabs(cross(base, s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\n//円\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c=Point(), double r=0.) : c(c), r(r) {}\n};\n//円cと線分lの交点二つ\npair<Point,Point> getCrossPoints(Circle c, Line l){\n\t//交点が存在するか\n\tassert(getDistanceLP(l,c.c)<c.r);\n\tVector pr=project(l, c.c);\n\tVector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn {pr+e*base, pr-e*base};\n}\n\ntypedef vector<Point> Polygon;\n//多角形gと点pの内包関係を返す\nstatic const int INSIDE = 2;\nstatic const int ONLINE = 1;\nstatic const int OUTSIDE = 0;\nll contains(Polygon &g, Point p){\n\tll n=g.size();\n\tbool x=false;\n\tfor(ll i=0; i<n; i++){\n\t\tPoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return ONLINE;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x=!x;\n\t}\n\treturn (x ? INSIDE : OUTSIDE);\n}\n\n//点の集合sに対する凸包を返す\nPolygon andrewScan(Polygon s){\n\tPolygon u,l;\n\tif(s.size()<3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(ll i=2; i<(ll)s.size(); i++){\n\t\tfor(ll n=u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor(ll i=s.size()-3; i>=0; i--){\n\t\tfor(ll n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor(ll i=u.size()-2; i>=1; i--)l.push_back(u[i]);\n\n\treturn l;\n}\n\n\n//線分の集合sの交点の数を返す\nclass EndPoint {\npublic:\n\tPoint pnt;\n\tll seg,st; //入力線分のID, 端点の種類\n\tEndPoint() {}\n\tEndPoint(Point pnt, ll seg, ll st) : pnt(pnt), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(pnt.y == ep.pnt.y) return st < ep.st;\n\t\treturn pnt.y < ep.pnt.y;\n\t}\n};\nll manhattanIntersection(vector<Segment> &S){\n\tstatic const int BOTTOM = 0;\n\tstatic const int LEFT = 1;\n\tstatic const int RIGHT = 2;\n\tstatic const int TOP = 3;\n\tll n=S.size();\n\tvector<EndPoint> EP(2*n);\n\tfor(ll i=0,k=0; i<n; i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP.begin(), EP.end());\n\n\tset<ll> BT;\n\tBT.insert(INF);\n\tll cnt=0;\n\tfor(ll i=0; i<2*n; i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].pnt.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.erase(EP[i].pnt.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tauto b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tauto e=BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\n/*-----8<-----library-----8<-----*/\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\nvoid CGL_2_A(){\n\tll N;\n\tcin>>N;\n\tvector<ll> ans(N,0);\n\trep(i,N){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tll t=0;\n\t\tif(isOrthogonal(p0,p1,p2,p3)){\n\t\t\tt=1;\n\t\t}else if(isParallel(p0,p1,p2,p3)){\n\t\t\tt=2;\n\t\t}\n\t\tans[i]=t;\n\t}\n\trep(i,N)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\nvoid CGL_1_A(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=project(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\nvoid CGL_1_B(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=reflect(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\nvoid CGL_2_D(){\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tSegment s0(Point(x0,y0),Point(x1,y1)), s1(Point(x2,y2),Point(x3,y3));\n\t\tdouble t=getDistance(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\nvoid CGL_1_C(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tPoint p0(x0,y0),p1(x1,y1);\n\tll Q;\n\tcin>>Q;\n\tvector<string> ans(Q,\"\");\n\tmap<ll,string> m;\n\tm[1]=\"COUNTER_CLOCKWISE\";\n\tm[-1]=\"CLOCKWISE\";\n\tm[2]=\"ONLINE_BACK\";\n\tm[-2]=\"ONLINE_FRONT\";\n\tm[0]=\"ON_SEGMENT\";\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint pq(xq,yq);\n\t\tll t=ccw(p0,p1,pq);\n\t\tans[i]=m[t];\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\nvoid CGL_2_B(){\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tbool t=intersect(p0,p1,p2,p3);\n\t\tans[i]=t ? 1 : 0;\n\t}\n\trep(i,Q)p(ans[i]);\t\n}\n\nsigned main() {\n\t//CGL_2_A();\n\t//CGL_1_A();\n\t//CGL_1_B();\n\t//CGL_2_D();\n\t//CGL_1_C();\n\tCGL_2_B();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-7;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n    \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (c == P(0, 0) || c == b) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return 1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        r = max(min(l.s, l.t), min(m.s, m.t));\n        P q = min(max(l.s, l.t), max(m.s, m.t));\n        return (r == q) ? 1 : (q < r ? 0 : -1);\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << abs(crossSS(l1, l2, p)) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    double x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(double nx) {\n        x = nx;\n    }\n    \n    void setY(double ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    double cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (double f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (double f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(double sx, double sy, double ex, double ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        double c1 = l1.cross(l.getStart() - start);\n        double c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        double c3 = l2.cross(start - l.getStart());\n        double c4 = l2.cross(end - l.getStart());\n        \n        if (c1 * c2 <= 0.0 && c3 * c4 <= 0.0) { // 外積の正負が異なるとき\n            return 1;\n        } else { // 外積の正負が同一のとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        double sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n\nusing namespace std;\ntypedef long long LL;\n\nconst double Pi = acos(-1.0);\nconst int INf = 0x7fffffff;\nconst double eps = 1e-9;\n\nint sgn(double d) {\n    if(fabs(d) < eps)\n        return 0;\n    if(d > 0)\n        return 1;\n    return -1;\n}\n\nint dcmp(double x, double y) {\n    if(fabs(x - y) < eps)\n        return 0;\n    if(x > y)\n        return 1;\n    return -1;\n}\n\nstruct Point {\n    double x, y;\n    Point(double _x = 0, double _y = 0):x(_x), y(_y){}\n};\n\ntypedef Point Vector;\n\nVector operator + (Vector A, Vector B) {\n    return Vector(A.x + B.x, A.y + B.y);\n}\n\nVector operator - (Point A, Point B) {\n    return Vector(A.x - B.x, A.y - B.y);\n}\n\nVector operator * (Vector A, double p) {\n    return Vector(A.x * p, A.y * p);\n}\n\nVector operator / (Vector A, double p) {\n    return Vector(A.x / p, A.y / p);\n}\n\nbool operator == (const Point &a, const Point &b) {\n    if(sgn(a.x-b.x) == 0 && sgn(a.y-b.y) == 0)\n        return true;\n    return false;\n}\n\ndouble Dot(Vector A, Vector B) {\n    return A.x * B.x + A.y * B.y;\n}\n\ndouble Cross(Vector A, Vector B) {\n    return A.x * B.y - B.x * A.y;\n}\n\ndouble Length(Vector A) {\n    return sqrt(Dot(A, A));\n}\n\ndouble Angle(Vector A, Vector B) {\n    return acos(Dot(A, B) / Length(A) / Length(B));\n}\n\ndouble Area2(Point A, Point B, Point C) {\n    return Cross(B - A, C - A);\n}\n\nVector Rotate(Vector A, double rad) { // 逆时针旋转rad\n    return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) - A.y * cos(rad));\n}\n\nVector Normal(Vector A) {      //A左转90°的单位法向量\n    double L = Length(A);\n    return Vector(-A.y / L, A.x / L);\n}\n\nbool ToLeftTest(Point a, Point b, Point c) {\n    return Cross(b - a, c - a) > 0;\n}\n\nstruct Line {\n    Point v, p;\n    Line(Point v, Point p) : v(v), p(p){}\n    Point point(double t) {\n        return v + (p - v) * t;\n    }\n};\n\nPoint GetLineIntersection(Point P, Vector v, Point Q, Vector w) {\n    Vector u = P - Q;\n    double t = Cross(w, u) / Cross(v, w);\n    return P + v * t;\n}\n\ndouble DistanceToLine(Point P, Point A, Point B) {\n    Vector v1 = B - A, v2 = P - A;\n    return fabs(Cross(v1, v2) / Length(v1));\n}\n\n\ndouble DistanceToSegment(Point P, Point A, Point B) {\n    if(A == B)\n        return Length(P - A);\n    Vector v1 = B - A, v2 = P - A, v3 = P - B;\n    if(sgn(Dot(v1, v2)) < 0)\n        return Length(v2);\n    if(sgn(Dot(v1, v3)) > 0)\n        return Length(v3);\n    return DistanceToLine(P, A, B);\n}\n\nPoint GetLineProjection(Point P, Point A, Point B) {\n    Vector v = B - A;\n    return A + v * (Dot(v, P - A) / Dot(v, v));\n}\n\nbool OnSegment(Point p, Point a1, Point a2){\n    return sgn(Cross(a1-p, a2-p)) == 0 && sgn(Dot(a1-p, a2-p)) < 0;\n}\n\nint PointAtSegment(Point p, Point a, Point b) {\n    Vector v1 = p - a, v2 = b - a;\n    if(sgn(Cross(v1, v2)) == -1)\n        return -1;\n    else if(sgn(Cross(v1, v2)) == 1)\n        return 1;\n    else if(sgn(Dot(v1, v2)) == -1)\n        return -1;\n    else if(sgn(Length(v1) - Length(v2)) == 1)\n        return 1;\n    return 0;\n}\n\nbool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2){\n    return PointAtSegment(b1, a1, a2) * PointAtSegment(b2, a1, a2) <= 0 && PointAtSegment(a1, b1, b2) * PointAtSegment(a2, b1, b2) <= 0;\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    Vector v1, v2;\n    int q;\n    scanf(\"%d\", &q);\n    while(q--) {\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p0.x, &p0.y, &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y);\n        if(SegmentProperIntersection(p0,p1,p2,p3))\n            printf(\"1\\n\");\n        else\n            printf(\"0\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint main(){\n  int Q;\n  Segment s1,s2;\n  cin >> Q;\n  while(Q--){\n    cin >> s1.s >> s1.t >> s2.s >> s2.t;\n    cout << isIntersectSS(s1,s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c (cw)\n *          a -> bで反時計方向に折れてb -> c (ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c (front)\n *          a -> bで逆を向いてb -> cまたは、b == c (on)\n */\nenum struct orientation {\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t abs2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t abs(const vector_t& v)\n{\n    return std::sqrt(abs2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / abs2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orientation ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orientation::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orientation::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orientation::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(abs2(p1), abs2(p2)))       { return orientation::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orientation::on;\n}\n\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\ncoord_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{  \n    return std::min(pi.x, pj.x) <= pk.x && pk.x <= std::max(pi.x, pj.x)\n        && std::min(pi.y, pj.y) <= pk.y && pk.y <= std::max(pi.y, pj.y);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    coord_t d1 = direction(p3, p4, p1);\n    coord_t d2 = direction(p3, p4, p2);\n    coord_t d3 = direction(p1, p2, p3);\n    coord_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n/**\n * @brief  線分交差検出を行う\n * \n * @note   n本の線分の集合をSとし、Sの中で交差している線分の数を返す\n */\nstd::size_t any_segments_intersect(segments_t& S)\n{\n    // struct cmp { bool operator () (const segment& s1, const segment& s2) {\n    //     return (s1.ps.x - s2.ps.x) * (s2.pd.y - s2.ps.y)\n    //         <  (s1.ps.y - s2.ps.y) * (s2.pd.x - s2.ps.x);\n    // } };\n    \n    std::set<index_t> T;  // 全擬順序Tを空に初期化する\n    \n    index_t n = S.size();\n    event_points Q;      // イベントキューQを空に初期化する\n    \n    for (index_t i = 0; i < n; i++) {\n        // 端点ps, pdが左下を基準に並ぶように調整する\n        if (eq(S[i].ps.y, S[i].pd.y)) {\n            if (S[i].ps.x > S[i].pd.x)  { std::swap(S[i].ps, S[i].pd); }\n        }\n        else if (S[i].ps.y > S[i].pd.y) { std::swap(S[i].ps, S[i].pd); }\n\n        Q.emplace_back(S[i].ps, i, event_type::left);\n        Q.emplace_back(S[i].pd, i, event_type::right);\n    }\n\n    // Sの線分の端点を左から右にソートする\n    std::sort(Q.begin(), Q.end());\n\n    std::size_t count = 0;\n    for (index_t i = 0; i < 2 * n; i++) {   // イベント点の個数は2nだからループの繰り返しは2n\n\n        if (Q[i].e == event_type::left)  {  // pが線分sの左端点\n\n            for (index_t s : T) {\n                if (segment_intersect(S[Q[i].seg].ps, S[Q[i].seg].pd,\n                                      S[s].ps, S[s].pd)) {\n                    count = count + 1;\n                }\n            }         \n            T.insert(Q[i].seg);\n        }\n        if (Q[i].e == event_type::right) {  // pが線分sの右端点\n            T.erase(Q[i].seg);\n        }\n    }\n\n    return count;\n}\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x=0, double y=0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/ a, y/ a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x, y*y; }\n    bool operator < (const Point &p) const {\n\treturn x != p.x ? x<p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p0, p1;\n};\n\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble norm(Vector a) {\n    return a.x*a.x + a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\n/*\n  ???????????§??????????????¨??????????????°??????\n  |a*b|=|a||b|sin(theta)\n */\ndouble cross(Vector a, Vector b){ \n    return a.x*b.y - a.y*b.x;\n}\n\n/*const?????????????????????????????????*/\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    if (cross(p1-p0, p2-p0) > EPS) return COUNTER_CLOCKWISE;\n    else if (cross(p1-p0, p2-p0) < -EPS) return CLOCKWISE;\n    else return ON_SEGMENT;\n}\n\n/*\n  intersect\n  ?????¨?????????????????¢???????????£????????????????????????\n  ????????????????¨?????????????????¨???????????????????????????°OK\n*/\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0,p1, p2) * ccw(p0,p1,p3) <= 0 && ccw(p2, p3, p0) * ccw(p2,p3,p1) <=0);\n}\n\nint main() {\n    int n,i,d;\n    \n    Point p0, p1, p2,p3;\n    cin >> n;\n    for(i=0;i<n;i++){\n\tcin >>  p0.x>> p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n\tif (intersect(p0,p1,p2,p3)) cout << \"1\" << endl;\n\telse cout << \"0\" << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\n// Segments/Lines - Intersection\n// status: [not solve]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <sstream>\n#include <cmath>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst double eps = 1e-8;\n\nbool almost_equals(double a, double b) { return std::abs(a - b) < eps; }\n\nclass point2d {\npublic:\n    // constructors\n    point2d() : point2d(0.0, 0.0) {}\n    point2d(double x, double y) : x_(x), y_(y) {}\n\n    // member functions\n    // operator functions\n    point2d operator+(const point2d& rhs) const { return {x_ + rhs.x_, y_ + rhs.y_}; }\n    point2d operator-(const point2d& rhs) const { return {x_ - rhs.x_, y_ - rhs.y_}; }\n    point2d operator*(double rhs) const { return {x_ * rhs, y_ * rhs}; }\n    point2d operator/(double rhs) const { return {x_ / rhs, y_ / rhs}; }\n    bool operator==(const point2d& rhs) const { return almost_equals(x_, rhs.x_) && almost_equals(y_, rhs.y_); }\n\n    // utility functions\n    double l2_norm() const { std::sqrt(squared_l2_norm()); }\n    double squared_l2_norm() const { return x_ * x_ + y_ * y_; }\n    // getter\n    double x() const noexcept { return x_; }\n    double y() const noexcept { return y_; }\n\n    // non-member functions\n    friend double dot(const point2d& lhs, const point2d& rhs);\n    friend double cross(const point2d& lhs, const point2d& rhs);\n\nprivate:\n    double x_;\n    double y_;\n};\n\ndouble dot(const point2d& lhs, const point2d& rhs) { return lhs.x_ * rhs.x_ + lhs.y_ * rhs.y_; }\ndouble cross(const point2d& lhs, const point2d& rhs) { return lhs.x_ * rhs.y_ - lhs.y_ * rhs.x_; }\nbool is_orthogonal(const point2d& lhs, const point2d& rhs) { return almost_equals(dot(lhs, rhs), 0.0); }\nbool is_parallel(const point2d& lhs, const point2d& rhs) { return almost_equals(cross(lhs, rhs), 0.0); }\ndouble compute_distance(const point2d& p1, const point2d& p2) { return (p2 - p1).l2_norm(); }\n\nclass segment {\npublic:\n    segment() : segment(point2d(), point2d()) {}\n    segment(const point2d& p1, const point2d& p2) : p1_(p1), p2_(p2) {}\n    const point2d& p1() const noexcept { return p1_; }\n    const point2d& p2() const noexcept { return p2_; }\nprivate:\n    point2d p1_, p2_;\n};\n\nclass line {\npublic:\n    line() : line(point2d(), point2d()) {}\n    line(const point2d& p1, const point2d& p2) : p1_(p1), p2_(p2) {}\n    const point2d& p1() const noexcept { return p1_; }\n    const point2d& p2() const noexcept { return p2_; }\nprivate:\n    point2d p1_, p2_;\n};\n\ndouble compute_distance(const line& l, const point2d& p) {\n    auto a = l.p2() - l.p1();\n    auto b = p - l.p1();\n    return abs(cross(a, b)) / a.l2_norm();\n}\n\ndouble compute_distance(const segment& s, const point2d& p) {\n    auto a = s.p2() - s.p1();\n    if (dot(a, p - s.p1()) < 0.0) return (p - s.p1()).l2_norm();\n    if (dot(a, p - s.p2()) < 0.0) return (p - s.p2()).l2_norm();\n    return compute_distance(line(s.p1(), s.p2()), p);\n}\n\npoint2d project(const segment& s, const point2d& p) {\n    auto base = s.p2() - s.p1();\n    auto r = dot(p - s.p1(), base) / base.squared_l2_norm();\n    return s.p1() + base * r;\n}\n\npoint2d reflect(const segment& s, const point2d& p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\nenum class clockwise_type {\n    online_front = -2,\n    clockwise = -1,\n    counter_clockwise = 1,\n    online_back = 2,\n    on_segment = 0\n};\n\nclockwise_type judge_clockwise_type(const point2d& p0, const point2d& p1, const point2d& p2) {\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n\n    if (cross(a, b) > eps) return clockwise_type::counter_clockwise;\n    if (cross(a, b) < -eps) return clockwise_type::clockwise;\n    if (dot(a, b) < -eps) return clockwise_type::online_back;\n    if (a.squared_l2_norm() < b.squared_l2_norm()) return clockwise_type::online_front;\n\n    return clockwise_type::on_segment;\n}\n\nbool intersect(const point2d& p1, const point2d& p2, const point2d& p3, const point2d& p4) {\n    return static_cast<int>(judge_clockwise_type(p1, p2, p3)) * static_cast<int>(judge_clockwise_type(p1, p2, p4)) <= 0 &&\n            static_cast<int>(judge_clockwise_type(p3, p4, p1)) * static_cast<int>(judge_clockwise_type(p3, p4, p2)) <= 0;\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(3\n0 0 3 0 1 1 2 -1\n0 0 3 0 3 1 3 -1\n0 0 3 0 3 -2 5 0\n)\";\n    stringstream stream(program_input_str);\n#endif\n    int q;\n    stream >> q;\n    for (int i = 0; i < q; ++i) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        stream >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        point2d p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n        if (intersect(p0, p1, p2, p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x=0, double y=0):x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a * x, a * y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y;}\n\tbool operator < (const Point &p) const {\n\t\t// first x, second y\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment{\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2){\n\t\tthis->p1 = p1;\n\t\tthis->p2 = p2;\n\t}\n};\n\n// ??????\ndouble dot(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// ??????\ndouble cross(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1- b2);\n}\n\n// ????????????\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1- b2);\n}\n\n// ???p????????????s???????????????????????????\nPoint project(Segment s, Point p){\n\t// ??\\??????????????????\n\t// hypo -> p - p1, base -> p2 - p1\n\t// t = |hypo|cos??\n\t// cos?? = dot(hypo,base)/|hypo||base|\n\t// project = s.p1 + base/|base| * t\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(hypo, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n// ???p????????????s???????§°?????¨?????????\nPoint reflection(Segment s, Point p){\n\tPoint pr = project(s, p);\n\treturn p + (pr - p) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// p0??????p1????????????????????????????????????p2?????????\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a,b) <-EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????????????????? ??????p1->p2, p3->p4\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n// ?????????????????????\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???????????????\nPoint crosspoint(Segment s1, Segment s2){\n\t// s1.p1??????s2???????????????????????????d1\n\t// s1.p2??????s2???????????????????????????d2??¨????????¨???\n\t// ?????????s1???d1/(d1+d2)?????????????????¨??????\n\tVector base = s2.p2 - s2.p1;\n\tVector hypo1 = s1.p1 - s2.p1;\n\tVector hypo2 = s1.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, hypo1)) / base.abs();\n\tdouble d2 = abs(cross(base, hypo2)) / base.abs();\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n// ???????????¢\ndouble distance(Point a, Point b){\n\treturn (a - b).abs();\n}\n\n// ?????¨??´???????????¢\ndouble distanceLinePoint(Segment s, Point p){\n\t// sin?? = |cross(hypo, base)|/|hypo||base|\n\t// distance = |hypo|sin?? = |cross(hypo, base)|/|base|\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\treturn abs(cross(hypo, base)) / base.abs();\n}\n\n// ?????¨??????????????¢\ndouble distanceSegmentPoint(Segment s, Point p){\n\t// (p2-p1)??¨???p-p1??????90???????????§????????´??????p??¨p1????????¢\n\t// (p1-p2)??¨???p-p2??????90???????????§????????´??????p??¨p2????????¢\n\t// ????????\\????????´???????????¨??´???????????¢\n\tif(dot(s.p2-s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n\treturn distanceLinePoint(s, p);\n}\n\n// ????????¨??????????????¢\ndouble distanceSegmentSegment(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\tdouble ret = distanceSegmentPoint(s1, s2.p1);\n\tret = min(ret, distanceSegmentPoint(s1, s2.p2));\n\tret = min(ret, distanceSegmentPoint(s2, s1.p1));\n\tret = min(ret, distanceSegmentPoint(s2, s1.p2));\n\treturn ret;\n}\n\n\nclass Answer{\npublic:\n\tstatic void CGL_1_A() {\n\t\tint Q;\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint pp;\n\t\t\tcin >> pp.x >> pp.y;\n\t\t\tPoint pr = project(Segment(p1, p2), pp);\n\t\t\tfprintf(stdout, \"%.10f %.10f\\n\", pr.x, pr.y);\n\t\t}\n\t}\n\tstatic void CGL_1_B() {\n\t\tint Q;\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint pp;\n\t\t\tcin >> pp.x >> pp.y;\n\t\t\tPoint rf = reflection(Segment(p1, p2), pp);\n\t\t\tfprintf(stdout, \"%.10f %.10f\\n\", rf.x, rf.y);\n\t\t}\n\t}\n\tstatic void CGL_1_C() {\n\t\tint Q;\n\t\tPoint p0, p1;\n\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint p2;\n\t\t\tcin >> p2.x >> p2.y;\n\t\t\tint c = ccw(p0, p1, p2);\n\t\t\tif(c == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\tif(c == CLOCKWISE) cout << \"CLOCKWISE\" << endl;\n\t\t\tif(c == ONLINE_BACK) cout << \"ONLINE_BACK\" << endl;\n\t\t\tif(c == ONLINE_FRONT) cout << \"ONLINE_FRONT\" << endl;\n\t\t\tif(c == ON_SEGMENT) cout << \"ON_SEGMENT\" << endl;\n\t\t}\n\t}\n\tstatic void CGL_2_A() {\n\t\tint Q;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint p0, p1, p2, p3;\n\t\t\tcin >> p0.x >> p0.y;\n\t\t\tcin >> p1.x >> p1.y;\n\t\t\tcin >> p2.x >> p2.y;\n\t\t\tcin >> p3.x >> p3.y;\n\t\t\tint r;\n\t\t\tif(isOrthogonal(p0,p1,p2,p3)) {r = 1;}\n\t\t\telse if(isParallel(p0,p1,p2,p3)){r = 2;}\n\t\t\telse{r = 0;}\n\t\t\tcout << r << endl;\n\t\t}\n\t}\n\tstatic void CGL_2_B() {\n\t\tint Q;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint p0, p1;\n\t\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y;\n\t\t\tPoint p2, p3;\n\t\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y;\n\t\t\tcout << (intersect(p0, p1, p2, p3) ? 1 : 0) << endl;\n\t\t}\n\t}\n\tstatic void CGL_2_C() {\n\t\tint Q;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint p0, p1;\n\t\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y;\n\t\t\tPoint p2, p3;\n\t\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y;\n\t\t\tPoint c = crosspoint(Segment(p0, p1), Segment(p2, p3));\n\t\t\tfprintf(stdout, \"%.10f %.10f\\n\", c.x, c.y);\n\t\t}\n\t}\n\n\tstatic void CGL_2_D(){\n\t\tint Q;\n\t\tcin >> Q;\n\t\trep(i, Q){\n\t\t\tPoint p0, p1;\n\t\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y;\n\t\t\tPoint p2, p3;\n\t\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y;\n\t\t\tdouble ret = distanceSegmentSegment(Segment(p0, p1), Segment(p2, p3));\n\t\t\tfprintf(stdout, \"%.10f\\n\", ret) ;\n\t\t}\n\t}\n};\n\nint main() {\n\tAnswer::CGL_2_B();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(){\n    int q;\n    long x[4], y[4];\n    \n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; ++i) {\n        for (int j = 0; j < 4; ++j){\n            scanf(\"%ld %ld\", &x[j], &y[j]);\n        }\n        \n        long croProd = (x[1] - x[0]) * (y[3] - y[2]) - (y[1] - y[0]) * (x[3] - x[2]);\n        long croProd2 = (x[2] - x[0]) * (y[3] - y[2]) - (y[2] - y[0]) * (x[3] - x[2]);\n        if (croProd > 0) {\n            if (0 <= croProd2 && croProd2 <= croProd) puts(\"1\");\n            else puts(\"0\");\n        } else if (croProd < 0) {\n            if (0 >= croProd2 && croProd2 >= croProd) puts(\"1\");\n            else puts(\"0\");\n        } else {\n            if (croProd2 != 0) puts(\"0\");\n            else {\n                double v1x = x[1] - x[0];\n                double v1y = y[1] - y[0];\n                double v2x = x[2] - x[0];\n                double v2y = y[2] - y[0];\n                double v3x = x[3] - x[0];\n                double v3y = y[3] - y[0];\n                double dotPro1 = v1x * v1x + v1y * v1y;\n                double dotPro2 = v1x * v2x + v1y * v2y;\n                double dotPro3 = v1x * v3x + v1y * v3y;\n                if (dotPro2 < 0 && dotPro3 < 0) puts(\"0\");\n                else if (dotPro2 > dotPro1 && dotPro3 > dotPro1) puts(\"0\");\n                else puts(\"1\");\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n    ll x,y;\n    Point(){ x = y = 0.0; }\n    Point(ll _x, ll _y) : x(_x), y(_y){}\n\n    Point operator+ (Point p)\n    {\n        return Point(p.x + x, p.y + y);\n    }\n\n    Point operator- (Point p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    ll operator* (Point p)\n    {\n        return p.x * x + p.y * y;\n    }\n\n    Point operator* (ll t)\n    {\n        return Point(x*t, y*t);\n    }\n\n    ll operator~ ()\n    {\n        return x * x + y * y;\n    }\n\n    ll operator% (Point p)\n    {\n        return x * p.y - y * p.x;\n    }\n\n};\n\nbool intersect(Point a, Point b, Point p, Point q)\n{\n    Point v1=(b-a);\n    Point v2=(q-p);\n    if( v1 % v2 == 0 ) return false;\n    double t = (double)(( p - a ) % v2) / (double)(v1 % v2);\n    if( t >= 0.0 && t <= 1.0) return true;\n    else return false;\n}\n\nint main()\n{\n    Point p0,p1,p2,p3;\n    Point vec, vec1;\n    int q;\n    cin >> q;\n    while(q--)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << intersect(p0,p1,p2,p3) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\nconst double EPS=1e-9;\nconst double PI=3.141592653589793238;//18 ragham\n\nbool Equal(double d1,double d2)\n{ return fabs(d1-d2)<EPS;}\n\nstruct line{double a,b,c;};\nstruct vec\n{\n  double x,y;\n  vec(double _x=0,double _y=0)\n  {x=_x;  y=_y;}\n};\n  \nstruct point_i\n{\n  int x,y;\n  point_i(int _x=0,int _y=0){x=_x;y=_y;}\n};\nstruct point\n{\n  double x,y;\n  point(double _x=0,double _y=0){x=_x;y=_y;}\n  bool operator < (point other)\n  {  \n    if(fabs(x-other.x)<EPS)\n      return y<other.y;\n    return x<other.x;}\n  bool operator == (point other)\n  {return (fabs(x-other.x)<EPS) && (fabs(y-other.y)<EPS) ;}\n  \n  \n};\ndouble Hypot(double dx,double dy)\n{\n  return sqrt(dx*dx+dy*dy);\n}\ndouble Distance(point p1,point p2)\n{\n  return hypot(p1.x-p2.x,p1.y-p2.y);\n}\ndouble DEG_to_RAD(double theta)\n{\n  return theta*PI/180;\n}\ndouble RAD_to_DEG(double rad)\n{\n  return rad*180/PI;\n}\npoint rotate(point p, double theta)//theta is degree\n{\n  \n  //rotation matrixR(theta) = [cos(theta) - sin(theta)]\n  //                          [sin(theta) + cos(theta)]\n  //usage: [x'] = R(theta)* [x]\n  //       [y']             [y]\n  double rad=DEG_to_RAD(theta);\n  return point(p.x * cos(rad) - p.x * sin(rad) ,\n\t       p.y * sin(rad) + p.y * cos(rad)  );\n}\nvoid PointsToLine(point p1,point p2,line *l)\n{\n  if(p1.x==p2.x) // vertical line handled here\n    { l->a=1.0;   l->b= 0.0 ; l->c=-p1.x;}\n  else\n    {\n      l->a=-(double)(p1.y-p2.y)/(p1.x-p2.x);\n      l->b=1.0;\n      l->c=-(double)(l->a * p1.x) - (l->b*p1.y);\n    }\n}\nbool AreParallel(line l1,line l2)\n{\n  return Equal(l1.a,l2.a) && Equal(l1.b,l2.b);\n}\nbool AreSame(line l1,line l2)\n{\n  return AreParallel(l1,l2) && Equal(l1.c,l2.c);\n}\nbool AreIntersect(line l1,line l2,point *p)//TO BE CHECKED (mine)\n{\n  if(AreSame(l1,l2))\n    return false;\n  if(AreParallel(l1,l2))\n    return false;\n\n  //solving\n  double delta=(double)l1.a*l2.b - l1.b*l2.a;\n  if(Equal(delta,0))//this if should never be true because lines are't parallel\n    return false;\n  //a1x+b1y=-c1\n  //a2x+b2y=-c2\n  p->x= (double)(-l1.c*l2.b+l2.c*l1.b) / delta;\n  p->y= (double)(-l1.a*l2.c+l2.a*l1.c) / delta;\n  return true;\n}\nvec ToVector(point p1,point p2)\n{\n  return vec(p2.x-p1.x,p2.y-p1.y);\n}\nvec ScaleVector(vec v, double s) // v*=s\n{\n  return vec(v.x*s,v.y*s);\n}\npoint Translate(point p,vec move)//moves point p in direction of vector move\n{\n  return point(p.x+move.x , p.y + move.y);\n}\ndouble Dot(double x1,double y1 ,double x2,double y2)\n{ return x1*x2+y1*y2;};\ndouble Determinant(double x1,double y1,double x2,double y2)\n{return x1*y2-x2*y1;};\n//angle A<BC (radian (PI) )\ndouble Angle(point A,point B,point C)\n{\n  double dot=Dot(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  double det=Determinant(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  //atan2(y,x), or atan2(sin,cos)\n  return atan2(det,dot);\n}\ndouble Cross(point p,point q,point r)\n{\n  return (r.x-q.x)*(p.y-q.y)-(r.y-q.y)*(p.x-q.x);\n}\nbool Collinear(point p,point q,point r)\n{\n  return Equal(Cross(p,q,r),0);\n}\n//returns true if point r is on the left side of line pq\nbool CCW(point p,point q,point r)\n{\n   //can be modified to accept collinear ( >0 instead of >EPS )\n  if(Cross(p,q,r) > EPS)\n    return true;\n  return false;\n}\n\n//returns the distance from p to line AB\n// A and B must be different\n//closest point is in *c\ndouble DistToLine(point p,point A,point B,point *c)\n{// formula : c= A+ (p-A).(A-B)/|B-A|*(B-A)\n  double scale= (double)\n    ((p.x-A.x)*(B.x-A.x)+(p.y-A.y)*(B.y-A.y))/\n    ((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));\n  c->x= A.x + scale*(B.x - A.x);\n  c->y= A.y + scale*(B.y - A.y);\n  \n  return Distance(p,*c);\n}\ndouble DistToLineSegment(point p,point A,point B,point *c)\n{\n  if((B.x-A.x) * (p.x-A.x)+ (B.y-A.y)*(p.y-A.y) <EPS)\n    { c->x=A.x ; c->y= A.y;\n      return Distance(p,A);}//closer to A\n \n  if((A.x-B.x) * (p.x-B.x)+ (A.y-B.y)*(p.y-B.y) <EPS)\n    { c->x=B.x ; c->y= B.y;\n      return Distance(p,B);}//closer to B\n\n  return DistToLine(p,A,B,c);\n  \n}\n//returns true if p is on segment AB\nbool IsOnLineSegment(point p,point A,point B)\n{\n   if(Collinear(p,A,B)==false)\n    return false;\n  if(p==A || p==B)\n    return true;\n  double angle=Angle(A,p,B);\n  //cout<<\"angle:\"<<RAD_to_DEG(angle)<<endl;\n  if(Equal( angle, PI ) || Equal(angle,-PI) ||  Equal(RAD_to_DEG(angle),180) )\n    return true;\n  return false;\n}\nbool AreSegmentsIntersect(point A,point B,point C,point D,point *p)\n{\n  line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2))\n    {\n      //cout<<\"A\"<<endl;\n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))cnt++;\n      if(IsOnLineSegment(B,C,D))cnt++;\n      if(IsOnLineSegment(C,A,B))cnt++;\n      if(IsOnLineSegment(D,A,B))cnt++;\n      if(cnt!=2)\n\treturn false;\n      if(A==C || A==D){\n\tp->x=A.x;\n\tp->y=A.y;\n\treturn true;}\n      if(B==C || B==D){\n\tp->x=B.x;\n\tp->y=B.y;\n\treturn true;}\n      return false;\n    }\n \n  if(AreIntersect(l1,l2,p))\n    {\n      //cout<<\"B\"<<endl;\n      //\t  cout<<p->x<<\" \"<<p->y<<endl;\n      if(IsOnLineSegment(*p,A,B) && IsOnLineSegment(*p,C,D))\n\treturn true;\n      return false;\n    }\n  //cout<<\"C\"<<endl;\n  return false;\n}\nbool SegmentRangeIntersection(point A,point B,point C,point D)\n{\n    line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2)==false)\n    return false;\n  //cout<<\"AA\"<<endl;\n  \n  \n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))cnt++;\n      if(IsOnLineSegment(B,C,D))cnt++;\n      if(IsOnLineSegment(C,A,B))cnt++;\n      if(IsOnLineSegment(D,A,B))cnt++;\n      if(cnt)\n\treturn true;//special case : one point\n      //cout<<\"BB\"<<endl;\n  return false;\n}\n///*****************### End of Library ###*******************///\n\n\n\n\n\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    {\n      int x,y;\n      point A,B,C,D,p;\n      cin>>x>>y;\n      A=point(x,y);\n      \n      cin>>x>>y;\n      B=point(x,y);\n      \n      cin>>x>>y;\n      C=point(x,y);\n      \n      cin>>x>>y;\n      D=point(x,y);\n      if(AreSegmentsIntersect(A,B,C,D,&p) || SegmentRangeIntersection(A,B,C,D))\n\tcout<<1<<endl;\n      else\n\tcout<<0<<endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\n#include <complex>\ntypedef complex<double> P;\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\nint ccw(P a, P b,P c) {\n\tP e = b - a;\n\tP f = c - a;\n\tif (cross(e, f) > eps) {\n\t\treturn 1;\n\t}\n\tif (cross(e, f) < -eps) {\n\t\treturn -1;\n\t}\n\tif (dot(e, f) < -eps) return 2;\n\tif (abs(e) < abs(f)) return -2;\n\treturn 0;\n}\nbool intersect(P a, P b, P c, P d) {\n\tif (ccw(a, b, c) * ccw(a, b, d) <= 0) {\n\t\tif (ccw(c, d, a) * ccw(c, d, b) <= 0){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\tint query;\n\tcin >> query;\n\tREP(i, query) {\n\t\tdouble a,b,c,d,e, f,g,h;\n\t\tcin >> a >> b >> c >> d >> e >> f >> g >> h;\n\t\tcout << intersect(P(a, b), P(c, d), P(e, f), P(g, h)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n    \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint isOnSegment(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n    (dot(b-a, c-a) > -EPS) &&\n    (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return isOnSegment(a1,a2,b1) || isOnSegment(a1,a2,b2)\n      || isOnSegment(b1,b2,a1) || isOnSegment(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\n\nint main(void){\n\n  int q;\n  cin >> q;\n  while(q--){\n    point a,b,c,d;\n    cin >> a.x >> a.y >> b.x >> b.y;\n    cin >> c.x >> c.y >> d.x >> d.y;\n    if(is_intersected_ls(a,b,c,d))cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define _GLIBCXX_DEBUG\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...on_seg(p1,p2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n\tint q;\n\tcin>>q;\n\tfor(int cnt=0;cnt<q;cnt++)\n\t{\n\t\tpoint a[2];\n\t\tpoint b[2];\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tdouble c,d;\n\t\t\tcin>>c>>d;\n\t\t\tpoint a[i]=point(a,b);\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tdouble c,d;\n\t\t\tcin>>c>>d;\n\t\t\tpoint b[i]=point(a,b);\n\t\t}\n\t\tif(on_seg(a[0],a[1],intersection(a[0],a[1],b[0],b[1])))\n\t\t\tcout<<1<<endl;\n\t\telse\n\t\t\tcout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define PII pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double X = 0, double Y = 0)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\tPoint operator +(const Point &p)const { return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p)const { return Point(x - p.x, y - p.y); };\n\tPoint operator *(const double a)const { return Point(x*a, y*a); };\n\tPoint operator /(const double a)const { return Point(x / a, y / a); };\n\tdouble norm()const { return x*x + y*y; };\n\tdouble length()const { return sqrt(norm()); };\n\tdouble dot(const Point &p)const { return x*p.x + y*p.y; };\n\tdouble cross(const Point &p)const { return x*p.y - y*p.x; };\n\tbool operator ==(const Point &p)const\n\t{\n\t\treturn fabs(x - p.x)<EPS &&fabs(y - p.y)<EPS;\n\t}\n\tfriend ostream& operator <<(ostream& os, const Point &p);\n\tint CCW(Point p1, Point p2)\n\t{\n\t\tPoint p0(x, y);\n\t\tPoint V1 = p1 - p0;\n\t\tPoint V2 = p2 - p0;\n\t\tif (V1.cross(V2) > 0.0)return 1;\n\t\telse if (V1.cross(V2) < 0.0)return -1;\n\t\telse if (V1.dot(V2) < 0.0)return -2;\n\t\telse if (V1.norm() < V2.norm())return 2;\n\t\treturn 0;\n\t}\n};\ntypedef Point Vector;\n\nostream& operator <<(ostream& os, const Point &p)\n{\n\treturn os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\nclass Segment\n{\npublic:\n\tPoint p1, p2;\n\tSegment(double x1, double y1, double x2, double y2)\n\t{\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tdouble GetLength()\n\t{\n\t\tPoint temp = p2 - p1;\n\t\treturn temp.length();\n\t}\n\tdouble GetDistanceSeg(double X, double Y)\n\t{\n\t\tPoint p(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = p - p1;\n\t\tPoint c = p1 - p2;\n\t\tPoint d = p - p2;\n\t\tif (a.dot(b) < 0.0)return b.length();\n\t\tif (c.dot(d) < 0.0)return d.length();\n\t\treturn GetDistanceLine(X, Y);\n\t}\n\n\tdouble GetDistanceLine(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = t - p1;\n\t\treturn abs(a.cross(b) / a.length());\n\t}\n\tbool IsIntersect(Segment &s)\n\t{\n\t\tint s1, s2;\n\t\ts1 = p1.CCW(p2, s.p1)*p1.CCW(p2, s.p2);\n\t\ts2 = s.p1.CCW(s.p2, p1)*s.p1.CCW(s.p2, p2);\n\t\treturn s1 <= 0 && s2 <= 0;\n\t}\n\tbool IsOrthogonal(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.dot(t2));\n\t}\n\tbool IsParallel(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.cross(t2));\n\t}\n\tPoint GetProjection(double X, double Y)const\n\t{\n\t\tVector V = p2 - p1;\n\t\tPoint P(X, Y);\n\t\tPoint ret = V*(V.dot(P - p1) / V.norm());\n\t\treturn ret + p1;\n\t}\n\tPoint GetReflect(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint Pro = GetProjection(X, Y);\n\t\tVector dV = Pro - t;\n\t\treturn t + dV*2.0;\n\t}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point C = Point(), double R = 0)\n\t{\n\t\tc = C;\n\t\tr = R;\n\t}\n};\nint main()\n{\n\tint q;\n\tcin >> q;\n\tREP(i, q)\n\t{\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tSegment s1(x0, y0, x1, y1), s2(x2, y2, x3, y3);\n\t\tcout << s1.IsIntersect(s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point p1 = z2 * conj(z1);\n        Point p2 = z3 * conj(z1);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n\n        if (p1.imag() * p2.imag() > 0 \n            || (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() > 0 \n            || p1.imag() == 0 && p2.imag() == 0\n               && p1.real() * p2.real() > 0\n               && p1.real() * (p1.real() - abs(z1) * abs(z1)) > 0\n               && p2.real() * (p2.real() - abs(z1) * abs(z1)) > 0)\n            cout << \"0\\n\";\n        else cout << \"1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n\nint main(){\n    \n    int x0, x1, x2, x3, y0, y1, y2, y3;\n    int n, t0, t1, t2, t3;\n    \n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        t0 = (y0-y2)*(x3-x2) - (y3-y2)*(x0-x2);\n        t1 = (y1-y2)*(x3-x2) - (y3-y2)*(x1-x2);\n        t2 = (y2-y0)*(x1-x0) - (y1-y0)*(x2-x0);\n        t3 = (y3-y0)*(x1-x0) - (y1-y0)*(x3-x0);\n            \n        if (t0*t1 < 0 && t2*t3 < 0){\n            cout << 1 << endl;\n        }\n        else if\n        (\n            t0 == 0\n            &&\n            ((x2 <= x0 && x0 <= x3) ||(x3 <= x0 && x0 <= x2))\n        )\n        {\n            cout << 1 << endl;\n        }\n        else if\n            (\n             t1 == 0\n             &&\n             ((x2 <= x1 && x1 <= x3) ||(x3 <= x1 && x1 <= x2))\n             )\n        {\n            cout << 1 << endl;\n        }\n        else if\n            (\n             t2 == 0\n             &&\n             ((x0 <= x2 && x2 <= x1) ||(x1 <= x2 && x2 <= x0))\n             )\n        {\n            cout << 1 << endl;\n        }\n        else if\n            (\n             t3 == 0\n             &&\n             ((x0 <= x3 && x3 <= x1) ||(x1 <= x3 && x3 <= x0))\n             )\n        {\n            cout << 1 << endl;\n        }\n        else{\n            cout << 0 << endl;\n        }\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = int64_t;\nconst int64_t MOD = 1e9+7;\nusing Real = double;\nReal EPS = 1e-8;\nusing Point = complex<Real>;\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\nReal radian_to_degree(Real r) {\n    return r * 180.0 / M_PI;\n}\nReal degree_to_radian(Real d) {\n    return d * M_PI / 180.0;\n}\nPoint rotate(const Point &p, Real theta) {\n    return p * polar(1., theta);\n}\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nconst int COUNTER_CLOCKWISE = 1,\n          CLOCKWISE = -1,\n          ONLINE_BACK = 2,\n          ONLINE_FRONT = -2,\n          ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\nint main()\n{\n    int q; cin >> q;\n    while (q--) {\n        double x1, y1, x2, y2, x3, y3, x4, y4;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n        Segment l1{Point{x1, y1}, Point{x2, y2}},\n                l2{Point{x3, y3}, Point{x4, y4}};\n        if (intersected(l1, l2)) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\npair< Point, Point > closer(const pair< Point, Point > &a, const pair< Point, Point > &b) {\n  return distance(a.first, a.second) < distance(b.first, b.second) ? a : b;\n}\n\npair< Point, Point > closest_pair_util(Points &ps, int l, int r) {\n  if(r - l == 2) {\n    return {ps[l], ps[l + 1]};\n  }\n  if(r - l == 3) {\n    pair< Point, Point > a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return closer(a, closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  auto res = closer(closest_pair_util(ps, l, mid), closest_pair_util(ps, mid, r));\n  double d = distance(res.first, res.second);\n\n  Points pos[2];\n  for(int i = l; i < r; ++i) {\n    if(abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for(const auto &i : pos[0]) {\n    for(const auto &j : pos[1]) {\n      if(distance(i, j) < d) {\n        d = distance(i, j);\n        res = {i, j};\n      }\n    }\n  }\n  return res;\n}\n\npair< Point, Point > closest_pair(Points ps) {\n  if(ps.size() <= 1) exit(-1);\n  for(int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n  if(ps.size() == 2) return {ps[0], ps[1]};\n  auto res = closest_pair_util(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\nint main() {\n  int Q;\n  cin >> Q;\n  while(Q--) {\n    Segment s1, s2;\n    cin >> s1 >> s2;\n    cout << (int) (intersect(s1, s2)) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>0) return 1;\n\t\tif(Getmp<0) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpdd Ge1(Gex.first.x,Gey.first.x),Ge2(Gex.second.x,Gey.second.x),Ge3(Gex.first.y,Gey.first.y),Ge4(Gex.second.y,Gey.second.y);\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tif(min(Ge1.first,Ge2.first)<=Getmp.x&&Getmp.x<=max(Ge1.first,Ge2.first)&&min(Ge1.second,Ge2.second)<=Getmp.x&&Getmp.x<=max(Ge1.second,Ge2.second)\n\t\t&&min(Ge3.first,Ge4.first)<=Getmp.y&&Getmp.y<=max(Ge3.first,Ge4.first)&&min(Ge3.second,Ge4.second)<=Getmp.y&&Getmp.y<=max(Ge3.second,Ge4.second)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) { return dcmp(a * p.x + b * p.y + c); }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() { return line(p1, p2); }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    return ok;\n  }\n  bool intersect(segment s) {\n    point a = p1, b = p2, c = s.p1, d = s.p2;\n    double v1 = (c - a).cross(c - d);\n    double v2 = (c - b).cross(c - d);\n    double v3 = (a - c).cross(a - b);\n    double v4 = (a - d).cross(a - b);\n    // printf(\"%lf %lf %lf %lf\\n\", v1, v2, v3, v4);\n    return v1 * v2 <= 0 && v3 * v4 <= 0;\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1);\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif(((xp2-xp0)*(xp2-xp1) <= 0 || (xp3-xp0)*(xp3-xp1) <= 0) && ((yp2-yp0)*(yp2-yp1) <= 0 || (yp3-yp0)*(yp3-yp1) <= 0)) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst double eps = 1e-11;\n\ninline int dcmp(double x){if(-eps<x && x<eps)return 0;return x>0?1:-1;}\n\nstruct points\n{\n\tdouble x,y;\n\tpoints(double _x=0,double _y=0){x=_x,y=_y;}\n\n\tinline friend points operator + (points a,points b){return points(a.x+b.x,a.y+b.y);}\n\tinline friend points operator - (points a,points b){return points(a.x-b.x,a.y-b.y);}\n\tinline friend points operator * (points a,double b){return points(a.x*b,a.y*b);}\n\tinline friend points operator / (points a,double b){return points(a.x/b,a.y/b);}\n\n\tinline friend int operator == (points a,points b){return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;}\n\n\tvoid takein(){x=ty(),y=ty();}\n\tvoid print(char ends='\\n'){printf(\"%.12lf %.12lf\",x,y),putchar(ends);}\n};\n\ninline double dox(points a,points b){return a.x*b.x+a.y*b.y;}\ninline double cox(points a,points b){return a.x*b.y-a.y*b.x;}\ninline double length(points a){return sqrt(dox(a,a));}\ninline double distan(points a,points b){return length(a-b);}\n\ninline points pervec(points a){if(dcmp(length(a))<=0)return points(0,0);return a/length(a);}\n\ninline int isponl(points p,points a,points b)\n{\n\treturn dcmp(cox(p-a,p-b))==0 && distan(a,p)<=distan(a,b) && distan(b,p)<=distan(a,b);\n}\n\nvoid finder()\n{\n\tpoints al,ar,bl,br;\n\tal.takein(),ar.takein(),bl.takein(),br.takein();\n\n\tdouble amix=min(al.x,ar.x),amxx=max(al.x,ar.x),amiy=min(al.y,ar.y),amxy=max(al.y,ar.y);\n\tdouble bmix=min(bl.x,br.x),bmxx=max(bl.x,br.x),bmiy=min(bl.y,br.y),bmxy=max(bl.y,br.y);\n\t\n\tif(amxx<bmix || bmxx<amix || amxy<bmiy || bmxy<amiy){puts(\"0\");return;}\n\tif(isponl(al,bl,br) || isponl(ar,bl,br) || isponl(bl,al,ar) || isponl(br,al,ar)){puts(\"1\");return;}\n\n\tif(dcmp(cox(al-bl,br-bl))!=dcmp(cox(ar-bl,br-bl))\n\t\t&& dcmp(cox(bl-al,ar-al))!=dcmp(cox(br-al,ar-al)))puts(\"1\");\n\telse puts(\"0\");\n}\n\nint main()\n{\n\tint q=ty();\n\twhile(q--)finder();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nstruct Point { double x, y; };//点\nstruct Segment { Point p1, p2; };//線\ndouble dot(Point a, Point b) {//内積\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b) {//外積\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(Point a) {\n    return a.x * a.x + a.y * a.y;\n}\ndouble absv(Point a) {\n    return sqrt(norm(a));\n}\nPoint project(Segment s, Point p) {\n    Point base, q;\n    Point ans;\n    base.x = s.p2.x - s.p1.x;\n    base.y = s.p2.y - s.p1.y;\n    q.x = p.x - s.p1.x;\n    q.y = p.y - s.p1.y;\n    double r = dot(q, base) / norm(base);\n    ans.x = s.p1.x + base.x * r;\n    ans.y = s.p1.y + base.y * r;\n    return ans;\n}\nPoint reflect(Segment s, Point p) {\n    Point ans;\n    ans.x = p.x + (project(s, p).x - p.x) * 2.0;\n    ans.y = p.y + (project(s, p).y - p.y) * 2.0;\n    return ans;\n}\n/*double getPointDistance(Point a, Point b) {\n    Point ans;\n    ans.x = a.x - b.x;\n    ans.y = a.y - b.y;\n    absv(ans);\n}\ndouble getDistanceLP(Segment l, Point p) {\n    Point tmp, tmp2, ans;\n    tmp.x = l.p2.x - l.p1.x;\n    tmp.y = l.p2.y - l.p1.y;\n    tmp2.x = p.x - l.p1.x;\n    tmp2.y = p.y - l.p1.y;\n    return absv(cross(tmp, tmp2) / absv(tmp));\n}\ndouble getDistanceSP(Segment s, Point p) {\n    Point t1, t2, t3, t4;\n    t1.x = s.p2.x - s.p1.x;\n    t1.y = s.p2.y - s.p1.y;\n    t2.x = p.x - s.p1.x;\n    t2.y = p.y - s.p1.y;\n    t3.x = s.p1.x - s.p2.x;\n    t3.y = s.p1.y - s.p2.y;\n    t4.x = p.x - s.p2.x;\n    t4.y = p.y - s.p2.y;\n    if (dot(t1, t2) < 0.0)return absv(t2);\n    if (dot(t3, t4) < 0.0)return absv(t4);\n    return getDistanceLP(s, p);\n}*/\nint ccw(Point p0,Point p1,Point p2){\n    Point a,b;\n    a.x=p1.x-p0.x;\n    a.y=p1.y-p0.y;\n    b.x=p2.x-p0.x;\n    b.y=p2.y-p0.y;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<(-EPS))return CLOCKWISE;\n    if(dot(a,b)<(-EPS))return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    \n    return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersectS(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*double getDistance(Segment s1,Segment s2){\n    if(intersectS(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1)),getDistanceSP(s1,s2.p2)),min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}*/\n\nint main(void) {\n    Segment a,b;\n    int n;cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a.p1.x >> a.p1.y >> a.p2.x >> a.p2.y;\n        cin >> b.p1.x >> b.p1.y >> b.p2.x >> b.p2.y;\n        cout<<intersectS(a,b)<<endl;\n        //cout << fixed << setprecision(10) <<  << \" \" << ans.y << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<complex>\nusing namespace std;\nconst long double EPS=1e-8;\nbool maziwatteruno(complex<long double>a1,complex<long double>a2,complex<long double>b1,complex<long double>b2 ){\n\ta2-=a1;\n\tb1-=a1;\n\tb2-=a1;\n\ta1-=a1;\n\tb1/=a2;\n\tb2/=a2;\n\ta2/=a2;\n\tlong double kouten=(abs(b1.imag())*b2.real()+abs(b2.imag())*b1.real());\n\t\n\tif(abs(b1.imag())+abs(b2.imag())<EPS&&(b1.real()<0&&b2.real()<0)||(b1.real()>1&&b2.real()>1))\n\t{\n\t\treturn false;\n\t}else if(abs(b1.imag())+abs(b2.imag())<EPS){return true;}\n\t\n\tif(b1.imag()*b2.imag()>0){\n\t\t\n\t\t\n\t\treturn false;\n\t}else if(kouten<0||kouten>(abs(b1.imag())+abs(b2.imag()))){\n\t\t\n\t\t\n\t\t\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\n\n\nint main(){\n\tcout << fixed << setprecision(10);\n\t\n\tlong double Re,Im;\n\tint q;\n\tcomplex<long double>p1,p2;\n\t\n\tcin>>q;\n\t\n\tfor(int i=0;i<q;i++){\n\t\t\n\t\t\n\t\tcomplex<long double>p1,p2,p3,p4;\n\t\t\n\t\tcin>>Re>>Im;\n\t\tp1.real(Re);\n\t\tp1.imag(Im);\n\t\tcin>>Re>>Im;\n\t\tp2.real(Re);\n\t\tp2.imag(Im);\n\t\tcin>>Re>>Im;\n\t\tp3.real(Re);\n\t\tp3.imag(Im);\n\t\tcin>>Re>>Im;\n\t\tp4.real(Re);\n\t\tp4.imag(Im);\n\t\tif(maziwatteruno(p1, p2, p3, p4)){\n\t\t\tcout<<1<<endl;\n\t\t}else{\n\t\tcout<<0<<endl;\t\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Vector {\npublic:\n  double x, y;\n  Vector() {}\n  Vector(double x, double y) : x(x), y(y) {}\n\n  Vector operator+(Vector v) { return Vector(x + v.x, y + v.y); }\n  Vector operator-(Vector v) { return Vector(x - v.x, y - v.y); }\n  Vector operator*(double s) { return Vector(s * x, s * y); }\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\n\n// inner product\ndouble dot(Vector v1, Vector v2) { return v1.x * v2.x + v1.y * v2.y; }\n\n// cross product\ndouble cross(Vector v1, Vector v2) { return v1.x * v2.y - v1.y * v2.x; }\n\nclass Line {\npublic:\n  Vector v1, v2;\n  Line() {}\n  Line(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n};\nclass Segment {\npublic:\n  Vector v1, v2;\n  Segment() {}\n  Segment(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  operator Line() const { return Line(v1, v2); }\n};\n\nbool is_parrallel(Vector a, Vector b) { return equals(cross(a, b), 0); }\nbool is_parrallel(Line a, Line b) {\n  return is_parrallel(a.v1 - a.v2, b.v1 - b.v2);\n}\nbool is_parrallel(Segment a, Segment b) {\n  return is_parrallel((Line)a, (Line)b);\n}\n\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0); }\nbool is_orthogonal(Line a, Line b) {\n  return is_orthogonal(a.v1 - a.v2, b.v1 - b.v2);\n}\n\nVector project(Line l, Vector v) {\n  Vector a = v - l.v1;\n  Vector b = l.v2 - l.v1;\n  return l.v1 + b * (dot(a, b) / b.norm());\n}\n\nVector reflect(Line l, Vector v) { return v + (project(l, v) - v) * 2.0; }\n\ndouble distance(Line l, Vector v) { return (v - project(l, v)).abs(); }\ndouble distance(Vector v1, Vector v2) { return (v1 - v2).abs(); }\nbool in_segment(Segment s, Vector v) {\n  return dot(s.v2 - s.v1, v - s.v1) > 0 && dot(s.v1 - s.v2, v - s.v2) > 0;\n}\ndouble distance(Segment s, Vector v) {\n  auto m = project((Line)s, v);\n  if (in_segment(s, m)) {\n    return distance(m, v);\n  } else\n    return min(distance(s.v1, v), distance(s.v2, v));\n}\nbool opposite(Line l, Vector v1, Vector v2) {\n  auto a = l.v2 - l.v1;\n  auto b = v1 - l.v1;\n  auto c = v2 - l.v1;\n  return cross(a, b) * cross(a, c) < 0;\n}\nenum Direction {\n  ONLINE_FRONT = -2,\n  CLOCKWISE = -1,\n  ON_SEGMENT = 0,\n  COUNTER_CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n};\nDirection ccw(Vector v0, Vector v1, Vector v2) {\n  auto a = v1 - v0;\n  auto b = v2 - v0;\n  if (cross(a, b) > 0)\n    return COUNTER_CLOCKWISE;\n  if (cross(a, b) < 0)\n    return CLOCKWISE;\n  if (dot(a, b) < 0)\n    return ONLINE_BACK;\n  if (a.norm() < b.norm())\n    return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nvoid printd(Direction d) {\n  switch (d) {\n  case COUNTER_CLOCKWISE:\n    printf(\"COUNTER_CLOCKWISE\\n\");\n    break;\n  case CLOCKWISE:\n    printf(\"CLOCKWISE\\n\");\n    break;\n  case ONLINE_BACK:\n    printf(\"ONLINE_BACK\\n\");\n    break;\n  case ONLINE_FRONT:\n    printf(\"ONLINE_FRONT\\n\");\n    break;\n  case ON_SEGMENT:\n    printf(\"ON_SEGMENT\\n\");\n    break;\n  }\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return ccw(s1.v1, s1.v2, s2.v1) * ccw(s1.v1, s1.v2, s2.v2) <= 0 &&\n  ccw(s2.v1, s2.v2, s1.v1) * ccw(s2.v1, s2.v2, s1.v2) <= 0;\n}\n\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) {\n    return 0;\n  }\n  return min({distance(s1, s2.v1), distance(s1, s2.v2), distance(s2, s1.v1),\n              distance(s2, s1.v2)});\n}\n\nint main() {\n  int nq;\n  cin >> nq;\n  for (int i = 0; i < nq; i++) {\n    Segment seg[2];\n    for (int j = 0; j < 2; j++) {\n      int x0, y0, x1, y1;\n      cin >> x0 >> y0 >> x1 >> y1;\n      seg[j] = Segment(Vector(x0, y0), Vector(x1, y1));\n    }\n    printf(\"%d\\n\", intersect(seg[0], seg[1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n  if (b.cross(c) > 0)   return +1;       // counter clockwise\n  if (b.cross(c) < 0)   return -1;       // clockwise\n  if (b.dot(c) < 0)     return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;    // a--b--c on line\n  return 0;                              // a--c--b on line\n}\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n\n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n  //平行でない前提\n  Point intersectionPoint(Line l){\n    return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n  }\n\n};\n\nstruct Segment: public Line{\n  Point a,b;\n  \n  bool on(Point c){return ccw(a,b,c)==0;}\n  bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n\n  Real dist(Point c){\n    if((b-a).dot(c-a)<EPS)return c.dist(a);\n    if((a-b).dot(c-b)<EPS)return c.dist(b);\n    return abs((b-a).cross(c-a))/b.dist(a);    \n  }\n\n  Point intersectionPoint(Segment s){\n    Point q=s.b-s.a;\n    Real d1=abs(q.cross(a-s.a));\n    Real d2=abs(q.cross(b-s.a));\n    Real t=d1/(d1+d2);\n    return a+(b-a)*t;\n  }\n\n  //この線分が直線lの上に載っていない前提\n  bool isIntersection(Line l){\n    int p=ccw(a,b,l.a);\n    int q=ccw(a,b,l.b);\n    return (p==1 && q==-1)||(p==-1 && q==1);\n  }\n\n  bool isIntersection(Segment s){\n    if(isParallel(s))return on(s.a)||on(s.b)||s.on(a)||s.on(b);\n    return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n\t    ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n  }\n};\n\nint main(void){\n\n  int q;\n  cin >> q;\n  while(q--){\n    Segment a,b;\n    cin >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    cin >> b.a.x >> b.a.y >> b.b.x >> b.b.y;\n    cout << a.isIntersection(b) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)\n#define per(i, a, b) for (int i = a, i##end = b; i >= i##end; --i)\n#define rep0(i, a) for (int i = 0, i##end = a; i < i##end; ++i)\n#define per0(i, a) for (int i = (int)a-1; ~i; --i)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define chkmax(a, b) a = max(a, b)\n#define chkmin(a, b) a = min(a, b)\n#define x first\n#define y second\n#define enter putchar('\\n')\n\ntypedef long long ll;\ntypedef double DB;\n\nconst DB eps = 1e-12;\n\nint sgn(DB x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }\n\nstruct Point {\n\tDB x, y;\n\tPoint(DB x = 0, DB y = 0) : x(x), y(y) {}\n\tPoint operator + (Point a) { return Point(x + a.x, y + a.y); }\n\tPoint operator - (Point a) { return Point(x - a.x, y - a.y); }\n\tPoint operator - () { return Point(-x, -y); }\n\tfriend Point operator * (DB k, Point a) { return Point(k * a.x, k * a.y); }\n\tDB operator % (Point a) { return x * a.x + y * a.y; }\n\tDB operator / (Point a) { return x * a.y - y * a.x; }\n\toperator DB() { return sqrt(*this % *this); }\n};\n\nPoint gp() { Point a; scanf(\"%lf%lf\", &a.x, &a.y); return a; }\nvoid wp(Point a) { printf(\"%.10lf %.10lf \", a.x, a.y); }\n\nstruct Poly {\n\tstd::vector<Point> a;\n\tPoly(int n = 0) { a.resize(n); rep0(i, n) a[i] = gp(); }\n\tPoint &operator [] (int i) { int n = a.size(); return a[i >= n ? i-n : i]; }\n};\n\nPoint Proj(Point P, Point P1, Point P2) { // Projection\n\tPoint v = P2-P1; DB t = (P-P1)%v / (v%v);\n\treturn P1 + t*v;\n}\n\nint Direct(Point P, Point P1, Point P2) { return sgn((P1-P)/(P2-P)); }\n\nbool IsInter(Point P1, Point P2, Point Q1, Point Q2) {\n\tif (min(P1.x, P2.x) <= max(Q1.x, Q2.x) && max(P1.x, P2.x) >= min(Q1.x, Q2.x) && min(P1.y, P2.y) <= max(Q1.y, Q2.y) && max(P1.y, P2.y) >= min(Q1.y, Q2.y))\n\t\tif (Direct(P1, P2, Q1) * Direct(P1, P2, Q2) <= 0 && Direct(Q1, Q2, P1) * Direct(Q1, Q2, P2) <= 0) return 1;\n\treturn 0;\n}\n\nint q;\n\nint main() {\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tPoint P1 = gp(), P2 = gp(), Q1 = gp(), Q2 = gp();\n\t\tprintf(\"%d\\n\", IsInter(P1, P2, Q1, Q2));\n\t\t//wp(Proj(P, P1, P2)); enter;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n#include <cstdint>\n#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nvoid CallLineSegmentIntersection(std::istream &input_stream) noexcept;\n\nclass Point2D {\n public:\n  Point2D() noexcept;\n  Point2D(const double x, const double y) noexcept;\n  ~Point2D() noexcept;\n  Point2D(const Point2D &obj) noexcept;\n  Point2D &operator=(const Point2D &obj) noexcept;\n  Point2D(Point2D &&obj) noexcept;\n  Point2D &operator=(Point2D &&obj) noexcept;\n\n  Point2D operator+(const Point2D &rhs) const noexcept;\n  Point2D operator-(const Point2D &rhs) const noexcept;\n  Point2D operator*(const double rhs) const noexcept;\n  double InnerProduct(const Point2D &rhs) const noexcept;\n  double OuterProduct(const Point2D &rhs) const noexcept;\n  double SquareSum() const noexcept;\n  double Norm() const noexcept;\n\n  double X() const noexcept;\n  double Y() const noexcept;\n\n private:\n  double x_;\n  double y_;\n};\n\nclass Line {\n public:\n  Line(const Point2D &p1, const Point2D &p2) noexcept;\n  ~Line() noexcept;\n  bool IsParallel(const Line &rhs) const noexcept;\n  bool IsOrthogonal(const Line &rhs) const noexcept;\n  bool IsOnLine(const Point2D &point) const noexcept;\n  bool operator==(const Line &rhs) const noexcept;\n  bool operator!=(const Line &rhs) const noexcept;\n  Point2D ProjectPoint(const Point2D &point) const;\n  Point2D ReflectPoint(const Point2D &point) const;\n\n  bool SegmentsAreCrossing(const Line &line) const;\n  bool PointIsOnSegment(const Point2D &point) const;\n  double GetLineSegmentDistanceFromPoint(const Point2D &point) const;\n  double GetLineSegmentDistance(const Line &line) const;\n\n private:\n  Line() = delete;\n  Line(const Line &obj) = delete;\n  Line &operator=(const Line &obj) = delete;\n  Line(Line &&obj) = delete;\n  Line &operator=(Line &&obj) = delete;\n\n private:\n  Point2D p1_;\n  Point2D p2_;\n};\n\nvoid CallLineSegmentIntersection(std::istream &input_stream) noexcept {\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  int32_t number_of_queries;\n  input_stream >> number_of_queries;\n  for (int32_t i = 0; i < number_of_queries; ++i) {\n    int32_t p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y;\n    input_stream >> p0_x >> p0_y >> p1_x >> p1_y >> p2_x >> p2_y >> p3_x >> p3_y;\n    Line line1(Point2D(p0_x, p0_y), Point2D(p1_x, p1_y));\n    Line line2(Point2D(p2_x, p2_y), Point2D(p3_x, p3_y));\n    std::cout << (line1.SegmentsAreCrossing(line2) ? 1 : 0) << std::endl;\n  }\n}\n\n// *************************************\nPoint2D::Point2D() noexcept : x_(0.0), y_(0.0) {}\n\nPoint2D::Point2D(const double x, const double y) noexcept : x_(x), y_(y) {}\n\nPoint2D::~Point2D() noexcept {}\n\nPoint2D::Point2D(const Point2D &obj) noexcept : x_(obj.x_), y_(obj.y_) {}\n\nPoint2D &Point2D::operator=(const Point2D &rhs) noexcept {\n  if (this != &rhs) {\n    this->x_ = rhs.x_;\n    this->y_ = rhs.y_;\n  }\n  return *this;\n}\n\nPoint2D::Point2D(Point2D &&obj) noexcept : x_(obj.x_), y_(obj.y_) {}\n\nPoint2D &Point2D::operator=(Point2D &&rhs) noexcept {\n  if (this != &rhs) {\n    this->x_ = rhs.x_;\n    this->y_ = rhs.y_;\n  }\n  return *this;\n}\n\nPoint2D Point2D::operator+(const Point2D &rhs) const noexcept {\n  Point2D point(this->x_ + rhs.x_, this->y_ + rhs.y_);\n  return point;\n}\n\nPoint2D Point2D::operator-(const Point2D &rhs) const noexcept {\n  Point2D point(this->x_ - rhs.x_, this->y_ - rhs.y_);\n  return point;\n}\n\nPoint2D Point2D::operator*(const double rhs) const noexcept {\n  Point2D point(this->x_ * rhs, this->y_ * rhs);\n  return point;\n}\n\ndouble Point2D::X() const noexcept {\n  return x_;\n}\n\ndouble Point2D::Y() const noexcept {\n  return y_;\n}\n\ndouble Point2D::InnerProduct(const Point2D &rhs) const noexcept {\n  return ((this->x_ * rhs.x_) + (this->y_ * rhs.y_));\n}\ndouble Point2D::OuterProduct(const Point2D &rhs) const noexcept {\n  return ((this->x_ * rhs.y_) - (this->y_ * rhs.x_));\n}\n\ndouble Point2D::SquareSum() const noexcept {\n  return (x_ * x_ + y_ * y_);\n}\n\ndouble Point2D::Norm() const noexcept {\n  return sqrt(SquareSum());\n}\n\n// ************************************************\n\nLine::Line(const Point2D &p1, const Point2D &p2) noexcept : p1_(p1), p2_(p2) {}\n\nLine::~Line() noexcept {}\n\nbool Line::IsParallel(const Line &rhs) const noexcept {\n  const Point2D this_direction = this->p2_ - this->p1_;\n  const Point2D rhs_direction = rhs.p2_ - rhs.p1_;\n  const double outer_product = this_direction.OuterProduct(rhs_direction);\n  constexpr double kEps = 0.0000001;\n  const bool is_parallel = (abs(outer_product) < kEps);\n  return is_parallel;\n}\n\nbool Line::IsOrthogonal(const Line &rhs) const noexcept {\n  const Point2D this_direction = this->p2_ - this->p1_;\n  const Point2D rhs_direction = rhs.p2_ - rhs.p1_;\n  constexpr double kEps = 0.0000001;\n  const double inner_product = this_direction.InnerProduct(rhs_direction);\n  const bool is_parallel = (abs(inner_product) < kEps);\n  return is_parallel;\n}\n\nbool Line::IsOnLine(const Point2D &point) const noexcept {\n  const Line line1(point, p1_);\n  const Line line2(point, p2_);\n  const bool is_on_line = line1.IsParallel(line2);\n  return is_on_line;\n}\n\nbool Line::operator==(const Line &rhs) const noexcept {\n  return (IsOnLine(rhs.p1_) && IsOnLine(rhs.p2_));\n}\n\nbool Line::operator!=(const Line &rhs) const noexcept {\n  return !(*this == rhs);\n}\n\nPoint2D Line::ProjectPoint(const Point2D &point) const {\n  const Point2D p2_from_p1 = p2_ - p1_;\n  const Point2D point_from_p1 = point - p1_;\n  const double square_sum = p2_from_p1.SquareSum();\n  constexpr double kEps = 0.0000001;\n  if (abs(square_sum) < kEps) {\n    std::cerr << \"ERROR: Line::ProjectPoint()\" << std::endl;\n    throw 1;\n  }\n  const double coefficient = p2_from_p1.InnerProduct(point_from_p1) / square_sum;\n  const Point2D projected_point = p1_ + (p2_from_p1 * coefficient);\n  return projected_point;\n}\n\nPoint2D Line::ReflectPoint(const Point2D &point) const {\n  Point2D reflected_point;\n  try {\n    const Point2D projected_point = ProjectPoint(point);\n    reflected_point = point + ((projected_point - point) * 2.0);\n  } catch (...) {\n    std::cerr << \"ERROR: ReflectPoint()\" << std::endl;\n  }\n  return reflected_point;\n}\n\ndouble Line::GetLineSegmentDistanceFromPoint(const Point2D &point) const {\n  double distance;\n  try {\n    const Point2D projected_point_from_point1 = ProjectPoint(point) - p1_;\n    const Point2D point2_from_point1 = p2_ - p1_;\n    bool projected_point_is_inside = ((projected_point_from_point1.SquareSum() <= point2_from_point1.SquareSum()) &&\n                                      (projected_point_from_point1.InnerProduct(point2_from_point1) >= 0.0));\n    if (projected_point_is_inside) {\n      const Point2D r = ProjectPoint(point) - point;\n      distance = r.Norm();\n    } else {\n      const Point2D diff1 = point - p1_;\n      const Point2D diff2 = point - p2_;\n      distance = fmin(diff1.Norm(), diff2.Norm());\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: GetLineSegmentDistanceFromPoint()\" << std::endl;\n    throw 1;\n  }\n  return distance;\n}\n\ndouble Line::GetLineSegmentDistance(const Line &line) const {\n  double line_segment_distance;\n  try {\n    if (SegmentsAreCrossing(line)) {\n      line_segment_distance = 0.0;\n    } else {\n      line_segment_distance =\n          fmin(fmin(GetLineSegmentDistanceFromPoint(line.p1_), GetLineSegmentDistanceFromPoint(line.p2_)),\n               fmin(line.GetLineSegmentDistanceFromPoint(p1_), line.GetLineSegmentDistanceFromPoint(p2_)));\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: GetLineSegmentDistance()\" << std::endl;\n  }\n  return line_segment_distance;\n}\n\nbool Line::PointIsOnSegment(const Point2D &point) const {\n  constexpr double kEps = 0.0000001;\n  bool point_is_on_segment;\n  try {\n    point_is_on_segment = (GetLineSegmentDistanceFromPoint(point) < kEps);\n  } catch (...) {\n    std::cerr << \"ERROR: PointIsOnSegment()\" << std::endl;\n    throw;\n  }\n  return point_is_on_segment;\n}\n\nbool Line::SegmentsAreCrossing(const Line &line) const {\n  const Point2D r1 = p2_ - p1_;\n  const Point2D diff1_1 = line.p1_ - p1_;\n  const Point2D diff1_2 = line.p2_ - p1_;\n  const bool temp_1 = ((r1.OuterProduct(diff1_1) * r1.OuterProduct(diff1_2)) < 0.0);\n\n  const Point2D r2 = line.p2_ - line.p1_;\n  const Point2D diff2_1 = p1_ - line.p1_;\n  const Point2D diff2_2 = p2_ - line.p1_;\n  const bool temp_2 = ((r2.OuterProduct(diff2_1) * r2.OuterProduct(diff2_2)) < 0.0);\n\n  const bool any_points_is_on_segment = (PointIsOnSegment(line.p1_) || PointIsOnSegment(line.p2_) ||\n                                         line.PointIsOnSegment(p1_) || line.PointIsOnSegment(p2_));\n\n  return (temp_1 && temp_2) || any_points_is_on_segment;\n}\n\nint main(int argc, char *argv[]) {\n  try {\n    CallLineSegmentIntersection(std::cin);\n  } catch (...) {\n    std::cerr << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n#define DBG(n) n;\n#else\n#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\t\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\tif(intersectSP(s,t[0]) || intersectSP(s,t[1]) || intersectSP(t,s[0]) || intersectSP(t,s[1]))return true;\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tif(!intersectSS(l,m))return point(INF,INF);\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return point(INF,INF); // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用) \nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble X = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble Y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(X, Y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\nint main() {\n\tint q;cin >> q;\n\tREP(i,q){\n\t\tint a,b,c,d;cin >> a >> b >> c >> d;\n\t\tsegment A = segment(point(a,b),point(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tsegment B = segment(point(a,b),point(c,d));\n\t\tif(intersectSS(A,B)){\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, N) for (int i = 0; i < (int)N; ++i)\n#define all(a) (a).begin(), (a).end()\nconst double EPS = 1e-10;\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n  Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n  Point operator*(const double a) { return Point(a * x, a * y); }\n  Point operator/(const double a) { return Point(x / a, y / a); }\n\n  double abs() const { return sqrt(norm()); }\n  double norm() const { return x * x + y * y; }\n\n  Point rotate(double theta) const {\n    return Point(cos(theta) * x - sin(theta) * y,\n                 sin(theta) * x + cos(theta) * y);\n  }\n\n  Point normalize() const { return Point(*this) / abs(); }\n\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }\n};\n\ndouble abs(const Point &p) { return p.abs(); }\ndouble norm(const Point &p) { return p.norm(); }\n\ntypedef Point Vector;\n\nclass Segment {\n public:\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  friend istream &operator>>(istream &is, Segment &s) {\n    return is >> s.p1 >> s.p2;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\n  int contains(const Point &p) const {\n    double d = abs(c - p);\n    if (equals(d, r)) return 1;  // ON\n    if (d < r + EPS) return 2;   // IN\n    return 0;                    // OUT\n  }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\ndouble distance(Point a, Point b) { return (a - b).abs(); }\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble distanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n  return distanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min({distanceSP(s1, s2.p1), distanceSP(s1, s2.p2),\n              distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)});\n}\n\nenum CCW {\n  COUNTER_CLOCKWISE = 1,\n  CLOCKWISE = -1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\nCCW ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;      // p2, p0, p1\n  if (a.norm() < b.norm()) return ONLINE_FRONT;  // p0, p1, p2\n  return ON_SEGMENT;                             // p0, p2, p1\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l) { return distanceLP(l, c.c) < c.r; }\n\npair<Point, Point> crossPoint(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nbool intersect(Circle c1, Circle c2) {\n  return (c1.c - c2.c).abs() < c1.r + c2.r;\n}\n\npair<Point, Point> crossPoint(Circle c1, Circle c2) {\n  assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/*\n  IN 2\n  ON 1\n  OUT 0\n*/\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    Point a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS & EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nPolygon convexHull(Polygon s) {\n  Polygon u, l;\n  if (s.size() < 3) return s;\n  sort(s.begin(), s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size() - 1]);\n  l.push_back(s[s.size() - 2]);\n\n  for (int i = 2; i < s.size(); ++i) {\n    for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE;\n         --n) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for (int i = s.size() - 3; i >= 0; i--) {\n    for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE;\n         --n) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(), l.end());\n  for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n  return l;\n}\n\nCircle circumscribedCircle(const Point &a, const Point &b, const Point &c) {\n  double a1, a2, b1, b2, c1, c2;\n  a1 = 2 * (b.x - a.x);\n  b1 = 2 * (b.y - a.y);\n  c1 = a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;\n  a2 = 2 * (c.x - a.x);\n  b2 = 2 * (c.y - a.y);\n  c2 = a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;\n  Point p;\n  p.x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n  p.y = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n  return Circle(p, abs(p - a));\n}\n\nint main() {\n  int q;\n  cin >> q;\n  rep(i, q) {\n    Segment s1, s2;\n    cin >> s1 >> s2;\n    cout << (intersect(s1, s2) ? 1 : 0) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n/*\nx 座標は p.real(), real(p), y 座標は p.imag(), imag(p) とする．\n足し算，引き算，スカラー倍は定義済み．\noperator < は入っていないので自分で namespace std に突っ込む．*/\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b);\n\n\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n//ラジアンに変換\ndouble radian(double angle){\n    return angle/180.0*M_PI;\n}\n//度数に変換\ndouble degree(double radian){\n    return radian*180.0/M_PI;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n    (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(point a1,point a2,point b1,point b2) {\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// 線分同士の最短距離\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n               dist_linesegment_and_point(a1,a2,b2)),\n    min(dist_linesegment_and_point(b1,b2,a1),\n        dist_linesegment_and_point(b1,b2,a2)));\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// verify\nbool is_orthogonal(point a1,point a2,point b1,point b2) {\n    return abs(dot(a1-a2,b1-b2))< EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n//verify\nbool is_parallel(point a1,point a2,point b1,point b2) {\n    return abs(cross(a2-a1,b2-b1)) < EPS;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(point a1,point a2,point b1,point b2) {\n    return not is_parallel(a1,a2,b1,b2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(point a1,point a2,point b1,point b2) {\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\n// 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n// 円と線分の交差判定\nbool is_cross_linesegment_and_circle(point c,double r,point a1,point a2){\n    return (dist_linesegment_and_point(a1,a2,c) < r+EPS and\n            (r < abs(c-a1) + EPS or r < abs(c-a2) + EPS));\n}\n\n//線の進行方向\nint ccw(point p0, point p1, point p2)\n{\n    point a = p1 - p0;\n    point b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    return (0); //p0--p2--p1 の順で一直線上\n}\n\n// 点が真に多角形(凸?)の中にはいっているか\nbool is_inner_point_vertex(const vector<point> &ps,point a){\n    int cc = ccw(ps[0],ps[1],a);\n    if(not(cc == 1 or cc == -1)) return false;\n    for(size_t i=0;i<ps.size();i++){\n        if(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n    }\n    return true;\n}\n\n// 点が辺上、もしくは内部にある。(未検証)\nbool is_inner_point_vertex_or_line(const vector<point> &ps,point a){\n    for(size_t i=0;i<ps.size();i++){\n        if(dist_linesegment_and_point(ps[i],ps[(i+1)%ps.size()],a) < EPS){\n            return true;\n        }\n    }\n    return is_inner_point_vertex(ps,a);\n}\n\n\n// 凸包 (UVA 109)\nvector<point> convex_hull(vector<point> ps){\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(),ps.end());\n    vector<point> ch(2*n);\n    for(int i=0;i<n;ch[k++] = ps[i++]){\n        while(k >= 2 and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    }\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--]){\n        while(k >= t and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n// remember,pts make convex.\n// (http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACAC002&pid=C)\ndouble convex_diameter(const vector<point>& pts){\n    const int n = pts.size();\n    int is=0,js=0; // initial antipode.\n    for(int i=1;i<n;i++){\n        if(pts[i].imag() > pts[is].imag()) is = i;\n        if(pts[i].imag() < pts[js].imag()) js = i;\n    }\n    double maxd = abs(pts[is]-pts[js]);\n    int i,j,maxi,maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(cross(pts[(i+1)%n]-pts[i],\n           pts[(j+1)%n]-pts[j]) >= 0){\n            j = (j+1)%n;\n    }else{\n        i = (i+1)%n;\n    }\n    if(abs(pts[i]-pts[j]) > maxd){\n        maxd = abs(pts[i]-pts[j]);\n        maxi = i;maxj = j;\n    }\n} while(not(i == is and j == js));\n    // pts[maxi],pts[maxj] is pair of max diff.\nreturn maxd;\n}\n\n// 円と円の交点(2点ある前提)\nvector<point> circles_point(point c1,double r1,point c2,double r2){\n    double d = abs(c1-c2);\n    double s = (r1+r2+d) / 2;\n    double S = sqrt(s*(s-r1)*(s-r2)*(s-d));\n    double h = 2 * S / d;\n    point v = (c2-c1) / (abs(c2-c1));\n\n    double m = sqrt(r1*r1 - h*h);\n\n    vector<point> ret;\n    ret.push_back(c1 + m*v+h*v*point(0,1));\n    ret.push_back(c1 + m*v-h*v*point(0,1));\n    return ret;\n}\n\n// clockwiseだと負\ndouble triangle_area(point a,point b,point c){\n    return cross(b-a,c-a)/2;\n}\n\n// clockwiseだと負\ndouble vertex_area(vector<point> v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += triangle_area(v[0],v[i],v[i+1]);\n    }\n    return ret;\n}\n/*多角形の面積を求める*/\n//verify\ndouble area_vertex(const vertex& g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n//円同士が互いに含まれているかどうか\n//中心が(xa,ya)で半径r1の円Aと、中心が(xb,yb) で半径 r2 の円 B が与えられたとき、 B が A の中にあるとき 2、A が B の中にあるとき -2、A の円周と B の円周が交わっている場合 1、A と B が重なっていないとき 0 \n//verify\nint Circles_Intersection(point a,double r1,point b,double r2){\n    double dp =abs(a-b);//中心間の距離\n    double dr =r1+r2;//円の半径の合計\n    if(dp >dr){\n        return 0;\n    }else if(dp +r1 <r2){\n        return -2;\n    }else if(dp +r2 <r1){\n        return 2;\n    }else if(dp <=dr){\n        return 1;\n    }\n    return -100;\n}\npoint projection(point p1, point p2, point p3) //直線p1p2 上への写像の点\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\npoint reflection(point p1, point p2, point p3) //直線p1p2 上への反射した点(線分p1p2に対してp3を線対称)\n{\n\n    return (p3 + 2.0*(projection(p1, p2, p3) - p3));\n}\n/*// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n    (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}*/\n\nint main(){\n    double x1,y1,x2,y2,x3,y3,x4,y4;\n    int q;\n    cin>>q;// 点の進行方向\n    for(int i =0;i <q;i++){\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        point p1(x1,y1),p2(x2,y2),p3(x3,y3),p4(x4,y4);\n        if(is_intersected_linesegment(p1, p2, p3, p4)){\n            cout <<1<<endl;\n        }else{\n            cout <<0<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-8;\nconst double inf=1e12;\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p){\n  return p+2.0*(projection(l,p)-p);\n}\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  int q;\n  cin>>q;\n  while(q--){\n    P p[4];\n    rep(i,4){\n      double x,y;\n      cin>>x>>y;\n      p[i]=P(x,y);\n    }\n    if(intersectSS(L(p[1],p[0]),L(p[2],p[3])))cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing Real = double;\nconstexpr Real EPS = 1e-10;\nconstexpr Real INF = 1e18;\nconst Real PI = acos(-1);\n\nusing P = complex<Real>;\nint sgn(const Real a) {\n    return (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n}\n\ninline bool EQ(Real a, Real b) {\n    return (abs(a - b) < EPS);\n}\n\ninline Real Get_Value(Real a) {\n    return (EQ(a, 0) ? 0 : a);\n}\n\nistream &operator>>(istream &is, P &p) {\n    Real a, b;\n    is >> a >> b;\n    p = P(a, b);\n    return is;\n}\nostream &operator<<(ostream &os, P &p) {\n    return os << fixed << setprecision(12) << Get_Value(p.real()) << \" \" << Get_Value(p.imag());\n}\n\nP operator*(const P &p, const Real &d) {\n    return P(real(p) * d, imag(p) * d);\n}\n\nbool operator==(const P &p, const P &q) {\n    return (EQ(p.real(), q.real()) && EQ(p.imag(), q.imag()));\n}\n\nReal dot(const P &a, const P &b) {\n    // ベクトル a,b の内積\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nReal cross(const P &a, const P &b) {\n    // 外積\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstruct Line {\n    // 直線\n    P a, b;\n\n    Line() = default;\n\n    Line(P a, P b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if(EQ(A, 0))\n            a = P(0, C / B), b = P(1, C / B);\n        else if(EQ(B, 0))\n            b = P(C / A, 0), b = P(C / A, 1);\n        else\n            a = P(0, C / B), b = P(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a) {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line {\n    // 線分\n    Segment() = default;\n    Segment(P a,P b):Line(a,b){}\n};\n\nstruct Circle {\n    // 円 p が中心 r が半径\n    P p;\n    Real r;\n    Circle() = default;\n    Circle(P p,Real r):p(p),r(r){};\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const P &a, P b, P c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\" CがベクトルABの半時計方向にある\n    if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\" CがベクトルABの時計方向にある\n    if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\" Cが直線AB上かつAの方向にある\n    if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\" Cが直線AB上かつBの方向にある\n    return 0;                         // \"ON_SEGMENT\" Cが線分AB上に乗っている\n}\n\nbool is_orthogonal(const Line &a, const Line &b) {\n    // 2直線の直交判定\n    // 2つのベクトルの内積が0なら直交\n    return EQ(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n    // 2直線の平行判定\n    // 2つのベクトルの外積が0なら平行\n    return EQ(cross(a.b - a.a, b.a - b.b), 0.0);\n}\n\nbool is_point_on_line(const P &a, const P &b, const P &c) {\n    // 点cが直線a,b上にあるかどうか\n    // ab ベクトルと ac ベクトルが平行なら点cは直線a,b上にある\n    // 3点は同一直線状にあるともいえる\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n    // 線分同士の交差判定\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP projection(const Line &s, const P &p){\n    Real t = dot(p-s.a,s.a-s.b)/norm(s.a-s.b);\n    return s.a+(s.a-s.b)*t;\n}\n\nP refrection(const Line &s, const P &p) {\n    return (projection(s, p) - p) * 2.0 + p;\n}\n\nP refrection(const Segment &s, const P &p) {\n    return refrection((Line)s, p);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    while(n--){\n        Segment p,q;\n        cin >> p >> q;\n        cout << intersect(p,q) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif(((p2-p0).dot(p2-p1)<=0)||((p3-p0).dot(p3-p1)<=0)){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ld = long double;\nusing point = std::complex<ld>;\nusing polygon = std::vector<point>;\n\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = std::acos(-1.0);\n\nbool comp(point a, point b) {\n    return std::real(a) < std::real(b) || (std::real(a) <= std::real(b) && std::imag(a) < std::imag(b));\n}\n\nstd::vector<point> unique(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    std::vector<point> res;\n    for(auto& p : ps) {\n        if(res.empty() || abs(res.back() - p) > eps) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n\nld dot(point const& a, point const& b) {\n    return std::real(std::conj(a) * b);\n}\nld cross(point const& a, point const& b) {\n    return std::imag(std::conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps) return 1;            // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps) return -1;          // a -> b -> c : clockwise\n    if(dot(b, c) < 0) return 2;                // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\nstruct segment {\n    segment() : a(0, 0), b(0, 0) {}\n    segment(point a, point b) : a(a), b(b) {}\n    point a, b;\n};\n\nstruct line {\n    line() : a(0, 0), b(0, 0) {}\n    line(point a, point b) : a(a), b(b) {}\n    line(segment s) : a(s.a), b(s.b) {}\n    point a, b;\n};\n\n\nbool isis_ll(line l, line m) {\n    return cross(l.b - l.a, m.b - m.a) < eps;\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint is_ss(segment s1, segment s2) {\n    assert(isis_ss(s1, s2));\n    point sv = s1.b - s1.a, tv = s2.b - s2.a;\n    if(cross(sv, tv) == 0) {\n        if(std::abs(s1.a - s2.a) < eps || std::abs(s1.a - s2.b) < eps) {\n            return s1.a;\n        } else {\n            return s1.b;\n        }\n    } else {\n        return is_ll(line(s1), line(s2));\n    }\n}\n\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n    while(q--) {\n        vector<segment> segs(2);\n        for(int i = 0; i < 2; ++i) {\n            ld x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            segs[i] = segment(point(x1, y1), point(x2, y2));\n        }\n        cout << isis_ss(segs[0], segs[1]) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tPoint p[4];\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t{\n\t\t\tcin >> p[j].x >> p[j].y;\n\t\t}\n\t\tif (intersect(p[0], p[1], p[2], p[3]))\n\t\t{\n\t\t\tcout << \"1\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"0\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nconst double eps = 1e-10;\ninline bool eq(double a, double b) { return fabs(a - b) < eps; }\nconst double pi = acos(-1);\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(x * k, y * k); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\nistream &operator>>(istream &is, Point &p) {\n    is >> p.x >> p.y;\n    return is;\n}\nostream &operator<<(ostream &os, Point p) {\n    os << fixed << setprecision(10) << p.x << \" \" << p.y;\n    return os;\n}\nPoint rotate(double theta, const Point &p) {\n    return Point(cos(theta) * p.x - sin(theta) * p.y, sin(theta) * p.x + cos(theta) * p.y);\n}\ndouble radian_to_degree(double r) { return (r * 180.0 / pi); }\ndouble degree_to_radian(double d) { return (d * pi / 180.0); }\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Line(double A, double B, double C) { // Ax + By = C\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            a = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n    Point vec() const { return b - a; }\n};\nstruct Segment : Line {\n    Segment() {}\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\ndouble norm(const Point &a) { return a.x * a.x + a.y * a.y; }\ndouble abs(const Point &a) { return sqrt(norm(a)); }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\n\nPoint project(Line l, Point p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\nPoint reflect(Line l, Point p) { return p + (project(l, p) - p) * 2; }\nbool parallel(Line a, Line b) { return eq(cross(a.vec(), b.vec()), 0.0); }\nbool orthogonal(Line a, Line b) { return eq(dot(a.vec(), b.vec()), 0.0); }\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > eps)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -eps)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\nbool intersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\nbool intersect(const Line &l, const Line &m) { return !parallel(l, m) || abs(cross(l.vec(), m.b - l.a)) < eps; }\nbool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\nbool intersect(const Line &l, const Segment &s) { return cross(l.vec(), s.a - l.a) * cross(l.vec(), s.b - l.a) < eps; }\ndouble distance(const Line &l, const Point &p);\nbool intersect(const Circle &c, const Line &l) { return distance(l, c.p) <= c.r + eps; }\nbool intersect(const Circle &c, const Point &p) { return abs(abs(p - c.p) - c.r) < eps; }\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nint intersect(const Circle &c, const Segment &l) {\n    if (norm(project(l, c.p) - c.p) - c.r * c.r > eps)\n        return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if (d1 < c.r + eps && d2 < c.r + eps)\n        return 0;\n    if ((d1 < c.r - eps && d2 > c.r + eps) || (d1 > c.r + eps && d2 < c.r - eps))\n        return 1;\n    const Point h = project(l, c.p);\n    if (dot(l.a - h, l.b - h) < 0)\n        return 2;\n    return 0;\n}\nint intersect(Circle c1, Circle c2) {\n    if (c1.r < c2.r)\n        swap(c1, c2);\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d)\n        return 4;\n    if (eq(c1.r + c2.r, d))\n        return 3;\n    if (c1.r - c2.r < d)\n        return 2;\n    if (eq(c1.r - c2.r, d))\n        return 1;\n    return 0;\n}\ndouble distance(const Point &a, const Point &b) { return abs(a - b); }\ndouble distance(const Line &l, const Point &p) { return abs(p - project(l, p)); }\ndouble distance(const Line &l, const Line &m) { return intersect(l, m) ? 0 : distance(l, m.a); }\ndouble distance(const Segment &s, const Point &p) {\n    Point r = project(s, p);\n    if (intersect(s, r))\n        return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\ndouble distance(const Segment &a, const Segment &b) {\n    if (intersect(a, b))\n        return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\ndouble distance(const Line &l, const Segment &s) {\n    if (intersect(l, s))\n        return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int q;\n    cin >> q;\n    vector<Segment> f, t;\n    for (int i = 0; i < q; ++i) {\n        Point a, b, c, d;\n        cin >> a >> b >> c >> d;\n        f.emplace_back(a, b);\n        t.emplace_back(c, d);\n    }\n    for (int i = 0; i < q; ++i) {\n        if (intersect(f[i], t[i]))\n            cout << 1 << \"\\n\";\n        else\n            cout << 0 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Counter-Clockwise\n#include <iostream>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nstatic const double ESP = 1e-10;\n\nbool equals(double a, double b) { return fabs(a - b) < ESP; }\n\nclass Point {\npublic:\n    double x, y;\n\n    explicit Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(a / x, a / y); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < ESP && fabs(y - p.y) < ESP;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector v1, Vector v2) {\n    return equals(cross(v1, v2), 0.0);\n}\n\nbool isOrthogonal(Vector v1, Vector v2) {\n    return equals(dot(v1, v2), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    return s.p1 + (base * (dot(base, p - s.p1) / base.norm()));\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2;\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > ESP) return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -ESP) return CLOCKWISE;\n    else if (dot(a, b) < -ESP) return ONLINE_BACK;\n    else if (a.norm() < b.norm()) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n    int q;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> q;\n    for(int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = Segment(Point(x0, y0), Point(x1, y1));\n        Segment s2 = Segment(Point(x2, y2), Point(x3, y3));\n        if(intersect(s1, s2)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double ta, tb, tc, td;\n    ta = (p3.x - p4.x) * (p1.y - p3.y) + (p3.y - p4.y) * (p3.x - p1.x);\n    tb = (p3.x - p4.x) * (p2.y - p3.y) + (p3.y - p4.y) * (p3.x - p2.x);\n    tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - p3.x);\n    td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - p4.x);\n    return ta * tb < 0 && tc * td < 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n    // cout<<\"p1=\"<<p1<<\",s2=\"<<s2<<endl;\n    // cout<<\"p1.real()/s2.real()=\"<<p1.real()/s2.real()<<endl;\n\n    // printf(\"s1.real%f,s1.imag%f\\ns2.real%f,s2.imag%f\\n\",s1.real(),s1.imag(),s2.real(),s2.imag());\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){//parallel\n      if(s1.real()==0 && s2.real()==0){//tate\n\tif( ( min(p3.imag(),p4.imag()) <= p2.imag() &&\n\t      p2.imag() <= max(p3.imag(),p4.imag()) )  ||\n\t    ( min(p3.imag(),p4.imag()) <= p1.imag() && \n\t      p1.imag() <= max(p3.imag(),p4.imag()) ) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else if(s1.imag()==0 && s2.imag()==0){//yoko\n\tif( ( min(p3.real(),p4.real()) <= p2.real() &&\n\t      p2.real() <= max(p3.real(),p4.real()) )  ||\n\t    ( min(p3.real(),p4.real()) <= p2.real() &&\n\t      p2.real() <= max(p3.real(),p4.real()) )  )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else \n\tcout<<\"0\"<<endl;\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine a, b;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &a.a.x, &a.a.y, &a.b.x, &a.b.y, &b.a.x, &b.a.y, &b.b.x, &b.b.y);\n\t\tif(!cmp(dis_segment_segment(a, b)))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t\t//~ Point res;\n\t\t//~ if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\t\t//~ puts(\"1\");\n\t\t//~ else\n\t\t\t//~ puts(\"0\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) {a = _a, b = _b, v = b - a;}\n    L(double _ax, double _ay, double _bx, double _by) {\n        a = P(_ax, _ay), b = P(_bx, _by), v = b - a;\n    }\n};\n\nbool intersectSS(L l1, L l2) {\n    return (cross(l1.v, l2.a - l1.a) * cross(l1.v, l2.b - l1.a) <= 0 &&\n            cross(l2.v, l1.a - l2.a) * cross(l2.v, l1.b - l2.a) <= 0);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int v[4][2];\n        rep(i, 4) rep(j, 2) cin >> v[i][j];\n        L l1(v[0][0], v[0][1], v[1][0], v[1][1]);\n        L l2(v[2][0], v[2][1], v[3][0], v[3][1]);\n        cout << intersectSS(l1, l2) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nconst double EPS = 1e-10;\nstruct Vec2 {\n  double x;\n  double y;\n\n  Vec2() : x(0.0),y(0.0){} \n  Vec2(double _x,double _y) :x(_x),y(_y){}  \n  \n  Vec2 operator+(const Vec2& other) const { return { x + other.x , y + other.y }; }\n  Vec2 operator-(const Vec2& other) const { return { x - other.x , y - other.y }; }\n  bool operator==(const Vec2& other) const { return (abs(x - other.x) < EPS && abs(y - other.y) < EPS ); } \n  bool operator<(const Vec2& other) const { if(abs(x - other.x) < EPS) return y < other.y; else return x < other.x; }\n \n  double dot(const Vec2& other) const { return x * other.x + y * other.y; }\n  double cross(const Vec2& other) const { return x * other.y - y * other.x; }\n  double length() const { return sqrt(x * x + y * y); }\n\n  void Show() { printf(\"%.8f %.8f\\n\", x, y); }\n};\n\nstruct Line {\n  Vec2 s; // 始点\n  Vec2 t; // 終点\n\n  Line() : s({0, 0}), t({0, 0}) {}\n  Line(Vec2 s, Vec2 t) : s(s), t(t) {}\n\n  Vec2 V() { return t - s; }\n  double dot(const Line &other) const { return (t - s).dot(other.t - other.s); }\n  double cross(const Line &other) const { return (t - s).cross(other.t - other.s); }\n  double length() const { return (t - s).length(); }  \n};\n// A とB のなす角θ cosθ, sinθ を返す\ndouble Cos(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.dot(B) / (A.length()*B.length());\n}\ndouble Sin(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.cross(B) / (A.length()*B.length());\n}\n// 線分ABをB方向に長さlに延長する\nLine ExpandB(const Line &AB, const double &l) {\n  Line v(Vec2(0,0), Vec2(1,0));\n  Vec2 d(l * Cos(v, AB), l * Sin(v, AB));\n  return Line(AB.s, AB.s + d);\n}\n\n// 直線ABと点Cの距離\ndouble DistLinePoint(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  return AC.length() * abs(Sin(AB, AC));\n}\n// 直線AB上に点Cを射影した点\nVec2 Proj(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  double l = AC.length() * Cos(AB, AC);\n  Line res = ExpandB(AB, l);\n  return res.t;\n}\n// 線分の交差判定\nbool CrossCheck(const Line &AB, const Line &CD) {\n  //  if(a == c || a == d || b == c || b == d) return true; // 端点が等しい場合はtrue\n  Line AC(AB.s, CD.s), AD(AB.s, CD.t);\n  Line BC(AB.t, CD.s), BD(AB.t, CD.t);\n  Line CA(CD.s, AB.s), CB(CD.s, AB.t);\n  Line DA(CD.t, AB.s), DB(CD.t, AB.t);\n  double s = AB.cross(AC) * AB.cross(AD);\n  double t = CD.cross(CA) * CD.cross(CB);\n\n  if(abs(Sin(AB, CD)) < EPS) { // 平行のとき\n    if(abs(Sin(AB, AC)) < EPS) { // 同一直線上にあるか？\n      return (CA.dot(CB) < EPS || DA.dot(DB) < EPS || AC.dot(AD) < EPS || BC.dot(BD) < EPS);\n    }\n    else return false;\n  }\n  else return s < EPS && t < EPS;\n}\n\nint main()\n{\n  int q; cin >> q;\n  while(q-- > 0) {\n    Vec2 A,B,C,D; cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> D.x >> D.y;\n    Line AB(A, B), CD(C, D);\n    if(CrossCheck(AB, CD)) cout << 1 << \"\\n\";\n    else cout << 0 << \"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<min(x[3],x[4])||min(x[1],x[2])>max(x[3],x[4])||max(y[1],y[2])<min(y[3],y[4])||min(y[1],y[2])>max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<=0&&p3*p4<=0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nstring ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return \"COUNTER_CLOCKWISE\";\n  if(cross(d,e)<0) return \"CLOCKWISE\";\n  if(dot(d,e)<0) return \"ONLINE_BACK\";\n  if(abs(d) < abs(e)) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = ((c-d)/abs(c-d))*(abs(c-d)*abs(d.y))/(d.y-c.y)+d;\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nclass Point {\npublic:\n  ld x, y;\n\n  Point() {}\n  Point(ld x, ld y): x(x), y(y) {}\n\n  Point operator + (const Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n  Point operator - (const Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n  Point operator * (const ld k) {\n    return Point(x * k, y * k);\n  }\n  Point operator / (const ld k) {\n    return Point(x / k, y / k);\n  }\n  Point operator += (const Point &p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n  Point operator -= (const Point &p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n  Point operator *= (const ld k) {\n    x *= k;\n    y *= k;\n    return *this;\n  }\n  Point operator /= (const ld k) {\n    x /= k;\n    y /= k;\n    return *this;\n  }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n  friend ostream& operator << (ostream &os, const Point &p) {\n    os << p.x << ' ' << p.y;\n    return os;\n  }\n  friend istream& operator >> (istream &is, Point &p) {\n    ld x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n  }\n\n  ld abs() {return sqrt(norm());}\n  ld norm() {return x * x + y * y;}\n};\n\nld dot(Point a, Point b) {\n  return a.x * b.x + a.y * b.y;\n}\n\nld cross(Point a, Point b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n  Point p1, p2;\n\n  Segment() {}\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n\n  friend ostream& operator << (ostream &os, const Segment &s) {\n    os << s.p1 << ' ' << s.p2;\n    return os;\n  }\n  friend istream& operator >> (istream &is, Segment &s) {\n    Point p1, p2;\n    is >> p1 >> p2;\n    s = Segment(p1, p2);\n    return is;\n  }\n};\n\n//線分sに対する点pの射影\nPoint project(Segment s, Point p) {\n  Point base = s.p2 - s.p1;\n  ld r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\n//線分sを対称軸とした点pの線対象の点\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2;\n}\n\n//反時計回り:1\n//時計回り:-1\n//p2, p0, p1:2\n//p0, p1, p2:-2\n//p0, p2, p1:0\nint ccw(Point p0, Point p1, Point p2) {\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if (cross(a, b) > EPS) return 1;\n  if (cross(a, b) < -EPS) return -1;\n  if (dot(a, b) < -EPS) return 2;\n  if (a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//直線lと点pの距離\nld getDistanceLP(Segment l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\n//線分sと点pの距離\nld getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n  return getDistanceLP(s, p);\n}\n\n\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n\n  Circle() {}\n  Circle(Point p, ld r): p(p), r(r) {}\n};\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  Segment s[2];\n  int q;\n  cin >> q;\n  while (q--) {\n    cin >> s[0] >> s[1];\n    cout << intersect(s[0], s[1]) << '\\n';\n  }\n\n\n  \n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n\n    \n    if(a1*b2==a2*b1)return false;//平行の判定\n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    if(a*x1+b*y1+c==0){//(x1,y1)が直線上にある.\n        *x2=x1;\n        *y2=y1;\n        return;\n    }\n    \n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    //cout<<a1<<\" \"<<b1<<\" \"<<c1<<endl;\n    //cout<<a2<<\" \"<<b2<<\" \"<<c2<<endl;\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1*c2)==(c1*b2)) || (b1==0 && (a1*c2)==(c1*a2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return /*2*M_PI- */ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    \n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    if(x1==x2&&y1==y2)return 0.0;\n    if(x3==x2&&y3==y2)return 0.0;\n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    double ret = 2*M_PI-( angle+(M_PI-angle2) );\n    if(ret<0)ret+=2*M_PI;\n    if(ret>=2*M_PI)ret-=2*M_PI;\n    \n    \n    \n    return ret;\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用前に sort(a, a+n); をおこなう*/\n/*使用注意 他と仕様が違う*/\n/*点にpairを使っている*/\n\n\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double> >b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n//-------------------------------------------------------------------------------------\n/* 2点(x1,y1) (x2,y2)を通る直線に点(px,py)から引いた垂線の直線との交点(x, y)を返す */\nvoid intersection_of_the_normal_to_the_straight_line_passing_through_the_two_points(double px,double py,double x1, double y1,double x2, double y2,double *x, double *y){\n    double a,b,c;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    *x = px-(a*px+b*py+c)/(a*a+b*b)*a;\n    *y = py-(a*px+b*py+c)/(a*a+b*b)*b;\n}\n                                      \nint main(){\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    double a,b,c,d,e,f;\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        //straight_line_passing_through_the_two_points(x0, y0, x1, y1, &a, &b, &c);\n        //straight_line_passing_through_the_two_points(x2, y2, x3, y3, &d, &e, &f);\n        cout<<line_segment_cross_decision(x0, y0, x1, y1, x2, y2, x3, y3)<<endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n};\nT norm(P a){return a*a;}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nbool isSSr(const L&a,const L&b){ // seg x seg restrict\n  T c1=(a.t-a.s)/(b.s-a.s) , c2=(a.t-a.s)/(b.t-a.s),\n    c3=(b.t-b.s)/(a.s-b.s) , c4=(b.t-b.s)/(a.t-b.s);\n  return sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0;\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n  T c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n  T c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n  return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n    sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n    sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n    sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n    sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\n\nP a, b, c, d;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n\tint q;\n\tcin >> q;\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\twhile(q--) {\n\t\tcin >> a.x >> a.y >> b.x >> b.y;\n\t\tcin >> c.x >> c.y >> d.x >> d.y;\n\t\tL x = L(a, b), y = L(c, d);\n\t\tcout << isSS(x, y) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\ntypedef struct _PT {\n  double x, y;\n  _PT() {}\n  _PT(double x, double y) : x(x), y(y) {} \n  _PT operator + (_PT p){\n     return _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n     return _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (double d){\n     return _PT(d*x, d*y);\n  }\n\n  double norm(void){\n    return sqrt(x*x + y*y);\n  }\n\n  double twiceNorm(void){\n    return x*x + y*y;\n  }\n\n  double dist(_PT p){ //pとの距離の2乗\n     return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n     return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n     return x == e.x? (y > e.y) : x > e.x;\n  }\n\n  double dot(_PT p){ //pとの内積\n     return x * p.x + y * p.y;\n  }\n  \n  double det(_PT p){ // (x,p)の外積\n     return x * p.y - p.x * y;\n  }\n}P;\n\nP intersection(P p1,P p2,P q1,P q2) { //線分 p1-p2とq1-q2の交点\n  \treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool on_seq(P p1,P p2,P q) { // 線分p1-p2上に点qがあるか\n    return (abs((p1 - q).det(p2 - q)) < eps) && ((p1 - q).dot(p2 - q) < eps);\n}\n\nint main(void) {\n\tlong N;\n\tcin >> N;\n\tREP(i,N) {\n\t\tP p1,p2,q1,q2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> q1.x >> q1.y >> q2.x >> q2.y;\n\t\tif (abs((p1-p2).det(q1-q2)) > eps) {\n\t\t\tP r = intersection(p1,p2,q1,q2);\n\t\t\tif (on_seq(p1,p2,r)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t\telse cout << \"0\" << endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\n\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\n\n\nint main(){\n    \tint q;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tline l1,l2;\n\t\tl1.input();\n\t\tl2.input();\n\t\tif(intersect(l1,l2) ){\n\t\t\tcout<<1<<endl;\n\t\t}else{\n\t\t\tcout<<0<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :\n\t\t\tx(x), y(y) {\n\t}\n\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n};\n\nclass Segment {\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\ndouble dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\ndouble cross(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ON_SEGMENT = 0;\nstatic const int ONLINE_FRONT = -2;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\tif (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\tif (a.norm() < b.norm())\n\t\treturn ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\nint main() {\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\", &p1x, &p1y, &p2x, &p2y, &p3x, &p3y, &p4x, &p4y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tPoint p3(p3x, p3y);\n\t\tPoint p4(p4x, p4y);\n\n\t\tif (intersect(p1, p2, p3, p4)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=105,INF=1<<30;\n\nconst double eps=1e-10;\nconst long double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r-c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(int(s.size())<3) return s;\n    sort(all(s));\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    for(int i=2;i<n;i++){\n        for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    \n    for(int i=int(s.size())-3;i>=0;i--){\n        for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        Segment s1,s2;\n        cin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y>>s2.p1.x>>s2.p1.y>>s2.p2.x>>s2.p2.y;\n        cout<<intersect(s1,s2)<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < -EPS) return 2;\n  if(abs(b-a) < abs(c-a) - EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\nint main(){\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i){\n    P points[4];\n    for(int j = 0; j < 4; ++j){\n      double x, y;\n      cin >> x >> y;\n      points[j] = P(x, y);\n    }\n    L l1 = L(points[0], points[1]), l2 = L(points[2], points[3]);\n    if(is_cross(l1, l2)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n        if ((z2 * conj(z1)).imag() * (z3 * conj(z1)).imag() <= 0\n            && (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() <= 0)\n            cout << \"1\\n\";\n        else cout << \"0\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double lf;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 5;\nconst int MOD = 1e9+7;\n\nconst lf eps = 1e-9;\ntypedef double T;\nstruct pt {\n  T x, y;\n  pt operator + (pt p) { return {x+p.x, y+p.y}; }\n  pt operator - (pt p) { return {x-p.x, y-p.y}; }\n  pt operator * (pt p) { return {x*p.x-y*p.y, x*p.y+y*p.x}; }\n  pt operator * (T d) { return {x*d, y*d}; }\n  pt operator / (T d) { return {x/d, y/d}; } /// only for floating point\n  bool operator == (pt b) { return x == b.x && y == b.y; }\n  bool operator != (pt b) { return !(*this == b); }\n  bool operator < (const pt &o) const { return y < o.y || (y == o.y && x < o.x); }\n  bool operator > (const pt &o) const { return y > o.y || (y == o.y && x > o.x); }\n};\nint cmp (lf a, lf b) { return (a + eps < b ? -1 :(b + eps < a ? 1 : 0)); }\n/** Already in complex **/\nT norm(pt a) { return a.x*a.x + a.y*a.y; }\nT abs(pt a) { return sqrt(norm(a)); }\nT arg(pt a) { return atan2(a.y, a.x); }\nostream& operator << (ostream& os, pt &p) {\n  return os << \"(\"<< p.x << \",\" << p.y << \")\";\n}\n/***/\nistream &operator >> (istream &in, pt &p) {\n    T x, y; in >> x >> y;\n    p = {x, y};\n    return in;\n}\nT dot(pt a, pt b) { return a.x*b.x + a.y*b.y; }\nT cross(pt a, pt b) { return a.x*b.y - a.y*b.x; }\nT orient(pt a, pt b, pt c) { return cross(b-a,c-a); }\n//pt rot(pt p, lf a) { return {p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a)}; }\n//pt rot(pt p, double a) { return p * polar(1.0, a); } /// for complex\n//pt rotate_to_b(pt a, pt b, lf ang) { return rot(a-b, ang)+b; }\npt rot90ccw(pt p) { return {-p.y, p.x}; }\npt rot90cw(pt p) { return {p.y, -p.x}; }\npt translate(pt p, pt v) { return p+v; }\npt scale(pt p, double f, pt c) { return c + (p-c)*f; }\nbool are_perp(pt v, pt w) { return dot(v,w) == 0; }\nint sign(T x) { return (T(0) < x) - (x < T(0)); }\npt unit(pt a) { return a/abs(a); }\n\nbool in_angle(pt a, pt b, pt c, pt x) {\n  assert(orient(a,b,c) != 0);\n  if (orient(a,b,c) < 0) swap(b,c);\n  return orient(a,b,x) >= 0 && orient(a,c,x) <= 0;\n}\n\n//lf angle(pt a, pt b) { return acos(max(-1.0, min(1.0, dot(a,b)/abs(a)/abs(b)))); }\n//lf angle(pt a, pt b) { return atan2(cross(a, b), dot(a, b)); }\n/// returns vector to transform points\npt get_linear_transformation(pt p, pt q, pt r, pt fp, pt fq) {\n  pt pq = q-p, num{cross(pq, fq-fp), dot(pq, fq-fp)};\n  return fp + pt{cross(r-p, num), dot(r-p, num)} / norm(pq);\n}\n\nbool half(pt p) { /// true if is in (0, 180]\n  assert(p.x != 0 || p.y != 0); /// the argument of (0,0) is undefined\n  return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nbool half_from(pt p, pt v = {1, 0}) {\n  return cross(v,p) < 0 || (cross(v,p) == 0 && dot(v,p) < 0);\n}\nbool polar_cmp(const pt &a, const pt &b) {\n  return make_tuple(half(a), 0) < make_tuple(half(b), cross(a,b));\n}\n\nstruct line {\n  pt v; T c;\n  line(pt v, T c) : v(v), c(c) {}\n  line(T a, T b, T c) : v({b,-a}), c(c) {}\n  line(pt p, pt q) : v(q-p), c(cross(v,p)) {}\n  T side(pt p) { return cross(v,p)-c; }\n  lf dist(pt p) { return abs(side(p)) / abs(v); }\n  lf sq_dist(pt p) { return side(p)*side(p) / (lf)norm(v); }\n  line perp_through(pt p) { return {p, p + rot90ccw(v)}; }\n  bool cmp_proj(pt p, pt q) { return dot(v,p) < dot(v,q); }\n  line translate(pt t) { return {v, c + cross(v,t)}; }\n  line shift_left(double d) { return {v, c + d*abs(v)}; }\n  pt proj(pt p) { return p - rot90ccw(v)*side(p)/norm(v); }\n  pt refl(pt p) { return p - rot90ccw(v)*2*side(p)/norm(v); }\n};\n\nbool inter_ll(line l1, line l2, pt &out) {\n  T d = cross(l1.v, l2.v);\n  if (d == 0) return false;\n  out = (l2.v*l1.c - l1.v*l2.c) / d;\n  return true;\n}\n/*line bisector(line l1, line l2, bool interior) {\n  assert(cross(l1.v, l2.v) != 0); /// l1 and l2 cannot be parallel!\n  lf sign = interior ? 1 : -1;\n  return {l2.v/abs(l2.v) + l1.v/abs(l1.v) * sign,\n          l2.c/abs(l2.v) + l1.c/abs(l1.v) * sign};\n}*/\n\nbool in_disk(pt a, pt b, pt p) {\n  return dot(a-p, b-p) <= 0;\n}\nbool on_segment(pt a, pt b, pt p) {\n  return orient(a,b,p) == 0 && in_disk(a,b,p);\n}\nbool proper_inter(pt a, pt b, pt c, pt d, pt &out) {\n  T oa = orient(c,d,a),\n  ob = orient(c,d,b),\n  oc = orient(a,b,c),\n  od = orient(a,b,d);\n  /// Proper intersection exists iff opposite signs\n  if (oa*ob < 0 && oc*od < 0) {\n    out = (a*ob - b*oa) / (ob-oa);\n    return true;\n  }\n  return false;\n}\nset<pt> inter_ss(pt a, pt b, pt c, pt d) {\n  pt out;\n  if (proper_inter(a,b,c,d,out)) return {out};\n  set<pt> s;\n  if (on_segment(c,d,a)) s.insert(a);\n  if (on_segment(c,d,b)) s.insert(b);\n  if (on_segment(a,b,c)) s.insert(c);\n  if (on_segment(a,b,d)) s.insert(d);\n  return s;\n}\nlf pt_to_seg(pt a, pt b, pt p) {\n  if(a != b) {\n    line l(a,b);\n    if (l.cmp_proj(a,p) && l.cmp_proj(p,b)) /// if closest to  projection\n      return l.dist(p); /// output distance to line\n  }\n  return min(abs(p-a), abs(p-b)); /// otherwise distance to A or B\n}\nlf seg_to_seg(pt a, pt b, pt c, pt d) {\n  pt dummy;\n  if (proper_inter(a,b,c,d,dummy)) return 0;\n  return min({pt_to_seg(a,b,c), pt_to_seg(a,b,d),\n              pt_to_seg(c,d,a), pt_to_seg(c,d,b)});\n}\n\nenum {IN, OUT, ON};\nstruct polygon {\n  vector<pt> p;\n  polygon(int n) : p(n) {}\n  int top = -1, bottom = -1;\n  void delete_repetead() {\n    vector<pt> aux;\n    sort(p.begin(), p.end());\n    for(pt &i : p)\n      if(aux.empty() || aux.back() != i)\n        aux.push_back(i);\n    p.swap(aux);\n  }\n  bool is_convex() {\n    bool pos = 0, neg = 0;\n    for (int i = 0, n = p.size(); i < n; i++) {\n      int o = orient(p[i], p[(i+1)%n], p[(i+2)%n]);\n      if (o > 0) pos = 1;\n      if (o < 0) neg = 1;\n    }\n    return !(pos && neg);\n  }\n  lf area() {\n    lf ans = 0;\n    for (int i = 0, n = p.size(); i < n; i++)\n      ans += cross(p[i], p[(i+1)%n]);\n    return abs(ans) / 2.0;\n  }\n  lf perimeter() {\n    lf per = 0;\n    for(int i = 0, n = p.size(); i < n; i++)\n      per += abs(p[i] - p[(i+1)%n]);\n    return per;\n  }\n  bool above(pt a, pt p) { return p.y >= a.y; }\n  bool crosses_ray(pt a, pt p, pt q) {\n    return (above(a,q)-above(a,p))*orient(a,p,q) > 0;\n  }\n  int in_polygon(pt a) {\n    int crosses = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      if(on_segment(p[i], p[(i+1)%n], a)) return ON;\n      crosses += crosses_ray(a, p[i], p[(i+1)%n]);\n    }\n    return (crosses&1 ? IN : OUT);\n  }\n  void normalize() { /// polygon is CCW\n    bottom = min_element(p.begin(), p.end()) - p.begin();\n    vector<pt> tmp(p.begin()+bottom, p.end());\n    tmp.insert(tmp.end(), p.begin(), p.begin()+bottom);\n    p.swap(tmp);\n    bottom = 0;\n    top = max_element(p.begin(), p.end()) - p.begin();\n  }\n  int in_convex(pt a) {\n    assert(bottom == 0 && top != -1);\n    if(a < p[0] || a > p[top]) return OUT;\n    T orientation = orient(p[0], p[top], a);\n    if(orientation == 0) {\n      if(a == p[0] || a == p[top]) return ON;\n      return top == 1 || top + 1 == p.size() ? ON : IN;\n    } else if (orientation < 0) {\n      auto it = lower_bound(p.begin()+1, p.begin()+top, a);\n      T d = orient(*prev(it), a, *it);\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n    else {\n      auto it = upper_bound(p.rbegin(), p.rend()-top-1, a);\n      T d = orient(*it, a, it == p.rbegin() ? p[0] : *prev(it));\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n  }\n  polygon cut(pt a, pt b) {\n    line l(a, b);\n    polygon new_polygon(0);\n    for(int i = 0, n = p.size(); i < n; ++i) {\n      pt c = p[i], d = p[(i+1)%n];\n      lf abc = cross(b-a, c-a), abd = cross(b-a, d-a);\n      if(abc >= 0) new_polygon.p.push_back(c);\n      if(abc*abd < 0) {\n        pt out; inter_ll(l, line(c, d), out);\n        new_polygon.p.push_back(out);\n      }\n    }\n    return new_polygon;\n  }\n  void convex_hull() {\n    sort(p.begin(), p.end());\n    vector<pt> ch;\n    ch.reserve(p.size()+1);\n    for(int it = 0; it < 2; it++) {\n      int start = ch.size();\n      for(auto &a : p) {\n        /// if colineal are needed, use < and remove repeated points\n        while(ch.size() >= start+2 && orient(ch[ch.size()-2], ch.back(), a) <= 0)\n          ch.pop_back();\n        ch.push_back(a);\n      }\n      ch.pop_back();\n      reverse(p.begin(), p.end());\n    }\n    if(ch.size() == 2 && ch[0] == ch[1]) ch.pop_back();\n    /// be careful with CH of size < 3\n    p.swap(ch);\n  }\n  ll pick() {\n    ll boundary = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      int j = (i+1 == n ? 0 : i+1);\n      boundary += __gcd((ll)abs(p[i].x - p[j].x), (ll)abs(p[i].y - p[j].y));\n    }\n    return area() + 1 - boundary/2;\n  }\n  pt& operator[] (int i){ return p[i]; }\n};\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  #ifdef LOCAL\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n  #else\n      #define endl '\\n'\n  #endif // LOCAL\n\n  int q; cin >> q;\n  cout << fixed << setprecision(10);\n  while(q--) {\n    pt a, b, c, d; cin >> a >> b >> c >> d;\n    int ans = inter_ss(a, b, c, d).size();\n    ans = min(1, ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\telse return x < p.x;\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(),double r = 0.0): c(c),r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n\treturn a.x * b.y - b.x * a.y;\n}\nbool vertical(Line l1,Line l2){\n\treturn abs(dot(l1.p2 - l1.p1,l2.p2 - l2.p1)) < EPS;\n}\nbool parallel(Line l1,Line l2){\n\treturn abs(det(l1.p2 - l1.p1,l2.p2 - l2.p1)) < EPS;\n}\nPoint proj(Point p,Line l){\n\tVector a = l.p2 - l.p1;\n\tdouble r = dot(a,p - l.p1) / a.norm();\n\treturn l.p1 + a * r;\n}\nPoint ref(Point p,Line l){\n\tPoint A = proj(p,l);\n\treturn A + (A - p);\n}\nint ccw(Segment/*Directed Segment*/ s,Point p){//\n\tVector a = s.p2 - s.p1,b = p - s.p1;\n\tif(det(a,b) > EPS) return 1;\n\telse if(det(a,b) < -EPS) return -1;\n\telse if(dot(a,b) < -EPS) return 2;\n\telse if(a.norm() < b.norm() - EPS) return -2;\n\telse return 0;\n}\nbool intersect(Segment s1,Segment s2){\n\treturn ccw(s1,s2.p1) * ccw(s1,s2.p2) <= 0 && ccw(s2,s1.p1) * ccw(s2,s1.p2) <= 0;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tSegment s1,s2;\n\t\tscanf(\"%lf%lf%lf%lf\",&s1.p1.x,&s1.p1.y,&s1.p2.x,&s1.p2.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&s2.p1.x,&s2.p1.y,&s2.p2.x,&s2.p2.y);\n\t\tprintf(\"%d\\n\",(int)intersect(s1,s2));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{\n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;\n  }\n  double dot(Point p){return x*p.x+y*p.y;}\n  double det(Point p){return x*p.y-y*p.x;}\n};\nstruct Line{\n  Point p1,p2;\n  Line(){}\n  Line(Point p1, Point p2):p1(p1),p2(p2){}\n};\nint ccw(Point a,Point b,Point c){\n  Point t1=b-a,t2=c-a;\n  if(t1.det(t2)> eps) return 1;//counter clockwise\n  if(t1.det(t2)< -eps) return -1;//clockwise\n  if(t1.dot(t2)< -eps) return 2;//c-a-b online\n  if(t1.norm()<t2.norm()) return -2;//a-b-c online\n  return 0;//a-c-b online\n}\nbool intersectSS(Point a,Point b,Point c,Point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\nbool intersectSS(Line l1,Line l2){\n  return intersectSS(l1.p1,l1.p2,l2.p1,l2.p2);\n}\nbool isOrthogonal(Point a,Point b){\n  return fabs(a.dot(b))<eps;\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\nbool isParallel(Point a,Point b){\n  return fabs(a.det(b))<eps;\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nPoint CrossPoint(Line l1,Line l2){\n    double a=(l1.p2-l1.p1).det(l2.p2-l2.p1);\n    double b=(l1.p2-l1.p1).det(l1.p2-l2.p1);\n    if(fabs(a)<eps&&fabs(b)<eps) return l2.p1;\n    return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\nPoint project(Line l,Point p){\n  Point base=l.p2-l.p1;\n  double r=(p-l.p1).dot(base)/base.norm();\n  return l.p1+base*r;\n}\nPoint reflect(Line l,Point p){\n  return p+(project(l,p)-p)*2.0;\n}\nint main(){\n    int q;\n    double xp0,yp0,xp1,yp1,xp2,yp2,xp3,yp3;\n    cin>>q;\n    while(q--){\n        cin>>xp0>>yp0>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3;\n        Point p0(xp0,yp0),p1(xp1,yp1),p2(xp2,yp2),p3(xp3,yp3);\n        if(intersectSS(p0,p1,p2,p3)) cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\ntypedef long double ld;\nconst ld global_eps=1e-8;\n#if 0\nenum cases{insi,bord,outs};//inside, border, outside\nenum cases{para,coin,inte};//parallel, coincide, intersect\n#else\nenum Case\n{\n    insi,bord,outs,//inside, border, outside\n    para,coin,inte, //parallel, coincide, intersect\n    tang,tang_in,tang_out //tangent\n};\n#endif\nint sign(ld x,ld eps=global_eps){return (x>=eps)-(x<=-eps);}\nint cmp(ld a,ld b,ld eps=global_eps){return sign(a-b,eps);}\nstruct Point\n{\n    ld x,y;\n    Point():x(0),y(0){}\n    Point(ld _x,ld _y):x(_x),y(_y){}\n    Point operator +(const Point &p) const\n    {return Point(x+p.x,y+p.y);}\n    Point operator -(const Point &p) const\n    {return Point(x-p.x,y-p.y);}\n    ld operator *(const Point &p) const\n    {return x*p.x+y*p.y;}\n    ld operator %(const Point &p) const\n    {return x*p.y-y*p.x;}   \n    bool operator <(const Point &p) const\n    {return tie(y,x) < tie(p.y,p.x);}\n    bool operator ==(const Point &p) const\n    {return tie(y,x) == tie(p.y,p.x);}\n    Point operator /(const ld &l) const\n    {return Point(x/l,y/l);}\n    Point operator *(const ld &l) const\n    {return Point(x*l,y*l);}\n    ld len() const{return hypot(x,y);}\n    ld len2() const{return x*x+y*y;}\n    ld dis(const Point &a)const{return (*this-a).len();}\n    ld dis2(const Point &a)const{return (*this-a).len2();}\n    Point unit()const{return *this/len();}\n    Point resize(const ld &l)const{return unit()*l;}\n};\nstruct Line\n{\n    Point p1,p2;\n    Line(){}\n    Line(Point a,Point b):p1(a),p2(b){}\n    Point way() const{return p2-p1;}\n    Point norm() const{return {p1.y-p2.y,p2.x-p1.x};}\n    bool online(const Point &p) const{return sign((p-p1)%way())==0;}\n    bool onsegment(const Point &p)const\n    {\n        return online(p) && sign((p-p1)*(p2-p))>=0;\n    }\n    pair<int,Point> intersect(const Line &I) const\n    {\n        if(sign(I.way()%way())==0) return {online(I.p1)?coin:para,{0,0}};\n        const Point &p3=I.p1,&p4=I.p2;\n        auto _143=(p1-p4)%(p4-p3),_342=(p3-p4)%(p4-p2);\n        return {inte,(p1*_342+p2*_143)/(_143+_342)};\n    }\n    ld linedistance(const Point &p) const\n    {\n        return abs((p-p1)%way())/way().len();\n    }\n    Point project(const Point &p) const\n    {\n        return intersect(Line(p,p+norm())).second;\n    }\n    ld segmentdistance(const Point &p) const\n    {\n        const auto &pro=project(p);\n        if(onsegment(pro)) return p.dis(pro);\n        return min(p.dis(p1),p.dis(p2));\n    }\n};\nint main()\n{\n    int t;RI(t);\n    while(t--)\n    {\n        Point p[4];\n        REP(i,4) cin>>p[i].x>>p[i].y;\n        Line I(p[0],p[1]),J(p[2],p[3]);\n        auto ans=I.intersect(J);\n        if(ans.F==para) PL(0);\n        else if(ans.F==coin)\n        {\n            bool ok=0;\n            REP(i,4) ok|=(i<2?J:I).onsegment(p[i]);\n            if(ok) PL(1);\n            else PL(0);\n        }\n        else if(I.onsegment(ans.S) && J.onsegment(ans.S)) PL(1);\n        else PL(0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\nconst double inf = 1e20;\ninline double sqr (double k) {return k * k;}\ninline int sgn (double p) {\n    if (fabs (p) < eps) return 0;\n    if (p < 0) return -1;\n    return 1;\n}\nstruct point {\n    double x, y;\n    point (){}\n    point (double _x, double _y) {\n        x = _x, y = _y;\n    }\n    void input () {\n        scanf (\"%lf %lf\", &x, &y);\n    }\n    bool operator == (point b) const {\n        return sgn (x - b.x) == 0 && sgn (y - b.y) == 0;\n    }\n    point operator - (const point &b) const {\n        return point (x - b.x, y - b.y);\n    }\n    double operator * (const point &b) const {\n        return x * b.x + y * b.y;\n    }\n    double operator ^ (const point &b) const {\n        return x * b.y - y * b.x;\n    }\n    double len () {\n        return hypot (x, y);\n    }\n    double len2 () {\n        return x * x + y * y;\n    }\n    double distance (point p) {\n        return hypot (x - p.x, y - p.y);\n    }\n    point operator + (const point &b) const{\n        return point (x + b.x, y + b.y);\n    }\n    point operator * (const double &b) const {\n        return point (x * b, y * b);\n    }\n    point operator / (const double &b) const {\n        return point (x / b, y / b);\n    }\n    double cross (point a, point b) {\n        return (a - *this) ^ (b - *this);\n    }\n    double dot (point a, point b) {\n        return (a - *this) * (b - *this);\n    }\n    bool on_seg (point a, point b) {\n        return sgn (cross (a, b)) == 0 && dot (a, b) <= 0;\n    }\n};\nbool seg (point a, point b, point c, point d) {\n    if (a.on_seg (c, d) || b.on_seg (c, d) || c.on_seg (a, b) || d.on_seg (a, b)) return true;\n    if (a.cross (b, d) * a.cross (b, c) < 0 && c.cross (d, b) * c.cross (d, a) < 0) return true;\n    return false;\n}\nint main () {\n//    freopen (\"in.txt\", \"r\", stdin);\n    int Q;\n    cin >> Q;\n    while (Q --) {\n        int flag1 = 0, flag2 = 0, ans;\n        double u, k;\n        point s1, e1, s2, e2, a, b, c;\n        s1.input (), e1.input ();\n        s2.input (), e2.input ();\n        if (seg (s1, e1, s2, e2)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nbool check(double d,int a,int b){\n\treturn ((d<=a&&d>=b)||(d>=a&&d<=b));\n}\n\n\t\nint main(){\n\tint q;\n\tint ans[1000];\n\tint x0,x1,x2,x3,y0,y1,y2,y3;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tans[i]=0;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tif(x1==x0){\n\t\t\tdouble k=(y3-y2)/(x3-x2);\n\t\t\tdouble d=k*(x0-x3)+y3; //?????????y??§?¨?\n\t\t\tif(check(d,y1,y0)){\n\t\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\t else if(x2==x3){\n\t\t\t  double t=(y1-y0)/(x1-x0);\n\t\t\t  double e=t*(x2-x1)+y1; //?????????y??§?¨?\n\t\t\t  if(check(e,y2,y3)){\n\t\t\t  \tans[i]=1;\n\t\t\t  }\n\t\t\t }\n\t\telse if(x1!=x0&&x3!=x2){\n\t\tdouble t=(y1-y0)/(x1-x0);\n\t\tdouble k=(y3-y2)/(x3-x2);\n\t\tif(t!=k){\n\t\tdouble c=(t*x1+y1-k*x3+y3)/(t-k); //?????????x??§?¨?\n\t\tif(check(c,x2,x3)&&check(c,x0,x1)){\n\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef double db;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nnamespace Geometry{\n\tconst db eps = 1e-9;\n\tstruct point{\n\t\tdb x,y;\n\t\tinline point operator + (const point &p){return (point){x+p.x,y+p.y};}\n\t\tinline point operator - (const point &p){return (point){x-p.x,y-p.y};}\n\t\tinline db operator * (const point &p){return x*p.x+y*p.y;}\n\t\tinline point operator / (const db &v){return (point){x/v,y/v};}\n\t\tinline point operator * (const db &v){return (point){x*v,y*v};}\n\t};\n\ttypedef point vec;\n\tinline db dot(vec a,vec b){return a.x*b.x+a.y*b.y;}\n\tinline db sqr(db x){return x*x;}\n\tinline db dis(point a,point b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}\n\tinline db dis2(point a,point b){return sqr(a.x-b.x)+sqr(a.y-b.y);}\n\tinline db cross(vec a,vec b){return a.x*b.y-a.y*b.x;}\n\tstruct line{\n\t\tpoint a,b;\n\t};\n\tinline point projection(point A,line b){\n\t\tpoint B=b.a,C=b.b;\n\t\tvec BA=A-B,BC=C-B,BD=BC*(BA*BC/dis2(B,C));\n\t\treturn B+BD;\n\t}\n\tinline point reflection(point A,line b){\n\t\tpoint D=projection(A,b);\n\t\treturn (point){D.x*2-A.x,D.y*2-A.y};\n\t}\n\tinline int Counter_Clockwise(point A,line b){\n\t\tpoint B=b.a,C=b.b;\n\t\tdb f1=cross(C-B,A-B);\n\t\tif (fabs(f1)>eps) return (f1<0?2:1);\n\t\tdb f2=(C-B)*(A-B);\n\t\tif (f2<0) return 3;\n\t\treturn dis(B,C)<dis(A,B)?4:5;\n\t}\n\tinline int checkline(line a,line b){\n\t\tvec A=a.b-a.a,B=b.b-b.a;\n\t\tdb f1=A*B;\n\t\tif (fabs(f1)<=eps) return 1;\n\t\treturn dis(a.a,a.b)*dis(b.a,b.b)-fabs(f1)<=eps?2:0;\n\t}\n\tinline int checkseg(line a,line b){\n\t\tpoint A=a.a,B=a.b,C=b.a,D=b.b;\n\t\tif (max(A.x,B.x)<min(C.x,D.x)) return 0;\n\t\tif (min(A.x,B.x)>max(C.x,D.x)) return 0;\n\t\tif (max(A.y,B.y)<min(C.y,D.y)) return 0;\n\t\tif (min(A.y,B.y)>max(C.y,D.y)) return 0;\n\t\tdb s=cross(B-A,C-A),h=cross(B-A,D-A);\n\t\tif (s*h>=eps) return 0;\n\t\tdb i=cross(D-C,A-C),t=cross(D-C,B-C);\n\t\treturn i*t<=eps;\n\t}\n};\nusing namespace Geometry;\n\nint main(){\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tint T;scanf(\"%d\",&T);\n\twhile (T--){\n\t\tline a;scanf(\"%lf%lf%lf%lf\",&a.a.x,&a.a.y,&a.b.x,&a.b.y);\n\t\tline b;scanf(\"%lf%lf%lf%lf\",&b.a.x,&b.a.y,&b.b.x,&b.b.y);\n\t\tprintf(\"%d\\n\",checkseg(a,b));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// 平面幾何\n\n// 型変換\n//   double  -> Point\n//   Segment -> Line\n\n////////////////////\n// ライブラリ\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// 定数\nconst double EPS = 1e-9;\n////////////////////\n// 構造体\nstruct Point {\n  double x, y;\n  Point(const double d = 0.0) :x(d), y(d) {}\n  Point(const double x, const double y) :x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial = 0, const Point& terminal = 0) :initial(initial), terminal(terminal) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial = 0, const Point& terminal = 0) :initial(initial), terminal(terminal) {}\n  Line(const Segment& s) :initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// 実装\n// bool operator==(const Point& lhs, const Point& rhs) {return lhs.x == rhs.x && lhs.y == rhs.y;}\n// bool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}\n// bool operator>(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x > rhs.x : lhs.y > rhs.y;}\n// bool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\n// bool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\n// bool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// 点\ndouble abs(const Point& p) {return std::hypot(p.x, p.y);}\ndouble norm(const Point& p) {return p.x * p.x + p.y * p.y;}\ndouble dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\ndouble cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / hypot(p.x, p.y);}\n// 線\nbool parallel(const Line& l1, const Line& l2) {return std::abs(cross(l2.terminal - l2.initial, l1.terminal - l1.initial)) <= EPS;}\nbool orthogonal(const Line& l1, const Line& l2) {return std::abs(dot(l2.terminal - l2.initial, l1.terminal - l1.initial)) <= EPS;}\n// 点の位置関係\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK}; \nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) < -EPS) return CLOCKWISE;\n  if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n  if(norm(v2) - norm(v1) > EPS) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// 交差判定\nbool intersect(const Point& p1, const Point& p2) {return p1.x == p2.x && p1.y == p2.y;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(l.terminal - p, l.initial - p);}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || parallel(l1, Line(l1.initial, l2.initial));}  // 非平行または同一直線上\n// 点移動\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// 距離\ndouble distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\ndouble distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\ndouble distance(const Segment& s, const Point& p) {return distance(p, s);}\ndouble distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\ndouble distance(const Line& l, const Point& p) {return distance(p, l);}\ndouble distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial),\n                                             distance(s1, s2.terminal),\n                                             distance(s2, s1.initial),\n                                             distance(s2, s1.terminal)});\n}\ndouble distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\ndouble distance(const Line& l,const Segment& s) {return distance(s, l);}\ndouble distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// 交点\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  double A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  double B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  if(std::abs(A) < EPS && std::abs(B) < EPS) return l2.initial;\n  assert(std::abs(A) > EPS);                                // 平行かつ同一直線上にない\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  Point cp = crosspoint(Line(s), l);\n  assert(intersect(s, cp));                                 // 2直線の交点が線分上にない\n  return cp;\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  Point cp = crosspoint(Line(s1), Line(s2));\n  assert(intersect(s1, cp) && intersect(s2, cp));           // 2直線の交点が線分上にない\n  return cp;\n}\n// デバッグ用\n// #include<bits/stdc++.h>\n// using namespace std;\n// void print(const Point& p) {cout<<\"(\"<<p.x<<\",\"<<p.y<<\")\";}\n// void print(const Line& l) {print(l.initial); cout<<\" - \";print(l.terminal);}\n////////////////////////////////////////////////////////////////////////////////\n// 多角形\n//   辺をメンバ変数に持たないようにすればメモリ節約（1/3くらい？） + シンプルに記述 + edge(void)がO(n)\n#include<vector>\n#include<algorithm>\n#include<utility>\nclass Polygon {\npublic:\n  void add(const Point& p) {\n    if(!vertex_.empty()) {\n      if(!edge_.empty()) edge_.pop_back();\n      edge_.push_back(Segment(vertex_.back(), p));\n      edge_.push_back(Segment(p, vertex_.front()));\n    }\n    vertex_.push_back(p);\n  }\n  int size() const {return vertex_.size();}\n  Point vertex(const int n) const {return vertex_.at(n);}\n  Segment edge(const int n) const {return edge_.at(n);}\n  const std::vector<Point>& vertex() const {return vertex_;}\n  const std::vector<Segment>& edge() const {return edge_;}\n  bool touch(const Point& p) const {\n    return std::any_of(edge_.begin(), edge_.end(), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n  }\n  bool include(const Point& p) const {  // intersect()という名前にしたいけどグローバルスコープのintersect()たちが隠蔽されて困った\n    bool in = false;                    // p=(x,y)から(INF,y)への半直線と多角形とが交差する回数 mod 2\n    for(const auto& e: edge()) {\n      if(intersect(p, e)) return true;\n      Point a = e.initial  - p;\n      Point b = e.terminal - p;\n      if(a.y > b.y) std::swap(a, b);\n      if(a.y <= EPS && 0.0 < b.y && cross(a, b) < EPS) in = !in;\n    }\n    return in;\n  }\n    void clear() {\n      vertex_.clear();\n      edge_.clear();\n    };\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n//   Polygon polygon;\n  for(cin >> n; n > 0; --n) {\n    int a, b, c, d, e, f, g, h;\n    cin >> a >> b >> c >> d >> e >> f >> g >> h;\n    Segment s(Point(a, b), Point(c, d));\n    Segment t(Point(e, f), Point(g, h));\n    cout << (intersect(s, t) ? 1 : 0) << endl;\n//     int x, y;\n//     cin >> x >> y;\n//     polygon.add(Point(x, y));\n  }\n//   int q;\n//   for(cin >> q; q > 0; --q) {\n//     int x, y;\n//     cin >> x >> y;\n//     Point p(x, y);\n//     cout << (polygon.touch(p) ? 1 : (polygon.include(p) ? 2 : 0)) << endl;\n//   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n    \n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(a * x, a * y); }\n    Point operator / (double a) {return Point(x / a, y / a); }\n    \n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; \n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) {\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    \n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nint main() {\n    int n;\n    Segment s1, s2;\n    cin >> n;\n    \n    for ( int i = 0; i < n; i++ ) {\n        cin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y\n            >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n        if (intersect(s1, s2)) cout << \"1\";\n        else cout << \"0\";\n        cout << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n#define db double\n#define zero(x) (fabs(x)<eps)\n#define sgn(x) (zero(x)?0:((x)>0?1:-1))\nconst db eps=1e-10;\nstruct point{\n    db x,y;\n    point(){}\n    point(db x,db y):x(x),y(y){}\n    point operator + (point B){ return point(x+B.x,y+B.y); }\n    point operator - (point B){ return point(x-B.x,y-B.y); }\n    point operator * (db k){ return point(k*x,k*y); }\n    db operator * (point B){ return x*B.y-y*B.x; }\n    db operator ^ (point B){ return x*B.x+y*B.y; }\n    bool operator < (point B){ return (y>0)!=(B.y>0)?y>0:((*this)*B)>0; }\n};\ndb dis2(point A,point B){ return (A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y); }\nstruct line{\n    point A,B;\n    line(){}\n    line(point A,point B):A(A),B(B){}\n};\npoint projection(line l,point P){\n    point dir=l.B-l.A; P=P-l.A;\n    return dir*((P^dir)/dis2(l.A,l.B))+l.A;\n}\npoint reflection(line l,point P){\n    return projection(l,P)*2-P;\n}\nint direction(point P0,point P1,point P2){\n    db det=(P2-P0)*(P1-P0); return sgn(det);\n}\nbool parallel(line l1,line l2){\n    return zero((l1.B-l1.A)*(l2.B-l2.A));\n}\nbool orthogonal(line l1,line l2){\n    return zero((l1.B-l1.A)^(l2.B-l2.A));\n}\nbool intersect(line l1,line l2){\n    int d1=direction(l1.A,l1.B,l2.A),d2=direction(l1.A,l1.B,l2.B);\n    int d3=direction(l2.A,l2.B,l1.A),d4=direction(l2.A,l2.B,l1.B);\n    if (d1>0&&d2>0||d1<0&&d2<0||d3>0&&d4>0||d3<0&&d4<0) return false;\n    if (l1.A.x>l1.B.x) swap(l1.A.x,l1.B.x);\n    if (l1.A.y>l1.B.y) swap(l1.A.y,l1.B.y);\n    if (l2.A.x>l2.B.x) swap(l2.A.x,l2.B.x);\n    if (l2.A.y>l2.B.y) swap(l2.A.y,l2.B.y);\n    return !(l1.B.x<l2.A.x||l2.B.x<l1.A.x||l1.B.y<l2.A.y||l2.B.y<l1.A.y);\n}\nint main(){\n    int q; scanf(\"%d\",&q);\n    while (q--){\n        db x1,y1,x2,y2; line l1,l2;\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2); l1=line(point(x1,y1),point(x2,y2));\n        scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2); l2=line(point(x1,y1),point(x2,y2));\n        printf(\"%d\\n\",intersect(l1,l2));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <array>\n#include <vector>\n#include <cmath>\n\nconst double EPSILON = 1e-10;\n\ninline bool equals(double a, double b) {\n    return std::fabs(a - b) < EPSILON;\n}\n\nstruct Point {\n    double x;\n    double y;\n\n    bool operator < (const Point& p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point& p) const {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\nPoint operator + (const Point& p1, const Point& p2) {\n    return Point{p1.x + p2.x, p1.y + p2.y};\n}\n\nPoint operator - (const Point& p1, const Point& p2) {\n    return Point{p1.x - p2.x, p1.y - p2.y};\n}\n\nPoint operator * (const Point& p1, double k) {\n    return Point{p1.x * k, p1.y * k};\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nusing Vector = Point;\nusing Line = Segment;\nusing Polygon = std::vector<Point>;\n\n\ndouble norm(const Vector& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const Vector& p) {\n    return std::sqrt(norm(p));\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nVector projection(const Segment& s, const Point& p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nVector reflection(const Segment& s, const Point& p) {\n    return p + (projection(s, p) - p) * 2.0;\n}\n\nbool is_orthogonal(const Vector& a, const Vector& b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool is_orthogonal(const Segment& s1, const Segment& s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool is_parallel(const Vector& a, const Vector& b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool is_parallel(const Segment& s1, const Segment& s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0,\n};\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n    if (cross(a, b) > EPSILON) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPSILON) return CLOCKWISE;\n    if (dot(a, b) < -EPSILON) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    auto area = [](const Point& x0, const Point& x1, const Point& x2) {\n        auto a = x1 - x0;\n        auto b = x2 - x0;\n        return cross(a, b);\n    };\n    return (area(p1, p2, p3) * area(p1, p2, p4) < 0 &&\n            area(p3, p4, p1) * area(p3, p4, p2) < 0);\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return abs(a - b);\n}\n\ndouble distanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s, p);\n}\n\ndouble distance(const Segment& s1, const Segment& s2) {\n    using std::min;\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n               min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n}\n\n\nint main() {\n    using namespace std;\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        array<Point, 4> points;\n        for (auto& p : points) {\n            cin >> p.x >> p.y;\n        }\n        Segment s1{points[0], points[1]};\n        Segment s2{points[2], points[3]};\n        cout << intersect(s1, s2) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1 ;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x); \n            if (tc * td <= 0 && ta * tb <= 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  cgl_1_b.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Oct 23 00:28:22 2017\n//\n#include <cmath>\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n#define EPS 1e-10\n#define equals(x, y) (fabs(x - y) < EPS)\n\nstruct vector_t {\n  double x;\n  double y;\n\n  vector_t(double a, double b) : x(a), y(b)\n  {\n  }\n\n  double norm2()\n  {\n    return x * x + y * y;\n  }\n\n  double dot(vector_t a)\n  {\n    return x * a.x + y * a.y;\n  }\n\n  double cross(vector_t a)\n  {\n    return x * a.y - y * a.x;\n  }\n\n  vector_t operator*(double a)\n  {\n    return vector_t(a * x, a * y);\n  }\n};\n\nstruct point_t {\n  double x;\n  double y;\n\n  point_t operator+(const point_t a)\n  {\n    return point_t({x + a.x, y + a.y});\n  }\n\n  void print()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y << endl;\n  }\n\n  point_t operator+(const vector_t vec)\n  {\n    return point_t({x + vec.x, y + vec.y});\n  }\n\n  vector_t operator-(const point_t p)\n  {\n    return vector_t({x - p.x, y - p.y});\n  }\n\n  point_t project(point_t p1, point_t p2)\n  {\n    vector_t vec1(x - p1.x, y - p1.y);\n    vector_t vec2(p2.x - x, p2.y - y);\n    return point_t({x, y}) + vec1 * (vec1.dot(vec2) / vec1.norm2());\n  }\n\n  point_t reflect(point_t p1, point_t p2)\n  {\n    point_t proj = project(p1, p2);\n    return p2 + (proj - p2) * 2.0;\n  }\n};\n\nenum pos_t {\n  CCLOCKWISE = -1,\n  CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = 3,\n  ON_SEGMENT = 0,\n};\n\npos_t ccw(point_t p0, point_t p1, point_t p2)\n{\n  if ((p1 - p0).cross(p2 - p0) > EPS) {\n    return CCLOCKWISE;\n  } else if ((p1 - p0).cross(p2 - p0) < -EPS) {\n    return CLOCKWISE;\n  } else if ((p1 - p0).dot(p2 - p0) < -EPS) {\n    return ONLINE_BACK;\n  } else {\n    if ((p1 - p0).norm2() < (p2 - p0).norm2()) {\n      return ONLINE_FRONT;\n    } else {\n      return ON_SEGMENT;\n    }\n  }\n}\n\nbool intersection(point_t p0, point_t p1, point_t p2, point_t p3)\n{\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0.0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nstruct segment_t {\n  point_t x;\n  point_t y;\n};\n\nint32_t main()\n{\n  uint32_t q;\n  cin >> q;\n\n  for (uint32_t i = 0; i < q; i++) {\n    double x, y;\n    cin >> x >> y;\n    point_t p0({x, y});\n    cin >> x >> y;\n    point_t p1({x, y});\n    cin >> x >> y;\n    point_t p2({x, y});\n    cin >> x >> y;\n    point_t p3({x, y});\n    cout << (int)intersection(p0, p1, p2, p3) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//???????????????????????????????????°???\n//??????????????????????????????????????????????????????\n//references<http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/IntersectionEX.htm>\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint q; cin >> q;\n\tbool f;\n\tfor (int i = 0; i < q; i++) {\n\t\tf = false;\n\t\tlong double x0, y0, x1, y1, x2, y2, x3, y3; cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t//x coordinate\n\t\tif (x0 >= x1) {\n\t\t\tif (((x0 < x2) && (x0 < x3)) || ((x1 > x2) && (x1 > x3)))f = true;\n\t\t}\n\t\telse {\n\t\t\tif (((x1 < x2) && (x1 < x3)) || ((x0 > x2) && (x0 > x3))) f = true;\n\t\t}\n\t\t//y coordinate\n\t\tif (y0 > y1) {\n\t\t\tif (((y0 < y2) && (y0 < y3)) || ((y1 > y2) && (y1 > y3)))f = true;\n\t\t}\n\t\telse {\n\t\t\tif (((y1 < y2) && (y1 < y3)) || ((y0 > y2) && (y0 > y3))) f = true;\n\t\t}\n\t\tif ((((x0 - x1)*(y2 - y0) + (y0 - y1)*(x0 - x2))*((x0 - x1)*(y3 - y1) + (y0 - y1)*(x0 - x3))) > 0) f = true;\n\t\tif ((((x2 - x3)*(y0 - y2) + (y2 - y3)*(x2 - x0))*((x2 - x3)*(y1 - y2) + (y2 - y3)*(x2 - x1))) > 0) f = true;\n\t\tif (f) { cout << \"0\" << endl; }\n\t\telse { cout << \"1\" << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n\nconst int get_diff(const std::vector<std::pair<int, int>> &point, const int &p0, const int &p1){\n\tint X = point.at(p0 + 1).first - point.at(p0).first;\n\tint Y = point.at(p0 + 1).second - point.at(p0).second;\n\treturn (X * point.at(p1).second - Y * (point.at(p1).first - point.at(p0).first) - X * point.at(p0).second);\n}\nconst bool sub_inter(const int &p0, const int &p1, const int &p2){\n\treturn ((p2 - p0) * (p2 - p1) <= 0);\n}\nconst bool inter(const std::vector<std::pair<int, int>> &point){\n\tbool result = false;\n\tfor (auto i = 0; i < 2; ++i){\n\t\tfor (auto j = 0; j < 2; ++j){\n\t\t\tresult = result || sub_inter(point.at(2 * i).second, point.at(2 * i + 1).second, point.at(3 - 2 * i - j).second);\n\t\t}\n\t}\n\treturn result;\n}\nbool judge(const std::vector<std::pair<int, int>> &point){\n\tif (point.at(0).first != point.at(1).first and point.at(2).first != point.at(3).first){\n\t\tif ((get_diff(point, 0, 2) * get_diff(point, 0, 3) <= 0) and (get_diff(point, 2, 0) * get_diff(point, 2, 1) <= 0)){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else if (point.at(2).first != point.at(3).first){\n\t\tif ((point.at(0).first - point.at(2).first) * (point.at(0).first - point.at(3).first) <= 0 and (get_diff(point, 2, 0) * get_diff(point, 2, 1) <= 0)){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else if (point.at(0).first != point.at(1).first){\n\t\tif ((point.at(2).first - point.at(0).first) * (point.at(2).first - point.at(1).first) <= 0 and (get_diff(point, 0, 2) * get_diff(point, 0, 3) <= 0)){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif (point.at(0).first == point.at(2).first){\n\t\t\tif (inter(point)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\nint main(){\n\tint q;\n\tstd::cin >> q;\n\tfor (auto i = 0; i < q; ++i){\n\t\tstd::vector<std::pair<int, int>> point;\n\t\tfor (auto j  = 0; j < 4; ++j){\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\tpoint.push_back(std::make_pair(x, y));\n\t\t}\n\t\tif (judge(point)){\n\t\t\tstd::cout << \"1\\n\";\n\t\t}else{\n\t\t\tstd::cout << \"0\\n\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const {\n        return max(std::abs(x), std::abs(y));\n    } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        if (!rless(m.s, m.t)) swap(m.s, m.t);\n        if (!rless(l.s, m.s)) swap(l, m);\n        if (ccw(l, m.s) == 0) {\n            r = m.s;\n            if (near(l.t, m.s)) return 1;\n            return -1;\n        }\n        return 0;\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v+di, v-di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << abs(crossSS(l1, l2, p)) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals (fabs((a)-(b)<EPS)\nint n;\n\nstruct Point\n{\n    double x, y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n    double norm()\n    {\n        return x*x+y*y;\n    }\n};\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\nPoint p0,p1,p2,p3;\nint ccw(Point p0,Point p1,Point p2)\n{\n    Point a=p1-p0;\n    Point b=p2-p0;\n    if(cross(a,b)>EPS) return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS) return 2;\n    if(a.norm()<b.norm()) return -2;\n\n    return 0;\n}\nvoid solve()\n{\n   if(ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0) printf(\"1\\n\");\n   else printf(\"0\\n\");\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p0.x,&p0.y,&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y);\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (p0 == p1 || p0 == p2 || p0 == p3 || p1 == p2 || p1 == p3 || p2 == p3) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_parallel(p0, p1, p2, p3)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-10;\nstruct Node\n{\n    double x, y;\n    Node(double xx = 0, double yy = 0){\n        x = xx; y = yy;\n    }\n\n    Node operator + (Node b){\n        return Node(x+b.x, y+b.y);\n    }\n    Node operator - (Node b){\n        return Node(x-b.x, y-b.y);\n    }\n    Node operator * (double a){\n        return Node(a*x, a*y);\n    }\n    Node operator / (double a){\n        return Node(x/a, y/a);\n    }\n\n    double norm(){return x*x+y*y;}\n    double len(){\n        return sqrt(norm());\n    }\n\n    bool operator < (const Node &p) const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n\n    bool operator == (const Node &p) const {\n        return fabs(x-p.x)<eps && fabs(y-p.y)<eps;\n    }\n};\n\nbool equals(double a, double b) {\n    return fabs(a)-fabs(b) < eps;\n}\n\ntypedef Node vtr;\n\nstruct line{\n    Node a, b;\n    line(Node x, Node y){\n        a = x, b = y;\n    }\n};\n\n//向量点积\ndouble dot(vtr a, vtr b){\n    return a.x*b.x+a.y*b.y;\n}\n\n//向量叉积\ndouble cross(vtr a, vtr b){\n    return a.x*b.y-a.y*b.x;\n}\n\n//判断向量a,b是否正交(垂直)\nbool isOrthogonal(vtr a, vtr b){\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Node a1, Node a2, Node b1, Node b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\n\nbool isOrthogonal(line s1, line s2){\n    return equals(dot(s1.b-s1.a, s2.b-s2.a), 0.0);\n}\n\n//判断向量a,b是否平行\nbool isParallel(vtr a, vtr b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Node a1, Node a2, Node b1, Node b2){\n    return isParallel(a1-a2, b1-b2);\n}\n\nbool isParallel(line s1, line s2){\n    return equals(cross(s1.b-s1.a, s2.b-s2.a), 0.0);\n}\n\n//投影 求垂足坐标\n//点p在直线p1p2上的投影\nNode project(line s, Node p)\n{\n    vtr base = s.b-s.a;\n    //算出比例\n    double r = dot(p-s.a, base)/base.norm();\n    return s.a+base*r;\n}\n\n//映象 求p以直线s为对称轴的对称点\nNode reflect(line s, Node p){\n    return p+(project(s, p)-p)*2.0;\n}\n\nint ccw(Node p0, Node p1, Node p2)\n{\n    vtr a = p1-p0, b = p2-p0;\n    //b在a的逆时针方向\n    if(cross(a, b) > eps) return 1;\n    //顺时针方向\n    if(cross(a, b) < -eps) return -1;\n    //共线但反向\n    if(dot(a, b) < -eps) return 2;\n    //共线同向\n    //b更长一点\n    if(a.norm() < b.norm()) return -2;\n    //a更长一点\n    return 0;\n}\n\n//判断两线段是否相交\nbool intersect(Node p1, Node p2, Node p3, Node p4){\n    bool t1 = ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0;\n    bool t2 = ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0;\n    return t1&&t2;\n}\nbool intersect(line s1, line s2){\n    return intersect(s1.a, s1.b, s2.a, s2.b);\n}\n\n\nint main()\n{\n    Node p0, p1, p2, p3;\n    int q; cin >> q;\n    while(q--)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        line s1 = line(p0, p1);\n        line s2 = line(p2, p3);\n        cout << intersect(s1, s2) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<assert.h>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstdlib>\n#include<iostream>\n#include<bitset>\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)\n#define per(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)\nusing namespace std;\ntypedef long long LL;\n//template\ntypedef double db;\nconst db eps=1e-10;\nconst db pi=acosl(-1.0);\nint sign(db x){if(x<-eps)return -1;if(x>eps)return 1;return 0;}\nint cmp(db x,db y){return sign(x-y);}\nbool inmid(db x,db l,db r){return cmp(x,l)*cmp(x,r)<=0;}\nstruct po{\n\tdb x,y;\n\tpo(db _x=0,db _y=0):x(_x),y(_y){}\n\tvoid read(){scanf(\"%lf%lf\",&x,&y);}\n};\npo operator +(const po &a,const po &b){return po(a.x+b.x,a.y+b.y);}\npo operator -(const po &a,const po &b){return po(a.x-b.x,a.y-b.y);}\npo operator *(const po &a,const db &b){return po(a.x*b,a.y*b);}\npo operator /(const po &a,const db &b){return po(a.x/b,a.y/b);}\ndb operator *(const po &a,const po &b){return a.x*b.x+a.y*b.y;}\ndb operator ^(const po &a,const po &b){return a.x*b.y-a.y*b.x;}\ndb mo2(po a){return a*a;}\ndb mo(po a){return sqrt(a*a);}\npo proj(po x,po y){//proj x to y\n\treturn y*((x*y)/mo2(y));\n}\npo refl(po x,po y){//refl x from y\n\treturn proj(x,y)*2-x;\n}\nbool onseg(po x,po l,po r){\n\treturn (sign((x-l)^(r-l))==0)&&inmid(x.x,l.x,r.x)&&inmid(x.y,l.y,r.y);\n}\nbool inter(db l1,db r1,db l2,db r2){\n\tif(cmp(l1,r1)==1)swap(l1,r1);\n\tif(cmp(l2,r2)==1)swap(l2,r2);\n\treturn cmp(min(r1,r2),max(l1,l2))>=0;\n}\nbool checkss(po a,po b,po c,po d){\n\treturn sign((b-a)^(c-a))*sign((b-a)^(d-a))<=0&&sign((d-c)^(a-c))*sign((d-c)^(b-c))<=0&&inter(a.x,b.x,c.x,d.x)&&inter(a.y,b.y,c.y,d.y);\n}\n//template\nint main(){\n\tint t;scanf(\"%d\",&t);\n\twhile(t--){\n\t\tpo a,b,c,d;\n\t\ta.read();b.read();c.read();d.read();\n\t\tif(checkss(a,b,c,d))puts(\"1\");else puts(\"0\");\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1e10\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE -1\n#define C_A_B +2\n#define A_B_C -2\n#define A_C_B 0\n \nstruct Point{\n    double x, y;\n\n    Point(){}\n\n    Point(double _x, double _y)\n\t{\n        x = _x; y = _y;\n    }\n\n    Point operator + (const Point p) const\n\t{\n        return Point(x + p.x, y + p.y);\n    }\n\tPoint operator - (const Point p) const\n\t{\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (const double d) const\n\t{\n        return Point(x*d,y*d);\n    }\n    bool operator < (const Point &p) const\n\t{\n        if(x==p.x) return y < p.y;\n        return x < p.x;\n    }\n\tbool operator == (const Point &p) const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n    double Norm()\n\t{\n        return x*x + y*y;\n    }\n\tbool Input()\n\t{\n\t\tif(cin >> x >> y) return true;\n\t\treturn false;\n\t}\n};\n\nstruct Line{\n    Point a, b;\n\n    Line(){}\n\n    Line(Point _a, Point _b)\n\t{\n        a = _a; b = _b;\n    }\n\tbool Input()\n\t{\n\t\tif( a.Input() && b.Input() ) return true;\n\t\treturn false;\n\t}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n\n    Circle(){}\n\n    Circle(Point _c, double _r)\n\t{\n        c = _c; r = _r;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ntypedef Line Segment;\n\ndouble Dot(Vector p, Vector q)\n{\n    return p.x*q.x + p.y*q.y;\n}\n\ndouble Cross(Vector p, Vector q)\n{\n    return p.x*q.y - q.x*p.y;\n}\n\nint CCW(Point a, Point b, Point c){ //a,b,c,?????¨?????°??????\n\tVector v1 = b-a;\n\tVector v2 = c-a;\n    if(Cross(v1, v2) > EPS) return +1; //a->b->c ??????????¨???????\n    if(Cross(v1, v2) <- EPS) return -1; //a->b->c ???????¨???????\n\tif(Dot(v1, v2) <- EPS) return +2; //c???a-b???????????? c<-a->b\n\tif(v2.Norm() - v1.Norm() > EPS) return -2; //c???a-b????????? a->b->c\n    return 0; //c???a-b??? a->c->b\n}\n\nPoint GetProject(Segment s, Point p){\n\tVector v1 = s.b - s.a;\n\tVector v2 = p - s.a;\n\tdouble r = Dot(v1,v2)/v1.Norm();\n\treturn s.a + v1*r;\n}\n\nPoint GetReflect(Segment s, Point p){\n\treturn p + (GetProject(s, p) - p)*2.0;\n}\n\nbool IntersectsSS(Segment l, Segment m){\n\treturn CCW(l.a, l.b, m.a)*CCW(l.a, l.b, m.b) <= 0 && CCW(m.a, m.b, l.a)*CCW(m.a, m.b, l.b) <= 0;\n}\n\nbool GetIntersectionSS(Segment s, Segment t, Point &p){\n    Vector a1, a2, b1, b2;\n    a1 = s.b - s.a;\n\ta2 = t.b - t.a;\n    b1 = t.a - s.a;\n\tb2 = s.a - t.b;\n    double s1, s2;\n    s1 = Cross(a1, b1)/2;\n\ts2 = Cross(a1, b2)/2;\n    //if(s1 + s2 < EPS) return false; //??????\n    p = Point( t.a.x + a2.x*s1/(s1 + s2), t.a.y + a2.y*s1/(s1 + s2) );\n    return true;\n}\n\nint GetIntersectionLL(Line l, Line m, Point &p){\n    if(GetIntersectionSS(l,m,p) == true) return 1;\n\treturn -1; //??????????????????(??????????????????)\n}\n\nint GetIntersectionCC(Circle c1, Circle c2, Point &p1, Point &p2){\n    double d, a, t;\n    d = sqrt( (c2.c - c1.c).Norm() );\n\tif(abs(c1.c.x - c2.c.x) < EPS && abs(c1.c.y - c2.c.y) < EPS && abs(c1.r - c2.r) < EPS)\n\t\treturn -1; //2????????????????????£?????????\n    if(d < abs(c1.r - c2.r) || c1.r + c2.r < d) return 0; //??¢?????????????????????\n    a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    t = atan2(c2.c.y - c1.c.y, c2.c.x - c1.c.x);\n    p1 = Point(c1.c.x + c1.r*cos(t + a),c1.c.y + c1.r*sin(t + a));\n    p2 = Point(c1.c.x + c1.r*cos(t - a),c1.c.y + c1.r*sin(t - a));\n    if(abs(p1.x - p2.x) < EPS && abs(p1.y - p2.y) < EPS) return 1; //?????????1???\n    return 2; //?????????2???\n}\n\n//????§???¢???????????????\nint ContainsGP(Polygon g, Point p){\n\tLine l = Line( p, Point(INF, p.y) );\n\tint cnt = 0, n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tVector a = g[i] - p;\n\t\tVector b = g[(i+1)%n] - p;\n\t\tif(CCW(g[i],g[(i+1)%n], p) == 0) return 1; //?????????\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y <= EPS && EPS < b.y && Cross(a, b) > EPS) cnt++;\n\t}\n\tif((cnt&1) == 1) return 2; //??????????????????\n\treturn 0; //?????????????????????\n}\n\nPolygon AndrewScan(Polygon s){\n\tif(s.size() <= 2) return s;\n\tsort(s.begin(), s.end());\n\tPolygon g;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tfor(int n = g.size(); n >= 2 && CCW(g[n-2], g[n-1], s[i]) != -1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i = s.size()-2; i >= 0;i--){\n\t\tfor(int n = g.size(); n > upper_n && CCW(g[n-2], g[n-1], s[i]) != -1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(), g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tSegment l, m;\n\t\tl.a.Input();\n\t\tl.b.Input();\n\t\tm.a.Input();\n\t\tm.b.Input();\n\t\tprintf(\"%d\\n\", IntersectsSS(l, m) );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Computing Geometry Library\n * @author Sshwy\n */\n#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\n\nnamespace cg{\n    typedef long double vtyp;\n    const vtyp eps = 1e-9;\n    bool isZero(vtyp x){ return -eps < x && x < eps; }\n    bool equal(vtyp x, vtyp y){ return isZero(x-y); }\n    bool lt(vtyp x,vtyp y){ return !equal(x,y) && x<y; }\n    bool gt(vtyp x,vtyp y){ return !equal(x,y) && x>y; }\n    struct vec {\n        vtyp x,y;\n        vec(){ x = y = 0; }\n        vec(vtyp _x, vtyp _y){ x = _x, y = _y; }\n        vec operator+(const vec V) const { return vec(x+V.x, y+V.y); }\n        vec operator-() const { return vec(-x, -y); }\n        vec operator-(const vec V) const { return *this + (-V); }\n        vec operator*(const vtyp a) const { return vec(x*a, y*a); }\n        friend vec operator*(const vtyp a, const vec v){ return v*a; }\n        vec operator/(const vtyp a) const { return vec(x/a, y/a); }\n        operator bool() const { return !(isZero(x) && isZero(y)); }\n        bool operator==(const vec V) const { return bool(*this-V) == 0; }\n        vtyp length(){ return sqrt(x*x + y*y); }\n        /**\n         * 方向角，单位 rad\n         */\n        vtyp ang() const { return atan2(y,x); }\n        /**\n         * 方向向量\n         * @return 0向量或者一个单位向量\n         */\n        vec dir() const {\n            if(*this){\n                vtyp ang = atan2(y,x);\n                return vec(cos(ang), sin(ang));\n            } else return vec(0,0);\n        }\n        void read(){ scanf(\"%Lf%Lf\",&x,&y); }\n    };\n    typedef vec point;\n\n    struct line {\n        point p1, p2;\n        line(point _p1, point _p2){ p1 = _p1, p2 = _p2; }\n    };\n    typedef line segment;\n\n    istream & operator>>(istream & in, vec & v){ \n        return in >> v.x >> v.y, in; \n    }\n    ostream & operator<<(ostream & out, const vec & v){ \n        return out << v.x << \" \" << v.y, out;\n    }\n    ifstream & operator>>(ifstream & in, vec & v){ \n        return in >> v.x >> v.y, in; \n    }\n    ofstream & operator<<(ofstream & out, const vec & v){ \n        return out << v.x << \" \" << v.y, out;\n    }\n    /**\n     * 点积\n     * a dot b == |a||b|cos theta\n     */\n    vtyp dot(const vec a, const vec b){ return a.x*b.x + a.y*b.y; }\n    /**\n     * 叉积\n     * 两个向量围成的有向面积\n     */\n    vtyp det(const vec a, const vec b){ return a.x*b.y - a.y*b.x; }\n\n\n    /**\n     * 投影\n     * @param L 直线\n     * @param p 要求投影的点\n     * @return p 在 L 上的投影坐标（即垂足）\n     */\n    point projection(line L, point p){\n        vec d = L.p2 - L.p1;\n        return L.p1 + (dot(d, p-L.p1)/d.length()) * d.dir();\n    }\n    /**\n     * 对称点\n     * @param L 直线\n     * @param p 点\n     * @return p 关于直线 L 的对称点\n     */\n    point reflection(line L, point p){\n        point o = projection(L,p);\n        return vtyp(2)*(o-p)+p;\n    }\n\n    /**\n     * 判断向量是否平行\n     */\n    bool parallel(vec a, vec b){ return isZero(det(a,b)); }\n    /**\n     * 判断直线是否平行\n     */\n    bool parallel(line a, line b){ return parallel(a.p2-a.p1, b.p2-b.p1); }\n    /**\n     * 判断向量是否垂直\n     */\n    bool orthogonal(vec a, vec b){ return isZero(dot(a,b)); }\n    /**\n     * 判断直线是否垂直\n     */\n    bool orthogonal(line a, line b){ return orthogonal(a.p2-a.p1, b.p2-b.p1); }\n    /**\n     * 判断点 p 是否在直线L上\n     */\n    bool online(line L, point p){\n        return parallel(L.p2-L.p1,p-L.p1);\n    }\n    /**\n     * 判断两直线是否重合\n     */\n    bool coincident(line a, line b){\n        return online(a, b.p1) && online(a, b.p2);\n    }\n    /**\n     * 判断点 p 是否与有向线段共线且在反向延长线上\n     */\n    bool online_back(segment sl, point p){\n        vec a = sl.p2-sl.p1, b = p-sl.p1;\n        return parallel(a,b) && lt(dot(a,b),0);\n    }\n    /**\n     * 判断点 p 是否与有向线段共线且在正向延长线上\n     */\n    bool online_front(segment sl, point p){\n        vec a = sl.p1-sl.p2, b = p-sl.p2; // 倒过来\n        return parallel(a,b) && lt(dot(a,b),0);\n    }\n    /**\n     * 判断点 p 是否在线段上（含端点）\n     */\n    bool on_segment(segment sl, point p){\n        return online(sl,p) && !online_back(sl,p) && !online_front(sl,p);\n    }\n    /**\n     * 两条直线的交点\n     * 需确保两条直线不平行\n     */\n    point intersection(line a, line b){\n        assert(!parallel(a,b));\n        vtyp x = det(a.p1-b.p1,b.p2-b.p1);\n        vtyp y = det(b.p2-b.p1,a.p2-b.p1);\n        return a.p1 + (a.p2-a.p1)*x/(x+y);\n    }\n    /**\n     * 判断两个线段是否相交（含边界）\n     */\n    bool check_segment_intersection(segment a, segment b){\n        if(cg::coincident(a,b)){\n            if(on_segment(a,b.p1) \n                    || on_segment(a,b.p2)\n                    || on_segment(b,a.p1) \n                    || on_segment(b,a.p2))return true;\n            else return false;\n        }else if(cg::parallel(a,b)){\n            return false;\n        }else{\n            point o = cg::intersection(a,b);\n            if(cg::on_segment(a,o) && cg::on_segment(b,o))return true;\n            else return false;\n        }\n    }\n}\nusing cg::point;\nusing cg::line;\nusing cg::segment;\n\n\nint main(){\n    int q;\n    cin>>q;\n    FOR(i,1,q){\n        point p[4];\n        cin>>p[0]>>p[1]>>p[2]>>p[3];\n        line l1(p[0],p[1]),l2(p[2],p[3]);\n        cout<<cg::check_segment_intersection(l1,l2)<<endl;\n        // cout<<setiosflags(ios::fixed) <<setprecision(10)\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8, PI = acos(-1);\n\n// 実数同士の比較\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\n// 入力\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\n// 出力\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\n// 原点を中心として, 点 p を θ 回転すた点を返す\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアンを度数に変換\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\n// 度数をラジアンに変換\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\n// ∠BAC をラジアンで取得\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - a);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\n// x軸, y軸の順にソート\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n// 直線\n// 2 点を通る直線\n// Ax + By = C  \nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\n// 線分\n// 2 点を結ぶ\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n// 円\n// 中心と半径\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\n// いらんかも\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\n// 外積\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\n// 内積\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n\n//          +1\n//          \n//  +2   a   0   b  -2\n//\n//          -1\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n\n// 2 直線が平行か\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// 2 直線が垂直か\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// 直線 l に 点 p から垂線を下ろして,交わる点を返す\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 同じ\n// 直線として扱われそう\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 直線 l に対して, 点 p と線対称な位置にある点を返す.\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\n// 直線上に点が乗るかどうか\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n// 直線 l と直線 m の交差判定\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\n// 線分上に点があるかどうか\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\n// 直線 l と 線分 s の交差判定\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\n// 点 p と 直線 l との距離\nReal distance(const Line &l, const Point &p);\n\n// 円 c と直線 l との交差判定\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\n// 点 p が 円 c 上にあるかどうか\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint main(){\n    \n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        Real a, b, c, d;\n        cin >> a >> b >> c >> d;\n        Segment s1(Point(a, b), Point(c, d));\n        cin >> a >> b >> c >> d;\n        Segment s2(Point(a, b), Point(c, d));\n        if(intersect(s1, s2)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE_BACK,\n              ONLINE_FRONT, ON_SEGMENT};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    POSITION s2p1_s1 = get_position(s2.p1, s1);\n    POSITION s2p2_s1 = get_position(s2.p2, s1);\n    POSITION s1p1_s2 = get_position(s1.p1, s2);\n    POSITION s1p2_s2 = get_position(s1.p2, s2);\n    if (s2p1_s1 == ON_SEGMENT || s2p2_s1 == ON_SEGMENT) return true;\n    if (s1p1_s2 == ON_SEGMENT || s1p2_s2 == ON_SEGMENT) return true;\n    if (s2p1_s1 == ONLINE_FRONT) {\n        if (s2p2_s1 == ONLINE_BACK) return true;\n        return false;\n    }\n    if (s2p1_s1 == ONLINE_BACK) {\n        if (s2p2_s1 == ONLINE_FRONT) return true;\n        return false;\n    }\n    if (s2p1_s1 == CLOCKWISE) {\n        if (s2p2_s1 != COUNTER_CLOCKWISE) return false;\n        if (s1p1_s2 == s1p2_s2) return false;\n        return true;\n    }\n    if (s2p1_s1 == COUNTER_CLOCKWISE) {\n        if (s2p2_s1 != CLOCKWISE) return false;\n        if (s1p1_s2 == s1p2_s2) return false;\n        return true;\n    }\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define EPS 1e-8\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n\ninline int signum(double x) { return (abs(x) < EPS) ? 0 : x > 0 ? 1 : -1; };\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_intersected_lines_ss(P p1, P p2, P p3, P p4) {\n    return (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS) &&\n           (cross(p4 - p3, p1 - p3) * cross(p4 - p3, p2 - p3) < EPS);\n}\n\nint main() {\n\n    int Q;\n    cin >> Q;\n\n    while (Q--) {\n\n        vector<P> p(4);\n        for (int i = 0; i < 4; i++) {\n            double x, y;\n            cin >> x >> y;\n            p[i] = P(x, y);\n        }\n\n        if (is_intersected_lines_ss(p[0], p[1], p[2], p[3])) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef pair<double, double> pdd;\nconst double eps = 1e-10;\nconst double pi = acos(-1);\ninline int sgn(double d){if(fabs(d) < eps) return 0;if(d > 0) return 1;return -1;}\ninline double rad(double _deg){return _deg / 180.0 * pi;}\ninline double deg(double _rad){return _rad / pi * 180.0;}\nstruct Point{\n\tdouble x, y;\n\tvoid read(){scanf(\"%lf%lf\", &x, &y);}\n\tPoint():x(0.0), y(0.0){}\n\tPoint(double a, double b = 0.0): x(a), y(b){}\n\tPoint(const Point& p): x(p.x), y(p.y){}\n\tPoint operator + (const Point& a){return {x + a.x, y + a.y};}\n\tPoint operator - (const Point& a){return {x - a.x, y - a.y};}\n\tdouble operator * (const Point& a){return x * a.x + y * a.y;}\n\tdouble operator ^ (const Point& a){return x * a.y - y * a.x;}\n\tbool operator == (const Point& p){return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;}\n\tbool operator < (const Point &p) const{\n\t\tif(sgn(x - p.x) == 0) \n\t\t\treturn sgn(y - p.y) == -1;\n\t\treturn sgn(x - p.x) == -1;\n\t}\n\tdouble length(){return sqrt(x * x + y * y);}\n}typedef Vector;\nstruct Line{\n\tPoint a, b;\n\tvoid read(){a.read(); b.read();}\n\tLine() : a(0.0, 0.0) , b(0.0, 0.0){}\n};\nstruct Segment{\n\tPoint a, b;\n\tvoid read(){a.read(); b.read();}\n\tSegment() : a(0.0, 0.0) , b(0.0, 0.0){}\n};\ndouble Distance(const Point &a, const Point &b) \n{\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt(x * x + y * y);\n}\nPoint Projection(Point p, Line l)\n{ \n\t// 点在直线上的投影点\n\tVector v1 = l.b - l.a;\n\tVector v2 = p - l.a;\n\tdouble k1 = v1 * v2;\n\tdouble k2 = v1.length();\n\tk1 /= k2 * k2;\n\treturn {l.a.x + v1.x * k1, l.a.y+ v1.y * k1};\n}\nPoint Reflection(Point p, Line l)\n{\n\t// 点关于直线对称\n\tPoint p0 = Projection(p, l);\n\tVector v0 = p0 - p;\n\treturn p0 + v0;\n}\nint ccw(Point p, Segment sg)\n{\t// Counter_Clockwise\n\t// p 关于(sg.a -> sg.b)的位置关系\n\tVector v0 = sg.b - sg.a;\n\tVector v1 = p - sg.a;\n\t\n\tint fcross = sgn(v0 ^ v1);\n\t\n\tif(fcross == 1) return 1; // 逆时针方向\n\tif(fcross == -1) return -1; // 顺时针方向\n\t\n\tint fdot = sgn(v0 * v1);\n\t\n\tif(fdot == -1) return 2; // 反向线段外共线\n\tif(v0.length() < v1.length()) return -2; //正向线段外共线\n\treturn 0; //点在线段上\n}\nbool isParallel(Line l1, Line l2)\n{\n\t//没有判断重合\n\treturn sgn((l1.b - l1.a) ^ (l2.b - l2.a)) == 0;\n}\nbool isOrthogonal(Line l1, Line l2)\n{\n\treturn sgn((l1.b - l1.a) * (l2.b - l2.a)) == 0;\n}\nbool isIntersection(Segment sg1, Segment sg2)\n{\n\treturn ccw(sg2.a, sg1) * ccw(sg2.b, sg1) <= 0 && ccw(sg1.a, sg2) * ccw(sg1.b, sg2) <= 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile(n --)\n\t{\n\t\tSegment sg1, sg2;\n\t\tsg1.read(); sg2.read();\n\t\tbool ans = isIntersection(sg1, sg2);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nbool are_crossing(complex<double> a1, complex<double> a2, complex<double> b1, complex<double> b2){\n    double ta = (a1.real() - a2.real()) * (b1.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b1.real());\n    double tb = (a1.real() - a2.real()) * (b2.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b2.real());\n    return (ta*tb < 0.0);\n}\n\nint main(){\n    int q;\n    cin >> q;\n    double re, im;\n    vector< complex<double> > v(4);\n    for(int i=0;i<q;i++){\n        for(int j=0;j<4;j++){\n            cin >> re >> im;\n            v[j].real(re);\n            v[j].imag(im);\n        }\n        cout << are_crossing(v[0], v[1], v[2], v[3]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Vector {\npublic:\n  double x, y;\n  Vector() {}\n  Vector(double x, double y) : x(x), y(y) {}\n\n  Vector operator+(Vector v) { return Vector(x + v.x, y + v.y); }\n  Vector operator-(Vector v) { return Vector(x - v.x, y - v.y); }\n  Vector operator*(double s) { return Vector(s * x, s * y); }\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\n\n// inner product\ndouble dot(Vector v1, Vector v2) { return v1.x * v2.x + v1.y * v2.y; }\n\n// cross product\ndouble cross(Vector v1, Vector v2) { return v1.x * v2.y - v1.y * v2.x; }\n\nclass Line {\npublic:\n  Vector v1, v2;\n  Line() {}\n  Line(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n};\nclass Segment {\npublic:\n  Vector v1, v2;\n  Segment() {}\n  Segment(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  operator Line() const { return Line(v1, v2); }\n};\n\nbool is_parrallel(Vector a, Vector b) { return equals(cross(a, b), 0); }\nbool is_parrallel(Line a, Line b) {\n  return is_parrallel(a.v1 - a.v2, b.v1 - b.v2);\n}\nbool is_parrallel(Segment a, Segment b) {\n  return is_parrallel((Line)a, (Line)b);\n}\n\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0); }\nbool is_orthogonal(Line a, Line b) {\n  return is_orthogonal(a.v1 - a.v2, b.v1 - b.v2);\n}\n\nVector project(Line l, Vector v) {\n  Vector a = v - l.v1;\n  Vector b = l.v2 - l.v1;\n  return l.v1 + b * (dot(a, b) / b.norm());\n}\n\nVector reflect(Line l, Vector v) { return v + (project(l, v) - v) * 2.0; }\n\ndouble distance(Line l, Vector v) { return (v - project(l, v)).abs(); }\ndouble distance(Vector v1, Vector v2) { return (v1 - v2).abs(); }\nbool in_segment(Segment s, Vector v) {\n  return dot(s.v2 - s.v1, v - s.v1) > 0 && dot(s.v1 - s.v2, v - s.v2) > 0;\n}\ndouble distance(Segment s, Vector v) {\n  auto m = project((Line)s, v);\n  if (in_segment(s, m)) {\n    return distance(m, v);\n  } else\n    return min(distance(s.v1, v), distance(s.v2, v));\n}\nbool opposite(Line l, Vector v1, Vector v2) {\n  auto a = l.v2 - l.v1;\n  auto b = v1 - l.v1;\n  auto c = v2 - l.v1;\n  return cross(a, b) * cross(a, c) < 0;\n}\nenum Direction {\n  CLOCKWISE = -1,\n  ON_SEGMENT = 0,\n  COUNTER_CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = 3,\n};\nDirection ccw(Vector v0, Vector v1, Vector v2) {\n  auto a = v1 - v0;\n  auto b = v2 - v0;\n  if (cross(a, b) > 0)\n    return COUNTER_CLOCKWISE;\n  if (cross(a, b) < 0)\n    return CLOCKWISE;\n  if (dot(a, b) < 0)\n    return ONLINE_BACK;\n  if (a.norm() < b.norm())\n    return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nvoid printd(Direction d) {\n  switch (d) {\n  case COUNTER_CLOCKWISE:\n    printf(\"COUNTER_CLOCKWISE\\n\");\n    break;\n  case CLOCKWISE:\n    printf(\"CLOCKWISE\\n\");\n    break;\n  case ONLINE_BACK:\n    printf(\"ONLINE_BACK\\n\");\n    break;\n  case ONLINE_FRONT:\n    printf(\"ONLINE_FRONT\\n\");\n    break;\n  case ON_SEGMENT:\n    printf(\"ON_SEGMENT\\n\");\n    break;\n  }\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return ccw(s1.v1, s1.v2, s2.v1) * ccw(s1.v1, s1.v2, s2.v2) <= 0 &&\n  ccw(s2.v1, s2.v2, s1.v1) * ccw(s2.v1, s2.v2, s1.v2) <= 0;\n}\n\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) {\n    return 0;\n  }\n  return min({distance(s1, s2.v1), distance(s1, s2.v2), distance(s2, s1.v1),\n              distance(s2, s1.v2)});\n}\n\nint main() {\n  int nq;\n  cin >> nq;\n  for (int i = 0; i < nq; i++) {\n    Segment seg[2];\n    for (int j = 0; j < 2; j++) {\n      int x0, y0, x1, y1;\n      cin >> x0 >> y0 >> x1 >> y1;\n      seg[j] = Segment(Vector(x0, y0), Vector(x1, y1));\n    }\n    printf(\"%d\\n\", intersect(seg[0], seg[1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//id of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\nint main()\n{\n\t//Segment s;\n\t//cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n\tint q;cin>>q;\n\t//Point a;\n\tSegment s1,s2;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y>>s2.p1.x>>s2.p1.y>>s2.p2.x>>s2.p2.y;\n\t\tif(intersect(s1,s2))cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint projection(Point p1, Point p2, Point p0){\n    if(p1 == p0){\n        return p0;\n    }\n    if(p2 == p0){\n        return p0;\n    }\n    return p1 + (p2 - p1) / (p2 - p1).abs() * (p0 - p1).abs() * getCos(p2 - p1, p0 - p1);\n}\n\nPoint reflection(Point p1, Point p2, Point p0){\n    Point p = projection(p1, p2, p0);\n    return p0 + (p - p0) * 2;\n}\n\ndouble getDistanceSP(Point p1, Point p2, Point p0){\n    if(dot(p2 - p1, p0 - p1) < 0.0) return (p0 - p1).abs();\n    if(dot(p1 - p2, p0 - p2) < 0.0) return (p0 - p2).abs();\n    return (projection(p1, p2, p0) -  p0).abs();\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 3\n#define ONLINE_FRONT 4\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    if(counterClockwise(p1, p2, p3) * counterClockwise(p1, p2, p4) <= 0){\n        return true;\n    }\n\n    if(counterClockwise(p3, p4, p2) * counterClockwise(p3, p4, p1) <= 0){\n        return true;\n    }\n    return false;\n}\n\ndouble getDistance(Point p0, Point p1, Point p2, Point p3){\n    if(intersect(p0, p1, p2, p3)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(p0, p1, p2), getDistanceSP(p0, p1, p3)),\n                min(getDistanceSP(p2, p3, p0), getDistanceSP(p2, p3, p1)));\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n        \n        Point p0 = Point(xp0, yp0);\n        Point p1 = Point(xp1, yp1);\n        Point p2 = Point(xp2, yp2);\n        Point p3 = Point(xp3, yp3);\n\n        if(intersect(p0, p1, p2, p3)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n}\n\n/*\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n\n        printf(\"%.10f\\n\", getDistance(Point(xp0, yp0), Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3)));\n    }\n\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n//#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n//#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nint main(){\n    int n;\n\n    cin >> n;\n    while(n--){\n        double a[8];\n        rep(i,8) cin >> a[i];\n\n        cout << isIntersectedLs(Point(a[0], a[1]), Point(a[2], a[3]), Point(a[4], a[5]), Point(a[6], a[7])) << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* Header {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long readtype;\ntypedef long long var;\ntypedef long double let;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n#ifdef LOCAL_LOGGER\n#define logger(...) fprintf(stderr, __VA_ARGS__)\n#define abortif(v, ...) if (v) {logger(\"Error in Line %d, Function '%s()'.\\nInfo: \", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}\n#else\n#define logger(...);\n#define abortif(v, ...);\n#endif\n/* }}} */\n\nconst let EPS = 1e-8;\n\nint sign(let x) { return (x < -EPS) ? -1 : (x > EPS ? 1 : 0); }\n\nstruct Point {\n  let x, y;\n  friend Point operator + (Point a, Point b) {\n    return (Point) {a.x + b.x, a.y + b.y};\n  }\n  friend Point operator - (Point a, Point b) {\n    return (Point) {a.x - b.x, a.y - b.y};\n  }\n  friend let Times(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n  }\n  Point operator * (let k) { return (Point) {x * k, y * k}; }\n  Point operator ~ () {\n    return (Point) {x, -y};\n  }\n  Point Rotate(let sink, let cosk) {\n    return (Point) {\n      x * cosk - y * sink, x * sink + y * cosk\n    };\n  }\n  let dist() {\n    return sqrt(x * x + y * y);\n  }\n};\n\ntypedef Point Vec;\n\nstruct Segment {\n  Point s, e;\n  Vec v;\n\n  Segment() {}\n  Segment(Point a, Point b) {\n    s = a, e = b;\n    v = b - a;\n  }\n  Segment(Point a, Point b, Vec c) {\n    s = a, e = b, v = c;\n  }\n\n  Segment Rotate(Vec v) {\n    let z = v.dist();\n    return Rotate(v.y / z, v.x / z);\n  }\n\n  Segment Rotate(let sink, let cosk) {\n    return (Segment) {\n      s.Rotate(sink, cosk), e.Rotate(sink, cosk), v.Rotate(sink, cosk)\n    };\n  }\n\n  Segment operator + (Vec b) {\n    return (Segment) {s + b, e + b, v};\n  }\n\n  Segment operator - (Vec b) {\n    return (Segment) {s - b, e - b, v};\n  }\n\n  friend bool CheckIntersection(Segment a, Segment b) {\n    let ar = a.v.dist();\n    Segment c = (b - a.s).Rotate(~a.v);\n\n    int tcs = sign(Times(c.s, (Point) {ar, 0})),\n        tce = sign(Times(c.e, (Point) {ar, 0}));\n\n    if (tcs == 0 && tce == 0) {\n      if (sign(max(c.s.x, c.e.x)) < 0 ||\n          sign(min(c.s.x, c.e.x) - ar) > 0) return false;\n      return true;\n    }\n\n    if (tcs == tce) return false;\n\n    Point i = c.e - c.v * (c.e.y / c.v.y);\n    if (sign(i.x) < 0 || sign(i.x - ar) > 0) return false;\n    return true;\n  }\n};\n\nPoint ReadPoint() {\n  Point t;\n  scanf(\"%Lf%Lf\", &t.x, &t.y);\n  return t;\n}\n\nint main() {\n// #ifndef ONLINE_JUDGE\n//   freopen(\"CGL_2_B.in\", \"r\", stdin);\n//   freopen(\"CGL_2_B.out\", \"w\", stdout);\n// #endif\n// #ifdef LOCAL_LOGGER\n//   freopen(\"CGL_2_B.log\", \"w\", stderr);\n// #endif\n  int q = read();\n  while (q--) {\n    Point p0 = ReadPoint(),\n          p1 = ReadPoint(),\n          p2 = ReadPoint(),\n          p3 = ReadPoint();\n    Segment s1 = (Segment) {p0, p1},\n            s2 = (Segment) {p2, p3};\n    if (CheckIntersection(s1, s2))\n      puts(\"1\");\n    else puts(\"0\");\n  }\n  return 0;\n}\n\n/* ==== Makefile ==== {{{\nCompileAndRun:\n\tmake Compile\n\tmake Run\n\nCompile:\n\tg++ -o CGL_2_B CGL_2_B.cpp -g -Wall -DLOCAL_LOGGER\n\nCompileUF:\n\tg++ -o CGL_2_B CGL_2_B.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined\n\nRun:\n\t./CGL_2_B < CGL_2_B.in > CGL_2_B.out\n==================\n}}} */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs(a)-fabs(b)<EPS)\n\nusing namespace std;\n\nclass Point{\npublic:\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point &p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point &p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double a) { return Point(x*a,y*a); }\n    Point operator / (double a) { return Point(x/a,y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point &p) const {\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n    }\n};\n\ntypedef Point Vector;\n\n///Program 16.3 表示线段的结构体\nstruct Segment{\n    Point p1,p2;\n};\n\n///Program 16.4 表示直线的结构体\ntypedef Segment Line;\n\n///内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n///外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)  {//printf(\"COUNTER_CLOCKWISE\\n\");\n            return 1;}///p2位于p0-->p1的逆时针方向\n    if(cross(a,b)<-EPS) {//printf(\"CLOCKWISE\\n\");\n        return -1;}///p2位于p0-->p1的顺时针方向\n    if(dot(a,b)<-EPS)   {//printf(\"ONLINE_BACK\\n\");\n        return 2;}///p2位于线段p0p1后方\n    if(a.norm()<b.norm())  { //printf(\"ONLINE_FRONT\\n\");\n        return -2;}///p2位于线段p0p1前方\n\n  //  printf(\"ON_SEGMENT\\n\");///p2位于线段p0p1的中间\n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0&&\n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main()\n{\n    Point p0,p1,p2,p3;\n    int q;\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p0.x,&p0.y,&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y);\n        printf(\"%d\\n\",intersect(p0,p1,p2,p3));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point p1 = z2 * conj(z1);\n        Point p2 = z3 * conj(z1);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n\n        if (p1.imag() * p2.imag() > 0 \n            || (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() > 0 \n            || p1.imag() == 0 && p2.imag() == 0 \n               && (p1.real() - abs(z1) * abs(z1)) * (p2.real() - abs(z1) * abs(z1)) > 0)\n            cout << \"0\\n\";\n        else cout << \"1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////????????????\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////?°???±??¨????°?\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n\n\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n/*\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}*/\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nint main(void){\n    int q;\n    cin >> q;\n    REP(i,q){\n       int x1,x2,x3,x4,y1,y2,y3,y4;\n       cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n       Line s1,s2;\n       s1 = Line(Point(x1,y1),Point(x2,y2));s2 = Line(Point(x3,y3),Point(x4,y4));\n       printf(\"%d\\n\",is_intersection_ss(s1,s2));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n  static bool crossing(P p1,P p2,P q1,P q2)\n  {\n    double x=(q2-q1).det(q1-p1)/(q2-q1).det(p2-p1);\n    double y=(p2-p1).det(p1-q1)/(p2-p1).det(q2-q1);\n    return x<=1 && x>=0 && y<=1 && y>=0;\n  }\n};\n\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\nint main(){\nint n;\ncin>>n;\ndouble a1,a2,a3,a4,a5,a6,a7,a8;\n\nPoint p0,p1,p2,p3;\nVector v01,v31,v02,v03,v23,v21,v20;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8;\np0.x=a1,p0.y=a2;\np1.x=a3,p1.y=a4;\np2.x=a5,p2.y=a6;\np3.x=a7,p3.y=a8;\nv01=p0-p1;\nv02=p0-p2;\nv03=p0-p3;\nv23=p2-p3;\nv21=p2-p1;\nv20=p2-p0;\nv31=p3-p1;\nif(cross(v01,v02)==0 && cross(v01,v03)==0){\nif(dot(v03,v02)<=0|| dot(v21,v31)<=0) cout<<\"1\"<<endl;\n\nelse cout<<\"0\"<<endl;\n//cout<<dot(v03,v02)<<\" \"<<dot(v21,v31)<<endl;\n}\nelse if(cross(v01,v02)*cross(v01,v03)<=0 && cross(v23,v21)*cross(v23,v20)<=0) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( onSP(S(a,b),p) )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\nP input(){\n  int x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    P s,t;\n    s=input(), t=input();\n    P a,b;\n    a=input(), b=input();\n    \n    cout<< isCrossSS( S(s,t) , S(a,b) ) <<endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing u64 = uint_fast64_t; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//////////////////////////////////////////////////////////////////////////////\n\nusing DD = double; // 精度が足りないときはlong double\nconstexpr DD EPS = 1e-11;\n\ninline int sgn(DD a) {return (a < -EPS) ? -1 : (a > EPS) ? 1 : 0;}\n\n//点\nstruct Point {\n    DD x, y;\n    Point (DD x = 0, DD y = 0): x(x), y(y) {}\n\n    Point operator+(const Point &p) const { return Point(*this) += p;}\n    Point operator-(const Point &p) const { return Point(*this) -= p;}\n    Point operator*(const Point &p) const { return Point(*this) *= p;}\n    Point operator*(DD a) const { return Point(*this) *= a;}\n    Point operator/(DD a) const { return Point(*this) /= a;}\n    Point& operator+=(const Point &p) { x += p.x; y += p.y; return *this;}\n    Point& operator-=(const Point &p) { x -= p.x; y -= p.y; return *this;}\n    Point& operator*=(const Point &p) { DD u = x*p.x - y*p.y; DD v = x*p.y + y*p.x; x = u; y = v; return *this;}\n    Point& operator*=(DD a) { x *= a; y *= a; return *this;}\n    Point& operator/=(DD a) { x /= a; y /= a; return *this;}\n    bool operator== (const Point &p) const { return !sgn(x - p.x) && !sgn(y - p.y);}\n    bool operator!= (const Point &p) const { return sgn(x - p.x) || sgn(y - p.y);}\n    bool operator< (const Point &p) const {\n        if (sgn(x - p.x)) return sgn(x - p.x) < 0;\n        return sgn(y - p.y) < 0;\n    }\n    friend istream& operator >>(istream& is, Point& p) { is >> p.x >> p.y; return is;}\n    friend ostream& operator <<(ostream& os, const Point& p) { os << p.x << \" \" << p.y; return os;}\n\n    DD norm() { return x*x + y*y;}\n    DD abs() { return sqrt(norm());}\n    DD arg() { return atan2(y,x);}\n};\n\n//ベクトル\nusing Vector = Point;\n\ninline DD norm(const Vector &a) { return a.x * a.x + a.y * a.y;}\ninline DD abs(const Vector &a) { return sqrt(norm(a));}\ninline DD dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y;}\ninline DD cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x;}\ninline Point rot(const Point &p, DD arg) { return Point(cos(arg) * p.x - sin(arg) * p.y, sin(arg) * p.x + cos(arg) * p.y);}\ninline Point rot90(const Point &p) { return Point(-p.y, p.x);}\ninline DD arg(const Vector &p) { return atan2(p.y, p.x);}\n//象限\nint ort(const Point &a) {\n    if (sgn(norm(a))) {\n        if (sgn(a.y) > 0) return sgn(a.x) > 0 ? 1 : 2;\n        return sgn(a.x) > 0 ? 4 : 3;\n    }\n    return 0;\n}\nbool xsort(const Point &a, const Point &b) {\n    if (sgn(a.x - b.x)) return sgn(a.x - b.x) < 0;\n    return sgn(a.y - b.y) < 0;\n}\nbool ysort(const Point &a, const Point &b) {\n    if (sgn(a.y - b.y)) return sgn(a.y - b.y) < 0;\n    return sgn(a.x - b.x) < 0;\n}\n\nbool argsortcross(const Point &a, const Point &b) {\n    int ao = ort(a), bo = ort(b);\n    if (ao != bo) return ao < bo;\n    return sgn(cross(a,b)) > 0;\n}\n\nbool argsortatan2(const Point &a, const Point &b) {\n    return sgn(atan2(b.y, b.x) - atan2(a.y, a.x)) > 0;\n}\n\n//線分\nstruct Segment {\n    Point p1,p2;\n    Segment() {};\n    Segment(Point p1, Point p2) : p1(p1),p2(p2) {}\n};\n\n//直線\nusing Line = Segment;\n\n// 円\nstruct Circle {\n    Point c;\n    DD r;\n    Circle(){}\n    Circle(Point c, DD r): c(c), r(r) {}\n    friend istream& operator >>(istream& is, Circle& C) { is >> C.c >> C.r; return is;}\n    friend ostream& operator <<(ostream& os, const Circle& C) { os << C.c << \" \" << C.r; return os;}\n};\n\n//多角形\nusing Polygon = vector<Point>;\n\n//点の進行方向\nint ccw(const Point &p0, const Point &p1, const Point &p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (sgn(cross(a,b)) > 0) return 1; //p0,p1から見てp2は左側(反時計回り)\n    if (sgn(cross(a,b)) < 0) return -1; //p0,p1から見てp2は右側(時計回り)\n    if (sgn(dot(a,b)) < 0) return 2; //p2-p0-p1の順に一直線上\n    if (sgn(norm(b) - norm(a)) > 0) return -2; //p0-p1-p2の順に一直線上\n    return 0; //p0-p2-p1の順に一直線上\n}\n\n//直線の交差判定 交差する場合1, 平行な場合0, 同一直線のとき-1\nint intersectLP(const Vector &a, const Vector &b) {\n    if (sgn(cross(a,b))) return 1;\n    if (sgn(dot(a,b))) return 0;\n    return -1;\n} \nint intersectLP(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return intersectLP(p2-p1,p4-p3);}\nint intersectLP(const Line &l1, const Line &l2) {return intersectLP(l1.p1,l1.p2,l2.p1,l2.p2);}\n\n//直線の平行判定\nbool isParallel(const Vector &a, Vector &b) {return intersectLP(a,b) <= 0;}\nbool isParallel(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return intersectLP(p1,p2,p3,p4) <= 0;}\nbool isParallel(const Line &l1, const Line &l2) {return intersectLP(l1,l2) <= 0;}\n\n//直線の直交判定\nbool isOrthogonal(const Vector &a, const Vector &b) {return !sgn(dot(a,b));}\nbool isOrthogonal(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return isOrthogonal(p2-p1,p4-p3);}\nbool isOrthogonal(const Line &l1, const Line &l2) {return isOrthogonal(l1.p1,l1.p2,l2.p1,l2.p2);}\n\n//線分の交差判定\nbool intersectSP(const Point &p1, const Point &p2, const Point &p3, const Point &p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);}\nbool intersectSP(const Segment &s1, const Segment &s2) { return intersectSP(s1.p1, s1.p2, s2.p1, s2.p2);}\n\n//射影\nPoint project(const Segment &s, const Point &p) {\n    Vector base = s.p2 - s.p1;\n    DD r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//線対称\nPoint reflect(const Segment &s, const Point &p) {return p + (project(s,p) - p) * 2;}\n\ninline DD getDistanceLP(const Line &l, const Point &p) { return abs(cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1));}\nDD getDistanceSP(const Segment &s, const Point &p) {\n    if (dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\nDD getDistance(const Segment &s1, const Segment &s2) {\n    if (intersectSP(s1, s2)) return (DD)0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n//線分と線分の交点\nPoint getCrossPoint(const Segment &s1, const Segment &s2) {\n    Vector base = s2.p2 - s2.p1;\n    DD d1 = abs(cross(base, s1.p1 - s2.p1));\n    DD d2 = abs(cross(base, s1.p2 - s2.p1));\n    DD t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//円と直線の交差判定\ninline bool intersect(const Circle &c, const Line &l) { return getDistanceLP(l, c.c) - c.r < EPS;}\n//円と円の交差判定\ninline bool intersect(const Circle &c1, const Circle &c2) { return abs(c1.c - c2.c) - (c1.r + c2.r) < EPS && fabs(c1.r - c2.r) - abs(c1.c - c2.c) < EPS;}\n\n//円と線分の交点\npair<Point, Point> getCrossPoints(const Circle &c, const Line &l) {\n    assert(intersect(c,l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    DD base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ninline Vector polar(DD a, DD r) { return Point(cos(r) * a, sin(r) * a);}\n\n//円と円の交点\npair<Point, Point> getCrossPoints(const Circle &c1, const Circle &c2) {\n    assert(intersect(c1, c2));\n    DD d = abs(c1.c - c2.c);\n    DD a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (DD(2) * c1.r * d));\n    DD t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//多角形の面積\nDD area(const Polygon &g) {\n    const int N = g.size();\n    DD ret = 0;\n    for (int i = 0; i < N; ++i) {\n        ret += cross(g[i],g[(i+1)%N]);\n    }\n    return fabs(ret)/2;\n}\n\n// 多角形-点の包含判定\nint containment(const Polygon &g, const Point &p) {\n    const int N = g.size();\n    int cnt = 0;\n    for (int i = 0; i < N; ++i) {\n        if (norm(g[i] - p) < EPS || norm(g[(i+1)%N] - p) < EPS || ccw(g[i], g[(i+1)%N], p) == 0) {\n            return 1; // pがgの辺上に存在する\n        }\n        Point I = Point(2e9 + p.x, 2e9 + 574677631 + p.y);\n        if (ccw(I, p, g[i]) == 0 || ccw(I, p, g[(i+1)%N]) == 0) continue;\n        if (intersectSP(I, p, g[i], g[(i+1)%N])) ++cnt;\n    }\n    if (cnt&1) return 2; // pがgに含まれる\n    else return 0; // pがgに含まれない\n}\n\n//凸包\nPolygon andrewScan(Polygon s) {\n    Polygon u,l;\n    const int N = s.size();\n    if (N < 3) return s;\n    sort(s.begin(), s.end(), xsort);\n    u.emplace_back(s[0]);\n    u.emplace_back(s[1]);\n    l.emplace_back(s[N-1]);\n    l.emplace_back(s[N-2]);\n    \n    for (int i = 2; i < s.size(); ++i) {\n        // 凸包上の点も含めるなら ccw() == 1\n        for (int n = u.size(); n >= 2 && ccw(u[n-2],u[n-1],s[i]) != -1; --n) {\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for (int i = N - 3; i >= 0; --i) {\n        // 凸包上の点も含めるなら ccw() == 1\n        for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != -1; --n) {\n            l.pop_back();\n        }\n        l.emplace_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i) l.emplace_back(u[i]);\n\n    return l;\n}\n\n//最遠点対\nDD farthestpointpair(const Polygon &g) {\n    const int N = g.size();\n    if (N == 2) return abs(g[1] - g[0]);\n    int i = 0, j = 0;\n    for (int k = 0; k < N; ++k) {\n        if (g[k].y > g[i].y) i = k;\n        if (g[k].y < g[j].y) j = k;\n    }\n\n    DD ret = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        ret = max(ret, abs(g[i]-g[j]));\n        if (cross(g[(i+1)%N] - g[i], g[(j+1)%N] - g[j]) < -EPS) {\n            i = (i+1)%N;\n        } else {\n            j = (j+1)%N;\n        }\n    }\n\n    return ret;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid CGL_1_A() {\n    Point p1,p2; cin >> p1 >> p2;\n    Line l(p1,p2);\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p; cin >> p;\n        cout << project(l,p) << ln;\n    }\n}\n\nvoid CGL_1_B() {\n    Point p1,p2; cin >> p1 >> p2;\n    Line l(p1,p2);\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p; cin >> p;\n        cout << reflect(l,p) << ln;\n    }\n}\n\nvoid CGL_1_C() {\n    Point p0,p1; cin >> p0 >> p1;\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p2; cin >> p2;\n        int v = ccw(p0,p1,p2);\n        string ans;\n        if (v==1) ans = \"COUNTER_CLOCKWISE\";\n        if (v==-1) ans = \"CLOCKWISE\";\n        if (v==2) ans = \"ONLINE_BACK\";\n        if (v==-2) ans = \"ONLINE_FRONT\";\n        if (v==0) ans = \"ON_SEGMENT\";\n        cout << ans << ln;\n    }\n}\n\nvoid CGL_2_A() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        if (isParallel(p0,p1,p2,p3)) cout << 2 << ln;\n        else if (isOrthogonal(p0,p1,p2,p3)) cout << 1 << ln;\n        else cout << 0 << ln;\n    }\n}\n\nvoid CGL_2_B() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        cout << intersectSP(p0,p1,p2,p3) << ln;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    cout << fixed << setprecision(20);\n    //CGL_1_A();\n    //CGL_1_B();\n    //CGL_1_C();\n    //CGL_2_A();\n    CGL_2_B();\n}\n\n/*\n  verified on 2020/06/02\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n\nint main(){\n    \n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    \n    int q;\n    \n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        Point p0 = Point(x0, y0);\n        Point p1 = Point(x1, y1);\n        Point p2 = Point(x2, y2);\n        Point p3 = Point(x3, y3);\n        \n        \n        if( intersect(p0, p1, p2, p3) ) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0) return 0;\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tr.print();\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <iomanip>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\n#define NAN_M 0x800000000000\n#define EPS 0.0000000001\n\nclass Position {\npublic:\n    enum Positions {\n        COUNTER_CLOCKWISE = -1,\n        CLOCKWISE = 1,\n        ONLINE_BACK,\n        ONLINE_FRONT,\n        ON_SEGMENT = 0\n    };\n\n    string ToString(enum Positions e) {\n        switch (e) {\n            case COUNTER_CLOCKWISE:\n                return \"COUNTER_CLOCKWISE\";\n            case CLOCKWISE:\n                return \"CLOCKWISE\";\n            case ONLINE_BACK:\n                return \"ONLINE_BACK\";\n            case ONLINE_FRONT:\n                return \"ONLINE_FRONT\";\n            case ON_SEGMENT:\n                return \"ON_SEGMENT\";\n        }\n    }\n};\n\ntemplate<class T>\nclass Vector2D {\npublic:\n    T x;\n    T y;\n\n    Vector2D() {\n        x = y = 0;\n    }\n\n    Vector2D(T x_, T y_) {\n        x = x_;\n        y = y_;\n    }\n\n    T operator*(const Vector2D<T> *e) {\n        return this->x * e->x + this->y * e->y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x - e->x, this->y - e->y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x + e->x, this->y + e->y);\n    }\n\n    T operator*(const Vector2D<T> e) {\n        return this->x * e.x + this->y * e.y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> e) {\n        return Vector2D<T>(this->x - e.x, this->y - e.y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> e) {\n        return Vector2D<T>(this->x + e.x, this->y + e.y);\n    }\n\n    Vector2D<T> operator*(const T r) {\n        return Vector2D<T>(this->x * r, this->y * r);\n    }\n\n    Vector2D<T> operator/(const T r) {\n        return Vector2D<T>(this->x / r, this->y / r);\n    }\n\n    Vector2D<T> operator-() {\n        return Vector2D<T>(-this->x, -this->y);\n    }\n\n    double abs() {\n        return sqrt(x * x + y * y);\n    }\n\n    T norm() {\n        return x * x + y * y;\n    }\n\n    T crossP(Vector2D<T> e) {\n        if (x * e.y >= y * e.x) return (x * e.y) - (y * e.x);\n        else return (y * e.x) - (x * e.y);\n    }\n\n    T cross(Vector2D<T> e) {\n        return (y * e.x) - (x * e.y);\n    }\n\n    double cos(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return (e * (*this)) / (e.abs() * abs());\n    }\n\n    double sin(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return ((x * e.y) - (y * e.x)) / (e.abs() * abs());\n    }\n};\n\ntemplate<class T>\nclass Point2D : public Vector2D<T> {\npublic:\n};\n\ntemplate<class T>\nclass Line2D {\npublic:\n    Point2D<T> p1, p2;\n    Line2D(Point2D<T> p1_,Point2D<T> p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Vector2D<T> getVector() {\n        return p2 - p1;\n    }\n\n    Point2D<T> getProject(Point2D<T> p) {\n        Vector2D<T> base = getVector();\n        return p1 + base * ((p - p1) * base) / base.norm();\n    }\n\n    Point2D<T> reflect(Point2D<T> p) {\n        return p + (getProject(p) - p) * 2;\n    }\n\n    virtual double getDistance(Point2D<T> p) {\n        return (p2 - p1).crossP(p - p1) / (p2 - p1).abs();\n    }\n};\n\ntemplate<class T>\nclass Segment2D : public Line2D<T> {\npublic:\n    using Line2D<T>::p1;\n    using Line2D<T>::p2;\n    using Line2D<T>::Line2D;\n    double getDistance(Point2D<T> p) override{\n        if ((p2 - p1).cross(p - p1) < 0) return (p - p1).abs();\n        if ((p1 - p2).cross(p - p1) < 0) return (p - p1).abs();\n        return Line2D<T>::getDistance(p);\n    }\n\n    Position::Positions ccw(Point2D<T> p) {\n        Vector2D<T> a = Line2D<T>::getVector();\n        Vector2D<T> b = p - p1;\n        if (a.cross(b) > EPS) return Position::Positions::COUNTER_CLOCKWISE;\n        if (a.cross(b) < -EPS) return Position::Positions::CLOCKWISE;\n        if (a * b < -EPS) return Position::Positions::ONLINE_BACK;\n        if (a.norm() < b.norm()) return Position::Positions::ONLINE_FRONT;\n        return Position::Positions::ON_SEGMENT;\n    }\n\n    bool intersect(Segment2D<T> s) {\n        return (ccw(s.p1) * ccw(s.p2) <= 0 && s.ccw(p1) * s.ccw(p2) <= 0);\n    }\n\n    double getDistance(Segment2D<T> s) {\n\n    }\n};\n\nint main(void){\n    int q;\n    cin >> q;\n    loop(i,0,q){\n        Point2D<double> v[4];\n        loop(j,0,4) {\n            cin >> v[j].x >> v[j].y;\n        }\n        int res = Segment2D<double>(v[0],v[1]).intersect(Segment2D<double>(v[2],v[3]));\n        if(res) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false)return 0;\n    \n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4)return 1;\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <algorithm>\ntypedef long long int ll;\nusing namespace std;\nconst int MAX=5000+10;\nconst double eps=1e-9;\nconst double PI=acos(-1.0);\n\nint sgn(double x)\n{\n    if (fabs(x)<eps) {\n        return 0;\n    }\n    if (x<0) {\n        return -1;\n    }\n    else return 1;\n}\nstruct point\n{\n    double x,y;\n    point(){}\n    point(double _x,double _y)\n    {\n        x=_x;y=_y;\n    }\n    point operator +(const point &b)const\n    {\n        return point(x+b.x,y+b.y);\n    }\n    point operator -(const point &b)const\n    {\n        return point(x-b.x,y-b.y);\n    }\n    double operator ^(const point &b)const\n    {\n        return x*b.y-y*b.x;\n    }\n    double operator *(const point &b)const\n    {\n        return x*b.x+y*b.y;\n    }\n    point operator *(const double k)const\n    {\n        point kk;kk.x=k*x;kk.y=k*y;return kk;\n    }\n    double len(void)\n    {\n        return sqrt(x*x+y*y);\n    }\n};\n\nstruct line\n{\n    point s,e;\n    line(){}\n    line(point _s,point _e)\n    {\n        s=_s;e=_e;\n    }\n    pair<int, point> operator &(const line &b)const\n    {\n        point res=s;\n        if(sgn((s-e)^(b.s-b.e))==0){\n            if(sgn((s-b.e)^(b.s-b.e))==0){\n                return make_pair(0, res);\n            }\n            else{\n                return make_pair(1,res);\n            }\n        }\n        double t=((s-b.s)^(b.s-b.e))/((s-e)^(b.s-b.e));\n        res.x+=(e.x-s.x)*t;\n        res.y+=(e.y-s.y)*t;\n        return make_pair(2, res);\n    }\n};\n\nbool inter(line l1,line l2)\n{\n    return max(l1.s.x,l1.e.x) >= min(l2.s.x,l2.e.x) &&\n    max(l2.s.x,l2.e.x) >= min(l1.s.x,l1.e.x) &&\n    max(l1.s.y,l1.e.y) >= min(l2.s.y,l2.e.y) &&\n    max(l2.s.y,l2.e.y) >= min(l1.s.y,l1.e.y) &&\n    sgn((l2.s-l1.e)^(l1.s-l1.e))*sgn((l2.e-l1.e)^(l1.s-l1.e)) <= 0 &&\n    sgn((l1.s-l2.e)^(l2.s-l2.e))*sgn((l1.e-l2.e)^(l2.s-l2.e)) <= 0;\n}\n\nint main(){\n    //freopen(\"/Users/mac/Desktop/C++?¨????/test/test.txt\", \"r\", stdin);\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        line l1,l2;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&l1.s.x,&l1.s.y,&l1.e.x,&l1.e.y,&l2.s.x,&l2.s.y,&l2.e.x,&l2.e.y);\n        printf(\"%d\\n\",inter(l1, l2)?1:0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// CGL_2_B\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n};\n\nbool intersect(point p1, point p2, point p3, point p4){\n\tint a = (p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x);\n\tint b = (p2.x-p1.x)*(p4.y-p1.y) - (p2.y-p1.y)*(p4.x-p1.x);\n\n\tif(a*b < 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(){\n\tpoint p[4];\n\tint q;\n\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>p[0].x>>p[0].y>>p[1].x>>p[1].y>>p[2].x>>p[2].y>>p[3].x>>p[3].y;\n\n\t\tif(intersect(p[0], p[1], p[2], p[3]) && intersect(p[2], p[3], p[0], p[1]))\n\t\t\tcout<<\"1\"<<endl;\n\t\telse\n\t\t\tcout<<\"0\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - x3.x);\n    double td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - x4.x);\n    return tc * td < 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << intersect(s1, s2) ? 1 : 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-9;\n\nbool same(double a, double b) { return a == b; }\n\nstruct P {\n    double x, y;\n    P() : x(0), y(0) {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator + (P b) { return P(x + b.x, y + b.y); }\n    P operator - (P b) { return P(x - b.x, y - b.y); }\n    P operator * (double b) { return P(x * b, y * b); }\n    P operator / (double b) { return P(x / b, y / b); }\n    double operator * (P b) { return x * b.x + y * b.y; }\n    double operator ^ (P b) { return x * b.y - y * b.x; }\n    double abs() { return hypot(x, y); }\n    P unit() { return *this / abs(); }\n};\n\nstruct L{\n    // ax + by + c = 0\n    double a, b ,c, o;\n    P pa, pb;\n    L() : a(0), b(0), c(0), o(0), pa(), pb() {}\n    L(P pa, P pb) : a(pa.y - pb.y), b(pb.x - pa.x), c(pa ^ pb), o(atan2(-a, b)), pa(pa), pb(pb) {}\n    P project(P p) { return pa + (pb - pa).unit() * ((pb - pa) * (p - pa) / (pb - pa).abs()); }\n    P reflect(P p) { return p + (project(p) - p) * 2; }\n    double get_ratio(P p) { return (p - pa) * (pb - pa) / ((pb - pa).abs() * (pb - pa).abs()); }\n    bool inside(P p) {\n        double z = get_ratio(p);\n        return z >= 0 && z <= 1;\n    }\n};\n\nbool parallel(L x, L y) { return same(x.a * y.b, x.b * y.a); }\n\nP intersect(L x, L y) { return P(-x.b * y.c + x.c * y.b, x.a * y.c - x.c * y.a) / (-x.a * y.b + x.b * y.a); }\n\nint main() {\n    int q; cin >> q; while (q--) {\n        P p[4]; \n        for (int i = 0; i < 4; ++i) cin >> p[i].x >> p[i].y;\n        if ((p[0] - L(p[2], p[3]).project(p[0])).abs() < eps && L(p[2], p[3]).inside(p[0])) cout << \"1\" << '\\n';\n        else if ((p[1] - L(p[2], p[3]).project(p[1])).abs() < eps && L(p[2], p[3]).inside(p[1])) cout << \"1\" << '\\n';\n        else if ((p[2] - L(p[0], p[1]).project(p[2])).abs() < eps && L(p[0], p[1]).inside(p[2])) cout << \"1\" << '\\n';\n        else if ((p[3] - L(p[0], p[1]).project(p[3])).abs() < eps && L(p[0], p[1]).inside(p[3])) cout << \"1\" << '\\n';\n        else if (((p[3] - p[2]) ^ (p[1] - p[2])) * ((p[3] - p[2]) ^ (p[0] - p[2])) < 0 &&\n            ((p[1] - p[0]) ^ (p[3] - p[0])) * ((p[1] - p[0]) ^ (p[2] - p[0])) < 0) {\n            cout << \"1\" << '\\n';\n        } else cout << \"0\" << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n  static bool crossing(P p1,P p2,P q1,P q2)\n  {\n    if((p2-p1).sign(q2-q1)==0) return on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2);\n    double x=(q2-q1).det(q1-p1)/(q2-q1).det(p2-p1);\n    double y=(p2-p1).det(p1-q1)/(p2-p1).det(q2-q1);\n    return x<=1 && x>=0 && y<=1 && y>=0;\n  }\n};\n\n\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//???????????????????????????????????°???\n//??????????????????????????????????????????????????????\n//references<http://qiita.com/ykob/items/ab7f30c43a0ed52d16f2>\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tlong double ax, ay, bx, by, cx, cy, dx, dy; cin >> ax >> ay >> bx >> by >> cx >> cy >> dx >> dy;\n\t\tint ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\t\tint tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\t\tint tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\t\tint td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\t\tif ((tc * td <= 0) && (ta * tb <= 0)) {\n\t\t\tcout << \"1\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"0\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-10\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\ntypedef double Type;\n\nint sign(Type x)\n{\n    return x<-EPS?-1:(x>EPS?1:0);\n}\n\nstruct Point\n{\n    Type x,y;\n    Point(Type x,Type y):x(x),y(y) {}\n    Point() {}\n    void read()\n    {\n        scanf(\"%lf %lf\",&x,&y);\n    }\n    bool operator==(const Point& p) const\n    {\n        return sign(x-p.x)==0&&sign(y-p.y)==0;\n    }\n    Point operator-(const Point& p) const\n    {\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator*(const Type t) const\n    {\n        return Point(t*x,t*y);\n    }\n    Point operator+(const Point & p) const\n    {\n        return Point(x+p.x,y+p.y);\n    }\n    bool operator<(const Point& p) const\n    {\n        return sign(x-p.x)==0?sign(y-p.y)<0:sign(x-p.x)<0;\n    }\n};\n\nostream& operator<<(ostream& out,Point p)\n{\n    out<<p.x<<\" \"<<p.y;\n    return out;\n}\n\ntypedef Point Vector;\n\nstruct Line\n{\n    Point a,b;\n    Line() {}\n    Line(Point a,Point b):a(a),b(b) {}\n};\n\ntypedef Line SegMent;\n\n//叉?\nType Cross(Vector a,Vector b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\n//点?\nType Dot(Vector a,Vector b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n\n//?度\nType Length(Vector v)\n{\n    return sqrt(v.x*v.x+v.y*v.y);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(Cross(a,b)>EPS)\n        return COUNTER_CLOCKWISE;\n    if(Cross(b,a)>EPS)\n        return CLOCKWISE;\n    if(Dot(a,b)<-EPS)\n        return ONLINE_BACK;\n    if(Length(a)<Length(b))\n        return ONLINE_FRONT;\n    if(Length(a)>Length(b))\n        return ON_SEGMENT;\n}\n\nbool intersect(SegMent s1,SegMent s2)\n{\n    if(ccw(s1.a,s1.b,s2.a)*ccw(s1.a,s1.b,s2.b)<=0 && ccw(s2.a,s2.b,s1.a)*ccw(s2.a,s2.b,s1.b)<=0)\n        return true;\n    return false;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        SegMent s1,s2;\n        s1.a.read();\n        s1.b.read();\n        s2.a.read();\n        s2.b.read();\n        if(intersect(s1,s2))\n            puts(\"1\");\n        else\n            puts(\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    double x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(double nx) {\n        x = nx;\n    }\n    \n    void setY(double ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    double cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    // ベクトルの大きさを求める\n    double norm() const {\n        return sqrt(x * x + y * y);\n    }\n    \n    // 単位ベクトルを返す\n    Vector getUnit() const {\n        Vector v;\n        double n = norm();\n        if (n == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / n, y / n);\n        }\n        return v;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (double f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (double f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n    \n    bool operator == (const Vector& vec) const {\n        if (x == vec.x && y == vec.y) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(double sx, double sy, double ex, double ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    // 指定の線分を含むか\n    // このメソッドは線分同士が平行の時しか使用しない\n    bool isInLine(const LineSegment& l) const {\n        bool b1 = isPointInLine(l.getStart());\n        bool b2 = isPointInLine(l.getEnd());\n        if (b1 || b2) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    bool isPointInLine(const Vector& p) const {\n        if (start == p) {\n            return true;\n        }\n        \n        Vector l1 = end - start;\n        Vector l2 = p - start;\n        Vector u1 = l1.getUnit();\n        Vector u2 = l2.getUnit();\n        \n        if (u1 == u2 && l2.norm() <= l1.norm()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        double c1 = l1.cross(l.getStart() - start);\n        double c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        double c3 = l2.cross(start - l.getStart());\n        double c4 = l2.cross(end - l.getStart());\n        \n        if (c1 * c2 == 0.0 && c3 * c4 == 0.0) { // 平行のとき\n            LineSegment ls;\n            ls.setStartEnd(start.x, start.y, end.x, end.y);\n            if (isInLine(l) || l.isInLine(ls)) {\n                return 1;\n            }\n            return 0;\n        } else if ((c1 * c2 < 0.0 && c3 * c4 <= 0.0)\n                   || (c1 * c2 <= 0.0 && c3 * c4 < 0.0)\n                   || (c1 * c2 < 0.0 && c3 * c4 < 0.0)) { // 交差するとき\n            return 1;\n        } else { // 交差しないとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        double sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nusing namespace std;\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y){}\n\tPoint operator + (Point p){return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p){return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);}\n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble abs() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\nstruct Segment{Point p1,p2;};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n\tVector a=p1-p0,b=p2-p0;\n\tif(cross(a,b)>EPS) return 1;\n\tif(cross(a,b)<-EPS) return -1;\n\tif(dot(a,b)<-EPS) return 2;\n\tif(a.abs()<b.abs()) return -2;\n\tif(a.abs()>=b.abs()) return 0;\n}\nbool intersect(Segment s1,Segment s2){\n\tPoint p1=s1.p1,p2=s1.p2;\n\tPoint p3=s2.p1,p4=s2.p2;\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\nmain(){\n\tint q;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tint x1,y1,x2,y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tPoint p1(x1,y1),p2(x2,y2);\n\t\tSegment s1;\n\t\ts1.p1=p1;s1.p2=p2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tPoint p3(x1,y1),p4(x2,y2);\n\t\tSegment s2;\n\t\ts2.p1=p3;s2.p2=p4;\n\t\tif(intersect(s1,s2)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <iomanip>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\n#define NAN_M 0x800000000000\n#define EPS 0.0000000001\n\ntemplate<typename T>\nclass Vector2D {\npublic:\n    T x;\n    T y;\n\n    Vector2D() {\n        x = y = 0;\n    }\n\n    Vector2D(T x_, T y_) {\n        x = x_;\n        y = y_;\n    }\n\n    T operator*(const Vector2D<T> *e) {\n        return this->x * e->x + this->y * e->y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x - e->x, this->y - e->y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x + e->x, this->y + e->y);\n    }\n\n    T operator*(const Vector2D<T> e) {\n        return this->x * e.x + this->y * e.y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> e) {\n        return Vector2D<T>(this->x - e.x, this->y - e.y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> e) {\n        return Vector2D<T>(this->x + e.x, this->y + e.y);\n    }\n\n    Vector2D<T> operator*(const T r) {\n        return Vector2D<T>(this->x * r, this->y * r);\n    }\n\n    Vector2D<T> operator/(const T r) {\n        return Vector2D<T>(this->x / r, this->y / r);\n    }\n\n    double abs() {\n        return sqrt(x * x + y * y);\n    }\n\n    T abs2() {\n        return x * x + y * y;\n    }\n\n    T cross(Vector2D<T> e) {\n        if(x * e.y >= y * e.x) return (x * e.y) - (y * e.x);\n        else return (y * e.x) - (x * e.y);\n    }\n\n    double cos(Vector2D<T> e) {\n        if((e.abs() * abs()) == 0) return NAN_M;\n        return (e * (*this)) / (e.abs() * abs());\n    }\n\n    double sin(Vector2D<T> e) {\n        if((e.abs() * abs()) == 0) return NAN_M;\n//        cout << ((x * e.y) - (y * e.x)) / (e.abs() * abs()) << endl;\n        return ((x * e.y) - (y * e.x)) / (e.abs() * abs());\n    }\n};\n\ntypedef Vector2D<double> vdd;\n\ndouble dist__(double x0, double y0, double x1, double y1, double xx, double yy) {\n    int b = 0;\n    vdd p[3] = {vdd(x0, y0), vdd(x1, y1), vdd(xx, yy)};\n    if (((p[0] - p[1]) * (p[2] - p[1])) < 0) b = -1;\n    if (((p[1] - p[0]) * (p[2] - p[0])) < 0) b = 1;\n    if (b == 1) return (p[2] - p[0]).abs();\n    if (b == -1) return (p[2] - p[1]).abs();\n    return (p[1] - p[0]).cross(p[2] - p[0]) / (p[1] - p[0]).abs();\n}\n\ndouble dist(double x0, double y0, double x1, double y1, double xx, double yy){\n    double res = dist__(x0,y0,x1,y1,xx,yy);\n    return res;\n}\n\nint main() {\n    int q;\n    cin >> q;\n    loop(i, 0, q) {\n        vdd v[4];\n        for(auto& e:v) {\n            cin >> e.x >> e.y;\n        }\n        if ((v[0] - v[1]).sin(v[2] - v[1]) * (v[0] - v[1]).sin(v[3] - v[1]) <= 0 &&\n            (v[2] - v[3]).sin(v[0] - v[3]) * (v[2] - v[3]).sin(v[1] - v[3]) <= 0){\n            if ((v[0] - v[1]).sin(v[2] - v[1]) * (v[0] - v[1]).sin(v[3] - v[1]) == 0 &&\n                   (v[2] - v[3]).sin(v[0] - v[3]) * (v[2] - v[3]).sin(v[1] - v[3]) == 0){\n                cout << 0 << endl;\n            }\n            else cout << 1 << endl;\n        }\n        else cout << 0 << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst double kEps = 1e-10;\nconst double kInf = 1e15;\n\nint dcmp(double x) {\n  if (fabs(x) < kEps) return 0;\n  return x < 0 ? -1 : 1;\n}\n\nstruct Vector {\n  double x, y;\n  Vector() {}\n  Vector(double x, double y): x(x), y(y) {}\n  // Vector(const Point & p1, const Point & p2): x(p2.x - p1.x), y(p2.y - p1.y) {}\n  Vector(const Vector & v);\n\n  double Norm() const { return hypot(x, y); }\n  double NormSquared() const { return x * x + y * y; }\n  Vector Normalize() const {\n    return *this / this->Norm();\n  }\n  Vector operator-() const {\n    return Vector(-x, -y);\n  }\n  Vector operator+(const Vector & rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n  }\n  Vector operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  Vector operator*(const double rhs) const {\n    return Vector(rhs * x, rhs * y);\n  }\n  Vector operator/(const double rhs) const {\n    return *this * (1.0 / rhs);\n  }\n  double Dot(const Vector & rhs) const {\n    return x * rhs.x + y * rhs.y;\n  }\n  double Cross(const Vector & rhs) const {\n    return x * rhs.y - y * rhs.x;\n  }\n  bool operator==(const Vector & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Vector & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Point {\n  Point() {}\n  Point(double x, double y): x(x), y(y) {}\n  Point(const Point & p);\n\n  double x, y;\n\n  Point operator-() {\n    return Point(-x, -y);\n  }\n  Point operator+(const Vector & rhs) const {\n    return Point(x + rhs.x, y + rhs.y);\n  }\n  Point operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  bool operator==(const Point & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Point & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Line {\n  Line() {}\n  Line(const Point & p1, const Point & p2): p1(p1), p2(p2) {\n    if (dcmp(p2.x - p1.x) == 0) {\n      slope = kInf;\n    } else {\n      slope = (p2.y - p1.y) / (p2.x - p1.x);\n    }\n  }\n  Line(double x1, double y1, double x2, double y2): p1(x1, y1), p2(x2, y2) {\n    if (dcmp(x2 - x1) == 0) {\n      slope = kInf;\n    } else {\n      slope = (y2 - y1) / (x2 - x1);\n    }\n  }\n  Line(const Line & l);\n\n  Point p1, p2;\n  double slope;\n};\n\n// minus: left, plus: right, 0: colinear\nint Direction(const Point & p0, const Point & p1, const Point & p2) {\n  Vector v1(p1.x - p0.x, p1.y - p0.y);\n  Vector v2(p2.x - p0.x, p2.y - p0.y);\n  return v2.Cross(v1);\n}\n\n// minus: back, plus: front, 0: on\nint SegmentDirection(const Point & p0, const Point & p1, const Point & p2) {\n  if (p2.x >= min(p0.x, p1.x) && p2.x <= max(p0.x, p1.x)\n      && p2.y >= min(p0.y, p1.y) && p2.y <= max(p0.y, p1.y)) { return 0; }\n  if ((p2.x - p0.x) * (p1.x - p0.x) > 0\n      || (p2.y - p0.y) * (p1.y - p0.y) > 0) { return 1; }\n  return -1;\n}\n\nbool IsIntersecting(const Line & l1, const Line & l2) {\n  auto d1 = Direction(l2.p1, l2.p2, l1.p1);\n  auto d2 = Direction(l2.p1, l2.p2, l1.p2);\n  auto d3 = Direction(l1.p1, l1.p2, l2.p1);\n  auto d4 = Direction(l1.p1, l1.p2, l2.p2);\n\n  if (d1 * d2 < 0 && d3 * d4 < 0) { return true; }\n  if (d1 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p1) == 0) { return true; }\n  if (d2 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p2) == 0) { return true; }\n  if (d3 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p1) == 0) { return true; }\n  if (d4 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p2) == 0) { return true; }\n  return false;\n}\n\nint main(int argc, char const *argv[]) {\n  double x0, y0, x1, y1;\n  Point p0(x0, y0);\n  Point p1(x1, y1);\n\n  int q;\n  cin >> q;\n  for (unsigned i = 0; i < q; ++i) {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    if (IsIntersecting(Line(x0, y0, x1, y1), Line(x2, y2, x3, y3))) {\n      cout << 1 << \"\\n\";\n    } else {\n      cout << 0 << \"\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<=min(x[3],x[4])||min(x[1],x[2])>=max(x[3],x[4])||max(y[1],y[2])<=min(y[3],y[4])||min(y[1],y[2])>=max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<=0&&p3*p4<=0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define MP make_pair\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSegment(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\nint main(){\n\tint n;cin>>n;\n\trep(i,0,n){\n\t\tP p1,p2,q1,q2;\n\t\tp1.read(),p2.read(),q1.read(),q2.read();\n\n\t\tcout<<isSS(p1,p2,q1,q2)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nint main()\n{\n\tint q;\n\tld x1, x2, x3, x4, y1, y2, y3, y4;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tLine l1 = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tLine l2 = { (Point) { x3, y3 }, (Point) { x4, y4 } };\n\t\tcout << isis_ss(l1, l2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n}\nusing namespace Ps;\n\nnamespace Ls{\n    struct L : public vector<P> {\n        Vec vec;\n        L(const P &a, const P &b):vec(b - a){\n            push_back(a); push_back(b);\n        }\n    };\n\n    // verified by ACAC003 B\n    // http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899178&cid=ACAC003\n    bool isIntersectSS(const L &s, const L &t) {\n      return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n             ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n    }\n}\nusing namespace Ls;\n\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        \n        int q;cin >> q;\n        REP(i,q){\n            P a,b;cin >> a >> b;L l1(a,b);\n            P c,d;cin >> c >> d;L l2(c,d);\n            cout << isIntersectSS(l1, l2)<<endl;\n        }\n    }\n};\n\nint main(){\n cout <<fixed<<setprecision(20);\n cin.tie(0);\n ios::sync_with_stdio(false);\n Main().run();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\nint argtype(const Point&);//(-pi,0]->0,(0,pi]->1\nbool argless(const Point&,const Point&);//sorting points with arg\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&);\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\nint argtype(const Point&a)\n{\n\treturn a.y<-EPS?0:a.y>EPS?1:a.x<0?1:0;\n}\nbool argless(const Point&a,const Point&b)\n{\n\tint at=argtype(a),bt=argtype(b);\n\treturn at!=bt?at<bt:ccw(a,b)>0;\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b)\n{\n\treturn cross(a,b)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(a,b)<-EPS?CLOCKWISE\n\t\t:dot(a,b)<0?ONLINE_BACK\n\t\t:norm(a)<norm(b)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Point&a,const Point&b,const Point&c){return ccw(b-a,c-a);}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n    int q;cin>>q;\n    for(;q--;)\n    {\n        Segment s1,s2;\n        cin>>s1.p1>>s1.p2>>s2.p1>>s2.p2;\n        cout<<intersect(s1,s2)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include \"stdio.h\"\n#include <cstdlib>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string>\n\nusing namespace std;\nusing NUM = long double;\n\ntemplate<typename T>\nstruct Point {\n\tT x, y;\n\tPoint<T> operator+(const Point<T>& rhs)const {\n\t\tPoint<T> p;\n\t\tp.x = this->x + rhs.x;\n\t\tp.y = this->y + rhs.y;\n\t\treturn p;\n\t}\n\tPoint<T> operator-(const Point<T>& rhs)const {\n\t\tPoint<T> p;\n\t\tp.x = this->x - rhs.x;\n\t\tp.y = this->y - rhs.y;\n\t\treturn p;\n\t}\n\tPoint<T> operator*(const T rhs) const {\n\t\tPoint<T> p;\n\t\tp.x = this->x * rhs;\n\t\tp.y = this->y * rhs;\n\t\treturn p;\n\t}\n\tPoint<T> operator-() const {\n\t\tPoint<T> p;\n\t\tp.x = this->x * -1.0;\n\t\tp.y = this->y * -1.0;\n\t\treturn p;\n\t}\n};\n\ntemplate<typename T>\nPoint<T> operator*(const T val, const Point<T>& p)\n{\n\treturn p*val;\n}\n\ntemplate<typename T>\nstruct Segment {\n\tPoint<T> p1, p2;\n};\n\ntemplate<typename T>\nbool isZero(const T val)\n{\n\treturn fabs(val) < 1e-10;\n}\n\ntemplate<typename T>\nT innerProduct(const Point<T>& p0, const Point<T>& p1)\n{\n\tdouble x0 = p0.x;\n\tdouble y0 = p0.y;\n\tdouble x1 = p1.x;\n\tdouble y1 = p1.y;\n\treturn x0 * x1 + y0 * y1;\n}\n\ntemplate<typename T>\nT outerProduct(const Point<T>& p0, const Point<T>& p1)\n{\n\tdouble x0 = p0.x;\n\tdouble y0 = p0.y;\n\tdouble x1 = p1.x;\n\tdouble y1 = p1.y;\n\treturn x0 * y1 - y0 * x1;\n}\n\ntemplate<typename T>\nT norm(const Point<T>& p)\n{\n\tdouble x = p.x;\n\tdouble y = p.y;\n\treturn x*x + y*y;\n}\n\ntemplate<typename T>\nT absolute(const Point<T>& p)\n{\n\treturn sqrt(norm(p));\n}\n\ntemplate<typename T>\nvoid readPoint(Point<T>& p)\n{\n\tcin >> p.x;\n\tcin >> p.y;\n}\n\ntemplate<typename T>\nvoid readSegment(Segment<T>& s)\n{\n\tcin >> s.p1.x;\n\tcin >> s.p1.y;\n\tcin >> s.p2.x;\n\tcin >> s.p2.y;\n}\n\n//template<typename T>\n//void outputComponentesOfPoint(const Point<T>& p)\n//{\n//\tcout << fixed;\n//\tcout << setprecision(8) << p.x;\n//\tcout << \" \";\n//\tcout << setprecision(8) << p.y;\n//\tcout << endl;\n//}\n\n//template<typename T>\n//T getDistanceFromPointToLine(const Segment<T>& s, const Point<T>& p) {\n//\tconst Point<T> a = p - s.p1;\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst Point<T> outer = outerProduct(a, b);\n//\treturn outer / absolute(b);\n//}\n\n//template<typename T>\n//T distance(const Point<T>& p1, const Point<T>& p2)\n//{\n//\treturn absolute(p2 - p1);\n//}\n//\n//template<typename T>\n//T getDistanceFromPointToSegment(const Point<T>& p, const Segment<T>& s) {\n//\tconst T zero = static_cast<T>(0);\n//\tconst Point<T> a = p - s.p1;//本当は使いまわせる\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst Point<T> c = p - s.p2;\n//\tconst T innerAB = innerProduct(a, b);\n//\tconst T innerc_b = innerProduct(c, -b);\n//\n//\tT aaa = distance(p, s.p1);\n//\tT bbb = distance(p, s.p2);\n//\tT ccc = fabs(outerProduct(a, b) / absolute(b));\n//\tif (innerAB < zero) {\n//\t\treturn distance(p, s.p1);\n//\t}\n//\telse if (innerc_b < zero) {\n//\t\treturn distance(p, s.p2);\n//\t}\n//\telse {\n//\t\treturn fabs(outerProduct(a, b) / absolute(b) );\n//\t}\n//}\n//\n\ntemplate<typename T>\ndouble getParameterOfProjectedPointToSegment(const Point<T>& p, const Segment<T>& s)\n{\n\tconst Point<T> a = p - s.p1;\n\tconst Point<T> b = s.p2 - s.p1;\n\tconst T normB = norm(b);\n\tconst T ab = innerProduct(a, b);\n\treturn ab / normB;\n}\n\ntemplate<typename T>\nint getPositionOnSegment(const Point<T>& p, const Segment<T>& s)\n{\n\tconst T position = getParameterOfProjectedPointToSegment(p, s);\n\tif (position < 0.0) {\n\t\treturn -1;\n\t}\n\telse if (1.0 < position) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n\ntemplate<typename T>\nbool intersects(const Segment<T>& s1, const Segment<T>& s2) {\n\tfunction<bool(Segment<T>, Segment<T>)> intersectsFromOneSegment//one segment : s1\n\t\t= [&](const Segment<T>& s1, const Segment<T>& s2) {\n\t\tconst Point<T> a = s2.p1 - s1.p1;\n\t\tconst Point<T> c = s2.p2 - s1.p1;\n\t\tconst Point<T> b = s1.p2 - s1.p1;\n\t\tconst T outerBA = outerProduct(b, a);\n\t\tconst T outerBC = outerProduct(b, c);\n\t\treturn  isZero(outerBA) || isZero(outerBC) || ( outerBA > 0.0 != outerBC > 0.0 );\n\t};\n\n\tbool isFourPointsOnSameLine = false; {\n\t\tconst Point<T> a = s2.p1 - s1.p1;\n\t\tconst Point<T> c = s2.p2 - s1.p1;\n\t\tconst Point<T> b = s1.p2 - s1.p1;\n\t\tconst T outerBA = outerProduct(b, a);\n\t\tconst T outerBC = outerProduct(b, c);\n\t\tisFourPointsOnSameLine = isZero(outerBA) && isZero(outerBC);\n\t}\n\tif (isFourPointsOnSameLine) {//case of all of four Points is on same line\n\t\treturn getPositionOnSegment(s2.p1, s1) * getPositionOnSegment(s2.p2, s1) <= 0;\n\t}\n\telse {\n\t\treturn intersectsFromOneSegment(s1, s2) && intersectsFromOneSegment(s2, s1);\n\t}\n\t\n}\n//\n//template<typename T>\n//T getDistanceFromSegmentToSegment(const Segment<T>& s1, const Segment<T>& s2) {\n//\tif (intersects(s1, s2)) {\n//\t\treturn static_cast<T>(0.0);\n//\t}else{\n//\t\treturn min(\n//\t\t\tmin(getDistanceFromPointToSegment(s1.p1, s2), getDistanceFromPointToSegment(s1.p2, s2))\n//\t\t\t, min(getDistanceFromPointToSegment(s2.p1, s1), getDistanceFromPointToSegment(s2.p2, s1))\n//\t\t);\n//\t}\n//}\n\n//template<typename T>\n//void projectPointToSegment(const Point<T>& p, const Segment<T>& s, Point<T>& foot, T& param )\n//{\n//\tconst Point<T> a = p - s.p1;\n//\tconst Point<T> b = s.p2 - s.p1;\n//\tconst T normB = norm(b);\n//\tconst T ab = innerProduct(a, b);\n//\tparam = ab / normB;\n//\tfoot = s.p1 + (s.p2 - s.p1)*param;\n//}\n\n\n\nint main()\n{\n\tint q; cin >> q;\n\tfor (int i = 0; i != q; ++i) {\n\t\tSegment<NUM> s1, s2;\n\t\treadSegment(s1);\n\t\treadSegment(s2);\n\t\tcout << (intersects(s1, s2) ? 1 : 0) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\ndouble distPP(Point p1, Point p2) {\n\treturn (p1 - p2).abs();\n}\n\ndouble distLineP(Line l, Point p) {\n\treturn (project(l, p) - p).abs();\n}\n\ndouble distSegP(Segment s, Point p) {\n\tif (dot(p - s.p1, s.p2 - s.p1) > 0 && dot(p - s.p2, s.p1 - s.p2) > 0) {\n\t\treturn distLineP(s, p);\n\t}\n\telse {\n\t\treturn min(distPP(p, s.p1), distPP(p, s.p2));\n\t}\n}\n\nbool crossPoint(Line l1, Line l2, Point &p) {\n\tif (isParallel(l1, l2)) {\n\t\treturn false;\n\t}\n\telse {\n\t\tdouble alpha = cross(l2.p1 - l1.p1, l2.p1 - l2.p2) / cross(l1.p2 - l1.p1, l2.p1 - l2.p2);\n\t\tp = l1.p1 + (l1.p2 - l1.p1)*alpha;\n\t\treturn true;\n\t}\n}\n\nbool intersect(Segment s1, Segment s2) {\n\tPoint p;\n\tif (!crossPoint(s1, s2, p)) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif (distPP(s1.p1, s1.p2) < distPP(p, s1.p1) + distPP(p, s1.p2)) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\ndouble distSegSeg(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(distSegP(s1, s2.p1), distSegP(s1, s2.p2)), min(distSegP(s2, s1.p1), distSegP(s2, s1.p2)));\n}\n\n//int main() {\n//\tSegment S1, S2;\n//\tint q;\n//\tcin >> q;\n//\tfor (int i = 0; i < q; i++) {\n//\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n//\t\tcout << fixed << setprecision(15);\n//\t\tcout << distSegSeg(S1, S2) << endl;\n//\t}\n//\n//\treturn 0;\n//}\n\nint main() {\n\tSegment S1, S2;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcout << intersect(S1, S2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<utility>\nusing namespace std;\nconst double eps = 1e-10;\ntypedef complex<double> Point;\ntypedef Point Vector;\npair <Point,Point> Line1,Line2;\n\ndouble dot(Point& a,Point& b)\n{\n    return real(conj(a)*b);\n}\n\ndouble cross(Point& a, Point& b)\n{\n    return imag(conj(a)*b);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if (cross(t1, t2) > 0)   return +1;       // counter clockwise\n    if (cross(t1, t2) < 0)   return -1;       // clockwise\n    if (dot(t1, t2) < 0)     return +2;       // c--a--b on line\n    if (norm(t1) < norm(t2)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool isintersaction(pair <Point,Point> a, pair <Point,Point> b)\n{\n    return (ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0 && ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0);\n}\n\nint main()\n{\n    int vol;\n    scanf(\"%d\",&vol);\n    while(vol--)\n    {\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        scanf(\"%d%d%d%d%d%d%d%d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n        Line1 = make_pair(Point(x0, y0), Point(x1, y1)), Line2 = make_pair(Point(x2, y2), Point(x3, y3));\n        printf(\"%d\\n\",isintersaction(Line1, Line2));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x=0, double y=0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/ a, y/ a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x, y*y; }\n    bool operator < (const Point &p) const {\n\treturn x != p.x ? x<p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p0, p1;\n};\n\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble norm(Vector a) {\n    return a.x*a.x + a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\n/*\n  ???????????§??????????????¨??????????????°??????\n  |a*b|=|a||b|sin(theta)\n */\ndouble cross(Vector a, Vector b){ \n    return a.x*b.y - a.y*b.x;\n}\n\n/*const?????????????????????????????????*/\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ON_SEGMENT = 0;\nconst int ONLINE_FRONT = -2;\nconst int ONLINE_BACK = 2;\n\nint ccw(Point p0, Point p1, Point p2){\n    if (cross(p1-p0, p2-p0) > EPS) return COUNTER_CLOCKWISE;\n    else if (cross(p1-p0, p2-p0) < -EPS) return CLOCKWISE;\n    else if (dot(p1-p0,p2-p0) < -EPS) return ONLINE_BACK;\n    else if (norm(p1-p0) < norm(p2-p0)) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\n/*\n  intersect\n  ?????¨?????????????????¢???????????£????????????????????????\n  ????????????????¨?????????????????¨???????????????????????????°OK\n*/\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n    return ((ccw(p0,p1, p2) * ccw(p0,p1,p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2,p3,p1) <=0));\n}\n\nint main() {\n    int n,i,d;\n    \n    Point p0, p1, p2,p3;\n    cin >> n;\n    for(i=0;i<n;i++){\n\tcin >>  p0.x>> p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n\tif (intersect(p0,p1,p2,p3)) cout << \"1\" << endl;\n\telse cout << \"0\" << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\n/* ?¨±?????????????????  */\n#define EPS (1e-10)\n\n/* ?????? (cross product) : a??b = |a||b|sin */\ndouble cross(const P& a, const P& b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n/* a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????????? */\nint isIntersectedLS(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main() {\n  int n;\n  int ax, ay, bx, by, cx, cy, dx, dy;\n  scanf(\"%d\", &n);\n\n  while(n--) {\n    scanf(\"%d %d %d %d %d %d %d %d\", &ax, &ay, &bx, &by, &cx, &cy, &dx, &dy);\n    P a(ax, ay), b(bx, by), c(cx, cy), d(dx, dy);\n\n    printf(\"%d\\n\", isIntersectedLS(a, b, c, d));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double b) { return Point(x / b, y / b); }\n\tfriend istream& operator >> (istream & s, Point p) { s >> p.x >> p.y; }\n\n\tdouble dot(Point a, Point b) { return a.x* b.x + a.y * b.y; }\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator <(const Point & p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator == (const Point & p) const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n};\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x* a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\n\ndouble dot(Vector a, Vector b) { return a.x* b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x* b.y - a.y * b.x; }\n\nint ccw(Point p0, Point p1, Point p2) {        //判断有三个点构成的两个向量之间的关系（相反，同向（谁更大），逆时针方向，顺时针方向）\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;   //如果外积为正，那么就是顺时针\n\tif (cross(a, b) < -EPS) return CLOCKWISE;                             //如果外积为负，那么就是逆时针\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;              //上面两种情况都不符合的时候，就一定在一条直线上，如果内积为负，那就是相反方向\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;  //如果上面条件还不符合的话，那就按看谁的大了，\n\treturn ON_SEGMENT;                 \n}\n\n\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\twhile (q--)\n\t{\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tPoint p0 = Point(x0, y0), p1 = Point(x1, y1), p2 = Point(x2, y2), p3 = Point(x3, y3);\n\t\tcout << intersect(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst double kEps = 1e-10;\nconst double kInf = 1e15;\n\nint dcmp(double x) {\n  if (fabs(x) < kEps) return 0;\n  return x < 0 ? -1 : 1;\n}\n\nstruct Vector {\n  double x, y;\n  Vector() {}\n  Vector(double x, double y): x(x), y(y) {}\n  // Vector(const Point & p1, const Point & p2): x(p2.x - p1.x), y(p2.y - p1.y) {}\n  Vector(const Vector & v);\n\n  double Norm() const { return hypot(x, y); }\n  double NormSquared() const { return x * x + y * y; }\n  Vector Normalize() const {\n    return *this / this->Norm();\n  }\n  Vector operator-() const {\n    return Vector(-x, -y);\n  }\n  Vector operator+(const Vector & rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n  }\n  Vector operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  Vector operator*(const double rhs) const {\n    return Vector(rhs * x, rhs * y);\n  }\n  Vector operator/(const double rhs) const {\n    return *this * (1.0 / rhs);\n  }\n  double Dot(const Vector & rhs) const {\n    return x * rhs.x + y * rhs.y;\n  }\n  double Cross(const Vector & rhs) const {\n    return x * rhs.y - y * rhs.x;\n  }\n  bool operator==(const Vector & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Vector & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Point {\n  Point() {}\n  Point(double x, double y): x(x), y(y) {}\n  Point(const Point & p);\n\n  double x, y;\n\n  Point operator-() {\n    return Point(-x, -y);\n  }\n  Point operator+(const Vector & rhs) const {\n    return Point(x + rhs.x, y + rhs.y);\n  }\n  Point operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  bool operator==(const Point & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Point & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Line {\n  Line() {}\n  Line(const Point & p1, const Point & p2): p1(p1), p2(p2) {\n    if (dcmp(p2.x - p1.x) == 0) {\n      slope = kInf;\n    } else {\n      slope = (p2.y - p1.y) / (p2.x - p1.x);\n    }\n  }\n  Line(double x1, double y1, double x2, double y2): p1(x1, y1), p2(x2, y2) {\n    if (dcmp(x2 - x1) == 0) {\n      slope = kInf;\n    } else {\n      slope = (y2 - y1) / (x2 - x1);\n    }\n  }\n  Line(const Line & l);\n\n  Point p1, p2;\n  double slope;\n};\n\n// minus: left, plus: right, 0: colinear\nint Direction(const Point & p0, const Point & p1, const Point & p2) {\n  Vector v1(p1.x - p0.x, p1.y - p0.y);\n  Vector v2(p2.x - p0.x, p2.y - p0.y);\n  return dcmp(v2.Cross(v1));\n}\n\n// minus: back, plus: front, 0: on\nint SegmentDirection(const Point & p0, const Point & p1, const Point & p2) {\n  if (p2.x >= min(p0.x, p1.x) && p2.x <= max(p0.x, p1.x)\n      && p2.y >= min(p0.y, p1.y) && p2.y <= max(p0.y, p1.y)) { return 0; }\n  if ((p2.x - p0.x) * (p1.x - p0.x) > 0\n      || (p2.y - p0.y) * (p1.y - p0.y) > 0) { return 1; }\n  return -1;\n}\n\nbool IsIntersecting(const Line & l1, const Line & l2) {\n  auto d1 = Direction(l2.p1, l2.p2, l1.p1);\n  auto d2 = Direction(l2.p1, l2.p2, l1.p2);\n  auto d3 = Direction(l1.p1, l1.p2, l2.p1);\n  auto d4 = Direction(l1.p1, l1.p2, l2.p2);\n\n  if (d1 * d2 < 0 && d3 * d4 < 0) { return true; }\n  if (d1 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p1) == 0) { return true; }\n  if (d2 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p2) == 0) { return true; }\n  if (d3 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p1) == 0) { return true; }\n  if (d4 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p2) == 0) { return true; }\n  return false;\n}\n\nint main(int argc, char const *argv[]) {\n  double x0, y0, x1, y1;\n  Point p0(x0, y0);\n  Point p1(x1, y1);\n\n  int q;\n  cin >> q;\n  for (unsigned i = 0; i < q; ++i) {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    if (IsIntersecting(Line(x0, y0, x1, y1), Line(x2, y2, x3, y3))) {\n      cout << 1 << \"\\n\";\n    } else {\n      cout << 0 << \"\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8, pi = acos(-1.0);\nbool eq(ld a, ld b){return (abs(b-a)<eps);}\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nclass Line{\npublic:\n  Point a,b;\n};\n\nld triangle(Point p1, Point p2, Point p3){\n  return cross(p2-p1, p3-p1);\n}\n\nint intersect(Line l1, Line l2){\n  return triangle(l1.a, l1.b, l2.a) * triangle(l1.a, l1.b, l2.b) < 0 ? 1 : 0;\n}\n\nint main(){\n  int q;cin>>q;\n  REP(i,q){\n    ld real, imag;\n    Line s1,s2;\n    cin>>real>>imag;\n    s1.a = Point(real,imag);\n    cin>>real>>imag;\n    s1.b = Point(real,imag);\n    cin>>real>>imag;\n    s2.a = Point(real,imag);\n    cin>>real>>imag;\n    s2.b = Point(real,imag);\n    cout<<intersect(s1,s2)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define Graph vector< vector<int> >\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\n\nconst double EPS = 1e-10;\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point{\n    double x, y;\n    Point(){}\n    Point(double x0, double y0){\n        x = x0; y = y0;\n    }\n\n    Point operator +(const Point &p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator -(const Point &p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator *(const double &a){\n        return Point(a * x, a * y);\n    }\n    Point operator /(const double &a){\n        return Point(x / a, y / a);\n    }\n\n    bool operator == (const Point &p){\n        return equals(x, p.x) && equals(y, p.y);\n    }\n\n    bool operator < (const Point &p){\n        return x != p.x ? x < p.x : y < p.y ;\n    }\n\n};\n\ndouble norm(Point p){\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble v_abs(Point p){\n    return sqrt(norm(p));\n}\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c0, double r0){\n        c.x = c0.x;\n        c.y = c0.y;\n        r = r0;\n    }\n    Circle(double x0, double y0, double r0){\n        c.x = x0;\n        c.y = y0;\n        r = r0;\n    }\n};\n\nint ccw(Point p0, Point p1, Point p2){\n    int COUNTER_CLOCKWISE = 1;\n    int CLOCKWISE = -1;\n    int ON_SEGMENT = 0;\n    int ONLINE_FRONT = 2;\n    int ONLINE_BACK = -2;\n    Vector a = p1 - p0, b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    else if(cross(a, b) < -EPS) return CLOCKWISE;\n    else if(dot(a, b) < -EPS) return ONLINE_BACK;\n    else if(norm(a) < norm(b)) return ONLINE_FRONT;\n    else return ON_SEGMENT;\n}\n\nint main(){\n    int Q;\n    cin >> Q;\n    rep(i, Q){\n        Point p0, p1, p2, p3;\n        cin >> p0.x >> p0.y;\n        cin >> p1.x >> p1.y;\n        cin >> p2.x >> p2.y;\n        cin >> p3.x >> p3.y;\n        if(ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0 ){\n            cout << 1 << endl;\n        }\n        else cout << 0 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define next Next\n#define gc getchar\nstruct node{\n\tdouble x,y;\n}a,b,c,d;\nnode operator - (node a,node b)\n{\n\treturn (node){a.x-b.x,a.y-b.y};\n}\ndouble DJ(node a,node b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble CJ(node a,node b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble len(node a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n/*char buf[1<<21],*p1=buf,*p2=buf;\ninline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/\ninline int read()\n{\n    int ret=0,f=0;char c=gc();\n    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n    if(f)return -ret;return ret;\n}\nbool chk(node c,node a,node b)\n{\n\tint x=CJ(b-a,c-a);\n\tif(x>0)return 0;\n\tif(x<0)return 0;\n\tint y=DJ(b-a,c-a);\n\tif(y<0)return 0;\n\tdouble ma=max(len(c-a),len(c-b));\n\tif(ma>len(b-a))return 0;\n\tif(ma<=len(b-a))return 1;\n}\nbool pd(node a,node b,node c,node d)\n{\n\tif(chk(a,c,d))return 1;\n\tif(chk(b,c,d))return 1;\n\tif(chk(c,a,b))return 1;\n\tif(chk(d,a,b))return 1;\n\tdouble A=CJ(d-a,b-a),B=CJ(c-a,b-a);\n\tif(A*B>=0)return 0;\n\tA=CJ(a-c,d-c),B=CJ(b-c,d-c);\n\tif(A*B>=0)return 0;\n\treturn 1;\t\n}\nsigned main()\n{\n\tint n=read();\n\twhile(n--)\n\t{\n\t\ta=(node){read(),read()};\n\t\tb=(node){read(),read()};\n\t\tc=(node){read(),read()};\n\t\td=(node){read(),read()};\n\t\tif(pd(a,b,c,d))puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(x * a, y * a); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x; \n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nint main()\n{\n    int q;\n    double x1, x2, x3, x4, y1, y2, y3, y4;\n    Segment s1, s2;\n    cin >> q;\n    for (int i = 0; i != q; ++i)\n    {\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n        s1.p1 = Point(x1, y1);\n        s1.p2 = Point(x2, y2);\n        s2.p1 = Point(x3, y3);\n        s2.p2 = Point(x4, y4);\n        if ( intersect(s1, s2) ) { cout << 1 << endl; }\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass vec{\npublic:\n\tint x,y;\n\tvec(int x_=0,int y_=0):x(x_),y(y_){}\n\tvoid make(int x_,int y_){\n\t\tx = x_; y = y_;\n\t}\n\tvec operator + (vec A){\n\t\tvec ans(this->x+A.x,this->y+A.y);\n\t\treturn ans;\n\t}\n\tvec operator - (vec A){\n\t\tvec ans(this->x-A.x,this->y-A.y);\n\t\treturn ans;\n\t}\n\tint operator * (vec A){\n\t\treturn this->x*A.x+this->y*A.y;\n\t}\n\tbool operator == (vec A){\n\t\treturn (this->x==A.x && this->y==A.y);\n\t}\n\tdouble r(){\n\t\treturn sqrt((double)x*x+(double)y*y);\n\t}\n\tdouble sita(){\n\t\tdouble ans = atan2(y,x);\n\t\treturn (ans<0.000?ans+2.0*M_PI:ans);\n\t}\n};\ndouble sin_sita(vec v1,vec v2){ // v2 basis\n\treturn double(v2.x*v1.y-v2.y*v1.x)/v1.r()/v2.r();\n}\ndouble cos_sita(vec v1,vec v2){ // v2 basis\n\treturn double(v2.x*v1.x+v2.y*v1.y)/v1.r()/v2.r();\n}\nbool Ientersected(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\treturn tc * td <= 0 && ta * tb <= 0;\n}\n\nint main(){\n\tint q,x0,y0,x1,y1,x2,y2,x3,y3;\n\tcin >> q;\n\tdouble EPS = 1e-13;\n\tFOR(i,0,q){\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tif(max(x0,x1) < min(x2,x3) || max(x2,x3) < min(x0,x1)){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(max(y0,y1) < min(y2,y3) || max(y2,y3) < min(y0,y1)){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(Ientersected(x0,y0,x1,y1,x2,y2,x3,y3)){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector A,Vector B){\n    return Vector(A.x+B.x,A.y+B.y);\n}\nVector operator - (Vector A,Vector B){\n    return Vector(A.x-B.x,A.y-B.y);\n}\nVector operator * (Vector A,double p){\n    return Vector(A.x*p,A.y*p);\n}\nVector operator / (Vector A,double p){\n    return Vector(A.x/p,A.y/p);\n}\nbool operator < (const Point& a,const Point& b){\n    return a.x<b.x||(a.x==b.x&&a.y<b.y);\n}\nconst double eps = 1e-10;\nint dcmp(double x){\n    if(fabs(x)<eps) return 0; else return (x<0?-1:1);\n}\nbool operator == (const Point& a,const Point& b){\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\n//点积\ndouble Dot(Vector A,Vector B){\n    return A.x*B.x+A.y*B.y;\n}\ndouble Length(Vector A){\n    return sqrt(Dot(A,A));\n}\ndouble Angle(Vector A,Vector B){\n    return acos(Dot(A,B)/Length(A)/Length(B));\n}\n \n//叉积\ndouble Cross(Vector A,Vector B){\n    return (A.x*B.y-A.y*B.x);\n}\n//三角形面积的二倍的叉乘公式\ndouble Area2(Point A,Point B,Point C){\n    return Cross(B-A,C-A);\n}\n//向量旋转,rad是弧度\nVector Rotate(Vector A,double rad){\n    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));\n}\n//计算向量的单位法线,先逆时针旋转90度，然后把长度归一化\nVector Normal(Vector A){\n    double Len=Length(A);\n    return Vector(-A.y/Len,A.x/Len);\n}\n//求两直线交点\n//调用前请确保P+tv和Q+tw有唯一交点，当且仅当Cross(v,w)非0\nPoint GetLineIntersection(Point P,Vector v,Point Q,Vector w){\n    Vector u=P-Q;\n    double t=Cross(w,u)/Cross(v,w);\n    return P+v*t;\n}\n//点到直线的距离\ndouble DistanceToLine(Point P,Point A,Point B){\n    Vector v1=B-A,v2=P-A;\n    return fabs(Cross(v1,v2))/Length(v1);\n}\n//点到线段的距离\ndouble DistanceToSegment(Point P,Point A,Point B){\n    if(A==B) return Length(P-A);\n    Vector v1=B-A,v2=P-A,v3=P-B;\n    if(dcmp(Dot(v1,v2))<0) return Length(v2);\n    else if(dcmp(Dot(v1,v3))>0) return Length(v3);\n    else return fabs(Cross(v1,v2))/Length(v1);\n}\n//点在直线上的投影\nPoint GetLineProjection(Point P,Point A,Point B){\n    Vector v=B-A;\n    return A+v*(Dot(v,P-A)/Dot(v,v));\n}\n//反射\nPoint GetLineReflection(Point P,Point A,Point B){\n    return GetLineProjection(P,A,B)*2-P;\n}\n//判断两线段严格相交\nbool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2){\n    double c1=Cross(a2-a1,b1-a1), c2=Cross(a2-a1,b2-a1),\n           c3=Cross(b2-b1,a1-b1), c4=Cross(b2-b1,a2-b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n//判断点是否在线段上\nbool OnSegment(Point P,Point a1,Point a2){\n    return dcmp(Cross(a1-P,a2-P))==0 && dcmp(Dot(a1-P,a2-P))<=0;\n}\nint main(){\n    int t;\n    cin>>t;\n    while(t--){\n        Point A,B,C,D;\n        cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>D.x>>D.y;\n        bool ans1=SegmentProperIntersection(A,B,C,D);\n        bool ans2=OnSegment(A,C,D)||OnSegment(B,C,D)||OnSegment(C,A,B)||OnSegment(D,A,B);\n        if(ans1||ans2) cout<<1;\n        else cout<<0;\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   //freopen(\"in.txt\",\"w\",stdout);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<=min(x[3],x[4])||min(x[1],x[2])>=max(x[3],x[4])\n      \t   ||max(y[1],y[2])<=min(y[3],y[4])&&min(y[1],y[2])>=max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  int p=cross(Point(x[1]-x[2],y[1]-y[2]),Point(x[3]-y[3],x[4]-y[4]));  \n   \t  if(p==0)\n   \t  {\n   \t    int w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(w==0)\n   \t    {\n   \t    \tint ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tint e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tint eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tint eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<=0||e<=0||eee<=0||eeee<=0) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t  puts(\"1\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct vec{\n    double x,y;\n    vec operator-(vec b){\n        vec& a = *this;\n        vec c;\n        c.x=a.x-b.x;c.y=a.y-b.y;\n        return c;\n    }\n};\n\nconst double eps = 0.0000001;\n\ndouble inner_product(vec& a, vec& b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble outer_product(vec& a, vec& b){\n    return a.x*b.y-a.y*b.x;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = outer_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isInterSection(vec (&p)[4]){\n    int flag = 1;\n    switch(ccw(p[0],p[1],p[2])){\n        case 2:\n        case -2:\n        case 0:\n            flag = 0;\n            break;\n        case -1:\n            flag *= -1;\n            break;\n        case 1:\n            break;\n    }\n    switch(ccw(p[0],p[1],p[3])){\n        case 2:\n        case -2:\n        case 0:\n            flag = 0;\n            break;\n        case -1:\n            flag *= -1;\n            break;\n        case 1:\n            break;\n    }\n    if(flag==1) return false;\n\n    flag = 1;\n\n    switch(ccw(p[2],p[3],p[0])){\n        case 2:\n        case -2:\n        case 0:\n            flag = 0;\n            break;\n        case -1:\n            flag *= -1;\n            break;\n        case 1:\n            break;\n    }\n    switch(ccw(p[2],p[3],p[1])){\n        case 2:\n        case -2:\n        case 0:\n            flag = 0;\n            break;\n        case -1:\n            flag *= -1;\n            break;\n        case 1:\n            break;\n    }\n    if(flag==1) return false;\n    \n    return true;\n}\n\nint main(void){\n    vec p[4];\n    int q;\n    cin >> q;\n    while(q--){\n        for(auto& v : p) cin >> v.x >> v.y;\n        if(isInterSection(p)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); };\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  vec proj(vec p){\n    vec pa = p - a, ba = b - a;\n    double t = pa.dot(ba) / ba.dot(ba);\n    return a + ba.sca(t);\n  }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){\n    double res = abs(l.getvec().cross(getvec()));\n    return res < eps;\n  }\n  bool orth(line l){\n    double res = abs(l.getvec().dot(getvec()));\n    return res < eps;\n  }\n  bool intersec(line l){\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return res1 && res2;\n  }\n};\n\nsigned main(void){\n  int i, j, k;\n  int(q);\n  for(;q--;){\n    line l, m;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y >> m.a.x >> m.a.y >> m.b.x >> m.b.y;\n    puts(l.intersec(m) ? \"1\" : \"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second)) <= 0 && (ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second)) <= 0;\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag = true) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag = true) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first), distance(s1, s2.second));\n\treturn std::min({ distance(s1, s2.first, false), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, false) });\n}\nPoint crosspoint(const Segment& s1, const Segment& s2) {\n\tGType r1 = cross(s1.second - s1.first, s2.second - s2.first);\n\tGType r2 = cross(s1.second - s1.first, s1.second - s2.first);\n\tif (std::abs(r1) < EPS && std::abs(r2) < EPS) return s2.first;\n\treturn s2.first + r2 / r1 * (s2.second - s2.first);\n}\n\n#endif\n\n#include <iostream>\nusing namespace std;\nint q, xa, ya, xb, yb; Segment s1, s2;\nint main() {\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> xa >> ya >> xb >> yb; s1 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tcin >> xa >> ya >> xb >> yb; s2 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tif (intersect(s1, s2, true)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\nstruct Line : public vector<P>\n{\n  Line(P a=P(), P b=P()) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef Line Segment;\n\n#define EPS (1e-7)\n\nbool operator < (P const& a, P const& b) {\n  return (a.real() != a.real()) ? a.real() < b.real() : a.imag() < b.imag();\n}\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\nP projection_point(P const& a, P const& b, P const& c) {\n  double k = dot(b-a, c-a) / norm(b-a);\n  return a+k*(b-a);\n}\n\nP reflection_point(P const& a, P const& b, P const& c) {\n  return c + 2.*(projection_point(a, b, c) - c);\n}\n\nbool is_parallel(Segment const& s, Segment const& t) {\n  return abs(cross(s[1]-s[0], t[1]-t[0])) < EPS;\n}\n\nbool is_orthogonal(Segment const& s, Segment const& t) {\n  return abs(dot(s[1]-s[0], t[1]-t[0])) < EPS;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return +1; // counter clockwise\n  if(cross(b, c) < 0) return -1;  // clockwise\n  if(dot(b, c) < 0) return +2;    // c-a-b\n  if(norm(b) < norm(c)) return -2;  // a-b-c\n  return 0; // on segment\n}\n\nbool is_intersect_ss(Segment s, Segment t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0\n         && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main () {\n  \n  int q; cin >> q;\n  for(;q--;) {\n    Segment s, t;\n    cin >> s[0].real() >> s[0].imag();\n    cin >> s[1].real() >> s[1].imag();\n    cin >> t[0].real() >> t[0].imag();\n    cin >> t[1].real() >> t[1].imag();\n    \n    cout << is_intersect_ss(s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef long double Real;\ntypedef complex<Real> Point;\n#define PCR Point const &\n#define X real()\n#define Y imag()\n\nconst Real EPS = 1e-10;\nconst Real INF = 1e100;\nconst Real PI = acos(-1);\n\nstruct Segment {\n    Point p[2];\n    Segment (PCR a = Point(), PCR b = Point()){\n        p[0] = a, p[1] = b;\n    }\n    Point & operator [] (int k) { return p[k]; }\n    Point const & operator [] (int k) const { return p[k]; }\n};\ntypedef vector<Point> Polygon;\nstruct Circle { Real radius; Point center; };\n\nReal dot(PCR a, PCR b){\n    return a.X*b.X + a.Y*b.Y;\n}\nReal cross(PCR a, PCR b){\n    return a.X*b.Y - a.Y*b.X;\n}\n\nPoint pSP(Segment const & s, PCR p){\n    Point base = s[1] - s[0];\n    Real r = dot(p - s[0], base) / norm(base);\n    return s[0] + base * r;\n}\n\nPoint rSP(Segment const & s, PCR p){\n    Point v = pSP(s,p) - p;\n    return p + v * Real(2);\n}\n\nenum { LEFT = 1, RIGHT = -1, BACK = 2, FRONT = -2, ON = 0 };\n// Includes end-points. Comment in to exclude.\nint ccw(PCR x, PCR p, PCR q){\n    Point a = p - x, b = q - x;\n    if(cross(a,b) > EPS) return LEFT;\n    if(cross(a,b) < -EPS) return RIGHT;\n    if(/* abs(a) < EPS || */ dot(a,b) < -EPS) return BACK;\n    if(/* abs(b) < EPS || */ norm(a) < norm(b)) return FRONT;\n    return ON;\n}\n\nbool isParallel(Segment const & s, Segment const & t){\n    return abs(cross(s[1]-s[0],t[1]-t[0])) < EPS;\n}\n\nbool isOrthogonal(Segment const & s, Segment const & t){\n    return abs(dot(s[1]-s[0],t[1]-t[0])) < EPS;\n}\n\n// Includes end-points. Modify CCW to exclude\nbool iSS(Segment const & s, Segment const & t){\n    bool f1 = ccw(s[0],s[1],t[0]) * ccw(s[0],s[1],t[1]) <= 0;\n    bool f2 = ccw(t[0],t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n    return f1 && f2;\n}\n\n#include <iostream>\n#include <cstdio>\n\nint main(){\n    Segment s,t;\n    Real x,y;\n    int n; cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> x >> y;\n        s[0] = Point(x,y);\n        cin >> x >> y;\n        s[1] = Point(x,y);\n        cin >> x >> y;\n        t[0] = Point(x,y);\n        cin >> x >> y;\n        t[1] = Point(x,y);\n        cout << iSS(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <complex>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\ntypedef double coordinate_t;\n\nstruct coordinate {\n  coordinate_t x, y;\n  bool operator<(const coordinate & another) const {\n    return x != another.x ? x < another.x : y < another.y;\n  }\n};\n\nstruct line {\n  coordinate_t a, b, c;\n  coordinate p, q;\n};\n\n// is p in [l.x, r.x] * [l.y, r.y] ?\nbool in_section(coordinate p, coordinate l, coordinate r) {\n  coordinate_t lx, ly, rx, ry;\n  lx = min(l.x, r.x);\n  rx = max(l.x, r.x);\n  ly = min(l.y, r.y);\n  ry = max(l.y, r.y);\n  if (lx <= p.x && p.x <= rx && ly <= p.y && p.y <= ry) return true;\n  else return false;\n}\n\n// the intersections of 2 lines\ncoordinate cross_of_2_lines(line k, line l) {\n  coordinate_t dn = l.a * k.b - k.a * l.b;\n  if (dn == 0) return{ NAN, NAN };\n  else {\n    coordinate ret;\n    ret.x = (l.b * k.c - k.b * l.c) / dn;\n    ret.y = (k.a * l.c - l.a * k.c) / dn;\n    if (in_section(ret, k.p, k.q) && in_section(ret, l.p, l.q)) return ret;\n    else return{ NAN, NAN };\n  }\n}\n\n\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (!_isnan(p.x )&& !_isnan(p.y)) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n\n// the line through 2 coordinates\nline line_through_2_coordinates(coordinate p, coordinate q) {\n  if (p.x == q.x && p.y == q.y) return{ NAN, NAN, NAN, p, q };\n  else {\n    if (p.x == q.x) {\n      if (p.y < q.y) return { 1, 0, -p.x, p, q };\n      else return{ 1, 0, -p.x, q, p };\n    }\n    else {\n      if (p.x < q.x) return { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, p, q };\n      else return{ (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, q, p };\n    }\n  }\n}\n\n\n\nint main() {\n  int q; cin >> q;\n  cout << setprecision(18);\n  Loop(i, q) {\n    coordinate p, q;\n    line s, t;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    s = line_through_2_coordinates(p, q);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    t = line_through_2_coordinates(p, q);\n    coordinate r = cross_of_2_lines(s, t);\n    if (_isnan(r.x)) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define db double\nconst db eps = 1e-8;\n\nstruct Point{\n    db x, y;\n    Point(db x=0, db y=0): x(x), y(y) {}    //必须有初始化\n    bool operator < (const Point &p){\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\ntypedef Point Vector;\nVector operator + (Vector a, Vector b){ return Point(a.x+b.x, a.y+b.y);}\nVector operator - (Point a, Point b){ return Vector(a.x-b.x, a.y-b.y);}\nVector operator * (Vector a, db k){ return Vector(a.x*k, a.y*k);}\nVector operator / (Vector a, db k){ return Vector(a.x/k, a.y/k);}\n\n//inline将函数名为内联函数，不使用栈空间，直接运算，但不能有while,switch等复杂语句\ninline db dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\ninline db cross(Vector a, Vector b){\n    return a.x*b.y - b.x*a.y;\n}\ndb length(Vector a){\n    return sqrt(dot(a, a));\n}\ndb angle(Vector a, Vector b){\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\nint dcmp(db x){\n    if(fabs(x) < eps) return 0;\n    return x < 0? -1: 1;\n}\nbool operator == (Point a, Point b){\n    return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0;\n}\n\nstruct Segment{\n    Point p1, p2;\n};\ntypedef Segment Line;\nvector<Point> Polygon;\nPoint project(Line l, Point p){\n    Vector a = l.p2 - l.p1, b = p - l.p1;\n    db len_a = dot(a, a);   //这里不加sqrt，是因为下面算投影长度时，要除以两次len_a\n    Vector tmp = a * (dot(a, b) / len_a);\n    return Point(tmp.x+l.p1.x, tmp.y+l.p1.y);\n}\nPoint reflect(Line l, Point p){\n    Point tmp = project(l, p);\n    return p + (tmp - p)*2;\n}\n\nvoid line_relation(Point p1, Point p2, Point p3, Point p4){\n    Vector a = p2 - p1, b = p4 - p3;\n    if(cross(a, b) == 0)\n        puts(\"parallel\");\n    else if(dot(a, b) == 0)\n        puts(\"orthogonal\");\n    else\n        puts(\"others\");\n}\nint com_segment_relation(Point p0, Point p1, Point p2){\n    Vector a = p1-p0, b = p2-p0;\n    db flag = cross(p1-p0, p2-p0);\n    if(flag < 0)  return 2;\n    else if(flag > 0)  return 1;\n    else{       //重合\n        if(a.x*b.x < 0 || a.y*b.y < 0) return 3;\n        else if(length(a) < length(b)) return 4;\n        else return 5;\n    }\n}\n\nint segment_intersection(Point p1, Point p2, Point p3, Point p4){\n    Point node1[2] = {p1, p2}, node2[2] = {p3, p4};\n    sort(node1, node1+2), sort(node2, node2+2);\n    if(node2[1] < node1[0] || node1[1] < node2[0])  return 0;       //同一直线上，最大最小排除\n    else if(cross(p2-p1, p3-p1)*cross(p2-p1, p4-p1) > 0 || cross(p4-p3, p1-p3)*cross(p4-p3, p2-p3) > 0) return 0;\n    else    return 1;\n}\nint main()\n{\n    Point p1, p2, p3, p4;\n    int n;\n    cin >>n;\n    while(n --){\n        cin >>p1.x >>p1.y >>p2.x >>p2.y >>p3.x >>p3.y >>p4.x >>p4.y;\n        int flag = segment_intersection(p1, p2, p3, p4);\n        cout <<flag;\n        cout << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersect(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid swap(long long int *a, long long int *b){\n\tif(*a != *b){\n\t\t*a ^= *b;\n\t\t*b ^= *a;\n\t\t*a ^= *b;\n\t}\n}\n\nint main() {\n\tlong long int n, xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3, d1, d2, d3, d4;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;++i){\n\t\tcin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n\t\td1 = (yp2 - yp0)*(xp1 - xp0) - (xp2 - xp0)*(yp1 - yp0);\n\t\td2 = (yp3 - yp0)*(xp1 - xp0) - (xp3 - xp0)*(yp1 - yp0);\n\t\td3 = (yp0 - yp2)*(xp3 - xp2) - (xp0 - xp2)*(yp3 - yp2);\n\t\td4 = (yp1 - yp2)*(xp3 - xp2) - (xp1 - xp2)*(yp3 - yp2);\n\t\t\n\t\tif( d1 == 0 && d2 == 0){\n\t\t\tif(xp0 != xp1){//not parallel with y axis\n\t\t\t\tif(xp0 > xp1)swap(&xp0, &xp1);\n\t\t\t\tif(xp2 > xp3)swap(&xp2, &xp3);\n\t\t\t\t\n\t\t\t\tif(xp0 <= xp3 && xp1 >= xp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}else{//parallel with y axis\n\t\t\t\tif(yp0 > yp1)swap(&yp0, &yp1);\n\t\t\t\tif(yp2 > yp3)swap(&yp2, &yp3);\n\t\t\t\t\n\t\t\t\tif(yp0 <= yp3 && yp1 >= yp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( d1 * d2 <= 0 && d3 * d4 <= 0){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\nint main(){\nint n;\ncin>>n;\ndouble a1,a2,a3,a4,a5,a6,a7,a8;\ncin>>a1>>a2>>a3>>a4;\nPoint p0,p1,p2,p3;\nVector v01,v31,v02,v03,v23,v21,v20;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8;\np0.x=a1,p0.y=a2;\np1.x=a3,p1.y=a4;\np2.x=a5,p2.y=a6;\np3.x=a7,p3.y=a8;\nv01=p0-p1;\nv02=p0-p2;\nv03=p0-p3;\nv23=p2-p3;\nv21=p2-p1;\nv20=p2-p0;\nv31=p3-p1;\nif(cross(v01,v02)==0 && cross(v01,v03)==0){\nif(dot(v03,v02)<=0|| dot(v21,v31)<=0) cout<<\"1\"<<endl;\n\nelse cout<<\"0\"<<endl;\n//cout<<dot(v03,v02)<<\" \"<<dot(v21,v31)<<endl;\n}\nelse if(cross(v01,v02)*cross(v01,v03)<=0 && cross(v23,v21)*cross(v23,v20)<=0) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nstring ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return \"COUNTER_CLOCKWISE\";\n  if(cross(d,e)<0) return \"CLOCKWISE\";\n  if(dot(d,e)<0) return \"ONLINE_BACK\";\n  if(abs(d) < abs(e)) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = ((c-d)*abs(d.y))/(abs(d.y)-abs(c.y))+d;\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(O,a.t-a.s,b.t-b.s)==0;}\nbool parallel(L a,L b) {return sdet(O,a.t-a.s,b.t-b.s)==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint s1=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint s2=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(s1,s2)<=0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(O,a.t-a.s,b.t-b.s);\n\treturn u*a.s+(1-u)*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h=l.s;\n\tif(sdot(l.t,l.s,p)<=0) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << iss(s1,s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Geometry INT\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ninline int sign(const LL x) {\n\tif (x < 0) {\n\t\treturn -1;\n\t}\n\tif (x > 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct point {\n\tLL x, y;\n\tpoint() {}\n\tpoint(LL _x, LL _y) : x(_x), y(_y) {}\n};\n\nvoid normalize(point &P) {\n\tassert(P.x != 0 || P.y != 0);\n\tLL g = __gcd(P.x, P.y);\n\tP.x /= g;\n\tP.y /= g;\n}\n\npoint operator + (const point &P, const point &Q) {\n\treturn point(P.x + Q.x, P.y + Q.y);\n}\n\npoint operator - (const point &P, const point &Q) {\n\treturn point (P.x - Q.x, P.y - Q.y);\n}\n\npoint operator * (const point &P, const LL k) {\n\treturn point(P.x * k, P.y * k);\n}\n\npoint operator / (const point &P, const LL k) {\n\tassert(k != 0 && P.x % k == 0 && P.y % k == 0);\n\treturn point(P.x / k, P.y / k);\n}\n\ninline LL dot(const point &P, const point &Q) {\n\treturn P.x * Q.x + P.y * Q.y;\n}\n\ninline LL cross(const point &P, const point &Q) {\n\treturn P.x * Q.y - P.y * Q.x;\n}\n\ninline bool is_in(LL x, LL a, LL b) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\treturn (a <= x && x <= b);\n}\n\ninline bool is_in(const point &P, const point &A, const point &B) {\n\tif (cross(B - A, P - A) != 0) {\n\t\treturn false;\n\t}\n\treturn (is_in(P.x, A.x, B.x) && is_in(P.y, A.y, B.y));\n}\n\ninline bool segment_segment_intersect(const point &A, const point &B, const point &C, const point &D) {\n\tif (cross(B - A, D - C) == 0) { // lines are parallel\n\t\treturn (is_in(A, C, D) || is_in(B, C, D) || is_in(C, A, B) || is_in(D, A, B));\n\t}\n\tif (sign(cross(C - A, B - A)) * sign(cross(D - A, B - A)) > 0) {\n\t\treturn false;\n\t}\n\tif (sign(cross(A - C, D - C)) * sign(cross(B - C, D - C)) > 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nvoid test_segment_segment_intersection() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tpoint A, B, C, D;\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> D.x >> D.y;\n\t\tcout << (segment_segment_intersect(A, B, C, D) ? \"1\" : \"0\") << \"\\n\";\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\ttest_segment_segment_intersection();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\tint p1p2p3, p1p2p4, p3p4p1, p3p4p2;\n\tp1p2p3 = ccw(p1, p2, p3);\n\tp1p2p4 = ccw(p1, p2, p4);\n\tp3p4p1 = ccw(p3, p4, p1);\n\tp3p4p2 = ccw(p3, p4, p2);\n\n\tif (p1p2p3 == ON_SEGMENT) return true;\n\tif (p1p2p4 == ON_SEGMENT) return true;\n\tif (p3p4p1 == ON_SEGMENT) return true;\n\tif (p3p4p2 == ON_SEGMENT) return true;\n\tif (p1p2p3 == ONLINE_FRONT && p1p2p4 == ONLINE_BACK) return true;\n\tif (p1p2p3 == ONLINE_BACK && p1p2p4 == ONLINE_FRONT) return true;\n\tif (p1p2p3 == COUNTER_CLOCKWISE && p1p2p4 == CLOCKWISE && p3p4p1 == CLOCKWISE && p3p4p2 == COUNTER_CLOCKWISE) return true;\n\tif (p1p2p3 == CLOCKWISE && p1p2p4 == COUNTER_CLOCKWISE && p3p4p1 == COUNTER_CLOCKWISE && p3p4p2 == CLOCKWISE) return true;\n\treturn false;\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//int main() {\n//\tSegment S1, S2;\n//\tint q;\n//\tcin >> q;\n//\tfor (int i = 0; i < q; i++) {\n//\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n//\t\tcout << fixed << setprecision(15);\n//\t\tcout << distSegSeg(S1, S2) << endl;\n//\t}\n//\n//\treturn 0;\n//}\n\nint main() {\n\tSegment S1, S2;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcout << intersect(S1, S2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n// to do : 1183\n\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum CCW{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線abと点cの距離\nD distLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD distSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n/** Problem CGL_2-B : Intersection **/\nint main()\n{\n\tL s, t;\n\tint q; cin>>q;\n\trep(i, q) {\n\t\tcin>>s.a.X>>s.a.Y>>s.b.X>>s.b.Y;\n\t\tcin>>t.a.X>>t.a.Y>>t.b.X>>t.b.Y;\n\t\tcout << iSS(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nint sign(double x) {\n    if (fabs(x) < EPS) {\n        return 0;\n    } else if (x > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nint dcmp(double x, double y) {\n    return sign(x - y);\n}\n\ndouble cosLaw(double a, double b, double c) {\n    return acos((a * a + b * b - c * c) / (2 * a * b));\n}\n\nstruct Vector;\ntypedef Vector Point;\nstruct Line;\nstruct Segment;\nstruct Circle;\n\nstruct Vector {\n    double x;\n    double y;\n\n    explicit Vector(double x = 0, double y = 0);\n\n    Vector operator+(const Vector &rhs) const;\n    Vector operator-() const;\n    Vector operator-(const Vector &rhs) const;\n    Vector operator*(double d) const;\n    Vector operator/(double d) const;\n\n    bool operator==(const Vector &rhs) const;\n    bool operator!=(const Vector &rhs) const;\n    bool operator<(const Vector &rhs) const;\n    bool operator>(const Vector &rhs) const;\n    bool operator<=(const Vector &rhs) const;\n    bool operator>=(const Vector &rhs) const;\n\n    friend std::ostream &operator<<(std::ostream &os, const Vector &vector);\n\n    double dot(const Vector &rhs) const;\n    double cross(const Vector &rhs) const;\n    double length() const;\n    double angle() const;\n    double angle(const Vector &rhs) const;\n    Vector rotate(double rad) const;\n    Vector normal() const;\n    double getDistanceTo(const Point &rhs) const;\n};\n\nstruct Segment {\n    Point a;\n    Point b;\n\n    explicit Segment(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0);\n    explicit Segment(const Point &a = Point(), const Point &b = Point());\n\n    bool contains(const Point &rhs, bool containsEndPoints = true) const;\n    bool intersects(const Segment &rhs, bool containsEndPoints = true) const;\n    double length() const;\n};\n\nVector::Vector(double x, double y) : x(x), y(y) {}\n\nVector Vector::operator+(const Vector &rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n}\n\nVector Vector::operator-() const {\n    return Vector(-x, -y);\n}\n\nVector Vector::operator-(const Vector &rhs) const {\n    return *this + -rhs;\n}\n\nVector Vector::operator*(double d) const {\n    return Vector(x * d, y * d);\n}\n\nVector Vector::operator/(double d) const {\n    return Vector(x / d, y / d);\n}\n\n\nbool Vector::operator==(const Vector &rhs) const {\n    return dcmp(x, rhs.x) == 0 && dcmp(y, rhs.y) == 0;\n}\n\nbool Vector::operator!=(const Vector &rhs) const {\n    return !(rhs == *this);\n}\n\nbool Vector::operator<(const Vector &rhs) const {\n    if (dcmp(x, rhs.x) != 0) {\n        return dcmp(x, rhs.x) < 0;\n    } else {\n        return dcmp(y, rhs.y) < 0;\n    }\n}\n\nbool Vector::operator>(const Vector &rhs) const {\n    return rhs < *this;\n}\n\nbool Vector::operator<=(const Vector &rhs) const {\n    return !(rhs < *this);\n}\n\nbool Vector::operator>=(const Vector &rhs) const {\n    return !(*this < rhs);\n}\n\nstd::ostream &operator<<(std::ostream &os, const Vector &vector) {\n    os << \"(\" << vector.x << \", \" << vector.y << \")\";\n    return os;\n}\n\ndouble Vector::dot(const Vector &rhs) const {\n    return x * rhs.x + y * rhs.y;\n}\n\ndouble Vector::cross(const Vector &rhs) const {\n    return x * rhs.y - rhs.x * y;\n}\n\ndouble Vector::length() const {\n    return sqrt(dot(*this));\n}\n\ndouble Vector::angle() const {\n    return atan2(y, x);\n}\n\ndouble Vector::angle(const Vector &rhs) const {\n    return acos(dot(rhs) / length() / rhs.length());\n}\n\nVector Vector::rotate(double rad) const {\n    return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));\n}\n\nVector Vector::normal() const {\n    double l = length();\n    return Vector(-y / l, x / l);\n}\n\ndouble Vector::getDistanceTo(const Point &rhs) const {\n    return sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2));\n}\n\nSegment::Segment(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}\n\nSegment::Segment(const Point &a, const Point &b) : a(a), b(b) {}\n\nbool Segment::contains(const Point &rhs, bool containsEndPoints) const {\n    const Vector &u = a - rhs;\n    const Vector &v = b - rhs;\n    return sign(u.cross(v)) == 0 && (containsEndPoints ? sign(u.dot(v)) <= 0 : sign(u.dot(v)) < 0);\n}\n\nbool Segment::intersects(const Segment &rhs, bool containsEndPoints) const {\n    const Vector &u = b - a;\n    const Vector &v = rhs.b - rhs.a;\n    double c1 = u.cross(rhs.a - a);\n    double c2 = u.cross(rhs.b - a);\n    double c3 = v.cross(a - rhs.a);\n    double c4 = v.cross(b - rhs.a);\n    if (containsEndPoints && (!sign(c1) || !sign(c2) || !sign(c3) || !sign(c4))) {\n        return contains(rhs.a) || contains(rhs.b) || rhs.contains(a) || rhs.contains(b);\n    }\n    return sign(c1) * sign(c2) < 0 && sign(c3) * sign(c4) < 0;\n}\n\ndouble Segment::length() const {\n    return a.getDistanceTo(b);\n}\n\n\nint main() {\n//    freopen(\"data.in\", \"r\", stdin);\n\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int x1, y1;\n        int x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        Segment segment1(x1, y1, x2, y2);\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        Segment segment2(x1, y1, x2, y2);\n        if (segment1.intersects(segment2)) {\n            puts(\"1\");\n        } else {\n            puts(\"0\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(){}\n\tPoint(const Point &P){\n\t\tx=P.x;\n\t\ty=P.y;\n\t}\n\tPoint(double a, double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tPoint operator*(const double coe)const\n\t{\n\t\tPoint P;\n\t\tP.x=x*coe;\n\t\tP.y=y*coe;\n\t\treturn P;\n\t}\n\tPoint operator-(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x-P.x;\n\t\tresult.y=y-P.y;\n\t\treturn result;\n\t}\n\tPoint operator+(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x+P.x;\n\t\tresult.y=y+P.y;\n\t\treturn result;\n\t}\n};\n\nclass Line\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tLine(){}\n\tLine(Point a, Point b){\n\t\tp1=a;\n\t\tp2=b;\n\t}\n\tLine(const Line &L){\n\t\tp1=L.p1;\n\t\tp2=L.p2;\n\t}\n\tdouble cross(const Line &L)const{\n\t\treturn (p2.x-p1.x)*(L.p2.y-L.p1.y)-(p2.y-p1.y)*(L.p2.x-L.p1.x);\n\t}\n\tPoint intersection(const Line &L)const{//line intersection point\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            result.x=-999999;\n            result.y=-999999;\n            return result;\n\t\t}\n\t\tresult=p1+(p2-p1)*(Line(L.p1, p1).cross(L)/L.cross(*this));\n\t\treturn result;\n\t}\n\tbool point_on_segment(const Point &P)const{//point on line, but on segment?\n\t\tif((P.x-p1.x)*(P.x-p2.x)<=0&&(P.y-p1.y)*(P.y-p2.y)<=0) return 1;\n\t\treturn 0;\n\t}\n\tbool valid_intersection(const Line &L)const{//segment intersect?\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            Line L2(p2, L.p1);\n            if(cross(L2)==0&&(point_on_segment(L.p1)||point_on_segment(L.p2))) return 1;\n            return 0;\n\t\t}\n\t\tresult=intersection(L);\n\t\tif(point_on_segment(result)&&L.point_on_segment(result)) return 1;\n\t\treturn 0;\n\t}\n\tLine perpendicular_bisector()const{//a perpendicular bisector line\n\t    Point P1((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n\t    Point v(p2.y-p1.y, p1.x-p2.x);\n\t    Point P2=P1+v;\n\t    Line result(P1, P2);\n\t    return result;\n\t}\n};\n\nclass Polygon\n{\npublic:\n\tvector<Point> v;\n\tPolygon(){\n\t\tv.clear();\n\t}\n\tdouble area(){//area\n\t\tdouble a=0;\n\t\tfor(int i=1;i<v.size()-1;i++){\n\t\t\tLine L1(v[0], v[i]);\n\t\t\tLine L2(v[0], v[i+1]);\n\t\t\ta+=L1.cross(L2);\n\t\t}\n\t\tif(a<0) return (-a)/2;\n\t\telse return a/2;\n\t}\n\tPolygon HPits(Line &L){//half plane intersection //only keep the counterclockwise side's polygon\n\t\tPolygon q;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tLine L1(L.p1, v[i]);\n\t\t\tif(L.cross(L1)>=0) q.v.push_back(v[i]);\n\t\t\tLine L2(L.p1, v[(i+1)%v.size()]);\n\t\t\tif(L.cross(L1)*L.cross(L2)<0) q.v.push_back(L.intersection(Line(v[i], v[(i+1)%v.size()])));\n\t\t}\n\t\treturn q;\n\t}\n};\n\nclass Triangle\n{\npublic:\n    Point a;\n    Point b;\n    Point c;\n    Triangle(){}\n    Triangle(Point A, Point B, Point C){\n        a=A; b=B; c=C;\n    }\n    Point center(){//tircumcenter\n        Line L1(a, b);\n        Line L2(b, c);\n        Line N1=L1.perpendicular_bisector();\n        Line N2=L2.perpendicular_bisector();\n        return N1.intersection(N2);\n    }\n    double area(){\n        Line L1(a, b);\n        Line L2(a, c);\n        double ans=L1.cross(L2);\n        if(ans<0) ans=-ans;\n        return ans/2;\n    }\n    bool point_in_triangle(const Point &P)const{\n        Line L1(P, a);\n        Line L2(P, b);\n        Line L3(P, c);\n        if(L1.cross(L2)<=0&&L2.cross(L3)<=0&&L3.cross(L1)<=0) return 1;\n        if(L1.cross(L2)>=0&&L2.cross(L3)>=0&&L3.cross(L1)>=0) return 1;\n        return 0;\n    }\n};\n\nint main()\n{\n    int n;\n    double x, y;\n    scanf(\"%d\", &n);\n    while(n--){\n        scanf(\"%lf %lf\", &x, &y);\n        Point P1(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P2(x, y);\n        Line L1(P1, P2);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P3(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P4(x, y);\n        Line L2(P3, P4);\n        printf(\"%d\\n\", L1.valid_intersection(L2));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 dot(a, b) = |a||b|cosθ\nLD dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 cross(a, b) = |a||b|sinθ\nLD cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n\n// 交差判定 (isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool isecLP(Point a1, Point a2, Point b){\n    return abs(ccw(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool isecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(Point a1, Point a2, Point b1, Point b2) {\n    return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n    return !ccw(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p){\n    return a1 + dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint reflection(Point a1, Point a2, Point p){\n    return 2.0L*proj(a1, a2, p) - p;\n}\n\n// 直線と点\nLD distLP(Point a1, Point a2, Point p){\n    return abs(proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD distLL(Point a1, Point a2, Point b1, Point b2) {\n    return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD distLS(Point a1, Point a2, Point b1, Point b2) {\n    return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\n// 線分と点\nLD distSP(Point a1, Point a2, Point p) {\n    Point r = proj(a1, a2, p);\n    if(isecSP(a1, a2, r)) return abs(r-p);\n    return min(abs(a1-p), abs(a2-p));\n}\n\n// 線分と線分\nLD distSS(Point a1, Point a2, Point b1, Point b2) {\n    if(isecSS(a1, a2, b1, b2)) return 0;\n    return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)), min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (crosspoint) *******************\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = cross(b2-b1, b1-a1);\n    LD d2 = cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n/*************** using variables ***************/\nPoint p[4];\nint q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> q;\n    REP(i, q){\n        LD xp, yp;\n        REP(i, 4){\n            cin >> xp >> yp;\n            p[i] = Point(xp, yp);\n        }\n        cout << isecSS(p[0], p[1], p[2], p[3]) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > 0) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < 0) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line or Segment in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\nusing Segment = Line;\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nbool IsIntersectSS(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\n/**\n * Intersection point and Distance\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\nPoint Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\n\nint main()\n{\n    Segment s1, s2;\n    int q;\n\n    std::cin >> q;\n\n    while (q--) {\n        std::cin >> s1 >> s2;\n\n        if (IsIntersectSS(s1, s2))\n            std::cout << \"1\\n\";\n        else\n            std::cout << \"0\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(){}\n\tPoint(const Point &P){\n\t\tx=P.x;\n\t\ty=P.y;\n\t}\n\tPoint(double a, double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tPoint operator*(const double coe)const\n\t{\n\t\tPoint P;\n\t\tP.x=x*coe;\n\t\tP.y=y*coe;\n\t\treturn P;\n\t}\n\tPoint operator-(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x-P.x;\n\t\tresult.y=y-P.y;\n\t\treturn result;\n\t}\n\tPoint operator+(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x+P.x;\n\t\tresult.y=y+P.y;\n\t\treturn result;\n\t}\n};\n\nclass Line\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tLine(){}\n\tLine(Point a, Point b){\n\t\tp1=a;\n\t\tp2=b;\n\t}\n\tLine(const Line &L){\n\t\tp1=L.p1;\n\t\tp2=L.p2;\n\t}\n\tdouble cross(const Line &L)const{\n\t\treturn (p2.x-p1.x)*(L.p2.y-L.p1.y)-(p2.y-p1.y)*(L.p2.x-L.p1.x);\n\t}\n\tPoint intersection(const Line &L)const{//line intersection point\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            result.x=-999999;\n            result.y=-999999;\n            return result;\n\t\t}\n\t\tresult=p1+(p2-p1)*(Line(L.p1, p1).cross(L)/L.cross(*this));\n\t\treturn result;\n\t}\n\tbool point_on_segment(const Point &P)const{//point on line, but on segment?\n\t\tif((P.x-p1.x)*(P.x-p2.x)<=0&&(P.y-p1.y)*(P.y-p2.y)<=0) return 1;\n\t\treturn 0;\n\t}\n\tbool valid_intersection(const Line &L)const{//segment intersect?\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            Line L2(p2, L.p1);\n            if(cross(L2)==0&&(point_on_segment(L.p1)||point_on_segment(L.p2)||L.point_on_segment(p1)||L.point_on_segment(p2))) return 1;\n            return 0;\n\t\t}\n\t\tresult=intersection(L);\n\t\t//printf(\"%d\\n\", point_on_segment(result));\n\t\t//printf(\"%d\\n\", L.point_on_segment(result));\n\t\tif(point_on_segment(result)&&L.point_on_segment(result)) return 1;\n\t\treturn 0;\n\t}\n\tLine perpendicular_bisector()const{//a perpendicular bisector line\n\t    Point P1((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n\t    Point v(p2.y-p1.y, p1.x-p2.x);\n\t    Point P2=P1+v;\n\t    Line result(P1, P2);\n\t    return result;\n\t}\n};\n\nclass Polygon\n{\npublic:\n\tvector<Point> v;\n\tPolygon(){\n\t\tv.clear();\n\t}\n\tdouble area(){//area\n\t\tdouble a=0;\n\t\tfor(int i=1;i<v.size()-1;i++){\n\t\t\tLine L1(v[0], v[i]);\n\t\t\tLine L2(v[0], v[i+1]);\n\t\t\ta+=L1.cross(L2);\n\t\t}\n\t\tif(a<0) return (-a)/2;\n\t\telse return a/2;\n\t}\n\tPolygon HPits(Line &L){//half plane intersection //only keep the counterclockwise side's polygon\n\t\tPolygon q;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tLine L1(L.p1, v[i]);\n\t\t\tif(L.cross(L1)>=0) q.v.push_back(v[i]);\n\t\t\tLine L2(L.p1, v[(i+1)%v.size()]);\n\t\t\tif(L.cross(L1)*L.cross(L2)<0) q.v.push_back(L.intersection(Line(v[i], v[(i+1)%v.size()])));\n\t\t}\n\t\treturn q;\n\t}\n};\n\nclass Triangle\n{\npublic:\n    Point a;\n    Point b;\n    Point c;\n    Triangle(){}\n    Triangle(Point A, Point B, Point C){\n        a=A; b=B; c=C;\n    }\n    Point center(){//tircumcenter\n        Line L1(a, b);\n        Line L2(b, c);\n        Line N1=L1.perpendicular_bisector();\n        Line N2=L2.perpendicular_bisector();\n        return N1.intersection(N2);\n    }\n    double area(){\n        Line L1(a, b);\n        Line L2(a, c);\n        double ans=L1.cross(L2);\n        if(ans<0) ans=-ans;\n        return ans/2;\n    }\n    bool point_in_triangle(const Point &P)const{\n        Line L1(P, a);\n        Line L2(P, b);\n        Line L3(P, c);\n        if(L1.cross(L2)<=0&&L2.cross(L3)<=0&&L3.cross(L1)<=0) return 1;\n        if(L1.cross(L2)>=0&&L2.cross(L3)>=0&&L3.cross(L1)>=0) return 1;\n        return 0;\n    }\n};\n\nbool ans[1000];\n\nint main()\n{\n    int n, i, tmp;\n    double x, y;\n    //freopen(\"out.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for(i=0;i<n;i++){\n        scanf(\"%lf %lf\", &x, &y);\n        Point P1(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P2(x, y);\n        Line L1(P1, P2);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P3(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P4(x, y);\n        Line L2(P3, P4);\n        ans[i]=L1.valid_intersection(L2);\n        printf(\"%d\\n\", ans[i]);\n    }\n    /*for(i=0;i<n;i++){\n        scanf(\"%d\", &tmp);\n        if(tmp!=ans[i]) printf(\"RRRRRR!!!!!! %d\\n\", i);\n    }*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\n\nint dcmp(double x) {\n        if(fabs(x) < eps) return 0;\n        return x < 0 ? -1 : 1;\n}\n\n#define Vector P\nstruct P {\n        double x, y;\n        P(double x = 0, double y = 0): x(x), y(y) {}\n        P operator + (P b) {return P(x + b.x, y + b.y);}\n        P operator - (P b) {return P(x - b.x, y - b.y);}\n        P operator * (double b) {return P(x * b, y * b);}\n        P operator / (double b) {return P(x / b, y / b);}\n        double operator * (P b) {return x * b.x + y * b.y;} // Dot\n        double operator ^ (P b) {return x * b.y - y * b.x;} // Cross\n        double abs() {return hypot(x, y);}\n        P unit() {return *this / abs();}\n        P spin(double o) {\n                double c = cos(o), s = sin(o);\n                return P(c * x - s * y, s * x + c * y);\n        }\n};\n\nstruct Line {\n        //ax + by + c = 0\n        double a, b, c, theta;\n        P pa, pb;\n        Line(): a(0), b(0), c(0), theta(0), pa(), pb() {}\n        Line(P pa, P pb): a(pa.y - pb.y), b(pb.x - pa.x), c(pa ^ pb), theta(atan2(-a, b)), pa(pa), pb(pb) {}        P projection(P p) {return pa + (pb - pa).unit() * ((pb - pa) * (p - pa) / (pb - pa).abs());}                P reflection(P p) {return p + (projection(p) - p) * 2;}\n        double get_ratio(P p) {return (p - pa) * (pb - pa) / ((pb - pa).abs() * (pb - pa).abs());}\n        P dis(P p) {return ((pb - pa) ^ (p - pa)) / (pb - pa).abs();} // directed distance\n};\n\nstruct Circle {\n        P c;\n        double r;\n        Circle(P c, double r = 0): c(c), r(r) {}\n};\nbool onsegment(P p, P a, P b) {\n        return dcmp((a - p) ^ (b - p)) == 0 && dcmp((a - p) * (b - p)) <= 0;\n}\nbool segment_intersection(P p1, P p2, P p3, P p4) { // end points are not allowed\n        return dcmp((p2 - p1) ^ (p3 - p1)) * dcmp((p2 - p1) ^ (p4 - p1)) < 0\n                && dcmp((p4 - p3) ^ (p1 - p3)) * dcmp((p4 - p3) ^ (p2 - p3)) < 0;\n\n}\n\nint main() {\n        ios_base::sync_with_stdio(false); cin.tie(0);\n        int q; cin >> q;\n        while(q--) {\n                P p0, p1, p2, p3;\n                cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n                if(segment_intersection(p0, p1, p2, p3) || onsegment(p0, p2, p3) || onsegment(p1, p2, p3) || onsegment(p2, p0, p1)|| onsegment(p3, p0, p1)) cout << 1 << '\\n';\n                else cout << 0 << '\\n';\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\nusing namespace std;\n\nconst double EPS = 1e-10;\ndouble add(double a, double b) {\n    if(abs(a+b) < EPS*(abs(a)+abs(b))) return 0;\n    return a+b;\n}\nstruct Vector {\n    double x, y;\n    Vector() {}\n    Vector(double x, double y):x(x), y(y) {}\n    Vector operator+(Vector v) {return Vector(add(x, v.x), add(y, v.y));}\n    Vector operator-(Vector v) {return Vector(add(x, -v.x), add(y, -v.y));}\n    Vector operator*(double d) {return Vector(x*d, y*d);}\n    Vector operator/(double d) {return Vector(x/d, y/d);}\n    double dot(Vector v) {return add(x*v.x, y*v.y);}\n    double cross(Vector v) {return add(x*v.y, -y*v.x);}\n};\nistream &operator>>(istream &is, Vector &v) {return is >> v.x >> v.y;}\nostream &operator<<(ostream &os, const Vector &v) {return os << v.x << ' ' << v.y;}\ndouble sqdist(Vector &v, const Vector &u) {return (v-u).dot(v-u);}\n//線分v2-v1上にあるか\nbool on_seg(Vector &v1,Vector &v2, const Vector &p) {\n    return (v1-p).cross(v2-p) == 0 && (v1-p).dot(v2-p) <= 0;\n}\n//v1-v2とu1-u2の交点\nVector intersection(Vector &v1,Vector &v2,Vector &u1,Vector &u2) {\n    assert((v1-v2).cross(u1-u2)); //2直線が平行だとだめ\n    return v1 + (v2-v1)*((u2-u1).cross(u1-v1)/(u2-u1).cross(v2-v1));\n}\n//p2-p1へのQの投影\nVector projection(Vector &p1,Vector &p2,Vector &Q) {\n    return p1+(p2-p1)*(Q-p1).dot(p2-p1)/sqdist(p1, p2);\n}\n//p1-p2を軸としたQの線対称移動\nVector reflection(Vector &p1,Vector &p2,Vector &Q) {\n    return projection(p1, p2, Q)*2-Q;\n}\nbool cmp_x(const Vector &v, const Vector &u) {\n    if(v.x != u.x) return v.x < u.x;\n    return v.y < u.y;\n}\n//頂点数nの頂点集合vv\nvector<Vector> convex_hull(vector<Vector> &vv, int n) {\n    sort(vv.begin(), vv.end(), cmp_x);\n    int k = 0;\n    vector<Vector> res(n*2);\n    for(int i = 0; i < n; i++) {\n        while(k > 1 && (res[k-1]-res[k-2]).cross(vv[i]-res[k-1]) <= 0) k--;\n        res[k++] = vv[i];\n    }\n    for(int i = n-2, t = k; i >= 0; i--) {\n        while(k > t && (res[k-1]-res[k-2]).cross(vv[i]-res[k-1]) <= 0) k--;\n        res[k++] = vv[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\nsigned main() {\n    Vector p0, p1, p2, p3;\n    int q;\n    cin >> q;\n    while(q--) {\n        cin >> p0 >> p1 >> p2 >> p3;\n        if((p0-p1).cross(p2-p3) == 0) {\n            if(on_seg(p1, p0, p2) or on_seg(p1, p0, p3) or on_seg(p2, p3, p0) or on_seg(p2, p3, p1)) {\n                cout << 1 << endl;\n            } else {\n                cout << 0 << endl;\n            }\n        } else {\n            Vector p = intersection(p0, p1, p2, p3);\n            cout << (on_seg(p0, p1, p) and on_seg(p2, p3, p)?1:0) << endl;\n            //cout << p << endl;\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// 平面幾何\n\n// int -> double -> Pointの暗黙の型変換を許した\n// メンバ変数をprivateにした\n// 代入演算子の戻り値とかにconstいっぱい付けた\n\n//   Segment::intersect(const Segment&)\n//   Circle::crosspoint(const Circle&)\n// のどっちかがバグってそう？ (AOJ1183)\n// crosspointは大丈夫？ (AOJ1132)\n\n// 通らない幾何問題\n// AOJ0153  円による点の包含　点と線分との距離　ccw\n// AOJ0187  線分の交差判定　線分同士の交点\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    while(n--) {\n        vector<Point> point(4);\n        for(auto& p: point) {\n            double x, y;\n            cin >> x >> y;\n            p = Point(x, y);\n        }\n        Segment s1 = Segment(point[0], point[1]);\n        Segment s2 = Segment(point[2], point[3]);\n        cout << (s1.intersect(s2) ? 1 : 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define chmax(a, b) a = (a >= b ? a : b)\n#define chmin(a, b) a = (a <= b ? a : b)\n#define out(a) cout << a << endl\n#define outa(a, n) { rep(_, n) cout << a[_] << \" \"; cout << endl; }\n#define outp(a, n) { cout << endl; rep(_, n) cout << a[_].F << \" \" << a[_].S << endl; }\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define abs(x) (x >= 0 ? x : -(x))\n#define ceil(a, b) a / b + !!(a % b)\n#define FIX(a) fixed << setprecision(a)\n#define LB(v, n) (int)(lower_bound(all(v), n) - v.begin())\n#define UB(v, n) (int)(upper_bound(all(v), n) - v.begin())\nll pow(ll a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\n\n\nusing P = complex<double>;\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nconst double eps = 1e-8;\n\nbool on_seg(P v1, P v2) {\n    // cout << abs(cross(v1, v2)) << \" \" << dot(v1, v2) << endl;\n    return (abs(cross(v1, v2)) < eps && dot(v1, v2) <= 0);\n}\nP intersection(P p0, P p1, P p2, P p3, P s1, P s2) {\n    double d1 = abs(cross(s2, p0 - p2));\n    double d2 = abs(cross(s2, p1 - p2));\n    double t = d1 / (d1 + d2);\n    return p0 + (p1 - p0) * t;\n}\nint main() {\n    int query;\n    cin >> query;\n    while (query--) {\n        int p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;\n        cin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n        P p0 = P(p0x, p0y), p1 = P(p1x, p1y), p2 = P(p2x, p2y), p3 = P(p3x, p3y);\n        P s1 = P(p1x - p0x, p1y - p0y), s2 = P(p3x - p2x, p3y - p2y);\n        \n        if (abs(cross(s1, s2)) < eps) { // 平行\n            bool os = (on_seg(p2 - p0, p2 - p1) || on_seg(p3 - p0, p3 - p1) || on_seg(p0 - p2, p0 - p3) || on_seg(p1 - p2, p1 - p3));\n            if (os) { // 線分上に頂点乗ってる\n                cout << 1 << endl;\n            } else {\n                cout << 0 << endl;\n            }\n        } else {\n            P r = intersection(p0, p1, p2, p3, s1, s2);\n            // cout << real(r) << \" \" << imag(r) << endl;\n            if (on_seg(p0 - r, p1 - r) && on_seg(p2 - r, p3 - r)) {\n                cout << 1 << endl;\n            } else {\n                cout << 0 << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nbool isCrossLineSegments(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n\treturn (((dy-cy)*ax-(dx-cx)*ay+cy*(dx-cx)-cx*(dy-cy))*((dy-cy)*bx-(dx-cx)*by+cy*(dx-cx)-cx*(dy-cy))<=0)&&(((by-ay)*cx-(bx-ax)*cy+ay*(bx-ax)-ax*(by-ay))*((by-ay)*dx-(bx-ax)*dy+ay*(bx-ax)-ax*(by-ay))<=0);\n}\n\nint main() {\n\tint ax,ay,bx,by,cx,cy,dx,dy,n,i;\n\tcin>>n;\n\tfor(i=0;i<n;++i){\n\t\tcin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n\t\tcout << (isCrossLineSegments(ax,ay,bx,by,cx,cy,dx,dy)?1:0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\n/// --------------------------------------------\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    pt A,B,C,D;\n    cin >> A >> B >> C >> D;\n    if( segmentsIntersect( A, B, C, D ) ) {\n      cout << \"1\\n\";\n    }\n    else {\n      cout << \"0\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef double D;\nconst D EPS = 1e-8;\nconst D INF = 1e10;\nconst D PI = M_PI;\n\nstruct P {\n    D x, y;\n    P(D xs, D ys) : x(xs), y(ys) { }\n    P() { }\n};\n\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P p, D s) { return P(p.x * s, p.y * s); }\n\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\n\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\n\nbool eq(P a, P b) { return abs(a - b) < EPS; }\n\nD arg(P p) { return atan2(p.y, p.x); }\n\nP rot90(P p) {\n    return P(-p.y, p.x);\n}\n\nP rot(P p, D radian) {\n    P q;\n    q.x = cos(radian)*p.x - sin(radian)*p.y;\n    q.y = sin(radian)*p.x + cos(radian)*p.y;\n    return q;\n}\n\nstruct L : vector<P> {\n    L(P a, P b) { push_back(a); push_back(b); }\n    L() { this->resize(2); }\n};\n\nstruct C {\n    P p; D r;\n    C(P ps, D rs) : p(ps), r(rs) { }\n    C() { }\n};\n\n// ??卒???l???????????????p?????????\n// (l??????p??????????????????????????即????????????????賊???????)\n// norm??則?????贈?????????(abs??則??????????????????)\nP projection(L l, P p) {\n    P a = l[1] - l[0];\n    P b = p - l[0];\n    D t = inp(b, a) / norm(a);\n    return l[0] + a * t;\n}\n\n// ??卒???l???????????????p???????属?\n// (l????????????????則属???p??????)\nP reflection(L l, P p) {\n    return p + (projection(l, p) - p) * 2;\n}\n\nint ccw(P a, P b, P c) {\n    b = b - a; c = c - a;\n\n    // a - b - c ????????????????????即???\n    if(outp(b, c) > EPS)  return +1; // ???????即???????\n    if(outp(b, c) < -EPS) return -1; // ????即???????\n\n    // a - b - c ??卒??????????????其??即???\n    if(inp(b, c) < 0)     return +2; // c - a - b\n    if(norm(b) < norm(c)) return -2; // a - b - c\n    return 0;                        // a - c - b\n}\n\nbool iSS(L s, L t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main() {\n    int Q; cin >> Q;\n    while(Q--) {\n        D x[4], y[4];\n        for(int i = 0; i < 4; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        L s(P(x[0], y[0]), P(x[1], y[1])), t(P(x[2], y[2]), P(x[3], y[3]));\n\n        int result;\n        if(iSS(s, t)) {\n            result = 1;\n        }\n        else {\n            result = 0;\n        }\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw_online(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tint c=ccw_online(p0,p1,p2);\n\tif(c==counter_clockwise||c==clockwise)return c;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//id of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\nint main()\n{\n\t//Segment s;\n\t//cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n\tint q;cin>>q;\n\t//Point a;\n\tSegment s1,s2;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y>>s2.p1.x>>s2.p1.y>>s2.p2.x>>s2.p2.y;\n\t\tif(intersect(s1,s2))cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n\n\nusing namespace std;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS) //?????????????????????????????????\n\n//??????p0,p1,p2????????????\n#define COUNTER_CLOCKWISE 1 //???????????§???????¨????????????´???\n#define CLOCKWISE  -1 //???????????§????¨????????????´???\n#define ONLINE_BACK 2 //p2,p0,p1??????????????§????????´?????????????????¨???\n#define ONLINE_FRONT -2//???????????§????????´?????????????????¨???\n#define ON_SEGMENT 0 //p2?????????p0 p1??????????????¨???\n\n\n//??????????????????????????????\nclass Point {\n\npublic:\n\n\tdouble x, y;//??§?¨????????????????x,y??????\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator * (double r) {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tPoint operator / (double r) {\n\t\treturn Point(x / r, y / r);\n\t}\n\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n\n\t//?????????????????§???????????????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS &&  fabs(y - p.y) < EPS;\n\t}\n\n};\n\ntypedef Point Vector;\n\n//??????????????????????????????\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//??????????????????????????????\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment() {}\n\n\t//?????¨????°???±?????????\n\tPoint projection(Point p) {\n\t\tVector base = p2 - p1;\n\n\t\tdouble r = dot(p - p1, base) / base.norm();\n\t\treturn p1 + base * r;\n\t}\n\n\t//????°??????????\n\tPoint reflection(Point p) {\n\t\treturn p + (projection(p) - p)*2.0;\n\t}\n\n\n};\n\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\n\n//?????????????????´?????????\nbool isOrthogonal(Vector a, Vector b);\n\n//??????????§??????¨?????????????????´?????????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\n\n//???????????´?????????\nbool isOrthogonal(Segment s1, Segment s2);\n\n//???????????????????????????\nbool isParallel(Vector a, Vector b);\n\n//??????????§??????¨???????????????????????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\n\n//?????????????????????\nbool isParallel(Segment s1, Segment s2);\n\n//?°???±?????????\nPoint projection(Segment s, Point p);\n\n//????°??????????\nPoint reflection(Segment s, Point p);\n\n//2??????????????¢?????????\ndouble getDistance(Point a, Point b);\n\n//??´?????¨???????????¢?????????\ndouble getDistanceLP(Line l, Point p);\n\n//????????¨???????????¢?????????\ndouble getDistanceSP(Segment s, Point p);\n\n//??????s1??¨??????s2????????¢?????????\ndouble getDistance(Segment s1, Segment s2);\n\n\n//???????????¢????????????\nint ccw(Point p0, Point p1, Point p2);\n\n//??????p1p2??¨??????p2p3???????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4);\n\n//??????s1??¨??????s2???????????????\nbool intersect(Segment s1, Segment s2);\n\n\n\n//?????????????????´?????????\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\n//??????????§??????¨?????????????????´?????????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\n//???????????´?????????\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//???????????????????????????\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\n//??????????§??????¨???????????????????????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\n//?????????????????????\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//?°???±?????????\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n//????°??????????\nPoint reflection(Segment s, Point p) {\n\treturn p + (projection(s, p) - p)*2.0;\n}\n\n//2??????????????¢?????????\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\n//??´?????¨???????????¢?????????\ndouble getDistanceLP(Line l, Point p) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\n//????????¨???????????¢?????????\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\treturn (p - s.p1).abs();\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) {\n\t\treturn (p - s.p2).abs();\n\t}\n\n\treturn getDistanceLP(s, p);\n}\n\n//??????s1??¨??????s2????????¢?????????\ndouble getDistance(Segment s1, Segment s2) {\n\n\tif (intersect(s1, s2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n\n//???????????¢????????????\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > EPS) {//???????¨?????????????\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\tif (cross(a, b) < -EPS) {//????¨?????????????\n\t\treturn CLOCKWISE;\n\t}\n\tif (dot(a, b) < -EPS) {//p2,p0,p1??????????????§????????´?????????????????????\n\t\treturn ONLINE_BACK;\n\t}\n\tif (a.norm() < b.norm()) {//p0,p1,p2??????????????§????????´?????????????????????\n\t\treturn ONLINE_FRONT;\n\t}\n\n\treturn ON_SEGMENT;//??????p0 p1??????p2???????????????\n\n}\n\n//??????p1p2??¨??????p2p3???????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\n//??????s1??¨??????s2???????????????\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\n\n\n\n\n\n//???\nclass Circle {\npublic:\n\tPoint c;//??????\n\tdouble r;//??????\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n\nint main(void)\n{\n\tint n;\n\n\tSegment s1, s2;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y;\n\t\tcin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\n\t\tcout << ((intersect(s1, s2)) ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0) :x(x), y(y) {};\n\t\n\tpoint operator + (point p) { return point(x + p.x, y + p.y); }\n\tpoint operator - (point p) { return point(x - p.x, y - p.y); }\n\tpoint operator * (double s) { return point(x * s, y * s); }\n\tpoint operator / (double s) { return point(x / s, y / s); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\tbool operator < (const point &p) const\n\t{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const point &p) const\n\t{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ndouble dot(point a, point b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nstruct line\n{\n\tpoint a, b;\n\tline(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0) :a(point(x1, y1)), b(point(x2, y2)) {};\n\n\tpoint univec() { return (b - a) / (b - a).norm(); }\n};\n\nbool isis_ss(line s, line t)\n{\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < EPS &&\n\t\tcross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < EPS);\n}\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tdouble x[8];\n\t\tREP(i, 8) cin >> x[i];\n\t\tline s(x[0], x[1], x[2], x[3]);\n\t\tline t(x[4], x[5], x[6], x[7]);\n\t\tcout << isis_ss(s, t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass Vec;\nVec operator/(const Vec& v, const double& divisor);\nVec operator*(const double& scale, const Vec& v);\n\nclass Vec {\n  using F = double;\n  vector<F> container;\n\n public:\n  Vec(size_t size) : container(size) {}\n  Vec(initializer_list<F> elements)\n      : container(elements.begin(), elements.end()) {}\n  size_t dim() const { return container.size(); }\n  F& operator[](const size_t size) { return container.at(size); }\n  const F& operator[](const size_t size) const { return container.at(size); }\n  Vec operator+(const Vec& other) const {\n    Vec ret(*this);\n    for (size_t i = 0; i < dim(); i++) ret[i] += other[i];\n    return ret;\n  }\n  Vec operator-(const Vec& other) const { return (*this) + (-other); }\n  Vec operator-() const { return -1.0 * (*this); }\n  F inner(const Vec& other) const {\n    F acc = 0;\n    for (size_t i = 0; i < dim(); i++) {\n      acc += (*this)[i] * other[i];\n    }\n    return acc;\n  }\n  F norm() const { return sqrt(inner(*this)); }\n  Vec unit() const { return (*this) / this->norm(); }\n  F ccw(const Vec& other) const {\n    return (*this)[0] * other[1] - other[0] * (*this)[1];\n  }\n};\nVec operator/(const Vec& v, const double& divisor) { return 1.0 / divisor * v; }\nVec operator*(const double& scale, const Vec& v) {\n  Vec ret(v);\n  for (size_t i = 0; i < ret.dim(); i++) ret[i] *= scale;\n  return ret;\n}\n\nclass Segment {\n  const Vec m_start;\n  const Vec m_end;\n\n public:\n  Segment(const Vec& start, const Vec& end) : m_start(start), m_end(end) {}\n  bool intersect(const Segment& other, const double eps) {\n    const Vec u = other.m_start - m_start, w = other.m_end - m_start;\n    const Vec v0 = m_end - m_start, v1 = other.m_end - other.m_start;\n\n    const double vn = v0.norm();\n    double u_v = v0.inner(u) / vn;\n    double w_v = v0.inner(w) / vn;\n    if (abs(abs(u_v / u.norm()) - 1) < eps &&\n        abs(abs(w_v / w.norm()) - 1) < eps) {\n      if (u_v > w_v) {\n        swap(u_v, w_v);\n      }\n      return !(u_v > vn + eps || w_v < -eps);\n    }\n    bool cond1 =\n        v0.ccw(other.m_start - m_start) * v0.ccw(other.m_end - m_start) < eps;\n    bool cond2 =\n        v1.ccw(m_start - other.m_start) * v1.ccw(m_end - other.m_start) < eps;\n    return cond1 && cond2;\n  }\n};\n\nint main() {\n  int q;\n  cin >> q;\n\n  rep(i, q) {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    if (Segment(Vec({x0, y0}), Vec({x1, y1}))\n            .intersect(Segment(Vec({x2, y2}), Vec({x3, y3})), 1e-9)) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <utility>\n#define EPS 1e-16\n\n#define COUNTER_CLOCKWISE \t1\n#define CLOCKWISE \t\t\t-1\n#define ON_LINE_BACK\t\t2\n#define ON_LINE_FRONT\t\t-2\n#define ON_SEGMENT\t\t\t0\n\ntypedef std::pair<double, double> point;\n\nclass C{ friend point operator - (point, point); };\npoint operator - (point p0, point p1)\t{ return point(p0.first - p1.first, p0.second - p1.second); }\n\ndouble cross(point p0, point p1)\t{ return p0.first * p1.second - p1.first * p0.second; }\ndouble dot(point p0, point p1)\t\t{ return p0.first * p1.first + p0.second * p1.second; }\ndouble norm(point p)\t\t\t\t{ return sqrt(pow(p.first, 2) + pow(p.second, 2));\t  }\n\nint ccw(point p0, point p1, point p2)\n{\n\tpoint a = p1 - p0, b = p2 - p0;\n\tif( cross(a, b) > EPS ) \treturn COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS )\treturn CLOCKWISE;\n\tif( dot(a, b) < -EPS ) \t\treturn ON_LINE_BACK;\n\tif( norm(a) < norm(b))\t\treturn ON_LINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool isIntersected(point p0, point p1, point p2, point p3)\n{\n\treturn ( (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) &&\n\t\t\t (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0) );\n}\n\nint main(void)\n{\n\tint n;\n\tpoint p0, p1, p2, p3;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &p0.first, &p0.second, &p1.first, &p1.second, &p2.first, &p2.second, &p3.first, &p3.second);\n\t\tprintf(\"%d\\n\", isIntersected(p0, p1, p2, p3));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl; \n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF = 1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n//幾何だいっきらい\n \nusing Real=double;\nusing Point=complex<Real>;\nconst Real EPS=1e-10;\nconst Real pi=acosl(-1);\n \ninline bool eq(Real a,Real b){\n   return fabs(a-b)<EPS;\n}\n \nPoint operator*(const Point &p,const Real &d){\n   return Point(real(p)*d,imag(p)*d);\n}\n \n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point &p) {\n return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\n \n \nReal radian_to_degree(Real r){\n   return r*180.0/pi;\n}\n \nReal degree_to_radian(Real d){\n   return d*pi/180.0;\n}\n \n//三角形の面積，サラスの公式\nReal area_triangle(Point a,Point b,Point c){\n   Point x=b-a,y=c-a;\n   return fabs(x.real()*y.imag()-x.imag()*y.real())/2;\n}\nstruct Circle{\n   Point center;\n   Real r;\n   Circle(Point center,Real r):center(center),r(r){}\n};\n \n \nstruct Line{\n    Point p1,p2;\n    Line(Point p1,Point p2):p1(p1),p2(p2){}\n \n    //Ax + By = C\n    Line(Real A,Real B,Real C){\n       if(eq(A,0))     p1=Point(0,C/B),p2=Point(1,C/B);\n       else if(eq(B,0))p1=Point(C/A,0),p2=Point(C/A,1);\n       else            p1=Point(0,C/B),p2=Point(C/A,0);\n    }\n};\n \nstruct Segment:Line{\n   Segment()=default;\n   Segment(Point p1,Point p2):Line(p1,p2){}\n};\n \n//v\n//外積\nReal cross(const Point &a, const Point &b) {\n return real(a)*imag(b)-imag(a)*real(b);\n}\n \n//v\n//内積\nReal dot(const Point &a, const Point &b) {\n return real(a)*real(b)+imag(a)*imag(b);\n}\n \n//v\n//平行判定，外積0かをみる\nbool parallel(Line &a,Line &b){\n   return eq(cross(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n \n//v\n//垂直判定，内積0かをみる\nbool orthogonal(Line &a,Line &b){\n   return eq(dot(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n \n//v\n//正射影，pからlに下した推薦の足を求める\nPoint projection(const Line &l, const Point &p){\n    //ベクトルl上のどの位置に垂線の足が来るか求める\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\nPoint projection(const Segment &l, const Point &p){\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\n \n//v\n//反射，直線lに関し点pと線対称な点を返す\nPoint reflection(const Line &l, const Point &p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\nPoint reflection(const Segment &l, const Point &p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\n \n//二点間の距離\nReal dis(Point a,Point b){\n   return abs(a-b);\n} \n//点と直線の距離\nReal dis(const Line &l,const Point &p){\n    return abs(p-projection(l,p));\n}\n//\n\n//v\n//COUNTER CLOCKWISE，返す値は↓を参照\n//https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_C\nint ccw(Point p0,Point p1,Point p2){\n    Real c=cross(p1-p0,p2-p0);\n    Real d=dot(p1-p0,p2-p0);\n    if(c>EPS)           return 1; //反時計回り       COUNTER CLOCKWISE\n    else if(c<-EPS)     return -1;//時計回り         CLOCKWISE\n    else if(d<0)        return 2; //p1の反対側にp2   ONLINE BACK\n    else if(dis(p0,p1)<dis(p0,p2))  return -2;//     ONLINE FRONT\n    else                            return 0;//     ON SEGMENT\n}\n \n//v\n//3点が作る三角形の外心\n//面積0の三角形を渡すと分母に面積があるので壊れるかも\nPoint circumcenter(const Point &A,const Point &B,const Point &C){\n    Real S=area_triangle(A,B,C);\n    Real a=dis(B,C),b=dis(A,C),c=dis(A,B);\n    return A*(a*a*(b*b+c*c-a*a)/(16*S*S))+B*(b*b*(c*c+a*a-b*b)/(16*S*S))+C*(c*c*(a*a+b*b-c*c)/(16*S*S));\n}\n \n\n//交差判定\n//直線状に乗るか\nbool intersect(const Line &l,const Point &p){\n    return abs(ccw(l.p1,l.p2,p))!=1;\n}\n//直線の交差判定，外積\nbool intersect(const Line &l1,const Line &l2){\n    return abs(cross(l1.p2-l1.p1,l2.p2-l2.p1))>EPS or\n        abs(cross(l1.p2-l1.p1,l2.p2-l1.p1))<EPS;\n}\n//線分に点が乗るかの判定，ccw\nbool intersect(const Segment &s,const Point &p){\n    return ccw(s.p1,s.p2,p)==0;\n}\n//直線と線分の交差判定\nbool intersect(const Line &l,const Segment &s){\n    return cross(l.p2-l.p1,s.p1-l.p1)*cross(l.p2-l.p1,s.p2-l.p1)<EPS;\n}\n//円と直線の交差判定\nbool intersect(const Circle &c,const Line &l){\n    return dis(l,c.center)<=c.r+EPS;\n}\n//円上かどうか，内部かどうかではない\nbool intersect(const Circle &c,const Point &p){\n    return abs(abs(p-c.center)-c.r)<EPS;\n}\n//線分と線分の交差判定\nbool intersect(const Segment &s,const Segment &t){\n    return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <=0 and\n        ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;\n}\n\n \n//v\n//最小包含円を返す　計算量は期待値O(n)\nCircle MinimumBoundingCircle(vector<Point> v){\n   int n=v.size();\n  \n   //ランダムシャッフル．いぢわるされたくないもんだ\n   mt19937 mt(time(0));\n   shuffle(v.begin(),v.end(),mt);\n \n   Circle ret(0,0);\n   //2点で円を作る\n   auto make_circle2=[&](Point a,Point b){\n       return Circle((a+b)*0.5,dis(a,b)/2);\n   };\n   //3点で円を作る\n   auto make_circle3=[&](Point A,Point B,Point C){\n       Point cent=circumcenter(A,B,C);\n       return Circle(cent,dis(cent,A));\n   };\n   auto isIn=[&](Point a){\n       return dis(ret.center,a)<ret.r+EPS;\n   };\n \n   ret=make_circle2(v[0],v[1]);\n   for(int i=2;i<n;i++){\n       //v[i]が円に入っていないなら\n       if(!isIn(v[i])){\n           //円内にないなら点v[i]は必ず円周上に来る\n           ret=make_circle2(v[0],v[i]);\n           for(int j=1;j<i;j++){\n               if(!isIn(v[j])){\n                   //この時iとjが円周上を考える\n                   ret=make_circle2(v[i],v[j]);\n                   //最後の1点の決定\n                   for(int k=0;k<j;k++){\n                       if(!isIn(v[k])){\n                           ret=make_circle3(v[i],v[j],v[k]);\n                       }\n                   }\n               }\n           }\n       }\n   }\n   return ret;\n}\n \nsigned main(){\n   cin.tie(0);\n   ios::sync_with_stdio(0);\n   cout<<fixed<<setprecision(12);\n    \n    int q;cin>>q;\n    while(q--){\n        Real x[4],y[4];\n        rep(i,4){\n            cin>>x[i]>>y[i];\n        }\n        Segment l(Point(x[0],y[0]),Point(x[1],y[1])),\n                m(Point(x[2],y[2]),Point(x[3],y[3]));\n        cout<<intersect(l,m)<<endl;\n    }\n    return 0;\n}\n \n \n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cfloat>\n\nusing namespace std;\n\n#define INFLD numeric_limits<double>::infinity()\n// #define INF (int)1e8\n// #define INFLL (long long)1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\nnamespace geometry {\n  struct coordinate {\n    double x, y;\n    bool operator<(const coordinate & another) const {\n      return x != another.x ? x < another.x : y < another.y;\n    }\n  };\n  struct line {\n    double a, b, c;\n    pair<double, double> domain; // if b == 0, domain means range \n  };\n  enum linetype {\n    LINE, HALFLINE, SEGMENT\n  };\n  // ax + by + c = 0\n  line make_line(double a, double b, double c, pair<double, double> domain = { -INFLD, INFLD }) {\n    return{ a,b,c,domain };\n  }\n  // line from p through q when type is HALFLINE\n  line make_line_through(coordinate p, coordinate q, linetype type = LINE) {\n    line ret = { NAN, NAN, NAN,{ NAN,NAN } };\n    if (p.x == q.x && p.y == q.y) return ret;\n    else {\n      if (p.x == q.x) {\n        ret = { 1, 0, -p.x, {-INFLD, INFLD} };\n        switch (type) {\n        case SEGMENT:\n          if (p.y > q.y) ret.domain = { q.y, p.y };\n          else ret.domain = { p.y, q.y };\n          return ret;\n        case HALFLINE:\n          if (p.y > q.y) ret.domain = { -INFLD, p.y };\n          else ret.domain = { p.y, INFLD };\n          return ret;\n        case LINE:\n          return ret;\n        }\n      }\n      else {\n        ret = { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y,{ -INFLD, INFLD } };\n        switch (type) {\n        case SEGMENT:\n          if (p.x > q.x) ret.domain = { q.x, p.x };\n          else ret.domain = { p.x, q.x };\n          return ret;\n        case HALFLINE:\n          if (p.x > q.x) ret.domain = { -INFLD, p.x };\n          else ret.domain = { p.x, INFLD };\n          return ret;\n        case LINE:\n          return ret;\n        }\n      }\n    }\n  }\n  class Two_Lines {\n  private:\n    line l;\n    line m;\n    coordinate crosspoint; // (NAN, NAN) when not existing\n    bool in_range(coordinate p, line l) {\n      if (l.b == 0) {\n        if (l.domain.first <= p.y && p.y <= l.domain.second) return true;\n        else return false;\n      }\n      else {\n        if (l.domain.first <= p.x && p.x <= l.domain.second) return true;\n        else return false;\n      }\n    }\n  public:\n    bool is_intersect; // include having common interval\n    bool is_parallel; // include having common interval\n    Two_Lines(line l, line m) {\n      Two_Lines::l = l;\n      Two_Lines::m = m;\n      is_intersect = false;\n      is_parallel = false;\n      crosspoint = { NAN, NAN };\n      double dn = l.a * m.b - m.a * l.b;\n      if (dn == 0) {\n        is_parallel = true;\n        if (l.a * m.c - m.a * l.c);\n        else if (l.b * m.c - m.b * l.c);\n        else {\n          if (l.domain.first <= m.domain.second && m.domain.first <= l.domain.second) is_intersect = true;\n          else is_intersect = false;\n        }\n      }\n      else {\n        crosspoint.x = (l.b * m.c - m.b * l.c) / dn;\n        crosspoint.y = (m.a * l.c - l.a * m.c) / dn;\n        if (in_range(crosspoint, l) && in_range(crosspoint, m)) {\n          is_intersect = true;\n        }\n        else {\n          crosspoint = { NAN, NAN };\n        }\n      }\n    }\n    double get_distance() {\n      return 0;\n    }\n    coordinate get_crosspoint() {\n      return crosspoint;\n    }\n  };\n}\n\nint main() {\n  using namespace geometry;\n  int q; cin >> q;\n  Loop(i, q) {\n    coordinate p, q;\n    line l, m;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    l = make_line_through(p, q, SEGMENT);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    m = make_line_through(p, q, SEGMENT);\n    Two_Lines tls(l, m);\n    cout << tls.is_intersect << endl;\n  }\n}\n\n/*\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (p.valid) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// geo\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(double a) { return Point(x * a, y * a); }\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator==(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nclass vector<Point> Polygon;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\n\ndouble abs(Vector a) { return sqrt(norm(a)); }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\n#define STR(var) #var\n\nenum Position {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ON_SEGMENT = 0,\n    ONLINE_FRONT = -2\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    enum Position p;\n    if (cross(a, b) > EPS)\n        p = COUNTER_CLOCKWISE;\n    else if (cross(a, b) < -EPS)\n        p = CLOCKWISE;\n    else if (dot(a, b) < -EPS)\n        p = ONLINE_BACK;\n    else if (a.norm() < b.norm())\n        p = ONLINE_FRONT;\n    else\n        p = ON_SEGMENT;\n    return p;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    Point a[n], b[n], c[n], d[n];\n    REP(i, n) {\n        cin >> a[i].x >> a[i].y >> b[i].x >> b[i].y >> c[i].x >> c[i].y >>\n            d[i].x >> d[i].y;\n    }\n    REP(i, n) {\n        if (intersect(a[i], b[i], c[i], d[i]))\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst double EPS =  1e-10;\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y){}\n\n    Point operator + (Point p){\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p){\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (Point p){\n        return Point(x * p.x, y * p.y);\n    }\n    Point operator * (double r){\n        return Point(x * r, y * r);\n    }\n    Point operator / (Point p){\n        return Point(x / p.x, y / p.y);\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n    \n    \n};\n\ntypedef Point Vector;\n\nclass Segment : public Point{\n    public:\n    Point p1, p2;\n    Segment(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Segment(double a, double b, double c, double d){\n        Point(a, b);\n        Point(c, d);\n    }\n    \n};\n\ntypedef Segment Line;\n\ndouble dot(Point a, Point b){\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b){\n    return a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Point a, Point b){\n    return equals(dot(a, b), 0.0);\n}\nbool isParallel(Point a, Point b){\n    return equals(cross(a, b), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s1.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    //Vector tmp = s.p1 + base * r;\n    Vector tmp = base * r;\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2;\n}\n\nint ccw(Point p1, Point p2, Point p3){\n    Vector a = p2 - p1;\n    Vector b = p3 - p1;\n    if( cross(a, b) > EPS ) return 1;\n    else if( cross(a, b) < -EPS ) return -1;\n    else if( dot(a, b) < -EPS ) return 2;\n    else if( a.norm() < b.norm() ) return -2;\n    //std::cout << std::fixed << std::setprecision(10) << ans.x << \" \" << ans.y << std::endl;\n    else return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint main(void){\n    Point p0, p1, p2, p3;\n    \n    \n    int q;\n    std::cin >> q;\n\n    for(int i = 0; i < q; i++){\n        std::cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        std::cout << intersect(p0, p1, p2, p3) << std::endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nstring ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return \"COUNTER_CLOCKWISE\";\n  if(cross(d,e)<0) return \"CLOCKWISE\";\n  if(dot(d,e)<0) return \"ONLINE_BACK\";\n  if(abs(d) < abs(e)) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nbool are_crossing(complex<double> a1, complex<double> a2, complex<double> b1, complex<double> b2){\n    double ta = (a1.real() - a2.real()) * (b1.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b1.real());\n    double tb = (a1.real() - a2.real()) * (b2.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b2.real());\n    double tc = (b1.real() - b2.real()) * (a1.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a1.real());\n    double td = (b1.real() - b2.real()) * (a2.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a2.real());\n    return (ta*tb < 0.0 && tc*td < 0.0);\n}\n\nint main(){\n    int q;\n    cin >> q;\n    double re, im;\n    vector< complex<double> > v(4);\n    for(int i=0;i<q;i++){\n        for(int j=0;j<4;j++){\n            cin >> re >> im;\n            v[j].real(re);\n            v[j].imag(im);\n        }\n        cout << are_crossing(v[0], v[1], v[2], v[3]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\ntypedef complex<double> C;\ntypedef pair<C,C> pp;\ntypedef vector<C> VP;\n#define eq(a,b) (fabs(a-b)<eps)\n#define veq(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\nconst C O{0,0};\n\nvoid In(C& p){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp=C(x,y);\n}\n\nvoid Out(C p){\n\tcout<<p.real()<<' '<<p.imag()<<endl;\n}\n\ndouble Dot(C p,C q){\n\treturn p.real()*q.real()+p.imag()*q.imag();\n}\n\ndouble Det(C p,C q){\n\treturn p.real()*q.imag()-q.real()*p.imag();\n}\n\nC Normal(C p){\n\treturn C(p.imag(),-p.real());\n}\n\nbool Comp(C p,C q){\n\tif(eq(p.real(),q.real())) return p.imag()<q.imag();\n\treturn p.real()<q.real();\n}\n\nint Clock(C a,C b,C c){\n\tdouble t=Det(b-a,c-a);\n\tif(t>eps) return 1;\n\tif(t<-eps) return -1;\n\tif(Dot(b-a,c-a)<-eps) return 2;\n\tif(Dot(a-b,c-b)<-eps) return -2;\n\treturn 0;\n}\n\nbool is_Orthgonal(C a,C b,C c,C d){\n\treturn eq(Dot(a-b,c-d),0);\n}\n\nbool is_Parallel(C a,C b,C c,C d){\n\treturn eq(Det(a-b,c-d),0);\n}\n\nbool is_Cross(C a,C b,C c,C d){\n\tif(is_Parallel(a,b,c,d)){\n\t\tif(Clock(a,b,c)==0||Clock(a,b,d)==0) return 1;\n\t\treturn 0;\n\t}\n\treturn Clock(a,b,c)*Clock(a,b,d)<=0&&Clock(c,d,a)*Clock(c,d,b)<=0;\n}\n\nint n;\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tC a,b,c,d;\n\t\tIn(a);In(b);In(c);In(d);\n\t\tcout<<is_Cross(a,b,c,d)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    // printf(\"Line: %lfx + %lfy + %lf = 0\\n\", a, b, c);\n    // printf(\"Point: (%lf, %lf), (%lf, %lf)\\n\", p1.x, p1.y, p2.x, p2.y);\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n    // printf(\"M1 = %lf, M2 = %lf\\n\", m1, m2);\n    // printf(\"OK: %d %d\\n\", dcmp(m1), dcmp(m2));\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) {\n    // printf(\"%lfx + %lfy + %lf = 0 contains (%lf, %lf): %d [%lf]\\n\", a, b, c,\n    //        p.x, p.y, dcmp(a * p.x + b * p.y + c), a * p.x + b * p.y + c);\n    return dcmp(a * p.x + b * p.y + c);\n  }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() {\n    // printf(\"Sline: (%lf, %lf) and (%lf, %lf)\\n\", p1.x, p1.y, p2.x, p2.y);\n    return line(p1, p2);\n  }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    // printf(\"Segment (%lf, %lf) - (%lf, %lf) contains (%lf, %lf): %d\\n\", p1.x,\n    //        p1.y, p2.x, p2.y, p.x, p.y, ok);\n    return ok;\n  }\n  optional<point> intersect(segment s) {\n    optional<point> r = sline().intersect(s.sline());\n    if (!r.has)\n      return r;\n    point p = r.val;\n    // printf(\"Possibly: (%lf, %lf)\\n\", p.x, p.y);\n    if (contains(p) && s.contains(p))\n      return r;\n    return optional<point>();\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1).has;\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Vector {\npublic:\n  double x, y;\n  Vector() {}\n  Vector(double x, double y) : x(x), y(y) {}\n\n  Vector operator+(Vector v) { return Vector(x + v.x, y + v.y); }\n  Vector operator-(Vector v) { return Vector(x - v.x, y - v.y); }\n  Vector operator*(double s) { return Vector(s * x, s * y); }\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\n\n// inner product\ndouble dot(Vector v1, Vector v2) { return v1.x * v2.x + v1.y * v2.y; }\n\n// cross product\ndouble cross(Vector v1, Vector v2) { return v1.x * v2.y - v1.y * v2.x; }\n\nclass Line {\npublic:\n  Vector v1, v2;\n  Line() {}\n  Line(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n};\nclass Segment {\npublic:\n  Vector v1, v2;\n  Segment() {}\n  Segment(Vector v1, Vector v2) : v1(v1), v2(v2) {}\n  operator Line() const { return Line(v1, v2); }\n};\n\nbool is_parrallel(Vector a, Vector b) { return equals(cross(a, b), 0); }\nbool is_parrallel(Line a, Line b) {\n  return is_parrallel(a.v1 - a.v2, b.v1 - b.v2);\n}\nbool is_parrallel(Segment a, Segment b) {\n  return is_parrallel((Line)a, (Line)b);\n}\n\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0); }\nbool is_orthogonal(Line a, Line b) {\n  return is_orthogonal(a.v1 - a.v2, b.v1 - b.v2);\n}\n\nVector project(Line l, Vector v) {\n  Vector a = v - l.v1;\n  Vector b = l.v2 - l.v1;\n  return l.v1 + b * (dot(a, b) / b.norm());\n}\n\nVector reflect(Line l, Vector v) { return v + (project(l, v) - v) * 2.0; }\n\ndouble distance(Line l, Vector v) { return (v - project(l, v)).abs(); }\ndouble distance(Vector v1, Vector v2) { return (v1 - v2).abs(); }\nbool in_segment(Segment s, Vector v) {\n  return dot(s.v2 - s.v1, v - s.v1) > 0 && dot(s.v1 - s.v2, v - s.v2) > 0;\n}\ndouble distance(Segment s, Vector v) {\n  auto m = project((Line)s, v);\n  if (in_segment(s, m)) {\n    return distance(m, v);\n  } else\n    return min(distance(s.v1, v), distance(s.v2, v));\n}\nbool opposite(Line l, Vector v1, Vector v2) {\n  auto a = l.v2 - l.v1;\n  auto b = v1 - l.v1;\n  auto c = v2 - l.v1;\n  return cross(a, b) * cross(a, c) < 0;\n}\nenum Direction {\n  ONLINE_FRONT = -2,\n  CLOCKWISE = -1,\n  ON_SEGMENT = 0,\n  COUNTER_CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n};\nDirection ccw(Vector v0, Vector v1, Vector v2) {\n  auto a = v1 - v0;\n  auto b = v2 - v0;\n  if (cross(a, b) > 0)\n    return COUNTER_CLOCKWISE;\n  if (cross(a, b) < 0)\n    return CLOCKWISE;\n  if (dot(a, b) < 0)\n    return ONLINE_BACK;\n  if (a.norm() < b.norm())\n    return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nvoid printd(Direction d) {\n  switch (d) {\n  case COUNTER_CLOCKWISE:\n    printf(\"COUNTER_CLOCKWISE\\n\");\n    break;\n  case CLOCKWISE:\n    printf(\"CLOCKWISE\\n\");\n    break;\n  case ONLINE_BACK:\n    printf(\"ONLINE_BACK\\n\");\n    break;\n  case ONLINE_FRONT:\n    printf(\"ONLINE_FRONT\\n\");\n    break;\n  case ON_SEGMENT:\n    printf(\"ON_SEGMENT\\n\");\n    break;\n  }\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return ccw(s1.v1, s1.v2, s2.v1) * ccw(s1.v1, s1.v2, s2.v2) <= 0 &&\n  ccw(s2.v1, s2.v2, s1.v1) * ccw(s2.v1, s2.v2, s1.v2) <= 0;\n}\n\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) {\n    return 0;\n  }\n  return min({distance(s1, s2.v1), distance(s1, s2.v2), distance(s2, s1.v1),\n              distance(s2, s1.v2)});\n}\n\nint main() {\n  int nq;\n  cin >> nq;\n  for (int i = 0; i < nq; i++) {\n    Segment seg[2];\n    for (int j = 0; j < 2; j++) {\n      int x0, y0, x1, y1;\n      cin >> x0 >> y0 >> x1 >> y1;\n      seg[j] = Segment(Vector(x0, y0), Vector(x1, y1));\n    }\n    printf(\"%d\\n\", intersect(seg[0], seg[1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(){\n\n    int q; cin >> q;\n    for(int i = 0; i < q; i++){\n        P p0, p1, p2, p3; cin >> p0.real() >> p0.imag() >> p1.real() >> p1.imag() >> p2.real() >> p2.imag() >> p3.real() >> p3.imag();\n        if(is_intersected_ls(p0, p1, p2, p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\ntypedef long double ld;\nconst ld global_eps=1e-8;\n#if 0\nenum cases{insi,bord,outs};//inside, border, outside\nenum cases{para,coin,inte};//parallel, coincide, intersect\n#else\nenum Case\n{\n    insi,bord,outs,//inside, border, outside\n    para,coin,inte, //parallel, coincide, intersect\n    tang,tang_in,tang_out //tangent\n};\n#endif\nint sign(ld x,ld eps=global_eps){return (x>=eps)-(x<=-eps);}\nint cmp(ld a,ld b,ld eps=global_eps){return sign(a-b,eps);}\nstruct Point\n{\n    ld x,y;\n    Point():x(0),y(0){}\n    Point(ld _x,ld _y):x(_x),y(_y){}\n    Point operator +(const Point &p) const\n    {return Point(x+p.x,y+p.y);}\n    Point operator -(const Point &p) const\n    {return Point(x-p.x,y-p.y);}\n    ld operator *(const Point &p) const\n    {return x*p.x+y*p.y;}\n    ld operator %(const Point &p) const\n    {return x*p.y-y*p.x;}   \n    bool operator <(const Point &p) const\n    {return tie(y,x) < tie(p.y,p.x);}\n    bool operator ==(const Point &p) const\n    {return tie(y,x) == tie(p.y,p.x);}\n    Point operator /(const ld &l) const\n    {return Point(x/l,y/l);}\n    Point operator *(const ld &l) const\n    {return Point(x*l,y*l);}\n    ld len() const{return hypot(x,y);}\n    ld len2() const{return x*x+y*y;}\n    ld dis(const Point &a)const{return (*this-a).len();}\n    ld dis2(const Point &a)const{return (*this-a).len2();}\n    Point unit()const{return *this/len();}\n    Point resize(const ld &l)const{return unit()*l;}\n};\nstruct Line\n{\n    Point p1,p2;\n    Line(){}\n    Line(Point a,Point b):p1(a),p2(b){}\n    Point way() const{return p2-p1;}\n    Point norm() const{return {p1.y-p2.y,p2.x-p1.x};}\n    bool online(const Point &p) const{return sign((p-p1)%way())==0;}\n    bool onsegment(const Point &p)const\n    {\n        return online(p) && sign((p-p1)*(p2-p))>=0;\n    }\n    pair<int,Point> intersect(const Line &I) const\n    {\n        if(sign(I.way()%way())==0) return {online(I.p1)?coin:para,{0,0}};\n        const Point &p3=I.p1,&p4=I.p2;\n        auto _143=(p1-p4)%(p4-p3),_342=(p3-p4)%(p4-p2);\n        return {inte,(p1*_342+p2*_143)/(_143+_342)};\n    }\n    ld linedistance(const Point &p) const\n    {\n        return abs((p-p1)%way())/way().len();\n    }\n    Point project(const Point &p) const\n    {\n        return intersect(Line(p,p+norm())).second;\n    }\n    ld segmentdistance(const Point &p) const\n    {\n        const auto &pro=project(p);\n        if(onsegment(pro)) return p.dis(pro);\n        return min(p.dis(p1),p.dis(p2));\n    }\n};\nint main()\n{\n    int t;RI(t);\n    while(t--)\n    {\n        Point p[4];\n        REP(i,4) cin>>p[i].x>>p[i].y;\n        Line I(p[0],p[1]),J(p[2],p[3]);\n        auto ans=I.intersect(J);\n        if(ans.F==para) PL(0);\n        else if(ans.F==coin)\n        {\n            bool ok=0;\n            REP(i,4) ok|=(i<2?J:I).online(p[i]);\n            if(ok) PL(1);\n            else PL(0);\n        }\n        else if(I.onsegment(ans.S)) PL(1);\n        else PL(0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nstring ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return \"COUNTER_CLOCKWISE\";\n  if(cross(d,e)<0) return \"CLOCKWISE\";\n  if(dot(d,e)<0) return \"ONLINE_BACK\";\n  if(abs(d) < abs(e)) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = ((c-d)/abs(c-d))*(abs(c-d)*d.y)/(d.y-c.y)+d;\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\tint\tp0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0;\n\tint n = 0;\n\tdouble s = 0, t = 0;\n\n\tcin >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\t\tn = 0;\n\t\t\n\t\tif (p3x == p0x && p3y == p0y)\n\t\t\ts = 0;\n\t\telse\n\t\t\ts = (double)((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) \n\t\t\t\t/ (double)((p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y));\n\n\t\tif (p2x == p0x && p2y == p0y)\n\t\t\tt = 0;\n\t\telse\n\t\t\tt = (double)((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) \n\t\t\t\t/ (double)((p2y - p0y) * (p3x - p0x) - (p2x - p0x) * (p3y - p0y));\n\n\t\tif (s >= 0 && t >= 0) {\n\t\t\tif (s + t >= 1)\n\t\t\t\tn = 1;\n\t\t}\t\t\t\n\n\t\tcout << n << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing namespace std;\nusing ll = long long;\nconst ll MOD = (ll)1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nconst double EPS = 1e-5;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\n#ifdef DEBUG\n#define OUTPUT(x) (output(x), outendl())\n#else\n#define OUTPUT(x) (void)0\n#endif\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\n//below here\n\n\nclass Vector2{\npublic:\n  double x;\n  double y;\n  Vector2():x(0), y(0){}\n  Vector2(double a, double b):x(a), y(b){}\n  Vector2(const Vector2 &o):x(o.x), y(o.y){}\n\n  Vector2& operator+=(Vector2 o){x+=o.x;y+=o.y;return *this;}\n  Vector2& operator-=(Vector2 o){x-=o.x;y-=o.y;return *this; }\n  Vector2& operator*=(double o){x*=o;y*=o;return *this;}\n  Vector2& operator/=(double o){x/=o;y/=o;return *this;}\n\n  Vector2 operator+(Vector2 o){return Vector2(*this)+=o;}\n  Vector2 operator-(Vector2 o){return Vector2(*this)-=o;}\n  Vector2 operator-(){return Vector2(-x,-y);}\n  Vector2 operator*(double o){return Vector2(*this)*=o;}\n  Vector2 operator/(double o){return Vector2(*this)/=o;}\n\n  double abs(){\n    return sqrt(mag());\n  }\n\n  double mag(){\n    return x*x+y*y;\n  }\n\n  Vector2 normal(){\n    return (*this) / abs();\n  }\n\n  Vector2 rotate_90(){\n    return Vector2(-y,x);\n  }\n\n  static double dot(Vector2 a,Vector2 b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  static double cross(Vector2 a,Vector2 b){\n    return a.x * b.y - a.y * b.x;\n  }\n};\n\n\ndouble dot(Vector2 x, Vector2 y){\n  return Vector2::dot(x,y);\n}\n\ndouble cross(Vector2 x, Vector2 y){\n  return Vector2::cross(x,y);\n}\n\nvoid output(Vector2 x){\n  cout << x.x << \" \" << x.y << endl;\n}\n\n\nclass straight_line{\npublic:\n  Vector2 f;\n  Vector2 s;\n  straight_line(){\n    f = Vector2(0,0);\n    s = Vector2(1,0);\n  }\n  straight_line(Vector2 a,Vector2 b):f(a),s(b){}\n\n  Vector2 projection(Vector2 pos){\n    pos -= f;\n    Vector2 n = (s-f).normal();\n    Vector2 res;\n    res = n * dot(pos,n) + f;\n    return res;\n  }\n\n  Vector2 reflection(Vector2 pos){\n    Vector2 n;\n    Vector2 res;\n    pos -= f;\n    double x = f.y-s.y;\n    double y = s.x-f.x;\n    n = Vector2(x,y).normal();\n    res = pos + f - n * dot(pos,n) * 2;\n    return res;\n  }\n\n  static bool is_cross(straight_line a,straight_line b){\n    Vector2 ap = a.s - a.f;\n    Vector2 bp = b.s - b.f;\n    if(abs(Vector2::dot(ap,bp))<EPS){\n      return true;\n    }\n    return false;\n  }\n\n  static bool is_cross_segment(straight_line a,straight_line b){\n\t  if(Vector2::cross(b.f-a.f,a.s-a.f)<0!=Vector2::cross(a.s-a.f,b.s-a.f)<0)return false;\n\t  if(Vector2::cross(b.f-a.s,a.f-a.s)<0!=Vector2::cross(a.s-a.f,b.s-a.f)<0)return false;\nreturn true;\n  }\n\n  static bool is_parallel(straight_line a,straight_line b){\n    Vector2 ap = a.s - a.f;\n    Vector2 bp = b.s - b.f;\n    if(abs(Vector2::cross(ap,bp))<EPS){\n      return true;\n    }\n    return false;\n  }\n\n  static Vector2 cul_cross(straight_line a,straight_line b){\n    if(a.is_online(b.f)){\n      return b.f;\n    }\n    if(a.is_online(b.s)){\n      return b.s;\n    }\n    if(b.is_online(a.f)){\n      return a.f;\n    }\n    if(b.is_online(a.s)){\n      return a.s;\n    }\n    Vector2 an = (a.s-a.f).rotate_90();\n    if(Vector2::dot(b.f-a.f,an)<0){\n      an = -an;\n    }\n    double dis_1 = Vector2::dot(b.f-a.f,an);\n    double dis_2 = Vector2::dot(b.s-a.f,an);\n    return b.f + (b.s - b.f) * dis_1 / (dis_1 - dis_2);\n  }\n\n  bool is_online(Vector2 pos){\n    Vector2 v = s-f;\n    Vector2 n = v.normal();\n    double k = v.abs();\n    pos-=f;\n    double dis = Vector2::dot(pos,n);\n    if(dis>0){\n      if(dis>k)dis=k;\n      pos -= n * dis;\n    }\n    return pos.abs() < EPS;\n  }\n};\n\nVector2 input_vector2(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn Vector2(x,y);\n}\n\nint func(){\n\tstraight_line a,b;\n\ta.f = input_vector2();\n\ta.s = input_vector2();\n\tb.f = input_vector2();\n\tb.s = input_vector2();\n  Vector2 cross_point = straight_line::cul_cross(a,b);\n  return a.is_online(cross_point) && b.is_online(cross_point);\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\trep(i,q){\n\t\tcout << func() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Fi first\n#define Se second\n#define pb push_back\n#define mp make_pair\n#define rep(x, a, b) for(int x = (a); x <= (b); ++ x)\n#define per(x, a, b) for(int x = (a); x >= (b); -- x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++ x)\n#define por(x, a, b) for(int x = (a); x > (b); -- x) \n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int unt;\ntypedef double db;\ntypedef pair <int, int> pii;\ntypedef vector <int> vi;\n\nconst db eps  = 1e-8;\nconst db _PI  = 3.1415926535897932384;\nconst db _E   = 2.7182818284590452354;\nconst int inf = 0x3f3f3f3f;\nconst LL INF  = 0x3f3f3f3f3f3f3f3fll;\n\nint dcmp(db x) {\n\tif(x > eps) return 1;\n\tif(x < -eps) return -1;\n\treturn 0;\n}\n\nint dcmp(db x, db y) {\n\treturn dcmp(x - y);\n}\n\nstruct Point {\n\tdb x, y;\n\tPoint(db _x = 0, db _y = 0) : x(_x), y(_y) {}\n\tvoid print() { printf(\"%.10f %.10f\", x, y); }\n};\nstruct Line {\n\tPoint p1, p2;\n\tLine() {};\n\tLine(Point _p1, Point _p2) : p1(_p1), p2(_p2) {};\n};\n\ntypedef Point Vector;\ntypedef Line Segment;\n\n// CCW\nconst int CCW_COUNTER_CLOCKWISE = 1;\nconst int CCW_CLOCKWISE = -1;\nconst int CCW_ONLINE_FRONT = -2;\nconst int CCW_ONLINE_BACK = 2;\nconst int CCW_ON_SEGMENT = 0;\n\nVector operator + (Vector a, Vector b) {\n\treturn Vector(a.x + b.x, a.y + b.y);\n}\nVector operator - (Vector a, Vector b) {\n\treturn Vector(a.x - b.x, a.y - b.y);\n}\nVector operator * (Vector a, db b) {\n\treturn Vector(a.x * b, a.y * b);\n}\nVector operator / (Vector a, db b) {\n\treturn Vector(a.x / b, a.y / b);\n}\ndb operator * (Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndb operator ^ (Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\ndb dis(Point a, Point b) {\n\treturn sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\ndb dis2(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\ndb dis(Vector a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\ndb dis2(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\nPoint Project(Line L, Point p) {\n\tVector Base = L.p2 - L.p1;\n\tdb len = Base * (p - L.p1);\n\treturn L.p1 + Base * (len / dis2(L.p1, L.p2));\n}\nPoint Reflect(Line L, Point p) {\n\treturn p + (Project(L, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector p01 = p1 - p0, p02 = p2 - p0;\n\tif(dcmp(p01 ^ p02) == 1) return CCW_COUNTER_CLOCKWISE; // 顺时针 \n\tif(dcmp(p01 ^ p02) == -1) return CCW_CLOCKWISE;        // 逆时针 \n\tif(dcmp(p01 * p02) == -1) return CCW_ONLINE_BACK;\n\tif(dcmp(dis2(p01), dis2(p02)) == -1) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn dcmp(a * b) == 0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a2 - a1, b2 - b1);\n}\nbool isOrthogonal(Line a, Line b) {\n\treturn isOrthogonal(a.p2 - a.p1, b.p2 - b.p1);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn dcmp(a ^ b) == 0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a2 - a1, b2 - b1);\n}\nbool isParallel(Line a, Line b) {\n\treturn isParallel(a.p2 - a.p1, b.p2 - b.p1);\n}\nbool IntersectSS(Point a1, Point a2, Point b1, Point b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\nbool IntersectSS(Segment a, Segment b) {\n\treturn IntersectSS(a.p1, a.p2, b.p1, b.p2);\n}\n\nint main() {\n\tint q; scanf(\"%d\", &q);\n\trep(i, 1, q) {\n\t\tSegment a, b;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &a.p1.x, &a.p1.y, &a.p2.x, &a.p2.y, &b.p1.x, &b.p1.y, &b.p2.x, &b.p2.y);\n\t\tif(IntersectSS(a, b)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define _GLIBCXX_DEBUG\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...on_seg(p1,p2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n\tint q;\n\tcin>>q;\n\tfor(int cnt=0;cnt<q;cnt++)\n\t{\n\t\tpoint a[2];\n\t\tpoint b[2];\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\tpoint a[i]=point(a,b);\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\tpoint b[i]=point(a,b);\n\t\t}\n\t\tif(on_seg(a[0],a[1],intersection(a[0],a[1],b[0],b[1])))\n\t\t\tcout<<1<<endl;\n\t\telse\n\t\t\tcout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ONLINE_JUDGE\n#define getchar gc\ninline char gc(){\n\tstatic char buf[1<<16],*p1=buf,*p2=buf;\n\tif(p1==p2){\n\t\tp2=(p1=buf)+fread(buf,1,1<<16,stdin);\n\t\tif(p2==p1) return EOF;\n\t}\n\treturn *p1++;\n}\n#endif\ntemplate<class t> inline t read(t &x){\n    char c=getchar();bool f=0;x=0;\n    while(!isdigit(c)) f|=c=='-',c=getchar();\n    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    if(f) x=-x;return x;\n}\ntemplate<class t> inline void write(t x){\n    if(x<0) putchar('-'),write(-x);\n    else{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst double eps=1e-9;\nconst double pi=acos(-1);\n\n\nstruct point{\n\tdouble x,y;\n\tinline void read(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tinline point operator + (const point &nt) const {\n\t\treturn (point){x+nt.x,y+nt.y};\n\t}\n\tinline point operator - (const point &nt) const {\n\t\treturn (point){x-nt.x,y-nt.y};\n\t}\n\tinline point operator * (const double &nt) const {\n\t\treturn (point){x*nt,y*nt};\n\t}\n\tinline double length(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n};\n\ndouble distance(point x,point y){ //距离 \n\treturn sqrt((y.x-x.x)*(y.x-x.x)+(y.y-x.y)*(y.y-x.y));\n}\n\nstruct segment{\n\tpoint x,y;\n\tinline void read(){\n\t\tx.read();y.read();\n\t}\n\tinline double length(){ //线段长度 \n\t\treturn distance(x,y);\n\t}\n}x,y;\n\nstruct line{\n\tpoint x,y;\n\tinline void read(){\n\t\tx.read();y.read();\n\t}\n};\n\ndouble DJ(point x,point y){ //点积 \n\treturn x.x*y.x+x.y*y.y;\n}\n\ndouble CJ(point x,point y){ //叉积 \n\treturn x.x*y.y-x.y*y.x;\n}\n\n\npoint trpoint(segment x){ //将有向线段转成向量点 \n\treturn x.y-x.x;\n}\n\npoint trpoint(line x){ //将直线转成向量点 \n\treturn x.y-x.x;\n}\n\ndouble prolen(point x,segment a){ //点在有向线段上的投影长度 \n\treturn DJ(trpoint((segment){a.x,x}),trpoint(a))/a.length();\n}\n\npoint propoint(point x,segment a){ //点在直线上的投影点 \n\treturn a.x+trpoint(a)*(prolen(x,a)/a.length());\n}\n\npoint refpoint(point x,segment a){ //点在直线上的投影点 \n\treturn x+(propoint(x,a)-x)*2;\n}\n\nbool orthline(line x,line y){ //两条直线是否垂直 \n\treturn DJ(trpoint(x),trpoint(y))==0;\n}\n\nbool paraline(line x,line y){ //两条直线是否平行 \n\treturn CJ(trpoint(x),trpoint(y))==0;\n}\n\nbool interseg(segment x,segment y){ //两条线段是否相交 \n\treturn min(x.x.x,x.y.x)<=max(y.x.x,y.y.x)&&min(y.x.x,y.y.x)<=max(x.x.x,x.y.x)&&min(x.x.y,x.y.y)<=max(y.x.y,y.y.y)&&min(y.x.y,y.y.y)<=max(x.x.y,x.y.y)&&CJ(y.x-x.x,y.y-x.x)*CJ(y.x-x.y,y.y-x.y)<=0&&CJ(x.x-y.x,x.y-y.x)*CJ(x.x-y.y,x.y-y.y)<=0;\n}\n\nvoid doit(){\n\tx.read();y.read();\n\twrite(interseg(x,y));puts(\"\");\n}\n\nsigned main(){\n\tint t;\n\tread(t);\n\twhile(t--) doit();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble dot(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vx) + (v1.vy * v2.vy);\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n\treturn (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble onenorm(const Vector &v)\n{\n\treturn abs(v.vx) + abs(v.vy);\n}\n\nint ccw(const Point &P0, const Point &P1, const Point &P2)\n{\n\tVector V1 = set_v(P0, P1);\n\tVector V2 = set_v(P0, P2);\n\tdouble c = cross(V1, V2);\n\tif(c > 0){ return 1; }else if(c < 0){ return -1; }\n\tif(dot(V1, V2) < 0){ return -2; }\n\tif(onenorm(V1) < onenorm(V2)){ return 2; }\n\treturn 0;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n        if(ccw(P0, P1, P2) * ccw(P0, P1, P3) <= 0 && ccw(P2, P3, P0) * ccw(P2, P3, P1) <= 0){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long double ld;\n\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nstruct L { P a, b; };//二点の情報をもつ\n\n//内積 |a||b|cosθ θはaからbに反時計周りにとる\nld dot (P a, P b) { return real(conj(a) * b); }\n//外積 |a||b|sinθ θはaからbに反時計周りにとる\nld cross (P a, P b) { return imag(conj(a) * b); }\n\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;//原点中心に考えている\n  if (cross(b, c) > eps) return 1;   //0<θ<180 // counter clockwise\n  if (cross(b, c) < -eps) return -1; //180<θ<360 clockwise\n  //上のどちらでもないなら線上にある\n  if (dot(b, c) < 0) return 2;       //θ=180// c--a--b on line\n  //以下θ=0\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\n\nbool isis_ss(L s, L t) {\n //二つの線分が互いに,「片方の線分の方向ベクトルに対して,もう片方の線分の頂点が反対側にある」という関係であれば交点をもつ.\n //点が一致していてもよいので=0も含む\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint main() {\n  int q;\n  ld x0, y0, x1, y1, x2, y2, x3, y3;\n  cin >> q;\n  REP(i,q) {\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n    L seg1 = (L){P(x0, y0), P(x1, y1)}, seg2 = (L){P(x2, y2), P(x3, y3)};\n    if (isis_ss(seg1, seg2)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<min(x[3],x[4])||min(x[1],x[2])>max(x[3],x[4])||max(y[1],y[2])<min(y[3],y[4])||min(y[1],y[2])>max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<=0&&p3*p4<=0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#define EPS (1e-15)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\n\nstruct Segment;\nclass Point;\ntypedef Point Vector;\ntypedef Segment Line;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double xx, double yy) {\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tPoint operator + (Point& p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point& p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double k) { return Point(x * k, y * k); }\n\tPoint operator / (double k) { return Point(x / k, y / k); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tdouble dot(Point p) { return x * p.x + y * p.y; }\n\tdouble cross(Point& p) { return x * p.y - y * p.x; }\n\tdouble distance(Point& p) { return (*this - p).abs(); }\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n\tvoid input() {\n\t\tcin >> x >> y;\n\t}\n};\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tvoid input() {\n\t\tp1.input();\n\t\tp2.input();\n\t}\n};\n\ndouble distance(Point p, Line s) {\n\tVector a = s.p2 - s.p1;\n\tVector b = p - s.p1;\n\treturn a.cross(b) / a.abs();\n}\n\ndouble distanceS(Point p, Segment s) {\n\tVector p1p = p - s.p1;\n\tVector p2p = p - s.p2;\n\tVector p1p2 = s.p2 - s.p1;\n\tVector p2p1 = s.p1 - s.p2;\n\tif (p1p.dot(p1p2) < 0) {\n\t\treturn p1p.abs();\n\t}\n\telse if (p2p.dot(p2p1) < 0) {\n\t\treturn p2p.abs();\n\t}\n\telse {\n\t\treturn distance(p, s);\n\t}\n}\n\nPoint project(Point p, Segment s) {\n\tVector hepo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\tVector t = base * (hepo.dot(base) / base.norm());\n\treturn s.p1 + t;\n}\n\nint ccw(Point p0, Point p1, Point p) {\n\tVector p0p1 = p1 - p0;\n\tVector p0p;\n\tp0p = p - p0;\n\tif (p0p1.cross(p0p) > EPS) {\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\telse if (p0p1.cross(p0p) < -EPS) {\n\t\treturn CLOCKWISE;\n\t}\n\telse if (p0p1.dot(p0p) < -EPS) {\n\t\treturn ONLINE_BACK;\n\t}\n\telse if (p0p1.norm() < p0p.norm()) {\n\t\treturn ONLINE_FRONT;\n\t}\n\telse {\n\t\treturn ON_SEGMENT;\n\t}\n}\n\nbool intersection(Segment s1,Segment s2) {\n\tPoint p0 = s1.p1;\n\tPoint p1 = s1.p2;\n\tPoint p2 = s2.p1;\n\tPoint p3 = s2.p2;\n\treturn ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 &&\n\t\tccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\n\n\nint main() {\n\tSegment s1,s2;\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\ts1.input();\n\t\ts2.input();\n\t\tif (intersection(s1,s2)) {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>0) return 1;\n\t\tif(Getmp<0) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tif(three_PJUD(Gex,Getmp)&&three_PJUD(Gey,Getmp)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tbool three_PJUD(pair<point,point> Gea,point Gex){\n\t\tpdd Ger(EXTLEN(Gea.first,Gex),EXTLEN(Gea.second,Gex));\n\t\tif(Gex==DIP(Gea,Ger)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\nconst double EPS=1e-9;\nconst double PI=3.141592653589793238;//18 ragham\n\nbool Equal(double d1,double d2)\n{ return fabs(d1-d2)<EPS;}\n\nstruct line{double a,b,c;};\nstruct vec\n{\n  double x,y;\n  vec(double _x=0,double _y=0)\n  {x=_x;  y=_y;}\n};\n  \nstruct point_i\n{\n  int x,y;\n  point_i(int _x=0,int _y=0){x=_x;y=_y;}\n};\nstruct point\n{\n  double x,y;\n  point(double _x=0,double _y=0){x=_x;y=_y;}\n  bool operator < (point other)\n  {  \n    if(fabs(x-other.x)<EPS)\n      return y<other.y;\n    return x<other.x;}\n  bool operator == (point other)\n  {return (fabs(x-other.x)<EPS) && (fabs(y-other.y)<EPS) ;}\n  \n  \n};\ndouble Hypot(double dx,double dy)\n{\n  return sqrt(dx*dx+dy*dy);\n}\ndouble Distance(point p1,point p2)\n{\n  return hypot(p1.x-p2.x,p1.y-p2.y);\n}\ndouble DEG_to_RAD(double theta)\n{\n  return theta*PI/180;\n}\ndouble RAD_to_DEG(double rad)\n{\n  return rad*180/PI;\n}\npoint rotate(point p, double theta)//theta is degree\n{\n  \n  //rotation matrixR(theta) = [cos(theta) - sin(theta)]\n  //                          [sin(theta) + cos(theta)]\n  //usage: [x'] = R(theta)* [x]\n  //       [y']             [y]\n  double rad=DEG_to_RAD(theta);\n  return point(p.x * cos(rad) - p.x * sin(rad) ,\n\t       p.y * sin(rad) + p.y * cos(rad)  );\n}\nvoid PointsToLine(point p1,point p2,line *l)\n{\n  if(p1.x==p2.x) // vertical line handled here\n    { l->a=1.0;   l->b= 0.0 ; l->c=-p1.x;}\n  else\n    {\n      l->a=-(double)(p1.y-p2.y)/(p1.x-p2.x);\n      l->b=1.0;\n      l->c=-(double)(l->a * p1.x) - (l->b*p1.y);\n    }\n}\nbool AreParallel(line l1,line l2)\n{\n  return Equal(l1.a,l2.a) && Equal(l1.b,l2.b);\n}\nbool AreSame(line l1,line l2)\n{\n  return AreParallel(l1,l2) && Equal(l1.c,l2.c);\n}\nbool AreIntersect(line l1,line l2,point *p)//TO BE CHECKED (mine)\n{\n  if(AreSame(l1,l2))\n    return false;\n  if(AreParallel(l1,l2))\n    return false;\n\n  //solving\n  double delta=(double)l1.a*l2.b - l1.b*l2.a;\n  if(Equal(delta,0))//this if should never be true because lines are't parallel\n    return false;\n  //a1x+b1y=-c1\n  //a2x+b2y=-c2\n  p->x= (double)(-l1.c*l2.b+l2.c*l1.b) / delta;\n  p->y= (double)(-l1.a*l2.c+l2.a*l1.c) / delta;\n  return true;\n}\nvec ToVector(point p1,point p2)\n{\n  return vec(p2.x-p1.x,p2.y-p1.y);\n}\nvec ScaleVector(vec v, double s) // v*=s\n{\n  return vec(v.x*s,v.y*s);\n}\npoint Translate(point p,vec move)//moves point p in direction of vector move\n{\n  return point(p.x+move.x , p.y + move.y);\n}\ndouble Dot(double x1,double y1 ,double x2,double y2)\n{ return x1*x2+y1*y2;};\ndouble Determinant(double x1,double y1,double x2,double y2)\n{return x1*y2-x2*y1;};\n//angle A<BC (radian (PI) )\ndouble Angle(point A,point B,point C)\n{\n  int dot=Dot(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  int det=Determinant(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  //atan2(y,x), or atan2(sin,cos)\n  return atan2(det,dot);\n}\ndouble Cross(point p,point q,point r)\n{\n  return (r.x-q.x)*(p.y-q.y)-(r.y-q.y)*(p.x-q.x);\n}\nbool Collinear(point p,point q,point r)\n{\n  return Equal(Cross(p,q,r),0);\n}\n//returns true if point r is on the left side of line pq\nbool CCW(point p,point q,point r)\n{\n   //can be modified to accept collinear ( >0 instead of >EPS )\n  if(Cross(p,q,r) > EPS)\n    return true;\n  return false;\n}\n\n//returns the distance from p to line AB\n// A and B must be different\n//closest point is in *c\ndouble DistToLine(point p,point A,point B,point *c)\n{// formula : c= A+ (p-A).(A-B)/|B-A|*(B-A)\n  double scale= (double)\n    ((p.x-A.x)*(B.x-A.x)+(p.y-A.y)*(B.y-A.y))/\n    ((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));\n  c->x= A.x + scale*(B.x - A.x);\n  c->y= A.y + scale*(B.y - A.y);\n  \n  return Distance(p,*c);\n}\ndouble DistToLineSegment(point p,point A,point B,point *c)\n{\n  if((B.x-A.x) * (p.x-A.x)+ (B.y-A.y)*(p.y-A.y) <EPS)\n    { c->x=A.x ; c->y= A.y;\n      return Distance(p,A);}//closer to A\n \n  if((A.x-B.x) * (p.x-B.x)+ (A.y-B.y)*(p.y-B.y) <EPS)\n    { c->x=B.x ; c->y= B.y;\n      return Distance(p,B);}//closer to B\n\n  return DistToLine(p,A,B,c);\n  \n}\n//returns true if p is on segment AB\nbool IsOnLineSegment(point p,point A,point B)\n{\n  if(Collinear(p,A,B)==false)\n    return false;\n  if(p==A || p==B)\n    return true;\n  double angle=Angle(A,p,B);\n  if(Equal( angle, PI ) || Equal(RAD_to_DEG(angle),180) )\n    return true;\n  return false;\n}\nbool AreSegmentsIntersect(point A,point B,point C,point D,point *p)\n{\n  line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2))\n    {\n      //cout<<\"A\"<<endl;\n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))\n\tcnt++;\n      if(IsOnLineSegment(B,C,D))\n\tcnt++;\n      if(IsOnLineSegment(C,A,B))\n\tcnt++;\n      if(IsOnLineSegment(D,A,B))\n\tcnt++;\n      if(cnt!=2)\n\treturn false;\n      if(A==C || A==D){\n\tp->x=A.x;\n\tp->y=A.y;\n\treturn true;}\n      if(B==C || B==D){\n\tp->x=B.x;\n\tp->y=B.y;\n\treturn true;}\n      return false;\n    }\n \n  if(AreIntersect(l1,l2,p))\n    {\n      //    cout<<\"B\"<<endl;\n      //   cout<<p->x<<\" \"<<p->y<<endl;\n      if(IsOnLineSegment(*p,A,B) && IsOnLineSegment(*p,C,D))\n\treturn true;\n      return false;\n    }\n  //  cout<<\"C\"<<endl;\n  return false;\n    \n}\n///*****************### End of Library ###*******************///\n\n\n\n\n\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    {\n      int x,y;\n      point A,B,C,D,p;\n      cin>>x>>y;\n      A=point(x,y);\n      \n      cin>>x>>y;\n      B=point(x,y);\n      \n      cin>>x>>y;\n      C=point(x,y);\n      \n      cin>>x>>y;\n      D=point(x,y);\n      if(AreSegmentsIntersect(A,B,C,D,&p))\n\tcout<<1<<endl;\n      else\n\tcout<<0<<endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n\n        public Segment() {\n            this(new Point(), new Point());\n        }\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static bool cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS \n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS \n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define dTolerance 1.0e-10\n\n    //(x,y)が(x0,y0),(x1,y1)を通る直線のどちら側にあるか  1:左 -1:右 0:直線上\nint LF_COUNTER_CLOCKWIZE(const double &x, const double &y, const double &x0, const double &y0, const double &x1, const double &y1){\n    if((x1 - x0) * (y - y0) - (x - x0) * (y1 - y0) > dTolerance){\n        return 1;\n    } else if((x1 - x0) * (y - y0) - (x - x0) * (y1 - y0) < -dTolerance){\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++){\n        double x0,x1,x2,x3,y0,y1,y2,y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        if(LF_COUNTER_CLOCKWIZE(x0, y0, x2, y2, x3, y3) == 0 && LF_COUNTER_CLOCKWIZE(x1, y1, x2, y2, x3, y3) == 0 ){    //2線分が延長して一致する場合だけ面倒\n            if(fabs(x0 - x1) < dTolerance){    //y軸平行  y座標比較\n                if(max(y0, y1) < min(y2, y3) || max(y2, y3) < min(y0, y1)){    //交わらない\n                    printf(\"0\\n\");\n                } else {    //交わる\n                    printf(\"1\\n\");\n                }\n            } else {    //x座標比較\n                if(max(x0, x1) < min(x2, x3) || max(x2, x3) < min(x0, x1)){    //交わらない\n                    printf(\"0\\n\");\n                } else {    //交わる\n                    printf(\"1\\n\");\n                }\n            }\n        } else {\n            bool bIntersect = true;\n            if(LF_COUNTER_CLOCKWIZE(x0, y0, x2, y2, x3, y3) * LF_COUNTER_CLOCKWIZE(x1, y1, x2, y2, x3, y3) == 1 ) {    //同じ側にあったら交わらない\n                bIntersect = false;\n            }\n            if(LF_COUNTER_CLOCKWIZE(x2, y2, x0, y0, x1, y1) * LF_COUNTER_CLOCKWIZE(x3, y3, x0, y0, x1, y1) == 1 ) {    //同じ側にあったら交わらない\n                bIntersect = false;\n            }\n            if(bIntersect == true){\n                printf(\"1\\n\");                \n            } else {\n                printf(\"0\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <complex>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define loop(i, x, n) for (int i = (x); i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define int long long\n#define INF 1e9\n#define MOD 1e9 + 7\nusing namespace std;\n\ntemplate<typename T> void cmin(T &a, T b) { a = min(a, b); }\ntemplate<typename T> void cmax(T &a, T b) { a = max(a, b); }\n\nusing P = complex<double>;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n// P p(a,b)=a+bi -> 点p(a,b)\nnamespace std {\n  bool operator<(const P &a, const P &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); }\n  bool operator==(const P &a, const P &b) { return a.real() == b.real() && a.imag() == b.imag(); }\n} // namespace std\n// i倍すれば反時計回りに90度回転\nP turn(P p, double t) { // t度回転\n  return p * exp(P(.0, t * PI / 180.0)); //ベクトルにe^θiをかける\n}\n\n//内積\ndouble dot(P a, P b) { return real(conj(a) * b); }\n//外戚\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\n//////////////////////////////////////\n// 直線(Line) 線分(Segment)          //\n// L l(a,b);で直線ab                 //\n// l[0]=a l[1]=b                    //\n// e.g. L line(P(x1,y1),P(x2,y2));  //\n//////////////////////////////////////\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a);\n    push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return +1; // counter clockwise\n  if (cross(b, c) < 0) return -1; // clockwise\n  if (dot(b, c) < 0) return +2; // c--a--b on line\n  if (norm(b) < norm(c)) return -2; // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) { return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0; }\n\nsigned main() {\n\n  int q;\n  cin >> q;\n  while (q--) {\n    int a, b, c, d, e, f, g, h;\n    cin >> a >> b >> c >> d >> e >> f >> g >> h;\n    L l(P(a, b), P(c, d));\n    L m(P(e, f), P(g, h));\n    cout << intersectSS(l, m) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\nusing R = double;\nusing P = complex<R>;\n#define x real()\n#define y imag()\nconst R eps = 1e-9,PI = acos(-1);\n\nbool equal(R a,R b){return abs(b-a)<eps;}\nbool equal0(R a){return equal(a,0.0);}\n\nP operator*(const P& p,const R& d){\n    return P(p.x*d,p.y*d);\n}\n\nistream &operator>>(istream& is,P& p){\n    R a,b;\n    is >> a >> b;\n    p = P(a,b);\n    return is;\n}\n\nostream &operator<<(ostream& os,P& p){\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n//内積\ndouble dot(P a,P b) {return (conj(a)*b).real();}\n//外積\ndouble cross(P a,P b) {return (conj(a)*b).imag();}\n\nstruct L{\n    P a,b;\n    L(P a,P b):a(a),b(b){}\n    L(R A,R B,R C){\n        if(equal(A,0)) a = P(0,C/B),b = P(1,C/B);\n        else if(equal(B,0)) b = P(C/A,0),b = P(C/A,1);\n        else a = P(0,C/B),b = P(C/A,0);\n    }\n};\n\n//pをbに射影\nP projection(P p,P b) {return b*dot(p,b)/norm(b);}\n\n//pとp1 to p2 に射影\nP projection(L l,P p){\n    p -= l.a; l.b -= l.a;\n    P proj = projection(p,l.b);\n    return l.a+proj;\n}\n\nstruct S:L{\n    S(P a,P b):L(a,b){}\n};\n\n//点の回転方向を判定\nint ccw(P& p0,P p1,P p2){\n    p1 -= p0,p2 -= p0;\n    if(cross(p1,p2)>eps) return 1; //\"COUNTER_CLOCKWISE\"\n    if(cross(p1,p2)<-eps) return -1; //\"CLOCKWISE\"\n    if(dot(p1,p2)<0) return 2; //\"ONLINE_BACK\"\n    if(norm(p1)<norm(p2)) return -2; //\"ONLINE_FRONT\"\n    return 0; //\"ON_SEGMENT\"\n}\n\nbool is_parallel(L l1,L l2){\n    return equal0(cross(l1.b-l1.a,l2.b-l2.a));\n}\n\nbool is_orthogonal(L l1,L l2){\n    return equal0(dot(l1.b-l1.a,l2.b-l2.a));\n}\n\n//pをlに関して対称移動\nP reflection(L l,P p){\n    P pj = projection(l,p);\n    return 2.0*pj-p;\n}\n\n//pがl上にあるか\nbool is_online(L& l,P& p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\n\nbool is_onsegment(S& s,P& p){\n    return ccw(s.a,s.b,p)==0;\n}\n\n//線分の交差判定\nbool intersect(S s,S t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0 && ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\n\nint main(){\n    int Q;\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        P p1,p2,p3,p4;\n        cin >> p1 >> p2 >> p3 >> p4;\n        cout << intersect(S(p1,p2),S(p3,p4)) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\nstruct dot{\n\tdouble x,y;\n\tdouble len(){return sqrt(x*x+y*y);}\n\tdot(double a=0.0,double b=0.0){x=a,y=b;}\n\tdot operator +(const dot&b)const {return dot(x+b.x,y+b.y);}\n\tdot operator -(const dot&b)const {return dot(x-b.x,y-b.y);}\n\tdot operator *(const double&z)const {return dot(x*z,y*z);}\n\tbool operator <(const dot&b)const {return (x<b.x)||(x==b.x&&y<b.y);}\n\tvoid read(){scanf(\"%lf%lf\",&x,&y);} \n};\nstruct line{\n\tdot x1,x2;\n\tvoid read(){x1.read();x2.read();};\n\tdot getdot(){return x2-x1;}\n};\ndouble chaji(dot x,dot y){\n\treturn x.x*y.y-x.y*y.x;\n}\ndouble neiji(dot x,dot y){\n\treturn x.x*y.x+x.y*y.y;\n}\ndouble cos(dot x,dot y){\n\tif (!x.len()||!y.len())return 0;\n\treturn neiji(x,y)/x.len()/y.len();\n}\ndot Projection(dot x,line y){//求x关于直线y的投影点（垂足） \n\ty.x2=y.x2-y.x1;\n\tx=x-y.x1;\n\tdouble len=cos(x,y.x2)*x.len()/y.x2.len();\n\ty.x2=y.x2*len;\n\treturn y.x2+y.x1;\n}\ndot Reflection(dot x,line y){//求x关于直线y的对称点 \n\tdot z=Projection(x,y);\n\treturn z*2-x;\n}\nint Counter_Clockwise(dot x,line y){//求两个向量的五种关系 \n\tx=x-y.x1;y.x2=y.x2-y.x1;\n\tif (chaji(y.x2,x)!=0){\n\t\tif (chaji(y.x2,x)>0)return 1;\n\t\treturn 2;\n\t} \n\tif (fabs(cos(x,y.x2)+1)<eps)return 3;\n\tif (x.len()>y.x2.len())return 4;\n\treturn 5;\n} \nint Parallel_Orthogonal(line x,line y){//求两个直线是垂直还是平行还是其他 \n\tdot a=x.getdot(),b=y.getdot();\n\tif (chaji(a,b)==0)return 2;\n\tif (neiji(a,b)==0)return 1;\n\treturn 0;\n}\nint Intersection(line x,line y){//求两条直线是否相交 \n\tint Minx1=min(x.x1.x,x.x2.x),Maxx1=max(x.x1.x,x.x2.x);\n\tint Minx2=min(y.x1.x,y.x2.x),Maxx2=max(y.x1.x,y.x2.x);\n\tint Miny1=min(x.x1.y,x.x2.y),Maxy1=max(x.x1.y,x.x2.y);\n\tint Miny2=min(y.x1.y,y.x2.y),Maxy2=max(y.x1.y,y.x2.y);\n\tif (Minx1>Maxx2||Minx2>Maxx1)return 0;\n\tif (Miny1>Maxy2||Miny2>Maxy1)return 0;\n\tif (chaji(x.getdot(),y.x1-x.x1)*chaji(x.getdot(),y.x2-x.x1)>0)return 0;\n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T--){\n\t\tline x,y;\n\t\tx.read();y.read();\n\t\tprintf(\"%d\\n\",Intersection(x,y));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\n#define pb push_back\n#define eb emplace_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\ntemplate <class T>\nusing V = vector<T>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\ntemplate <class T>\nvoid chmin(T &a, T b) { a = min(a, b); }\ntemplate <class T>\nvoid chmax(T &a, T b) { a = max(a, b); }\nvoid ok() { cerr << \"ok\" << endl; }\nusing D = double;\nusing Point = complex<D>;\nconst D eps = 1e-40;\ninline int sgn(const D &a) { return (a < -eps) ? -1 : (a > eps) ? 1 : 0; }\ninline D cross(const Point &a, const Point &b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\ninline D dot(const Point &a, const Point &b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\nistream &operator>>(istream &is, Point &p) {\n    D a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\ninline int ccw(const Point &a, const Point &b, const Point &c) {\n    D d = cross(b - a, c - a);\n    if (sgn(d) > 0) {\n        return +1; //counter-clockwise\n    } else if (sgn(d) < 0) {\n        return -1; //clockwise\n    } else {\n        if (sgn(dot(b - a, c - a)) < 0) {\n            return -2; //c,a,b\n        } else if (sgn(dot(a - b, c - b)) < 0) {\n            return +2; //a,b,c\n        }\n    }\n    return 0; //a,c,b\n}\nstruct Line {\n    Point a, b; //a,bを通る直線\n    Line(const Point &p0, const Point &p1) : a(p0), b(p1) {}\n};\nstruct Segment {\n    Point a, b;\n    Segment(const Point &p0, const Point &p1) : a(p0), b(p1) {}\n};\ninline Point projection(const Line &l, const Point &b) { //a to b\n    return l.a + (dot(l.b - l.a, b - l.a) / norm(l.b - l.a)) * l.b;\n}\ninline Point reflection(const Line &l, const Point &b) {\n    return b + (projection(l, b) - b) * static_cast<D>(2.0);\n}\ninline bool parallel(const Line &l1, const Line &l2) {\n    return sgn(cross(l1.b - l1.a, l2.b - l2.a)) == 0;\n}\ninline bool vertical(const Line &l1, const Line &l2) {\n    return sgn(dot(l1.b - l1.a, l2.b - l2.a)) == 0;\n}\ninline bool intersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 && ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int q;\n    cin >> q;\n    while (q--) {\n        Point p0, p1, p2, p3;\n        cin >> p0 >> p1 >> p2 >> p3;\n        Segment l1(p0, p1), l2(p2, p3);\n        if (intersect(l1, l2)) {\n            cout << 1 << '\\n';\n        } else {\n            cout << 0 << '\\n';\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nclass Point{\npublic:\n\tPoint(const int argx = 0, const int argy = 0):x(argx),y(argy){};\n\tint x, y;\n};\nclass Line{\npublic:\n\tLine(const int x1, const int y1, const int x2, const int y2):p1(x1, y1),p2(x2, y2),X(x1 - x2),Y(y1 - y2){\n\t\tif (x1 > x2){\n\t\t\tmaxx = (x1);\n\t\t\tminx = (x2);\n\t\t}else{\n\t\t\tmaxx = (x2);\n\t\t\tminx = (x1);\n\t\t}\n\t\tif (y1 > y2){\n\t\t\tmaxy = (y1);\n\t\t\tminy = (y2);\n\t\t}else{\n\t\t\tmaxy = (y2);\n\t\t\tminy = (y1);\n\t\t}\n\t};\n\tbool is_parallel(const Line &other) const {\n\t\treturn (X * other.Y) == (Y * other.X);\n\t}\n\tbool is_over_x(const Line &other) const {\n\t\treturn (X * X + other.X * other.X >= (maxx - other.maxx) * (maxx - other.maxx) + (minx - other.minx) * (minx - other.minx));\n\t}\n\tbool is_over_y(const Line &other) const {\n\t\treturn (Y * Y + other.Y * other.Y >= (maxy - other.maxy) * (maxy - other.maxy) + (miny - other.miny) * (miny - other.miny));\n\t}\n\tint get_Xy(const int &other_x) const {return (Y * other_x + (X * p2.y - Y * p2.x));}\n\tint get_Yx(const int &other_y) const {return (X * other_y + (Y * p2.x - X * p2.y));}\n\tbool is_cross_x(const Line &other) const {\n\t\treturn (other.X * p1.y - other.get_Xy(p1.x)) * (other.X * p2.y - other.get_Xy(p2.x)) <= 0;\n\t}\n\tbool is_cross_y(const Line &other) const {\n\t\treturn (other.Y * p1.x - other.get_Yx(p1.y)) * (other.Y * p2.x - other.get_Yx(p2.y)) <= 0;\n\t}\n\tbool is_intersection(const Line &other) const {\n\t\tif (is_parallel(other)){\n\t\t\tif (X * Y == 0){\n\t\t\t\tif (X == 0){\n\t\t\t\t\treturn (p1.x == other.p1.x and is_over_y(other));\n\t\t\t\t}else{\n\t\t\t\t\treturn (p1.y == other.p1.y and is_over_x(other));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn (is_cross_x(other) and is_over_x(other));\n\t\t\t}\n\n\t\t}else{\n\t\t\tif (Y == 0 or other.Y == 0){\n\t\t\t\treturn (is_cross_x(other) and other.is_cross_x((*this)));\n\t\t\t}else{\n\t\t\t\treturn (is_cross_y(other) and other.is_cross_y((*this)));\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\tPoint p1, p2;\n\tint X, Y, maxx, maxy, minx, miny;\n};\nint main(){\n\tint q;\n\tstd::scanf(\"%d\", &q);\n\tfor (auto i = 0; i < q; ++i){\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tstd::scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tLine l1(x0, y0, x1, y1), l2(x2, y2, x3, y3);\n\t\tif (l1.is_intersection(l2)){\n\t\t\tstd::printf(\"1\\n\");\n\t\t}else{\n\t\t\tstd::printf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#define EPS 1e-16\n\ntypedef std::pair<double, double> point;\n\nclass C\n{\n\tfriend point operator - (point, point);\n};\npoint operator - (point p0, point p1)\n{\n\treturn point(p0.first - p1.first, p0.second - p1.second);\n}\n\ndouble cross(point p0, point p1)\n{\n\treturn p0.first * p1.second - p1.first * p0.second;\n}\n\nbool is_intersected(point a0, point a1, point b0, point b1)\n{\n\treturn ( cross(a1 - a0, b0 - a0) * cross(a1 - a0, b1 - b0) < EPS ) && ( cross(b1 - b0, a0 - b0) * cross(b1 - b0, a1 - b0) < EPS);\n}\n\nint main(void)\n{\n\tint n;\n\tpoint p0, p1, p2, p3;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &p0.first, &p0.second, &p1.first, &p1.second, &p2.first, &p2.second, &p3.first, &p3.second);\n\t\tprintf(\"%d\\n\", is_intersected(p0, p1, p2, p3));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int MOD = 1000000007;\n\n// Data structures.\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point(const Point& p) : x(p.x), y(p.y) {}\n\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n\n    bool operator<(const Point& p) const { return x != p.x ? x < p.x : y < p.y; }\n    bool operator==(const Point& p) const { return fabs(x - p.x) < 1e-10 && fabs(y - p.y) < 1e-10; }\n\n    static double norm(const Point& p) { return sqrt(p.x * p.x + p.y * p.y); }\n    static double dot(const Point& p1, const Point& p2) { return p1.x * p2.x + p1.y * p2.y; }\n    static double cross(const Point& p1, const Point& p2) { return p1.x * p2.y - p1.y * p2.x; }\n};\n\nstruct Segment {\n    Point s, t;\n};\n\nint ccw(const Point& p1, const Point& p2, const Point& p) {\n    double cr = Point::cross(p2 - p1, p - p1);\n    if (cr > 0) return 1;\n    if (cr < 0) return -1;\n    // p, p1, p2.\n    if (Point::dot(p2 - p1, p - p1) < 0) { return 2; }\n    // p1, p2, p.\n    if (Point::dot(p - p2, p1 - p2) < 0) { return -2; }\n    // p is in [p1, p2].\n    return 0;\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    bool ok1 = ccw(s1.s, s1.t, s2.s) * ccw(s1.s, s1.t, s2.t) <= 0;\n    bool ok2 = ccw(s2.s, s2.t, s1.s) * ccw(s2.s, s2.t, s1.t) <= 0;\n    return ok1 && ok2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int q;\n    cin >> q;\n\n    rep(i, 0, q) {\n        Segment s1, s2;\n        cin >> s1.s.x >> s1.s.y >> s1.t.x >> s1.t.y;\n        cin >> s2.s.x >> s2.s.y >> s2.t.x >> s2.t.y;\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE_BACK,\n              ONLINE_FRONT, ON_SEGMENT};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    POSITION s2p1_s1 = get_position(s2.p1, s1);\n    POSITION s2p2_s1 = get_position(s2.p2, s1);\n    POSITION s1p1_s2 = get_position(s1.p1, s2);\n    POSITION s1p2_s2 = get_position(s1.p2, s2);\n    if (s2p1_s1 == ON_SEGMENT || s2p2_s1 == ON_SEGMENT) return true;\n    if (s1p1_s2 == ON_SEGMENT || s1p2_s2 == ON_SEGMENT) return true;\n    if (s2p1_s1 == ONLINE_FRONT) {\n        if (s2p2_s1 == ONLINE_BACK) return true;\n        return false;\n    }\n    if (s2p1_s1 == ONLINE_BACK) {\n        if (s2p2_s1 == ONLINE_FRONT) return true;\n        return false;\n    }\n    if (s2p1_s1 != s2p2_s1 && s1p1_s2 != s1p2_s2) return true;\n    return false;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 定義・定数\nusing P = complex<double>;\nconst double EPS = 1e-10;\n\nnamespace std {\n  // 点の比較演算子\n  bool operator < (const P &a, const P &b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  \n  // 点の等価演算子\n  bool operator == (const P &a, const P &b) {\n    return fabs(a - b) < EPS;\n  }\n}\n\n// 直線\nstruct L : public vector<P> {\n  L(P &_a, P &_b) {\n    push_back(_a);\n    push_back(_b);\n  }\n};\n\n// 線分\nstruct S : L {\n  S(P &_a, P &_b) : L(_a, _b) {}\n};\n\n// 円\nstruct C {\n  P p;\n  double r;\n  \n  C(P _p, double _r) : p(_p), r(_r) {}\n};\n\n// 内積\ndouble dot(const P &a, const P &b) {\n  return real(conj(a) * b);\n}\n\n// 外積\ndouble cross(const P &a, const P &b) {\n  return imag(conj(a) * b);\n}\n\n// 直交判定\nbool isOrthogonal(const L &l, const L &m) {\n  return abs(dot(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\n// 平行判定\nbool isParallel(const L &l, const L &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// 交差判定\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n         abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const S &s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *      // s[0] is left of l\n         cross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const S &s, const S &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const S &s, const P &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\n// 距離など\nP projection(const L &l, const P &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const S &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const S &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const S &s, const S &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  int q;\n  cin >> q;\n  while (q--) {\n    double a, b, c, d, x, y, z, w;\n    cin >> a >> b >> c >> d >> x >> y >> z >> w;\n    P p0(a, b), p1(c, d), p2(x, y), p3(z, w);\n    S s(p0, p1), t(p2, p3);\n    \n    if (intersectSS(s, t)) cout << 1 << '\\n';\n    else cout << 0 << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-7;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n    \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(ll i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\n\nusing P=complex<R>;\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nusing L=struct{P s,t;};\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a)-norm(b)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tR s1=det(a.s,a.t,b.s)*det(a.s,a.t,b.t);\n\tR s2=det(b.s,b.t,a.s)*det(b.s,b.t,a.t);\n\treturn sgn(s1)<=-end&&sgn(s2)<=-end;\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << iss(s1,s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef double db;\ndb eps=1e-9;\nstruct point {\n\tdb x,y;\n\tpoint() {}\n\tpoint(db x,db y):x(x),y(y) {}\n\tvoid input() { scanf(\"%lf%lf\",&x,&y); }\n\tvoid output() { printf(\"%.10f %.10f\\n\",x,y); }\n\tdb len() { return sqrt(x*x+y*y); }\n\tdb len2() { return x*x+y*y; }\n};\npoint operator + (const point &a,const point &b) { return point(a.x+b.x,a.y+b.y);}\npoint operator - (const point &a,const point &b) { return point(a.x-b.x,a.y-b.y);}\npoint operator * (const point &a,const db &b) { return point(a.x*b,a.y*b);}\npoint operator / (const point &a,const db &b) { return point(a.x/b,a.y/b);}\ndb dot(const point &a,const point &b) { return a.x*b.x+a.y*b.y; }\ndb det(const point &a,const point &b) { return a.x*b.y-a.y*b.x; }\nstruct line {\n\tpoint a,b;\n\tline() {}\n\tline(point a,point b):a(a),b(b) {}\n};\npoint proj(const line &a,const point &b) {\n\treturn a.a+(a.b-a.a)*dot(a.b-a.a,b-a.a)/(a.b-a.a).len2();\n}\npoint reflect(const line &a,const point &b) {\n\treturn proj(a,b)*2-b;\n}\nint dblcmp(db x) {\n\treturn fabs(x)<eps?0:(x>0?1:-1);\n}\nint relation(const line &a,const point &b) {\n\tint x=dblcmp(det(a.b-a.a,b-a.a));\n\tif (x==1) return 0; // COUNTER_CLOCKWISE ?????¶???\n\telse if (x==-1) return 1; // CLOCKWISE ?????¶???\n\telse {\n\t\tx=dblcmp(dot(b-a.a,a.b-a.a));\n\t\tif (x<-eps) return 2; // ONLINE_BACK\n\t\telse {\n\t\t\tx=dblcmp(dot(b-a.b,a.b-a.a));\n\t\t\tif (x>eps) return 3; // ONLINE_FRONT\n\t\t\telse return 4; // ON_SEGMENT\n\t\t}\n\t}\n}\nbool parallel(line &a,line &b) { return dblcmp(det(a.a-a.b,b.a-b.b))==0;}\nint segcrossseg(const line &a, const line &b) {\n\tint d1=dblcmp(det(a.b-a.a,b.a-a.a));\n\tint d2=dblcmp(det(a.b-a.a,b.b-a.a));\n\tint d3=dblcmp(det(b.b-b.a,a.a-b.a));\n\tint d4=dblcmp(det(b.b-b.a,a.b-b.a));\n\tif ((d1^d2)==-2&&(d3^d4)==-2) return 2; // ?§??????????\n\treturn ((d1==0&&dblcmp(dot(b.a-a.a,b.a-a.b))<=0)||\n\t\t\t(d2==0&&dblcmp(dot(b.b-a.a,b.b-a.b))<=0)||\n\t\t\t(d3==0&&dblcmp(dot(a.a-b.a,a.a-b.b))<=0)||\n\t\t\t(d4==0&&dblcmp(dot(a.b-b.a,a.b-b.b))<=0)); // ????§????/?????????\n}\n\nint q;\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,0,q) {\n\t\tpoint p1,p2,q1,q2;\n\t\tp1.input(); p2.input(); q1.input(); q2.input();\n\t\tputs(segcrossseg(line(p1,p2),line(q1,q2))>=1?\"1\":\"0\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef complex<double> P;\nconst double eps = 1e-8;\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < -eps) return 2;\n    if (norm(c) > norm(b)) return -2;\n    return 0;\n}\nbool intersectSS(P p1, P p2, P p3, P p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nint n,m;long double ax[1000],ay[1000],bx[1000],by[1000],dist[1000];\nvector<pair<int,long double>>x[1000];\nlong double dijkstra(int s,int t){\n\tpriority_queue<pair<long double,int>,vector<pair<long double,int>>,greater<pair<long double,int>>>Q;\n\tQ.push(make_pair(0.0L,s));for(int i=0;i<1000;i++)dist[i]=1e9;dist[s]=0.0L;\n\twhile(!Q.empty()){\n\t\tlong double a1=Q.top().first;int a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<x[a2].size();i++){\n\t\t\tif(dist[x[a2][i].first]>a1+x[a2][i].second){\n\t\t\t\tdist[x[a2][i].first]=a1+x[a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[x[a2][i].first],x[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[t];\n}\nint main(){\n\tcin>>n>>m;for(int i=0;i<n;i++)cin>>ax[i]>>ay[i];\n\tfor(int i=0;i<m;i++)cin>>bx[i]>>by[i];\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(ax[i],ay[i]),P(ax[j],ay[j]),P(bx[0],by[0]),P(bx[1],by[1]))==0){\n\t\t\t\tlong double dst1=sqtrl((ax[i]-ax[j])*(ax[i]-ax[j])+(ay[i]-ay[j])*(ay[i]-ay[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r1=dijkstra(0,1);\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(bx[i],by[i]),P(bx[j],by[j]),P(ax[0],ay[0]),P(ax[1],ay[1]))==0){\n\t\t\t\tlong double dst1=sqtrl((bx[i]-bx[j])*(bx[i]-bx[j])+(by[i]-by[j])*(by[i]-by[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r2=dijkstra(0,1);\n\tprintf(\"%.15Lf\\n\",min(p1,p2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\ndouble sgn(double d) {\n  if (dcmp(d))\n    return 0;\n  if (d > 0)\n    return 1;\n  return -1;\n}\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) { return dcmp(a * p.x + b * p.y + c); }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() { return line(p1, p2); }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    return ok;\n  }\n  bool intersect(segment s) {\n    if (p1 == s.p1 || p1 == s.p2 || p2 == s.p1 || p2 == s.p2)\n      return true;\n    point a = p1, b = p2, c = s.p1, d = s.p2;\n    return sgn((a - b).cross(b - c)) != sgn((a - b).cross(b - d)) &&\n           sgn((c - d).cross(d - a)) != sgn((c - d).cross(d - b));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1);\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n\nclass point {\npublic:\n\tdouble x, y;\n\tpoint() {}\n\tpoint( double x_, double y_ ) : x(x_), y(y_) {}\n\tpoint operator -( point p ) { return point( x - p.x, y - p.y ); }\n\tpoint operator +( point p ) { return point( x + p.x, y + p.y ); }\n\tpoint operator *( int a ) { return point( x * a, y * a ); }\n};\n\nclass segment {\npublic:\n\tpoint p1, p2;\n\tsegment() {}\n};\n\ndouble dot( point a, point b ) { return a.x * b.x + a.y * b.y; }\ndouble cross( point a, point b ) { return a.x * b.y - a.y * b.x; }\ndouble norm( point a ) { return a.x * a.x + a.y * a.y; }\n\ndouble distance( segment s, point p )\n{\n\tif( dot( s.p2 - s.p1, p - s.p1 ) < 0 ) return sqrt( norm( p - s.p1 ) );\n\tif( dot( s.p1 - s.p2, p - s.p2 ) < 0 ) return sqrt( norm( p - s.p2 ) );;\n\treturn fabs( cross( s.p2 - s.p1, p - s.p1 ) / sqrt( norm( s.p2 - s.p1 ) ) );\n}\n\nint ccw( point p0, point p1, point p2 )\n{\n\tpoint v1 = p1 - p0;\n\tpoint v2 = p2 - p0;\n\tif( cross( v1, v2 ) > EPS ) return 1;\n\tif( cross( v1, v2 ) < -EPS ) return -1;\n\tif( dot( v1, v2 ) < -EPS ) return 2;\n\tif( norm( v1 ) < norm( v2 ) ) return -2;\n\treturn 0;\n}\n\nbool intersect( segment s1, segment s2 )\n{\n\treturn ccw( s1.p1, s1.p2, s2.p1 ) * ccw( s1.p1, s1.p2, s2.p2 ) <= 0 &&\n\t\t\tccw( s2.p1, s2.p2, s1.p1 ) * ccw( s2.p1, s2.p2, s1.p2 ) <= 0;\n}\n\ndouble distance( segment s1, segment s2 )\n{\n\tif( intersect( s1, s2 ) ) return 0;\n\treturn min( { distance( s1, s2.p1 ), distance( s1, s2.p2 ),\n\t\t\t\t\tdistance( s2, s1.p1 ), distance( s2, s1.p2 ) } );\n}\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\tfor( int i = 0; i < q; i++ ) {\n\t\tsegment s1, s2;\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tint ans = intersect( s1, s2 );\n\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 0\ntypedef struct{\n\tdouble x,y;\n}point;\n\npoint make(double x,double y){\n\tpoint res;\n\tres.x=x;\n\tres.y=y;\n\treturn res;\n}\n//a-b\npoint vec(point a,point b){\n\tpoint res;\n\tres.x=a.x-b.x;\n\tres.y=a.y-b.y;\n\treturn res;\n}\n\n// a・b\ndouble dot(point a,point b){\n\treturn a.x*b.x+a.y*b.y;\n}\n//|a|\ndouble  norm(point a){\nreturn sqrt(dot(a,a));\n}\n//|a|^2\ndouble absolute(point a){\nreturn dot(a,a);\n}\n//a×ｂ　外積z成分\ndouble cross(point a,point b){\nreturn a.x*b.y-a.y*b.x;\n}\n//a=x1+iy1,b=x2+iy2 a*b\npoint imaseki(point a,point b){\npoint res;\nres.x=a.x*b.x-a.y*b.y;\nres.y=a.x*b.y+a.y*b.x;\nreturn res;\n}\n//共役\npoint conjugate(point a){\npoint res;\nres.x=a.x;\nres.y=-a.y;\nreturn res;\n}\n\n\nint ccw(point p0,point p1,point p2){\npoint a=vec(p1,p0);\npoint b=vec(p2,p0);\n\tif(cross(a,b)>EPS){\n\treturn 1;//counter_clockwise\n\t}else if(cross(a,b)<EPS){\n\treturn -1;//clockwise\n\t}else if(dot(a,b)<-EPS){\n\treturn 2;//online_back\n\t}else if(absolute(a)<absolute(b)){\n\treturn -2;//online_front\n\t}else{\n\treturn 0;//on_segment\n\t}\n\n}\n//交差判定　s1-s2 s3-s4\nbool intersect(point s1,point s2,point s3,point s4){\n if(ccw(s1,s2,s3)*ccw(s1,s2,s4)<=0 && ccw(s3,s4,s1)*ccw(s3,s4,s2)<=0)\n        return true;\n    return false;\n}\n\nint main(){\nint q;\ncin>>q;\nfor(int i=0;i<q;i++){\npoint s1,s2,s3,s4;\ndouble x,y;\ncin>>x>>y;\ns1=make(x,y);\ncin>>x>>y;\ns2=make(x,y);\ncin>>x>>y;\ns3=make(x,y);\ncin>>x>>y;\ns4=make(x,y);\nif(intersect(s1,s2,s3,s4)){\ncout<<1<<endl;\n}else{\ncout<<0<<endl;\n}\n\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nint dcmp(double x) {\n    static double eps = 1e-8;\n    return (x > eps) - (x < -eps);\n}\n\nstruct vec{\n    double x, y;\n\n    vec(double _x=0, double _y=0)\n        :x(_x), y(_y) {}\n\n    vec operator- () const{ return vec(-x, -y); }\n    \n    vec operator+ (const vec& v) const{ return vec(x+v.x, y+v.y); }\n    vec operator- (const vec& v) const{ return vec(x-v.x, y-v.y); }\n    vec operator* (double c) const{ return vec(x*c, y*c); }\n    vec operator/ (double c) const{ return vec(x/c, y/c); }\n\n    double dot(const vec& v) const{ return x*v.x + y*v.y; }\n    double cross(const vec& v) const{ return x*v.y - y*v.x; }\n\n    double len2() const{ return x*x + y*y; }\n    double len() const{ return sqrt(len2()); }\n    \n    vec& norm() { return *this = *this / len(); }\n    vec& rot(double rad) {\n        return  *this = vec(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad));\n    }\n\n    bool operator< (const vec& v) const{\n        return dcmp(x-v.x) < 0 || (dcmp(x-v.x)==0 && dcmp(y-v.y) < 0);\n    }\n    bool operator== (const vec& v) const{\n        return dcmp(x-v.x) == 0 && dcmp(y-v.y) == 0;\n    }\n};\n\nstruct line{\n    vec u, v; // u + x*v\n\n    line() {}\n    line(vec _u, vec _v)\n        :u(_u), v(_v) {}\n\n    vec get(double x) const{ return u + v * x; }\n    \n    bool on_left(vec p) const{ return dcmp(v.cross(p - u)) > 0; }\n    \n    vec proj(vec p) const{ return get(v.dot(p - u)); }\n    vec refl(vec p) const{ return p + (proj(p) - p) * 2; }\n    \n    vec line_intersection(line b) const{\n        return b.u + b.v * b.v.cross(b.u-u) / v.cross(b.v);\n    }\n};\n\nline makeline(vec a, vec b) {\n    return line(a, (b - a).norm());\n}\n\nbool in_segment(vec a, vec b, vec c) {\n    vec u = a - c, v = b - c;\n    return a == c || b == c || (dcmp(u.cross(v)) == 0 && dcmp(u.dot(v)) < 0);\n}\n\nbool segment_intersection(vec a, vec b, vec c, vec d) {\n    line x = line(a, b-a), y = line(c, d-c);\n    return in_segment(a, b, c) || in_segment(a, b, d) ||\n           in_segment(c, d, a) || in_segment(c, d, b) ||\n           (x.on_left(c) != x.on_left(d) && y.on_left(a) != y.on_left(b));\n}\n\nbool is_convex(const std::vector<vec>& p) {\n    for (size_t i = 0, j = 1, k; j < p.size(); i++, j++) {\n        k = (j + 1) % p.size();\n        if ((p[j] - p[i]).cross(p[k] - p[j]) < 0)\n            return false;\n    }\n    return true;\n}\n\nstd::vector<vec> convex_hull(std::vector<vec> p) {\n    std::sort(p.begin(), p.end());\n    std::vector<vec> ch;\n    for (size_t i = 0; i < p.size(); ++i) {\n        while (ch.size() > 1 && makeline(ch[ch.size()-2], p[i]).on_left(ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    size_t k = ch.size();\n    for (int i = p.size() - 2; i >= 0; --i) {\n        while (ch.size() > k && makeline(ch[ch.size()-2], p[i]).on_left(ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    ch.pop_back();\n    return ch;\n}\n\nstd::pair<vec, vec> convex_diameter(const std::vector<vec> &p) {\n    int xmax = 0, xmin = 0, n = p.size();\n    for (int i = 1; i < n; ++i) {\n        if (p[i].x > p[xmax].x) xmax = i;\n        if (p[i].x < p[xmin].x) xmin = i;\n    }\n    \n    int i = xmax, j = xmin;\n    int u = xmax, v = xmin;\n    double ans = (p[xmax] - p[xmin]).len2();\n    \n    do {\n        if ((p[i] - p[(i + 1) % n]).cross(p[j] - p[(j + 1) % n]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n\n        double dist = (p[i] - p[j]).len2();\n        if (dist > ans) {\n            ans = dist;\n            u = i; v = j;\n        }\n    }while(i != xmax || j != xmin);\n    return std::make_pair(p[u], p[v]);\n}\n\ndouble polygon_area(const std::vector<vec>& v) {\n    double area = 0;\n    for (size_t i = 0; i < v.size(); ++i)\n        area += v[i].cross(v[(i + 1) % v.size()]);\n    return area * 0.5;\n}\n\nint relation(const std::vector<vec>& p, const vec& v) {\n    int ret = -1, n = p.size();\n    for (int i = 0; i < n; ++i) {\n        vec a = p[i] - v, b = p[(i + 1) % n] - v;\n        if (a.y > b.y) std::swap(a, b);\n        if (a.y <= 0 && 0 < b.y && a.cross(b) < 0)\n            ret = -ret;\n        if (a.cross(b) == 0 && a.dot(b) <= 0) return 0;\n    }\n    \n    return ret; // 1 - contain, -1 - out\n}\n\n// end template\n\nint main() {\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        vec a, b, c, d;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",\n              &a.x, &a.y, &b.x, &b.y, &c.x, &c.y, &d.x, &d.y);\n\n        puts(segment_intersection(a, b, c, d) ? \"1\": \"0\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\nconst double eps = 1e-10;\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}  \n  double norm() {return sqrt(x*x + y*y);}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ndouble operator * (const Point &p, const Point q) {return p.x * q.x + p.y * q.y;}\nbool operator == (const Point &p, const Point &q) {return (abs(p.x - q.x) < eps && abs(p.y - q.y) < eps);}\nbool operator != (const Point &p, const Point &q) {return !(p == q);}\ndouble cross(const Point &p, const Point &q) {return p.x*q.y - p.y*q.x;}\n\nstruct Line_Segment {\n  Point p , q;\n  Line_Segment(Point p = Point(0.0,0.0), Point q = Point(0.0,0.0)) : p(p), q(q) {}\n};\n\nstruct Line {\n  double a, b, c;\n  Line(double a, double b, double c) : a(a), b(b), c(c) {}\n  Line(Point p, Point q) {\n    a = q.y - p.y;\n    b = p.x - q.x;\n    c = q.x * p.y - p.x * q.y;\n  }\n};\n\nstruct Circle {\n  double r;\n  Point p;\n  Circle(Point p = Point(0.0, 0.0), double r = 0.0) : p(p), r(r) {}\n};\n\nint ccw(Point p, Point p1, Point p2) {\n  p1 = p1 - p; p2 = p2 - p;\n  if(cross(p1,p2) > eps) return 1; \n  if(cross(p1,p2) < -eps) return -1; \n  if(p1 * p2 < 0) return 2; \n  if(p1.norm() < p2.norm()) return -2; \n  return 0; \n}\n\nbool line_segment_cross(const Line_Segment l, const Line_Segment s) {\n  return ccw(l.p,l.q,s.p) * ccw(l.p,l.q,s.q) <= 0 && ccw(s.p,s.q,l.p) * ccw(s.p,s.q,l.q) <= 0;\n}\n\nint main() {\n  int q;\n  cin >> q;\n  rep(i,q) {\n    Point a, b, c, d;\n    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y;\n    Line_Segment l(a,b);\n    Line_Segment s(c,d);\n    cout << (line_segment_cross(l,s) ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <iomanip>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\n#define NAN_M 0x800000000000\n#define EPS 0.0000000001\n\nclass Position {\npublic:\n    enum Positions {\n        COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = 3,\n        ON_SEGMENT = 0\n    };\n\n    static std::string ToString(enum Positions e) {\n        switch (e) {\n            case COUNTER_CLOCKWISE:\n                return \"COUNTER_CLOCKWISE\";\n            case CLOCKWISE:\n                return \"CLOCKWISE\";\n            case ONLINE_BACK:\n                return \"ONLINE_BACK\";\n            case ONLINE_FRONT:\n                return \"ONLINE_FRONT\";\n            case ON_SEGMENT:\n                return \"ON_SEGMENT\";\n        }\n    }\n};\n\ntemplate<class T>\nclass Vector2D {\npublic:\n    T x;\n    T y;\n\n    Vector2D() {\n        x = y = 0;\n    }\n\n    Vector2D(T x_, T y_) {\n        x = x_;\n        y = y_;\n    }\n\n    T operator*(const Vector2D<T> *e) {\n        return this->x * e->x + this->y * e->y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x - e->x, this->y - e->y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x + e->x, this->y + e->y);\n    }\n\n    T operator*(const Vector2D<T> e) {\n        return this->x * e.x + this->y * e.y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> e) {\n        return Vector2D<T>(this->x - e.x, this->y - e.y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> e) {\n        return Vector2D<T>(this->x + e.x, this->y + e.y);\n    }\n\n    Vector2D<T> operator*(const T r) {\n        return Vector2D<T>(this->x * r, this->y * r);\n    }\n\n    Vector2D<T> operator/(const T r) {\n        return Vector2D<T>(this->x / r, this->y / r);\n    }\n\n    Vector2D<T> operator-() {\n        return Vector2D<T>(-this->x, -this->y);\n    }\n\n    double abs() {\n        return sqrt(x * x + y * y);\n    }\n\n    T norm() {\n        return x * x + y * y;\n    }\n\n    T crossP(Vector2D<T> e) {\n        if (x * e.y >= y * e.x) return (x * e.y) - (y * e.x);\n        else return (y * e.x) - (x * e.y);\n    }\n\n    T cross(Vector2D<T> e) {\n        return (x * e.y) - (y * e.x);\n    }\n\n    double cos(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return (e * (*this)) / (e.abs() * abs());\n    }\n\n    double sin(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return ((x * e.y) - (y * e.x)) / (e.abs() * abs());\n    }\n};\n\ntemplate<class T>\nclass Point2D : public Vector2D<T> {\npublic:\n    using Vector2D<T>::Vector2D;\n};\n\ntemplate<class T>\nclass Line2D {\npublic:\n    Point2D<T> p1, p2;\n    Line2D(){\n        p1 = Point2D<T>(0,0);\n        p2 = Point2D<T>(0,0);\n    }\n    Line2D(Point2D<T> p1_,Point2D<T> p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Vector2D<T> getVector() {\n        return p2 - p1;\n    }\n\n    Point2D<T> getProject(Point2D<T> p) {\n        Vector2D<T> base = getVector();\n        return p1 + base * ((p - p1) * base) / base.norm();\n    }\n\n    Point2D<T> reflect(Point2D<T> p) {\n        return p + (getProject(p) - p) * 2;\n    }\n\n    virtual double getDistance(Point2D<T> p) {\n        return (p2 - p1).crossP(p - p1) / (p2 - p1).abs();\n    }\n};\n\ntemplate<class T>\nclass Segment2D : public Line2D<T> {\npublic:\n    using Line2D<T>::p1;\n    using Line2D<T>::p2;\n    using Line2D<T>::Line2D;\n    double getDistance(Point2D<T> p) override{\n        if ((p2 - p1).cross(p - p1) < 0) return (p - p1).abs();\n        if ((p1 - p2).cross(p - p1) < 0) return (p - p1).abs();\n        return Line2D<T>::getDistance(p);\n    }\n\n    Position::Positions ccw(Point2D<T> p) {\n        Vector2D<T> a = p2 - p1;\n        Vector2D<T> b = p - p1;\n        if (a.cross(b) > EPS) return Position::Positions::COUNTER_CLOCKWISE;\n        if (a.cross(b) < -EPS) return Position::Positions::CLOCKWISE;\n        if (a * b < -EPS) return Position::Positions::ONLINE_BACK;\n        if (a.norm() < b.norm()) return Position::Positions::ONLINE_FRONT;\n        return Position::Positions::ON_SEGMENT;\n    }\n\n    bool intersect(Segment2D<T> s) {\n        return ((ccw(s.p1) * ccw(s.p2) <= 0 && s.ccw(p1) * s.ccw(p2) <= 0) || ccw(s.p1) * ccw(s.p2) == 0  || s.ccw(p1) * s.ccw(p2) == 0);\n    }\n\n    double getDistance(Segment2D<T> s) {\n\n    }\n};\n\nint main(void){\n    int q;\n    cin >> q;\n    loop(i,0,q){\n        Point2D<double> v[4];\n        loop(j,0,4) {\n            cin >> v[j].x >> v[j].y;\n        }        int res = Segment2D<double>(v[0],v[1]).intersect(Segment2D<double>(v[2],v[3]));\n        if(res) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n/*\nint main(void) {\n    Segment2D<double> b;\n    cin >> b.p1.x >> b.p1.y >> b.p2.x >> b.p2.y;\n    int q;\n    cin >> q;\n    Point2D<double> c;\n    loop(i,0,q){\n        cin >> c.x >> c.y;\n        cout << Position::ToString(b.ccw(c)) << endl;\n    }\n}*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.x + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os <<  p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (abs_cross(b, c) > 0) return COUNTER_CLOCKWISE;\n    if (abs_cross(b, c) < 0) return CLOCKWISE;\n    if (dot(b, c) < 0)       return ONLINE_BACK;\n    if (b.abs2() < c.abs2())   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\n\n/**\n * Intersection point and Distance\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\nPoint Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\n\nint main()\n{\n    Segment s1, s2;\n    int q;\n\n    std::cin >> q;\n\n    while (q--) {\n        std::cin >> s1 >> s2;\n\n        if (IsIntersect(s1, s2))\n            std::cout << \"1\\n\";\n        else\n            std::cout << \"0\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :\n\t\t\tx(x), y(y) {\n\t}\n\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n};\n\nclass Segment {\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\n\ndouble dot(Point p1, Point p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\ndouble cross(Point p1, Point p2) {\n\treturn p1.x * p2.y - p1.y * p2.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 0;\nstatic const int ON_SEGMENT = 0;\nstatic const int ONLINE_FRONT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\tif (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\tif (a.norm() < b.norm())\n\t\treturn ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3) {\n\treturn ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\nint main() {\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tint p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\", &p1x, &p1y, &p2x, &p2y, &p3x, &p3y, &p4x, &p4y);\n\t\tPoint p1(p1x, p1y);\n\t\tPoint p2(p2x, p2y);\n\t\tPoint p3(p3x, p3y);\n\t\tPoint p4(p4x, p4y);\n\n\t\tif (intersect(p1, p2, p3, p4)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\tint\tp0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0;\n\tint n = 0;\n\tdouble u = 0, s = 0, t = 0;\n\n\tcin >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\t\tn = 0;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\t\t\n\t\tif (u != 0) {\n\t\t\ts = (double)((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = - (double)((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((p2x == p0x && p2y == p0y)| (p3x == p0x && p3y == p0y))\n\t\t\t\tn = 1;\n\n\t\t\tif (p1x != 0) {\n\t\t\t\tif ((p1x - p2x) * (p1x - p3x) <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif ((p1y - p2y) * (p1y - p3y) <= 0)\n\t\t\t\t\tn = 1;\t\t\t\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n//--\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = Y-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\n#define re real()\n#define im imag()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> pt;\ntypedef pair<pt,pt> line; //sX+tY\n\ndouble dot(pt a,pt b){return (conj(a)*b).real();}\ndouble cros(pt a,pt b){return (conj(a)*b).imag();}\npt proj(pt a,pt to){\n  return dot(a,to)/norm(to)*to;\n}\n\npt refle(pt a,pt mirror){\n  return pt(2)*proj(a,mirror)-a;\n}\n\nint pt3(pt a,pt b,pt c){\n  pt p=b-a,q=c-a;\n  double tmp;\n  tmp=cros(p,q);\n  if(tmp>0){\n    return 0;\n  }else if(tmp<0){\n    return 1;\n  }else if(norm(p+q)<max(norm(p),norm(q))){\n    return 2;\n  }else if(norm(q)>norm(p)){\n    return 3;\n  }else if(norm(q)<norm(p)){\n    return 4;\n  }\n  return 5;\n}\n\npt dir(line a){return a.Y-a.X;}\n\nint line2(line a,line b){\n  if(dot(dir(a),dir(b))==0)\n    return 1;//直交\n  if(cros(dir(a),dir(b))==0)\n    return 2;//平行\n  return 0;\n}\n\nint intersect(line a,line b){\n  return cros(dir(a),b.X-a.X)*cros(dir(a),b.Y-a.X)<=0\n    && cros(dir(b),a.X-b.X)*cros(dir(b),a.Y-b.X)<=0;\n}\n\nint main(){\n  int i,j,k,n,re;\n  line s1,s2;\n  double a[8];\n  cin>>n;\n  rep(i,n){\n    rep(j,8)\n      cin>>a[j];\n    s1.X=pt(a[0],a[1]);\n    s1.Y=pt(a[2],a[3]);\n    s2.X=pt(a[0+4],a[1+4]);\n    s2.Y=pt(a[2+4],a[4+3]);\n    cout<<intersect(s1,s2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\ntypedef long double ld;\nconst ld global_eps=1e-8;\n#if 0\nenum cases{insi,bord,outs};//inside, border, outside\nenum cases{para,coin,inte};//parallel, coincide, intersect\n#else\nenum Case\n{\n    insi,bord,outs,//inside, border, outside\n    para,coin,inte, //parallel, coincide, intersect\n    tang,tang_in,tang_out //tangent\n};\n#endif\nint sign(ld x,ld eps=global_eps){return (x>=eps)-(x<=-eps);}\nint cmp(ld a,ld b,ld eps=global_eps){return sign(a-b,eps);}\nstruct Point\n{\n    ld x,y;\n    Point():x(0),y(0){}\n    Point(ld _x,ld _y):x(_x),y(_y){}\n    Point operator +(const Point &p) const\n    {return Point(x+p.x,y+p.y);}\n    Point operator -(const Point &p) const\n    {return Point(x-p.x,y-p.y);}\n    ld operator *(const Point &p) const\n    {return x*p.x+y*p.y;}\n    ld operator %(const Point &p) const\n    {return x*p.y-y*p.x;}   \n    bool operator <(const Point &p) const\n    {return tie(y,x) < tie(p.y,p.x);}\n    bool operator ==(const Point &p) const\n    {return tie(y,x) == tie(p.y,p.x);}\n    Point operator /(const ld &l) const\n    {return Point(x/l,y/l);}\n    Point operator *(const ld &l) const\n    {return Point(x*l,y*l);}\n    ld len() const{return hypot(x,y);}\n    ld len2() const{return x*x+y*y;}\n    ld dis(const Point &a)const{return (*this-a).len();}\n    ld dis2(const Point &a)const{return (*this-a).len2();}\n    Point unit()const{return *this/len();}\n    Point resize(const ld &l)const{return unit()*l;}\n};\nstruct Line\n{\n    Point p1,p2;\n    Line(){}\n    Line(Point a,Point b):p1(a),p2(b){}\n    Point way() const{return p2-p1;}\n    Point norm() const{return {p1.y-p2.y,p2.x-p1.x};}\n    bool online(const Point &p) const{return sign((p-p1)%way())==0;}\n    bool onsegment(const Point &p)const\n    {\n        return online(p) && sign((p-p1)*(p2-p))>=0;\n    }\n    pair<int,Point> intersect(const Line &I) const\n    {\n        if(sign(I.way()%way())==0) return {online(I.p1)?coin:para,{0,0}};\n        const Point &p3=I.p1,&p4=I.p2;\n        auto _143=(p1-p4)%(p4-p3),_342=(p3-p4)%(p4-p2);\n        return {inte,(p1*_342+p2*_143)/(_143+_342)};\n    }\n    ld linedistance(const Point &p) const\n    {\n        return abs((p-p1)%way())/way().len();\n    }\n    Point project(const Point &p) const\n    {\n        return intersect(Line(p,p+norm())).second;\n    }\n    ld segmentdistance(const Point &p) const\n    {\n        const auto &pro=project(p);\n        if(onsegment(pro)) return p.dis(pro);\n        return min(p.dis(p1),p.dis(p2));\n    }\n};\nint main()\n{\n    int t;RI(t);\n    while(t--)\n    {\n        Point p[4];\n        REP(i,4) cin>>p[i].x>>p[i].y;\n        Line I(p[0],p[1]),J(p[2],p[3]);\n        auto ans=I.intersect(J);\n        if(ans.F==coin||ans.F==para) PL(0);\n        else if(I.onsegment(ans.S)) PL(1);\n        else PL(0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n\n#define EPS 1e-10\n\nusing namespace std;\n\nint func(double x1, double y1, double x2, double y2, double xp, double yp) {\n    double naiseki, norm1, norm2, gaiseki;\n    norm1   = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    norm2   = sqrt((xp - x1) * (xp - x1) + (yp - y1) * (yp - y1));\n    naiseki = (xp - x1) * (x2 - x1) + (yp - y1) * (y2 - y1);\n    gaiseki = (x2 - x1) * (yp - y1) - (xp - x1) * (y2 - y1);\n    if (gaiseki > EPS) {\n        return 1;\n    } else if (gaiseki < -EPS) {\n        return -1;\n    }\n\n    if (naiseki < -EPS) {\n        return 2;\n    }\n\n    if (norm1 < norm2) {\n        return -2;\n    }\n    return 0;\n}\n\nint main() {\n    double x1, x2, x3, x4, y1, y2, y3, y4;\n    int    q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x1, &y1, &x2, &y2, &x3, &y3,\n              &x4, &y4);\n\n        if (func(x1, y1, x2, y2, x3, y3) * func(x1, y1, x2, y2, x4, y4) <= 0 &&\n            func(x3, y3, x4, y4, x1, y1) * func(x3, y3, x4, y4, x2, y2) <= 0) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ld long double\n#define eps 1e-9\n\nbool cmp(ld A , ld B){return A + eps > B && A - eps < B;}\n\nstruct vec{\n\tld x , y;\n\tvec(ld _x = 0 , ld _y = 0) : x(_x) , y(_y){}\n\tfriend vec operator +(vec A , vec B){return vec(A.x + B.x , A.y + B.y);}\n\tfriend vec operator -(vec A , vec B){return vec(A.x - B.x , A.y - B.y);}\n\tfriend ld operator *(vec A , vec B){return A.x * B.x + A.y * B.y;}\n\tfriend ld operator %(vec A , vec B){return A.x * B.y - A.y * B.x;}\n\tfriend vec operator *(vec A , ld B){return vec(A.x * B , A.y * B);}\n\tld len(){return sqrt(x * x + y * y);}\n\tld angle(){return atan2(y , x);}\n};\n\nstruct segment{\n\tvec st , ed , dir;\n\tsegment(vec _a = vec() , vec _b = vec()) : st(_a) , ed(_b) , dir(_b - _a){}\n\tfriend bool havesect(segment A , segment B){\n\t\tld P = A.st.x , Q = A.ed.x , X = B.st.x , Y = B.ed.x;\n\t\tif(Q < P) swap(P , Q);\n\t\tif(Y < X) swap(X , Y);\n\t\tif(X - eps > Q || P - eps > Y) return 0;\n\t\tP = A.st.y , Q = A.ed.y , X = B.st.y , Y = B.ed.y;\n\t\tif(Q < P) swap(P , Q);\n\t\tif(Y < X) swap(X , Y);\n\t\tif(X - eps > Q || P - eps > Y) return 0;\n\t\treturn\n\t\t\t((B.st - A.st) % A.dir) * (A.dir % (B.ed - A.st)) > -eps &&\n\t\t\t((B.st - A.ed) % A.dir) * (A.dir % (B.ed - A.ed)) > -eps &&\n\t\t\t((A.st - B.st) % B.dir) * (B.dir % (A.ed - B.st)) > -eps &&\n\t\t\t((A.st - B.ed) % B.dir) * (B.dir % (A.ed - B.ed)) > -eps;\n\t}\n\tfriend vec getsect(segment A , segment B){\n\t\t\n\t}\n};\n\nvec getvec(){int x , y; cin >> x >> y; return vec(x , y);}\nsegment getseg(){vec A = getvec() , B = getvec(); return segment(A , B);}\n\nint main(){\n\tint Q;\n\tfor(cin >> Q ; Q ; --Q){\n\t\tsegment A = getseg() , B = getseg();\n\t\tprintf(\"%d\\n\" , havesect(A , B));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n\n#define EPS 1e-10\n\nusing namespace std;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tint q;\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n\n\t\tif(func(x1,y1,x2,y2,x3,y3)*func(x1,y1,x2,y2,x4,y4) <= 0 &&\n\t\t\t\tfunc(x3,y3,x4,y4,x1,y1) * func(x3,y3,x4,y4,x2,y2) <= 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define eps = (1e-10);\n//点\nstruct Point{\n    double x,y;\n    Point(double _x=0,double _y=0):x(_x),y(_y){}\n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    double norm(){return x*x+y*y;}//模的平方\n    double ABS() {return sqrt(norm());}//模\n};\n//线段\nstruct Segment{\n    Point p1,p2;\n};\n//点积\ndouble dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n}\n//叉积\ndouble cross(Point a,Point b){\n    return a.x*b.y-a.y*b.x;\n}\nbool Intersect(Segment A ,Segment B){\n    if(max(B.p1.x,B.p2.x)<min(A.p1.x,A.p2.x)) return 0;\n    if(max(B.p1.y,B.p2.y)<min(A.p1.y,A.p2.y)) return 0;\n    if(max(A.p1.y,A.p2.y)<min(B.p1.y,B.p2.y)) return 0;\n    if(max(A.p1.x,A.p2.x)<min(B.p1.x,B.p2.x)) return 0;\n    if(cross(A.p1-B.p1,A.p2-B.p1)*cross(A.p1-B.p2,A.p2-B.p2)>0) return 0;\n    if(cross(B.p1-A.p1,B.p2-A.p1)*cross(B.p1-A.p2,B.p2-A.p2)>0) return 0;\n    return 1;\n}\nint main(){\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        Segment A,B;\n        scanf(\"%lf %lf %lf %lf\",&A.p1.x,&A.p1.y,&A.p2.x,&A.p2.y);\n        scanf(\"%lf %lf %lf %lf\",&B.p1.x,&B.p1.y,&B.p2.x,&B.p2.y);\n        if(Intersect(A,B)){\n            puts(\"1\");\n        }else{\n            puts(\"0\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nvoid clockwise(Point p0, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\t\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tPoint p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (doIntersect(p0, p1, p2, p3))cout << 1 << endl;\n\t\telse cout << 0;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (angle(p2 - p1, p4 - p1) == 0.0 || angle(p2 - p1, p4 - p1) == M_PI && angle(p2 - p1, p3 - p1) == 0 || angle(p2 - p1, p3 - p1) == M_PI)return false;\n\telse if (angle(p3 - p1, p4 - p1) >= angle(p3 - p1, p2 - p1) && angle(p3 - p1, p2 - p1) >= 0.0 && angle(p2 - p3, p1 - p3) >= angle(p2 - p3, p4 - p3) && angle(p2 - p3, p4 - p3) >= 0.0)return true;\n\telse if (angle(p3 - p2, p4 - p2) >= angle(p3 - p2, p1 - p2) && angle(p3 - p2, p1 - p2) >= 0.0 && angle(p1 - p3, p2 - p3) >= angle(p1 - p3, p4 - p3) && angle(p1 - p3, p4 - p3) >= 0.0)return true;\n\telse return false;\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nvoid clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\tcout << \"ON_SEGMENT\" << endl;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif((p1 - p0).norm() < (p2 - p0).norm())cout << \"ONLINE_FRONT\" << endl;\n\t\telse cout << \"ON_SEGMENT\" << endl;\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\tcout << \"ONLINE_BACK\" << endl;\n\t} else {\n\t\tif(angle(p1 - p0, p2 - p0) > 0.0)cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\telse cout << \"CLOCKWISE\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <limits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nnamespace libcomp {\nnamespace geometry {\nstatic const double EPS = 1e-9;\ninline double abs(double x){ return std::abs(x); }\ninline bool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n}\n}\nnamespace libcomp {\nnamespace geometry {\nstruct Point {\n\tdouble x;\n\tdouble y;\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(std::isnan(x) || std::isnan(y)); }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator*(const Point &p) const {\n\t\treturn Point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\tPoint &operator*=(const Point &p){ return *this = *this * p; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble norm() const { return x * x + y * y; }\n\tPoint unit() const { return *this / abs(); }\n\tPoint ortho() const { return Point(-y, x); }\n};\ninline Point operator*(double s, const Point &p){ return p * s; }\ninline bool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\ninline double cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline double dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(d.abs() < e.abs()){ return -2; }\n\treturn 0;\n}\n}\n}\nnamespace libcomp {\nnamespace geometry {\nstruct Segment {\n\tPoint a;\n\tPoint b;\n\texplicit Segment(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\tstatic Segment invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Segment(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\tbool operator<(const Segment &s) const {\n\t\treturn (a == s.a) ? (b < s.b) : (a < s.a);\n\t}\n};\ninline bool tolerant_eq(const Segment &a, const Segment &b){\n\tif(tolerant_eq(a.a, b.a) && tolerant_eq(a.b, b.b)){ return true; }\n\tif(tolerant_eq(a.a, b.b) && tolerant_eq(a.b, b.a)){ return true; }\n\treturn false;\n}\ninline bool directed_tolerant_eq(const Segment &a, const Segment &b){\n\treturn tolerant_eq(a.a, b.a) && tolerant_eq(a.b, b.b);\n}\n}\n}\nnamespace libcomp {\nnamespace geometry {\ninline bool intersect(const Point &a, const Point &b){\n\treturn tolerant_eq(a, b);\n}\ninline bool intersect(const Point &a, const Segment &b){\n\treturn (b.a - a).abs() + (b.b - a).abs() - (b.b - b.a).abs() < EPS;\n}\ninline bool intersect(const Segment &a, const Point &b){\n\treturn intersect(b, a);\n}\ninline bool intersect(const Segment &a, const Segment &b){\n\tif(ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) > 0){ return false; }\n\tif(ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) > 0){ return false; }\n\treturn true;\n}\n}\n}\nnamespace geom = libcomp::geometry;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tgeom::Segment a, b;\n\t\tcin >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n\t\tcin >> b.a.x >> b.a.y >> b.b.x >> b.b.y;\n\t\tcout << (geom::intersect(a, b) ? 1 : 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\t\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tPoint p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (doIntersect(p0, p1, p2, p3))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n    ll x,y;\n    Point(){ x = y = 0.0; }\n    Point(ll _x, ll _y) : x(_x), y(_y){}\n\n    Point operator+ (Point p)\n    {\n        return Point(p.x + x, p.y + y);\n    }\n\n    Point operator- (Point p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    ll operator* (Point p)\n    {\n        return p.x * x + p.y * y;\n    }\n\n    Point operator* (ll t)\n    {\n        return Point(x*t, y*t);\n    }\n\n    ll operator~ ()\n    {\n        return x * x + y * y;\n    }\n\n    ll operator% (Point p)\n    {\n        return x * p.y - y * p.x;\n    }\n\n};\n\nbool intersect(Point a, Point b, Point p, Point q)\n{\n    Point v1=(b-a);\n    Point v2=(q-p);\n    double t,t1;\n    if( v1 % v2 != 0 )\n    {\n        t = (double)(( p - a ) % v2) / (double)(v1 % v2);\n        t1 = (double)(( a - p ) % v1) / (double)(v2 % v1);\n        if( t >= 0.0 && t <= 1.0 && t1 >= 0.0 && t1 <= 1.0) return true;\n        else return false;\n    }\n    else\n    {\n        if( v1 % v2 == 0 && (p - a) % v1 == 0 )\n        {\n            t = (double)((p - a)*v1) /  (double)(v1*v1);\n            t1 = (double)((p+v2-a)*v1) / (double)(v1*v1);\n            //cout <<fixed << setprecision(6)<< t << \" \" << t1 << \" \" << v1*v2 << endl;\n            if( v1 * v2 < 0 )\n            {\n                if( t1 >= 0.0 && t <= 1.0 ) return true;\n            }\n            else\n            {\n                if( t >= 0.0 && t1 <= 1.0 ) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    Point p0,p1,p2,p3;\n    Point vec, vec1;\n    int q;\n    cin >> q;\n    while(q--)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << intersect(p0,p1,p2,p3) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(0,vec(a),vec(b))==0;}\nbool parallel(L a,L b) {return sdet(0,vec(a),vec(b))==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(0,vec(a),vec(b));\n\treturn (1-u)*a.s+u*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)) h=l.s;\n\tif(sdot(l.t,l.s,p)) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << iss(s1,s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-4)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\ndouble distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n//    return (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n//           (cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n    return (points_relation(a1, a2, b1) * points_relation(a1, a2, b2) <= 0 &&\n            points_relation(b1, b2, a1) * points_relation(b1, b2, a2) <= 0);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return res / 2;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\nvector<Point> circle_inter_line_points(Circle a, Line l) {\n    vector<Point> v;\n    Real d = line_dis(l, a.first);\n    if (d < a.second + EPS) {\n        Point x = a.second * unit_vector(l.second - l.first);\n        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n        else x = a.first + x * Point(0, 1);\n        if (d + EPS < a.second) {\n            Real y = sqrt(a.second * a.second - d * d);\n            if (d == 0) d += EPS;\n            Real s = args_bac(y, d, a.second);\n            v.push_back(rotate_vector(x, s));\n            v.push_back(rotate_vector(x, -s));\n        } else if (EQ(d, a.second)) {\n            v.push_back(x);\n        }\n    }\n    return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\nint main() {\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        bool ans = is_intersected_lines(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3));\n        if (ans) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate<class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\nusing P = Point<long long>;\n\ntemplate<class P>\nbool segmentIntersectionQ(P s1, P e1, P s2, P e2) {\n\tif (e1 == s1) {\n\t\tif (e2 == s2) return e1 == e2;\n\t\tswap(s1,s2); swap(e1,e2);\n\t}\n\tP v1 = e1-s1, v2 = e2-s2, d = s2-s1;\n\tauto a = v1.cross(v2), a1 = d.cross(v1), a2 = d.cross(v2);\n\tif (a == 0) { // parallel\n\t\tauto b1 = s1.dot(v1), c1 = e1.dot(v1),\n\t\t     b2 = s2.dot(v1), c2 = e2.dot(v1);\n\t\treturn !a1 && max(b1,min(b2,c2)) <= min(c1,max(b2,c2));\n\t}\n\tif (a < 0) { a = -a; a1 = -a1; a2 = -a2; }\n\treturn (0 <= a1 && a1 <= a && 0 <= a2 && a2 <= a);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\tint q;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++){\n\t\tP p0, p1;\n\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y;\n\t\tP p2, p3;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y;\n\t\tif(segmentIntersectionQ(p0, p1, p2, p3)){\n\t\t\tcout << 1 << '\\n';\n\t\t} else {\n\t\t\tcout << 0 << '\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n            if(x1>x2)swap(x1, x2);\n            if(y1>y2)swap(y1, y2);\n            \n            if(x1<=x3&&x3<=x2&&y1<=y3&&y3<=y2)return 1;\n            if(x1<=x4&&x4<=x2&&y1<=y4&&y4<=y2)return 1;\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\ntypedef complex<double> C;\ntypedef pair<C,C> pp;\ntypedef vector<C> VP;\n#define eq(a,b) (fabs(a-b)<eps)\n#define veq(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\nconst C O{0,0};\n\nvoid In(C& p){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp=C(x,y);\n}\n\nvoid Out(C p){\n\tcout<<p.real()<<' '<<p.imag()<<endl;\n}\n\ndouble Dot(C p,C q){\n\treturn p.real()*q.real()+p.imag()*q.imag();\n}\n\ndouble Det(C p,C q){\n\treturn p.real()*q.imag()-q.real()*p.imag();\n}\n\nC Normal(C p){\n\treturn C(p.imag(),-p.real());\n}\n\nbool Comp(C p,C q){\n\tif(eq(p.real(),q.real())) return p.imag()<q.imag();\n\treturn p.real()<q.real();\n}\n\nint Clock(C a,C b,C c){\n\tdouble t=Det(b-a,c-a);\n\tif(t>eps) return 1;\n\tif(t<-eps) return -1;\n\tif(Dot(b-a,c-a)<-eps) return 2;\n\tif(Dot(a-b,c-b)<-eps) return -2;\n\treturn 0;\n}\n\nbool is_Orthgonal(C a,C b,C c,C d){\n\treturn eq(Dot(a-b,c-d),0);\n}\n\nbool is_Parallel(C a,C b,C c,C d){\n\treturn eq(Det(a-b,c-d),0);\n}\n\nbool is_Cross(C a,C b,C c,C d){\n\tif(is_Parallel(a,b,c,d)){\n\t\tint A=Clock(a,b,c),B=Clock(a,b,d);\n\t\tif(A>B) swap(A,B);\n\t\tif(A==0||B==0||A==-2&&B==2) return 1;\n\t\treturn 0;\n\t}\n\treturn Clock(a,b,c)*Clock(a,b,d)<=0&&Clock(c,d,a)*Clock(c,d,b)<=0;\n}\n\nint n;\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tC a,b,c,d;\n\t\tIn(a);In(b);In(c);In(d);\n\t\tcout<<is_Cross(a,b,c,d)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif((xp2-xp0)*(xp2-xp1) <= 0 || (xp3-xp0)*(xp3-xp1) <= 0) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c (cw)\n *          a -> bで反時計方向に折れてb -> c (ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c (front)\n *          a -> bで逆を向いてb -> cまたは、b == c (on)\n */\nenum struct ffd {  // front face direciton\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t norm2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t norm(const vector_t& v)\n{\n    return std::sqrt(norm2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / abs2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline ffd ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return ffd::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return ffd::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return ffd::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(abs2(p1), norm2(p2)))      { return ffd::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return ffd::on;\n}\n\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\ncoord_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{  \n    return std::min(pi.x, pj.x) <= pk.x && pk.x <= std::max(pi.x, pj.x)\n        && std::min(pi.y, pj.y) <= pk.y && pk.y <= std::max(pi.y, pj.y);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    coord_t d1 = direction(p3, p4, p1);\n    coord_t d2 = direction(p3, p4, p2);\n    coord_t d3 = direction(p1, p2, p3);\n    coord_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\nconst double eps = 1e-10;\n#define EQ(a, b) (abs((a) - (b)) < eps)\nusing P = complex<double>;      // position\nstruct L : vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        emplace_back(a); emplace_back(b);\n    }\n};\ndouble dot(const P &a, const P &b) { return real(conj(a) * b); }\ndouble cross(const P &a, const P &b) { return imag(conj(a) * b); }\n\nenum CCW_RESULT { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return CCW;      // counter clockwise\n    if (cross(b, c) < -eps) return CW;      // clockwise\n    if (dot(b, c) < 0) return BEHIND;       // c--a--b on line\n    if (norm(b) < norm(c)) return FRONT;    // a--b--c on line | a=b\n    return ON;                              // on segment | a=c | b=c\n}\nbool isecSS(const L &s, const L &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n#include <iostream>\nint main() {\n    int q; cin >> q;\n    while (q--) {\n        vector<P> ps;\n        for (int i = 0; i < 4; i++) {\n            int x, y; cin >> x >> y;\n            ps.emplace_back(x, y);\n        }\n        cout << isecSS(L(ps[0], ps[1]), L(ps[2], ps[3])) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\ndouble abs(double x){\n\tif(x>0) return x;\n\telse return -x;\n}\n\nint main(void){\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tdouble o1 = (xp0+xp1)/2; double o2 = (xp2+xp3)/2; double o3 = (yp0+yp1)/2; double o4 = (yp2+yp3)/2;\n\t\tdouble r1 = (xp0-xp1)/2; double r2 = (xp2-xp3)/2; double r3 = (yp0-yp1)/2; double r4 = (yp2-yp3)/2;\n\t\tint ret = 0;\n\t\t// parallel\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif(abs(o1-o2) <= (r1+r2) && abs(o3-o4) <= (r3+r4)) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\ntypedef struct _PT {\n  double x, y;\n  _PT() {}\n  _PT(double x, double y) : x(x), y(y) {} \n  _PT operator + (_PT p){\n     return _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n     return _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (double d){\n     return _PT(d*x, d*y);\n  }\n\n  double norm(void){\n    return sqrt(x*x + y*y);\n  }\n\n  double twiceNorm(void){\n    return x*x + y*y;\n  }\n\n  double dist(_PT p){ //pとの距離の2乗\n     return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n     return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n     return x == e.x? (y > e.y) : x > e.x;\n  }\n\n  double dot(_PT p){ //pとの内積\n     return x * p.x + y * p.y;\n  }\n  \n  double det(_PT p){ // (x,p)の外積\n     return x * p.y - p.x * y;\n  }\n}P;\n\nP intersection(P p1,P p2,P q1,P q2) { //線分 p1-p2とq1-q2の交点\n  \treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool on_seq(P p1,P p2,P q) { // 線分p1-p2上に点qがあるか\n    return (abs((p1 - q).det(p2 - q)) < eps) && ((p1 - q).dot(p2 - q) < eps);\n}\n\nint main(void) {\n\tlong N;\n\tcin >> N;\n\tREP(i,N) {\n\t\tP p1,p2,q1,q2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> q1.x >> q1.y >> q2.x >> q2.y;\n\t\tif (abs((p1-p2).det(q1-q2)) > eps) {\n\t\t\tP r = intersection(p1,p2,q1,q2);\n\t\t\tif (on_seq(p1,p2,r) && on_seq(q1,q2,r)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t\telse cout << \"0\" << endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>0) return 1;\n\t\tif(Getmp<0) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpdd Ge1(Gex.first.x,Gey.first.x),Ge2(Gex.second.x,Gey.second.x);\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tif((min(Ge1.first,Ge2.first)<=Getmp.x&&Getmp.x<=max(Ge1.first,Ge2.first))&&(min(Ge1.second,Ge2.second)<=Getmp.x&&Getmp.x<=max(Ge1.second,Ge2.second))) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\ndouble x,xx,y,yy,xxx,yyy;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    double x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(double nx) {\n        x = nx;\n    }\n    \n    void setY(double ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    double cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (double f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (double f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(double sx, double sy, double ex, double ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        double c1 = l1.cross(l.getStart() - start);\n        double c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        double c3 = l2.cross(start - l.getStart());\n        double c4 = l2.cross(end - l.getStart());\n        \n        if (c1 * c2 == 0.0 && c3 * c4 == 0.0) { // 平行のとき\n            return 0;\n        } else if ((c1 * c2 < 0.0 && c3 * c4 <= 0.0)\n                   || (c1 * c2 <= 0.0 && c3 * c4 < 0.0)\n                   || (c1 * c2 < 0.0 && c3 * c4 < 0.0)) { // 交差するとき\n            return 1;\n        } else { // 交差しないとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        double sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 1;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -1;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  //if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n    if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n    if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n    if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n    return 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int q; cin >> q;\n    for(int i = 0;i<q;i++){\n        Line s1(input_point(),input_point()), s2(input_point(),input_point());\n        if(isis_ss(s1,s2)){\n            cout << 1 << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn isis_ls(s, t) && isis_ls(t, s);\n}\n\nint main()\n{\n\tint q;\n\tld x1, x2, x3, x4, y1, y2, y3, y4;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tLine l1 = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tLine l2 = { (Point) { x3, y3 }, (Point) { x4, y4 } };\n\t\tcout << isis_ss(l1, l2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) {a = _a, b = _b, v = b - a;}\n    L(double _ax, double _ay, double _bx, double _by) {\n        a = P(_ax, _ay), b = P(_bx, _by), v = b - a;\n    }\n};\n\nbool intersectSS(L l1, L l2) {\n    return (cross(l1.v, l2.a - l1.a) * cross(l1.v, l2.b - l1.a) <= 0 &&\n            cross(l2.v, l1.a - l2.a) * cross(l2.v, l1.b - l2.a) <= 0);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        double v[4][2];\n        rep(i, 4) rep(j, 2) cin >> v[i][j];\n        L l1(v[0][0], v[0][1], v[1][0], v[1][1]);\n        L l2(v[2][0], v[2][1], v[3][0], v[3][1]);\n        cout << intersectSS(l1, l2) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-10;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nclass Point\n{\npublic:\n  double x,y;\n  Point(double x,double y): x(x),y(y){}\n  Point operator + (const Point &p)\n  {\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)\n  {\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)\n  {\n    return Point(x*k,y*k);\n  }\n  Point operator / (double k)\n  {\n    return Point(x/k,y/k);\n  }\n  bool operator < (const Point &p) const\n  {\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n  bool operator == (const Point &p) const\n  {\n    return fabs(x-p.x)<eps && fabs(y-p.y) < eps;\n  }\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b)\n{\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a)\n{\n  return sqrt(norm(a));\n}\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1,Point p2): p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c,double r):  c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\n\nbool isorthogonal(Vector a,Vector b)\n{\n  return fabs(dot(a,b)-0.0)<eps;\n}\n\nbool isparallel(Vector a,Vector b)\n{\n  return fabs(cross(a,b)-0.0)<eps;\n}\nPoint project(Segment s,Point p)\n{\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return  s.p1 + base*r;\n}\nPoint reflect(Segment s,Point p)\n{\n  return p+ (project(s,p)-p)*2.0;\n}\ndouble getdistance(Point a,Point b)\n{\n  return abs(a-b);\n}\ndouble getdistanceLP(Line l,Point p)\n{\n  return abs(cross(l.p2-l.p1,p-l.p1) / abs(l.p2-l.p1));\n}\ndouble getdistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) <0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) <0.0) return abs(p-s.p2);\n  return getdistanceLP(s,p);\n}\nint ccw(Point p0,Point p1,Point p2)\n{\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps) return CLOCKWISE;\n  if(dot(a,b)<-eps) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1) * ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2)\n{\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nint main(int argc,char const* argv[])\n{\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++)\n    {\n      double p0x,p0y,p1x,p1y,p2x,p2y,p3x,p3y;\n      cin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n      Point p0=Point(p0x,p0y);\n      Point p1=Point(p1x,p1y);\n      Point p2=Point(p2x,p2y);\n      Point p3=Point(p3x,p3y);\n      Segment s0=Segment(p0,p1);\n      Segment s1=Segment(p2,p3);\n      if(intersect(s0,s1)) cout <<\"1\" << endl;\n      else cout << \"0\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(const Point &a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n    int _ccwise(const Point &rhs) const {\n        return ccwise(first, second, rhs);\n    }\n    bool intersects(const Line &rhs) {\n        if (abs(cross_prod(second-first, rhs.second-rhs.first)) > EPS)\n            // non parallel\n            return true;\n\n        // same line\n        return abs(cross_prod(second-first, rhs.first-first)) < EPS;\n    }\n    bool intersects(const Point &rhs) {\n        return abs(cross_prod(second-rhs, first-rhs)) < EPS;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n    int _ccwise(const Point &rhs) const {\n        return ccwise(first, second, rhs);\n    }\n    bool intersects(const Line &rhs) {\n        return (\n            cross_prod(rhs.second-rhs.first, first-rhs.first) *\n            cross_prod(rhs.second-rhs.first, second-rhs.first)\n        ) < EPS;\n    }\n    bool intersects(const LineSeg &rhs) {\n        if (_ccwise(rhs.first) * _ccwise(rhs.second) > 0)\n            return false;\n\n        return rhs._ccwise(first) * rhs._ccwise(second) <= 0;\n    }\n    bool intersects(const Point &rhs) {\n        return abs(first-rhs)+abs(second-rhs)-abs(second-first) < EPS;\n    }\n};\n\nint main() {\n    size_t q;\n    scanf(\"%zu\", &q);\n    for (size_t i=0; i<q; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        Point p0(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p1(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p2(x, y);\n\n        scanf(\"%lf %lf\", &x, &y);\n        Point p3(x, y);\n\n        LineSeg l(p0, p1), m(p2, p3);\n        printf(\"%d\\n\", l.intersects(m));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\n\tdouble a[8];\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>a[0]>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]>>a[7];\n\t\tdouble x,y,z,l,m,n,d,e,r,t;\n\t\tx=a[3]-a[1];\n\t\ty=a[0]-a[2];\n\t\tz=(x*a[0])+(y*a[1]);\n\t\t\n\t\tl=a[7]-a[5];\n\t\tm=a[4]-a[6];\n\t\tn=(l*a[4])+(m*a[5]);\n\t\t\n\t\td=((n*y)-(z*m))/((x*m)-(y*l));\n\t\te=((z*l)-(n*x))/((x*m)-(y*l));\n\t\t\n\t\tr=sqrt(pow((a[0]-d),2)+pow((a[1]-e),2));\n\t\tt=sqrt(pow((a[0]-a[2]),2)+pow((a[1]-a[3]),2));\n\t\t\n\t\tif(r<=t) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef ll T;\nint sgn(T x){return (x>0)-(x<0);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lld%lld\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n};\n\nstruct L{\n    P s,t;\n    L(){} L(P s,P t):s(s),t(t){}\n    void read(){s.read();t.read();}\n};\n\nbool isSS(L a,L b){\n    T c1=(a.t-a.s)^(b.s-a.s),c2=(a.t-a.s)^(b.t-a.s);\n    T c3=(b.t-b.s)^(a.s-b.s),c4=(b.t-b.s)^(a.t-b.s);\n    return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n        sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n        sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n        sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n        sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\n\nint main(){\n    int Q;scanf(\"%d\",&Q);\n    rep(i,0,Q){\n        L a,b;a.read();b.read();\n        printf(\"%d\\n\",isSS(a,b));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (numeric_limits<double>::epsilon())\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(const Point &p) const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator-(const Point &p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    Point operator*(const double &a) const\n    {\n        return Point(a * x, a * y);\n    }\n\n    Point operator/(const double &a) const\n    {\n        return Point(x / a, y / a);\n    }\n\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    double norm()\n    {\n        return x * x + y * y;\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const\n    {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\n\n\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b)\n{\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n    return equals(cross(a2 - a1, b2 - b1), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n    return equals(dot(a2 - a1, b2 - b1), 0.0);\n}\n\nPoint project(Segment s, Point p)\n{\n    Vector hypo = p - s.p1;\n    Vector base = s.p2 - s.p1;\n    return base * (dot(hypo, base) / base.norm()) + s.p1;\n}\n\nPoint reflect(Segment s, Point p)\n{\n    return (project(s, p) - p) * 2.0 + p;\n}\n\ndouble getDistance(Point a, Point b)\n{\n    return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n        return getDistance(p, s.p1);\n    else if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n        return getDistance(p, s.p2);\n    else\n        return getDistanceLP(s, p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > 0.0)\n        return COUNTER_CLOCKWISE;\n    else if (cross(a, b) < 0.0)\n        return CLOCKWISE;\n    else if (dot(a, b) < 0.0)\n        return ONLINE_BACK;\n    else if (a.norm() < b.norm())\n        return ONLINE_FRONT;\n    else\n        return ON_SEGMENT;\n}\n\nbool intersect(Point p0, Point p1, Point p2, Point p3)\n{\n    return ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0\n           && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\n\nint main()\n{\n    int query;\n    cin >> query;\n    Point p0, p1, p2, p3;\n    for (int q = 0; q < query; q++)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        if(intersect(p0, p1, p2, p3))\n            cout << \"1\" << endl;\n        else\n            cout << \"0\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define REP(i, lim) for(int i=0;i<lim;++i)\n#define REPP(i, lim) for(int i=1;i<=lim;++i)\n#define DEC(i, lim) for(int i=lim;i>=1;--i)\n#define FOR(i,l,r)  for(int i=l;i<r;++i)\n#define deBug cout<<\"===================================\"<<endl;\n#define clr(s) memset(s, 0, sizeof(s))\n#define lowclr(s) memset(s, -1, sizeof(s))\nconst int MAXN = 1000055;\nconst int inf = 0x3f3f3f3f;\nconst double pi = acos(-1.0);\nconst db eps = 1e-9;\n\ninline int sgn(db x) { return x<-eps ? -1 : x>eps; }\ninline db sqr(db x) { return x*x; }\n\n#define cross(p1, p2, p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1, p2, p3) sgn(cross(p1, p2, p3))\n\nstruct P {\n    // information\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    db x, y;\n    // operation\n    P operator + (P p)   const{ return P(x+p.x, y+p.y); }\n    P operator - (P p)   const{ return P(x-p.x, y-p.y); }\n    P operator * (db d)  const{ return P(x*d, y*d); }\n    P operator / (db d)  const{ return P(x/d, y/d); }\n    db dot(P p) { return x * p.x + y * p.y; } // 点积\n    db det(P p) { return x * p.y - y + p.x; } // 叉积\n    // other\n    void input() { scanf(\"%lf%lf\", &x, &y); }\n    void print() { printf(\"(%lf, %lf)\\n\", x, y); }\n    db dis(P p) { return sqrt(sqr(x-p.x) + sqr(y-p.y)); }\n    db dis2(P p) { return sqr(dis(p)); }\n    db abs() { return sqrt(x*x + y*y); }\n    db abs2(){ return x*x + y*y; }\n};\n\nP getProj(P a, P b, P p) { return a + (b-a) * ( (b-a).dot(p-a) / a.dis2(b) );}\nP getReflect(P a, P b, P p) { return getProj(a, b, p) * 2 - p; }\n\nbool chkLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return sgn(a1+a2) != 0;\n}\nP getLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nbool intersect(db l1, db r1, db l2, db r2) {\n    if(l1>r1) swap(l1, r1); if(l2>r2) swap(l2, r2);\n    return !( sgn(r1-l2) == -1 || sgn(r2-l1) == -1 );\n}\nbool chkSS(P p1, P p2, P q1, P q2) {\n    return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y) &&\n    crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 &&\n    crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <=0;\n}\nbool chkSS_strict(P p1, P p2, P q1, P q2) {\n    return crossOp(p1, p2, q2) * crossOp(p1, p2, q2) < 0 &&\n           crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;\n}\n\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n//    std::ios::sync_with_stdio(false); cin.tie(0);\n\n    int T;\n    scanf(\"%d\", &T);\n    while(T--)\n    {\n        P p1, p2, q1, q2;\n        p1.input(); p2.input(), q1.input(); q2.input();\n\n        cout<<chkSS(p1, p2, q1, q2)<<endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define each(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n#define pb push_back\n#define mp make_pair\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\ndouble SQ(double a){ return a * a; }\nbool EQ(double a, double b){ return abs(a - b) < EPS; }\nbool LT(double a, double b){ return a - b < -EPS; }\nbool LEQ(double a, double b){ return a - b < EPS; }\n\ndouble toRad(double t){ return t / 180 * PI; }\ndouble toDeg(double t){ return t * 180 / PI; }\n\ntypedef complex<double> Point;\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\tif (a.X != b.X) return a.X < b.X;\n\t\treturn a.Y < b.Y;\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point &a){\n\t\treturn os << a.X << \" \" << a.Y;\n\t}\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\ntypedef Line Segment;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\n\ndouble norm(Point p){ return SQ(p.X) + SQ(p.Y); }\n\ndouble dot(Point a, Point b){ return (conj(a) * b).X; }\ndouble cross(Point a, Point b){ return (conj(a) * b).Y; }\n\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool orthogonal(Line l1, Line l2){\n\treturn EQ(dot(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nbool parallel(Line l1, Line l2){\n\treturn EQ(cross(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nPoint project(Line l, Point p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(Line &l, Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nbool sameLine(Line l1, Line l2){\n\treturn abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)) < EPS;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn LEQ(abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(Line l1, Line l2){\n\treturn !parallel(l1, l2) || sameLine(l1, l2);\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1) < -EPS;\n}\n\nbool intersectSP(Segment s, Point p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\nbool intersectSS(Segment s1, Segment s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n\t\t&& ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\ndouble distanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(Line l1, Line l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(Segment s, Point p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\ndouble distanceSS(Segment s1, Segment s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\nPoint crossPointLL(Line l1, Line l2){\n\tassert(intersectLL(l1, l2));\n\tassert(!sameLine(l1, l2));\n\tPoint base = l2.p2 - l2.p1;\n\tdouble d1 = abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(Line l, Segment s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(Segment s1, Segment s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointLL(s1, s2);\n}\n\nenum {\n\tIN = 2,\n\tON = 1,\n\tOUT = 0,\n};\n\nint contains(const Polygon &g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y < EPS && EPS < b.Y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn x ? IN : OUT;\n}\n\nPolygon convexHull(Polygon &s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\t\n\tu.pb(s[0]); u.pb(s[1]);\n\tl.pb(s[s.size() - 1]); l.pb(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.pb(s[i]);\n\t}\n\t\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.pb(u[i]);\n\t\n\treturn l;\n}\n\nint main()\n{\n\tcout << fixed << setprecision(20);\n\t\n\tint n;\n\tcin >> n;\n\trep(i, n){\n\t\tSegment s[2];\n\t\trep(j, 2) cin >> s[j].p1 >> s[j].p2;\n\t\tcout << intersectSS(s[0], s[1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point c,point d,point a,point b){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); };\n};\nstruct line{\n  vec a, b;\n  vec getvec(){ return b - a; }\n  vec proj(vec p){\n    vec pa = p - a, ba = b - a;\n    double t = pa.dot(ba) / ba.dot(ba);\n    return a + ba.sca(t);\n  }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){\n    double res = abs(l.getvec().cross(getvec()));\n    return res < eps;\n  }\n  bool orth(line l){\n    double res = abs(l.getvec().dot(getvec()));\n    return res < eps;\n  }\n  bool intersec(line l){\n    bool res0 = ccw(l.a) * ccw(l.b) == 4; //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n};\n\nsigned main(void){\n  int i, j, k;\n  int(q);\n  for(;q--;){\n    line l, m;\n    cin >> l.a.x >> l.a.y >> l.b.x >> l.b.y >> m.a.x >> m.a.y >> m.b.x >> m.b.y;\n    puts(l.intersec(m) ? \"1\" : \"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-7;\nconst double INF = 1e12;\nstruct Vec {\n    double x,y;\n    Vec(){}\n    Vec(double x,double y){ this->x=x,this->y=y; }\n    void read(){ scanf(\"%lf%lf\",&x,&y); }\n    void prt() {printf(\"%.9f %.9f\\n\",x,y); }\n    double len(){ return sqrt(x*x+y*y); }\n    double len2(){ return x*x+y*y; }\n    \n    Vec operator+(const Vec&o)const{ return Vec(x+o.x,y+o.y); }\n    Vec operator-(const Vec&o)const{ return Vec(x-o.x,y-o.y); }\n    Vec operator*(const double&k)const{ return Vec(k*x,k*y); }\n    double operator*(const Vec&o)const {return x*o.x+y*o.y; }\n    double operator^(const Vec&o)const {return x*o.y-y*o.x; }\n    Vec rotate(double ang){ return Vec(x*cos(ang)-y*sin(ang), x*sin(ang)+y*cos(ang)); }\n    Vec change(double l){ if(len()<EPS) return *this; return (*this)*(l/len()); }\n    double disToLine(Vec A, Vec B) {\n        return abs((A-*this)^(B-*this))/(B-A).len();\n    }\n};\n\nVec Lineintersect(Vec A1,Vec A2,Vec B1,Vec B2) {\n    if (abs((A2-A1)^(B2-B1)) < EPS) return Vec(INF,INF);\n    return A1 + (A2 - A1) * (( ((A2-A1)^(B2-B1)) - ((A2-B1)^(B2-B1)) ) / ((A2-A1)^(B2-B1)) );\n}\n\nVec Segintersect(Vec A1,Vec A2,Vec B1,Vec B2) {\n    Vec P = Lineintersect(A1,A2,B1,B2);\n    //P.prt();\n    if ((P-A1)*(P-A2)<=0 && (P-B1)*(P-B2)<=0) return P; \n    return Vec(INF,INF);\n}\n\nbool onseg(Vec P,Vec A,Vec B){\n    if(P.disToLine(A,B) > EPS) return 0;\n    return (P-A)*(P-B) <= 0;\n}\n\nVec A,B,C,D; int q;\nint main(){\n    scanf(\"%d\",&q);\n    while(q--){\n        A.read(); B.read(); C.read(); D.read();\n        if(onseg(A,C,D) || onseg(B,C,D) || onseg(C,A,B) || onseg(D,A,B)) {\n            printf(\"1\\n\"); continue;\n        }\n\n        if (Segintersect(A,B,C,D).x == INF)\n            printf(\"0\\n\");\n        else \n            printf(\"1\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\tint\tp0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0;\n\tint n = 0;\n\tdouble u = 0, s = 0, t = 0;\n\n\tcin >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\t\tn = 0;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\t\t\n\t\tif (u != 0) {\n\t\t\ts = (double)((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = - (double)((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (p1x != 0) {\n\t\t\t\tif ((p1x - p2x) * (p1x - p3x) <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif ((p1y - p2y) * (p1y - p3y) <= 0)\n\t\t\t\t\tn = 1;\t\t\t\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint q;\n\tint ans[1000];\n\tint x0,x1,x2,x3,y0,y1,y2,y3;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tans[i]=0;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tdouble t=(y1-y0)/(x1-x0);\n\t\tdouble k=(y3-y2)/(x3-x2);\n\t\tdouble c=(t*x1+y1-k*x3+y3)/(t-k); //?????????x??§?¨?\n\t\tif((c>=x0&&c<=x1)||(c>=x1&&c<=x0)){\n\t\t\tans[i]=1;\n\t\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps (1e-10)\nusing namespace std;\nclass Point\n{\n\tpublic:\n\tdouble x,y;\n\tPoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y);} \n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);} \n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble ABS(){return sqrt(norm());} //俩点间的距离 \n};\nstruct Segment\n{\n\tPoint p1,p2;\t\n};\n\ndouble dot(Point a,Point b)//求内积 就是向量a*b \n{\n\treturn a.x*b.x+a.y*b.y;\n}\n//外积的值为a与b向量构成的平行四边形面积的值 \ndouble cross(Point a,Point b)//求外积 \n{\n\treturn a.x*b.y-a.y*b.x;\n} \n\n\n//判断是否正交 向量内积：a*b=|a||b|*cos(Y) 当cos为0时正交(90,-90垂直) \n//a*b=a.x*b.x+a.y*b.y;\nbool solve1(Point a,Point b)//是否正交 \n{\n\tdouble f=a.x*b.x+a.y*b.y; \n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n//判断是否平行  向量外积：|a*b|=|a||b|sin(Y) 当sin为0时平行(180,0平行)\n//|a*b|=|a|*|b|*sin(Y) \nbool solve2(Point a,Point b)//是否平行 \n{\n\tdouble f=a.x*b.y-a.y*b.x;\n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求 \n*/\nPoint solve3(Segment s,Point p)//求投影点 \n{\n\tPoint base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r; \n}\n/*\n求投影点x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线为对称轴与点p\n成线对称点为x \n通过求solve3的垂足延长一倍就可以求x \n*/\nPoint solve4(Segment s,Point p)//求映象 \n{\n\treturn p+(solve3(s,p)-p)*2.0;\n}\n\n/*\n点a与点b之间的距离等于向量a-b或b-a的绝对值。 \n*/ \ndouble getdis(Point a,Point b)//求俩点间的距离                    \n{\n\treturn (a-b).ABS();\n} \n\n/*\n设直线p1 p2上的向量为a=p2-p1,p与p1构成的向量b=p-p1\n则点p与直线p1p2的距离d就等于a,b构成的平行四边形的高\n用a与b外积的大小(平行四边形的面积)除以a的大小|a|即可求出高d\nd=|a*b|/|a|=|(p2-p1)*(p-p1)|/|p2-p1|; \n*/\n//注意：这里Segmet s是不规范的应该是 Line s 才对 \ndouble getdis_Li(Segment s,Point p)//点与直线的距离 \n{\n\treturn abs(cross(s.p2-s.p1,p-s.p1)/(s.p2-s.p1).ABS());\n}\n/*\nPoint a=p1-p0;\nPoint b=p2-p0;\n1.外积大小cross(a,b)为正时,可确定b在a的逆时针方向\n\tsin(Y)（Y在0-180）所以是正数\n2. 外积大小cross(a,b)为负时,可确定b在a的顺时针方向\n3.（1,2）不符合 表示p2在直线p0p1上(注意是直线),cos(Y)大于90或小于-90\n\t度时为负，因此a与b的内积dot(a,b)负时，可确定p2位于线段p0p1后方\n\t即p2->p0->p1\n4.不是3时，有俩种p0->p1-p2或者p0->p2->p1如果b的大小大于a的大小，即为\n\tp0->p1->p2;\n5.不符合4，可以确定p2位于线段p0p1上 \n*/ \nint ccw(Point p0,Point p1,Point p2)//判断三个点相对位置 \n{\n\tPoint a=p1-p0;\n\tPoint b=p2-p0;\n\tif(cross(a,b)>eps) return 1;//p0,p1,p2成逆时针方向 \n\tif(cross(a,b)<-eps) return -1;//p0,p1,p2成顺时针方向 \n\tif(dot(a,b)<-eps) return 2;//p2 p0 p1一次排列在同一直线上 \n\tif(a.norm()<b.norm()) return -2;// p0 p1 p2一次排列在同一直线上 \n\treturn 0;//p2在线段p0p1上 \n\t\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nint main()\n{\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tif(intersect(p0,p1,p2,p3)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef double db;\ndb eps=1e-9;\nstruct point {\n\tdb x,y;\n\tpoint() {}\n\tpoint(db x,db y):x(x),y(y) {}\n\tvoid input() { scanf(\"%lf%lf\",&x,&y); }\n\tvoid output() { printf(\"%.10f %.10f\\n\",x,y); }\n\tdb len() { return sqrt(x*x+y*y); }\n\tdb len2() { return x*x+y*y; }\n};\npoint operator + (const point &a,const point &b) { return point(a.x+b.x,a.y+b.y);}\npoint operator - (const point &a,const point &b) { return point(a.x-b.x,a.y-b.y);}\npoint operator * (const point &a,const db &b) { return point(a.x*b,a.y*b);}\npoint operator / (const point &a,const db &b) { return point(a.x/b,a.y/b);}\ndb dot(const point &a,const point &b) { return a.x*b.x+a.y*b.y; }\ndb det(const point &a,const point &b) { return a.x*b.y-a.y*b.x; }\nstruct line {\n\tpoint a,b;\n\tline() {}\n\tline(point a,point b):a(a),b(b) {}\n};\npoint proj(const line &a,const point &b) {\n\treturn a.a+(a.b-a.a)*dot(a.b-a.a,b-a.a)/(a.b-a.a).len2();\n}\npoint reflect(const line &a,const point &b) {\n\treturn proj(a,b)*2-b;\n}\nint sign(db x) {\n\treturn fabs(x)<eps?0:(x>0?1:-1);\n}\nint relation(const line &a,const point &b) {\n\tint x=sign(det(a.b-a.a,b-a.a));\n\tif (x==1) return 0; // COUNTER_CLOCKWISE ?????¶???\n\telse if (x==-1) return 1; // CLOCKWISE ?????¶???\n\telse {\n\t\tx=sign(dot(b-a.a,a.b-a.a));\n\t\tif (x==-1) return 2; // ONLINE_BACK\n\t\telse {\n\t\t\tx=sign(dot(b-a.b,a.b-a.a));\n\t\t\tif (x==1) return 3; // ONLINE_FRONT\n\t\t\telse return 4; // ON_SEGMENT\n\t\t}\n\t}\n}\nbool parallel(const line &a,const line &b) { return sign(det(a.a-a.b,b.a-b.b))==0;}\nbool ismiddle(const line &a,const point &b) {\n\treturn sign(dot(b-a.a,a.b-a.a))>=0&&sign(dot(b-a.b,a.b-a.a))<=0;\n}\nint segcrossseg(const line &a, const line &b) {\n\tif (sign(min(b.a.x,b.b.x)-max(a.a.x,a.b.x))==1) return 0;\n\tif (sign(max(b.a.x,b.b.x)-min(a.a.x,a.b.x))==-1) return 0;\n\tif (sign(min(b.a.y,b.b.y)-max(a.a.y,a.b.y))==1) return 0;\n\tif (sign(max(b.a.y,b.b.y)-min(a.a.y,a.b.y))==-1) return 0;\n\tint d1=sign(det(a.b-a.a,b.a-a.a))*sign(det(a.b-a.a,b.b-a.a));\n\tint d2=sign(det(b.b-b.a,a.a-b.a))*sign(det(b.b-b.a,a.b-b.a));\n\tif (d1==-1&&d2==-1) return 2; // ?§??????????\n\telse if (d1<=0&&d2<=0) return 1; // ????§??????????\n\telse return 0; // ?????????\n}\npoint crosspoint(const line &a,const line &b) {\n\tdouble a1=det(b.b-b.a,a.a-b.a),a2=det(b.b-b.a,a.b-b.a);\n\treturn a.a*(a2/(a2-a1))-a.b*(a1/(a2-a1));\n}\n\nint q;\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,0,q) {\n\t\tpoint p1,p2,q1,q2;\n\t\tp1.input(); p2.input(); q1.input(); q2.input();\n\t\tcrosspoint(line(p1,p2),line(q1,q2)).output();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n\n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <http://unlicense.org>\n\n#include <algorithm>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef long double Real;\ntypedef complex<Real> Point;\nstruct Line {\n  Point a, b;\n  bool operator<(const Line &line) const;\n};\ntypedef vector<Point> Polygon;\n\nconstexpr Real PI = acos(Real(-1));\n\n// 比較関数\nint sgn(const Real &a, const Real &b = 0) {\n  constexpr Real EPS = 1e-8;\n  return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;\n}\n\nbool near(const Point &a, const Point &b) { return !sgn(norm(a - b)); }\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return sgn(a.X, b.X) ? a.X < b.X : a.Y < b.Y;\n}\n} // namespace std\n\nbool Line::operator<(const Line &line) const {\n  return !near(a, line.a) ? a < line.a : b < line.b;\n}\n\n// 平方根\nReal sr(const Real &a) { return sqrt(max<Real>(a, 0)); }\n\n// 内積\nReal dot(const Point &a, const Point &b) { return a.X * b.X + a.Y * b.Y; }\n// 外積\nReal det(const Point &a, const Point &b) { return a.X * b.Y - a.Y * b.X; }\n\n// 線分のベクトル\nPoint vec(const Line &a) { return a.b - a.a; }\n\n// 線分abに対する点cの位置\nenum CCW { FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16 };\nint ccw(const Point &a, const Point &b, const Point &c) {\n  if (near(a, c) || near(b, c)) {\n    return ON;\n  }\n  int s = sgn(det(b - a, c - a));\n  if (s) {\n    return s > 0 ? LEFT : RIGHT;\n  }\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\nint ccw(const Line &l, const Point &p) { return ccw(l.a, l.b, p); }\n\n// 有向角度\nReal arg(const Point &base, const Point &a, const Point &b) {\n  return arg((b - base) / (a - base));\n}\n\nLine sortBase;\nbool lessArg(const Point &a, const Point &b) {\n  Real ang1 = arg(sortBase.a, sortBase.b, a);\n  Real ang2 = arg(sortBase.a, sortBase.b, b);\n  return sgn(ang1, ang2) ? ang1 < ang2 : norm(a) > norm(b);\n}\n\n// 射影\nPoint proj(const Line &l, const Point &p) {\n  auto v = vec(l);\n  return l.a + ((p - l.a) / v).X * v;\n}\nPoint refl(const Line &l, const Point &p) {\n  auto v = vec(l);\n  return l.a + conj((p - l.a) / v) * v;\n}\n\n// 交差判定\nbool eqL(const Line &a, const Line &b) {\n  return !sgn(det(vec(a), vec(b))) && !sgn(det(vec(a), b.a - a.a));\n}\nbool iLL(const Line &a, const Line &b) {\n  return sgn(det(vec(a), vec(b))) || !sgn(det(vec(a), b.a - a.a));\n}\nbool iLLs(const Line &a, const Line &b) { return sgn(det(vec(a), vec(b))); }\nbool iLS(const Line &a, const Line &b) {\n  return sgn(det(vec(a), b.a - a.a)) * sgn(det(vec(a), b.b - a.a)) <= 0;\n}\nbool iLSs(const Line &a, const Line &b) {\n  return sgn(det(vec(a), b.a - a.a)) * sgn(det(vec(a), b.b - a.a)) < 0;\n}\nbool iSS(const Line &a, const Line &b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nbool iSSs(const Line &a, const Line &b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 交点\nPoint pLL(const Line &a, const Line &b) {\n  return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));\n}\n\n// 距離\nReal dLP(const Line &l, const Point &p) {\n  return abs(det(vec(l), p - l.a) / vec(l));\n}\nReal dSP(const Line &s, const Point &p) {\n  if (dot(vec(s), p - s.a) < 0) {\n    return abs(p - s.a);\n  }\n  if (dot(vec(s), p - s.b) > 0) {\n    return abs(p - s.b);\n  }\n  return dLP(s, p);\n}\nReal dLL(const Line &a, const Line &b) {\n  if (iLL(a, b)) {\n    return 0;\n  }\n  return dLP(a, b.a);\n}\nReal dLS(const Line &a, const Line &b) {\n  if (iLS(a, b)) {\n    return 0;\n  }\n  return min(dLP(a, b.a), dLP(a, b.b));\n}\nReal dSS(const Line &a, const Line &b) {\n  if (iSS(a, b)) {\n    return 0;\n  }\n  return min({dSP(a, b.a), dSP(a, b.b), dSP(b, a.a), dSP(b, a.b)});\n}\n\n// 円\nstruct Circle {\n  Point c;\n  Real r;\n};\n\n// 交差判定\nbool iCP(const Circle &c, const Point &p) {\n  return sgn(abs(p - c.c), c.r) <= 0;\n}\nbool iCL(const Circle &c, const Line &l) { return sgn(c.r, dLP(l, c.c)) >= 0; }\nbool iCS(const Circle &c, const Line &s) { return sgn(c.r, dSP(s, c.c)) >= 0; }\nbool iCSc(const Circle &c, const Line &s) {\n  return iCS(c, s) && sgn(c.r, max(abs(s.a - c.c), abs(s.b - c.c))) >= 0;\n}\nbool iCC(const Circle &a, const Circle &b) {\n  return sgn(abs(a.c - b.c), a.r + b.r) <= 0;\n}\nbool iCCc(const Circle &a, const Circle &b) {\n  return iCC(a, b) && sgn(abs(a.c - b.c), abs(a.r - b.r)) >= 0;\n}\n\n// 交点\npair<Point, Point> pCC(const Circle &a, const Circle &b) {\n  Real x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  Point e = (b.c - a.c) / abs(b.c - a.c);\n  Point y = e * Point(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<Point, Point> pCL(const Circle &c, const Line &l) {\n  Point x = proj(l, c.c);\n  Point y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(const Point &a, const Point &b, const Point &c) {\n  return sgn(det(a, c)) - sgn(det(b, c)) - sgn(det(a, b));\n}\n\n// 多角形の面積\nReal aPol(const Polygon &vp) {\n  Real res = 0;\n  for (int i = 0; i < int(vp.size()); ++i) {\n    res += det(vp[i], vp[(i + 1) % vp.size()]);\n  }\n  return res / 2;\n}\n\n// 多角形の内外判定 内部:1、周上:0、外部:-1\nint sGP(const Polygon &pol, const Point &p) {\n  int side = -1;\n  for (int i = 0; i < int(pol.size()); ++i) {\n    Point p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (ccw(p0, p1, 0) == ON) {\n      return 0;\n    }\n    if (p0.Y > p1.Y) {\n      swap(p0, p1);\n    }\n    if (sgn(p0.Y) <= 0 && 0 < sgn(p1.Y) && sgn(det(p0, p1)) > 0) {\n      side *= -1;\n    }\n  }\n  return side;\n}\n\n// 凸包\nPolygon convexHull(vector<Point> p) {\n  int m = -1, n = p.size();\n  if (n < 3) {\n    return p;\n  }\n  vector<Point> q(n * 2);\n  sort(p.begin(), p.end());\n  for (int i = 0; i < n; q[++m] = p[i++]) {\n    for (; m > 0 && ccw(q[m - 1], q[m], p[i]) != LEFT; --m) {\n      ;\n    }\n  }\n  for (int i = n - 2, r = m; i >= 0; q[++m] = p[i--]) {\n    for (; m > r && ccw(q[m - 1], q[m], p[i]) != LEFT; --m) {\n      ;\n    }\n  }\n  q.resize(m);\n  return q;\n}\n\n// 凸多角形切断\nPolygon convexCut(const Polygon &p, const Line &l) {\n  vector<Point> q;\n  for (int i = 0; i < int(p.size()); ++i) {\n    if (ccw(l.a, l.b, p[i]) != RIGHT) {\n      q.push_back(p[i]);\n    }\n    Line s = {p[i], p[(i + 1) % p.size()]};\n    if (iLSs(l, s)) {\n      q.push_back(pLL(l, s));\n    }\n  }\n  return q;\n}\n\n// 線分をマージする\nvector<Line> merge(vector<Line> s) {\n  for (int i = 0; i < int(s.size()); ++i) {\n    if (s[i].b < s[i].a) {\n      swap(s[i].a, s[i].b);\n    }\n  }\n  sort(s.begin(), s.end());\n  for (int i = 0; i < int(s.size()); ++i) {\n    for (int j = 0; j < i; ++j) {\n      if (iSS(s[i], s[j]) && !iLLs(s[i], s[j])) {\n        s[j].b = max(s[i].b, s[j].b);\n        s.erase(s.begin() + i--);\n        break;\n      }\n    }\n  }\n  return s;\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\nvector<vector<int>> sArr(vector<Line> s, vector<Point> &vp) {\n  s = merge(s);\n  for (int i = 0; i < int(s.size()); ++i) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  for (int i = 0; i < int(s.size()); ++i) {\n    for (int j = 0; j < i; ++j) {\n      if (iSS(s[i], s[j])) {\n        vp.push_back(pLL(s[i], s[j]));\n      }\n    }\n  }\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int>> graph(vp.size());\n  for (int i = 0; i < int(s.size()); ++i) {\n    vector<pair<Real, int>> v;\n    for (int j = 0; j < int(vp.size()); ++j) {\n      if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n        v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n      }\n    }\n    sort(v.begin(), v.end());\n    for (int j = 0; j < int(v.size()) - 1; ++j) {\n      graph[v[j + 1].second].push_back(v[j].second);\n      graph[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return graph;\n}\n\n#include <iomanip>\n#include <iostream>\n\nint main() {\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    Real p1x, p1y, p2x, p2y;\n    cin >> p1x >> p1y >> p2x >> p2y;\n    Line line1{Point(p1x, p1y), Point(p2x, p2y)};\n    Real p3x, p3y, p4x, p4y;\n    cin >> p3x >> p3y >> p4x >> p4y;\n    Line line2{Point(p3x, p3y), Point(p4x, p4y)};\n    if (iSS(line1, line2)) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <array>\n#include <vector>\n#include <cmath>\n\nconst double EPSILON = 1e-10;\n\ninline bool equals(double a, double b) {\n    return std::fabs(a - b) < EPSILON;\n}\n\nstruct Point {\n    double x;\n    double y;\n\n    bool operator < (const Point& p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point& p) const {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\nPoint operator + (const Point& p1, const Point& p2) {\n    return Point{p1.x + p2.x, p1.y + p2.y};\n}\n\nPoint operator - (const Point& p1, const Point& p2) {\n    return Point{p1.x - p2.x, p1.y - p2.y};\n}\n\nPoint operator * (const Point& p1, double k) {\n    return Point{p1.x * k, p1.y * k};\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nusing Vector = Point;\nusing Line = Segment;\nusing Polygon = std::vector<Point>;\n\n\ndouble norm(const Vector& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const Vector& p) {\n    return std::sqrt(norm(p));\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nVector projection(const Segment& s, const Point& p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nVector reflection(const Segment& s, const Point& p) {\n    auto proj = projection(s, p);\n    return p + (projection(s, p) - p) * 2.0;\n}\n\nbool is_orthogonal(const Vector& a, const Vector& b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool is_orthogonal(const Segment& s1, const Segment& s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool is_parallel(const Vector& a, const Vector& b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool is_parallel(const Segment& s1, const Segment& s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0,\n};\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n    if (cross(a, b) > EPSILON) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPSILON) return CLOCKWISE;\n    if (dot(a, b) < -EPSILON) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return abs(a - b);\n}\n\ndouble distanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s, p);\n}\n\ndouble distance(const Segment& s1, const Segment& s2) {\n    using std::min;\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n               min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n}\n\n\nint main() {\n    using namespace std;\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        array<Point, 4> points;\n        for (auto& p : points) {\n            cin >> p.x >> p.y;\n        }\n        Segment s1{points[0], points[1]};\n        Segment s2{points[2], points[3]};\n        cout << intersect(s1, s2) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c)+eps)return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n    \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(s1.real()*s2.imag()==s1.imag()*s2.real())\n      cout<<\"0\"<<endl;\n    else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif(((p2-p0).dot(p2-p1)<=0)||((p3-p0).dot(p3-p1)<=0) || ((p1-p2).dot(p0-p2)<=0)){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,first,last) for(int i=first;i<=last;++i)\n#define DOW(i,first,last) for(int i=first;i>=last;--i)\nusing namespace std;\ninline int Read()\n{\n\tint x(0),f(1);\n\tchar c(getchar());\n\twhile(c<'0'||'9'<c)\n\t{\n\t\tif(c=='-')\n\t\t{\n\t\t\tf=-1;\n\t\t}\n\t\tc=getchar();\n\t}\n\twhile('0'<=c&&c<='9')\n\t{\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nvoid Write(int x)\n{\n\tif(x<0)\n\t{\n\t\tprintf(\"-\");\n\t\tx=-x;\n\t}\n\tif(9<x)\n\t{\n\t\tWrite(x/10);\n\t}\n\tputchar(x%10+'0');\n}\ninline void Writeln(int x)\n{\n\tWrite(x);\n\tputs(\"\");\n}\nstruct Point\n{\n\tdouble x,y;\n\tPoint(double fx=0,double fy=0)\n\t{\n\t\tx=fx;\n\t\ty=fy;\n\t}\n\tvoid Read()\n\t{\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid Write(int len=2)\n\t{\n\t\tprintf(\"%.9lf %.9lf\",x,y);\n\t}\n\tdouble operator ^(Point const b)const\n\t{\n\t\treturn x*b.x+y*b.y;\n\t}\n\tdouble operator |(Point const b)const\n\t{\n\t\treturn x*b.y-b.x*y;\n\t}\n\tdouble operator ==(Point const b)const\n\t{\n\t\treturn sqrt((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y));\n\t}\n\tPoint operator *(double const b)const\n\t{\n\t\treturn Point(x*b,y*b);\n\t}\n\tPoint operator +(Point const b)const\n\t{\n\t\treturn Point(x+b.x,y+b.y);\n\t}\n\tPoint operator -(Point const b)const\n\t{\n\t\treturn Point(x-b.x,y-b.y);\n\t}\n};\nPoint Symmetrical(Point a,Point m=Point(0,0))\n{\n\treturn Point(m.x*2-a.x,m.y*2-a.y);\n}\n/**\n *      /\n *   a /\n *    m\n *   / b\n * return b;\n */\nstruct Vector\n{\n\tPoint a,b;\n\tVector(Point f=Point(0,0),Point e=Point(0,0))\n\t{\n\t\ta=f;\n\t\tb=e;\n\t}\n\tdouble operator ^(Vector const c)const\n\t{\n\t\treturn (a.x-b.x)*(c.a.x-c.b.x)+(c.a.y-c.b.y)*(a.y-b.y);\n\t}\n\tdouble operator |(Vector const c)const\n\t{\n\t\treturn (a.x-b.x)*(c.a.y-c.b.y)-(c.a.x-c.b.x)*(a.y-b.y);\n\t}\n};\nbool InRectangle(Point a,Point b,Point c)\n{\n\treturn\n\tmin(b.x,c.x)<=a.x&&a.x<=max(b.x,c.x)\n\t&&\n\tmin(b.y,c.y)<=a.y&&a.y<=max(b.y,c.y);\n}\n/**\n *   a\n *  b---*\n *  |   |\n *  *---c\n *  return 0;\n *\n *  b---*\n *  |a  |\n *  *---c\n *  return 1;\n */\nbool RectangleIntersection(Point a0,Point a1,Point b0,Point b1)\n{\n\tint zx=fabs(a0.x+a1.x-b0.x-b1.x);\n\tint zy=fabs(a0.y+a1.y-b0.y-b1.y);\n\tint x=fabs(a0.x-a1.x)+fabs(b0.x-b1.x);\n\tint y=fabs(a0.y-a1.y)+fabs(b0.y-b1.y);\n\tif(zx<=x&&zy<=y)\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n/**\n *  *---*\n *  |   |\n *  *---*\n *\n *    *--*\n *    |  |\n *    |  |\n *    *--*\n * return 0;\n *\n *  *---*\n *  | *-+*\n *  *-+-*|\n *    |  |\n *    *--*\n * return 1;\n */\nbool Intersect(Vector a,Vector b)\n{\n\tdouble a_aa=a|Vector(a.a,b.a);\n\tdouble a_ab=a|Vector(a.a,b.b);\n\tdouble b_aa=b|Vector(b.a,a.a);\n\tdouble b_ab=b|Vector(b.a,a.b);\n\tif(\n\t\t(\n\t\t\ta_aa==0\n\t\t\t||\n\t\t\ta_ab==0\n\t\t\t||\n\t\t\t((a_aa<0)^(a_ab<0))\n\t\t)\n\t\t&&\n\t\t(\n\t\t\tb_aa==0\n\t\t\t||\n\t\t\tb_ab==0\n\t\t\t||\n\t\t\t((b_aa<0)^(b_ab<0))\n\t\t)\n\t)\n\t{\n\t\treturn RectangleIntersection(a.a,a.b,b.a,b.b);\n\t}\n\treturn 0;\n}\n/**\n * \\  /\n *   /\n *  /  \\\n * /    \\\n * return 0;\n *\n *    /\n *  \\/\n *  /\\\n * /  \\\n * return 1;\n */\nPoint p0,p1,p2,p3;\nconst int MAXN=1e5+5;\nvoid Work()\n{\n\tp0.Read();\n\tp1.Read();\n\tp2.Read();\n\tp3.Read();\n\tprintf(\"%d\\n\",Intersect(Vector(p0,p1),Vector(p2,p3)));\n}\nint main()\n{\n\tint q;\n\tscanf(\"%d\",&q);\n\tREP(i,1,q)\n\t{\n\t\tWork();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n        if ((z2 * conj(z1)).imag() * (z3 * conj(z1)).imag() > 0\n            || (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() > 0)\n            cout << \"1\\n\";\n        else cout << \"0\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <complex>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\ntypedef double coordinate_t;\n\nstruct coordinate {\n  coordinate_t x, y;\n  bool operator<(const coordinate & another) const {\n    return x != another.x ? x < another.x : y < another.y;\n  }\n};\n\nstruct line {\n  coordinate_t a, b, c;\n  coordinate p, q;\n};\n\n// is p in [l.x, r.x] * [l.y, r.y] ?\nbool in_section(coordinate p, coordinate l, coordinate r) {\n  coordinate_t lx, ly, rx, ry;\n  lx = min(l.x, r.x);\n  rx = max(l.x, r.x);\n  ly = min(l.y, r.y);\n  ry = max(l.y, r.y);\n  if (lx <= p.x && p.x <= rx && ly <= p.y && p.y <= ry) return true;\n  else return false;\n}\n\n// the intersections of 2 lines\ncoordinate cross_of_2_lines(line k, line l) {\n  coordinate_t dn = l.a * k.b - k.a * l.b;\n  if (dn == 0) return{ NAN, NAN };\n  else {\n    coordinate ret;\n    ret.x = (l.b * k.c - k.b * l.c) / dn;\n    ret.y = (k.a * l.c - l.a * k.c) / dn;\n    if (in_section(ret, k.p, k.q) && in_section(ret, l.p, l.q)) return ret;\n    else return{ NAN, NAN };\n  }\n}\n\n\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (!isnan(p.x )&& !isnan(p.y)) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n\n// the line through 2 coordinates\nline line_through_2_coordinates(coordinate p, coordinate q) {\n  if (p.x == q.x && p.y == q.y) return{ NAN, NAN, NAN, p, q };\n  else {\n    if (p.x == q.x) {\n      if (p.y < q.y) return { 1, 0, -p.x, p, q };\n      else return{ 1, 0, -p.x, q, p };\n    }\n    else {\n      if (p.x < q.x) return { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, p, q };\n      else return{ (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, q, p };\n    }\n  }\n}\n\n\n\nint main() {\n  int q; cin >> q;\n  cout << setprecision(18);\n  Loop(i, q) {\n    coordinate p, q;\n    line s, t;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    s = line_through_2_coordinates(p, q);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    t = line_through_2_coordinates(p, q);\n    coordinate r = cross_of_2_lines(s, t);\n    if (isnan(r.x)) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <string>\n\n#define ll long long\n#define Int ll\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define EPS 0.000000001\n#define fequals(a,b) (fabs((a) - (b)) < EPS)\n\nclass Vector2 {\npublic:\n  double x, y;\n  \n  Vector2(double x = 0, double y = 0): x(x), y(y) {}\n  \n  Vector2 operator + (const Vector2 v) const { return Vector2(x + v.x, y + v.y); }\n  Vector2 operator - (const Vector2 v) const { return Vector2(x - v.x, y - v.y); }\n  Vector2 operator * (const double k) const { return Vector2(x * k, y * k); }\n  Vector2 operator / (const double k) const { return Vector2(x / k, y / k); }\n  \n  double length() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n  double dot (Vector2 const v) { return x * v.x + y * v.y; }\n  double cross (Vector2 const v) { return x * v.y - y * v.x; }\n  \n  bool parallel(Vector2 &other) {\n    return fequals(fabs(dot(other)), length() * other.length());\n  }\n  \n  bool orthogonal(Vector2 &other) {\n    return fequals(0, dot(other));\n  }\n  \n  bool operator < (const Vector2 &v) {\n    return x != v.x ? x < v.x : y < v.y;\n  }\n  \n  bool operator == (const Vector2 &v) {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n};\n\nostream & operator << (ostream & out, Vector2 const & v) { \n  out<< \"Vector2(\" << v.x << \", \" << v.y << ')';\n  return out;\n}\n\nistream & operator >> (istream & in, Vector2 & v) { \n  double x, y;\n  in >> x;\n  in >> y;\n  v.x = x;\n  v.y = y;\n  return in;\n}\n\nInt N;\nVector2 p0, p1, p2, p3;\n\nint cw(Vector2 v01, Vector2 v02) {\n  double cross_ = v01.cross(v02);\n  if (cross_ > EPS) return 1;\n  else if (cross_ < -EPS) return -1;\n  if (v01.dot(v02) < 0) return 2;\n  if (v01.length() - v02.length() >= 0) return 0;\n  return -2;\n}\n\nvoid solve() {\n  int cw1 = cw(p1 - p0, p2 - p0) * cw(p1 - p0, p3 - p0);\n  int cw2 = cw(p3 - p2, p1 - p2) * cw(p3 - p2, p0 - p2);\n  if (cw1 <= 0 && cw2 <= 0) cout << 1 << endl;\n  else cout << 0 << endl;\n}\n\nvoid input() {\n  cin >> N;\n  while (cin >> p0 >> p1 >> p2 >> p3) {\n    solve();\n  }\n}\n\nint main() {\n  cout.precision(15);\n  input();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nclass Point{\npublic:\n\tPoint(const int argx = 0, const int argy = 0):x(argx),y(argy){};\n\tint x, y;\n};\nclass Line{\npublic:\n\tLine(const int x1, const int y1, const int x2, const int y2):p1(x1, y1),p2(x2, y2),X(x1 - x2),Y(y1 - y2){\n\t\tif (x1 > x2){\n\t\t\tmaxx = (x1);\n\t\t\tminx = (x2);\n\t\t}else{\n\t\t\tmaxx = (x2);\n\t\t\tminx = (x1);\n\t\t}\n\t\tif (y1 > y2){\n\t\t\tmaxy = (y1);\n\t\t\tminy = (y2);\n\t\t}else{\n\t\t\tmaxy = (y2);\n\t\t\tminy = (y1);\n\t\t}\n\t};\n\tbool is_parallel(const Line &other) const {\n\t\treturn (X * other.Y) == (Y * other.X);\n\t}\n\tbool is_over_x(const Line &other) const {\n\t\treturn (X * X + other.X * other.X > (maxx - other.maxx) * (maxx - other.maxx) + (minx - other.minx) * (minx - other.minx));\n\t}\n\tbool is_over_y(const Line &other) const {\n\t\treturn (Y * Y + other.Y * other.Y > (maxy - other.maxy) * (maxy - other.maxy) + (miny - other.miny) * (miny - other.miny));\n\t}\n\tint get_Xy(const int &other_x) const {return (Y * other_x + (X * p2.y - Y * p2.x));}\n\tint get_Yx(const int &other_y) const {return (X * other_y + (Y * p2.x - X * p2.y));}\n\tbool is_cross_x(const Line &other) const {\n\t\treturn (other.X * p1.y - other.get_Xy(p1.x)) * (other.X * p2.y - other.get_Xy(p2.x)) <= 0;\n\t}\n\tbool is_cross_y(const Line &other) const {\n\t\treturn (other.Y * p1.x - other.get_Yx(p1.y)) * (other.Y * p2.x - other.get_Yx(p2.y)) <= 0;\n\t}\n\tbool is_intersection(const Line &other) const {\n\t\tif (is_parallel(other) and X * Y == 0){\n\t\t\tif (X == 0){\n\t\t\t\treturn is_over_y(other);\n\t\t\t}else{\n\t\t\t\treturn is_over_x(other);\n\t\t\t}\n\t\t}else{\n\t\t\tif (Y == 0 or other.Y == 0){\n\t\t\t\treturn is_cross_x(other) and other.is_cross_x((*this));\n\t\t\t}else{\n\t\t\t\treturn is_cross_y(other) and other.is_cross_y((*this));\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\tPoint p1, p2;\n\tint X, Y, maxx, maxy, minx, miny;\n\tint x_diff() const {if (X < 0){return -X;}else{return X;}}\n\tint y_diff() const {if (Y < 0){return -Y;}else{return Y;}}\n};\nint main(){\n\tint q;\n\tstd::scanf(\"%d\", &q);\n\tfor (auto i = 0; i < q; ++i){\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tstd::scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tLine l1(x0, y0, x1, y1), l2(x2, y2, x3, y3);\n\t\tif (l1.is_intersection(l2)){\n\t\t\tstd::printf(\"1\\n\");\n\t\t}else{\n\t\t\tstd::printf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/numeric/interval.hpp>\n#include <boost/numeric/interval/io.hpp>\n#include <boost/geometry.hpp>\n#include <boost/geometry/geometries/linestring.hpp>\n#include <boost/geometry/geometries/polygon.hpp>\n#include <boost/geometry/geometries/point_xy.hpp>\n#include <boost/assign/list_of.hpp>\nusing namespace::std;\nnamespace mp = boost::multiprecision;\ntypedef mp::number<mp::cpp_dec_float<32,int64_t>> cfloat;\ntypedef mp::cpp_int cint;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0)\n#define output2(v) for(auto j:v)output(j);\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n#define MOD 1000000007\n#define endl \"\\n\"\nstruct any{\n    string s;\n    any(string s):s(s){}\n    operator lint()const{return stoll(s);}\n    operator double()const{return stod(s);}\n    operator string()const{return s;}\n};\nany in(void){\n    return any(*istream_iterator<string>(cin));\n}\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ninline lint lcm(lint a,lint b){return a*b/gcd(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\ninline lint mex(vector<lint> s){\n    lint res=0;\n    sort(all(s));\n    while(binary_search(all(s),res))res++;\n    return res;\n}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\nnamespace bg = boost::geometry;\nnamespace trans = bg::strategy::transform;\ntypedef bg::model::d2::point_xy<double> point;\ntypedef boost::geometry::model::segment<point> line;\ntypedef bg::model::multi_point<point> mpoint;\n\nbool intersects(point a,point b,point c,point d){\n    return bg::intersects(line(a,b),line(c,d));\n}\n\nint main(){\n    lint n=in();\n    rep(i,n){\n        cout<<intersects(point(in(),in()),point(in(),in()),point(in(),in()),point(in(),in()))<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define db double\nconst db eps = 1e-6;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tvoid r() { cin >> x; cin >> y; }\n\tvoid w() { cout << x << ' ' << y << '\\n'; }\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tpoi operator +(poi p) {\n\t\treturn {x + p.x, y + p.y};\n\t}\n\tpoi operator *(db d) {\n\t\treturn {x * d, y * d};\n\t}\n\tdb dot(poi p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len2() { return x * x + y * y; }\n\tpoi proj(poi p, poi q) {\n\t\tdb s = (*this - p).dot(q - p) / (q - p).len2();\n\t\treturn p + (q - p) * s;\n\t}\n};\n\nint ccw(poi a, poi b, poi c) {\n\tpoi u = b - a, v = c - a;\n\tif(u.cross(v) > eps) return 1;\n\tif(u.cross(v) < -eps) return -1;\n\tif(u.dot(v) < -eps) return -2;\n\tif(u.len2() + eps < v.len2()) return 2;\n\treturn 0;\n}\nbool si(poi a, poi b, poi c, poi d) {\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0 &&\n\t\tccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\n\tint T; cin >> T;\n\twhile(T --) {\n\t\tpoi p0, p1, p2, p3; p0.r(); p1.r(); p2.r(); p3.r();\n\t\tcout << si(p0, p1, p2, p3) << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define _GLIBCXX_DEBUG\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...\n//on_seg(p1,p2,intersection(p1,p2,q1,q2)) && on_seg(q1,q2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n\tint q;\n\tcin>>q;\n\tfor(int cnt=0;cnt<q;cnt++)\n\t{\n\t\tvector<point> p;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tdouble c,d;\n\t\t\tcin>>c>>d;\n\t\t\tp.push_back(point(c,d));\n\t\t}\n\t\tif(on_seg(p[0],p[1],intersection(p[0],p[1],p[2],p[3])) && on_seg(p[2],p[3],intersection(p[0],p[1],p[2],p[3])))\n\t\t\tcout<<1<<endl;\n\t\telse\n\t\t\tcout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nusing ll = long long;\nconstexpr long long INF = 1LL << 62;\nconstexpr int MOD = 1e9 + 7;\nconstexpr double EPS = 1e-10;\n\nusing Point = complex<double>;\nusing Line  = pair<Point, Point>;\ndouble dot(Point p, Point q) { return (conj(p) * q).real(); }\ndouble cross(Point p, Point q) { return (conj(p) * q).imag(); }\ndouble slope(Line l) { return tan(arg(l.second - l.first)); }\n\nPoint project(Line l, Point p) { // project p onto line (s,t)\n    return l.first + (l.second - l.first) * dot(p - l.first, l.second - l.first) / norm(l.second - l.first);\n}\n\nPoint reflect(Line l, Point p) {\n    return l.first + conj((p - l.first) / (l.second - l.first)) * (l.second - l.first);\n}\n\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if(cross(b, c) >  EPS) return +1; // counter-clockwise\n    if(cross(b, c) < -EPS) return -1; // clockwise\n    if(  dot(b, c) < -EPS) return +2; // c--a--b\n    if(abs(b)+EPS < abs(c))return -2; // a--b--c\n    return 0; // a--c--b\n}\n\nbool intersect(Line a, Line b) {\n    return ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 && \n           ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int q;\n    cin >> q;\n    for(int i=0; i < q; ++i) {\n        double a,b,c,d,e,f,g,h;\n        cin >> a >> b >> c >> d >> e >> f >> g >> h;\n        Line l1(Point(a,b),Point(c,d));\n        Line l2(Point(e,f),Point(g,h));\n\n        if(intersect(l1, l2)) cout << 1;\n        else cout << 0;\n        cout << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\ntypedef long long ll;\nint sgn(double x){\n    if(fabs(x)<eps){\n        return 0;\n    }\n    if(x<0){\n        return -1;\n    }else{\n        return 1;\n    }\n}\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    void input(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    Point operator+(const Point &b)const{\n        return Point(x+b.x,y+b.y);\n    }\n    Point operator -(const Point &b)const{\n        return Point(x-b.x,y-b.y);\n    }\n    double operator *(const Point &b)const{\n        return x*b.x+y*b.y;\n    }\n    Point operator *(const double &k)const{\n        return Point(x*k,y*k);\n    }\n    double operator ^(const Point &b)const{\n        return x*b.y-y*b.x;\n    }\n    Point operator /(const double &k)const{\n        return Point(x/k,y/k);\n    }\n    bool operator <(const Point &b)const{\n        return sgn(x-b.x)==0?sgn(y-b.y)<0:x<b.x;\n    }\n};\nstruct Line{\n    Point s,e;\n    Line(){}\n    Line(Point _s,Point _e){\n        s = _s;\n        e = _e;\n    }\n    //两线段相交判断\n    // 2 规范相交\n    // 1 非规范相交\n    // 0 不相交\n    int segcrossseg(Line v){\n        int d1 = sgn((e-s)^(v.s-s));\n        int d2 = sgn((e-s)^(v.e-s));\n        int d3 = sgn((v.e-v.s)^(s-v.s));\n        int d4 = sgn((v.e-v.s)^(e-v.s));\n        if((d1^d2) == -2 && (d3^d4)==-2){\n            return 2;\n        }\n        return (d1==0&&sgn((v.s-s)*(v.s-e))<=0)||(d2==0&&sgn((v.e-s)*(v.e-e))<=0)||(d3==0&&sgn((s-v.s)*(s-v.e))<=0)||(d4==0&&sgn((e-v.s)*(e-v.e))<=0);\n    }\n};\nint main(){\n    int q;\n    Point p0,p1,p2,p3;\n    scanf(\"%d\",&q);\n    while(q--){\n        p0.input();\n        p1.input();\n        p2.input();\n        p3.input();\n        Line line1(p0,p1);\n        Line line2(p2,p3);\n        int tmp = line1.segcrossseg(line2);\n        if(tmp == 1 || tmp == 2){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<array>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef  complex<double> point;\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\ntypedef array<point, 2> line;\n\npoint projection(const line& l, const point& p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\npoint reflection(const line& l, const point& p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\n typedef array<point, 2> line;\n//using line = array<point, 2>;\n/*\n * 平行かどうか\n */\nbool is_parallel(const line& s, const line& t) {\n\treturn eq(cross(s[0] - s[1], t[0] - t[1]), 0.0);\n}\n\nbool is_orthogonal(const line& s, const line& t) {\n\treturn eq(dot(s[0] - s[1], t[0] - t[1]), 0.0);\n}\n\nbool intersectLL(const line& l, const line& m) {\n\treturn !eq(cross(l[1]-l[0], m[1]-m[0]), 0.) || // non-parallel\n\t\t\teq(cross(l[1]-l[0], m[0]-l[0]), 0.);   // same line\n}\nbool intersectSS(const line &s, const line &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint main()\n{\n  int q;\n  cin>>q;\n  for(;q--;)\n    {\n      line l1,l2;\n      double x,y;\n      cin>>x>>y;\n      l1[0]=point(x,y);\n      cin>>x>>y;\n      l1[1]=point(x,y);\n      cin>>x>>y;\n      l2[0]=point(x,y);\n      cin>>x>>y;\n      l2[1]=point(x,y);\n\n      cout<< (int)intersectSS(l1,l2) <<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double _x,double _y){\n\t\tx=_x;y=_y;\n\t}\n\tpoint operator +(const point &b) const{\n\t\treturn point(x+b.x,y+b.y);\n\t}\n\tpoint operator -(const point &b) const{\n\t\treturn point(x-b.x,y-b.y);\n\t}\n\tdouble operator ^(const point &b) const{\n\t\treturn (x*b.x)+(y*b.y);\n\t}\n\tdouble operator *(const point &b) const{\n\t\treturn x*b.y-y*b.x;\n\t}\n\tpoint operator *(const double &b) const{\n\t\treturn point(x*b,y*b);\n\t}\n};\nstruct matrix{\n\tint xmax,xmin,ymax,ymin;\n}a[2];\ndouble len(point p){\n\treturn (p.x*p.x+p.y*p.y);\n}\nint main(){\n\tpoint p0,p1,p2,p3;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>p0.x>>p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n\t\ta[0].xmax=max(p0.x,p1.x);\n\t\ta[0].xmin=min(p0.x,p1.x);\n\t\ta[0].ymax=max(p0.y,p1.y);\n\t\ta[0].ymin=min(p0.y,p1.y);\n\t\ta[1].xmax=max(p2.x,p3.x);\n\t\ta[1].xmin=min(p2.x,p3.x);\n\t\ta[1].ymax=max(p2.y,p3.y);\n\t\ta[1].ymin=min(p2.y,p3.y);\n\t\tif(!(a[0].xmax<a[1].xmin || a[1].xmax<a[0].xmin || a[0].ymax<a[1].ymin || a[1].ymax<a[0].ymin)){\n\t\t\tif(((p1-p0)*(p2-p0))*((p1-p0)*(p3-p0))<=0 &&\n\t\t\t   ((p3-p2)*(p1-p2))*((p3-p2)*(p0-p2))<=0) puts(\"1\");\n\t\t\telse puts(\"0\");\n\t\t}\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(ll i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-7; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\n\nusing P=complex<R>;\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nusing L=struct{P s,t;};\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a)-norm(b)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << iss(s1,s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c (cw)\n *          a -> bで反時計方向に折れてb -> c (ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c (front)\n *          a -> bで逆を向いてb -> cまたは、b == c (on)\n */\nenum struct ffd {  // front face direciton\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t norm2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t norm(const vector_t& v)\n{\n    return std::sqrt(norm2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / norm2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline ffd ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return ffd::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return ffd::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return ffd::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(norm2(p1), norm2(p2)))      { return ffd::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return ffd::on;\n}\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\ncoord_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{  \n    return std::min(pi.x, pj.x) <= pk.x && pk.x <= std::max(pi.x, pj.x)\n        && std::min(pi.y, pj.y) <= pk.y && pk.y <= std::max(pi.y, pj.y);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    coord_t d1 = direction(p3, p4, p1);\n    coord_t d2 = direction(p3, p4, p2);\n    coord_t d3 = direction(p1, p2, p3);\n    coord_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return -1;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -1;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(x1>x2)swap(x1, x2);\n        if(x3>x4)swap(x3, x4);\n        if(y1>y2)swap(y1, y2);\n        if(y3>y4)swap(y3, y4);\n        if(x1==x2&&x2==x3&&x3==x4){\n            if((y1<=y3&&y3<=y2) || (y3<=y1&&y1<=y4))return 1;\n        }\n        \n        if(y1==y2&&y2==y3&&y3==y4){\n            if((x1<=x3&&x3<=x2) || (x3<=x1&&x1<=x4))return 1;\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif((p1-p0).det(p2-p0)==0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tr.print();\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\tint\tp0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0;\n\tint n = 0;\n\tdouble u = 0, s = 0, t = 0;\n\n\tcin >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\t\tn = 0;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\t\t\n\t\tif (u != 0) {\n\t\t\ts = (double)((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = - (double)((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (p1x - p0x != 0) {\n\t\t\t\tif ((p0x - p2x) * (p0x - p3x) <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t\telse if(((p2x - p0x) * (p2x - p1x) <= 0) | ((p3x - p0x) * (p3x - p1x) <= 0))\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif ((p0y - p2y) * (p0y - p3y) <= 0)\n\t\t\t\t\tn = 1;\t\t\t\n\t\t\t\telse if (((p2y - p0y) * (p2y - p1y) <= 0) | ((p3y - p0y) * (p3y - p1y) <= 0))\n\t\t\t\t\tn = 1;\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <iomanip>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\n#define NAN_M 0x800000000000\n#define EPS 0.0000000001\n\nclass Position {\npublic:\n    enum Positions {\n        COUNTER_CLOCKWISE = -1,\n        CLOCKWISE = 1,\n        ONLINE_BACK,\n        ONLINE_FRONT,\n        ON_SEGMENT = 0\n    };\n\n    static std::string ToString(enum Positions e) {\n        switch (e) {\n            case COUNTER_CLOCKWISE:\n                return \"COUNTER_CLOCKWISE\";\n            case CLOCKWISE:\n                return \"CLOCKWISE\";\n            case ONLINE_BACK:\n                return \"ONLINE_BACK\";\n            case ONLINE_FRONT:\n                return \"ONLINE_FRONT\";\n            case ON_SEGMENT:\n                return \"ON_SEGMENT\";\n        }\n    }\n};\n\ntemplate<class T>\nclass Vector2D {\npublic:\n    T x;\n    T y;\n\n    Vector2D() {\n        x = y = 0;\n    }\n\n    Vector2D(T x_, T y_) {\n        x = x_;\n        y = y_;\n    }\n\n    T operator*(const Vector2D<T> *e) {\n        return this->x * e->x + this->y * e->y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x - e->x, this->y - e->y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x + e->x, this->y + e->y);\n    }\n\n    T operator*(const Vector2D<T> e) {\n        return this->x * e.x + this->y * e.y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> e) {\n        return Vector2D<T>(this->x - e.x, this->y - e.y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> e) {\n        return Vector2D<T>(this->x + e.x, this->y + e.y);\n    }\n\n    Vector2D<T> operator*(const T r) {\n        return Vector2D<T>(this->x * r, this->y * r);\n    }\n\n    Vector2D<T> operator/(const T r) {\n        return Vector2D<T>(this->x / r, this->y / r);\n    }\n\n    Vector2D<T> operator-() {\n        return Vector2D<T>(-this->x, -this->y);\n    }\n\n    double abs() {\n        return sqrt(x * x + y * y);\n    }\n\n    T norm() {\n        return x * x + y * y;\n    }\n\n    T crossP(Vector2D<T> e) {\n        if (x * e.y >= y * e.x) return (x * e.y) - (y * e.x);\n        else return (y * e.x) - (x * e.y);\n    }\n\n    T cross(Vector2D<T> e) {\n        return (x * e.y) - (y * e.x);\n    }\n\n    double cos(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return (e * (*this)) / (e.abs() * abs());\n    }\n\n    double sin(Vector2D<T> e) {\n        if ((e.abs() * abs()) == 0) return NAN_M;\n        return ((x * e.y) - (y * e.x)) / (e.abs() * abs());\n    }\n};\n\ntemplate<class T>\nclass Point2D : public Vector2D<T> {\npublic:\n    using Vector2D<T>::Vector2D;\n};\n\ntemplate<class T>\nclass Line2D {\npublic:\n    Point2D<T> p1, p2;\n    Line2D(){\n        p1 = Point2D<T>(0,0);\n        p2 = Point2D<T>(0,0);\n    }\n    Line2D(Point2D<T> p1_,Point2D<T> p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n    Vector2D<T> getVector() {\n        return p2 - p1;\n    }\n\n    Point2D<T> getProject(Point2D<T> p) {\n        Vector2D<T> base = getVector();\n        return p1 + base * ((p - p1) * base) / base.norm();\n    }\n\n    Point2D<T> reflect(Point2D<T> p) {\n        return p + (getProject(p) - p) * 2;\n    }\n\n    virtual double getDistance(Point2D<T> p) {\n        return (p2 - p1).crossP(p - p1) / (p2 - p1).abs();\n    }\n};\n\ntemplate<class T>\nclass Segment2D : public Line2D<T> {\npublic:\n    using Line2D<T>::p1;\n    using Line2D<T>::p2;\n    using Line2D<T>::Line2D;\n    double getDistance(Point2D<T> p) override{\n        if ((p2 - p1).cross(p - p1) < 0) return (p - p1).abs();\n        if ((p1 - p2).cross(p - p1) < 0) return (p - p1).abs();\n        return Line2D<T>::getDistance(p);\n    }\n\n    Position::Positions ccw(Point2D<T> p) {\n        Vector2D<T> a = p2 - p1;\n        Vector2D<T> b = p - p1;\n        if (a.cross(b) > EPS) return Position::Positions::COUNTER_CLOCKWISE;\n        if (a.cross(b) < -EPS) return Position::Positions::CLOCKWISE;\n        if (a * b < -EPS) return Position::Positions::ONLINE_BACK;\n        if (a.norm() < b.norm()) return Position::Positions::ONLINE_FRONT;\n        return Position::Positions::ON_SEGMENT;\n    }\n\n    bool intersect(Segment2D<T> s) {\n        return (ccw(s.p1) * ccw(s.p2) <= 0 && s.ccw(p1) * s.ccw(p2) <= 0);\n    }\n\n    double getDistance(Segment2D<T> s) {\n\n    }\n};\n\nint main(void){\n    int q;\n    cin >> q;\n    loop(i,0,q){\n        Point2D<double> v[4];\n        loop(j,0,4) {\n            cin >> v[j].x >> v[j].y;\n        }\n        int res = Segment2D<double>(v[0],v[1]).intersect(Segment2D<double>(v[2],v[3]));\n        if(res) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n/*\nint main(void) {\n    Segment2D<double> b;\n    cin >> b.p1.x >> b.p1.y >> b.p2.x >> b.p2.y;\n    int q;\n    cin >> q;\n    Point2D<double> c;\n    loop(i,0,q){\n        cin >> c.x >> c.y;\n        cout << Position::ToString(b.ccw(c)) << endl;\n    }\n}*/\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n//const\n#define EPS 1e-8\n#define EQ (abs((a) - (b)) < EPS)\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ninline int signum(double x) { return (abs(x) < EPS) ? 0 : (x > 0) ? 1 : -1; }\n\n//-----definition-----\ntypedef complex<double> P;\n\n//-----standard-----\npair<P, P> norm_vec(P a) {\n    return make_pair(a * P(0, 1), a * P(0, -1));\n}\n\nP unit_vec(P a) { a / abs(a); }\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    int sign = signum(cross(b, c));\n    if (sign != 0) return sign;\n    if (signum(dot(b, c)) < 0) return 2;//left\n    if (abs(b) < abs(c)) return -2;//right\n    return 0; //mid\n}\n\n//-----line-----\nbool is_paral(P a1, P a2, P b1, P b2) {\n    return signum(cross(a2 - a1, b2 - b1)) == 0;\n}\n\nbool is_orth(P a1, P a2, P b1, P b2) {\n    return signum(dot(a2 - a1, b2 - b1)) == 0;\n}\n\nbool is_p_on_li(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    return signum(cross(b, c)) == 0;\n}\n\nbool is_p_on_li_s(P a, P b, P c) {\n    return abs(c - a) + abs(b - c) < abs(b - a) + EPS;\n}\n\ndouble dis_p_li(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    return abs(cross(b, c)) / abs(b);\n}\n\ndouble dis_p_li_ss(P a, P b, P c) {\n    P x1 = b - a;\n    P y1 = c - a;\n    P x2 = a - b;\n    P y2 = c - b;\n    if (cross(x1, y1) < EPS) return abs(y1);\n    if (cross(x2, y2) < EPS) return abs(y2);\n    return dis_p_li(a, b, c);\n}\n\nbool is_inter_li_ss(P a1, P a2, P b1, P b2) {\n    return (ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0) && (ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0);\n\n}\n\nint main() {\n\n    int Q;\n    cin >> Q;\n\n    while (Q--) {\n\n        vector<P> p(4);\n        for (int i = 0; i < 4; i++) {\n            double x, y;\n            cin >> x >> y;\n            p[i] = P(x, y);\n        }\n\n        if (is_inter_li_ss(p[0], p[1], p[2], p[3])) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <algorithm>\nconst double EPS = 1e-9;\nusing namespace std;\nclass vector {\npublic:\n\tdouble x, y;\n\tvector(double a, double  b) {\n\t\tx = a;\n\t\ty = b;\n\t};\n\tvector operator * (const vector &v)const {\n\t\treturn vector(x*v.x, y* v.y);\n\t}\n\tvector operator * (double a) {\n\t\treturn vector(x * a, y * a);\n\t}\n\tvector operator - (vector v) {\n\t\treturn vector(x - v.x, y - v.y);\n\t}\n\tvector operator + (vector v) {\n\t\treturn vector(x + v.x, y + v.y);\n\t}\n};\ninline double dot(vector v1, vector v2) {\n\treturn v1.x*v2.x + v1.y*v2.y;\n}\ninline double squ(vector v) {\n\treturn v.x*v.x + v.y*v.y;\n}\ninline double norm(vector v) {\n\treturn sqrt(squ(v));\n}\ninline void print(vector v) {\n\tprintf(\"%.10f %.10f\\n\", v.x, v.y);\n}\ninline vector pro(vector base, vector v, vector be) {\n\tdouble a = dot(base, v) / squ(base);\n\tvector v1 = base * a;\n\treturn v1 + be;\n}\ninline vector ref(vector v, vector be) {\n\treturn (v - be)*2 + be;\n}\ninline double cross(vector v1, vector v2) {\n\treturn v1.x*v2.y - v1.y*v2.x;\n}\ninline int ccw(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\tif (cross(a, b) < 0.0) return -1;\n\telse if (cross(a, b) > 0.0) return 1;\n\telse if (dot(a, b) < 0.0) return -2;\n\telse if (dot(a, b) > squ(a)) return 2;\n\telse return 0;\n}\ninline int inter(vector v1, vector v2, vector v3, vector v4) {\n\treturn (ccw(v1, v2, v3) * ccw(v1, v2, v4) <= 0) && (ccw(v3, v4, v1) * ccw(v3, v4, v2) <= 0);\n}\ninline double disPP(vector v1, vector v2) {\n\treturn norm(v2 - v1);\n}\ninline double disLP(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\treturn fabs(cross(a, b) / norm(a));\n}\ninline double disSP(vector v1, vector v2, vector v3) {\n\tvector a = v2 - v1;\n\tvector b = v3 - v1;\n\tvector c = v1 - v2;\n\tvector d = v3 - v2;\n\tif (dot(a, b) < 0.0) return disPP(v1, v3);\n\telse if (dot(c, d) < 0.0) return disPP(v2, v3);\n\telse return disLP(v1, v2, v3);\n}\ninline double disSS(vector v1, vector v2, vector v3, vector v4) {\n\tif (inter(v1, v2, v3, v4)) return 0;\n\tdouble a = disSP(v1, v2, v3);\n\tdouble b = disSP(v1, v2, v4);\n\tdouble c = disSP(v3, v4, v1);\n\tdouble d = disSP(v3, v4, v2);\n\treturn min(min(a, b), min(c, d));\n}\nint main() {\n\t//inter\n\tint n;\n\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tvector v1(x0,y0);\n\t\tvector v2(x1, y1);\n\t\tvector v3(x2, y2);\n\t\tvector v4(x3, y3);\n\t\tcout << inter(v1, v2, v3, v4) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{x+p.x,y+p.y};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{x-p.x,y-p.y};\n\t}\n\tpoint operator*(double p){\n\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n\t}\n};\n\ntypedef pair<point,point> pp;\nconst point O{0,0};\n\nclass Geom{\n\tpublic:\n\tdouble Length(point x,point y){\n\t\tpoint z=y-x;\n\t\treturn sqrt(z.x*z.x+z.y*z.y);\n\t}\n\tdouble IP(point p,point q){\n\t\treturn p.x*q.x+p.y*q.y;\n\t}\n\tdouble CP(point p,point q){\n\t\treturn p.x*q.y-q.x*p.y;\n\t}\n\tstring Counter_Clockwise(pp a,point x){\n\t\tpoint A=a.second-a.first;\n\t\tpoint X=x-a.first;\n\t\tdouble ip=IP(A,X),cp=CP(A,X),Al=Length(O,A),Xl=Length(O,X);\n\t\tif(cp>eps) return \"Counter_Clockwise\";\n\t\tif(cp<-eps) return \"Clockwise\";\n\t\tif(ip<-eps) return \"Online_Back\";\n\t\tif(Xl<Al||fabs(Xl-Al)<eps) return \"On_Segment\";\n\t\treturn \"Online_Front\";\n\t}\n\tstring Parallel_Orthogonal(pp a,pp b){\n\t\tpoint A=a.second-a.first,B=b.second-b.first;\n\t\tdouble ip=IP(A,B),cp=CP(A,B);\n\t\tstring f=Counter_Clockwise(pp(a.first,a.second),b.first),s=Counter_Clockwise(pp(a.first,a.second),b.second);\n\t\tif(f[0]!='C'&&s[0]!='C') return \"Agreement\";\n\t\tif(cp<eps&&cp>-eps) return \"Parallel\";\n\t\tif(ip<eps&&ip>-eps) return \"Orthogonal\";\n\t\telse return \"Commonly\";\n\t}\n\tstring Intersection(pp a,pp b){\n\t\tpoint p=Cross_Point(a,b);\n\t\tif(p==point{inf,0}) return \"not_Intersection\";\n\t\tif(p==point{inf,inf}){\n\t\t\tstring S=Counter_Clockwise(a,b.first),T=Counter_Clockwise(a,b.second);\n\t\t\tif(S==T&&S[2]=='l'&&T[2]=='l') return \"not_Intersection\";\n\t\t\treturn \"Intersection\";\n\t\t}\n\t\tstring s=Counter_Clockwise(a,p),t=Counter_Clockwise(b,p);\n\t\tif(s[3]=='S'&&t[3]=='S') return \"Intersection\";\n\t\telse return \"not_Intersection\";\n\t}\n\tpoint Inter(pp  a,double x,double y){\n\t\treturn (a.first*y+a.second*x)/(x+y);\n\t}\n\tpoint Exterior(pp a,double x,double y){\n\t\treturn (a.first*-y+a.second*x)/(x-y);\n\t}\n\tpoint Projection(pp a,point x){\n\t\tpoint A=x-a.first,B=a.second-a.first;\n\t\tdouble l=Length(O,B);\n\t\treturn B*IP(A,B)/(l*l)+a.first;\n\t}\n\tpoint Cross_Point(pp a,pp b){\n\t\tstring s=Parallel_Orthogonal(a,b);\n\t\tif(s[0]=='A') return point{inf,inf};\n\t\tif(s[0]=='P') return point{inf,0};\n\t\tpoint p=Projection(a,b.first),q=Projection(a,b.second);\n\t\tdouble pl=Length(b.first,p),ql=Length(b.second,q);\n\t\tstring S=Counter_Clockwise(a,b.first),T=Counter_Clockwise(a,b.second);\n\t\tif(S==T) return Exterior(b,pl,ql);\n\t\telse return Inter(b,pl,ql);\n\t}\n\tvoid Point_in(point& p){\n\t\tcin>>p.x>>p.y;\n\t}\n\tvoid Point_out(point p){\n\t\tcout<<p.x<<' '<<p.y<<endl;\n\t}\n};\n\nint Q;\nvector<point> p(4);\n\nint main(){\n\tcout<<syosu(10);\n\tGeom geo;\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<4;j++) geo.Point_in(p[j]);\n\t\tstring ans=geo.Intersection(pp(p[0],p[1]),pp(p[2],p[3]));\n\t\tif(ans==\"Intersection\") cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(){\n\n    int q; cin >> q;\n    for(int i = 0; i < q; i++){\n        P p0, p1, p2, p3; cin >> p0.real() >> p0.imag() >> p1.real() >> p1.imag() >> p2.real() >> p2.imag() >> p3.real() >> p3.imag();\n        if(is_intersected_ls(p0, p1, p2, p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n//--\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = Y-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\n#define re real()\n#define im imag()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> pt;\ntypedef pair<pt,pt> line; //sX+tY\n\ndouble dot(pt a,pt b){return (conj(a)*b).real();}\ndouble cros(pt a,pt b){return (conj(a)*b).imag();}\npt proj(pt a,pt to){\n  return dot(a,to)/norm(to)*to;\n}\n\npt refle(pt a,pt mirror){\n  return pt(2)*proj(a,mirror)-a;\n}\n\nint pt3(pt a,pt b,pt c){\n  pt p=b-a,q=c-a;\n  double tmp;\n  tmp=cros(p,q);\n  if(tmp>0){\n    return 0;\n  }else if(tmp<0){\n    return 1;\n  }else if(norm(p+q)<max(norm(p),norm(q))){\n    return 2;//back\n  }else if(norm(q)>norm(p)){\n    return 3;//front\n  }else if(norm(q)<norm(p)){\n    return 4;\n  }\n  return 5;\n}\n\npt dir(line a){return a.Y-a.X;}\n\nint line2(line a,line b){\n  if(dot(dir(a),dir(b))==0)\n    return 1;//直交\n  if(cros(dir(a),dir(b))==0)\n    return 2;//平行\n  return 0;\n}\n\nint intersect(line a,line b){\n  if(line2(a,b)==2)\n    return pt3(a.X,a.Y,b.X)>3 || pt3(a.X,a.Y,b.Y)>3;\n  return cros(dir(a),b.X-a.X)*cros(dir(a),b.Y-a.X)<=0\n    && cros(dir(b),a.X-b.X)*cros(dir(b),a.Y-b.X)<=0;\n}\n\nint main(){\n  int i,j,k,n,re;\n  line s1,s2;\n  double a[8];\n  cin>>n;\n  rep(i,n){\n    rep(j,8)\n      cin>>a[j];\n    s1.X=pt(a[0],a[1]);\n    s1.Y=pt(a[2],a[3]);\n    s2.X=pt(a[0+4],a[1+4]);\n    s2.Y=pt(a[2+4],a[4+3]);\n    cout<<intersect(s1,s2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct Point \n{\n\tint x;\n\tint y;\n};\n\nbool inLine(Point a, Point b, Point c)\n{\n\tif(b.x<=max(a.x,c.x) && b.x>=min(a.x,c.x) && b.y<=max(a.y,c.y) && b.y>=min(a.y,c.y)) return true;\n\treturn false;\n}\n\nint orientation(Point a, Point b, Point c)\n{\n\tint val = (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);\n\t//counterclockwise\n\tif(val<0) return -1;\n\t//clockwise\n\telse if(val>0) return 1;\n\t//coliar\n\treturn 0;\t\n}\n\nbool intersect(Point a, Point b, Point c, Point d)\n{\n\tint o1 = orientation(a,b,c);\n\tint o2 = orientation(a,b,d);\t\n\tint o3 = orientation(c,d,a);\n\tint o4 = orientation(c,d,b);\n\n\tif(o1!=o2 && o3!=o4) return true;\n\tif(o1==0 && inLine(a,c,b)) return true;\n        if(o2==0 && inLine(a,d,b)) return true;\n\tif(o3==0 && inLine(c,a,d)) return true;\n\tif(o4==0 && inLine(c,b,d)) return true;\n\treturn false;\t\n}\n\nint main()\n{\n\tint q;\n\tint p1x,p1y,p2x,p2y;\n\tint q1x,q1y,q2x,q2y;\n\tcin>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>p1x>>p1y>>p2x>>p2y;\n\t\tcin>>q1x>>q1y>>q2x>>q2y;\n\n\t\tstruct Point p1 = {p1x,p1y};\n\t\tstruct Point p2 = {p2x,p2y};\n\t\tstruct Point q1 = {q1x,q1y};\n\t\tstruct Point q2 = {q2x,q2y};\n\t\tcout<<intersect(p1,p2,q1,q2)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){\n      if(s1.real()==0 && s2.real()==0){//tate\n\tif( (0<=abs(p1/s2) && abs(p1/s2)<=1) || (0<=abs(p2/s2) && abs(p2/s2)<=1) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else if(s1.imag()==0 && s2.imag()==0){//yoko\n\tif( (0<=abs(p1/s2) && abs(p1/s2)<=1) || (0<=abs(p2/s2) && abs(p2/s2)<=1) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else \n\tcout<<\"0\"<<endl;\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Point{double x,y;};\nPoint operator -(Point a,Point b){return (Point){a.x-b.x,a.y-b.y};}\ndouble cross(Point a,Point b){return a.x*b.y-a.y*b.x;}\nvoid read(Point &a){a.x=read(),a.y=read();}\nbool Intersect(Point p0,Point p1,Point p2,Point p3)\n{\n\tif(cross(p1-p0,p2-p0)*cross(p1-p0,p3-p0)>0)return 0;\n\tif(cross(p3-p2,p0-p2)*cross(p3-p2,p1-p2)>0)return 0;\n\treturn 1;\n}\nint main()\n{\n\tint q=read();while(q--)\n\t{\n\t\tPoint p0,p1,p2,p3;\n\t\tread(p0),read(p1),read(p2),read(p3);\n\t\tprintf(\"%d\\n\",Intersect(p0,p1,p2,p3));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static bool crossing(P p1,P p2,P q1,P q2){double x = ((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1)); return x<=1 && x>=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n};\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define NIL -2\n#define INF 1000000001\n#define EPS 1e-10\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\nclass Point{\n    public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double k){ return Point(x*k,y*k);     }\n    Point operator / (double k){ return Point(x/k,y/k);     }\n\n    double norm(){ return x*x + y*y;}\n    double abs(){ return sqrt(norm());}\n    double dot(Point p){\n        return x*p.x + y*p.y;\n    }\n    double prod(Point p){\n        return x*p.y - y*p.x;\n    }\n\n    bool operator < (Point &p){\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == (Point &p){\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n  \n};\ntypedef Point Vector;\n\nint ccw(Point p0, Point p1,Point p2){\n    Vector p10 = p1 - p0;\n    Vector p20 = p2 - p0;\n    double prod = p10.prod(p20);\n    if(prod > EPS) return 1;\n    if(prod < -EPS) return -1;\n    if(p10.dot(p20) < -EPS) return 2;\n    if(p10.abs() < p20.abs()) return -2;\n    return 0; \n}\n\nbool intersection(Point p0,Point p1,Point p2, Point p3){\n    return ( ccw(p0,p1,p2) * ccw(p0,p1,p3) <= 0 ) && ( ccw(p2,p3,p0) * ccw(p2,p3,p1) <= 0 ) ;\n}\n\nint main(){\n    double p0x,p0y,p1x,p1y;\n    double p2x,p2y,p3x,p3y;\n    int q;\n    \n    scanf(\"%d\",&q);\n    for(int i = 0;i < q;i++){\n        scanf(\"%lf %lf %lf %lf\",&p0x,&p0y,&p1x,&p1y);\n        scanf(\"%lf %lf %lf %lf\",&p2x,&p2y,&p3x,&p3y);\n        Point p0(p0x,p0y);\n        Point p1(p1x,p1y);\n        Point p2(p2x,p2y);\n        Point p3(p3x,p3y);\n        int ans = (intersection(p0,p1,p2,p3))? 1 : 0;\n        printf(\"%d\\n\",ans);\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nvoid solve() {\n\tdouble x1, x2, x3, x4, y1, y2, y3, y4;\n\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\tif ((x2 - x1) * (y4 - y3) == (y2 - y1) * (x4 - x3)) {\n\t\tif ((x2 - x1) * (y3 - y1) != (y2 - y1) * (x3 - x1))cout << \"0\\n\";\n\t\telse {\n\t\t\tbool b = 0;\n\t\t\tif ((x1 - x3) * (x2 - x3) <= 0 && (y1 - y3) * (y2 - y3) <= 0)b = 1;\n\t\t\tif ((x1 - x4) * (x2 - x4) <= 0 && (y1 - y4) * (y2 - y4) <= 0)b = 1;\n\t\t\tif ((x3 - x1) * (x4 - x1) <= 0 && (y3 - y1) * (y4 - y1) <= 0)b = 1;\n\t\t\tif ((x3 - x2) * (x4 - x2) <= 0 && (y3 - y2) * (y4 - y2) <= 0)b = 1;\n\t\t\tcout << b << endl;\n\t\t}\n\t}\n\telse {\n\t\tdouble p = ((y2 - y1) * (x3 - x1) - (x2 - x1) * (y3 - y1)) / ((x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3));\n\t\tdouble x = x3 + p * (x4 - x3), y = y3 + p * (y4 - y3);\n\t\tcout << (((x1 - x) * (x2 - x) <= 0.000001 && (y1 - y) * (y2 - y) <= 0.000001) && (0 <= p && p <= 1)) << endl;\n\t}\n}\nsigned main() {\n\tint n; cin >> n; for1(i, n)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return norm(a1-p)+norm(a2-p)<=norm(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2) // P0, P1, P2 counter_clockwise.\n{\n\tdouble d1 = (p1.x - p0.x) * (p2.y - p0.y);\n\tdouble d2 = (p2.x - p0.x) * (p1.y - p0.y);\n\tif(d1 == d2) return 0;\n\treturn (d1 > d2 ? 1 : -1);\n}\n\ndouble inpro(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vx) + (v1.vy * v2.vy);\n}\n\ndouble det2(const Vector &v1, const Vector &v2)\n{\n\treturn (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\nbool crit(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n\tdouble d1 = (p0.x - p2.x) * (p0.x - p3.x);\n\tdouble d2 = (p1.x - p2.x) * (p1.x - p3.x);\n\tif(((d1 > 0) && (d2 > 0)) || ((d1 < 0) && (d2 < 0))) return true;\n\tdouble d3 = (p0.y - p2.y) * (p0.y - p3.y);\n\tdouble d4 = (p1.y - p2.y) * (p1.y - p3.y);\n\tif(((d3 > 0) && (d4 > 0)) || ((d3 < 0) && (d4 < 0))) return true;\n\treturn false;\n}\n\nint main()\n{\n    int q;\n    double d12, d13;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n\t\tVector V01 = set_v(P0, P1), V23 = set_v(P2, P3);\n\t\tif(ccw(P0, P1, P2) * ccw(P0, P1, P3) > 0 || ccw(P2, P3, P0) * ccw(P2, P3, P1) > 0){\n\t\t\tprintf(\"0\\n\");\n\t\t}else {\n\t\t\tif(det2(V01, V23) == 0 && crit(P0, P1, P2, P3)){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t}\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <queue>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define mp make_pair\n#define pb push_back\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n    return a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){//?????????????????°\n    return sign(a-b);\n}\n\nstruct P {//???\n    db x, y;\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    P operator+(P p) { return P(x + p.x, y + p.y); }\n    P operator-(P p) { return P(x - p.x, y - p.y); }\n    P operator*(db d) { return P(x * d, y * d); }\n    P operator/(db d) { return P(x / d, y / d); }\n    bool operator<(P p) const {\n        int c = cmp(x, p.x);\n        if (c) return c == -1;\n        return cmp(y, p.y) == -1;\n    }\n    db dot(P p) { return x * p.x + y * p.y; }//????§?\n    db det(P p) { return x * p.y - y * p.x; }//????§?\n    db distTo(P p) { return (*this-p).abs(); }//??????\n    db alpha() { return atan2(y, x); }//?±?????§?\n    void read() { cin>>x>>y; }//?????\\\n    db abs() { return sqrt(abs2());}//??????\n    db abs2() { return x * x + y * y; }//???????????????\n    P rot90() { return P(-y,x);}//?????¶????????¬90???\n    P unit() { return *this/abs(); }//?????????\n    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }//????§?????????¨[0,180)?????´\n};\n\nstruct L{ //ps[0] -> ps[1]\n    P ps[2];\n    P& operator[](int i) { return ps[i]; }\n    P dir() { return ps[1] - ps[0]; }//??´??????????????????\n    bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) > 0; }//????????¨?????????????????¢????????¶????????¨???\n    L push(){ // push eps outward\n        const double eps = 1e-6;\n        P delta = (ps[1] - ps[0]).rot90().unit() * eps;\n        return {ps[0] - delta, ps[1] - delta};\n    }\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {//?±??????´?????????\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nP isLL(L l1,L l2){ return isLL(l1[0],l1[1],l2[0],l2[1]); }//?±??????´?????????\n\nbool intersect(db l1,db r1,db l2,db r2){\n    if(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2);\n    return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){//?±?????????????\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) &&\n           crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n                                                         * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {//??????m????????¨a,b?????´\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n\nbool isMiddle(P a, P m, P b) {//?????????m?????????????????¨a,b?????´\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){//?????????????????¨??´??????\n    return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {//????????´???????????±\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){//????????´??????????§°\n    return proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n    P h = proj(p1,p2,q);\n    if(isMiddle(p1,h,p2))\n        return q.distTo(h);\n    return min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n    if(isSS(p1,p2,q1,q2)) return 0;\n    return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb rad(P p1,P p2){\n    return atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n    db A = p1.distTo(p2);\n    db B = p2.distTo(p3);\n    db C = p3.distTo(p1);\n    return sqrtl(A*B*C/(A+B+C));\n}\n\n\n\nint main(){\n    L l[2];\n    int q;\n    scanf(\"%d\",&q);\n    for(int i = 1;i <= q;i++){\n        for(int j = 0;j < 2;j++){\n            l[j][0].read(),l[j][1].read();\n        }\n        if(isSS(l[0][0],l[0][1],l[1][0],l[1][1])){\n            puts(\"1\");\n        }else{\n            puts(\"0\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n    ll x,y;\n    Point(){ x = y = 0.0; }\n    Point(ll _x, ll _y) : x(_x), y(_y){}\n\n    Point operator+ (Point p)\n    {\n        return Point(p.x + x, p.y + y);\n    }\n\n    Point operator- (Point p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    ll operator* (Point p)\n    {\n        return p.x * x + p.y * y;\n    }\n\n    Point operator* (ll t)\n    {\n        return Point(x*t, y*t);\n    }\n\n    ll operator~ ()\n    {\n        return x * x + y * y;\n    }\n\n    ll operator% (Point p)\n    {\n        return x * p.y - y * p.x;\n    }\n\n};\n\nbool intersect(Point a, Point b, Point p, Point q)\n{\n    Point v1=(b-a);\n    Point v2=(q-p);\n    if( v1 % v2 == 0 ) return false;\n    double t = (double)(( p - a ) % v2) / (double)(v1 % v2);\n    double t1 = (double)(( a - p ) % v1) / (double)(v2 % v1);\n    if( t >= 0.0 && t <= 1.0 && t1 >= 0.0 && t1 <= 1.0) return true;\n    else return false;\n}\n\nint main()\n{\n    Point p0,p1,p2,p3;\n    Point vec, vec1;\n    int q;\n    cin >> q;\n    while(q--)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << intersect(p0,p1,p2,p3) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nPoint projection(Point p1, Point p2, Point p) {\n    Vector v = p2 - p1;\n    Vector u = p - p1;\n    Point t = p1 + v*dot(u,v)/v.norm();\n    return t;\n}\n\n//2つのベクトルが平行かどうか\nbool isParallel(Vector u, Vector v){\n    double Cross = cross(u,v);\n    bool out = (Cross==0)? true : false;\n    return out;\n}\n\n//ポイントp2が線分p0p1上にいるかどうか\nbool isOn(Point p0, Point p1, Point p2){\n    Vector v01 = p1 - p0;\n    Vector v02 = p2 - p0;\n    Vector v10 = p0 - p1;\n    Vector v12 = p2 - p1;\n\n    return cross(v01,v02)==0 && dot(v01,v02)>=0 && dot(v10,v12)>=0;\n}\n\n//ポイントp2がベクトルp1-p0からみて反時計回りにいるかどうか\n//CCW: 1, CW: -1, ON:0\nint isCCW(Point p0, Point p1, Point p2){\n    Vector v01 = p1 - p0;\n    Vector v02 = p2 - p0;\n\n    double Cross = cross(v01, v02);\n    \n    int out = 2;\n    if (Cross>0){out = 1;}\n    else if(Cross<0){out = -1;}\n    else{out = 0;}\n\n    return out;\n}\n\nbool isIntersect(Point p0, Point p1, Point p2, Point p3){\n    Vector s1 = p1-p0;\n    Vector s2 = p3-p2;\n    bool out;\n    //平行な場合\n    if(isParallel(s1,s2))\n    {\n        out = isOn(p0,p1,p2) || isOn(p0,p1,p3) || isOn(p2,p3,p0) || isOn(p2,p3,p1);\n    }\n    //平行でない場合\n    else     \n    {\n        out = ( ( isCCW(p0,p1,p2)*isCCW(p0,p1,p3) ) <= 0 ) && ( ( isCCW(p2,p3,p0)*isCCW(p2,p3,p1) ) <= 0 );\n    }\n    return out;\n}\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int q;\n    cin >> q;\n\n    for(int i=0; i<q; i++){\n        Point p0, p1, p2, p3;\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n\n        bool out = isIntersect(p0, p1, p2, p3);\n\n        cout << int(out) << \"\\n\";\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (p0 == p1 || p0 == p2 || p0 == p3 || p1 == p2 || p1 == p3 || p2 == p3) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_parallel(p0, p1, p2, p3)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define Vector Point\n#define INF 2000000000\n#define sq(x) ((x)*(x))\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\n\n// Geometry Library\n\ninline double add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint() {}\n\tPoint(double x,double y) : x(x),y(y){}\n\tPoint operator + (Point p){return Point(add(x,p.x),add(y,p.y));}\n\tPoint operator - (Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tPoint operator * (double d){return Point(x*d,y*d);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble det(Point p){return add(x*p.y,-y*p.x);}\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble norm2(){return x*x+y*y;}\n\tdouble dist2(Point p){return sq(x-p.x)+sq(y-p.y);}\n\tPoint vert(){return Point(y,-x);}\n\tvoid dump(const char* msg=\"\"){printf(\"%s(%.12f,%.12f)\\n\",msg,x,y);return;}\n\t\n\t// following functions for vector operation\n\n\t// signed area of triange (0,0) (x,y) (p.x,p.y)\n\tdouble area(Point p){\n\t\treturn (x*p.y-p.x*y)/2.0;\n\t}\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nint ccw(Point a,Point b,Point c){\n\tVector p = b-a;\n\tVector q = c-a;\n\tif(p.det(q)>0.0)return 1; // counter clockwise\n\tif(p.det(q)<0.0)return -1; // clockwise\n\tif(p.dot(q)<0.0)return 2; // c--a--b online_back\n\tif(p.norm()<q.norm())return 3; // a--b--c online_front \n\treturn 4;// a--c--b on_segment\n}\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point a,Point b):a(a),b(b){}\n\tbool on(Point q){\n\t\treturn (a-q).det(b-q)==0; \n\t}\n\t// folloing 2 functions verified AOJ CGL_2_A\n\tbool is_parallel(Line l){return (a-b).det(l.a-l.b)==0;}\n\tbool is_orthogonal(Line l){return (a-b).dot(l.a-l.b)==0;}\n\tPoint intersection(Line l){\n\t\t//assert(!is_parallel(l));\n\t\treturn a+(b-a)*((l.b-l.a).det(l.a-a)/(l.b-l.a).det(b-a));\n\t}\n\t// projection of p to this line\n\t// verified AOJ CGL_1_A\n\tPoint projection(Point p){\n\t\treturn (b-a)*((b-a).dot(p-a)/(b-a).norm2())+a;\n\t}\n\t// reflection point of p onto this line\n\t// verified AOJ CGL_1_B\n\tPoint refl(Point p){\n\t\tPoint proj = projection(p);\n\t\treturn p+((proj-p)*2.0);\n\t}\n};\nstruct Segment{\n\tPoint a,b;\n\tSegment(){}\n\tSegment(Point a,Point b):a(a),b(b){}\n\tLine line(){\n\t\treturn Line(a,b);\n\t}\n\tbool on(Point q){\n\t\treturn ((a-q).det(b-q)==0&&(a-q).dot(b-q)<=0); \n\t}\n\tbool is_intersect(Segment s){\n\t\t//if(a.x>b.x)swap(a,b);\n\t\t//if(s.a.x>s.b.x)swap(s.a,s.b);\n\t\tif(line().is_parallel(s.line())){\n\t\t\tif(on(s.a)||on(s.b))return true;\n\t\t\tif(s.on(a)||s.on(b))return true;\n\t\t\treturn false;\n\t\t}\n\t\tPoint p = line().intersection(s.line());\n\t\tif(on(p)&&s.on(p))return true;\n\t\telse return false;\n\t}\n\tbool is_intersect(Line l){\n\t\tif(a.x>b.x)swap(a,b);\n\t\tif(l.a.x>l.b.x)swap(l.a,l.b);\n\t\tPoint k = line().intersection(l);\n\t\tif((a.x<=k.x)&&(k.x<=b.x))return true;\n\t\telse return false;\n\t}\n};\n\ntypedef vector<Point> Polygon;\n\n// for input\nPoint input_point(){\n\tPoint p;\n\tcin >> p.x >> p.y;\n\treturn p;\n}\nSegment input_segment(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Segment(a,b);\n}\nLine input_line(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Line(a,b);\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tSegment a = input_segment();\n\t\tSegment b = input_segment();\n\t\tif(a.is_intersect(b))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nint main(){\n\tint T,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&T);T--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL A(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL B(P(x1,y1),P(x2,y2));\n\t\tprintf(\"%d\\n\",intersectSS(A,B));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\nstruct Line : public vector<int>\n{\n  Line(P a=P(), P b=P()) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef Line Segment;\n\n#define EPS (1e-7)\n\nbool operator < (P const& a, P const& b) {\n  return (a.real() != a.real()) ? a.real() < b.real() : a.imag() < b.imag();\n}\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\nP projection_point(P const& a, P const& b, P const& c) {\n  double k = dot(b-a, c-a) / norm(b-a);\n  return a+k*(b-a);\n}\n\nP reflection_point(P const& a, P const& b, P const& c) {\n  return c + 2.*(projection_point(a, b, c) - c);\n}\n\nbool is_parallel(Segment const& s, Segment const& t) {\n  return abs(cross(s[1]-s[0], t[1]-t[0])) < EPS;\n}\n\nbool is_orthogonal(Segment const& s, Segment const& t) {\n  return abs(dot(s[1]-s[0], t[1]-t[0])) < EPS;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return +1; // counter clockwise\n  if(cross(b, c) < 0) return -1;  // clockwise\n  if(dot(b, c) < 0) return +2;    // c-a-b\n  if(norm(b) < norm(c)) return -2;  // a-b-c\n  return 0; // on segment\n}\n\nbool is_intersect_ss(Segment s, Segment t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0\n         && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main () {\n  \n  int q; cin >> q;\n  for(;q--;) {\n    Segment s, t;\n    cin >> s[0].real() >> s[0].imag();\n    cin >> s[1].real() >> s[1].imag();\n    cin >> t[0].real() >> t[0].imag();\n    cin >> t[1].real() >> t[1].imag();\n    \n    cout << is_intersect(s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline void input(P &p){D x,y;cin >> x >> y;p={x,y};}\n// ???????????¬????????¨???\n\n// ccw\nenum CCW{\n\tLEFT = 1,\n\tRIGHT = 2,\n\tBACK = 4,\n\tFRONT = 8,\n\tMID = 16,\n\tON=FRONT|BACK|MID\n};\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n\ta -= base; b -= base;\n\tif (ep(a, b) > 0)\n\t\treturn LEFT;    // counter clockwise\n\tif (ep(a, b) < 0)\n\t\treturn RIGHT;   // clockwise\n\tif (ip(a, b) < 0)\n\t\treturn BACK;    // b--base--a on line\n\tif (norm(a) < norm(b))\n\t\treturn FRONT;   // base--a--b on line\n\t// otherwise\n\treturn MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ??????\nP pLL(L a,L b){ return a.s+vec(a)*ep(vec(b),b.s-a.s)/ep(vec(b),vec(a));}\n\n\n// ?????¨??´?????¨????????¢??£???????????????\n\nB iLL(L a,L b){return !ipar(a,b);}\nB eqL(L a,L b){return !iLL(a, b) && ep(vec(a), b.s - a.s)==0;}\nB iLS(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) <= 0;}\nB iLSs(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) < 0;}\nB iSS(L a,L b){\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a,L b) {\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ?????¨??´?????¨????????¢??£????????¢\n\nD dLP(L l,P p){return abs( ep(vec(l),p-l.s) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.s)) <= 0) return abs(p - s.s);\n\tif (sig( ip(-vec(s), p - s.t)) <= 0) return abs(p - s.t);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b)?0:dLP(a,b.s);}\nD dLS(L a,L b){ return iLS(a,b)?0:min(dLP(a, b.s),dLP(a, b.t));}\nD dSS(L a,L b){ return iSS(a,b)?0:\n\tmin({ dSP(a,b.s),dSP(a,b.t),dSP(b,a.s),dSP(b,a.t)});}\n\n\nint main(void){\n\tint q;\n\tcin >> q;\n\tcout.precision(10);\n\trep(loop,q){\n\t\tL line[2];\n\t\trep(i,2){\n\t\t\tinput(line[i].s);\n\t\t\tinput(line[i].t);\n\t\t}\n\t\tint ans=0;\n\t\tif(iSS(line[0],line[1])) ans=1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(Point p)\n  {\n    return Point(x + p.x, y + p.y);\n  }\n  Point operator-(Point p)\n  {\n    return Point(x - p.x, y - p.y);\n  }\n  Point operator*(double a)\n  {\n    return Point(a * x, a * y);\n  }\n  Point operator/(double a)\n  {\n    return Point(x / a, y / a);\n  }\n\n  double abs()\n  {\n    return sqrt(norm());\n  }\n  double norm()\n  {\n    return x * x + y * y;\n  }\n\n  bool operator<(const Point &p) const\n  {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator==(const Point &p) const\n  {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n\n  void print()\n  {\n    printf(\"%.10f %.10f\\n\", x, y);\n  }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b)\n{\n  return a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b)\n{\n  return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment\n{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint projection(Line l, Point p)\n{\n  return l.p1 + (l.p2 - l.p1) * (dot(p - l.p1, l.p2 - l.p1) / (l.p2 - l.p1).norm());\n}\n\nPoint reflection(Line l, Point p)\n{\n  Point x = projection(l, p);\n  return p + (x - p) * 2;\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) > EPS)\n  {\n    return COUNTER_CLOCKWISE;\n  }\n  if (cross(a, b) < -EPS)\n  {\n    return CLOCKWISE;\n  }\n  if (dot(a, b) < -EPS)\n  {\n    return ONLINE_BACK;\n  }\n  if (a.norm() < b.norm())\n  {\n    return ONLINE_FRONT;\n  }\n  return ON_SEGMENT;\n}\n\nbool is_parallel(Line l1, Line l2)\n{\n  Vector a = l1.p2 - l1.p1, b = l2.p2 - l2.p1;\n  return equals(cross(a, b), 0);\n}\n\nbool is_orthogonal(Line l1, Line l2)\n{\n  Vector a = l1.p2 - l1.p1, b = l2.p2 - l2.p1;\n  return equals(dot(a, b), 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  Point p0 = s1.p1, p1 = s1.p2, p2 = s2.p1, p3 = s2.p2;\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nint main()\n{\n  int q;\n  cin >> q;\n  vector<bool> ans;\n  rep(i, q)\n  {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n    Segment s1 = {Point{x0, y0}, Point{x1, y1}}, s2 = {Point{x2, y2}, Point{x3, y3}};\n    ans.push_back(intersect(s1, s2));\n  }\n  rep(i, q) cout << ans.at(i) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8, pi = acos(-1.0);\nbool eq(ld a, ld b){return (abs(b-a)<eps);}\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\nint ccw(Point a, Point b, Point c){\n  b-=a;c-=a;\n  if(cross(b,c)>eps) return 1;//countor_crockwise\n  if(cross(b,c)<-eps) return -1;//crockwise\n  if(dot(b,c)<0) return 2;//c,a,b\n  if(norm(b)<norm(c)) return -2;//a,b,c\n  return 0;//a,c,b\n}\n\nclass Line{\npublic:\n  Point a,b;\n};\n\nld triangle(Point p1, Point p2, Point p3){\n  return cross(p2-p1, p3-p1);\n}\n\nint intersect(Line l1, Line l2){\n  if(l1.a==l2.a||l1.a==l2.b||l1.b==l2.a||l1.b==l2.b){return 1;}\n  if(eq(cross(l1.b-l1.a,l2.b-l2.a),0)){\n    if(ccw(l1.a,l1.b,l2.a)==0||ccw(l1.a,l1.b,l2.b)==0||ccw(l2.a,l2.b,l1.a)==0||ccw(l2.a,l2.b,l1.b)==0)\n      return 1;\n    else\n      return 0;\n  }\n  ld a = triangle(l1.a, l1.b, l2.a) * triangle(l1.a, l1.b, l2.b);\n  ld b = triangle(l2.a, l2.b, l1.a) * triangle(l2.a, l2.b, l1.b);\n  return a <= 0 && b <= 0 ? 1 : 0;\n}\n\nint main(){\n  int q;cin>>q;\n  REP(i,q){\n    ld real, imag;\n    Line s1,s2;\n    cin>>real>>imag;\n    s1.a = Point(real,imag);\n    cin>>real>>imag;\n    s1.b = Point(real,imag);\n    cin>>real>>imag;\n    s2.a = Point(real,imag);\n    cin>>real>>imag;\n    s2.b = Point(real,imag);\n    cout<<intersect(s1,s2)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verifyed\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//?????????????????? verifyed\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    for(int j=0;j<n;j++){\n        P p[4];\n        for(int i=0;i<4;i++){\n            int x,y;\n            cin>>x>>y;\n            p[i] = P(x,y);\n        }\n        cout<<intersect(p[0],p[1],p[2],p[3])<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n#include <map>\n#include <string>\n#include <valarray>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <list>\n\n\nusing namespace std;\n\nconst double ESP = 1E-8;\n\nstruct Point\n{\n    //friends\n    friend Point operator*(double c, const Point & p);\n    friend ostream & operator<<(ostream & os, const Point & p);\n    friend istream & operator>>(istream & is, Point & p);\n    friend double cross(const Point & p1, const Point & p2);\n\n  \n    //members\n    double x, y;\n\n    Point() {};\n    Point(double x, double y): x(x), y(y) {};\n\n    Point operator-(const Point & p) const\n    {\n        // Point difference = {x - p.x, y - p.y};\n        // return difference;\n        return Point(x - p.x, y - p.y);\n    }\n\n    double operator*(const Point & p) const\n    {\n        return x*p.x + y*p.y;\n    }\n\n    Point operator*(double c) const\n    {\n        // Point p = {c*x, c*y};\n        // return p;\n        return Point(c*x, c*y);\n    }\n\n    Point operator+(const Point & p) const\n    {\n        // Point sum = {x+p.x, y+p.y};\n        // return sum;\n        return Point(x+p.x, y+p.y);\n    }\n\n    Point projection(const Point & p1, const Point & p2) const\n    {\n        Point a(*this-p1), b(p2-p1);\n        return (a*b)/(b*b)*b+p1;\n    }\n\n    Point reflection(const Point & p1, const Point & p2) const\n    {\n        return this->projection(p1, p2)*2 - *this;\n    }\n\n};\n\n\nstruct Line\n{\n    Line() = default;\n    Line(const Point & p1, const Point & p2): directional(p1-p2), point_online(p1) {}; \n    Point directional, point_online;\n};\n\nstruct Segment\n{\n    Segment() = default;\n    Segment(const Point & p1, const Point & p2): first_end(p1), second_end(p2), directional(p2-p1), length(sqrt(directional*directional)) {/*norm(p2-p1);*/};\n\n    Point first_end, second_end, directional;\n    double length;\n};\n\n\n//function related with point\ndouble norm(const Point & p);\nbool check_clockwise(const Point & p0, const Point & p1, const Point & p2);\nbool check_counter_clockwise(const Point & p0, const Point & p1, const Point & p2);\nbool check_online_back(const Point & p0, const Point & p1, const Point & p2);\nbool check_online_front(const Point & p0, const Point & p1, const Point & p2);\nbool check_on_segment(const Point & p0, const Point & p1, const Point & p2);\n// bool check_parallel(const Point & p0, const Point & p1, const Point & p2, const Point & p3);\n\n\n//functions related with lines\nbool check_parallel(const Line & l1, const Line & l2);\nbool check_orthogonal(const Line & l1, const Line & l2);\nbool check_intersection(const Segment & s1, const Segment & s2);\n\n\n\nint main()\n{\n    Point p0, p1, p2, p3;\n\n    int q;\n    cin >> q;\n\n    int result;\n\n    for (int i = 0; i < q; i++)\n    {\n        cin >> p0 >> p1 >> p2 >> p3;\n        if (check_intersection(Segment(p0, p1), Segment(p2, p3)))\n            result = 1;\n        else\n            result = 0;\n\n        cout << result << endl;\n    }\n\n\n    // vector<string> results(q);\n    // for (int i = 0; i < q; i++)\n    // {\n    //     cin >> p2;\n    //     if (check_counter_clockwise(p0, p1, p2))\n    //         results[i] = \"COUNTER_CLOCKWISE\";\n    //     else if (check_clockwise(p0, p1, p2))\n    //         results[i] = \"CLOCKWISE\";\n    //     else if (check_online_back(p0, p1, p2))\n    //         results[i] = \"ONLINE_BACK\";\n    //     else if (check_online_front(p0, p1, p2))\n    //         results[i] = \"ONLINE_FRONT\";\n    //     else if (check_on_segment(p0, p1, p2))\n    //         results[i] = \"ON_SEGMENT\";\n    // }\n\n    // for (auto x: results)\n    //     cout << x << endl;\n\n}\n\n\n//friends\nPoint operator*(double c, const Point & p)\n{\n    return p*c;\n}\n\nostream & operator<<(ostream & os, const Point & p) \n{\n    os << setprecision(8) << fixed << p.x << ' ' << p.y << endl;\n    return os;\n}\n\nistream & operator>>(istream & is, Point & p)\n{\n    is >> p.x >> p.y;\n    return is;\n}\n\ndouble cross(const Point & p1, const Point & p2)\n{\n    return p1.x*p2.y-p1.y*p2.x;\n}\n\nbool check_counter_clockwise(const Point & p0, const Point & p1, const Point & p2)\n{\n    return cross(p1-p0,p2-p0) > 0;\n}\n\nbool check_clockwise(const Point & p0, const Point & p1, const Point & p2)\n{\n    return cross(p1-p0,p2-p0) < 0;\n}\n\ndouble norm(const Point & p)\n{\n    return sqrt(p*p);\n}\n\nbool check_online_back(const Point & p0, const Point & p1, const Point & p2)\n{\n    Point a(p2-p0), b(p1-p0);\n    double norm_a = norm(a), norm_b = norm(b);\n    return fabs(a*b+norm_a*norm_b)<ESP && fabs(norm_a)>ESP;\n}\n\nbool check_online_front(const Point & p0, const Point & p1, const Point & p2)\n{\n    Point a(p2-p0), b(p1-p0);\n    double norm_a = norm(a), norm_b = norm(b);\n    return fabs(a*b-norm_a*norm_b)<ESP && norm_a>norm_b && fabs(norm_a-norm_b)>ESP;\n}\n\nbool check_on_segment(const Point & p0, const Point & p1, const Point & p2)\n{\n    Point a(p2-p0), b(p1-p0);\n    double norm_a = norm(a), norm_b = norm(b);\n    return fabs(a*b-norm_a*norm_b)<ESP && ((norm_a<norm_b && fabs(norm_a-norm_b)>ESP) || fabs(norm_a-norm_b)<ESP);\n    // double d1=a*b, d2=norm_a*norm_b, d3=fabs(d1-d2);\n    // bool t1 = d3<=ESP, t2=norm_a<norm_b && fabs(norm_a-norm_b)>=ESP, t3=fabs(norm_a-norm_b)<=ESP;\n    // return t1 &&(t2||t3);\n}\n\nbool check_parallel(const Line & l1, const Line & l2)\n{\n    return cross(l1.directional, l2.directional)==0;\n}\n\nbool check_orthogonal(const Line & l1, const Line & l2)\n{\n    return l1.directional*l2.directional==0;\n}\n\nbool check_on_segment(const  Segment & s, const Point & p)\n{\n    return cross(p-s.first_end, p-s.second_end)==0 && max(norm(p-s.first_end), norm(p-s.second_end))-s.length <= ESP;\n}\n\nbool check_intersection(const Segment & s1, const Segment & s2)\n{\n    bool mutually_different_side = \n        check_clockwise(s1.first_end, s1.second_end, s2.first_end) ==\n        check_counter_clockwise(s1.first_end, s1.second_end, s2.second_end) &&\n        check_clockwise(s2.first_end, s2.second_end, s1.first_end) ==\n        check_counter_clockwise(s2.first_end, s2.second_end, s1.second_end) &&\n        cross(s1.directional, s2.directional)!=0;\n         \n        // cross(s1.first_end-s1.second_end, s2.first_end-s1.second_end)==0 ==\n        // cross(s1.first_end-s1.second_end, s2.second_end-s1.second_end)>=0 &&\n        // cross(s2.first_end-s2.second_end, s1.first_end-s2.second_end)>=0 ==\n        // cross(s2.first_end-s2.second_end, s1.second_end-s2.second_end)>=0;\n\n    bool on_segment = \n        check_on_segment(s1, s2.first_end) ||\n        check_on_segment(s1, s2.second_end) ||\n        check_on_segment(s2, s1.first_end) ||\n        check_on_segment(s2, s1.second_end);\n\n    return mutually_different_side || on_segment;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\ndouble distPP(Point p1, Point p2) {\n\treturn (p1 - p2).abs();\n}\n\ndouble distLineP(Line l, Point p) {\n\treturn (project(l, p) - p).abs();\n}\n\ndouble distSegP(Segment s, Point p) {\n\tif (dot(p - s.p1, s.p2 - s.p1) > 0 && dot(p - s.p2, s.p1 - s.p2) > 0) {\n\t\treturn distLineP(s, p);\n\t}\n\telse {\n\t\treturn min(distPP(p, s.p1), distPP(p, s.p2));\n\t}\n}\n\nbool crossPoint(Line l1, Line l2, Point &p) {\n\tif (isParallel(l1, l2)) {\n\t\treturn false;\n\t}\n\telse {\n\t\tdouble alpha = cross(l2.p1 - l1.p1, l2.p1 - l2.p2) / cross(l1.p2 - l1.p1, l2.p1 - l2.p2);\n\t\tp = l1.p1 + (l1.p2 - l1.p1)*alpha;\n\t\treturn true;\n\t}\n}\n\nbool intersect(Segment s1, Segment s2) {\n\tPoint p;\n\tif (!crossPoint(s1, s2, p)) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif (distPP(s1.p1, s1.p2) < distPP(p, s1.p1) + distPP(p, s1.p2)) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\ndouble distSegSeg(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(distSegP(s1, s2.p1), distSegP(s1, s2.p2)), min(distSegP(s2, s1.p1), distSegP(s2, s1.p2)));\n}\n\n//int main() {\n//\tSegment S1, S2;\n//\tint q;\n//\tcin >> q;\n//\tfor (int i = 0; i < q; i++) {\n//\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n//\t\tcout << fixed << setprecision(15);\n//\t\tcout << distSegSeg(S1, S2) << endl;\n//\t}\n//\n//\treturn 0;\n//}\n\nint main() {\n\tSegment S1, S2;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcout << intersect(S1, S2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ-CGL-2-B\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nstruct Segment {\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\n\ndouble getDistance(Segment s1, Segment s2) {\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    // assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    // assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// IN : 2, ON : 1, OUT : 0\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for( int i = 0; i < n; i++ ) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if ( abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if ( a.y > b.y ) swap(a, b);\n        if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n    }\n    return ( x ? 2 : 0 );\n}\n\nsigned main(){\n    int q;\n    cin >> q;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    REP(i,q){\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        cout << intersect(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst double eps=1e-10;\nstruct node\n{\n    double x,y;\n    node operator -(const node &nd)const\n    {\n        return {x-nd.x,y-nd.y};\n    }\n    double operator * (const node &nd)const\n    {\n        return x*nd.x+y*nd.y;\n    }\n};\nstruct line\n{\n    double A,B,C;\n    line(node a,node b)\n    {\n        A=b.y-a.y;\n        B=a.x-b.x;\n        C=b.x*a.y-a.x*b.y;\n    }\n    bool operator ==(const line &L)const\n    {\n        if(abs(A*L.B-B*L.A)<eps&&abs(B*L.C-C*L.B)<eps&&abs(A*L.C-C*L.A)<eps) return 1;\n        return 0;\n    }\n    void show()\n    {\n        printf(\"A=%f,B=%f,C=%f\\n\",A,B,C);\n    }\n};\ndouble X(node aa,node bb)\n{\n    return aa.x*bb.y-aa.y*bb.x;\n}\nint main()\n{\n    int T;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        node a,b,c,d;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&a.x,&a.y\n              ,&b.x,&b.y\n              ,&c.x,&c.y\n              ,&d.x,&d.y);\n        if(a.x>b.x) swap(a,b);\n        if(c.x>d.x) swap(c,d);\n        line L1(a,b),L2(c,d);\n       // L1.show();\n       // L2.show();\n        if(L1==L2)\n        {\n            //puts(\"重合\");\n            if((c-a)*(c-b)<=0||(d-a)*(d-b)<=0||(a-c)*(a-d)<0||(b-c)*(b-d)<0)\n            {\n                puts(\"1\");\n            }\n            else\n                puts(\"0\");\n        }\n        else if(abs(L1.A*L2.B-L1.B*L2.A)<eps)\n        {\n            //puts(\"平行\");\n            puts(\"0\");\n        }\n        else\n        {\n            //puts(\"直线相交\");\n            double xx=(L2.C*L1.B-L1.C*L2.B)/(L1.A*L2.B-L2.A*L1.B);\n            double yy=(L1.A*L2.C-L2.A*L1.C)/(L2.A*L1.B-L1.A*L2.B);\n            //printf(\"%f %f\\n\",xx,yy);\n            node t;\n            t.x=xx,t.y=yy;\n            if((t-a)*(t-b)<=0&&(t-c)*(t-d)<=0) puts(\"1\");\n            else puts(\"0\");\n\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum DIRECTION{CLOCKWISE, COUNTER_CLOCKWISE, ONLINE};\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nDIRECTION get_direction(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    return ONLINE;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_direction(s1.p1, s2) == get_direction(s1.p2, s2)) {\n        return false;\n    }\n    if (get_direction(s2.p1, s1) == get_direction(s2.p2, s1)) {\n        return false;\n    }\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr double EPS = 1e-10;\ntypedef complex<double> Point;\ntypedef Point Vector;\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\ntypedef pair<Point, double> Circle;\ntypedef vector<Point> Polygon;\ndouble dot(Vector a, Vector b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\ndouble cross(Vector a, Vector b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\nPoint project(Line l, Point p){\n\tVector base = l.second - l.first;\n\tbase /= abs(base);\n\tdouble r = dot(p - l.first, base);\n\treturn l.first + r * base;\n}\nPoint reflect(Line l, Point p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\nint ccw(Point p0, Point p1, Point p2){\n\tVector v = p1 - p0, w = p2 - p0;\n\tif(cross(v, w) > EPS) return 1; // COUNTER_CLOCKWISE\n\tif(cross(v, w) < -EPS) return -1; // CLOCKWISE\n\tif(dot(v, w) < -EPS) return 2; // ONLINE p2 - p0 - p1\n\tif(norm(v) + EPS < norm(w)) return -2; // ONLINE p0 - p1 - p2\n\treturn 0; // ONLINE p0 - p1 - p2\n}\nbool isOrthogonal(Vector v1, Vector v2){\n\tdouble t = abs(dot(v1, v2));\n\treturn t <= EPS;\n}\nbool isParallel(Vector v1, Vector v2){\n\tdouble t = abs(cross(v1, v2));\n\treturn t <= EPS;\n}\nbool intersect(Segment s1, Segment s2){\n\tint t = ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second);\n\tint u = ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second);\n\treturn (t == 0 || t == -1 || t == -4) && (u == 0 || u == -1 || u == -4);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tdouble x[4], y[4];\n\t\tfor(int i=0; i<4; ++i) cin >> x[i] >> y[i];\n\t\tPoint p0(x[0], y[0]), p1(x[1], y[1]), p2(x[2], y[2]), p3(x[3], y[3]);\n\t\tif(intersect(Segment(p0, p1), Segment(p2, p3))) cout << 1 << \"\\n\";\n\t\telse cout << 0 << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\nint n;\n\nstruct Point\n{\n    double x, y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n};\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\nPoint p0,p1,p2,p3;\nvoid solve()\n{\n   if(cross(p1-p0,p2-p0)*cross(p1-p0,p3-p0)<0||cross(p3-p2,p0-p2)*cross(p3-p2,p1-p2)<0) printf(\"1\\n\");\n   else printf(\"0\\n\");\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p0.x,&p0.y,&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y);\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n} \nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tP p[4];\n\t\tPIN(p,4);\n\t\tL a=L(p[0],p[1]);\n\t\tL b=L(p[2],p[3]);\n\t\tcout<<intersectSS(a,b)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/19\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    elem_t r = dot(hypo, base) / norm(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief  絶対許容誤差(absolute tolerance)を比較します\n *\n * @note   2つの浮動小数点数値が等しいかどうか比較するためのイプシロン許容誤差の利用は、\n *         イプシロンの値が固定されているので、絶対許容誤差(absolute tolerance)と呼ばれている\n *         絶対許容誤差の欠点は適切なイプシロンの値を見つけるのが困難なことである\n *         イプシロンの値は入力データの値の範囲、および使用している浮動小数点の形式に依存する\n *         浮動小数点数の範囲全体に対するイプシロンの値を1つだけ選ぶことは不可能である\n *         xおよびyの値が非常に小さな(互いに等しくない)値の場合は、その差は常にイプシロンよりも小さくなる可能性があり、\n *         逆に大きな値の場合は、その差はイプシロンよりも常に大きくなるかもしれない. 別の見方として、\n *         判定している数が大きくなればなるほど、絶対値による判定が成立するために必要な桁数はどんどん大きくなっていく\n *\n * @note   固定されているイプシロンよりも数値が十分大きくなったとき、数値が正確に等しくない限り判定は常に失敗する\n *         これは通常、意図したことではない. 絶対許容誤差は数値の桁数の大きさが予めわかっており、\n *         許容誤差の値をそれに応じて設定することができる場合にのみ利用するべきである\n */\nstatic inline bool absolute_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps;\n}\n\n\n/**\n * @brief  相対許容誤差(relatice tolerance)を比較します\n *\n * @note   基本的な考え方はある数を別の数によって除算し、その結果がどのくらい1に近づいているかを見るというものである\n *\n *\n * @note   |x| <= |y|を仮定すると、判定は以下のようになる\n *           if (Abs(x/y - 1.0) <= epsilon)...\n *         これは以下のように書き直せる\n *           if (Abs((x - y) / y) <= epsilon)...\n *         コストのかかる除算を避け、ゼロによる除算のエラーから守るために、後者の式の両辺にAbs(y)を乗算して、以下のように単純化する\n *           if (Abs(x - y) <= epsilon * Abs(y))...\n *         仮定|x| <= |y|を取り除くと、式は最終的に以下のようになる\n *           if (Abs(x - y) <= epsilon * Max(Abs(x), Abs(y)))...  // 相対許容誤差の比較\n *\n *\n * @note   比較において相対的な判定は「より小さいか等しい」であり、「より小さい」ではないことは重要である\n *         もしそうでなければ、両方の数が正確にゼロだった場合、判定は失敗する。相対的な判定も問題がないわけではない\n *         判定の式はAbs(x)およびAbs(y)が1よりも大きいときには、望み通りの働きをするが、それらの数値が1よりも小さいときは、\n *         イプシロンはより小さくないと効力がなくなってしまい、それらの数値が小さくなるほど式を成立させるのに必要な桁数はより多く必要になる         \n */\nstatic inline bool relative_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max(std::fabs(x), std::fabs(y));\n}\n\n\n/**\n * @brief  上記2つの判定を1つに結合させる\n * @note   数値の絶対値が1よりも大きい場合には、相対的な判定を用い、1よりも小さい場合には、絶対的な判定を用いる\n * @attention  この式はMax()が機械語による命令によって利用できない場合には高価な計算になる可能性がある\n */\nstatic inline bool combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max({ std::fabs(x), std::fabs(y), static_cast<elem_t>(1.0) });\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(elem_t x, elem_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orient orientation(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orient::cw;    }  // クロス積(p1-p0)x(p2-p0)が正の場合、cw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orient::ccw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、ccw ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orient::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(norm(p1), norm(p2)))       { return orient::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orient::on;\n}\n\n\n/**\n * @brief 2点(p1, p2)を原点p0に関する偏角に従って、比較を行う\n */\nstatic inline int polar_angle_cmp(const point& p1, const point& p2)\n{\n    const point p0(0, 0);\n    switch(orientation(p0, p1, p2)) {\n      case orient::cw    : return 1;\n      case orient::ccw   : return -1;\n      case orient::back  : return 1;\n      case orient::front : return -1;\n      case orient::on    : return 1;\n    }\n    return 0;\n}\n\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\nelem_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{\n    elem_t xi = pi.x, xj = pj.x, xk = pk.x;\n    elem_t yi = pi.y, yj = pj.y, yk = pk.y;\n    \n    return std::min(xi, xj) <= xk && xk <= std::max(xi, xj)\n        && std::min(yi, yj) <= yk && yk <= std::max(yi, yj);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    elem_t d1 = direction(p3, p4, p1);\n    elem_t d2 = direction(p3, p4, p2);\n    elem_t d3 = direction(p1, p2, p3);\n    elem_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Vector\n{\npublic:\n\tdouble x,y;\n\tVector(double x=0,double y=0):x(x),y(y){}\n\t\n\tVector operator + (Vector p){return Vector(x+p.x,y+p.y);}\n\tVector operator - (Vector p){return Vector(x-p.x,y-p.y);}\n\tVector operator * (double a){return Vector(x*a,y*a);}\n\tVector operator / (double a){return Vector(x/a,y/a);}\n\t\n\tdouble abs(){return sqrt(norm());}\n\tdouble norm(){return x*x+y*y;}\n\t\n\tbool operator <  (const Vector &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator == (const Vector &p)const{return fabs(x-p.x)<EPS && fabs(y-p.y<EPS);}\n};\n\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-b.x*a.y;}\n\nint ccw(Vector p0,Vector p1,Vector p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;//???????¨???????\n\tif(cross(a,b)<-EPS)return -1;//????¨???????\n\tif(dot(a,b)<-EPS)return 2;//p0?????????\n\tif(a.norm()<b.norm())return -2;//p1????\\\\\n\treturn 0;//?????????\n}\n\nbool intersect(Vector p0,Vector p1,Vector p2,Vector p3)\n{\n\treturn (ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0);\n}\n\nint main()\n{\n\tVector p0,p1,p2,p3;\n\tint n;cin>>n;\n\tREP(i,n)\n\t{\n\t\tcin>>p0.x>>p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n\t\tbool j=intersect(p0,p1,p2,p3);\n\t\tcout<<j<<endl;\n\t}\n\treturn 0;\n}\n\n/*\nint main()\n{\n\tint n;cin>>n;\n\tvtr p[4];\n\tcout<<fixed<<setprecision(10);\n\tREP(i,n)\n\t{\n\t\tREP(j,4)cin>>p[j].x>>p[j].y;\n\t\t//????????????\n\t\tdouble a,b,c,d;\n\t\tif(dotp(minusvtr(p[1],p[0]),minusvtr(p[2],p[0]))>0&&dotp(minusvtr(p[0],p[1]),minusvtr(p[2],p[1]))>0)\n\t\t{\n\t\t\ta=abscrossp(minusvtr(p[1],p[0]),minusvtr(p[2],p[0]))/absvtr(minusvtr(p[1],p[0]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta=min(absvtr(minusvtr(p[2],p[0])),absvtr(minusvtr(p[2],p[1])));\n\t\t}\n\t\t\n\t\tif(dotp(minusvtr(p[1],p[0]),minusvtr(p[3],p[0]))>0&&dotp(minusvtr(p[0],p[1]),minusvtr(p[3],p[1]))>0)\n\t\t{\n\t\t\tb=abscrossp(minusvtr(p[1],p[0]),minusvtr(p[3],p[0]))/absvtr(minusvtr(p[1],p[0]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb=min(absvtr(minusvtr(p[3],p[0])),absvtr(minusvtr(p[3],p[1])));\n\t\t}\n\t\t\n\t\tif(dotp(minusvtr(p[3],p[2]),minusvtr(p[0],p[2]))>0&&dotp(minusvtr(p[2],p[3]),minusvtr(p[0],p[3]))>0)\n\t\t{\n\t\t\tc=abscrossp(minusvtr(p[3],p[2]),minusvtr(p[0],p[2]))/absvtr(minusvtr(p[3],p[2]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc=min(absvtr(minusvtr(p[0],p[2])),absvtr(minusvtr(p[0],p[3])));\n\t\t}\n\t\t\n\t\tif(dotp(minusvtr(p[3],p[2]),minusvtr(p[1],p[2]))>0&&dotp(minusvtr(p[2],p[3]),minusvtr(p[1],p[3]))>0)\n\t\t{\n\t\t\td=abscrossp(minusvtr(p[3],p[2]),minusvtr(p[1],p[2]))/absvtr(minusvtr(p[3],p[2]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\td=min(absvtr(minusvtr(p[1],p[2])),absvtr(minusvtr(p[1],p[3])));\n\t\t}\n\t\tcout<<min(min(a,b),min(c,d))<<endl;\n\t}\n\treturn 0;\n}*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) { };\n\tPoint operator + (Point& p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point& p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double k) { return Point(x * k, y * k); }\n\tPoint operator / (double k) { return Point(x / k, y / k); }\n\tdouble Abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n};\n\ndouble dot(Vector& a, Vector& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector& a, Vector& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = -1;\nstatic const int CLOCKWISE = 1;\nstatic const int ON_SEGMENT = 0;\nstatic const int ONLINE_BACK = -2;\nstatic const int ONLINE_FRONT = 2;\n\nSegment s1, s2;\nint T;\n\nint Position(Vector a, Vector b) {\n\tif (cross(a, b) > 0) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < 0) return CLOCKWISE;\n\tif (dot(a, b) < 0) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Segment s1, Segment s2) {\n\tint a = Position(s1.p2 - s1.p1, s2.p1 - s1.p1) * Position(s1.p2 - s1.p1, s2.p2 - s1.p1);\n\tint b = Position(s2.p2 - s2.p1, s1.p1 - s2.p1) * Position(s2.p2 - s2.p1, s1.p2 - s2.p1);\n\tif (a <= 0 && b <= 0) return true;\n\telse return false;\n}\n\nint main() {\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tif (intersect(s1, s2)) cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n    Point(){};\n    Point(double x, double y):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nclass Segment{\npublic:\n    Point p1, p2;\n    Segment(){};\n    Segment(Point p1, Point p2):p1(p1), p2(p2){};\n};\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(){};\n    Circle(Point c, double r):c(c), r(r){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble norm(Point p){return p.x * p.x + p.y * p.y;}\ndouble abs(Point p){return sqrt(norm(p));};\n\ndouble dot(Point a, Point b){\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(Point a, Point b){\n    return a.x * b.y - a.y * b.x;\n}\nbool isorthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isorthognoal(Point a1, Point a2, Point b1, Point b2){\n    return equals(cross(a1 - a2, b1 - b2), 0.0);\n}\nbool isparallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isparallel(Point a1, Point a2, Point b1, Point b2){\n    return equals(cross(a1 - a2, b1 - b2), 0.0);\n}\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\ndouble getdistance(Point a, Point b){\n    return abs(a - b);\n}\ndouble getdistancelp(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getdistancesp(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0)\n        return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0)\n        return abs(p - s.p2);\n    return getdistancelp(s, p);\n}\n\nbool isorthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2  - s1.p1, s2.p2 - s1.p1), 0.0);\n}\nbool isparallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nstatic const int counter_clockwise = 1;\nstatic const int clockwise = -1;\nstatic const int online_back = 2;\nstatic const int online_front = -2;\nstatic const int on_segment = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return counter_clockwise;\n    if(cross(a, b) < -EPS) return clockwise;\n    if(dot(a,b) < -EPS) return online_back;\n    if(norm(a) < norm(b)) return online_front;\n    return on_segment;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n        ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getdistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))\n        return 0.0;\n    return min(min(getdistancesp(s1, s2.p1), getdistancesp(s1, s2.p2)),\n        min(getdistancesp(s2, s1.p1), getdistancesp(s2, s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point>getcrosspoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr -c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p){return atan2(p.y, p.x);}\nVector polar(double a, double r){return Point(cos(r) * a, sin(r) * a);}\n\npair<Point, Point>getcrosspoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i ++){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS)\n            x !=x;\n    }\n    return (x ? 2 : 0);\n}\nint cmp(Point a, Point b){\n    return (a.y < b.y || (a.y == b.y  && a.x < b.x));\n}\nPolygon andrewscan(Polygon s){\n    Polygon u, l;\n    int len = s.size();\n    if(len < 3) return s;\n\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[len - 1]);\n    l.push_back(s[len - 2]);\n\n    for(int i = 2; i < len; i ++){\n        for(int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) >= 0; i --)\n            u.pop_back();\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size() - 2; i >= 1; i --)\n        l.push_back(u[i]);\n\n    return l;\n}\n\nint main(){\n    int q;\n    Segment s1, s2;\n    scanf(\"%d\", &q);\n    while(q --){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n            &s1.p1.x, &s1.p1.y, &s1.p2.x, &s1.p2.y,\n            &s2.p1.x, &s2.p1.y, &s2.p2.x, &s2.p2.y);\n        printf(\"%d\\n\", intersect(s1, s2));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{ONLINE_BACK = -2, CLOCKWISE = -1, ON_SEGMENT = 0,\n              COUNTER_CLOCKWISE = 1, ONLINE_FRONT = 2};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_pos(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_pos(s2.p1, s1) * get_pos(s2.p2, s1) > 0) return false;\n    if (get_pos(s1.p1, s2) * get_pos(s1.p2, s2) > 0) return false;\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0.0, double y = 0.0): x(x), y(y) {};\n\n    Point operator + (Point &p) {return Point(x + p.x, y + p.y);}\n    Point operator - (Point &p) {return Point(x - p.x, y - p.y);}\n    Point operator * (double k) {return Point(x * k, y * k);}\n    Point operator / (double k) {return Point(x / k, y / k);}\n\n    double norm(void) {return x * x + y * y;}\n    double abs(void) {return sqrt(norm());}\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    double dot(Point a) {\n        return x * a.x + y * a.y;\n    }\n\n    double cross(Point a) {\n        return x * a.y - y * a.x;\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n    Point p1, p2;\n};\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (a.cross(b) > EPS) return COUNTER_CLOCKWISE;\n    if (a.cross(b) < -EPS) return CLOCKWISE;\n    if (a.dot(b) < -EPS) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n\nint main(void) {\n    int x1, x2, x3, x4, y1, y2, y3, y4, q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d %d %d %d %d\",\n                &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n        int ret = intersect(Point(x1, y1), Point(x2, y2),\n                            Point(x3, y3), Point(x4, y4));\n        printf(\"%d\\n\", ret);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nconst double eps = 1e-15;\n\nbool IsEq(double d1, double d2)\n{\n    if (d1 - d2 > -eps && d1 - d2 < eps){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nclass Point2D {\npublic:\n    double x, y;\n    Point2D() : x(0), y(0) {}\n    Point2D(double _x, double _y) : x(_x), y(_y) {}\n    virtual ~Point2D() {}\n};\n\nistream& operator >> (istream& input, Point2D& P)\n{\n    input >> P.x >> P.y;\n    return input;\n}\n\nclass Segment {\npublic:\n    Point2D P, Q;\n    Segment() {}\n    Segment(const Point2D& _P, const Point2D& _Q) : P(_P), Q(_Q) {}\n};\n\nistream& operator >> (istream& input, Segment& Seg)\n{\n    input >> Seg.P >> Seg.Q;\n    return input;\n}\n\nclass Vector2D : public Point2D {\npublic:\n    Vector2D(const Point2D& P) : Point2D(P) {}\n    Vector2D(const Segment Seg) : Point2D(Seg.Q.x - Seg.P.x, Seg.Q.y - Seg.P.y) {}\n    Vector2D(const Point2D Start, Point2D End) : Point2D(End.x - Start.x, End.y - Start.y) {}\n    double InnerProd(const Vector2D Vec) const\n    {\n        return x * Vec.x + y * Vec.y;\n    }\n    double OuterProd(const Vector2D Vec) const\n    {\n        return x * Vec.y - y * Vec.x;\n    }\n    double Length() const\n    {\n        return sqrt((*this).InnerProd(*this));\n    }\n};\n\ndouble Dist(const Point2D P, const Segment Seg)\n{\n    Vector2D V1(Seg);\n    Vector2D V2(Seg.P, P);\n    return V1.InnerProd(V2) / V1.Length();\n}\n\nbool IsPara(Segment Seg1, Segment Seg2)\n{\n    Vector2D V1(Seg1), V2(Seg2);\n    return IsEq(V1.OuterProd(V2), 0.);\n}\n\nbool IsIntersect(Segment Seg1, Segment Seg2) {\n    Vector2D P1(Seg1.P), P2(Seg2.P);\n    Vector2D V1(Seg1), V2(Seg2);\n    if (!IsPara(Seg1, Seg2)) {\n        double t = (P2.OuterProd(V2) - P1.OuterProd(V2)) / V1.OuterProd(V2);\n        double s = (P2.OuterProd(V1) - P1.OuterProd(V1)) / V1.OuterProd(V2);\n        return t > -eps && t < 1 + eps && s > -eps && s < 1 + eps;\n    } else {\n        return false;\n        //if (!IsEq(Dist(P1, Seg2), 0.)) return false;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int q;\n    Segment Seg1, Seg2;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> Seg1 >> Seg2;\n        if (IsIntersect(Seg1, Seg2)) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \n \nusing namespace std;\n \ntypedef double Real;\n \nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n \nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n \nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n \n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n \n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n \n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n  if (b.cross(c) > 0)   return +1;       // counter clockwise\n  if (b.cross(c) < 0)   return -1;       // clockwise\n  if (b.dot(c) < 0)     return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;    // a--b--c on line\n  return 0;                              // a--c--b on line\n}\n \nstruct Line{\n  Point a,b;\n \n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n \n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n  //平行でない前提\n  Point intersectionPoint(Line l){\n    return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n  }\n \n};\n \nstruct Segment: public Line{\n  Point a,b;\n   \n  bool on(Point c){return ccw(a,b,c)==0;}\n  bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n \n  Real dist(Point c){\n    if((b-a).dot(c-a)<EPS)return c.dist(a);\n    if((a-b).dot(c-b)<EPS)return c.dist(b);\n    return abs((b-a).cross(c-a))/b.dist(a);    \n  }\n \n  Point intersectionPoint(Segment s){\n    Point q=s.b-s.a;\n    Real d1=abs(q.cross(a-s.a));\n    Real d2=abs(q.cross(b-s.a));\n    Real t=d1/(d1+d2);\n    return a+(b-a)*t;\n  }\n \n  //この線分が直線lの上に載っていない前提\n  bool isIntersection(Line l){\n    int p=ccw(a,b,l.a);\n    int q=ccw(a,b,l.b);\n    return (p==1 && q==-1)||(p==-1 && q==1);\n  }\n \n  bool isIntersection(Segment s){\n    return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n        ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n  }\n};\n \nint main(void){\n \n  int q;\n  cin >> q;\n  while(q--){\n    Segment a,b;\n    cin >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n    cin >> b.a.x >> b.a.y >> b.b.x >> b.b.y;\n    cout << a.isIntersection(b) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nnamespace geometry2d {\n\n\t//eps　浮動小数点誤差\n\tconst double EPS = 1e-10;\n\n\t//a > 0ならば+1, a == 0ならば0, a < 0ならば-1　を返す。　基本的にEPS込みの評価はこれで行う。\n\t//不等式は、加減算に直してこれに適用する。\n\tint sgn(const double a) {\n\t\treturn (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n\t}\n\n\tstruct Point {\n\t\t//2次元ベクトルのクラス\n\n\t\tdouble x, y;\n\t\tPoint(double _x, double _y) {\n\t\t\tx = _x, y = _y;\n\t\t}\n\t\tPoint() {\n\t\t\tx = 0, y = 0;\n\t\t}\n\n\t\tPoint operator+() const {\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-() const {\n\t\t\treturn{ -x, -y };\n\t\t}\n\t\tPoint operator+ (const Point& b) const {\n\t\t\treturn{ x + b.x, y + b.y };\n\t\t}\n\t\tPoint operator- (const Point& b) const {\n\t\t\treturn{ x - b.x, y - b.y };\n\t\t}\n\t\tPoint operator* (const double b) const {\n\t\t\treturn{ x * b, y * b };\n\t\t}\n\t\tPoint operator/ (const double b) const {\n\t\t\treturn{ x / b, y / b };\n\t\t}\n\t\tPoint operator+= (const Point& b) {\n\t\t\tx += b.x, y += b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-= (const Point& b) {\n\t\t\tx -= b.x, y -= b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator*= (const double b) {\n\t\t\tx *= b, y *= b;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator/= (const double b) {\n\t\t\tx /= b, y /= b;\n\t\t\treturn *this;\n\t\t}\n\t\tbool operator== (const Point& b) {\n\t\t\treturn b.x == x && b.y == y;\n\t\t}\n\n\t\tdouble lengthSquare() const {\n\t\t\treturn (x * x + y * y);\n\t\t}\n\t\tdouble length() const {\n\t\t\treturn std::sqrt(lengthSquare());\n\t\t}\n\t\tdouble dot(const Point& b) const {\n\t\t\treturn x * b.x + y * b.y;\n\t\t}\n\t\tdouble cross(const Point& b) const {\n\t\t\t//Generally, cross product is vector, but in 2D, cross product is also scalar.\n\t\t\treturn x * b.y - y * b.x;\n\t\t}\n\t\tdouble distanceFrom(const Point& b) const {\n\t\t\treturn std::sqrt((x - b.x) * (x - b.x) + (y - b.y) * (y - b.y));\n\t\t}\n\t\tPoint normalized() const {\n\t\t\treturn{ x / length(), y / length() };\n\t\t}\n\t\tbool isZero() const {\n\t\t\treturn sgn(x) == 0 && sgn(y) == 0;\n\t\t}\n\t\t//単位法線ベクトル\n\t\tPoint normalUnitVector() const {\n\t\t\treturn{ -normalized().y, normalized().x };\n\t\t}\n\t\t//(0, 0)中心にarg(弧度法)回転した座標\n\t\tPoint rotation(double arg) const {\n\t\t\tdouble cs = cos(arg), sn = sin(arg);\n\t\t\treturn Point(x * cs - y * sn, x * sn + y * cs);\n\t\t}\n\t\t//(0, 0)中心の円上に乗ってるとしたときの、偏角\n\t\tdouble angle() const {\n\t\t\treturn atan2(y, x);\n\t\t}\n\t};\n\n\tinline Point operator*(double a, const Point& b) {\n\t\treturn{ b.x * a, b.y * a };\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_ostream<Char>& operator <<(std::basic_ostream<Char>& os, const Point& v)\n\t{\n\t\treturn os << Char('(') << v.x << Char(',') << v.y << Char(')');\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_istream<Char>& operator >> (std::basic_istream<Char>& is, Point& v)\n\t{\n\t\treturn is >> v.x >> v.y;\n\t}\n\n\t//幾何ライブラリにおいて、解なしのような状態の時に返される点の値\n\tconst Point error_val = { 114514.0, -191981.0 };\n\n\tinline bool operator==(const Point& a, const Point& b) {\n\t\treturn (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0);\n\t}\n\n\t//第一にx, 第二にyを小さい順にソートするためのオーバーロード\n\tinline bool operator<(const Point& a, const Point& b) {\n\t\tif (sgn(a.x - b.x) != 0)return sgn(a.x - b.x) < 0;\n\t\telse sgn(a.y - b.y) < 0;\n\t}\n\n\t/*\n\t3点A, B, Cの位置関係を返す関数 A, Bがすべて異なった点であるのが前提\n\t//ABから見てBCは左に曲がるのなら +1\n\t//ABから見てBCは右に曲がるのなら -1\n\t//ABC(CBA)の順番で一直線上に並ぶなら +2\n\t//ACB(BCA)の順番で一直線上に並ぶなら 0\n\tBAC(CAB)の順番で一直線上に並ぶなら -2\n\t*/\n\tint iSP(const Point& a, const Point& b, const Point& c) {\n\t\tint flg = sgn((b - a).cross(c - a));\n\t\tif (flg == 1) {\n\t\t\treturn +1;\n\t\t}\n\t\telse if (flg == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\t//ABC(CBA)\n\t\t\tif (sgn((b - a).dot(c - b)) > 0)\n\t\t\t\treturn +2;\n\t\t\t//BAC(CAB)\n\t\t\telse if (sgn((a - b).dot(c - a)) > 0)\n\t\t\t\treturn -2;\n\t\t\t//ACB(BCA)　CがA or Bと一致しても、こっちに含まれる。\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t//直線に関する操作や判定\n\tnamespace line2d {\n\n\t\t//向きつき直線を想定。Segment\n\t\tstruct Line {\n\t\t\t\n\t\t\t//直線の通る二点。有向直線でないのならば、beginやendに違いはない。\n\t\t\tPoint begin, end;\n\n\t\t\tLine() {\n\t\t\t\tbegin = Point(), end = Point();\n\t\t\t}\n\n\t\t\tLine(const Point& b, const Point& e) {\n\t\t\t\tbegin = b, end = e;\n\t\t\t}\n\n\t\t\t//ax+by+c=0\n\t\t\tLine(const double a, const double b, const double c) {\n\t\t\t\tif (sgn(a) == 0 && sgn(b) == 0) {\n\t\t\t\t\tassert(-1);\n\t\t\t\t}\n\n\t\t\t\tif (sgn(b) == 0) {\n\t\t\t\t\t//ax+c=0になる。\n\t\t\t\t\tbegin = Point(-c / a, 0.0);\n\t\t\t\t\tend = Point(-c / a, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//y=-(ax+c)/b　傾きは-a/bで、y切片が-c/b\n\t\t\t\t\tbegin = Point(0, -c / b);\n\t\t\t\t\tend = Point(1.0, -(a + c) / b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPoint vec() const {\n\t\t\t\treturn end - begin;\n\t\t\t}\n\n\t\t};\n\n\n\t\t//線分の場合、Lineと同じものになるが、はっきりと区別する\n\t\ttypedef Line Segment;\n\n\n\t\t//直線の交点を返す。交わってなければ、error_valを返す。\n\t\tPoint lineIntersection(const Line& l1, const Line& l2) {\n\t\t\tif (sgn(l1.vec().cross(l2.vec())) == 0)return error_val;\n\n\t\t\tPoint ret;\n\t\t\tret = l1.begin + l1.vec() * \n\t\t\t\tabs((l2.end - l1.begin).cross(l2.vec()) / l1.vec().cross(l2.vec()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t//線分が共通部分を持つかどうか？と線分の交点を返す。共通部分がない、もしくは交点が一意ではないなら、error_valを返す。\n\t\t//trueなら、共通部分を持つ。falseなら、共通部分を持たない。\n\t\tpair<bool, Point> segmentIntersection(const Segment& s1, const Segment& s2) {\n\n\t\t\tif (iSP(s1.begin, s1.end, s2.begin) * iSP(s1.begin, s1.end, s2.end) <= 0 &&\n\t\t\t\tiSP(s2.begin, s2.end, s1.begin) * iSP(s2.begin, s2.end, s1.end) <= 0) {\n\n\t\t\t\t//平行ならば、交点は定まらない。(完全に重なってるので)\n\t\t\t\tif (s1.vec().cross(s2.vec()) == 0)\n\t\t\t\t\treturn make_pair(true, error_val);\n\t\t\t\telse //そうでないのなら、lineIntersection()で交点を返しておく。\n\t\t\t\t\treturn make_pair(true, lineIntersection(s1, s2));\n\n\t\t\t}\n\t\t\treturn make_pair(false, error_val);\n\t\t}\n\n\n\t\t//点と直線の距離。引数は、点、直線上の2点\n\t\tdouble distanceBetweenPointAndLine(const Point& p, const Line& l) {\n\t\t\treturn abs(l.vec().cross(p - l.begin) / l.vec().length());\n\t\t}\n\n\t\t//点と線分の距離。引数は、点、線分の両端\n\t\tdouble distanceBetweenPointAndSegment(const Point& p, const Segment& s) {\n\t\t\tif (sgn(s.vec().dot(p - s.begin)) < 0 || sgn(s.vec().dot(p - s.end)) < 0) {\n\t\t\t\t//下した垂線は線分の上にはない\n\t\t\t\treturn min(p.distanceFrom(s.begin), p.distanceFrom(s.end));\n\t\t\t}\n\t\t\treturn abs(s.vec().cross(p - s.begin) / s.vec().length());\n\t\t}\n\n\t\t//二線分間の距離\n\t\tdouble distanceBetweenSegmentAndSegment(const Segment& s1, const Segment& s2) {\n\t\t\tif (segmentIntersection(s1, s2).first)return 0;//交点を持つ\n\n\t\t\tdouble ans = distanceBetweenPointAndSegment(s1.begin, s2);\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s1.end, s2));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.begin, s1));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.end, s1));\n\t\t\treturn ans;\n\t\t}\n\n\t\t//正射影\n\t\t//引数は点A, B, Cで、BAベクトルの直線BC上の正射影を求める。\n\t\tPoint projection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = l.begin + \n\t\t\t\tl.vec().normalized() * (a - l.begin).dot(l.vec()) / l.vec().length();\n\t\t\treturn ret;\n\t\t}\n\n\t\t//鏡映変換。引数は点A, B, Cで、直線BCにおいて、Aと線対称な点を求める。\n\t\tPoint reflection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = a + 2 * (projection(a, l) - a);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tgeometry2d::line2d::Segment s1, s2;\n\t\tcin >> s1.begin >> s1.end >> s2.begin >> s2.end;\n\t\tif (geometry2d::line2d::segmentIntersection(s1, s2).first)\n\t\t\tcout << 1 << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t(dot(b - a, c - a) > -EPS) &&\n\t\t(dot(a - b, c - b) > -EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (is_point_on_line(p0, p1, p2)\n\t\t\t|| is_point_on_line(p0, p1, p3)\n\t\t\t|| is_point_on_line(p2, p3, p0)\n\t\t\t|| is_point_on_line(p2, p3, p1)) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_parallel(p0, p1, p2, p3)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n \n#define eps (1e-10)\n#define INF (1e20)\n\nstatic const double PI = acos(-1);\nbool eq(double a,double b){\n  return ( -eps < a-b && a-b < eps);\n}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n};\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n  Vector base(){\n    return p2-p1;\n  }\n};\ntypedef Segment Line;\n\nbool eq(Point a,Point b){ return (eq(a.x,b.x)&&eq(a.y,b.y)); }\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b){\n  return eq(cross(a,b),0);\n}\n\nVector unit(Vector v){\n  if(eq(abs(v),0))return v;\n  else return v/abs(v);\n}\n\nPoint getCrossPoint(Line a,Line b){\n  return a.p1+(a.p2-a.p1)*(cross(b.p2-b.p1,b.p1-a.p1)/cross(b.p2-b.p1,a.p2-a.p1));\n} \n\nbool onSegment(Segment a,Point p){\n  return eq( abs(a.p1-p)+abs(a.p2-p) , abs(a.p1-a.p2) );\n}\n\nbool intersect(Segment a,Segment b){\n  if(isParallel(a.base(),b.base())){\n    return (onSegment(a,b.p1)\n            ||onSegment(a,b.p2)\n            ||onSegment(b,a.p1)\n            ||onSegment(b,a.p2));\n  }\n  Point p=getCrossPoint(a,b);\n  \n  return (onSegment(a,p)&&onSegment(b,p));\n}\n\nvoid scan(Segment &a){\n  cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y;\n}\n\nint main(){\n  Segment a,b;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    scan(a);\n    scan(b);\n    cout<<intersect(a,b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <class T> inline bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator+(const Point &p) { return Point{x + p.x, y + p.y}; }\n    Point operator-(const Point &p) { return Point{x - p.x, y - p.y}; }\n    Point operator*(const double k) { return Point{x * k, y * k}; }\n    Point operator/(const double k) { return Point{x / k, y / k}; }\n\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n};\ntypedef Point Vector;\nstruct Segment {\n    Point p1, p2;\n};\ntypedef Segment Line;\nstruct Circle {\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector v) { return v.x * v.x + v.y * v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nbool isOrthogonal(Vector a, Vector b) { return dot(a, b) == 0; }\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Line l1, Line l2) {\n    return isOrthogonal(l1.p2, l1.p1, l2.p2, l2.p1);\n}\n\nbool isParallel(Vector a, Vector b) { return cross(a, b) == 0; }\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Line l1, Line l2) {\n    return isParallel(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\nPoint project(Line l, Point p) {\n    Vector base = l.p2 - l.p1;\n    double r = dot(p - l.p1, base) / base.norm();\n    return l.p1 + base * r;\n}\nPoint reflect(Line l, Point p) { return p + (project(l, p) - p) * 2; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > 0) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < 0) return CLOCKWISE;\n    if(dot(a, b) < 0) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n           ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while(n--) {\n        Segment s1, s2;\n        cin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y;\n        cin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n        cout << intersect(s1, s2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8, pi = acos(-1.0);\nbool eq(ld a, ld b){return (abs(b-a)<eps);}\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nclass Line{\npublic:\n  Point a,b;\n};\n\nld triangle(Point p1, Point p2, Point p3){\n  return cross(p2-p1, p3-p1);\n}\n\nint intersect(Line l1, Line l2){\n  return triangle(l1.a, l1.b, l2.a) * triangle(l1.a, l1.b, l2.b) <= 0 && triangle(l2.a, l2.b, l1.a) * triangle(l2.a, l2.b, l1.b) <= 0 ? 1 : 0;\n}\n\nint main(){\n  int q;cin>>q;\n  REP(i,q){\n    ld real, imag;\n    Line s1,s2;\n    cin>>real>>imag;\n    s1.a = Point(real,imag);\n    cin>>real>>imag;\n    s1.b = Point(real,imag);\n    cin>>real>>imag;\n    s2.a = Point(real,imag);\n    cin>>real>>imag;\n    s2.b = Point(real,imag);\n    cout<<intersect(s1,s2)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nusing C = pair<P,R>;\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n}\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s, const L&l) {\n  return intersect<strict>(l, s);\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON);\n}\n\n// 射影\nP projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int q;\n  cin >> q;\n  REP(i, q) {\n    S l1, l2;\n    cin >> l1 >> l2;\n    if(intersect(l1, l2)) cout << 1 << endl;\n    else cout << 0 << endl; \n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define PII pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double X = 0, double Y = 0)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\tPoint operator +(const Point &p)const { return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p)const { return Point(x - p.x, y - p.y); };\n\tPoint operator *(const double a)const { return Point(x*a, y*a); };\n\tPoint operator /(const double a)const { return Point(x / a, y / a); };\n\tdouble norm()const { return x*x + y*y; };\n\tdouble length()const { return sqrt(norm()); };\n\tdouble dot(const Point &p)const { return x*p.x + y*p.y; };\n\tdouble cross(const Point &p)const { return x*p.y - y*p.x; };\n\tbool operator ==(const Point &p)const\n\t{\n\t\treturn fabs(x - p.x)<EPS &&fabs(y - p.y)<EPS;\n\t}\n\tfriend ostream& operator <<(ostream& os, const Point &p);\n\tint CCW(Point p1, Point p2)\n\t{\n\t\tPoint p0(x, y);\n\t\tPoint V1 = p1 - p0;\n\t\tPoint V2 = p2 - p0;\n\t\tif (V1.cross(V2) > 0.0)return -1;\n\t\telse if (V1.cross(V2) < 0.0)return 1;\n\t\telse if (V1.dot(V2) < 0.0)return 2;\n\t\telse if (V1.norm() < V2.norm())return 3;\n\t\treturn 0;\n\t}\n};\ntypedef Point Vector;\n\nostream& operator <<(ostream& os, const Point &p)\n{\n\treturn os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\nclass Segment\n{\npublic:\n\tPoint p1, p2;\n\tSegment(double x1, double y1, double x2, double y2)\n\t{\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tdouble GetLength()\n\t{\n\t\tPoint temp = p2 - p1;\n\t\treturn temp.length();\n\t}\n\tdouble GetDistanceSeg(double X, double Y)\n\t{\n\t\tPoint p(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = p - p1;\n\t\tPoint c = p1 - p2;\n\t\tPoint d = p - p2;\n\t\tif (a.dot(b) < 0.0)return b.length();\n\t\tif (c.dot(d) < 0.0)return d.length();\n\t\treturn GetDistanceLine(X, Y);\n\t}\n\n\tdouble GetDistanceLine(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint a = p2 - p1;\n\t\tPoint b = t - p1;\n\t\treturn abs(a.cross(b) / a.length());\n\t}\n\tbool IsIntersect(Segment &s)\n\t{\n\t\tint s1, s2;\n\t\ts1 = p1.CCW(p2, s.p1)*p1.CCW(p2, s.p2);\n\t\ts2 = s.p1.CCW(s.p2, p1)*s.p1.CCW(s.p2, p2);\n\t\treturn s1 <= 0 && s2 <= 0;\n\t}\n\tbool IsOrthogonal(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.dot(t2));\n\t}\n\tbool IsParallel(const Segment &s)\n\t{\n\t\tVector t1 = p2 - p1;\n\t\tVector t2 = s.p2 - s.p1;\n\t\treturn equals(0.0, t1.cross(t2));\n\t}\n\tPoint GetProjection(double X, double Y)const\n\t{\n\t\tVector V = p2 - p1;\n\t\tPoint P(X, Y);\n\t\tPoint ret = V*(V.dot(P - p1) / V.norm());\n\t\treturn ret + p1;\n\t}\n\tPoint GetReflect(double X, double Y)\n\t{\n\t\tPoint t(X, Y);\n\t\tPoint Pro = GetProjection(X, Y);\n\t\tVector dV = Pro - t;\n\t\treturn t + dV*2.0;\n\t}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point C = Point(), double R = 0)\n\t{\n\t\tc = C;\n\t\tr = R;\n\t}\n};\nint main()\n{\n\tint q;\n\tcin >> q;\n\tREP(i, q)\n\t{\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tSegment s1(x0, y0, x1, y1), s2(x2, y2, x3, y3);\n\t\tcout << s1.IsIntersect(s2) << endl;;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{ONLINE_BACK = -2, CLOCKWISE = -1, ON_SEGMENT = 0,\n              COUNTER_CLOCKWISE = 1, ONLINE_FRONT = 2};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    POSITION s2p1_s1 = get_position(s2.p1, s1);\n    POSITION s2p2_s1 = get_position(s2.p2, s1);\n    POSITION s1p1_s2 = get_position(s1.p1, s2);\n    POSITION s1p2_s2 = get_position(s1.p2, s2);\n    // if (s2p1_s1 == ON_SEGMENT || s2p2_s1 == ON_SEGMENT) return true;\n    // if (s1p1_s2 == ON_SEGMENT || s1p2_s2 == ON_SEGMENT) return true;\n    // if (s2p1_s1 == ONLINE_FRONT) {\n    //     if (s2p2_s1 == ONLINE_BACK) return true;\n    //     return false;\n    // }\n    // if (s2p1_s1 == ONLINE_BACK) {\n    //     if (s2p2_s1 == ONLINE_FRONT) return true;\n    //     return false;\n    // }\n    // if (s2p1_s1 != s2p2_s1 && s1p1_s2 != s1p2_s2) return true;\n    // return false;\n    if (s2p1_s1 * s2p2_s1 <= 0 && s1p1_s2 * s1p2_s2 <= 0) return true;\n    return false;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\nint64_t cross(int64_t v1x, int64_t v1y, int64_t v2x, int64_t v2y) {\n    return v1x * v2y - v2x * v1y;\n}\n\nint main() {\n    int64_t q;\n\n    std::cin >> q;\n    \n    for (auto i = 0; i < q; ++i) {\n        int64_t x0, y0, x1, y1, x2, y2, x3, y3;\n        std::cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        int64_t v1x = x1 - x0;\n        int64_t v1y = y1 - y0;\n        int64_t v2x = x3 - x2;\n        int64_t v2y = y3 - y2;\n\n        int64_t f1 = cross(v1x, v1y, x2-x0, y2-y0) * cross(v1x, v1y, x3-x0, y3-y0);\n        int64_t f2 = cross(v2x, v2y, x0-x2, y0-y2) * cross(v2x, v2y, x1-x2, y1-y2);\n\n        std::cout << ((f1 <= 0 && f2 <= 0) ? 1 : 0 ) << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int X, Y; Y = scanf(\"%d\", &X); return X; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nbool eq(ld a, ld b){\n\treturn abs(a-b) < EPS;\n}\n\nstruct PT{\n\tld X, Y;\n\tPT (ld X = 0, ld Y = 0) : X(X), Y(Y) {}\n\tPT operator + (PT ro) const{\n\t\treturn PT(X+ro.X, Y+ro.Y);\n\t}\n\tPT operator - (PT ro) const{\n\t\treturn PT(X-ro.X, Y-ro.Y);\n\t}\n\tPT operator * (ld co) const{\n\t\treturn PT(X*co, Y*co);\n\t}\n\tPT operator / (ld co) const{\n\t\treturn PT(X/co, Y/co);\n\t}\n\tld operator * (PT ro) const{\n\t\treturn X*ro.X + Y*ro.Y;\n\t}\n\tld operator ^ (PT ro) const{\n\t\treturn X*ro.Y - Y*ro.X;\n\t}\n};\n\nistream& operator>> (istream &is, PT &p){\n\tld val;\n\tis >> val;\n\tp.X = val;\n\tis >> val;\n\tp.Y = val;\n\treturn is;\n}\n\nPT operator * (ld co, PT p){\n\treturn p*co;\n}\n\nld len(PT a){\n\treturn sqrt(a*a);\n}\n\nPT unit(PT a){\n\treturn a/len(a);\n}\n\nPT clrot(PT a){\n\treturn PT(-a.Y, a.X);\n}\n\nPT proj(PT a, PT b, PT c){\n\tb = b-a, c = c-a;\n\treturn a + (b*c)/(b*b)*b;\n}\n\nPT reflect(PT a, PT b, PT c){\n\tPT d = c;\n\tb = b-a, c = c-a;\n\treturn d + (c^b)/len(b)*clrot(unit(b))*2;\n}\n\nint sgn(PT a, PT b, PT c){\n\tld cr = (b-a)^(c-a);\n\treturn cr > EPS ? 1 : (cr + EPS < 0 ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = sgn(c, d, a),\n\t\tbs = sgn(c, d, b),\n\t\tcs = sgn(a, b, c),\n\t\tds = sgn(a, b, d);\n\tif (as && as == bs || cs && cs == ds)\n\t\treturn false;\n\telse if (as || bs || cs || ds)\n\t\treturn true;\n\tfor (int j = 0; j < 2; j++){\n\t\tld mX = min(a.X, b.X),\n\t\t   MX = max(a.X, b.X),\n\t\t   mY = min(a.Y, b.Y),\n\t\t   MY = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++){\n\t\t\tif (c.X + EPS > mX && c.X < MX + EPS && c.Y + EPS > mY && c.Y < MY + EPS)\n\t\t\t\treturn true;\n\t\t\tswap(c, d);\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor (int i = in(); i; i--){\n\t\tPT a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tcout << intersect(a, b, c, d) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> tpl;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\n/*---------------------------------   Geometry   -----------------------------------------*/\nusing Point = complex<double>;\nconst double EPS = 1e-12;\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)){\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream &operator<<(ostream &s, const Line &l) { return s << '{' << l[0] << ',' << l[1] << '}'; }\n};\n\n/* ∠ABC */\ndouble degree(Point A, Point B, Point C){\n    if(B == C) return 0;\n    return arg((A - B) / (C - B));\n}\n\n/* counter-clockwise */\n/* AB, ACの関係性を調べる*/\n/* 同一直線上 : positive, 非同一直線上 : negative*/\n/* 同一直線上だが、CはAB上に無い : 3 */\n/* 同一直線上でCはAB上の点 : 2 */\n/* 同一直線上で逆向きにCが存在 : 1 */\n/* AB -> ACが反時計周り : -1 */\n/* AB -> ACが時計周り : -2 */\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(Point A, Point B, Point C){\n    double deg = degree(B, A, C);\n    if(abs(cos(deg) - 1.0) <= EPS){\n        if(abs(C - A) > abs(B - A)) return 3;\n        else  return 2;\n    }\n    if(abs(cos(deg) + 1) <= EPS) return 1;\n\n    if(sin(deg) + EPS >= 0) return -2;\n    else return -1;\n}\n \n/* perpendicular bisector */\nLine bisector(const Line& L){\n    Point X = L[0], Y = L[1];\n    Point C = (X + Y) / 2.0;\n    Point D = C + (X - Y) * Point(0.0, 1.0);\n    return Line(C, D);\n}\n\n/* 二直線間の角度, 平行, 垂直 */\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\ndouble lineAngle(const Line& L1, const Line& L2){\n    return degree(Point(L1[1] - L1[0] ), Point(0.0, 0.0), Point(L2[1] - L2[0]));\n}\n\nbool isParallel(const Line& L1, const Line& L2){\n    return abs(sin(lineAngle(L1, L2))) <= EPS;\n}\n\nbool isOrthogonal(const Line& L1, const Line& L2){\n    return abs(cos(lineAngle(L1, L2))) <= EPS;\n}\n\n/* cross point */\n/* 二直線の交点 */\n// VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Line& L1, const Line& L2){\n    if(isParallel(L1, L2)) return Point(-INF, -INF);\n    Point A = L1[0], B = L1[1];\n    Point C = L2[0], D = L2[1];\n    return A + (B - A) * (imag((A - C) * conj(C - D)) / imag((C - D) * conj(B - A)));\n}\n\n/* Line Segment Crossed? */\n/* 線分の交差判定 */\nbool isSegmentCrossed(const Line& L1, const Line& L2){\n    Point A = L1[0], B = L1[1];\n    Point C = L2[0], D = L2[1];\n\n    if(isParallel(L1, L2)){\n        if(ccw(A, B, C) == 2 or ccw(A, B, D) == 2 or ccw(C, D, A) == 2 or ccw(C, D, B) == 2) return true;\n        return false;\n    }\n\n\n    double t = imag((A - C) * conj(C - D)) / imag((C - D) * conj(B  - A));\n    double s = imag((C - A) * conj(A - B)) / imag((A - B) * conj(D - C));\n    return t + EPS >= 0 and t - EPS <= 1 and s + EPS >= 0 and s - EPS <= 1;\n}\n\n/* foot of a perpendicular line　*/\n/* 垂線の足 */\nPoint foot(const Point &A, const Line &L){\n    return (A + L[0] + L[1] - (A * L[0] * conj(L[1]))) / 2.0;\n};\n\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    ll N;\n    cin >> N;\n    rep(i, N){\n        ll a, b, c, d, e, f, g, h;\n        cin >> a >> b >> c >> d >> e >> f >> g >> h;\n\n        bool cross = isSegmentCrossed(Line(Point(a, b), Point(c, d)), Line(Point(e, f), Point(g, h)));\n        print(cross);\n    }\n\n\n\n    return 0;\n}                                              \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n// dot det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\n//projection verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n//reflection verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\n// vertical parallel verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// same line determination \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// crossing determination???verify AOJ CGL_2_B if including endpoint 0: otherwise 1\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// crossing point verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// distance verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// Polygon\n// area Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// convex_polygon determination verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// polygon realation determination???(possible non-convex) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) reg(check,cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A  if including points on segment 1: otherwise 0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//these while statements: if removing points on convex hull  >=0 otherwise???>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size(),i=0,j=0;\n\tR res=0.0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// convex_cut verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\tchmin(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\treg(e,a[i]);\n\t}\n\treturn d;\n}\n\n// Circle\n// Verify AOJ 1183\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\nbool operator <  (const C& a,const C& b){ return a.c==b.c?sgn(a.r-b.r)<0:a.c<b.c;}\nbool operator == (const C& a,const C& b){ return a.c==b.c&&sgn(a.r-b.r)==0;}\n\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tif(sgn(a.r+b.r-d)<0) return OUT;\n\tif(sgn(a.r+b.r-d)==0) return ON_OUT;\n\tif(sgn(abs(a.r-b.r)-d)<0) return ISC;\n\tif(sgn(abs(a.r-b.r)-d)==0) return ON_IN;\n\treturn IN;\n}\n\n// circle crossing determination\nbool icp(C c,P p,int end=0){return sgn(norm(p-c.c)-norm(c.r))<=-end;}\nbool ics(C c,L s,int end=0){return sgn(dsp(s,c.c)-c.r)<=-end;}\nbool icsc(C c,L l,int end=0){return ics(c,l) && sgn(max(norm(l.s-c.c),norm(l.t-c.c))-norm(c.r))<=0;}\n\n// common area between circles\nR area(C c1,C c2){\n\tR d=abs(c2.c-c1.c);\n   \tint r=rcc(c1,c2);\n    if(r>=ON_OUT) return 0.0;  \n    if(r==IN) return min(norm(c1.r),norm(c2.r))*PI;\n    R rc=(norm(d)+ norm(c1.r) - norm(c2.r))/(2.0*d),theta=acos(rc/c1.r),phi=acos((d-rc)/c2.r);\n    return norm(c1.r)*theta+norm(c2.r)*phi-d*c1.r*sin(theta);\n}\n\n// cross point between circle and line Verify AOJ CGL_7_D\nP cir(C c,R t){return c.c+polar(c.r,t);}\nVP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\n\n// cross point between circles Verify AOJ CGL_7_E\nVP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n// circle tangent Verify AOJ 2001\nL tan(C c,R t){P p=cir(c,t),d=polar(c.r,t)*P(0,1);return L{p-d,p+d};}\n\nVL tan(C c,P p){\n\tVL res;R t=arg(p-c.c),d=acos(c.r/abs(p-c.c));\n\treg(res,tan(c,t+d));\n\tif(sgn(d)) reg(res,tan(c,t-d));\t\t\t\n\treturn res;\n}\n\nVL tan(C a,C b){\n\tVL res;R t=arg(b.c-a.c),d=abs(b.c-a.c),i=acos((a.r+b.r)/d),o=acos((a.r-b.r)/d); int r=rcc(a,b);\n\tif(r>=OUT) reg(res,tan(a,t+i)),reg(res,tan(a,t-i));\n\tif(r>=ISC) reg(res,tan(a,t+o)),reg(res,tan(a,t-o));\n\tif(r&ONS) reg(res,tan(a,t));\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\n// Points not verify\nR toRagian(R degree){ return degree*PI/180.0;}\nR ang (P p){return arg(p);}\nR ang (P base,P a,P b) {R res=arg((b-base)/(a-base));return res<0?res+2*PI:res;} // base ??????\nP rot (P base,P a,R theta){P tar=a-base;return base+polar(abs(tar), arg(tar)+theta );}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\n// AOJ 1352\n\nvoid circle_arrangement(const VC &circle,VP &point){\n\tVP candiate;\t\n\tauto can=[&](P p){for(auto &c:circle) if(icp(c,p,1)) return; reg(candiate,p);};\n\tauto check1=[&](P p){for(auto &c:circle) if(icp(c,p,1)) return false; return true;};\n\tauto check2=[&](L s){for(auto &c:circle) if(ics(c,s,1)) return false; return true;};\n\n\tfor(auto &c1:circle){\n\t\trep(j,4) can(cir(c1,j*PI/2.0));\n\t\tfor(auto &p:point) for(auto &l:tan(c1,p)) can(proj(l,c1.c));\n\t\tfor(auto &c2:circle){\n\t\t\tif(rcc(c1,c2)==ISC) for(auto &p:pcc(c1,c2)) can(p);\n\t\t\tfor(auto &l:tan(c1,c2)) can(proj(l,c1.c)),can(proj(l,c2.c));\n\t\t}\n\t}\t\n\tuniq(candiate),move(_all(candiate),back_inserter(point));\n\tfor(auto &c:circle){\n\t\tvector<pair<R,int>> idx;\n\t\trep(i,point.size()) if(sgn(norm(c.c-point[i])-norm(c.r))==0) reg(idx,{arg(point[i]-c.c),i});\n\t\tsort(_all(idx)),reg(idx,{idx[0].first+2*PI,idx[0].second});\n\t\trep(i,1,idx.size()){\n\t\t\tR a1=idx[i-1].first,a2=idx[i].first;\n\t\t\tP mid=cir(c,(a1+a2)/2.0);\n\t\t\tif(check1(mid)) add_edge(idx[i-1].second,idx[i].second,c.r*(a2-a1));\n\t\t}\n\t}\n\trep(i,point.size())rep(j,i){\n\t\tL l={point[i],point[j]};\n\t\tif(check2(l)) add_edge(i,j,abs(l.t-l.s));\n\t}\n}\n\n// segments arrangement AOJ 1050\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\tint n=seg.size();\n\trep(i,n){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j],1)) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\n// merge segments\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t=l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\nVP normalize_polygon(VP pol){rep(i,pol.size()) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);return pol;}\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\n// triangle incenter \n// verify : aoj 1301\nP incenter(P p1, P p2, P p3){\n    R a=abs(p2-p3),b=abs(p3-p1),c=abs(p1-p2);\n    return (a*p1+b*p2+c*p3)/(a+b+c);\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// common area between circle and polygon\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough Transfrom\n// Afin Transform\n// Delaunay Triangle\n// Kd-Tree\n// sector\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n\n  double abs(){return sqrt(norm());}\n\n  double norm(){return (x*x+y*y);}\n};\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble dot(Vector a,Vector b){return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nint main()\n{\n  Point A,B,C,D;\n  int q;\n\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>D.x>>D.y;\n    if(intersect(A,B,C,D))cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ?????? a1, a2 ??¨?????? b1, b2 ???????????????\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main() {\n    P a, b, c, d; \n    int q; cin >> q;\n    rep(i,0,q) {\n        cin >> a.X >> a.Y >> b.X >> b.Y >> c.X >> c.Y >> d.X >> d.Y;\n        if(isec_ss(a,b,c,d)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<string>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\nclass Point\n{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n    Point operator * (double a) {return Point(x * a, y * a);}\n    Point operator / (double a) {return Point(x / a, y / a);}\n\n    double abs() {return sqrt(norm());}\n    double norm() {return x * x + y * y;}\n    \n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};typedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS) return 1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS) return 2;\n    if (a.norm() < b.norm()) return -2;\n    return 0;\n}\n#include<iostream>\nbool intersection(Point p0, Point p1, Point p2, Point p3){\n    if (ccw(p0, p1, p2) == 0 || ccw(p0, p1, p3) == 0 || \n        ccw(p2, p3, p0) == 0 || ccw(p2, p3, p1) == 0)\n        return true;\n    if (ccw(p0, p1, p2) * ccw(p0, p1, p3) == -1 && ccw(p2, p3, p0) * ccw(p2, p3, p1) == -1)\n        return true;\n    return false;\n}\nint main(){\n    int q; cin >> q;\n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    Point p0, p1, p2, p3;\n    for (int i = 0; i < q; i++)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        p0 = Point(x0, y0);\n        p1 = Point(x1, y1);\n        p2 = Point(x2, y2);\n        p3 = Point(x3, y3);\n        if(intersection(p0, p1, p2, p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{x+p.x,y+p.y};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{x-p.x,y-p.y};\n\t}\n\tpoint operator*(double p){\n\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n\t}\n};\n\ntypedef pair<point,point> pp;\nconst point O{0,0};\n\nclass Geom{\n\tpublic:\n\tdouble Length(point x,point y){\n\t\tpoint z=y-x;\n\t\treturn sqrt(z.x*z.x+z.y*z.y);\n\t}\n\tdouble IP(point p,point q){\n\t\treturn p.x*q.x+p.y*q.y;\n\t}\n\tdouble CP(point p,point q){\n\t\treturn p.x*q.y-q.x*p.y;\n\t}\n\tstring Counter_Clockwise(pp a,point x){\n\t\tpoint A=a.second-a.first;\n\t\tpoint X=x-a.first;\n\t\tdouble ip=IP(A,X),cp=CP(A,X),Al=Length(O,A),Xl=Length(O,X);\n\t\tif(cp>eps) return \"Counter_Clockwise\";\n\t\tif(cp<-eps) return \"Clockwise\";\n\t\tif(ip<-eps) return \"Online_Back\";\n\t\tif(Xl<Al||fabs(Xl-Al)<eps) return \"On_Segment\";\n\t\treturn \"Online_Front\";\n\t}\n\tstring Parallel_Orthogonal(pp a,pp b){\n\t\tpoint A=a.second-a.first,B=b.second-b.first;\n\t\tdouble ip=IP(A,B),cp=CP(A,B);\n\t\tstring f=Counter_Clockwise(pp(a.first,a.second),b.first),s=Counter_Clockwise(pp(a.first,a.second),b.second);\n\t\tif(f[0]!='C'&&s[0]!='C') return \"Agreement\";\n\t\tif(cp<eps&&cp>-eps) return \"Parallel\";\n\t\tif(ip<eps&&ip>-eps) return \"Orthogonal\";\n\t\telse return \"Commonly\";\n\t}\n\tstring Intersection(pp a,pp b){\n\t\tpoint p=Cross_Point(a,b);\n\t\tif(p==point{inf,0}) return \"not_Intersection\";\n\t\tif(p==point{inf,inf}){\n\t\t\tstring S=Counter_Clockwise(a,b.first),T=Counter_Clockwise(a,b.second);\n\t\t\tif(S[2]=='l'&&T[2]=='l') return \"not_Intersection\";\n\t\t\treturn \"Intersection\";\n\t\t}\n\t\tstring s=Counter_Clockwise(a,p),t=Counter_Clockwise(b,p);\n\t\tif(s[3]=='S'&&t[3]=='S') return \"Intersection\";\n\t\telse return \"not_Intersection\";\n\t}\n\tpoint Inter(pp  a,double x,double y){\n\t\treturn (a.first*y+a.second*x)/(x+y);\n\t}\n\tpoint Exterior(pp a,double x,double y){\n\t\treturn (a.first*-y+a.second*x)/(x-y);\n\t}\n\tpoint Projection(pp a,point x){\n\t\tpoint A=x-a.first,B=a.second-a.first;\n\t\tdouble l=Length(O,B);\n\t\treturn B*IP(A,B)/(l*l)+a.first;\n\t}\n\tpoint Cross_Point(pp a,pp b){\n\t\tstring s=Parallel_Orthogonal(a,b);\n\t\tif(s[0]=='A') return point{inf,inf};\n\t\tif(s[0]=='P') return point{inf,0};\n\t\tpoint p=Projection(a,b.first),q=Projection(a,b.second);\n\t\tdouble pl=Length(b.first,p),ql=Length(b.second,q);\n\t\tstring S=Counter_Clockwise(a,b.first),T=Counter_Clockwise(a,b.second);\n\t\tif(S==T) return Exterior(b,pl,ql);\n\t\telse return Inter(b,pl,ql);\n\t}\n\tvoid Point_in(point& p){\n\t\tcin>>p.x>>p.y;\n\t}\n\tvoid Point_out(point p){\n\t\tcout<<p.x<<' '<<p.y<<endl;\n\t}\n};\n\nint Q;\nvector<point> p(4);\n\nint main(){\n\tcout<<syosu(10);\n\tGeom geo;\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<4;j++) geo.Point_in(p[j]);\n\t\tstring ans=geo.Intersection(pp(p[0],p[1]),pp(p[2],p[3]));\n\t\tif(ans==\"Intersection\") cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <array>\n#include <vector>\n#include <cmath>\n\nconst double EPSILON = 1e-10;\n\ninline bool equals(double a, double b) {\n    return std::fabs(a - b) < EPSILON;\n}\n\nstruct Point {\n    double x;\n    double y;\n\n    bool operator < (const Point& p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point& p) const {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\nPoint operator + (const Point& p1, const Point& p2) {\n    return Point{p1.x + p2.x, p1.y + p2.y};\n}\n\nPoint operator - (const Point& p1, const Point& p2) {\n    return Point{p1.x - p2.x, p1.y - p2.y};\n}\n\nPoint operator * (const Point& p1, double k) {\n    return Point{p1.x * k, p1.y * k};\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nusing Vector = Point;\nusing Line = Segment;\nusing Polygon = std::vector<Point>;\n\n\ndouble norm(const Vector& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const Vector& p) {\n    return std::sqrt(norm(p));\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nVector projection(const Segment& s, const Point& p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nVector reflection(const Segment& s, const Point& p) {\n    return p + (projection(s, p) - p) * 2.0;\n}\n\nbool is_orthogonal(const Vector& a, const Vector& b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool is_orthogonal(const Segment& s1, const Segment& s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool is_parallel(const Vector& a, const Vector& b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool is_parallel(const Segment& s1, const Segment& s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0,\n};\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n    if (cross(a, b) > EPSILON) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPSILON) return CLOCKWISE;\n    if (dot(a, b) < -EPSILON) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    auto area = [](const Point& x0, const Point& x1, const Point& x2) {\n        auto a = x1 - x0;\n        auto b = x2 - x0;\n        return cross(a, b);\n    };\n    return (area(p1, p2, p3) * area(p1, p2, p4) <= 0 &&\n            area(p3, p4, p1) * area(p3, p4, p2) <= 0);\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return abs(a - b);\n}\n\ndouble distanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s, p);\n}\n\ndouble distance(const Segment& s1, const Segment& s2) {\n    using std::min;\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n               min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n}\n\n\nint main() {\n    using namespace std;\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        array<Point, 4> points;\n        for (auto& p : points) {\n            cin >> p.x >> p.y;\n        }\n        Segment s1{points[0], points[1]};\n        Segment s2{points[2], points[3]};\n        cout << intersect(s1, s2) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\tPoint operator + (Point p){\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\n\tPoint operator - (Point p){\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\n\tPoint operator * (double k){\n\t\treturn Point(k*x,k*y);\n\t}\n\n\n\tbool operator<(const Point &p)const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\n};\ndouble dot(Point p, Point q){\n\treturn p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n\treturn p.x*q.y-q.x*p.y;\n}\n\ndouble norm(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\ndouble pabs(Point p){\n\treturn sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n\tLine(){}\n\tLine(Point p,Point q){\n\t\tPB(p);\n\t\tPB(q);\t\n\t}\n};\nstruct Circle{\n\tPoint p; //中心点\n\tdouble r; //半径\n\tCircle(){}\n\tCircle(Point _p,double _r){\n\t\tp = _p;\n\t\tr = _r;\n\t}\n};\nint ccw(Point a,Point b,Point c){\n\tb = b-a;\n\tc = c-a;\n\tif(cross(b,c) > 0)return +1; //a→b で反時計に折れて c ccw\n\tif(cross(b,c) < 0)return -1; //a→b で時計に折れて ccw\n\tif(dot(b,c) < 0)return +2; // c--a--b;\n\tif(pabs(b)<pabs(c))return -2; //a--b--c\n\treturn 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n\t//lとmが交差してるかどうか\n\treturn (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n\t\t\t(ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\nint main(){\n\tint Q;\n\tcin >> Q;\n\twhile(Q--){\n\t\tPoint p[4];\n\t\trep(i,4){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x,y);\n\t\t}\n\t\tLine l,m;\n\t\tl.PB(p[0]);l.PB(p[1]);\n\t\tm.PB(p[2]);m.PB(p[3]);\n\t\tcout << intersectSS(l,m) << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\nconst double EPS=1e-10;\nstruct point{\n\tdouble x,y;\n\tpoint(const point&a):x(a.x),y(a.y){}\n\tpoint(const double&x=0,const double&y=0):x(x),y(y){}\n\tpoint operator+(const point&p)const{return point(x+p.x,y+p.y);}\n\tpoint operator-(const point&p)const{return point(x-p.x,y-p.y);}\n\tpoint operator*(const double&k)const{return point(x*k,y*k);}\n\tpoint operator/(const double&k)const{return point(x/k,y/k);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble abs(){return sqrt(norm());}\n\tvoid operator=(const point&a){\n\t\tx=a.x,y=a.y;\n\t}\n\tbool operator<(const point&p)const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator==(const point&p)const{\n\t\treturn fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n\t}\n\tfriend double dot(const point&a,const point&b){\n\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\tfriend double cross(const point&a,const point&b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n};\ntypedef point vector;\nstruct segment{\n\tpoint p1,p2;\n\tsegment(const double&a,const double&b,const double&c,const double&d){\n\t\tp1.x=a,p1.y=b,p2.x=c,p2.y=d;\n\t}\n\tsegment(const point&a, const point&b):p1(a),p2(b){}\n\tpoint get_vec()const{return point(p2.x-p1.x,p2.y-p1.y);}\n};\nbool orthogonal(const vector&a,const vector&b){\n\treturn fabs(dot(a,b))<EPS;\n}\nbool orthogonal(const point&a,const point&b,const point&c,const point&d){\n\treturn fabs(dot(a-b,c-d))<EPS;\n}\nbool orthogonal(const segment&a,const segment&b){\n\treturn fabs(dot(a.get_vec(),b.get_vec()))<EPS;\n}\nbool parallel(const vector&a,const vector&b){\n\treturn fabs(cross(a,b))<EPS;\n}\nbool parallel(const point&a,const point&b,const point&c,const point&d){\n\treturn fabs(cross(a-b,c-d))<EPS;\n}\nbool parallel(const segment&a,const segment&b){\n\treturn fabs(cross(a.get_vec(),b.get_vec()))<EPS;\n}\npoint project(const segment&s,const point&p){\n\tvector base=s.get_vec();\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r;\n}\npoint reflect(const segment&s,const point&p){\n\treturn p+(project(s,p)-p)*2.0;\n}\nint ccw(const point&a,const point&b,const point&c){\n\tvector t1=b-a;\n\tvector t2=c-a;\n\tif(cross(t1,t2)>EPS) return 1;\n\tif(cross(t1,t2)<-EPS) return -1;\n\tif(dot(t1,t2)<-EPS) return -2;\n\tif(t1.norm()<t2.norm()) return 2;\n\treturn 0;\n}\nbool intersect(const point&a,const point&b,const point&c,const point&d){\n\treturn ((ccw(a,b,c)*ccw(a,b,d))<=0&&(ccw(c,d,a)*ccw(c,d,b))<=0);\n}\nbool intersect(const segment&a,const segment&b){\n\treturn intersect(a.p1,a.p2,b.p1,b.p2);\n}\nint main(){\n\tdouble a,b,c,d;\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a>>b>>c>>d;\n\t\tsegment s1(a,b,c,d);\n\t\tcin>>a>>b>>c>>d;\n\t\tsegment s2(a,b,c,d);\n\t\tif(intersect(s1,s2)) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\nint main(){\nint n;\ncin>>n;\ndouble a1,a2,a3,a4,a5,a6,a7,a8;\ncin>>a1>>a2>>a3>>a4;\nPoint p0,p1,p2,p3;\nVector v01,v02,v03,v23,v21,v20;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8;\np0.x=a1,p0.y=a2;\np1.x=a3,p1.y=a4;\np2.x=a5,p2.y=a6;\np3.x=a7,p3.y=a8;\nv01=p0-p1;\nv02=p0-p2;\nv03=p0-p3;\nv23=p2-p3;\nv21=p2-p1;\nv20=p2-p0;\nif(cross(v01,v02)*cross(v01,v03)<EPS && cross(v23,v21)*cross(v23,v20)<EPS) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define CP complex<long double>\n\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersection(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP a, CP b, CP p) {\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\n// segmentver.\nlong double distSP(CP a, CP b, CP p) {\n  if(dot(b - a, p - a) < 0) return abs(p - a);\n  if(dot(a - b, p - b) < 0) return abs(p - b);\n  return distLP(a, b, p);\n}\n\n// segment and segment\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\nlong long q;\n\nint main() {\n  cin >> q;\n  while(q--) {\n    int a, b, c, d, e, f, g, h;\n    cin >> a >> b >> c >> d >> e >> f >> g >> h;\n    CP xs(a, b), xt(c, d), ys(e, f), yt(g, h);\n    cout << iscross(xs, xt, ys, yt) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\tusing Real = double;\n\tusing Point = complex<Real>;\n\tconstexpr Real EPS = 1e-9;\n\t// 誤差を考慮した符号\n\tinline int sgn(const Real x) {\n\t\treturn (x > EPS) - (x < -EPS);\n\t}\n\t// 誤差を考慮した l - r の符号\n\tinline int sgn(const Real l, const Real r) {\n\t\treturn sgn(l - r);\n\t}\n\tstruct Circle {\n\t\tPoint p;\n\t\tReal r;\n\t\tCircle(const Point p, const Real r) : p(p), r(r) {}\n\t};\n\tstruct Line {\n\t\tPoint a, b;\n\t\tLine(const Point a, const Point b) : a(a), b(b) {}\n\t};\n\tstruct Segment : Line {\n\t\tSegment(const Point a, const Point b) : Line(a, b) {}\n\t};\n\t// 内積\n\tinline Real dot(const Point& lhs, const Point& rhs) {\n\t\treturn (conj(lhs) * rhs).real();\n\t}\n\t// 外積\n\tinline Real cross(const Point& lhs, const Point& rhs) {\n\t\treturn (conj(lhs) * rhs).imag();\n\t}\n\t// 直線の交点\n\t// vector<Point> crossPoint(const Line& l1, const Line& l2) {\n\t// \tvector<Point> ret;\n\t// \tif(parallel(l1, l2)) return ret;\n\t// \tPoint p1 = l1.b - l1.a;\n\t// \tPoint p2 = l2.b - l2.a;\n\t// \tret.emplace_back(l1.a + p1 * cross(p2, l2.a - l1.a) / cross(p2, p1));\n\t// \treturn ret;\n\t// }\n\t// // 線分の交点\n\t// vector<Point> crossPoint(const Segment& s1, const Segment& s2) {\n\t// \tvector<Point> ret = crossPoint((Line)s1, (Line)s2);\n\t// \tfor(Point& p : ret) {\n\n\t// \t}\n\t// }\n\t// 円の交点\n\tvector<Point> crossPoint(const Circle& c1, const Circle& c2) {\n\t\tconst Real dist = abs(c1.p - c2.p);\n\t\tvector<Point> ret;\n\t\tif(dist > c1.r + c2.r) return ret;\n\t\tif(dist < abs(c1.r - c2.r)) return ret;\n\t\tconst Real rc = (dist * dist + c1.r * c1.r - c2.r * c2.r) / (2 * dist);\n\t\tconst Real rs = sqrt(c1.r * c1.r - rc * rc);\n\t\tconst Point vec = (c2.p - c1.p) / dist;\n\t\tret.emplace_back(c1.p + vec * Point(rc, rs));\n\t\tret.emplace_back(c1.p + vec * Point(rc, -rs));\n\t\treturn ret;\n\t}\n\t// a の b に対する正射影ベクトル\n\tinline Point projection(const Point& a, const Point& b) {\n\t\treturn b * dot(a, b) / norm(b);\n\t}\n\t// 点pから直線lに下ろした垂線の足\n\tinline Point projection(const Line& l, const Point& p) {\n\t\treturn projection(p - l.a, l.b - l.a) + l.a;\n\t}\n\t// 直線lを対称軸として点pと線対称な点\n\tinline Point reflection(const Line &l, const Point &p) {\n\t\treturn p + (projection(l, p) - p) * 2.0;\n\t}\n\t// 反時計回り(a -> b -> c)\n\tstatic constexpr int CCW_COUNTER_CLOCKWISE = 0b00001;\n\t// 時計回り(a -> b -> c)\n\tstatic constexpr int CCW_CLOCKWISE = 0b00010;\n\t// 同一直線上(c -> a -> b)\n\tstatic constexpr int CCW_ONLINE_BACK = 0b00100;\n\t// 同一直線上(a -> b -> c, b on ac)\n\tstatic constexpr int CCW_ONLINE_FRONT = 0b01000;\n\t// 同一直線上(a -> c -> b)\n\tstatic constexpr int CCW_ON_SEGMENT = 0b10000;\n\t// 3点の位置関係\n\tint ccw(const Point &a, Point b, Point c) {\n\t\tb = b - a, c = c - a;\n\t\tif(cross(b, c) > EPS) return CCW_COUNTER_CLOCKWISE;\n\t\tif(cross(b, c) < -EPS) return CCW_CLOCKWISE;\n\t\tif(dot(b, c) < 0) return CCW_ONLINE_BACK;\n\t\tif(norm(b) < norm(c)) return CCW_ONLINE_FRONT;\n\t\treturn CCW_ON_SEGMENT;\n\t}\n\t// 平行判定\n\tinline bool parallel(const Line& l1, const Line& l2) {\n\t\treturn sgn(cross(l1.a - l1.b, l2.a - l2.b)) == 0;\n\t}\n\t// 直交判定\n\tinline bool orthogonal(const Line& l1, const Line& l2) {\n\t\treturn sgn(dot(l1.a - l1.b, l2.a - l2.b)) == 0;\n\t}\n\t// 線分の交差判定\n\tinline bool intersect(Segment& s1, Segment& s2) {\n\t\tconstexpr int plus = CCW_COUNTER_CLOCKWISE | CCW_ONLINE_BACK;\n\t\tconstexpr int minus = CCW_CLOCKWISE | CCW_ONLINE_FRONT;\n\t\tint f[4] = {ccw(s1.a, s1.b, s2.a), ccw(s1.a, s1.b, s2.b), ccw(s2.a, s2.b, s1.a), ccw(s2.a, s2.b, s1.b)};\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tf[i] = (f[i] & plus) ? +1 : ((f[i] & minus) ? -1 : 0);\n\t\t}\n\t\treturn (f[0] * f[1] <= 0) and (f[2] * f[3] <= 0);\n\t}\n\n\n\tinline istream& operator>>(istream& is, Point& p) {\n\t\tReal x, y;\n\t\tis >> x >> y;\n\t\tp = Point(x, y);\n\t\treturn is;\n\t}\n\tinline ostream& operator<<(ostream& os, const Point &p) {\n\t\treturn os << fixed << setprecision(15) << p.real() << \" \" << p.imag();\n\t}\n}\n\nusing namespace geometry;\nint main() {\n\tint q; cin >> q;\n\twhile(q--) {\n\t\tPoint p[4];\n\t\tfor(int i = 0; i < 4; ++i) cin >> p[i];\n\t\tSegment s1(p[0], p[1]);\n\t\tSegment s2(p[2], p[3]);\n\t\tcout << intersect(s1, s2) << '\\n';\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8, pi = acos(-1.0);\nbool eq(ld a, ld b){return (abs(b-a)<eps);}\nld dot(Point a, Point b){return real(conj(a)*b);}\nld cross(Point a, Point b){ return imag(conj(a)*b);}\n\nclass Line{\npublic:\n  Point a,b;\n};\n\nld triangle(Point p1, Point p2, Point p3){\n  return cross(p2-p1, p3-p1);\n}\n\nint intersect(Line l1, Line l2){\n  return triangle(l1.a, l1.b, l2.a) * triangle(l1.a, l1.b, l2.b) < 0 && triangle(l2.a, l2.b, l1.a) * triangle(l2.a, l2.b, l1.b) < 0 ? 1 : 0;\n}\n\nint main(){\n  int q;cin>>q;\n  REP(i,q){\n    ld real, imag;\n    Line s1,s2;\n    cin>>real>>imag;\n    s1.a = Point(real,imag);\n    cin>>real>>imag;\n    s1.b = Point(real,imag);\n    cin>>real>>imag;\n    s2.a = Point(real,imag);\n    cin>>real>>imag;\n    s2.b = Point(real,imag);\n    cout<<intersect(s1,s2)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\ndouble sgn(double d) {\n  if (dcmp(d))\n    return 0;\n  if (d > 0)\n    return 1;\n  return -1;\n}\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) { return dcmp(a * p.x + b * p.y + c); }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() { return line(p1, p2); }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    return ok;\n  }\n  bool intersect(segment s) {\n    point a = p1, b = p2, c = s.p1, d = s.p2;\n    return sgn((a - b).cross(b - c)) != sgn((a - b).cross(b - d)) &&\n           sgn((c - d).cross(d - a)) != sgn((c - d).cross(d - b));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1);\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cfloat>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\ntypedef double coordinate_t;\n\nstruct coordinate {\n  coordinate_t x, y;\n  bool operator<(const coordinate & another) const {\n    return x != another.x ? x < another.x : y < another.y;\n  }\n};\n\nstruct line {\n  coordinate_t a, b, c;\n  coordinate p, q;\n};\n\n// is p in [l.x, r.x] * [l.y, r.y] ?\nbool in_section(coordinate p, coordinate l, coordinate r) {\n  coordinate_t lx, ly, rx, ry;\n  lx = min(l.x, r.x);\n  rx = max(l.x, r.x);\n  ly = min(l.y, r.y);\n  ry = max(l.y, r.y);\n  if (lx <= p.x && p.x <= rx && ly <= p.y && p.y <= ry) return true;\n  else return false;\n}\n\n// the intersections of 2 lines\ncoordinate cross_of_2_lines(line k, line l) {\n  coordinate_t dn = l.a * k.b - k.a * l.b;\n  if (dn == 0) return{ NAN, NAN };\n  else {\n    coordinate ret;\n    ret.x = (l.b * k.c - k.b * l.c) / dn;\n    ret.y = (k.a * l.c - l.a * k.c) / dn;\n    if (in_section(ret, k.p, k.q) && in_section(ret, l.p, l.q)) return ret;\n    else return{ NAN, NAN };\n  }\n}\n\n\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (!_isnan(p.x )&& !_isnan(p.y)) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n\n// the line through 2 coordinates\nline line_through_2_coordinates(coordinate p, coordinate q) {\n  if (p.x == q.x && p.y == q.y) return{ NAN, NAN, NAN, p, q };\n  else {\n    if (p.x == q.x) {\n      if (p.y < q.y) return { 1, 0, -p.x, p, q };\n      else return{ 1, 0, -p.x, q, p };\n    }\n    else {\n      if (p.x < q.x) return { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, p, q };\n      else return{ (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, q, p };\n    }\n  }\n}\n\n\n\nint main() {\n  int q; cin >> q;\n  cout << setprecision(18);\n  Loop(i, q) {\n    coordinate p, q;\n    line s, t;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    s = line_through_2_coordinates(p, q);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    t = line_through_2_coordinates(p, q);\n    coordinate r = cross_of_2_lines(s, t);\n    if (_isnan(r.x)) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (cr <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (c == P(0, 0) || c == b) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return 1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        r = max(min(l.s, l.t), min(m.s, m.t));\n        P q = min(max(l.s, l.t), max(m.s, m.t));\n        return (r == q) ? 1 : (q < r ? 0 : -1);\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << abs(crossSS(l1, l2, p)) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\ndouble abs(double x){\n\tif(x>0) return x;\n\telse return -x;\n}\n\nint main(void){\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tdouble o1 = (xp0+xp1)/2; double o2 = (xp2+xp3)/2; double o3 = (yp0+yp1)/2; double o4 = (yp2+yp3)/2;\n\t\tdouble r1 = abs(xp0-xp1)/2; double r2 = abs(xp2-xp3)/2; double r3 = abs(yp0-yp1)/2; double r4 = abs(yp2-yp3)/2;\n\t\tint ret = 0;\n\t\t// parallel\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif(abs(o1-o2) <= (r1+r2) && abs(o3-o4) <= (r3+r4)) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main(void) {\n  int q;\n  std::cin >> q;\n\n  for (int i = 0; i < q; ++i) {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    std::cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    double num = (x2 - x0) * (y3 - y2) - (y2 - y0) * (x3 - x2);\n    double den = (x1 - x0) * (y3 - y2) - (y1 - y0) * (x3 - x2);\n    double t = num / den;\n\n    int result = 0;\n    if (t >= 0.0 && t <= 1.0) {\n      result = 1;\n    }\n  \n    std::cout << result << std::endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) + EPS <= 0 && EPS < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) <= EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tint n;cin >> n;\n\tREP(i, n){\n\t\tdouble a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tsegment seg1(point(a, b), point(c, d));\n\t\tcin >> a >> b >> c >> d;\n\t\tsegment seg2(point(a, b), point(c, d));\n\n\t\tif(intersectSS(seg1, seg2))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){\n      if(s1.real()==0 && s2.real()==0){//tate\n\tif( (0<=abs(p1/s2) && abs(p1/s2)<=1) || (0<=abs(p2/s2) && abs(p2/s2)<=1) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else if(s1.imag()==0 && s2.imag()==0){//yoko\n\tif( (0<=abs(p1/s2) && abs(p1/s2)<=1) || (0<=abs(p2/s2) && abs(p2/s2)<=1) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else \n\tcout<<\"0\"<<endl;\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "// A C++ program to check if two given line segments intersect \n#include <iostream> \nusing namespace std; \n\nstruct Point { \n  int x; \n  int y; \n}; \n\n\nbool onSegment(Point p, Point q, Point r) { \n  if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) && q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y)) {\n    return true; \n  }\n  return false;\n} \n\nint orientation(Point p, Point q, Point r) { \n  int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); \n\n  if (val == 0) return 0; // colinear \n\n  return (val > 0)? 1: 2; // clock or counterclock wise \n} \n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) { \n  // Find the four orientations needed for general and \n  // special cases \n  int o1 = orientation(p1, q1, p2); \n  int o2 = orientation(p1, q1, q2); \n  int o3 = orientation(p2, q2, p1); \n  int o4 = orientation(p2, q2, q1); \n\n  // General case \n  if (o1 != o2 && o3 != o4) return true; \n\n  // Special Cases \n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1 \n  if (o1 == 0 && onSegment(p1, p2, q1)) return true; \n\n  // p1, q1 and q2 are colinear and q2 lies on segment p1q1 \n  if (o2 == 0 && onSegment(p1, q2, q1)) return true; \n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2 \n  if (o3 == 0 && onSegment(p2, p1, q2)) return true; \n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2 \n  if (o4 == 0 && onSegment(p2, q1, q2)) return true; \n\n  return false; // Doesn't fall in any of the above cases \n} \n\n// Driver program to test above functions \nint main() { \n  Point p1, q1, p2, q2;\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    cin >> p1.x >> p1.y >> q1.x >> q1.y >> p2.x >> p2.y >> q2.x >> q2.y;\n    doIntersect(p1, q1, p2, q2) ? cout << \"1\\n\": cout << \"0\\n\"; \n  }\n  return 0; \n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n  public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n  return a.x * a.x + a.y * a.y;\n};\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n};\n\n// 内積\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n};\n\n// 外積\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n};\n\n// 直交判定\nbool isOrthogonal(Vector a, Vector b) {\n  return equals(dot(a, b), 0.0);\n};\n\n// 並行判定\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n};\n\n// 射影\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n};\n\n// 反射\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n};\n\n// 点と点の距離\ndouble getDistance(Point a, Point b) {\n  return abs(a - b);\n};\n\n// 点と直線の距離\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n};\n\n// 点と線分の距離\ndouble getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n};\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// 二つのベクトルの位置関係\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n};\n\n// 線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n};\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n};\n\nint main() {\n  int q;\n  cin >> q;\n  Point p1, p2, p3, p4;\n  Segment s1, s2;\n  rep(i, 0, q) {\n    cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y;\n    s1.p1 = p1;\n    s1.p2 = p2;\n    s2.p1 = p3;\n    s2.p2 = p4;\n    if (intersect(s1, s2)) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\ntypedef Point Vector;\n\nstruct Segment {Point p1, p2;};\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\n// return abs of closs product\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    const int COUNTER_CLOCKWISE = 1, CLOCKWISE = -1;\n    const int ONLINE_BACK = 2, ONLINE_FRONT = -2, ON_SEGMENT = 0;\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) >  eps) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -eps) return CLOCKWISE;\n    if (dot(a, b)   < -eps) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint projection(Point p1, Point p2, Point p0){\n    if(p1 == p0){\n        return p0;\n    }\n    if(p2 == p0){\n        return p0;\n    }\n    return p1 + (p2 - p1) / (p2 - p1).abs() * (p0 - p1).abs() * getCos(p2 - p1, p0 - p1);\n}\n\nPoint reflection(Point p1, Point p2, Point p0){\n    Point p = projection(p1, p2, p0);\n    return p0 + (p - p0) * 2;\n}\n\ndouble getDistanceSP(Point p1, Point p2, Point p0){\n    if(dot(p2 - p1, p0 - p1) < 0.0) return (p0 - p1).abs();\n    if(dot(p1 - p2, p0 - p2) < 0.0) return (p0 - p2).abs();\n    return (projection(p1, p2, p0) -  p0).abs();\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 3\n#define ONLINE_FRONT 4\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    if(counterClockwise(p1, p2, p3) * counterClockwise(p1, p2, p4) < 0){\n        return true;\n    }\n\n    if(counterClockwise(p3, p4, p2) * counterClockwise(p3, p4, p1) < 0){\n        return true;\n    }\n    return false;\n}\n\ndouble getDistance(Point p0, Point p1, Point p2, Point p3){\n    if(intersect(p0, p1, p2, p3)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(p0, p1, p2), getDistanceSP(p0, p1, p3)),\n                min(getDistanceSP(p2, p3, p0), getDistanceSP(p2, p3, p1)));\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n        \n        Point p0 = Point(xp0, yp0);\n        Point p1 = Point(xp1, yp1);\n        Point p2 = Point(xp2, yp2);\n        Point p3 = Point(xp3, yp3);\n\n        if(intersect(p0, p1, p2, p3)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n}\n\n/*\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n\n        printf(\"%.10f\\n\", getDistance(Point(xp0, yp0), Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3)));\n    }\n\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<double> P;\nstatic const double EPS = 1e-14;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_intersect(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS)\n\t\t\t&& (cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nint ax, ay, bx, by;\nint n;\nvector<P> v;\nP A, B;\n//void solve() {\n//\tcin >> ax >> ay >> bx >> by;\n//\tA = P(ax, ay);\n//\tB = P(bx, by);\n//\tcin >> n;\n//\trep(i,0,n)\n//\t{\n//\t\tint x, y;\n//\t\tcin >> x >> y;\n//\t\tv.push_back(P(x, y));\n//\t}\n//\tint cnt = 0;\n//\tfor (int i = 1; i <= n; ++i) {\n//\t\tP p1 = v[i - 1], p2 = v[i % n];\n//\t\tif (is_intersect(A, B, p1, p2)) {\n//\t\t\tcnt++;\n//\t\t}\n//\t}\n//\tcout << cnt / 2 + 1 << endl;\n//}\n\nvoid solve() {\n\tint q;\n\tcin >> q;\n\trep(i,0,q)\n\t{\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tcout\n\t\t\t\t<< (is_intersect(P(x0, y0), P(x1, y1), P(x2, y2), P(x3, y3)) ?\n\t\t\t\t\t\t1 : 0) << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "// CGL_2_B\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n};\n\nbool intersect(point p1, point p2, point p3, point p4){\n\tint a = (p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x);\n\tint b = (p2.x-p1.x)*(p4.y-p1.y) - (p2.y-p1.y)*(p4.x-p1.x);\n\n\tif(a*b <= 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(){\n\tpoint p[4];\n\tint q;\n\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>p[0].x>>p[0].y>>p[1].x>>p[1].y>>p[2].x>>p[2].y>>p[3].x>>p[3].y;\n\n\t\tif(intersect(p[0], p[1], p[2], p[3]) && intersect(p[2], p[3], p[0], p[1]))\n\t\t\tcout<<\"1\"<<endl;\n\t\telse\n\t\t\tcout<<\"0\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nnamespace LibraryOfComputationalGeometry {\n\ttypedef long double ld;\n\tconst ld eps = 1e-9;\n\tstruct point {ld x, y; };\n\tstruct line {point a, b; }; //Be sure that a and b are distinct.\n\tvoid ReadPointInt(point &a) {read(a.x), read(a.y); }\n\tvoid ReadLineInt(line &a) {ReadPointInt(a.a), ReadPointInt(a.b); }\n\tvoid CerrPoint(point a) {cerr << a.x << ' ' << a.y << endl; }\n\tvoid CerrLine(line a) {cerr << a.a.x << ' ' << a.a.y << ' ' << a.b.x << ' ' << a.b.y << endl; }\n\tpoint operator + (point a, point b) {return (point) {a.x + b.x, a.y + b.y}; }\n\tpoint operator - (point a, point b) {return (point) {a.x - b.x, a.y - b.y}; }\n\tpoint operator * (point a, ld b) {return (point) {a.x * b, a.y * b}; }\n\tld dot(point a, point b) {return a.x * b.x + a.y * b.y; }\n\tld operator * (point a, point b) {return a.x * b.y - a.y * b.x; }\n\tld moo(point a) {return sqrtl(a.x * a.x + a.y * a.y); }\n\tld dist(point a, point b) {return moo(a - b); }\n\tpoint unit(point a) {\n\t\tld tmp = moo(a);\n\t\tassert(tmp > eps);\n\t\treturn a * (1.0 / tmp);\n\t}\n\tpoint Projection(point x, line a) {\n\t\tld d = dot(x - a.a, a.b - a.a) / dist(a.a, a.b);\n\t\treturn a.a + unit(a.b - a.a) * d;\n\t}\n\tpoint Reflection(point x, line a) {\n\t\treturn Projection(x, a) * 2 - x;\n\t}\n\tbool OnLine(point x, line a) {\n\t\treturn fabsl((a.b - a.a) * (x - a.a)) <= eps;\n\t}\n\tbool OnSegment(point x, line a) {\n\t\treturn dist(x, a.a) + dist(x, a.b) - dist(a.a, a.b) <= eps;\n\t}\n\tbool Parallel(line a, line b) {\n\t\treturn fabsl((a.b - a.a) * (b.b - b.a)) <= eps;\n\t}\n\tbool Orthogonal(line a, line b) {\n\t\treturn fabsl(dot(a.b - a.a, b.b - b.a)) <= eps;\n\t}\n\tbool SegmentIntersect(line a, line b) {\n\t\tif (Parallel(a, b)) return false;\n\t\tld tmp = ((a.b - a.a) * (b.a - a.a)) * ((a.b - a.a) * (b.b - a.a));\n\t\tld tnp = ((b.b - b.a) * (a.a - b.a)) * ((b.b - b.a) * (a.b - b.a));\n\t\treturn tmp <= eps && tnp <= eps;\n\t}\n}\nint main() {\n\tusing namespace LibraryOfComputationalGeometry;\n\tint q; read(q);\n\twhile (q--) {\n\t\tline a, b;\n\t\tReadLineInt(a);\n\t\tReadLineInt(b);\n\t\tif (SegmentIntersect(a, b)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, int> pci;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nconstexpr double eps=1e-9;\n\ninline int sgn(double x){\n    if(x<-eps) return -1;\n    if(x>eps) return 1;\n    return 0;\n}\n\ninline bool EQ(double x, double y){\n    return sgn(x-y)==0;\n}\n\ninline bool GE(double x, double y){\n    return sgn(x-y)==1;\n}\n\ninline bool LE(double x, double y){\n    return sgn(x-y)==-1;\n}\n\ninline bool GEQ(double x, double y){\n    return sgn(x-y)>=0;\n}\n\ninline bool LEQ(double x, double y){\n    return sgn(x-y)<=0;\n}\n\nstruct Point{\n    double x, y;\n    Point(double x, double y): x(x), y(y){}\n\n    Point operator+(const Point &p){\n        return {x+p.x, y+p.y};\n    }\n\n    Point operator-(const Point &p){\n        return {x-p.x, y-p.y};\n    }\n\n    Point operator*(const double k){\n        return {k*x, k*y};\n    }\n\n    Point operator/(const double k){\n        return {x/k, y/k};\n    }\n\n    double operator*(const Point &p){\n        return x*p.x+y*p.y;\n    }\n\n    double operator^(const Point &p){\n        return x*p.y-y*p.x;\n    }\n\n    bool operator==(const Point &p){\n        return EQ(x, p.x) && EQ(y, p.y);\n    }\n};\n\nusing Vec=Point;\nusing pdi=pair<double, int>;\n\ndouble abs(Point p){\n    return hypot(p.x, p.y);\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nconstexpr int CCW_COUNTER_CLOCKWISE=1;\nconstexpr int CCW_CLOCKWISE=-1;\nconstexpr int CCW_ONLINE_BACK=-2;\nconstexpr int CCW_ONLINE_FRONT=2;\nconstexpr int CCW_ON_SEGMENT=0;\n\ninline int ccw(Point a, Point b, Point c){\n    Vec v=b-a, w=c-a;\n    if(GE(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n    if(LE(v^w, 0)) return CCW_CLOCKWISE;\n    if(LE(v*w, 0)) return CCW_ONLINE_BACK;\n    if(LE((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point a, Point b, Point c, Point d){\n    return ccw(a, b, c)*ccw(a, b, d)<=0 && ccw(c, d, a)*ccw(c, d, b)<=0;\n}\n\nPoint getCrossPointLL(Point p, Vec v, Point q, Vec w){\n    double s=((q-p)^w)/(v^w);\n    return p+v*s;\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    while(q--){\n        vector<Point> p;\n        rep(i, 4){\n            double x, y;\n            scanf(\"%lf%lf\", &x, &y);\n            p.emplace_back(x, y);\n        }\n        printf(\"%d\\n\", intersectSS(p[0], p[1], p[2], p[3]));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 50000 + 10;\nconst double pi = acos(-1.0);\nconst double inf = 1e100;\nconst double eps = 1e-12;\n\ntypedef struct point vec;\nstruct point { //点的基本数据结构\n    double x, y;\n    double poe;\n    point(double _x = 0, double _y = 0)\n        : x(_x)\n        , y(_y)\n    {\n    }\n    double len() //模长\n    {\n        return sqrt(x * x + y * y);\n    }\n    vec chuizhi()\n    {\n        return vec(-y, x);\n    }\n    double operator*(const point& i_T) const //点积\n    {\n        return x * i_T.x + y * i_T.y;\n    }\n    double operator^(const point& i_T) const //叉积\n    {\n        return x * i_T.y - y * i_T.x;\n    }\n    point operator*(double u) const\n    {\n        return point(x * u, y * u);\n    }\n    bool operator==(const point& i_T) const\n    {\n        return fabs(x - i_T.x) < eps && fabs(y - i_T.y) < eps;\n    }\n    point operator/(double u) const\n    {\n        return point(x / u, y / u);\n    }\n    point operator+(const point& i_T)\n    {\n        return point(x + i_T.x, y + i_T.y);\n    }\n    point operator-(const point& i_T)\n    {\n        return point(x - i_T.x, y - i_T.y);\n    }\n    friend bool operator<(point a, point b)\n    {\n        return fabs(a.y - b.y) < eps ? a.x < b.x : a.y < b.y;\n    }\n    void atn2()\n    {\n        poe = atan2(y, x);\n    }\n    friend ostream& operator<<(ostream& out, point& a)\n    {\n        //cout << a.x << ' ' << a.y;\n        printf(\"%.8f %.8f\", a.x, a.y);\n        return out;\n    }\n    friend istream& operator>>(istream& in, point& a)\n    {\n        scanf(\"%lf%lf\", &a.x, &a.y);\n        return in;\n    }\n};\ntypedef struct Line Segment; //线段Segment\nstruct Line { //直线\n    point a, b;\n    double poe;\n    Line(point _a = point(), point _b = point())\n        : a(_a)\n        , b(_b)\n    {\n    }\n    double len()\n    {\n        return (a - b).len();\n    }\n    friend istream& operator>>(istream& in, Line& a)\n    {\n        cin >> a.a >> a.b;\n        return in;\n    }\n    friend ostream& operator<<(ostream& out, Line& a)\n    {\n        out << a.a << ' ' << a.b;\n        return out;\n    }\n    void atn2()\n    {\n        poe = atan2(b.y - a.y, b.x - a.x);\n    }\n};\nbool xiangjiao(Segment l1, Segment l2)\n{\n    point a = l1.a, b = l1.b, c = l2.a, d = l2.b;\n    if (!(min(a.x, b.x) <= max(c.x, d.x) && min(c.y, d.y) <= max(a.y, b.y) && min(c.x, d.x) <= max(a.x, b.x) && min(a.y, b.y) <= max(c.y, d.y)))\n        return 0;\n    double u, v, w, z;\n    u = (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);\n    v = (d.x - a.x) * (b.y - a.y) - (b.x - a.x) * (d.y - a.y);\n    w = (a.x - c.x) * (d.y - c.y) - (d.x - c.x) * (a.y - c.y);\n    z = (b.x - c.x) * (d.y - c.y) - (d.x - c.x) * (b.y - c.y);\n    return (u * v <= eps && w * z <= eps);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        point p1, p2, p3, p4;\n        cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y;\n        vec A = p2 - p1, B = p4 - p3;\n        if (xiangjiao(Segment(p1, p2), Segment(p3, p4)))\n            cout << 1 << endl;\n        else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n    if(cross(a,b) < -EPS){ return CLOCKWISE; }\n    if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n    if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nint main(){\n    int Q;\n    Segment s1,s2;\n    cin >> Q;\n    while(Q--){\n        cin >> s1.s.x >> s1.s.y >> s1.t.x >> s1.t.y;\n        cin >> s2.s.x >> s2.s.y >> s2.t.x >> s2.t.y;\n        cout << isIntersectSS(s1,s2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){\n\t\tx+=p.x,y+=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator-=(Point p){\n\t\tx-=p.x,y-=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator*=(double c){\n\t\tx*=c,y*=c;\n\t\treturn *this;\n\t}\n\tPoint& operator/=(double c){\n\t\tx/=c,y/=c;\n\t\treturn *this;\n\t}\n};\nPoint operator+(Point a,Point b){\n\treturn a+=b;\n}\nPoint operator-(Point a,Point b){\n\treturn a-=b;\n}\nPoint operator*(Point a,double c){\n\treturn a*=c;\n}\nPoint operator*(double c,Point a){\n\treturn a*=c;\n}\nPoint operator/(Point a,double c){\n\treturn a/=c;\n}\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n\texplicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\texplicit operator Line()const{return Line(pos,dir);}\n};\n\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b\n}\n\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\n\nvoid solve()\n{\n\tSegment a; cin>>a.pos.x>>a.pos.y>>a.dir.x>>a.dir.y; a.dir-=a.pos;\n\tSegment b; cin>>b.pos.x>>b.pos.y>>b.dir.x>>b.dir.y; b.dir-=b.pos;\n\tcout<<IntersectSS(a,b)<<endl;\n}\n\nint main()\n{\n\tint q; cin>>q;\n\trep(_,q) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + (double)2 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\t\treturn min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\tfor(int i=0; i<q; ++i) {\n\t\tdouble x[4], y[4];\n\t\tfor(int j=0; j<4; ++j) cin >> x[j] >> y[j];\n\t\tL l1(P{x[0], y[0]}, P{x[1], y[1]}), l2(P{x[2], y[2]}, P{x[3], y[3]}); \n\t\tif(intersectSS(l1, l2)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-10;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\nnamespace geometry {\n// Point : 複素数型を位置ベクトルとして扱う\n// 実軸(real)をx軸、挙軸(imag)をy軸として見る\nusing Point = complex<double>;\n\ninline bool equal(const double &a, const double &b) {\n    return fabs(a - b) < EPS;\n}\n\n// 単位ベクトル(unit vector)を求める\nPoint unitVector(const Point &a) { return a / abs(a); }\n\n// 法線ベクトル(normal vector)を求める\n// 90度回転した単位ベクトルをかける\n// -90度がよければPoint(0, -1)をかける\nPoint normalVector(const Point &a) { return a * Point(0, 1); }\n\n// 内積(dot product) : a・b = |a||b|cosΘ\ndouble dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\ndouble cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点pを反時計回りにtheta度回転\nPoint rotate(const Point &p, const double &theta) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(),\n                 sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアン->度\ndouble radianToDegree(const double &radian) { return radian * 180.0 / PI; }\n\n// 度->ラジアン\ndouble degreeToRadian(const double &degree) { return degree * PI / 180.0; }\n\n// 点の回転方向\n// 点a, b, cの位置関係について\nint ccw(const Point &a, Point b, Point c) {\n    b -= a, c -= a;\n    // 点a, b, c が\n    // 反時計回りの時、\n    if(cross(b, c) > EPS) {\n        return 1;\n    }\n    // 時計回りの時、\n    if(cross(b, c) < -EPS) {\n        return -1;\n    }\n    // c, a, bがこの順番で同一直線上にある時、\n    if(dot(b, c) < 0) {\n        return 2;\n    }\n    // a, b, cがこの順番で同一直線上にある場合、\n    if(norm(b) < norm(c)) {\n        return -2;\n    }\n    // cが線分ab上にある場合、\n    return 0;\n}\n\n// Line : 直線を表す構造体\n// b - a で直線・線分を表せる\nstruct Line {\n    Point a, b;\n    Line() = default;\n    Line(Point a, Point b) : a(a), b(b) {}\n    // Ax+By=C\n    Line(double A, double B, double C) {\n        if(equal(A, 0)) {\n            a = Point(0, C / B), b = Point(1, C / B);\n        } else if(equal(B, 0)) {\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        } else {\n            a = Point(0, C / B), b = Point(C / A, 0);\n        }\n    }\n    friend ostream &operator<<(ostream &os, Line &p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a) {\n        return is >> a.a >> a.b;\n    }\n};\n\n// Segment : 線分を表す構造体\n// Lineと同じ\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n// Circle : 円を表す構造体\n// pが中心の位置ベクトル、rは半径\nstruct Circle {\n    Point p;\n    double r;\n\n    Circle() = default;\n\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(const Line &a, const Line &b) {\n    return equal(dot(a.b - a.a, b.b - b.a), 0);\n}\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(const Line &a, const Line &b) {\n    return equal(cross(a.b - a.a, b.b - b.a), 0);\n}\n\n// 点cが直線ab上にあるか\nbool isPointOnLine(const Point &a, const Point &b, const Point &c) {\n    return isParallel(Line(a, b), Line(a, c));\n}\n\n// 点cが\"線分\"ab上にあるか\nbool isPointOnSegment(const Point &a, const Point &b, const Point &c) {\n    // |a-c| + |c-b| <= |a-b| なら線分上\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n// 直線lと点pの距離を求める\ndouble distanceBetweenLineAndPoint(const Line &l, const Point &p) {\n    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\n// 線分lと点pの距離を求める\n// 定義：点pから「線分lのどこか」への最短距離\ndouble distanceBetweenSegmentAndPoint(const Segment &l, const Point &p) {\n    if(dot(l.b - l.a, p - l.a) < EPS) {\n        return abs(p - l.a);\n    }\n    if(dot(l.a - l.b, p - l.b) < EPS) {\n        return abs(p - l.b);\n    }\n    return abs(cross(l.b - l.a, p - l.a)) / abs(l.b - l.a);\n}\n\n// 線分sと線分tが交差しているかどうか\nbool isIntersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 射影(projection)\n// 直線(線分)lに点pから引いた垂線の足を求める\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\n// 反射(reflection)\n// 直線lを対称軸として点pと線対称の位置にある点を求める\nPoint reflection(const Line &l, const Point &p) {\n    return p + (projection(l, p) - p) * 2.0;\n}\n} // namespace geometry\n\nusing namespace geometry;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    int q;\n    cin >> q;\n    while(q--) {\n        vector<Point> p(4);\n        for(int i = 0; i < 4; i++) {\n            double x, y;\n            cin >> x >> y;\n            p[i] = Point(x, y);\n        }\n        Segment s(p[0], p[1]), t(p[2], p[3]);\n        cout << isIntersect(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nusing Point = complex<double>;\nusing Polygon = vector<Point>;\n\ninline int sgn(const double &a) { return (a < -EPS ? -1 : (a > EPS ? 1 : 0)); }\n\ninline bool eq(const Point &a, const Point &b) { return abs(a - b) < EPS; }\n\nnamespace std {\ninline bool operator<(const Point &a, const Point &b) {\n    if (sgn(a.real() - b.real()))\n        return sgn(a.real() - b.real()) < 0;\n    return sgn(a.imag() - b.imag()) < 0;\n}\n} // namespace std\n\ndouble dot(const Point &a, const Point &b) { return real(conj(a) * b); }\n\ndouble det(const Point &a, const Point &b) { return imag(conj(a) * b); }\n\nstruct Line {\n    Point p1, p2;\n\n    Line(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator<(const Line &rhs) const {\n        if (eq(p2, rhs.p2))\n            return p1 < rhs.p1;\n        return p2 < rhs.p2;\n    }\n    bool operator==(const Line &rhs) const {\n        return (eq(p1, rhs.p1) && eq(p2, rhs.p2)) ||\n               (eq(p1, rhs.p2) && eq(p2, rhs.p1));\n    }\n};\n\nenum CCW {\n    ONLINE_FRONT = -2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Point a = p1 - p0;\n    Point b = p2 - p0;\n    if (sgn(det(a, b)) == 1)\n        return COUNTER_CLOCKWISE;\n    if (sgn(det(a, b)) == -1)\n        return CLOCKWISE;\n    if (sgn(dot(a, b)) == -1)\n        return ONLINE_BACK;\n    if (sgn(norm(b) - norm(a)) == 1)\n        return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool is_intersected(Line a, Line b, bool segflag){\n    if(segflag)return (ccw(a.p1, a.p2, b.p1) * ccw(a.p1, a.p2, b.p2) <= 0) &&\n            (ccw(b.p1, b.p2, a.p1) * ccw(b.p1, b.p2, a.p2) <= 0);\n    else return (sgn(det(a.p2-a.p1, b.p1-a.p1) * det(a.p2-a.p1, b.p2-a.p1)) <= 0) &&\n            (sgn(det(b.p2-b.p1, a.p1-b.p1) * det(b.p2-b.p1, a.p2-b.p1)) <= 0);\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for(int i=0;i<q;++i){\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Point p0 = Point(x0, y0), p1 = Point(x1, y1), p2 = Point(x2, y2), p3 = Point(x3, y3);\n        Line s1 = Line(p0, p1), s2 = Line(p2, p3);\n        cout << (is_intersected(s1, s2, true) ? 1 : 0) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1, i##_end_ = (n); i <= i##_end_; ++i)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n\nconst double eps = 1e-10;\nint sgn(double x) {\n    if(fabs(x) < eps) return 0;\n    return x < 0 ? -1 : 1;\n}\nstruct Point {\n    double x, y;\n    Point(double xp=0, double yp=0): x(xp), y(yp) { }\n    Point operator + (const Point& rhs) const { return Point(x+rhs.x, y+rhs.y); }\n    Point operator - (const Point& rhs) const { return Point(x-rhs.x, y-rhs.y); }\n    Point operator * (const double& k) const { return Point(x*k, y*k); }\n    Point operator / (const double& k) const { return Point(x/k, y/k); }\n    bool operator < (const Point& rhs) const { return x < rhs.x || (x==rhs.x && y<rhs.y); }\n    bool operator == (const Point& rhs) const {return sgn(x - rhs.x) == 0 && sgn(y - rhs.y) == 0; }\n    Point turn(double rad) { return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); }\n    void scan() { scanf(\"%lf%lf\", &x, &y); }\n};\ntypedef Point Vector;\n\ndouble dot(Vector x, Vector y) { return x.x*y.x + x.y*y.y; }\ndouble length(Vector x) { return sqrt(dot(x, x)); }\ndouble cross(Vector A, Vector B) { return A.x*B.y - A.y*B.x; }\n\n\nPoint LineProjection(Point P, Point A, Point B) {\n    Vector v = B - A;\n    return A + v * (dot(P-A, v) / dot(v, v));\n}\nPoint LineReflection(Point P, Point A, Point B) {\n    Point proj = LineProjection(P, A, B);\n    return proj + proj - P;\n}\n\nint Clockwise(Point O, Point A, Point B) {\n    /* Clockwise: -1\n       Counterclockwise: 1\n       Otherwise: 0\n    */\n    return sgn(cross(A - O, B - O));\n}\n\nvoid SegCheck(Point a, Point b, Point p) {\n    Vector d = b - a, e = p - a;\n    if(sgn(dot(d, e)) == -1) puts(\"ONLINE_BACK\");\n    else if(sgn(length(e) - length(d)) == 1) puts(\"ONLINE_FRONT\");\n    else puts(\"ON_SEGMENT\");\n}\n\nint JudgeLLParOrth(Point a1, Point a2, Point b1, Point b2) {\n    /* 2: parallel\n       1: orthogonal\n       0: otherwise\n    */\n    Vector v = a2 - a1, w = b2 - b1;\n    if(sgn(cross(v, w)) == 0) return 2;\n    if(sgn(dot(v, w)) == 0) return 1;\n    return 0;\n}\n\nbool CheckSSProperIntersection(Point a1, Point a2, Point b1, Point b2) {\n    double c1 = cross(a1 - b1, b2 - b1), c2 = cross(a2 - b1, b2 - b1);\n    double c3 = cross(b1 - a1, a2 - a1), c4 = cross(b2 - a1, a2 - a1);\n    return sgn(c1) * sgn(c2) == -1 && sgn(c3) * sgn(c4) == -1;\n}\nbool OnSeg(Point P, Point A, Point B) {\n    Vector v = B - P, w = A - P;\n    if(sgn(cross(v, w)) != 0) return false;\n    return sgn(dot(v, w)) == -1;\n}\n\nbool CheckSSIntersection(Point a1, Point a2, Point b1, Point b2) {\n    if(a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2) return true;\n    if(OnSeg(a1, b1, b2) || OnSeg(a2, b1, b2) || OnSeg(b1, a1, a2) || OnSeg(b2, a1, a2))\n        return true;\n    return CheckSSProperIntersection(a1, a2, b1, b2);\n}\n\nint main() {\n    Point a1, a2, b1, b2;\n    int q; scanf(\"%d\", &q);\n    while(q--) {\n        a1.scan(), a2.scan();\n        b1.scan(), b2.scan();\n        printf(\"%d\\n\", CheckSSIntersection(a1, a2, b1, b2));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-7;\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\ndouble cross(P a,P b){return real(b*conj(a));}\ndouble dot(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n \n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return imag((c-a)*conj(b-a))/abs(b-a);\n}\n \nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n \n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  return min(min(abs(a-c),abs(a-d)),min(abs(b-c),abs(b-d)));\n}\n \nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy;\n     \n    cout<< isintersect ( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) <<endl;\n  //    printf(\"%.12f\\n\",dist( P(ax,ay) , P(bx,by) , P(cx,cy) , P(dx,dy) ) );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(){}\n\tPoint(const Point &P){\n\t\tx=P.x;\n\t\ty=P.y;\n\t}\n\tPoint(double a, double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tPoint operator*(const double coe)const\n\t{\n\t\tPoint P;\n\t\tP.x=x*coe;\n\t\tP.y=y*coe;\n\t\treturn P;\n\t}\n\tPoint operator-(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x-P.x;\n\t\tresult.y=y-P.y;\n\t\treturn result;\n\t}\n\tPoint operator+(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x+P.x;\n\t\tresult.y=y+P.y;\n\t\treturn result;\n\t}\n};\n\nclass Line\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tLine(){}\n\tLine(Point a, Point b){\n\t\tp1=a;\n\t\tp2=b;\n\t}\n\tLine(const Line &L){\n\t\tp1=L.p1;\n\t\tp2=L.p2;\n\t}\n\tdouble cross(const Line &L)const{\n\t\treturn (p2.x-p1.x)*(L.p2.y-L.p1.y)-(p2.y-p1.y)*(L.p2.x-L.p1.x);\n\t}\n\tPoint intersection(const Line &L)const{//line intersection point\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            result.x=-999999;\n            result.y=-999999;\n            return result;\n\t\t}\n\t\tresult=p1+(p2-p1)*(Line(L.p1, p1).cross(L)/L.cross(*this));\n\t\treturn result;\n\t}\n\tbool point_on_segment(const Point &P)const{//point on line, but on segment?\n\t\tif((P.x-p1.x)*(P.x-p2.x)<=1e-7&&(P.y-p1.y)*(P.y-p2.y)<=1e-7) return 1;\n\t\treturn 0;\n\t}\n\tbool valid_intersection(const Line &L)const{//segment intersect?\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            Line L2(p2, L.p1);\n            if(cross(L2)==0&&(point_on_segment(L.p1)||point_on_segment(L.p2)||L.point_on_segment(p1)||L.point_on_segment(p2))) return 1;\n            return 0;\n\t\t}\n\t\tresult=intersection(L);\n\t\t/*printf(\"%d\\n\", point_on_segment(result));\n\t\tprintf(\"%d\\n\", L.point_on_segment(result));*/\n\t\tif(point_on_segment(result)&&L.point_on_segment(result)) return 1;\n\t\treturn 0;\n\t}\n\tLine perpendicular_bisector()const{//a perpendicular bisector line\n\t    Point P1((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n\t    Point v(p2.y-p1.y, p1.x-p2.x);\n\t    Point P2=P1+v;\n\t    Line result(P1, P2);\n\t    return result;\n\t}\n};\n\nclass Polygon\n{\npublic:\n\tvector<Point> v;\n\tPolygon(){\n\t\tv.clear();\n\t}\n\tdouble area(){//area\n\t\tdouble a=0;\n\t\tfor(int i=1;i<v.size()-1;i++){\n\t\t\tLine L1(v[0], v[i]);\n\t\t\tLine L2(v[0], v[i+1]);\n\t\t\ta+=L1.cross(L2);\n\t\t}\n\t\tif(a<0) return (-a)/2;\n\t\telse return a/2;\n\t}\n\tPolygon HPits(Line &L){//half plane intersection //only keep the counterclockwise side's polygon\n\t\tPolygon q;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tLine L1(L.p1, v[i]);\n\t\t\tif(L.cross(L1)>=0) q.v.push_back(v[i]);\n\t\t\tLine L2(L.p1, v[(i+1)%v.size()]);\n\t\t\tif(L.cross(L1)*L.cross(L2)<0) q.v.push_back(L.intersection(Line(v[i], v[(i+1)%v.size()])));\n\t\t}\n\t\treturn q;\n\t}\n};\n\nclass Triangle\n{\npublic:\n    Point a;\n    Point b;\n    Point c;\n    Triangle(){}\n    Triangle(Point A, Point B, Point C){\n        a=A; b=B; c=C;\n    }\n    Point center(){//tircumcenter\n        Line L1(a, b);\n        Line L2(b, c);\n        Line N1=L1.perpendicular_bisector();\n        Line N2=L2.perpendicular_bisector();\n        return N1.intersection(N2);\n    }\n    double area(){\n        Line L1(a, b);\n        Line L2(a, c);\n        double ans=L1.cross(L2);\n        if(ans<0) ans=-ans;\n        return ans/2;\n    }\n    bool point_in_triangle(const Point &P)const{\n        Line L1(P, a);\n        Line L2(P, b);\n        Line L3(P, c);\n        if(L1.cross(L2)<=0&&L2.cross(L3)<=0&&L3.cross(L1)<=0) return 1;\n        if(L1.cross(L2)>=0&&L2.cross(L3)>=0&&L3.cross(L1)>=0) return 1;\n        return 0;\n    }\n};\n\nbool ans[1000];\n\nint main()\n{\n    int n, i, tmp;\n    double x, y;\n    //freopen(\"out.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for(i=0;i<n;i++){\n        scanf(\"%lf %lf\", &x, &y);\n        Point P1(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P2(x, y);\n        Line L1(P1, P2);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P3(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P4(x, y);\n        Line L2(P3, P4);\n        ans[i]=L1.valid_intersection(L2);\n        printf(\"%d\\n\", ans[i]);\n    }\n    /*for(i=0;i<n;i++){\n        scanf(\"%d\", &tmp);\n        if(tmp!=ans[i]) printf(\"RRRRRR!!!!!! %d\\n\", i);\n    }*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nnamespace LibraryOfComputationalGeometry {\n\ttypedef long double ld;\n\tconst ld eps = 1e-9;\n\tstruct point {ld x, y; };\n\tstruct line {point a, b; }; //Be sure that a and b are distinct.\n\tvoid ReadPointInt(point &a) {read(a.x), read(a.y); }\n\tvoid ReadLineInt(line &a) {ReadPointInt(a.a), ReadPointInt(a.b); }\n\tvoid CerrPoint(point a) {cerr << a.x << ' ' << a.y << endl; }\n\tvoid CerrLine(line a) {cerr << a.a.x << ' ' << a.a.y << ' ' << a.b.x << ' ' << a.b.y << endl; }\n\tpoint operator + (point a, point b) {return (point) {a.x + b.x, a.y + b.y}; }\n\tpoint operator - (point a, point b) {return (point) {a.x - b.x, a.y - b.y}; }\n\tpoint operator * (point a, ld b) {return (point) {a.x * b, a.y * b}; }\n\tld dot(point a, point b) {return a.x * b.x + a.y * b.y; }\n\tld operator * (point a, point b) {return a.x * b.y - a.y * b.x; }\n\tld moo(point a) {return sqrtl(a.x * a.x + a.y * a.y); }\n\tld dist(point a, point b) {return moo(a - b); }\n\tpoint unit(point a) {\n\t\tld tmp = moo(a);\n\t\tassert(tmp > eps);\n\t\treturn a * (1.0 / tmp);\n\t}\n\tpoint Projection(point x, line a) {\n\t\tld d = dot(x - a.a, a.b - a.a) / dist(a.a, a.b);\n\t\treturn a.a + unit(a.b - a.a) * d;\n\t}\n\tpoint Reflection(point x, line a) {\n\t\treturn Projection(x, a) * 2 - x;\n\t}\n\tbool OnLine(point x, line a) {\n\t\treturn fabsl((a.b - a.a) * (x - a.a)) <= eps;\n\t}\n\tbool OnSegment(point x, line a) {\n\t\treturn dist(x, a.a) + dist(x, a.b) - dist(a.a, a.b) <= eps;\n\t}\n\tbool Parallel(line a, line b) {\n\t\treturn fabsl((a.b - a.a) * (b.b - b.a)) <= eps;\n\t}\n\tbool Orthogonal(line a, line b) {\n\t\treturn fabsl(dot(a.b - a.a, b.b - b.a)) <= eps;\n\t}\n\tbool SegmentIntersect(line a, line b) {\n\t\tld tmp = ((a.b - a.a) * (b.a - a.a)) * ((a.b - a.a) * (b.b - a.a));\n\t\tld tnp = ((b.b - b.a) * (a.a - b.a)) * ((b.b - b.a) * (a.b - b.a));\n\t\treturn tmp <= eps && tnp <= eps;\n\t}\n}\nint main() {\n\tusing namespace LibraryOfComputationalGeometry;\n\tint q; read(q);\n\twhile (q--) {\n\t\tline a, b;\n\t\tReadLineInt(a);\n\t\tReadLineInt(b);\n\t\tif (SegmentIntersect(a, b)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    double x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(double nx, double ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(double nx) {\n        x = nx;\n    }\n    \n    void setY(double ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    double cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (double f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (double f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(double sx, double sy, double ex, double ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        double c1 = l1.cross(l.getStart() - start);\n        double c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        double c3 = l2.cross(start - l.getEnd());\n        double c4 = l2.cross(end - l.getEnd());\n        \n        if (c1 * c2 <= 0.0 && c3 * c4 <= 0.0) { // 外積の正負が異なるとき\n            return 1;\n        } else { // 外積の正負が同一のとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        double sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(O,a.t-a.s,b.t-b.s)==0;}\nbool parallel(L a,L b) {return sdet(O,a.t-a.s,b.t-b.s)==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(O,a.t-a.s,b.t-b.s);\n\treturn u*a.s+(1-u)*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h=l.s;\n\tif(sdot(l.t,l.s,p)<=0) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << (sgn(dss(s1,s2))==0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#include<algorithm>\n#include<array>\n#include<cmath>\n#include<vector>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\ntypedef double Real;\nconst Real EPS = 1e-8;\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\n//define class ...\n\nstruct Point {\n\tReal x, y;\n\tPoint(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\n\tPoint operator+(const Point &p) const {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator-(const Point &p) const {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator*(Real s) const {\n\t\treturn Point(x * s, y * s);\n\t}\n\n\tPoint operator/(Real s) const {\n\t\treturn Point(x / s, y / s);\n\t}\n\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1);\n\t}\n\n\tbool operator==(const Point &p) const {\n\t\treturn sign(x - p.x) == 0 && sign(y - p.y) == 0;\n\t}\n};\n\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tPoint r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// define function\nPoint rotate90(const Point &p) { // ???????¨???¨???\n\treturn Point(-p.y, p.x);\n}\n\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nReal angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\nReal norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nReal abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\nReal dot(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n\treturn sign( cross(a[1] - a[0], b[1] - b[0]) ) == 0;\n} \n\n// define app function\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real crs = cross(p, q); \n\t\n\tif(sign(crs) == 1) return CCW;\n\tif(sign(crs) == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tPoint p0, p1, p2, p3;\n\tint q;\t\n\tcin >> q;\t\n\trep(i, q) {\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tSegment s1 = Segment(p0, p1);\n\t\tSegment s2 = Segment(p2, p3);\n\t\tbool ans = intersect(s1, s2);\t\n\t\tcout << ((ans) ? 1 : 0) << endl; \n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INTMAX 2147483647LL\n#define PII pair<int,int>\n#define MK make_pair\n#define re register\n#define Eps (1e-10)\n#define Equal(a,b) (fabs((a)-(b))<Eps)\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst double Pi=acos(-1.0);\nconst int Inf=0x3f3f3f3f;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\ninline int read(){\n\tre int x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\ninline ll readll(){\n\tre ll x=0,f=1,ch=getchar();\n\twhile(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-48,ch=getchar();\n\treturn x*f;\n}\n\nstruct Point{\n\tdb x,y;\n\tPoint(){}\n\tPoint(db xx,db yy):x(xx),y(yy){}\n\tinline Point operator +(const Point &p){return Point(x+p.x,y+p.y);}\n\tinline Point operator -(const Point &p){return Point(x-p.x,y-p.y);}\n\tinline Point operator *(const db &k){return Point(x*k,y*k);}\n\tinline Point operator /(const db &k){return Point(x/k,y/k);}\n\tinline db Norm(){return x*x+y*y;}\n\tinline db abs(){return sqrt(Norm());}\n\tinline bool operator <(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tinline bool operator ==(const Point &p)const{return fabs(x-p.x)<Eps&&fabs(y-p.y)<Eps;}\n}; \n\ntypedef Point Vector;\ntypedef vector<Point> Poly;\n\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point p1_,Point p2_):p1(p1_),p2(p2_){}\n};\ntypedef Segment Line;\nstruct Circle{\n\tPoint c;db r;\n\tCircle(Point cc,db rr):c(cc),r(rr){}\n};\n\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n\ninline bool Is_Vertical(Vector a,Vector b){return Equal(dot(a,b),0.0);}\ninline bool Is_Vertical(Point a1,Point a2,Point b1,Point b2){return Is_Vertical(a1-a2,b1-b2);}\ninline bool Is_Vertical(Segment s1,Segment s2){return Equal(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);}\n\ninline bool Is_Parallel(Vector a,Vector b){return Equal(cross(a,b),0.0);}\ninline bool Is_Parallel(Point a1,Point a2,Point b1,Point b2){return Is_Parallel(a1-a2,b1-b2);}\ninline bool Is_Parallel(Segment s1,Segment s2){return Equal(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);}\n\nPoint Project(Segment s,Point p){\n\tVector bse=s.p2-s.p1;\n\tdouble res=dot(p-s.p1,bse)/norm(bse);\n\treturn s.p1+bse*res;\n}\nPoint Reflect(Segment s,Point p){return p+(Project(s,p)-p)*2.0;}\n\ninline int CCW(Point p0,Point p1,Point p2){\n\tVector a=p1-p0,b=p2-p0;\n\tif(cross(a,b)>Eps) return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-Eps)return CLOCKWISE;\n\tif(dot(a,b)<-Eps)  return ONLINE_BACK;\n\tif(a.Norm()<b.Norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT; \n}\n\ninline bool Is_Intersect(Point p1,Point p2,Point p3,Point p4){\n\treturn (CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0)&&(CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n} \nPoint p1,p2,p3,p4;\nint n;\n\nint main(){\n\tn=read();\n\twhile(n--){\n\t\tcin>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y>>p4.x>>p4.y;\n\t\tprintf(\"%d\\n\",Is_Intersect(p1,p2,p3,p4));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) {a = _a, b = _b, v = b - a;}\n    L(double _ax, double _ay, double _bx, double _by) {\n        a = P(_ax, _ay), b = P(_bx, _by), v = b - a;\n    }\n};\n\n// 0: counter-clockwise\n// 1: clockwise\n// 2: online_back\n// 3: online_front\n// 4: on_segment\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return 0;\n    if (cross(p1 - p0, p2 - p0) < 0) return 1;\n    if (dot(p1 - p0, p2 - p0) < 0) return 2;\n    if (dot(p0 - p1, p2 - p1) < 0) return 3;\n    return 4;\n}\n\nbool intersectPS(P p, L l) {\n    return ccw(l.a, l.b, p) == 4;\n}\n\nbool intersectSS(L l1, L l2) {\n    double c1 = cross(l1.v, l2.a - l1.a);\n    double c2 = cross(l1.v, l2.b - l1.a);\n    double c3 = cross(l2.v, l1.a - l2.a);\n    double c4 = cross(l2.v, l1.b - l2.a);\n    // all points on the same line\n    if (c1 == 0 && c2 == 0 == c3 == 0 && c4 == 0) {\n        return (intersectPS(l2.a, l1) || intersectPS(l2.b, l1) ||\n                intersectPS(l1.a, l2) || intersectPS(l1.b, l2));\n    }\n    return (cross(l1.v, l2.a - l1.a) * cross(l1.v, l2.b - l1.a) < EPS &&\n            cross(l2.v, l1.a - l2.a) * cross(l2.v, l1.b - l2.a) < EPS);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        double v[4][2];\n        rep(i, 4) rep(j, 2) cin >> v[i][j];\n        L l1(v[0][0], v[0][1], v[1][0], v[1][1]);\n        L l2(v[2][0], v[2][1], v[3][0], v[3][1]);\n        cout << intersectSS(l1, l2) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\ntypedef vector<Point> Polygon;                      //????§???¢\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n//????????????a?????§??????\ndouble absolute(Vector a){\n    return sqrt(norm(a));\n}\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//????????????a??¨b?????´?????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\n\n//????????????a??¨b???????????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isParallel(Vector a , Vector b){\n    return equals(cross(a,b), 0.0);\n}\n\n//??????s(p1p2)???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//??????s(p1p2)???????§°?????¨?????????p???????±????\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\n//???a,???b???????????¢\ndouble getDistance(Point a, Point b){\n    return absolute(a - b);\n}\n\n//??´???s??¨???p????????¢\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / absolute(l.p2 - l.p1));\n}\n\n//??????s(?§????p1/??????p2)??¨???p????????¢d????±???????\n//??\\???????????????????????§??´?????????\n//??????????????????p2-p1??¨???????????????p-p1??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p1??¨????????¢\n//??????????????????p1-p2??¨???????????????p-p2??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p2??¨????????¢\n//??????????????\\???????????????????????´??????d??????p??¨??´???p1p2????????¢\ndouble getDistanceSP(Segment s, Point p){\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absolute(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absolute(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n//??????s1??¨??????s2????????¢\n//??\\????????????????????¢????????§????????????????????????\n//????????????s1??¨??????s2????§????s2.p1????????¢\n//????????????s1??¨??????s2?????????s2.p2????????¢\n//????????????s2??¨??????s1????§????s1.p1????????¢\n//????????????s2??¨??????s1?????????s1.p2????????¢\ndouble getDistance(Segment s1, Segment s2){\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n    \n}\n\n//??????s1??¨??????s2?????????????±???????\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//?????¨??????l?????????????±???????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / absolute(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????????±???????\nVector polar(double a, double r){\n    //??????a,?§????r???point????±???????\n    return Point(cos(r) * a, sin(r) * a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    Vector v = c2.c - c1.c;\n    double d = absolute(v);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d) );\n    double t = atan2(v.y, v.x);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\n\n\nint main(){\n    \n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    \n    int q;\n    \n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        if(\n           intersect(\n                     Point(x0, y0),\n                     Point(x1, y1),\n                     Point(x2, y2),\n                     Point(x3, y3)\n                     )\n        ) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n    public:\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x * x + y * y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot((s1.p2 - s1.p1), (s2.p2 - s2.p1)), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n    Point projection = project(s, p);\n    Vector toReflection = (projection - p) * 2.0;\n    return p + toReflection; \n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n\n    // 反時計\n    if (cross(v1, v2) > 0.0) return 1;\n    // 時計\n    if (cross(v1, v2) < 0.0) return -1;\n\n    // p1, p2 が逆方向\n    if (dot(v1, v2) < 0.0) return 2;\n\n    // p1, p2 が同方向\n    if (v1.abs() < v2.abs()) return -2;\n    return 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n            && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p) < 0) return (s.p2 - p).abs();\n\n    return getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) {\n        return 0.0;\n    }\n\n    return min(\n        min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n        min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n    );\n}\n\ndouble getDistancePP(Point p1, Point p2) {\n    return (p2 - p1).abs();\n}\n\nint main() {\n    /*\n    cout << fixed << setprecision(11);\n\n    double x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    Point p1 = {x1, y1};\n    Point p2 = {x2, y2};\n    Segment s1 = {p1, p2};\n\n    double x3, y3, x4, y4;\n    cin >> x3 >> y3 >> x4 >> y4;\n    Point p3 = {x3, y3};\n    Point p4 = {x4, y4};\n    Segment s2 = {p3, p4};\n\n    double dist = distanceBetweenSegments(s1, s2);\n    */\n\n    int q;\n    cin >> q;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Point p0 = {x0, y0};\n        Point p1 = {x1, y1};\n        Point p2 = {x2, y2};\n        Point p3 = {x3, y3};\n        Segment s1 = {p0, p1};\n        Segment s2 = {p2, p3};\n\n        if (intersect(s1, s2)) {\n            cout << \"1\" << endl;\n        } else {\n            cout << \"0\" << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y){}\n    point operator +(point a){\n        return point(x+a.x,y+a.y);\n    }\n    point operator -(point a){\n        return point(x-a.x,y-a.y);\n    }\n}p[5];\ntypedef point vector;\ndouble cross(vector a,vector b){\n    return a.x*b.y-a.y*b.x;\n}\ndouble dot(vector a,vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble norm(vector a){\n    return a.x*a.x+a.y*a.y;\n}\nint ccw(point p1,point p2,point p3){\n    vector a=p2-p1,b=p3-p1;\n    if(cross(a,b)>eps) return 1;\n    if(cross(a,b)<-eps) return -1;\n    if(dot(a,b)<-eps) return 2;\n    if(norm(a)<norm(b)) return -2;\n    return 0;\n}\nbool intersect(point p1,point p2,point p3,point p4){\n    return (((ccw(p1,p2,p3)*ccw(p1,p2,p4))<=0)&&((ccw(p3,p4,p1)*ccw(p3,p4,p2))<=0));\n}\nint main(){\n    int n;\n    double x,y;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=4;++j){\n            scanf(\"%lf%lf\",&x,&y);\n            p[j]=point(x,y);\n        }\n        if(intersect(p[1],p[2],p[3],p[4])) printf(\"1\\n\");\n        else printf(\"0\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n\nint main(){\n    \n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    \n    int q;\n    \n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        Point p0 = Point(x0, y0);\n        Point p1 = Point(x1, y1);\n        Point p2 = Point(x2, y2);\n        Point p3 = Point(x3, y3);\n        \n        \n        if( intersect(p0, p1, p2, p3) ) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n            if(x1>x2)swap(x1, x2);\n            if(y1>y2)swap(y1, y2);\n            if(x3>x4)swap(x3, x4);\n            if(y3>y4)swap(y3, y4);\n            \n            if(x1<=x3&&x3<=x2&&y1<=y3&&y3<=y2)return 1;\n            if(x1<=x4&&x4<=x2&&y1<=y4&&y4<=y2)return 1;\n            if(x3<=x1&&x1<=x4&&y3<=y1&&y1<=y4)return 1;\n            if(x3<=x2&&x2<=x4&&y3<=y2&&y2<=y4)return 1;\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0) return 0;\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool check(double d,int a,int b){\n\treturn ((d<=a&&d>=b)||(d>=a&&d<=b));\n}\n\n\t\nint main(){\n\tint q;\n\tint ans[1000];\n\tint x0,x1,x2,x3,y0,y1,y2,y3;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tans[i]=0;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tif(x1==x0){\n\t\t\tdouble k=(y3-y2)/(x3-x2);\n\t\t\tdouble d=k*(x0-x3)+y3; //?????????y??§?¨?\n\t\t\tif(check(d,y1,y0)){\n\t\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\t else if(x2==x3){\n\t\t\t  double t=(y1-y0)/(x1-x0);\n\t\t\t  double e=t*(x2-x1)+y1; //?????????y??§?¨?\n\t\t\t  if(check(e,y2,y3)){\n\t\t\t  \tans[i]=1;\n\t\t\t  }\n\t\t\t }\n\t\telse if(x1!=x0&&x3!=x2){\n\t\tdouble t=(y1-y0)/(x1-x0);\n\t\tdouble k=(y3-y2)/(x3-x2);\n\t\tif(t!=k){\n\t\tdouble c=(t*x1+y1-k*x3+y3)/(t-k); //?????????x??§?¨?\n\t\tif(check(c,x2,x3)&&check(c,x0,x1)){\n\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const {\n        return max(std::abs(x), std::abs(y));\n    } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        if (!rless(m.s, m.t)) swap(m.s, m.t);\n        if (!rless(l.s, m.s)) swap(l, m);\n        if (ccw(l, m.s) == 0) {\n            r = m.s;\n            if (near(l.t, m.s)) return 1;\n            return -1;\n        }\n        return 0;\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v+di, v-di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << crossSS(l1, l2, p) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n\tdouble dot(const Point &o) const { return x * o.x + y * o.y; }\n\n\tdouble atan() const { return atan2(y, x); }\n\n\tdouble norm() const { return sqrt(dot(*this)); }\n\n\tdouble distance(const Point &o) const { return (o - (*this)).norm(); }\n\n\tdouble area(const Point &a,const Point &b) {\n\t\tPoint p = a - (*this), p2 = b - (*this); \n\t\treturn p.cross(p2);\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const {\n\t\tPoint p = a - (*this), p2 = b - (*this);\n\t\treturn fabs(p.cross(p2)) / 2.0;\n\t}\t\n\n\t//??????ab?????????????????????????????????????????????????????????\n\tint between(const Point &a,const Point &b) {\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)  return ((a.x <= x) && (x <= b.x)) || ((a.x >= x) && (x >= b.x));\n\t\telse return ((a.y <= y) && (y <= b.y)) || ((a.y >= y) && (y >= b.y));\n\t}      \n\n\tdouble distance_seg(const Point& a,const Point& b) {\n\t\tif((b-a).dot(*this-a) < EPS) {\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS) {\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(b.cross(c) > 0.0) return +1;\t//conter clockwise\n\tif(b.cross(c) < 0.0) return -1;\t//clockwise\n\tif(b.dot(c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }\n\n\tbool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }\n\n\tbool isIntersect(Seg &s) {\n\t\treturn ccw(a, b, s.a) * ccw(a, b, s.b) <= 0 && ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0;\n\t}\n\n\tbool distance(Seg &s) {\n\t\tif((*this).isIntersect(s)) return 0.0;\n\n\t\treturn min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));\n\t}\n\n\tPoint getCrossPoint(Seg &s) {\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n\tPoint project(Point &p) {\n\t\tPoint base = b - a;\n\t\tdouble t = base.dot(p-a) / base.dot(base);\n\t\treturn a + base * t;\n\t}\n\n\tPoint reflect(Point &p) {\n\t\treturn p + (project(p) - p) * 2.0;\n\t}\n};\n\nostream& operator << (ostream& os, const Seg& s) {\n\tos << \"(\" << s.a.x << \", \" << s.a.y << \")-(\" << s.b.x << \",\" << s.b.y << \")\";\n\treturn os;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tSeg s1, s2;\n\trep(i, q) {\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\n\t\tif(s1.isIntersect(s2)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main(){\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        Segment s1,s2;\n        getSegment(s1);\n        getSegment(s2);\n        if(intersect(s1,s2))puts(\"1\");\n        else puts(\"0\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define EPS (1e-10)\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\nenum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n\t\tVerified: AOJ 2003 Railroad Conflict\n*/\nbool intersect(const segment<double> &S1, const segment<double> &S2 ){\n\tif (max (S1.a.x, S1.b.x )+EPS < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y )+EPS < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x )+EPS < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y )+EPS < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tint q; cin >> q;\n\trep (i, q ){\n\t\tsegment<double> s1, s2;\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\t\n\t\tint res = intersect (s1, s2 );\n\t\tcout << res << endl;\n\t} // end rep\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n \n#define EPS 1e-10\n \nusing namespace std;\n \nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n    double naiseki,norm1,norm2,gaiseki;\n    norm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n    norm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n    naiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n    gaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n    if(gaiseki > EPS){\n        return 1;\n    }else if(gaiseki < -EPS){\n        return -1;\n    }\n \n    if(naiseki < -EPS){\n        return 2;\n    }\n \n    if(norm1 < norm2){\n        return -2;\n    }\n    return 0;\n}\n \n \nint main(){\n    double x1,x2,x3,x4,y1,y2,y3,y4;\n    int q;\n    scanf(\"%d\",&q);\n \n    for(int i=0;i<q;i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n \n        if(func(x1,y1,x2,y2,x3,y3)*func(x1,y1,x2,y2,x4,y4) <= 0 &&\n                func(x3,y3,x4,y4,x1,y1) * func(x3,y3,x4,y4,x2,y2) <= 0){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nstruct Point{\n  double x, y;\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ndouble dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nPoint project(Segment s, Point p){\n  Vector a = s.p2 - s.p1;\n  Vector b = p - s.p1;\n  return s.p1 + a * (dot(a, b)/a.norm());\n}\n\nPoint reflect(Segment s, Point p){\n  return p + (project(s, p) - p)*2;\n}\n\nstatic const int Counter_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return Counter_CLOCKWISE;\n  else if(cross(a, b) < -EPS) return CLOCKWISE;\n  else if(dot(a, b) < -EPS) return ONLINE_BACK;\n  else if(a.norm() < b.norm()) return ONLINE_FRONT;\n  else return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nint main(){\n  int q;\n  cin >> q;\n\n  rep(i, q){\n    double x1, y1, x2, y2;\n    double x3, y3, x4, y4;\n    cin >> x1 >> y1 >> x2 >> y2;\n    cin >> x3 >> y3 >> x4 >> y4;\n    Point p1 = Point(x1, y1);\n    Point p2 = Point(x2, y2);\n    Point p3 = Point(x3, y3);\n    Point p4 = Point(x4, y4);\n    cout << intersect(p1, p2, p3, p4) << endl;\n  }\n\n  return 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble p0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0,\n\t\t\t   u = 0, s = 0, t = 0;\n\t\tint n = 0;\n\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\n\t\tif (u != 0) {\n\t\t\ts = ((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = -((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((p1y - p0y) * (p2x - p0x) - (p1x - p0x) * (p2y - p0y) != 0) {\n\t\t\t\tif ((p2x - p0x) * (p3x - p0x) + (p2y - p0y) * (p3y - p0y) <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse if (((p2x - p0x) * (p3x - p0x) + (p2y - p0y) * (p3y - p0y) <= 0) | \n\t\t\t\t((p2x - p1x) * (p3x - p1x) + (p2y - p1y) * (p3y - p1y) <= 0))\n\t\t\t\tn = 1;\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\nconst double EPS=1e-9;\nconst double PI=3.141592653589793238;//18 ragham\n\nbool Equal(double d1,double d2)\n{ return fabs(d1-d2)<EPS;}\n\nstruct line{double a,b,c;};\nstruct vec\n{\n  double x,y;\n  vec(double _x=0,double _y=0)\n  {x=_x;  y=_y;}\n};\n  \nstruct point_i\n{\n  int x,y;\n  point_i(int _x=0,int _y=0){x=_x;y=_y;}\n};\nstruct point\n{\n  double x,y;\n  point(double _x=0,double _y=0){x=_x;y=_y;}\n  bool operator < (point other)\n  {  \n    if(fabs(x-other.x)<EPS)\n      return y<other.y;\n    return x<other.x;}\n  bool operator == (point other)\n  {return (fabs(x-other.x)<EPS) && (fabs(y-other.y)<EPS) ;}\n  \n  \n};\ndouble Hypot(double dx,double dy)\n{\n  return sqrt(dx*dx+dy*dy);\n}\ndouble Distance(point p1,point p2)\n{\n  return hypot(p1.x-p2.x,p1.y-p2.y);\n}\ndouble DEG_to_RAD(double theta)\n{\n  return theta*PI/180;\n}\ndouble RAD_to_DEG(double rad)\n{\n  return rad*180/PI;\n}\npoint rotate(point p, double theta)//theta is degree\n{\n  \n  //rotation matrixR(theta) = [cos(theta) - sin(theta)]\n  //                          [sin(theta) + cos(theta)]\n  //usage: [x'] = R(theta)* [x]\n  //       [y']             [y]\n  double rad=DEG_to_RAD(theta);\n  return point(p.x * cos(rad) - p.x * sin(rad) ,\n\t       p.y * sin(rad) + p.y * cos(rad)  );\n}\nvoid PointsToLine(point p1,point p2,line *l)\n{\n  if(p1.x==p2.x) // vertical line handled here\n    { l->a=1.0;   l->b= 0.0 ; l->c=-p1.x;}\n  else\n    {\n      l->a=-(double)(p1.y-p2.y)/(p1.x-p2.x);\n      l->b=1.0;\n      l->c=-(double)(l->a * p1.x) - (l->b*p1.y);\n    }\n}\nbool AreParallel(line l1,line l2)\n{\n  return Equal(l1.a,l2.a) && Equal(l1.b,l2.b);\n}\nbool AreSame(line l1,line l2)\n{\n  return AreParallel(l1,l2) && Equal(l1.c,l2.c);\n}\nbool AreIntersect(line l1,line l2,point *p)//TO BE CHECKED (mine)\n{\n  if(AreSame(l1,l2))\n    return false;\n  if(AreParallel(l1,l2))\n    return false;\n\n  //solving\n  double delta=(double)l1.a*l2.b - l1.b*l2.a;\n  if(Equal(delta,0))//this if should never be true because lines are't parallel\n    return false;\n  //a1x+b1y=-c1\n  //a2x+b2y=-c2\n  p->x= (double)(-l1.c*l2.b+l2.c*l1.b) / delta;\n  p->y= (double)(-l1.a*l2.c+l2.a*l1.c) / delta;\n  return true;\n}\nvec ToVector(point p1,point p2)\n{\n  return vec(p2.x-p1.x,p2.y-p1.y);\n}\nvec ScaleVector(vec v, double s) // v*=s\n{\n  return vec(v.x*s,v.y*s);\n}\npoint Translate(point p,vec move)//moves point p in direction of vector move\n{\n  return point(p.x+move.x , p.y + move.y);\n}\ndouble Dot(double x1,double y1 ,double x2,double y2)\n{ return x1*x2+y1*y2;};\ndouble Determinant(double x1,double y1,double x2,double y2)\n{return x1*y2-x2*y1;};\n//angle A<BC (radian (PI) )\ndouble Angle(point A,point B,point C)\n{\n  double dot=Dot(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  double det=Determinant(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  //atan2(y,x), or atan2(sin,cos)\n  return atan2(det,dot);\n}\ndouble Cross(point p,point q,point r)\n{\n  return (r.x-q.x)*(p.y-q.y)-(r.y-q.y)*(p.x-q.x);\n}\nbool Collinear(point p,point q,point r)\n{\n  return Equal(Cross(p,q,r),0);\n}\n//returns true if point r is on the left side of line pq\nbool CCW(point p,point q,point r)\n{\n   //can be modified to accept collinear ( >0 instead of >EPS )\n  if(Cross(p,q,r) > EPS)\n    return true;\n  return false;\n}\n\n//returns the distance from p to line AB\n// A and B must be different\n//closest point is in *c\ndouble DistToLine(point p,point A,point B,point *c)\n{// formula : c= A+ (p-A).(A-B)/|B-A|*(B-A)\n  double scale= (double)\n    ((p.x-A.x)*(B.x-A.x)+(p.y-A.y)*(B.y-A.y))/\n    ((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));\n  c->x= A.x + scale*(B.x - A.x);\n  c->y= A.y + scale*(B.y - A.y);\n  \n  return Distance(p,*c);\n}\ndouble DistToLineSegment(point p,point A,point B,point *c)\n{\n  if((B.x-A.x) * (p.x-A.x)+ (B.y-A.y)*(p.y-A.y) <EPS)\n    { c->x=A.x ; c->y= A.y;\n      return Distance(p,A);}//closer to A\n \n  if((A.x-B.x) * (p.x-B.x)+ (A.y-B.y)*(p.y-B.y) <EPS)\n    { c->x=B.x ; c->y= B.y;\n      return Distance(p,B);}//closer to B\n\n  return DistToLine(p,A,B,c);\n  \n}\n//returns true if p is on segment AB\nbool IsOnLineSegment(point p,point A,point B)\n{\n   if(Collinear(p,A,B)==false)\n    return false;\n  if(p==A || p==B)\n    return true;\n  double angle=Angle(A,p,B);\n  //cout<<\"angle:\"<<RAD_to_DEG(angle)<<endl;\n  if(Equal( angle, PI ) || Equal(angle,-PI) ||  Equal(RAD_to_DEG(angle),180) )\n    return true;\n  return false;\n}\nbool AreSegmentsIntersect(point A,point B,point C,point D,point *p)\n{\n  line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2))\n    {\n      //cout<<\"A\"<<endl;\n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))\n\tcnt++;\n      if(IsOnLineSegment(B,C,D))\n\tcnt++;\n      if(IsOnLineSegment(C,A,B))\n\tcnt++;\n      if(IsOnLineSegment(D,A,B))\n\tcnt++;\n      if(cnt!=2)\n\treturn false;\n      if(A==C || A==D){\n\tp->x=A.x;\n\tp->y=A.y;\n\treturn true;}\n      if(B==C || B==D){\n\tp->x=B.x;\n\tp->y=B.y;\n\treturn true;}\n      return false;\n    }\n \n  if(AreIntersect(l1,l2,p))\n    {\n      //cout<<\"B\"<<endl;\n      //\t  cout<<p->x<<\" \"<<p->y<<endl;\n      if(IsOnLineSegment(*p,A,B) && IsOnLineSegment(*p,C,D))\n\treturn true;\n      return false;\n    }\n  //cout<<\"C\"<<endl;\n  return false;\n    \n}\n///*****************### End of Library ###*******************///\n\n\n\n\n\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    {\n      int x,y;\n      point A,B,C,D,p;\n      cin>>x>>y;\n      A=point(x,y);\n      \n      cin>>x>>y;\n      B=point(x,y);\n      \n      cin>>x>>y;\n      C=point(x,y);\n      \n      cin>>x>>y;\n      D=point(x,y);\n      if(AreSegmentsIntersect(A,B,C,D,&p))\n\tcout<<1<<endl;\n      else\n\tcout<<0<<endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0) return 0;\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\n\tif ((p0-r).dot(p1-r) <=0) {\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define SQ(x) ((x)*(x))\n#define min(x, y) ((x)>(y)?(y):(x))\n#define max(x, y) ((x)<(y)?(y):(x))\ntypedef long long ll;\nstruct Point{\n\tint x,y;\n}p1,p2,p3,p4;\nPoint vector(Point p1,Point p2){\n\tPoint res;\n\tres.x = p2.x-p1.x;\n\tres.y = p2.y-p1.y;\n\treturn res;\n}\nint dot(Point p1, Point p2){ return p1.x*p2.x+p1.y*p2.y; }\nint cross(Point p1, Point p2){ return p1.x*p2.y-p1.y*p2.x; }\nll lengthSQ(Point vec){ return SQ(ll(vec.x))+SQ(ll(vec.y)); }\nint loc(Point pt0, Point pt1, Point pt2){\n\tPoint vec1 = vector(pt0, pt1);\n\tll vec1Len2 = lengthSQ(vec1);\n\tPoint vec2 = vector(pt0, pt2);\n\tint cro = cross(vec1, vec2);\n\tif(cro>0) return -1;// a×b>0，则b在a的逆时针方向\n\telse if(cro<0) return 1;// a×b<0，则b在a的顺时针方向\n\telse if(dot(vec1, vec2)<0) return -1;// a×b=0, a·b<0，则a、b方向相反\n\telse if(lengthSQ(vec2)>vec1Len2) return 1;\n\telse return 0;\n}\nvoid solve(){\n\tif(loc(p1, p2, p3) * loc(p1, p2, p4)<=0 && \n\t\tloc(p3, p4, p1) * loc(p3, p4, p2)<=0) printf(\"1\\n\");\n\telse printf(\"0\\n\");\n}\nbool rectDiv(){// 返回线段所在矩形是否相交\n\tif(max(p1.x, p2.x)<min(p3.x, p4.x) ||\n\t\tmin(p1.x, p2.x)>max(p3.x, p4.x) ||\n\t\tmax(p1.y, p2.y)<min(p3.y, p4.y) ||\n\t\tmin(p1.y, p2.y)>max(p3.y, p4.y))\n\t\treturn false;\n\telse return true;\n}\nint main(){\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--){\n\t\tscanf(\"%d%d%d%d%d%d%d%d\", &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y, &p4.x, &p4.y);\n\t\tif(rectDiv()) solve();\n\t\telse printf(\"0\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\"\n#line 1 \"/Users/knaga/programming/procon_library/macro/macros.hpp\"\n\n\n\n/*\n@title Macro\n@category template\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n  os << \"{\" <<p.first << \", \" << p.second << \"}\";\n  return os;\n}\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\n\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n\n\n#line 1 \"/Users/knaga/programming/procon_library/geometory/template.cpp\"\n\n\n#line 5 \"/Users/knaga/programming/procon_library/geometory/template.cpp\"\n/*\n@title Geometory/template.cpp\n@category Geometory\n*/\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Segment;\n#define EPS (1e-10)\n#define EQ(a, b) (abs((a) - (b)) < EPS)\nPoint operator*(const Point &p, const double &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n// 内積\ndouble dot(Point a, Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積\ndouble cross(const Point &a, const Point &b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n/*\n\"https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_1_A\"\n直線 l に p から引いた交点を求める\n*/\nPoint projection(const Segment &l, const Point &p){\n    double t = dot(p - l.first, l.second - l.first) / norm(l.second - l.first);\n    return l.first + t * (l.second - l.first);\n}\n/*\n直線 l に関して線対称な点を求める\n*/\nPoint reflection(const Segment &l, const Point &p){\n    return p + (projection(l,p)-p)*2.0;\n}\n/*\nhttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\ncrockwise\n*/\nint ccw(const Point &a, const Point &b, const Point &c){\n    Point x = b - a;\n    Point y = c - a;\n    if(cross(x,y) > EPS)return 1;   //時計回り\n    if(cross(x,y) < -EPS)return -1; //反時計回り\n    if(dot(x,y) < -EPS)return +2;   //後ろ\n    if(norm(x) < norm(y))return -2; //前\n    return 0;                       //中\n}\nbool intersect(const Segment &a, const Segment &b){\n    double ok[2];\n    ok[0] = ccw(a.first, a.second, b.first)*ccw(a.first, a.second, b.second);\n    ok[1] = ccw(b.first, b.second, a.first)*ccw(b.first, b.second, a.second);\n    return ok[0] <= 0 && ok[1] <= 0;\n}\nbool is_intersected_ls(Point a1, Point a2, Point b1, Point b2){\n    bool ok[2];\n    ok[0] = (cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < EPS);\n    ok[1] = (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < EPS);\n    return ok[0] && ok[1];\n}\n\n\n#line 4 \"CGL_2_B.test.cpp\"\nint main(){\n    int q;\n    cin >> q;\n    while(q--){\n        vector<Point> ps;\n        rep(i,4){\n            int x, y;\n            cin >> x >> y;\n            ps.emplace_back(x,y);\n        }\n        Segment s[] = {make_pair(ps[0], ps[1]), make_pair(ps[2], ps[3])};\n        if(intersect(s[0],s[1])){\n            cout << 1 << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll q;\n  cin >> q;\n  double x,y;\n  rep(i,q){\n    cin >> x >> y;\n    P a(x,y);\n    cin >> x >> y;\n    P b(x,y);\n    cin >> x >> y;\n    P c(x,y);\n    cin >> x >> y;\n    P d(x,y);\n    L ab(a,b),cd(c,d);\n    std::cout << intersectSS(ab,cd) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) {a = _a, b = _b, v = b - a;}\n    L(double _ax, double _ay, double _bx, double _by) {\n        a = P(_ax, _ay), b = P(_bx, _by), v = b - a;\n    }\n};\n\n// +1: counter-clockwise\n// -1: clockwise\n// +2: online_back\n// -2: online_front\n// 0: on_segment\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1;\n    if (cross(p1 - p0, p2 - p0) < 0) return -1;\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;\n    return 0;\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        double v[4][2];\n        rep(i, 4) rep(j, 2) cin >> v[i][j];\n        L l1(v[0][0], v[0][1], v[1][0], v[1][1]);\n        L l2(v[2][0], v[2][1], v[3][0], v[3][1]);\n        cout << intersectSS(l1, l2) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// definition of turning\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n  double x, y;\n  Point (double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) {return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) {return Point(x - p.x, y - p.y); }\n  Point operator * (double a) {return Point(a * x, a * y); }\n  Point operator / (double a) {return Point(x / a, y / a); }\n\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const\n  {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const\n  {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment\n{\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  Segment(double x1, double y1, double x2, double y2)\n  {\n    p1 = Point(x1, y1);\n    p2 = Point(x2, y2);\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\n// dot and cross product\ndouble dot(Vector a, Vector b)\n{\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b)\n{\n  return a.x * b.y - a.y * b.x;\n}\n\n// orthogonality\nbool isOrthagonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\n\nbool isOrthagonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthagonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthagonal(Segment s1, Segment s2)\n{\n  return isOrthagonal(s1.p1 - s1.p2, s2.p1 - s2.p2);\n}\n\n// parallelism\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n  return isParallel(s1.p1 - s1.p2, s2.p1 - s2.p2);\n}\n\n// projection & reflection\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\n\n// distance\ndouble getDistance(Point a, Point b)\n{\n  return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p1 - l.p2, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n  if (dot(p - s.p1, s.p2 - s.p1) < 0) return getDistance(p, s.p1);\n  if (dot(p - s.p2, s.p1 - s.p2) < 0) return getDistance(p, s.p2);\n  return getDistanceLP(s, p);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\ndouble getDistanceSS(Segment s1, Segment s2)\n{\n  if (intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), \\\n            min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n//ccw\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// intersection\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \\\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main()\n{\n  int T;\n  scanf(\"%d\", &T);\n  while (T--)\n  {\n    Point p0, p1, p2, p3;\n    scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p0.x, &p0.y, &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y);\n    printf(\"%d\\n\", intersect(p0, p1, p2, p3));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// 線分と線分の交差判定\n//\n// verified:\n//   AOJ Course CGL_2_B Segments/Lines - Intersection\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n//\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n\n/* Point */\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n/* projection, is_intersect, distnce */\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (norm(b-a) < norm(c-a)) return -2;\n    return 0;\n}\n\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\nint main() {\n    int Q; cin >> Q;\n    for (int _ = 0; _ < Q; ++_) {\n        Point x1, y1, x2, y2;\n        cin >> x1.x >> x1.y >> y1.x >> y1.y >> x2.x >> x2.y >> y2.x >> y2.y;\n        Line s(x1, y1), t(x2, y2);\n        if (isinterSS(s, t)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-9\n\nusing namespace std;\ntypedef double db;\nstruct P{\n    db x, y;\n    P(){}\n    P(db x, db y) : x(x) , y(y) {}\n    P operator - (P a){ return P(x-a.x, y-a.y); }\n    db times(P a){ return x*a.y-y*a.x; }\n};\ntypedef P V;\nstruct L{ P p, q; };\n\nint sign(db x){ return x<-eps ? -1 : x>eps; }\n\nbool intersection(P p1, P q1, P p2, P q2){\n    if(max(p1.x,q1.x)+eps < min(p2.x,q2.x)) return false;\n    if(max(p1.y,q1.y)+eps < min(p2.y,q2.y)) return false;\n    if(max(p2.x,q2.x)+eps < min(p1.x,q1.x)) return false;\n    if(max(p2.y,q2.y)+eps < min(p1.y,q1.y)) return false;\n    int t1=sign( (p2-p1).times(q1-p1) )*sign( (q1-p1).times(q2-p1) ), \n    t2=sign( (p1-p2).times(q2-p2) )*sign( (q2-p2).times(q1-p2) );\n    return (t1>=0) && (t2>=0);\n}\n\nint main(){\n    //freopen(\"owo.in\",\"r\",stdin);\n    L s1, s2;\n    int n;\n    cin >> n;\n    while(n--){\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &s1.p.x, &s1.p.y, &s1.q.x, &s1.q.y, &s2.p.x, &s2.p.y, &s2.q.x, &s2.q.y);\n        printf(\"%d\\n\", intersection(s1.p, s1.q, s2.p, s2.q));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Point{\n    long long x,y;\n    Point():x(0),y(0){}\n    Point(long long _x,long long _y):x(_x),y(_y){}\n};\nstruct Vector{\n    long long x,y;\n    Vector(long long _x,long long _y):x(_x),y(_y){}\n};\nVector to_vector(Point a,Point b){\n    return Vector(b.x-a.x,b.y-a.y);\n}\nlong long cross(Vector a,Vector b){\n    return (a.x*b.y)-(a.y*b.x);\n}\n// checks whether point B lies on line segment AC\nbool on_line_segment(Point a,Point b,Point c){\n    if(cross(to_vector(a,b),to_vector(b,c))==0\n     &&min(a.x,c.x)<=b.x&&b.x<=max(a.x,c.x)\n     &&min(a.y,c.y)<=b.y&&b.y<=max(a.y,c.y))return true;\n    return false;\n}\nbool line_segment_intersection(Point a,Point b,Point c,Point d){\n    if(cross(to_vector(a,b),to_vector(b,c))*cross(to_vector(a,b),to_vector(b,d))<0\n     &&cross(to_vector(c,d),to_vector(d,a))*cross(to_vector(c,d),to_vector(d,b))<0)return true;\n    if(on_line_segment(a,c,b)\n     ||on_line_segment(a,d,b)\n     ||on_line_segment(c,a,d)\n     ||on_line_segment(c,b,d))return true;\n    return false;\n}\nint q;\nPoint p[4];\nint main(){\n    scanf(\"%d\",&q);\n    while(q--){\n        for(int i=0;i<4;i++)scanf(\"%lld %lld\",&p[i].x,&p[i].y);\n        if(line_segment_intersection(p[0],p[1],p[2],p[3]))puts(\"1\");\n        else puts(\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\n//const int INF = 100100100;\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\n\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator<(const Point & p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator==(const Point & p) const {\n\t\treturn fabs(x - p.x) < EPS and fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x* b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x* b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n//直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//平行判定\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//線分sに対する点pの射影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n//線分ｓに対する点ｐの反射\nPoint refrect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n//2点間の距離\ndouble getDistance(Point a, Point b) {\n\tPoint res = a - b;\n\treturn res.abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / Vector(l.p2 - l.p1).abs());\n}\n\n//線分ｓと点ｐの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\tPoint r = p - s.p1;\n\t\treturn r.abs();\n\t}\n}\n\n//counter clock wise\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分と線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//線分と線分の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tint q;\n\tcin >> q;\n\trep(i, q) {\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tif (intersect(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3))) {\n\t\t\tcout << \"1\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"0\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct Point { double x; double y; };\n\nPoint a, b, c, d;\ndouble f(Point p) {\n  return (b.y - a.y) * (p.x - a.x) - (b.x - a.x) * (p.y - a.y);\n}\ndouble g(Point p) {\n  return (d.y - c.y) * (p.x - c.x) - (d.x - c.x) * (p.y - c.y);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  ll Q; cin >> Q;\n  for (ll i = 0; i < Q; i++) {\n    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y;\n    double ans0 = g(a), ans1 = g(b),  ans2 = f(c), ans3 = f(d);\n    int ans = 0;\n\n    if (g(a) * g(b) <= 0 && f(c) * f(d) <= 0) {\n      ans = 1;\n    }\n    if (g(a) == 0 && g(b) == 0 && f(c) == 0 && f(d) == 0) {\n      ans = 0;\n      if (a.x != b.x) {\n        if (a.x > b.x) swap(a, b);\n        if (c.x > d.x) swap(c, d);\n        if (a.x <= c.x && c.x <= b.x || a.x <= d.x && d.x <= b.x) ans = 1;\n        if (c.x <= a.x && a.x <= d.x || c.x <= b.x && b.x <= d.x) ans = 1;\n      } else {\n        if (a.y > b.y) swap(a, b);\n        if (c.y > d.y) swap(c, d);\n        if (a.y <= c.y && c.y <= b.y || a.y <= d.y && d.y <= b.y) ans = 1;\n        if (c.y <= a.y && a.y <= d.y || c.y <= b.y && b.y <= d.y) ans = 1;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n#include <complex>\n\nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\ntypedef std::complex<double> Com;\n\n//geometric library\n//#include <complex>\n//typedef complex<double> Com;\n//c++ -std=c++14\n\n//内積\ndouble dot_product(const Com a, const Com b){\n\treturn (conj(a)*b).real();\n}\n//外積\ndouble cross_product(const Com a, const Com b){\n\treturn (conj(a)*b).imag();\n}\n//点と直線の距離\ndouble dist_dot_line(const Com st, const Com en, const Com dt){\n    return std::abs(cross_product(dt-st, en-st) / std::abs(en-st));\n}\n//点と線分の距離\ndouble dist_dot_seg(const Com st, const Com en, const Com dt){\n\tif(dot_product(en-st, dt-st) <= 0){\n\t\treturn std::abs(dt-st);\n\t}else if(dot_product(st-en, dt-en) <= 0){\n\t\treturn std::abs(dt-en);\n\t}else{\n\t\treturn dist_dot_line(st, en, dt);\n\t}\n}\n//線分の交差判定\n//平行・接触は含まない(接触を含みたいときはdist_seg==0を使う)\nbool seg_crossing(const Com st1, const Com en1, const Com st2, const Com en2){\n\tdouble cross1 = cross_product(en1-st1, st2-st1) * cross_product(en1-st1, en2-st1);\n\tdouble cross2 = cross_product(en2-st2, st1-st2) * cross_product(en2-st2, en1-st2);\n\treturn (cross1 < 0) && (cross2 < 0);//\n}\n//線分と線分の距離\ndouble dist_seg(const Com st1, const Com en1, const Com st2, const Com en2){\n\tif(seg_crossing(st1, en1, st2, en2)){\n\t\treturn 0;\n\t}\n\treturn std::min(std::min(dist_dot_seg(st1, en1, st2), dist_dot_seg(st1, en1, en2)), std::min(dist_dot_seg(st2, en2, st1), dist_dot_seg(st2, en2, en1)));\n}\n\ndouble x[8];\nCom p[4];\n\nvoid solve(){\n    for(int i = 0; i < 8; i++){\n        scanf(\"%lf\", x+i);\n    }\n    for(int i = 0; i < 4; i++){\n        p[i] = Com(x[2*i], x[2*i+1]);\n    }\n    if(dist_seg(p[0], p[1], p[2], p[3]) == 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n}\n\nlong n;\nint main(){\n    scanf(\"%ld\", &n);\n    for(int i = 0; i < n; i++){\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// ------ Defines ------ //\n#define Point complex<long double>\n#define px real()\n#define py imag()\n// ------ Classes ------ //\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p1x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tLine(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p1x, p2y)) {};\n\tfriend bool operator==(const Line& s1, const Line& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Line& s1, const Line& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint prj(const Segment& a, const Point& b) {\n\tPoint c = a.p2 - a.p1;\n\treturn a.p2 + c * dot(b - a.p1, norm(c));\n}\nPoint rfl(const Segment& a, const Point& b) {\n\treturn b + (prj(a, b) - b) * 2.0L;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ------ Main ------ //\nint q, xp1, yp1, xp2, yp2, xq1, yq1, xq2, yq2;\nint main() {\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d\", &xp1, &yp1, &xp2, &yp2, &xq1, &yq1, &xq2, &yq2);\n\t\tprintf(\"%d\\n\", its(Segment(xp1, yp1, xp2, yp2), Segment(xq1, yq1, xq2, yq2)) ? 1 : 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//???????????????????????????????????°???\n//??????????????????????????????????????????????????????\n//references<http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm>\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tlong double ax, ay, bx, by, cx, cy, dx, dy; cin >> ax >> ay >> bx >> by >> cx >> cy >> dx >> dy;\n\t\tint ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\t\tint tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\t\tint tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\t\tint td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\t\t//cout << \"ta = \" << ta << \" tb = \" << tb << \" tc = \" << tc << \" td = \" << td << \" tc*td = \" << tc*td << \" ta*tb = \" << ta*tb << endl;\n\n\t\tif ((tc * td < 0) && (ta * tb < 0)) {\n\t\t\tcout << \"1\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"0\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0) :x(x), y(y) {};\n\n\tpoint operator + (point p) { return point(x + p.x, y + p.y); }\n\tpoint operator - (point p) { return point(x - p.x, y - p.y); }\n\tpoint operator * (double s) { return point(x * s, y * s); }\n\tpoint operator / (double s) { return point(x / s, y / s); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const point &p) const\n\t{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const point &p) const\n\t{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ndouble dot(point a, point b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(point a, point b, point c)\n{\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > EPS) return 1;//???????¨????????????????a,b,c??¨?????¶\n\tif (cross(b, c) < -EPS) return -1;//???????¨????????????????a,c,b??¨?????¶\n\tif (dot(b, c) < 0) return 2;//??´?????????c,a,b??????????????¶\n\tif (b.norm() < c.norm()) return -2;//??´?????????a,b,c??????????????¶\n\treturn 0;//??´?????????a,c,b??????????????¶\n}\n\nstruct line\n{\n\tpoint a, b;\n\tline(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0) :a(point(x1, y1)), b(point(x2, y2)) {};\n\n\tpoint univec() { return (b - a) / (b - a).norm(); }\n};\n\nbool isis_ss(line s, line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tint a[8];\n\t\tREP(i, 8) cin >> a[i];\n\t\tline s(a[0], a[1], a[2], a[3]);\n\t\tline t(a[4], a[5], a[6], a[7]);\n\t\tif (isis_ss(s, t)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing Point = complex< double >;\nconst double EPS = 1e-10, PI = acos(-1);\n\nbool eq(double a, double b){ return fabs(a-b) < EPS; }\n\nistream &operator>> (istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<< (ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\n// rotate Φ(rad)\n// x = r * cos(θ + Φ)\n//   = r * cos(θ) * cos(Φ) - r * sin(θ) * sin(Φ)\n//   = x * cos(Φ) - y * sin(Φ) (∵ cos(θ) = x/r, sin(θ) = y/r)  \nPoint rotate(double phi, const Point &p) {\n  double x = p.real(), y = p.imag();\n  return Point(x * cos(phi) - y * sin(phi), x * sin(phi) + y * cos(phi));\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\nstruct Line{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b){}\n\n  Line(double A, double B, double C){\n    //ax + by = c\n    if(eq(A, 0)){\n      a = Point(0, C/B), b = Point(1, C/B);\n    }else if(eq(B, 0)){\n      a = Point(C/A, 0), b = Point(C/A, 1);\n    }else{\n      a = Point(0, C/B), b = Point(C/A, 0);\n    }\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n  friend ostream &operator<<(ostream &os, Line &a) {\n    return os << a.a << \" to \" << a.b;\n  }\n};\n\nstruct Segment: Line{\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() = default;\n\n  Circle(Point p, double r): p(p), r(r){}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point& a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\n//https://mathtrain.jp/projection\nPoint projection(const Line &l, const Point &p){\n  double t = dot(p - l.a, l.a-l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p){\n  double t = dot(p - l.a, l.b-l.a) / norm(l.a - l.b);\n  return l.a + (l.b - l.a) * t;\n}\n\nPoint reflection(const Line &l, const Point &p){\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n  if(cross(b-a, c-a) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(b-a, c-a) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b-a, c-a) < -EPS) return 2;    // \"ONLINE_BACK\" c-a-b\n  if(norm(b-a) < norm(c-a) - EPS) return -2;  // \"ONLINE_FRONT\" a-b-c\n  return 0;                         // \"ON_SEGMENT\" a-c-b\n}\n\nbool parallel(const Line &a, const Line &b){\n  return eq(cross(a.a-a.b, b.a-b.b), 0.0);\n}\nbool orthogonal(const Line &a, const Line &b){\n  return eq(dot(a.a-a.b, b.a-b.b), 0.0);\n}\nbool intersect(const Segment &a, const Segment &b) {\n  return ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) <= 0 && ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) <= 0;\n}\nint main(){\n  int q;\n  cin >> q;\n  while(q--){\n    Segment a, b;\n    cin >> a >> b;\n    if(intersect(a, b)){\n      cout << 1 << endl;\n    }else{\n      cout << 0 << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Seg{\npublic:\n    Point p1;\n    Point p2;\n    Seg(Point p1_, Point p2_){\n        p1 = p1_;\n        p2 = p2_;\n    }\n};\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint project(Seg s, Point p0){\n    if(s.p1 == p0){\n        return p0;\n    }\n    if(s.p2 == p0){\n        return p0;\n    }\n    return s.p1 + (s.p2 - s.p1) / (s.p2 - s.p1).abs() * (p0 - s.p1).abs() * getCos(s.p2 - s.p1, p0 - s.p1);\n}\n\nPoint reflect(Seg s, Point p0){\n    Point p = project(s, p0);\n    return p0 + (p - p0) * 2;\n}\n\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Seg s1, Seg s2){\n    int t1 = counterClockwise(s1.p1, s1.p2, s2.p1);\n    int t2 = counterClockwise(s1.p1, s1.p2, s2.p2);\n    int t3 = counterClockwise(s2.p1, s2.p2, s1.p1);\n    int t4 = counterClockwise(s2.p1, s2.p2, s1.p2);\n    if(t1 * t2 <= 0){\n        if(t3 * t4 <= 0){\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble getDistanceSP(Seg s, Point p0){\n    if(dot(s.p2 - s.p1, p0 - s.p1) < 0.0) return (p0 - s.p1).abs();\n    if(dot(s.p1 - s.p2, p0 - s.p2) < 0.0) return (p0 - s.p2).abs();\n    return (project(s, p0) -  p0).abs();\n}\n\ndouble getDistance(Seg s1, Seg s2){\n    if(intersect(s1, s2)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n        \n        Seg s1 = Seg(Point(xp0, yp0), Point(xp1, yp1));\n        Seg s2 = Seg(Point(xp2, yp2), Point(xp3, yp3));\n\n        if(intersect(s1, s2)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n}\n\n/*\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n\n        printf(\"%.10f\\n\", getDistance(Point(xp0, yp0), Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3)));\n    }\n\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "// 線分の交差判定\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n\nusing namespace std;\n\n// 浮動小数点のゼロ判定\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n// 点を表すクラス\nclass Point\n{\n    public:\n        double x, y;\n        // コンストラクタ\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y){ }\n\n        // -----▼▼▼ 演算子のオーバーロード ▼▼▼-----\n\n        Point operator + (Point &p)\n        {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator - (Point &p)\n        {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator * (double a)\n        {\n            return Point(a * x, a * y);\n        }\n\n        Point operator / (double a)\n        {\n            return Point(x / a, y / a);\n        }\n\n        bool operator < ( const Point &p) const\n        {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator <= ( const Point &p) const\n        {\n            return x != p.x ? x <= p.x : y <= p.y;\n        }\n\n        bool operator == ( const Point &p) const\n        {\n            return fabs(x - p.x) < EPS && fabs(y -p.y) < EPS;\n        }\n\n        // -----▲▲▲ 演算子のオーバーロード ▲▲▲-----\n\n        // 22点間の距離の算出\n        double distance()\n        {\n            return sqrt( norm() );\n        }\n\n        double norm()\n        {\n            return ( x * x ) + ( y * y );\n        }\n};\n\n// 線分を表すクラス\nclass Segment\n{\n    public:\n        Point p1, p2;\n        // コンストラクタ\n        Segment(Point p1, Point p2) : p1(p1), p2(p2){ }\n};\n\n// 点とベクトルの表現は同じ\ntypedef Point Vector;\n// 線分と直線の表現は同じ\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble cross_point(Line line, Point pp);\nVector projection(Vector a, Vector b, Vector p);\ndouble getDistanceLP(Line l, Point p);\nint ccw(Point p0, Point p1, Point p2);\n\nint main(void)\n{\n    int q;\n    Point p0, p1, p2, p3;\n\n    cin >> q;\n\n    for(int i = 0; i < q; i++)\n    {\n        // 各点の格納\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        // 直線の作成\n        Line line_1(p0, p1);\n        Line line_2(p2, p3);\n\n        // 外積の演算結果から交差判定を実施する\n        // -----------------------------------------\n        // 直線と2点の外積を求めて異なる符号の場合,\n        // 直線に対して, 2点は反対側の領域にあることになる\n        // -----------------------------------------\n        if( ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0\n            && ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0 )\n        {\n            // 交差する\n            printf(\"1\\n\");\n        }\n        else\n        {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n// 内積の計算をする関数\ndouble dot(Vector a, Vector b)\n{\n    return ( ( a.x * b.x ) + ( a.y * b.y ) );\n}\n\n// 外積の計算をする関数\ndouble cross(Vector a, Vector b)\n{\n    return ( ( a.x * b.y ) - ( a.y * b.x ) );\n}\n\n// 外積の計算をする関数 2\n// 直線 : line に対する点pの外積の演算\ndouble cross_point(Line line, Point pp)\n{\n    return ( line.p2.x - line.p1.x ) * ( pp.y - line.p1.y ) - ( pp.x - line.p1.x ) * ( line.p2.y - line.p1.y );\n}\n\n// 正射影ベクトルを求める関数\nVector projection(Vector a, Vector b, Vector p)\n{\n    // 正射影ベクトルの考え方より\n    // 正射影ベクトル = ( ( a, bベクトルの内積 ) / aベクトルの大きさの2乗 ) * aベクトル\n    return ( ( a * ( dot(a, b) / pow( a.distance(), 2.0 ) ) ) + p );\n}\n\n// 点と直線の距離を求める関数\ndouble getDistanceLP(Line l, Point p)\n{\n    if( dot( l.p2 - l.p1, p - l.p1 ) < 0.0 )\n    {\n        // 内積の値が負の場合, 2つの線分のなす角が90°以上のため,\n        // 距離は, p と l.p1 の距離そのものになる\n        return ( p - l.p1 ).distance();\n    }\n\n    if( dot( l.p1 - l.p2, p - l.p2 ) < 0.0 )\n    {\n        // 内積の値が負の場合, 2つの線分のなす角が90°以上のため,\n        // 距離は, p と l.p2 の距離そのものになる\n        return ( p - l.p2 ).distance();\n    }\n\n    // 2つの線分のなす角が90°以内の時\n    return abs( cross(l.p2 - l.p1, p - l.p1) / ( l.p2 - l.p1 ).distance() );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// 3点の関係を調査する関数\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if( cross(a, b) > EPS )\n    {\n        // P2が半時計回りの方向にいる\n        return COUNTER_CLOCKWISE;\n    }\n    else if( cross(a, b) < -EPS )\n    {\n        // P2が時計回りの方向にいる\n        return CLOCKWISE;\n    }\n    else if( dot(a, b) < -EPS )\n    {\n        // P2が, 直線：p0p1に対して, 180°反対方向にいる\n        return ONLINE_BACK;\n    }\n    else if( a.norm() < b.norm() )\n    {\n        // p0, p1, p2 の順で点が並んでいる\n        return ONLINE_FRONT;\n    }\n\n    // p0, p2, p1 の順で点が並んでいる\n    return ON_SEGMENT;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Code by ajcxsu\n// Geometry template\n\n#include<bits/stdc++.h>\n#define EPS (1e-9)\nusing namespace std;\n\nstruct Point {\n    double x,y;\n    Point(double x=0,double y=0):x(x), y(y) {}\n\n    Point operator +(Point p) { return Point(x+p.x,y+p.y); }\n    Point operator -(Point p) { return Point(x-p.x,y-p.y); } // 加减\n    Point operator *(double a) { return Point(x*a,y*a); }\n    Point operator /(double a) { return Point(x/a,y/a); } // 数乘\n\n    double norm() { return x*x+y*y; } // 范数\n    double abs() { return sqrt(norm()); } // 大小\n\n    bool operator < (const Point &p) { return x!=p.x?x<p.x:y<p.y; }\n    bool operator == (const Point &p) { return fabs(p.x-x) < EPS && fabs(p.y-y) < EPS; }\n} ;\ntypedef Point Vector;\n\ndouble dot(const Point &a, const Point &b) {\n    return a.x*b.x+a.y*b.y;\n} // 内积\ndouble cross(const Point &a, const Point &b) {\n    return a.x*b.y-a.y*b.x;\n} // 外积\nbool equals(double a, double b) { return fabs(a-b)<EPS; } // 误差相等\n\nstruct Line {\n    Point p1,p2;\n} ;\ntypedef Line Seg;\n\n/* 1 正交 2 平行 0 其他 */\nint PO(Vector a, Vector b) {\n    if(equals(dot(a,b), 0)) return 1;\n    else if(equals(cross(a,b), 0)) return 2;\n    else return 0;\n}\nint PO(Line a, Line b) { // 正交、平行判定\n    return PO(a.p2-a.p1, b.p2-b.p1);\n}\n\nistream& operator >>(istream &in, Vector &a) {\n    in>>a.x>>a.y;\n    return in;\n}\nistream& operator >>(istream &in, Line &a) {\n    in>>a.p1>>a.p2;\n    return in;\n} // 输入重载\n\nPoint project(Point a, Seg b) {\n    Vector base=b.p2-b.p1;\n    Vector hypo=a-b.p1;\n    return b.p1+base*(dot(base, hypo)/ base.norm());\n} // 投影\n\nPoint ref(Point a, Seg b) {\n    Vector base=project(a,b)-a;\n    return a+base*2;\n} // 映像\n\nint ccw(Vector a, Vector b) {\n    if(cross(a,b)>EPS) return 1; // Counter clockwise\n    else if(cross(a,b)<-EPS) return -1; // Clockwise\n    else if(dot(a,b)<-EPS) return 2; // Online back\n    else if(a.norm()<b.norm()) return -2; // Online front\n    else return 0; // On segement\n} // 判断顺时针逆时针\nint ccw(Point p0, Point p1, Point p2) {\n    return ccw(p1-p0, p2-p0);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    if( ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n        ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0) return 1;\n    return 0;\n}\nbool intersect(Seg a, Seg b) {\n    return intersect(a.p1, a.p2, b.p1, b.p2);\n}\n\n\nostream& operator <<(ostream &out, Vector a) {\n    out<<a.x<<' '<<a.y;\n    return out;\n} // 输出重载\n\nint main() {\n    cout.setf(ios::fixed);\n    cout<<setprecision(10); // 设置输出精度\n\n    int q;\n    cin>>q;\n    while(q--) {\n        Seg a,b;\n        cin>>a>>b;\n        cout<<intersect(a,b)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include <cstdio>\n#include<queue>\n#include<map>\n#define WHITE 0\n#define GRAY  1\n#define BLACK 2\n#define endl '\\n'\n#define forup(i,a,n) for( int i =a; i < n; i++)\n#define llforup(i,a,n) for( ll i =a; i < n; i++)\n#define fordown(i,a,n) for( int i =a; i >= n; i--)\n#define fornot(i,a,n) for( int i=a;!n;i++)\n#define mod  (ll)(1e9+7)\n#define putnum(a) printf(\"%d\\n\",a)\nusing namespace std;\ntypedef long long ll;\ninline int readnum()\n{\n\tint p, data = 0; char ch = 0;\n\twhile ((ch != '-') &&( ch < '0' || ch>'9') )//注意运算优先级，逻辑与大于逻辑非\n\t\tch = getchar();//相当于正则表达式的搜索，跳过不需要的字符\n\tif (ch == '-')\n\t\tp = -1, ch = getchar();//不能与if平行放置，不懂为什么，可能是bug\n\telse p = 1;\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + ch - '0', ch = getchar();//搜索需要的字符\n\treturn data * p;\n}\ninline int ReadPossitive()\n{\n\tchar ch; int data = 0;\n\tch = getchar();\n\twhile (ch == ' ' || ch == '\\n')ch = getchar();\n\twhile (ch != ' ' && ch != '\\n' && ch != EOF)\n\t{\n\t\tdata = data * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn data;\n}\n//并查集模板\nclass DisjointSet {\nprivate:\n\tvector<int>rank, parent;\npublic:\n\tDisjointSet(){}\n\tDisjointSet(int size)\n\t{\n\t\trank.resize(size, 0);//默认初始化为0，养成习惯写完整\n\t\tparent.resize(size, 0);\n\t\tforup(i, 0, size)MakeSet(i);\n\t}\n\tvoid MakeSet(int x)\n\t{\n\t\tparent[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn Findroot(x) == Findroot(y);\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tlink(Findroot(x), Findroot(y));\n\t}\n\tinline int Findroot(int x)\n\t{\n\t\twhile (x != parent[x])\n\t\t{\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\tvoid link(int rootx, int rooty)\n\t{\n\t\tif (rank[rootx] < rank[rooty])parent[rootx] = parent[rooty];\n\t\telse\n\t\t{\n\t\t\tparent[rooty] = parent[rootx];\n\t\t\tif (rank[rootx] == rank[rooty])\n\t\t\t\trank[rootx]++;\n\t\t}\n\t}\n};\n\n//计算几何模板\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)//保留整数0\nclass Point {\npublic:\n\tdouble x, y;\npublic:\n\tPoint() {};\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint operator +(Point p) { return Point(x + p.x, y + p.y);}//p不能为引用的问题怎么解决？\n\tPoint operator -(Point p) { return Point(x - p.x, y - p.y);}\n\tPoint operator *(double a) { return Point(a * x, a * y); }\n\tPoint operator /(double a) { return Point(x / a, y / a); }\n\tinline double abs() { return sqrt(norm()); }\n\tinline double norm() { return x * x + y * y; }\n\tbool operator <(const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(const Point& p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nclass Line {\npublic:\n\tPoint p1, p2;\npublic:\n\tLine() {};\n\tLine(int p1x, int p1y, int p2x, int p2y)\n\t{\n\t\tp1.x = p1x; p1.y = p1y;\n\t\tp2.x = p2x; p2.y = p2y;\n\t}\n};\nclass VectorOperation {//操作符不必继承\npublic:\n\tdouble dot(Point a, Point b)//点乘\n\t{\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\tdouble cross(Point a, Point b)//叉乘\n\t{\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tdouble abs(Point s)\n\t{\n\t\treturn sqrt(s.norm());\n\t}\n\tdouble getDistance(Point a, Point b)\n\t{\n\t\treturn abs(a - b);\n\t}\n\tint rotation(Point p0, Point p1, Point p2)\n\t{\n#define COUNTER_CLOCKWISE -1\n#define CLOCKWISE 1\n#define ONLINE_BACK -2\n#define ONLINE_FRONT 2\n#define ON_SEGMENT 0\n\t\tVector a = p1 - p0;Vector b = p2 - p0;\n\t\tdouble Cross = cross(a, b);\n\t\tif (Cross > 0.0)return COUNTER_CLOCKWISE;\n\t\tif (Cross < 0.0)return CLOCKWISE;\n\t\tif (dot(a, b) < 0.0)return ONLINE_BACK;\n\t\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\n\t\treturn ON_SEGMENT;\n#undef COUNTER_CLOCKWISE -1\n#undef CLOCKWISE 1\n#undef ONLINE_BACK -2\n#undef ONLINE_FRONT 2\n#undef ON_SEGMENT 0\n\t}\n};\n\nclass LineOperation :public VectorOperation{\npublic:\t\n\tLineOperation() {};\n\tbool isOrthogonal(Line s1, Line s2)\n\t{\n\t\treturn equals(dot(s1.p2-s1.p1, s2.p2 - s2.p1), 0.0);//操作符重载的返回值的内存分配机制尚不可知，似乎返回值没有分配内存，dot的参数不能用引用，否则报错。\n\t}\n\tbool isParallel(Line s1, Line s2)\n\t{\n\t\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);//外积判断平行，内积判断垂直。\n\t}\n\tbool intersectSS(Line s1, Line s2)\n\t{\n\t\treturn (rotation(s1.p1, s1.p2, s2.p1) * rotation(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\t    rotation(s2.p1, s2.p2, s1.p1) * rotation(s2.p1, s2.p2, s1.p2) <= 0);//即对两条线段都有另一条线段的两个端点必须在当前线段的两侧\n\t}\n\tPoint projection(Line s, Point p)\n\t{\n\t\tVector base = s.p1 - s.p2;\n\t\tdouble r = dot(p - s.p1, base) /base.norm();\n\t\treturn s.p1 + base * r;\n\t}\n\tPoint reflection(Line s, Point p)\n\t{\n\t\treturn p + (projection(s, p)-p) * 2.0;\n\t}\n\tdouble getDistanceLP(Line s, Point p)//点与直线\n\t{\n\t\treturn fabs(cross(s.p2 - s.p1, p - s.p1)) / abs(s.p2 - s.p1);\n\t}\n\tdouble getDistanceSP(Line s, Point p)//点与线段\n\t{\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);//与点p1成钝角\n\t\telse if (dot(s.p2 - s.p1, p - s.p2) > 0.0)return abs(p - s.p2);\n\t\telse return getDistanceLP(s, p);\n\t}\n\tdouble getDistanceSS(Line s1, Line s2)//线段与线段\n\t{\n\n\t}\n};\n//E-mail 374656045@qq.com\n\nclass solve {\nprivate:\n\tint n;\npublic://采用邻接表建图,带权无向图\n\tsolve()\n\t{\n\t\tint x1, y1, x2, y2, x3, y3, x4, y4;\n\t\tn = readnum();\n\t\tLineOperation op;\n\t\tforup(i, 0, n)\n\t\t{\n\t\t\tx1 = readnum(); y1 = readnum();\n\t\t\tx2 = readnum(); y2 = readnum();\n\t\t\tx3 = readnum(); y3 = readnum();\n\t\t\tx4 = readnum(); y4 = readnum();\n\t\t\tLine s1(x1, y1, x2, y2);\n\t\t\tLine s2(x3, y3, x4, y4);\n\t\t\tif (op.intersectSS(s1, s2))putnum(1);\n\t\t\telse putnum(0);\n\t\t}\n\t}\n\t\n};\nint main(void)\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);//慎用，cin和scanf混用会导致非MSC++WA\n#ifdef DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tsolve solution;\n#ifdef DEBUG\n\tfclose(stdin);//关闭文件 \n\tfclose(stdout);//关闭文件 \n#endif\n\treturn 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator + (Point p){return Point(x + p.x, y + p.y);}\n  Point operator - (Point p){return Point(x - p.x, y - p.y);}\n  Point operator * (double a){return Point(x * a, y * a);}\n  Point operator / (double a){return Point(x / a, y / a);}\n\n  double abs(){return sqrt(norm());}\n  double norm(){return x * x + y * y;}\n\n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n};\n\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point p1, Point p2): p1(p1), p2(p2){}\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\nPoint reflect(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return (v21 * t - v01) * 2 + p0;\n}\n\nPoint project(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p0.x - p1.x, p0.y - p1.y);\n  Vector v21 = Vector(p2.x - p1.x, p2.y - p1.y);\n  double t = -1 * ((p2.x - p1.x) * (p1.x - p0.x) + (p2.y - p1.y) * (p1.y - p0.y)) / (pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));\n  return v21 * t + p1;\n}\n\ndouble dis(Point p1, Point p2){\n  return (p1 - p2).abs();\n}\n\ndouble getdis(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < 0) return dis(s.p1, p);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0) return dis(s.p2, p);\n  return dis(project(p, s.p1, s.p2), p);\n}\n\nstring ccw(Point p0, Point p1, Point p2){\n  Vector v01 = Vector(p1.x - p0.x, p1.y - p0.y);\n  Vector v02 = Vector(p2.x - p0.x, p2.y - p0.y);\n  if(equals(cross(v01, v02), 0)){\n    if(dot(v01, v02) < 0) return \"ONLINE_BACK\";\n    else if(equals(v01.abs(), v02.abs()) == true || v01.abs() > v02.abs()) return \"ON_SEGMENT\";\n    else return \"ONLINE_FRONT\";\n  }\n  else if(cross(v01, v02) > 0) return \"COUNTER_CLOCKWISE\";\n  else return \"CLOCKWISE\";\n}\n\n/*void solve(){\n  int q; cin >> q;\n  vector<double> ans(q);\n  for(int i = 0; i < q; i++){\n    double x[4], y[4];\n    Point p[4];\n    for(int j = 0; j < 4; j++){\n      cin >> x[j] >> y[j];\n      p[j] = Point(x[j], y[j]);\n    }\n    Segment s01 = Segment(p[0], p[1]);\n    Segment s23 = Segment(p[2], p[3]);\n    if(intersect(s01, s23)){\n      ans[i] = 0;\n      continue;\n    }\n    ans[i] = 10000000;\n    for(int j = 0; j < 4; j++){\n      if(j < 2) ans[i] = min(getdis(s23, p[j]), ans[i]);\n      else ans[i] = min(getdis(s01, p[j]), ans[i]);\n    }\n  }\n  for(int i = 0; i < q; i++){\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n  return;\n}*/\n\nbool intersect(Segment s1, Segment s2){\n  if(ccw(s1.p1, s1.p2, s2.p2) == \"ON_SEGMENT\" || ccw(s1.p1, s1.p2, s2.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s2.p1, s2.p2, s1.p2) == \"ON_SEGMENT\" || ccw(s2.p1, s2.p2, s1.p1) == \"ON_SEGMENT\") return true;\n  if(ccw(s1.p1, s1.p2, s2.p1) != ccw(s1.p1, s1.p2, s2.p2)){\n    if(ccw(s1.p1, s2.p1, s2.p2) != ccw(s1.p2, s2.p1, s2.p2)) return true;\n  }\n  return false;\n}\n\nvoid solve2(){\n  int q; cin >> q;\n  vector<bool> ans(q);\n  for(int i = 0; i < q; i++){\n    double x[4], y[4];\n    Point p[4];\n    for(int i = 0; i < 4; i++){\n      cin >> x[i] >> y[i];\n      p[i] = Point(x[i], y[i]);\n    }\n    Segment s01 = Segment(p[0], p[1]);\n    Segment s23 = Segment(p[2], p[3]);\n    ans[i] = intersect(s01, s23);\n  }\n  for(int i = 0; i < q; i++){\n    cout << (int)ans[i] << endl;\n  }\n  return;\n}\n\nint main(){\n  solve2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <ostream>\n#include <vector>\n\nconst double kEpsilon = 1e-10;\ninline bool equals(double a, double b)\n{\n    return fabs(a - b) < kEpsilon;\n}\n\nclass Point\n{\n  public:\n    double x, y;\n\n    Point() = default;\n    Point(double x, double y) : x(x), y(y)\n    {\n    }\n\n    Point operator+(const Point &p)\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point &p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)\n    {\n        return Point(x * k, y * k);\n    }\n\n    double SquaredNorm()\n    {\n        return x * x + y * y;\n    }\n    double abs()\n    {\n        return sqrt(this->SquaredNorm());\n    }\n\n    bool operator<(const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator==(const Point &p) const\n    {\n        return fabs(x - p.x) < kEpsilon && fabs(y - p.y) < kEpsilon;\n    }\n\n    double dot(const Point &p) const\n    {\n        return x * p.x + y * p.y;\n    }\n    double cross(const Point &p) const\n    {\n        return x * p.y - y * p.x;\n    }\n};\n\ndouble dot(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.x + p1.y * p2.y;\n}\ndouble cross(const Point &p1, const Point &p2)\n{\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nusing Vector = Point;\n\nstruct Segment\n{\n    Point p1, p2;\n\n    Segment() = default;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2)\n    {\n    }\n};\n\nint ccw(Point &p0, Point &p1, Point &p2)\n{\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n\n    auto cross_z = a.cross(b);\n\n    if (cross_z > 0.0)\n        return 1;\n    else if (cross_z < 0.0)\n        return -1;\n    else\n    {\n        auto dot_prod = a.dot(b);\n        if (dot_prod < 0.0)\n            return 100;\n        else if (b.abs() > a.abs())\n            return -100;\n        else\n        {\n            return 0;\n        }\n    }\n}\n\nbool intersection(Segment &s1, Segment &s2)\n{\n    return ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0.0 &&\n           ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0.0;\n}\n\nint main()\n{\n    Segment s1, s2;\n    int q;\n    std::cin >> q;\n\n    for (size_t i = 0; i < q; ++i)\n    {\n        std::cin >> s1.p1.x >> s1.p1.y;\n        std::cin >> s1.p2.x >> s1.p2.y;\n        std::cin >> s2.p1.x >> s2.p1.y;\n        std::cin >> s2.p2.x >> s2.p2.y;\n\n        if(intersection(s1, s2))\n          std::cout << 1 << std::endl;\n        else {\n          std::cout << 0 << std::endl;\n            }\n        }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 1;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -1;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n#define equals(a,b)(fabs((a)-(b)))<EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) :c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n// ??????s???????§°?????¨?????????p???????§°???\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p2 - s.p1, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\n// ????????????(p0,p1)???????????????p2?????????\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0\n\t\t&& ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\n\n// ?????¢a???????§?r\nVector polar(double a, double r) {\n\treturn Point(cos(r)*a, sin(r)*a);\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// IN:2, ON:1, OUT:0\nint contain(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n// ??????\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3)return s;\n\tsort(s.begin(), s.end());\n\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\n\nint main() {\n\tcout << fixed << setprecision(14);\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tcout << (intersect(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3)) ? 1 : 0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(fabs(naiseki-norm1*norm2)< 0.00000001 && norm1 >= norm2){\t//???p??????1??¨???2???????????????\n\t\treturn 0;\n\t}else if(gaiseki > 0){ //???????¨???¨???\n\t\treturn 1;\n\t}else{\t//????¨???¨???\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tint q;\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n\n\t\tif(func(x1,y1,x2,y2,x3,y3)*func(x1,y1,x2,y2,x4,y4) <= 0 &&\n\t\t\t\tfunc(x3,y3,x4,y4,x1,y1) * func(x3,y3,x4,y4,x2,y2) <= 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2) // P0, P1, P2 counter_clockwise.\n{\n\tdouble d1 = (p1.x - p0.x) * (p2.y - p0.y);\n\tdouble d2 = (p2.x - p0.x) * (p1.y - p0.y);\n\tif(d1 == d2) return 0;\n\treturn (d1 > d2 ? 1 : -1);\n}\n\ndouble inpro(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vx) + (v1.vy * v2.vy);\n}\n\ndouble det2(const Vector &v1, const Vector &v2)\n{\n\treturn (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\nbool crit(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n    if((p0.x > p2.x) && (p0.x > p3.x) && (p1.x > p2.x) && (p1.x > p3.x)) return true;\n    if((p0.x < p2.x) && (p0.x < p3.x) && (p1.x < p2.x) && (p1.x < p3.x)) return true;\n\n    if((p0.y > p2.y) && (p0.y > p3.y) && (p1.y > p2.y) && (p1.y > p3.y)) return true;\n    if((p0.y < p2.y) && (p0.y < p3.y) && (p1.y < p2.y) && (p1.y < p3.y)) return true;\n    return false;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n        Vector V01 = set_v(P0, P1), V23 = set_v(P2, P3);\n        if(ccw(P0, P1, P2) * ccw(P0, P1, P3) > 0 || ccw(P2, P3, P0) * ccw(P2, P3, P1) > 0){\n            printf(\"0\\n\");\n        }else {\n\t\t\tif(det2(V01, V23) == 0 && crit(P0, P1, P2, P3)){ printf(\"0\\n\"); }\n\t\t\telse{ printf(\"1\\n\"); }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nnamespace Random_Number{\n\tunsigned int seed = 19260817;\n\tvoid srnd(unsigned int x){ seed = x; }\n\tunsigned int rnd(){\n\t\treturn seed ^= seed << 19, seed ^= seed >> 7, seed ^= seed << 1;\n\t}\n}\nusing namespace Random_Number;\nnamespace Geometry{\n\tconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = 2, ONLINE_BACK = 3, ONLINE_FRONT = 4, ON_SEGMENT = 5;\n\tconst double eps = 1e-9, pi = 3.14159265358979323846;\n\tbool equal(double a, double b){ return fabs(a - b) < eps; }\n\tstruct point{\n\t\tdouble x, y;\n\t\tpoint(){}\n\t\tpoint(double _x, double _y){ x = _x, y = _y; }\n\t\tpoint operator * (const double &la) const { return point(x * la, y * la); }\n\t\tpoint operator / (const double &la) const { return point(x / la, y / la); }\n\t\tpoint operator + (const point &rhs) const { return point(x + rhs.x, y + rhs.y); }\n\t\tpoint operator - (const point &rhs) const { return point(x - rhs.x, y - rhs.y); }\n\t\tbool operator < (const point &rhs) const { return x < rhs.x || (x == rhs.x && y < rhs.y); }\n\t\tbool operator > (const point &rhs) const { return x > rhs.x || (x == rhs.x && y > rhs.y); }\n\t\tbool operator == (const point &rhs) const { return equal(x, rhs.x) && equal(y, rhs.y); }\n\t\tdouble len2() const { return x * x + y * y; }\n\t\tdouble len() const { return sqrt(len2()); }\n\t\tpoint unit() const { return *this / len(); }\n\t\tpoint unit2() const { return *this / len2(); }\n\t\tfriend double distance(const point &a, const point &b){ return (a - b).len(); }\n\t\tfriend double distance2(const point &a, const point &b){ return (a - b).len2(); }\n\t\tfriend double dot(const point &a, const point &b){ return a.x * b.x + a.y * b.y; }\n\t\tfriend double cross(const point &a, const point &b){ return a.x * b.y - a.y * b.x; }\n\t\tvoid read(){ scanf(\"%lf%lf\", &x, &y); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf\", x, y), putchar(ch); }\n\t\tpoint rotation(double th) const { return point(x * cos(th) - y * sin(th), y * cos(th) + x * sin(th)); }\n\t\tfriend double angle(const point &a, const point &b){ return atan2(cross(a, b), dot(a, b)); }\n\t};\n\tstruct line{\n\t\tpoint a, b;\n\t\tline(){}\n\t\tline(point _a, point _b){ a = _a, b = _b; }\n\t\tvoid read(){ a.read(), b.read(); }\n\t\tvoid print(char ch1 = ' ', char ch2 = '\\n') const { a.print(ch1), b.print(ch2); }\n\t\tpoint projection(const point &p) const { return a + (b - a).unit2() * dot(p - a, b - a); }\n\t\tpoint reflection(const point &p) const { return projection(p) * 2 - p; }\n\t\tint direction(const point &p) const {\n\t\t\tdouble t = cross(b - a, p - a);\n\t\t\tif (t >= eps) return 1;\n\t\t\tif (t <= -eps) return 2;\n\t\t\tdouble l1 = dot(p - a, b - a), l2 = dot(b - a, b - a);\n\t\t\tif (l1 <= -eps) return 3;\n\t\t\tif (l1 > l2) return 4;\n\t\t\treturn 5;\n\t\t}\n\t\tfriend bool parallel(const line &a, const line &b){ return equal(cross(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend bool orthogonal(const line &a, const line &b){ return equal(dot(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend std :: vector<point> line_cross_point(const line &a, const line &b){\n\t\t\t// gugugu\n\t\t\treturn {};\n\t\t}\n\t\tfriend bool segment_intersection(const line &a, const line &b){\n\t\t\tif (std :: min(a.a.x, a.b.x) >= std :: max(b.a.x, b.b.x) + eps) return 0;\n\t\t\tif (std :: min(b.a.x, b.b.x) >= std :: max(a.a.x, a.b.x) + eps) return 0;\n\t\t\tif (std :: min(a.a.y, a.b.y) >= std :: max(b.a.y, b.b.y) + eps) return 0;\n\t\t\tif (std :: min(b.a.y, b.b.y) >= std :: max(a.a.y, a.b.y) + eps) return 0;\n\t\t\tdouble t1, t2;\n\t\t\tt1 = cross(b.a - a.a, a.b - a.a), t2 = cross(b.b - a.a, a.b - a.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\tt1 = cross(a.a - b.a, b.b - b.a), t2 = cross(a.b - b.a, b.b - b.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tfriend double distance_ps(const point &p, const line &l){\n\t\t\tdouble l1 = dot(p - l.a, l.b - l.a), l2 = dot(l.b - l.a, l.b - l.a);\n\t\t\tif (l1 > l2) return distance(p, l.b);\n\t\t\tif (l1 < 0) return distance(p, l.a);\n\t\t\treturn fabs(cross(l.b - l.a, p - l.a)) / distance(l.a, l.b);\n\t\t}\n\t\tfriend double distance_ss(const line &a, const line &b){\n\t\t\tif (segment_intersection(a, b)) return 0;\n\t\t\treturn std :: min(std :: min(distance_ps(a.a, b), distance_ps(a.b, b)), \n\t\t\tstd :: min(distance_ps(b.a, a), distance_ps(b.b, a)));\n\t\t}\n\t};\n\tstruct polygon{\n\t\tstd :: vector<point> g;\n\t\tpolygon(){}\n\t\tpolygon(int n){ g.resize(n); }\n\t\tpolygon(const std :: vector<point> &_g){ g = _g; }\n\t\tvoid clear(){ g.clear(); }\n\t\tvoid resize(int n){ g.resize(n); }\n\t\tint size() const { return g.size(); }\n\t\tvoid push_back(point x){ return g.push_back(x); }\n\t\tvoid pop_back(){ g.pop_back(); }\n\t\tpoint& operator [] (int x){ return g[x]; }\n\t\tconst point& operator [] (int x) const { return g[x]; }\n\t\tdouble directed_area() const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i) s += cross(g[i], g[(i + 1) % n]);\n\t\t\treturn s / 2;\n\t\t}\n\t\tbool is_convex() const {\n\t\t\tint n = g.size();\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\tif (cross(g[(i + 1) % n] - g[i], g[(i - 1 + n) % n] - g[i]) <= -eps) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint polygon_point_containment(const point &a) const {\n\t\t\tdouble k = sqrt(1.0 * rnd() / rnd());\n\t\t\tline l = line(a, point(a.x + 1e9, a.y + 1e9 * k));\n\t\t\tint n = g.size(), s = 0;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (line(g[i], g[i + 1]).direction(a) == 5) return 1;\n\t\t\tif (line(g[n - 1], g[0]).direction(a) == 5) return 1;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (segment_intersection(l, line(g[i], g[i + 1]))) ++s;\n\t\t\tif (segment_intersection(l, line(g[n - 1], g[0]))) ++s;\n\t\t\tif (s & 1) return 2; else return 0;\n\t\t}\n\t\tvoid convex_hull(std :: vector<point> f){\n\t\t\tg.clear();\n\t\t\tint n = f.size();\n\t\t\tstd :: sort(f.begin(), f.end());\n\t\t\tstd :: vector<point> p;\n\t\t\tp.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tstd :: reverse(f.begin(), f.end());\n\t\t\tp.clear(), p.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tf = g, n = f.size(), g.clear();\n\t\t\tint t = 0;\n\t\t\tfor (register int i = 1; i < n; ++i)\n\t\t\t\tif (f[i].y < f[t].y || (f[i].y == f[t].y && f[i].x < f[t].x)) t = i;\n\t\t\tfor (register int i = t; i < n; ++i) g.push_back(f[i]);\n\t\t\tfor (register int i = 0; i < t; ++i) g.push_back(f[i]);\n\t\t}\n\t\tdouble convex_diamater() const {\n\t\t\tint n = g.size();\n\t\t\tdouble ans = 0;\n\t\t\tfor (register int i = 0, j = 0; i < n; ++i){\n\t\t\t\twhile (cross(g[i] - g[j], g[(i + 1) % n] - g[j])\n\t\t\t\t  < cross(g[i] - g[(j + 1) % n], g[(i + 1) % n] - g[(j + 1) % n]) + eps)\n\t\t\t\t\tj = (j + 1) % n;\n\t\t\t\tans = std :: max(ans, distance(g[j], g[i]));\n\t\t\t\tans = std :: max(ans, distance(g[j], g[(i + 1) % n]));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t};\n\tstruct circle{\n\t\tpoint o;\n\t\tdouble r;\n\t\tcircle(){}\n\t\tcircle(point _o, double _r){ o = _o, r = _r; }\n\t\tvoid read(){ o.read(), scanf(\"%lf\", &r); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf %.10lf\", o.x, o.y, r), putchar(ch); }\n\t\tint circle_intersection(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d >= r + c.r + eps) return 4;\n\t\t\tif (equal(d, r + c.r)) return 3;\n\t\t\tif (d >= fabs(r - c.r) + eps) return 2;\n\t\t\tif (equal(d, fabs(r - c.r))) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tstd :: vector<point> directed_line_cross_point(const line &l) const {\n\t\t\tpoint p = line(l.a, l.b).projection(o), v = (l.b - l.a).unit();\n\t\t\tdouble d = distance(p, o);\n\t\t\tif (d >= r + eps) return {};\n\t\t\tdouble t = sqrt(r * r - (p - o).len2());\n\t\t\tif (equal(t, 0)) return {p};\n\t\t\telse return {p - v * t, p + v * t};\n\t\t}\n\t\tstd :: vector<point> circle_cross_point(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d <= fabs(r - c.r) - eps || d >= r + c.r + eps) return {};\n\t\t\tdouble x = (r * r - c.r * c.r + d * d) / (d * 2), h = sqrt(r * r - x * x);\n\t\t\tpoint p = (c.o - o).unit() * x, v = (c.o - o).unit().rotation(pi / 2) * h;\n\t\t\tif (v == point(0, 0)) return {p}; else return {p - v, p + v};\n\t\t}\n\t\tstd :: vector<point> tangent(const point &p) const {\n\t\t\tdouble d = distance(o, p);\n\t\t\tif (d <= r - eps) return {};\n\t\t\tif (equal(d, r)) return {p};\n\t\t\treturn circle_cross_point(circle(p, sqrt(d * d - r * r)));\n\t\t}\n\t\tstd :: vector<point> common_tangent_out(const circle &c) const {\n\t\t\tif (equal(r, c.r)){\n\t\t\t\tpoint p = (c.o - o).unit().rotation(pi / 2) * r;\n\t\t\t\treturn {o - p, o + p};\n\t\t\t}\n\t\t\tpoint p = (o * c.r - c.o * r) / (c.r - r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tstd :: vector<point> common_intangent_in(const circle &c) const {\n\t\t\tpoint p = (o * c.r + c.o * r) / (r + c.r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tdouble directed_triangle_intersection(const point &a, const point &b) const {\n\t\t\tbool ta = a.x * a.x + a.y * a.y < r * r + eps, tb = b.x * b.x + b.y * b.y < r * r + eps;\n\t\t\tstd :: vector<point> t = circle(point(0, 0), r).directed_line_cross_point(line(b, a));\n\t\t\tif (ta == 1 && tb == 1) return cross(a, b) / 2;\n\t\t\tif (ta == 1 && tb == 0) return angle(t.front(), b) * r * r / 2 + cross(a, t.front()) / 2;\n\t\t\tif (ta == 0 && tb == 1) return angle(a, t.back()) * r * r / 2 + cross(t.back(), b) / 2;\n\t\t\tdouble s = angle(a, b) * r * r / 2;\n\t\t\tif (distance_ps(point(0, 0), line(a, b)) > r - eps) return s;\n\t\t\treturn s + angle(t.front(), t.back()) * r * r / 2 - cross(t.front(), t.back()) / 2;\n\t\t}\n\t\tdouble directed_polygon_intersection(const polygon &g) const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\ts += directed_triangle_intersection(g[i] - o, g[(i + 1) % n] - o);\n\t\t\treturn s;\n\t\t}\n\t};\n}\nusing namespace Geometry;\npoint p, t;\nline l, m;\npolygon g;\ncircle c;\nint n, q;\ndouble r;\nvoid CGL_1_A(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.projection(p).print();\n}\nvoid CGL_1_B(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.reflection(p).print();\n}\nvoid CGL_1_C(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--){\n\t\tp.read();\n\t\tint t = l.direction(p);\n\t\tif (t == COUNTER_CLOCKWISE) puts(\"COUNTER_CLOCKWISE\");\n\t\tif (t == CLOCKWISE) puts(\"CLOCKWISE\");\n\t\tif (t == ONLINE_BACK) puts(\"ONLINE_BACK\");\n\t\tif (t == ONLINE_FRONT) puts(\"ONLINE_FRONT\");\n\t\tif (t == ON_SEGMENT) puts(\"ON_SEGMENT\");\n\t}\n}\nvoid CGL_2_A(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (parallel(l, m)) puts(\"2\");\n\t\telse if (orthogonal(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_2_B(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (segment_intersection(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_7_H(){\n\tint n;\n\tdouble r;\n\tscanf(\"%d%lf\", &n, &r);\n\tpolygon g(n);\n\tfor (register int i = 0; i < n; ++i) g[i].read();\n\tprintf(\"%.10lf\\n\", fabs(circle(point(0, 0), r).directed_polygon_intersection(g)));\n}\nint main(){\n\tCGL_2_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @note  関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c (cw)\n *          a -> bで反時計方向に折れてb -> c (ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c (front)\n *          a -> bで逆を向いてb -> cまたは、b == c (on)\n */\nenum struct ffd {  // front face direciton\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t norm2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t norm(const vector_t& v)\n{\n    return std::sqrt(norm2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / norm2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline ffd ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return ffd::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return ffd::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return ffd::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(norm2(p1), norm2(p2)))      { return ffd::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return ffd::on;\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing coord = long double;\nconst long double pi = acos(-1);\nconst long double EPS = 1e-8;\n\nint sign(coord x) { return (x > EPS) - (x < -EPS); }\ncoord sq(coord x) { return x * x; }\n\nstruct point {\n\tcoord x, y;\n\tpoint() : x(0), y(0) {} point(coord _x, coord _y): x(_x), y(_y) {}\n\tinline point operator+(point& p){ return {x + p.x, y + p.y}; }\n\tinline point operator-(point& p){ return {x - p.x, y - p.y}; }\n\tinline point operator*(coord o){ return {x * o, y * o}; }\n\tinline point operator/(coord o){ return {x / o, y / o}; }\n\tinline void operator=(point& p){ x = p.x, y = p.y; }\n\tinline bool operator==(point& p){return sign(x - p.x) == 0 and sign(y - p.y) == 0; }\n\n\tinline coord operator*(point p){ return x * p.x + y * p.y; } // |a||b|cos(thta)\n\tinline coord operator^(point p){ return x * p.y - y * p.x; } // |a||b|sin(thta)\n\n\tinline int ccw(point p){ return sign(*this ^ p); } // ccw  -1 left, 0 over, 1 right\n\n\tinline long double norm(){ return hypot(x, y); }\n\tinline coord norm2(){ return x * x + y * y; }\n\n\tinline point rot90(){return {-y, x}; }\n\tinline point rot(long double ang){ return {cos(ang) * x - sin(ang) * y, sin(ang) * x + cos(ang) * y}; }\n\n\tinline void print(){ cout<<x<<' '<<y<<'\\n'; }\n};\n\nstruct line {\n\tpoint p; coord c; //p *<x,y> = c\n\tline() {} line(point _p, coord _c): p(_p), c(_c) {}\n\tline(point a, point b) : p((b - a).rot90()), c(p * a) {}\n\tinline line parll(point v){ return line(p, p * v); }// parallel line at point v\n\tinline line perp(){ return line(p.rot90(), c); }// perpendicular line\n\n\tbool contains(point v){ return sign(p * v - c) == 0; }\n\tbool intsec(line l){ return sign(p ^ l.p) != 0; } // can be the same line\n\n\tpoint get_intsec(line l){ coord d = p ^ l.p; \n\t\treturn point((c * l.p.y - l.c * p.y) / d, (p.x * l.c - c * l.p.x) / d ); }\n\tcoord dist(point v){ return abs(p * v - c) / p.norm2(); }\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment() {} segment(point _a, point _b): a(_a), b(_b) {}\n\n\tbool contains(point p){return sign((p-a)^(b-a)) == 0 and sign((p-a)*(b-a)) >= 0 and sign((p-b)*(a-b)) >= 0;}\n\t\n\tint ccw(point p){ return((b - a).ccw(p)); } // ccw  -1 left, 0 over, 1 right  of seg a->b\n\n\tbool intsec(segment q){ segment p = *this;\n\t\tif (p.contains(q.a) or p.contains(q.b) or q.contains(p.a) or q.contains(p.b))\n\t\t\treturn true;\n\t\treturn p.ccw(q.a-p.a)*p.ccw(q.b-p.a) == -1 and q.ccw(p.a-q.a)*q.ccw(p.b-q.a) == -1;\t\n\t}\n\n\tcoord dist(segment q){segment p = *this; \n\t\treturn p.intsec(q)? 0 : min({p.dist(q.a), p.dist(q.b), q.dist(p.a), q.dist(p.b)});\t}\n\n\tcoord dist(point p){\n\t\tif (sign(((p - a) * (b - a))) >= 0 and sign((p - b) * (a - b)) >= 0)\n\t\t\treturn abs((p - a) ^ (b - a)) / (b - a).norm();\n\t\treturn min((p - a).norm(), (p - b).norm());\n\t}\n\n\tline getline(){return line(a, b); }\n\n\tsegment getintsec(segment q){segment p = *this;\n\t\tif (((p.b - p.a)^(q.b - q.a)) == 0){\n\t\t\tif (p.contains(q.a) and q.contains(p.b))\n\t\t\t\treturn segment(q.a, p.b);\n\t\t\telse if (p.contains(q.a) and p.contains(q.b))\n\t\t\t\treturn q;\n\t\t\telse if (q.contains(p.a) and p.contains(q.b))\n\t\t\t\treturn segment(p.a, q.b);\n\t\t\treturn p;\n\t\t}\t\n\t\tpoint r = (p.getline()).get_intsec(q.getline());\n\t\treturn segment(r, r);\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\twhile (n--){\n\tint a, b, c, d;\n\tcin>>a>>b>>c>>d;\n\tsegment p = segment(point(a, b), point(c, d));\n\tcin>>a>>b>>c>>d;\n\tsegment q = segment(point(a, b), point(c, d));\n\tcout<<p.intsec(q)<<endl;\n\t}\n\n\tcout<<setprecision(9)<<fixed;\n\n\t// if (p.intsec(q) == 0)\n\t// \tcout<<\"Empty\"<<endl;\n\t// else{\n\t// \tsegment w = p.getintsec(q);\n\t// \t(w.a).print();\n\t// \tif (!(w.a == w.b))\n\t// \t\t(w.b).print();\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n\nstatic const double EPS = 1e-10;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n};\n\nstruct Segment\n{\n\tPoint p1, p2;\n};\n\ntypedef Point Vector;\n\ndouble\nnorm(Vector a)\n{\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble\ndot(Vector a, Vector b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n\ndouble\ncross(Vector a, Vector b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint\nccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\n\tif (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\n\tif (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\n\tif (norm(a) < norm(b))\n\t\treturn ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool\nintersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t        ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint\nmain(int argc, char** argv)\n{\n\tPoint p0, p1, p2, p3;\n\tint xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\tint q;\n\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d %d %d\", &xp0, &yp0, &xp1, &yp1, &xp2, &yp2, &xp3, &yp3);\n\t\tp0.x = xp0, p0.y = yp0;\n\t\tp1.x = xp1, p1.y = yp1;\n\t\tp2.x = xp2, p2.y = yp2;\n\t\tp3.x = xp3, p3.y = yp3;\n\t\tif (intersect(p0, p1, p2, p3))\n\t\t\tprintf(\"1\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(p1==p3 || p1==p4 || p2==p3 || p2==p4){\n      cout<<\"1\"<<endl;\n      continue;\n    }\n\n    // cout<<\"p1=\"<<p1<<\",s2=\"<<s2<<endl;\n    // cout<<\"p1.real()/s2.real()=\"<<p1.real()/s2.real()<<endl;\n\n    // printf(\"s1.real%f,s1.imag%f\\ns2.real%f,s2.imag%f\\n\",s1.real(),s1.imag(),s2.real(),s2.imag());\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){//parallel\n      if(s1.real()==0 && s2.real()==0){//tate\n\tif( ( min(p3.imag(),p4.imag()) <= p2.imag() &&\n\t      p2.imag() <= max(p3.imag(),p4.imag()) )  ||\n\t    ( min(p3.imag(),p4.imag()) <= p1.imag() && \n\t      p1.imag() <= max(p3.imag(),p4.imag()) ) )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else if(s1.imag()==0 && s2.imag()==0){//yoko\n\tif( ( min(p3.real(),p4.real()) <= p2.real() &&\n\t      p2.real() <= max(p3.real(),p4.real()) )  ||\n\t    ( min(p3.real(),p4.real()) <= p2.real() &&\n\t      p2.real() <= max(p3.real(),p4.real()) )  )\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n      }else \n\tcout<<\"0\"<<endl;\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nnamespace asl\n{\n    \n    template <typename numeric_type>\n    class point\n    {\n    public:\n        numeric_type x, y;\n\n        point(numeric_type x = 0, numeric_type y = 0) : x(x), y(y) {}\n\n        point<numeric_type> &operator-=(const point<numeric_type> &ri)\n        {\n            x -= ri.x;\n            y -= ri.y;\n            return *this;\n        }\n\n    };\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, point<numeric_type> &p)\n    {\n        return is >> p.x >> p.y;\n    }\n\n    template <typename numeric_type>\n    class line\n    {\n    public:\n        point<numeric_type> p, q;\n\n    };\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, line<numeric_type> &l)\n    {\n        return is >> l.p >> l.q;\n    }\n\n    template <typename numeric_type>\n    using segment = line<numeric_type>;\n\n    template <typename numeric_type>\n    numeric_type cross(point<numeric_type> a, point<numeric_type> b)\n    {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    template <typename numeric_type>\n    numeric_type dot(point<numeric_type> a, point<numeric_type> b)\n    {\n        return a.x * b.x + a.y * b.y;\n    }\n\n    enum PointOrder\n    {\n        CounterClockwise = +1,\n        Clockwise = -1,\n        AlignedFirst = +2,\n        AlignedLast = -2,\n        AlignedIn = 0,\n    };\n\n    template <typename numeric_type>\n    PointOrder ccw(point<numeric_type> a, point<numeric_type> b, point<numeric_type> c)\n    {\n        b -= a;\n        c -= a;\n        if (cross(b, c) > 0)\n            return PointOrder::CounterClockwise;\n        else if (cross(b, c) < 0)\n            return PointOrder::Clockwise;\n        else if (dot(b, c) < 0)\n            return PointOrder::AlignedFirst; \n        else if (dot(b, b) < dot(c, c))\n            return PointOrder::AlignedLast; \n        else\n            return PointOrder::AlignedIn; \n    }\n\n} \n\n#include <stdint.h>\n\n#include <experimental/optional>\n\nnamespace asl\n{\n    \n    template <typename numeric_type>\n    bool intersect_segment_segment(const segment<numeric_type> &s, const segment<numeric_type> &t)\n    {\n        return ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0 && ccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n    }\n\n} \n \n#include <random>\n\n#define endl '\\n'\n\nusing namespace asl;\nusing namespace std;\n\nvoid solve()\n{\n    segment<int> a, b;\n    cin >> a >> b;\n\n    cout << intersect_segment_segment(a, b) << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n\n    for (int i = 0; i < t; ++i)\n    {\n        solve();\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\n#define dTolerance 1.0e-10\n\n    //(x,y)が(x0,y0),(x1,y1)を通る直線のどちら側にあるか  1:左 -1:右 0:直線上\nint LF_COUNTER_CLOCKWIZE(const double &x, const double &y, const double &x0, const double &y0, const double &x1, const double &y1){\n    if((x1 - x0) * (y - y0) - (x - x0) * (y1 - y0) > dTolerance){\n        return 1;\n    } else if((x1 - x0) * (y - y0) - (x - x0) * (y1 - y0) < -dTolerance){\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\ndouble max(const double &a, const double &b){\n    if(a >= b){\n        return a;\n    } else {\n        return b;\n    }\n}\n\ndouble min(const double &a, const double &b){\n    if(a <= b){\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++){\n        double x0,x1,x2,x3,y0,y1,y2,y3;\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        if(LF_COUNTER_CLOCKWIZE(x0, y0, x2, y2, x3, y3) == 0 && LF_COUNTER_CLOCKWIZE(x1, y1, x2, y2, x3, y3) == 0 ){    //2線分が延長して一致する場合だけ面倒\n            if(fabs(x0 - x1) < dTolerance){    //y軸平行  y座標比較\n                if(max(y0, y1) < min(y2, y3) || max(y2, y3) < min(y0, y1)){    //交わらない\n                    printf(\"0\\n\");\n                } else {    //交わる\n                    printf(\"1\\n\");\n                }\n            } else {    //x座標比較\n                if(max(x0, x1) < min(x2, x3) || max(x2, x3) < min(x0, x1)){    //交わらない\n                    printf(\"0\\n\");\n                } else {    //交わる\n                    printf(\"1\\n\");\n                }\n            }\n        } else {\n            bool bIntersect = true;\n            if(LF_COUNTER_CLOCKWIZE(x0, y0, x2, y2, x3, y3) * LF_COUNTER_CLOCKWIZE(x1, y1, x2, y2, x3, y3) == 1 ) {    //同じ側にあったら交わらない\n                bIntersect = false;\n            }\n            if(LF_COUNTER_CLOCKWIZE(x2, y2, x0, y0, x1, y1) * LF_COUNTER_CLOCKWIZE(x3, y3, x0, y0, x1, y1) == 1 ) {    //同じ側にあったら交わらない\n                bIntersect = false;\n            }\n            if(bIntersect == true){\n                printf(\"1\\n\");                \n            } else {\n                printf(\"0\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// CGL_2_B\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nstruct vec{\n\tint x;\n\tint y;\n};\n\ndouble norm(struct vec a){\n\treturn sqrt(pow((double)a.x, 2) + pow((double)a.y, 2));\n}\n\ndouble inner_p(struct vec a, struct vec b){\n\treturn (a.x*b.x + a.y*b.y);\n}\n\ndouble cross_p(struct vec a, struct vec b){\n\treturn (a.x*b.y - a.y*b.x);\n}\n\nint clock(vec p1, vec p2, vec p3){\n\tvec a, b;\n\ta.x = p2.x - p1.x;\n\ta.y = p2.y - p1.y;\n\tb.x = p3.x - p1.x;\n\tb.y = p3.y - p1.y;\n\n\tif(fabs(cross_p(a, b)) == 0)\n\t\tif(inner_p(a, b) < 0)\n\t\t\treturn 1;\n\t\telse if(norm(a) < norm(b))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\telse if(cross_p(a, b) > 0)\n\t\treturn 2;\n\telse\n\t\treturn -2;\n}\n\nint intersect(vec p1, vec p2, vec p3, vec p4){\n\tif((clock(p1, p2, p3)*clock(p1, p2, p4) <= 0) && (clock(p3, p4, p1)*clock(p3, p4, p2) <= 0))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n\n\n}\n\nint main(){\n\tvec p[4];\n\tint q;\n\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>p[0].x>>p[0].y>>p[1].x>>p[1].y>>p[2].x>>p[2].y>>p[3].x>>p[3].y;\n\n\t\tcout<<intersect(p[0], p[1], p[2], p[3])<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mm(a,b) memset(a,b,sizeof(a))\n#define ACCELERATE (ios::sync_with_stdio(false),cin.tie(0))\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define pll pair<long long,long long>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define rush() int T;scanf(\"%d\",&T);while(T--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define pf(x) printf(\"%d\\n\",x)\n#define pf2(x,y) printf(\"%d %d\\n\",x,y)\n#define pf3(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\n#define E exp(1.0)\n#define db double\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n//#define io\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n//#define gc getchar\n//char buf[1<<21],*p1=buf,*p2=buf;\n//inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\n//inline int read()\n//{\n//    int ret=0,f=0;char c=gc();\n//    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n//    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n//    if(f)return -ret;return ret;\n//}\nconst db EPS=1e-10;\ninline int sign(db a){return a<-EPS?-1:a>EPS;}\ninline int cmp(db a,db b){return sign(a-b);}\ninline db sqr(db x){return x*x;}\nstruct Point{\n    db x,y;\n    Point(){}\n    Point(db _x,db _y):x(_x),y(_y){}\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n    void output(){printf(\"%.10f %.10f\\n\",x,y);}\n    bool operator == (Point b)const{\n        return sign(x-b.x)==0&&sign(y-b.y)==0;\n    }\n    bool operator < (Point b)const{\n        return sign(x-b.x)==0?sign(y-b.y)<0:x<b.x;\n    }\n    Point operator + (const Point &b)const{\n        return Point(x+b.x,y+b.y);\n    }\n    Point operator - (const Point &b)const{\n        return Point(x-b.x,y-b.y);\n    }\n    db operator ^ (const Point &b)const{\n        return x*b.y-y*b.x;\n    }\n    db operator * (const Point &b)const{\n        return x*b.x+y*b.y;\n    }\n    db len(){return hypot(x,y);}\n    db len2(){return x*x+y*y;}\n    db distance(Point p){return hypot(x-p.x,y-p.y);}\n    Point operator * (const db &k)const{\n        return Point(x*k,y*k);\n    }\n    Point operator / (const db &k)const{\n        return Point(x/k,y/k);\n    }\n    db rad(Point a,Point b){\n        Point p=*this;\n        return fabs(atan2(fabs((a-p)^(b-p)),(a-p)*(b-p)));\n    }\n    Point unit(){return *this/len();}\n    Point trunc(db r){\n        db l=len();\n        if(!sign(l))return *this;\n        r/=l;\n        return Point(x*r,y*r);\n    }\n    Point rotleft(){return Point(-y,x);}\n    Point rotright(){return Point(y,-x);}\n    Point rotate(Point p,db angle){\n        Point v=(*this)-p;\n        db c=cos(angle),s=sin(angle);\n        return Point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n};\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\nstruct Line{\n    Point s,e;\n    Line(){}\n    Line(Point _s,Point _e):s(_s),e(_e){}\n    bool operator == (Line v){\n        return (s==v.s)&&(e==v.e);\n    }\n    Line(Point p,db angle){\n        s=p;\n        if(sign(angle-PI/2)==0)e=(s+Point(0,1));\n        else e=(s+Point(1,tan(angle)));\n    }\n    Line(db a,db b,db c){\n        if(sign(a)==0){\n            s=Point(0,-c/b);e=Point(1,-c/b);\n        }else if(sign(b)==0){\n            s=Point(-c/a,0);e=Point(-c/a,1);\n        }else{\n            s=Point(0,-c/b);e=Point(1,(-c-a)/b);\n        }\n    }\n    void input(){s.input();e.input();}\n    void adjust(){if(e<s)swap(s,e);}\n    db length(){return s.distance(e);}\n    //[0,PI)\n    db angle(){\n        db k=atan2(e.y-s.y,e.x-s.x);\n        if(sign(k)<0)k+=PI;\n        if(sign(k-PI)==0)k-=PI;\n        return k;\n    }\n    //line|1 on the left|2 on the right|3 on line|\n    int relation(Point p){\n        int c=sign((p-s)^(e-s));\n        if(c<0)return 1;\n        else if(c>0)return 2;\n        else return 3;\n    }\n    bool pointonseg(Point p){\n        return sign((p-s)^(e-s))==0&&sign((p-s)*(p-e))<=0;\n    }\n    bool parallel(Line v){\n        return sign((e-s)^(v.e-v.s))==0;\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int segcrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        int d3=sign((v.e-v.s)^(s-v.s));\n        int d4=sign((v.e-v.s)^(e-v.s));\n        if((d1^d2)==-2&&(d3^d4)==-2)return 2;\n        return (d1==0&&sign((v.s-s)*(v.s-e))<=0)||\n            (d2==0&&sign((v.e-s)*(v.e-e))<=0)||\n            (d3==0&&sign((s-v.s)*(s-v.e))<=0)||\n            (d4==0&&sign((e-v.s)*(e-v.e))<=0);\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int linecrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        if((d1^d2)==-2)return 2;\n        return (d1==0||d2==0);\n    }\n    //|0 parallel|1 coincides|2 intersect|\n    int linecrossline(Line v){\n        if((*this).parallel(v))return v.relation(s)==3;\n        return 2;\n    }\n    //要保证两直线不平行或重合\n    Point crossPoint(Line v){\n        db a1=(v.e-v.s)^(s-v.s);\n        db a2=(v.e-v.s)^(e-v.s);\n        return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));\n    }\n    db dispointtoline(Point p){\n        return fabs((p-s)^(e-s))/length();\n    }\n    db dispointtoseg(Point p){\n        if(sign((p-s)*(e-s))<0||sign((p-e)*(s-e))<0)return min(p.distance(s),p.distance(e));\n        return dispointtoline(p);\n    }\n    //前提是两线段不相交，相交距离就是0了\n    db dissegtoseg(Line v){\n        return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e)));\n    }\n    Point lineprog(Point p){\n\t\treturn s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );\n\t}\n\tPoint symmetrypoint(Point p){\n\t\tPoint q = lineprog(p);\n\t\treturn Point(2*q.x-p.x,2*q.y-p.y);\n\t}\n};\nLine l1,l2;\nint main()\n{\n    #ifdef io\n    freopen(\"in.txt\",\"r\",stdin);\n    #endif\n    int q;\n    sc(q);\n    while(q--){\n        l1.input();l2.input();\n        int t=l1.segcrossseg(l2);\n        if(!t)puts(\"0\");\n        else puts(\"1\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <complex>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n//二つのスカラーが等しいか\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n\n//二つのベクトルが等しいか\n#define EQV(a, b) (EQ((a), real(), (b).real()) && EQ((a), imag(), (b).imag()))\n\nnamespace std\n{\nbool operator<(P &a, P &b)\n{\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n} // namespace std\n\ndouble dot(P a, P b)\n{\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(P a, P b)\n{\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\nint is_orthogonal(P a1, P a2, P b1, P b2)\n{\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\nint is_parallel(P a1, P a2, P b1, P b2)\n{\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\nint ccw(P a, P b, P c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > 0)\n        return 1;\n    if (cross(b, c) < 0)\n        return -1;\n    if (dot(b, c) < 0) // c--a--b on line\n        return 2;\n    if (norm(b) < norm(c)) //a--b--c on line or a==b\n        return -2;\n    return 0; // a--c--b on line a==c or b==c\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2)\n{\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\nint main(void)\n{\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i)\n    {\n        double a, b, c, d, e, f, g, h;\n        cin >> a >> b >> c >> d >> e >> f >> g >> h;\n\n        P p0(a, b);\n        P p1(c, d);\n        P p2(e, f);\n        P p3(g, h);\n\n        if (is_intersected_ls(p0, p1, p2, p3))\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<eps;\n}\n\nint Q;\nint X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n\n\nusing namespace std;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS) //?????????????????????????????????\n\n//??????p0,p1,p2????????????\n#define COUNTER_CLOCKWISE 1 //???????????§???????¨????????????´???\n#define CLOCKWISE  -1 //???????????§????¨????????????´???\n#define ONLINE_BACK 2 //p2,p0,p1??????????????§????????´?????????????????¨???\n#define ONLINE_FRONT -2//???????????§????????´?????????????????¨???\n#define ON_SEGMENT 0 //p2?????????p0 p1??????????????¨???\n\n\n//??????????????????????????????\nclass Point {\n\npublic:\n\n\tdouble x, y;//??§?¨????????????????x,y??????\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\n\tPoint operator * (double r) {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tPoint operator / (double r) {\n\t\treturn Point(x / r, y / r);\n\t}\n\n\tdouble norm() {\n\t\treturn x*x + y*y;\n\t}\n\n\t//?????????????????§???????????????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS &&  fabs(y - p.y) < EPS;\n\t}\n\n};\n\ntypedef Point Vector;\n\n//??????????????????????????????\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//??????????????????????????????\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment() {}\n\n\t//?????¨????°???±?????????\n\tPoint projection(Point p) {\n\t\tVector base = p2 - p1;\n\n\t\tdouble r = dot(p - p1, base) / base.norm();\n\t\treturn p1 + base * r;\n\t}\n\n\t//????°??????????\n\tPoint reflection(Point p) {\n\t\treturn p + (projection(p) - p)*2.0;\n\t}\n\n\n};\n\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\n\n//?????????????????´?????????\nbool isOrthogonal(Vector a, Vector b);\n\n//??????????§??????¨?????????????????´?????????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\n\n//???????????´?????????\nbool isOrthogonal(Segment s1, Segment s2);\n\n//???????????????????????????\nbool isParallel(Vector a, Vector b);\n\n//??????????§??????¨???????????????????????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\n\n//?????????????????????\nbool isParallel(Segment s1, Segment s2);\n\n//?°???±?????????\nPoint projection(Segment s, Point p);\n\n//????°??????????\nPoint reflection(Segment s, Point p);\n\n//2??????????????¢?????????\ndouble getDistance(Point a, Point b);\n\n//??´?????¨???????????¢?????????\ndouble getDistanceLP(Line l, Point p);\n\n//????????¨???????????¢?????????\ndouble getDistanceSP(Segment s, Point p);\n\n//??????s1??¨??????s2????????¢?????????\ndouble getDistance(Segment s1, Segment s2);\n\n\n//???????????¢????????????\nint ccw(Point p0, Point p1, Point p2);\n\n//??????p1p2??¨??????p2p3???????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4);\n\n//??????s1??¨??????s2???????????????\nbool intersect(Segment s1, Segment s2);\n\n\n\n//?????????????????´?????????\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\n//??????????§??????¨?????????????????´?????????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\n//???????????´?????????\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//???????????????????????????\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\n//??????????§??????¨???????????????????????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\n//?????????????????????\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//?°???±?????????\nPoint projection(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n//????°??????????\nPoint reflection(Segment s, Point p) {\n\treturn p + (projection(s, p) - p)*2.0;\n}\n\n//2??????????????¢?????????\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\n//??´?????¨???????????¢?????????\ndouble getDistanceLP(Line l, Point p) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\n//????????¨???????????¢?????????\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\treturn (p - s.p1).abs();\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) {\n\t\treturn (p - s.p2).abs();\n\t}\n\n\treturn getDistanceLP(s, p);\n}\n\n//??????s1??¨??????s2????????¢?????????\ndouble getDistance(Segment s1, Segment s2) {\n\n\tif (intersect(s1, s2)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n\n//???????????¢????????????\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > EPS) {//???????¨?????????????\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\tif (cross(a, b) < -EPS) {//????¨?????????????\n\t\treturn CLOCKWISE;\n\t}\n\tif (dot(a, b) < -EPS) {//p2,p0,p1??????????????§????????´?????????????????????\n\t\treturn ONLINE_BACK;\n\t}\n\tif (a.norm() < b.norm()) {//p0,p1,p2??????????????§????????´?????????????????????\n\t\treturn ONLINE_FRONT;\n\t}\n\n\treturn ON_SEGMENT;//??????p0 p1??????p2???????????????\n\n}\n\n//??????p1p2??¨??????p2p3???????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\n//??????s1??¨??????s2???????????????\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\n\n\n\n\n\n//???\nclass Circle {\npublic:\n\tPoint c;//??????\n\tdouble r;//??????\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n\nint main(void)\n{\n\tint n;\n\n\tSegment s1, s2;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y;\n\t\tcin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\n\t\tcout << ((intersect(s1, s2)) ? 1 : 0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(){}\n\tPoint(const Point &P){\n\t\tx=P.x;\n\t\ty=P.y;\n\t}\n\tPoint(double a, double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tPoint operator*(const double coe)const\n\t{\n\t\tPoint P;\n\t\tP.x=x*coe;\n\t\tP.y=y*coe;\n\t\treturn P;\n\t}\n\tPoint operator-(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x-P.x;\n\t\tresult.y=y-P.y;\n\t\treturn result;\n\t}\n\tPoint operator+(const Point P)const\n\t{\n\t\tPoint result;\n\t\tresult.x=x+P.x;\n\t\tresult.y=y+P.y;\n\t\treturn result;\n\t}\n};\n\nclass Line\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tLine(){}\n\tLine(Point a, Point b){\n\t\tp1=a;\n\t\tp2=b;\n\t}\n\tLine(const Line &L){\n\t\tp1=L.p1;\n\t\tp2=L.p2;\n\t}\n\tdouble cross(const Line &L)const{\n\t\treturn (p2.x-p1.x)*(L.p2.y-L.p1.y)-(p2.y-p1.y)*(L.p2.x-L.p1.x);\n\t}\n\tPoint intersection(const Line &L)const{//line intersection point\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            result.x=-999999;\n            result.y=-999999;\n            return result;\n\t\t}\n\t\tresult=p1+(p2-p1)*(Line(L.p1, p1).cross(L)/L.cross(*this));\n\t\treturn result;\n\t}\n\tbool point_on_segment(const Point &P)const{//point on line, but on segment?\n\t\tif((P.x-p1.x)*(P.x-p2.x)<=0&&(P.y-p1.y)*(P.y-p2.y)<=0) return 1;\n\t\treturn 0;\n\t}\n\tbool valid_intersection(const Line &L)const{//segment intersect?\n\t\tPoint result;\n\t\tif(cross(L)==0){\n            Line L2(p2, L.p1);\n            if(cross(L2)==0&&(point_on_segment(L.p1)||point_on_segment(L.p2)||L.point_on_segment(p1)||L.point_on_segment(p2))) return 1;\n            return 0;\n\t\t}\n\t\tresult=intersection(L);\n\t\tif(point_on_segment(result)&&L.point_on_segment(result)) return 1;\n\t\treturn 0;\n\t}\n\tLine perpendicular_bisector()const{//a perpendicular bisector line\n\t    Point P1((p1.x+p2.x)/2, (p1.y+p2.y)/2);\n\t    Point v(p2.y-p1.y, p1.x-p2.x);\n\t    Point P2=P1+v;\n\t    Line result(P1, P2);\n\t    return result;\n\t}\n};\n\nclass Polygon\n{\npublic:\n\tvector<Point> v;\n\tPolygon(){\n\t\tv.clear();\n\t}\n\tdouble area(){//area\n\t\tdouble a=0;\n\t\tfor(int i=1;i<v.size()-1;i++){\n\t\t\tLine L1(v[0], v[i]);\n\t\t\tLine L2(v[0], v[i+1]);\n\t\t\ta+=L1.cross(L2);\n\t\t}\n\t\tif(a<0) return (-a)/2;\n\t\telse return a/2;\n\t}\n\tPolygon HPits(Line &L){//half plane intersection //only keep the counterclockwise side's polygon\n\t\tPolygon q;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tLine L1(L.p1, v[i]);\n\t\t\tif(L.cross(L1)>=0) q.v.push_back(v[i]);\n\t\t\tLine L2(L.p1, v[(i+1)%v.size()]);\n\t\t\tif(L.cross(L1)*L.cross(L2)<0) q.v.push_back(L.intersection(Line(v[i], v[(i+1)%v.size()])));\n\t\t}\n\t\treturn q;\n\t}\n};\n\nclass Triangle\n{\npublic:\n    Point a;\n    Point b;\n    Point c;\n    Triangle(){}\n    Triangle(Point A, Point B, Point C){\n        a=A; b=B; c=C;\n    }\n    Point center(){//tircumcenter\n        Line L1(a, b);\n        Line L2(b, c);\n        Line N1=L1.perpendicular_bisector();\n        Line N2=L2.perpendicular_bisector();\n        return N1.intersection(N2);\n    }\n    double area(){\n        Line L1(a, b);\n        Line L2(a, c);\n        double ans=L1.cross(L2);\n        if(ans<0) ans=-ans;\n        return ans/2;\n    }\n    bool point_in_triangle(const Point &P)const{\n        Line L1(P, a);\n        Line L2(P, b);\n        Line L3(P, c);\n        if(L1.cross(L2)<=0&&L2.cross(L3)<=0&&L3.cross(L1)<=0) return 1;\n        if(L1.cross(L2)>=0&&L2.cross(L3)>=0&&L3.cross(L1)>=0) return 1;\n        return 0;\n    }\n};\n\nint main()\n{\n    int n;\n    double x, y;\n    scanf(\"%d\", &n);\n    while(n--){\n        scanf(\"%lf %lf\", &x, &y);\n        Point P1(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P2(x, y);\n        Line L1(P1, P2);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P3(x, y);\n        scanf(\"%lf %lf\", &x, &y);\n        Point P4(x, y);\n        Line L2(P3, P4);\n        printf(\"%d\\n\", L1.valid_intersection(L2));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define join_(a,b) join_again_(a,b)\n#define join_again_(a,b) a ## b\n#define rep(i,n) for(int i = 0, join_(lim, __LINE__) = n; i < join_(lim, __LINE__); ++i)\nusing C = std::complex<double>;\nconst double EPS = 1e-10;\n\n// CGL_1_A\nC projection(C p, C p1, C p2) {\n    return C(((p-p1) / (p2-p1)).real(), 0.0) * (p2-p1) + p1;\n}\n\nvoid solve_CGL_1_A() {\n    int x1, y1, x2, y2;\n    std::cin >> x1 >> y1 >> x2 >> y2;\n    C p1(x1,y1), p2(x2,y2);\n    int q;\n    std::cin >> q;\n    rep(i,q) {\n        int x, y;\n        std::cin >> x >> y;\n        C p = C(x,y);\n        C res = projection(p, p1, p2);\n        printf(\"%.20lf %.20lf\\n\", res.real(), res.imag());\n    }\n}\n\n// CGL_1_B\nC reflection(C p, C p1, C p2) {\n    return std::conj(((p-p1) / (p2-p1))) * (p2-p1) + p1;\n}\n\nvoid solve_CGL_1_B() {\n    int x1, y1, x2, y2;\n    std::cin >> x1 >> y1 >> x2 >> y2;\n    C p1(x1,y1), p2(x2,y2);\n    int q;\n    std::cin >> q;\n    rep(i,q) {\n        int x, y;\n        std::cin >> x >> y;\n        C p = C(x,y);\n        C res = reflection(p, p1, p2);\n        printf(\"%.20lf %.20lf\\n\", res.real(), res.imag());\n    }\n}\n\n// CGL_1_C\n// p0->p1 and p0->p2, query is p2\nint counter_clockwise(C p0, C p1, C p2) {\n    C a = std::conj(p1-p0) * (p2-p0);\n    if (a.imag() >  EPS) { return +1; } // counter clockwise\n    if (a.imag() < -EPS) { return -1; } // clockwise\n    if (a.real() < -EPS) { return +2; } // p2-p0-p1\n    if (std::norm(p1-p0) < std::norm(p2-p0)) { return -2; } // p0-p1-p2\n    return 0; // p0-p2-p1\n}\nauto ccw = counter_clockwise;\n\nvoid solve_CGL_1_C() {\n    int x1, y1, x2, y2;\n    std::cin >> x1 >> y1 >> x2 >> y2;\n    C p0(x1,y1), p1(x2,y2);\n    int q;\n    std::cin >> q;\n    rep(i,q) {\n        int x, y;\n        std::cin >> x >> y;\n        C p2 = C(x,y);\n        int res = counter_clockwise(p0, p1, p2);\n        if (res == 1) {\n            printf(\"COUNTER_CLOCKWISE\\n\");\n        }\n        if (res == -1) {\n            printf(\"CLOCKWISE\\n\");\n        }\n        if (res == 2) {\n            printf(\"ONLINE_BACK\\n\");\n        }\n        if (res == -2) {\n            printf(\"ONLINE_FRONT\\n\");\n        }\n        if (res == 0) {\n            printf(\"ON_SEGMENT\\n\");\n        }\n    }\n}\n\n// CGL_2_A\nint parallel_orthogonal(C p0, C p1, C p2, C p3) {\n    C a = (p3-p2) / (p1-p0);\n    if (std::abs(a.real()) < EPS) { return 1; } // orthogonal\n    if (std::abs(a.imag()) < EPS) { return 2; } // parallel\n    return 0;\n}\n\nvoid solve_CGL_2_A() {\n    int q;\n    std::cin >> q;\n    rep(i,q) {\n        int xs[8];\n        rep(k,8) {\n            std::cin >> xs[k];\n        }\n        C p0 = C(xs[0], xs[1]);\n        C p1 = C(xs[2], xs[3]);\n        C p2 = C(xs[4], xs[5]);\n        C p3 = C(xs[6], xs[7]);\n        int res = parallel_orthogonal(p0, p1, p2, p3);\n        printf(\"%d\\n\", res);\n    }\n}\n\n// CGL_2_B\nbool intersection(C p0, C p1, C p2, C p3) {\n    return\n        ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 &&\n        ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0;\n}\n\nvoid solve_CGL_2_B() {\n    int q;\n    std::cin >> q;\n    rep(i,q) {\n        int xs[8];\n        rep(k,8) {\n            std::cin >> xs[k];\n        }\n        C p0 = C(xs[0], xs[1]);\n        C p1 = C(xs[2], xs[3]);\n        C p2 = C(xs[4], xs[5]);\n        C p3 = C(xs[6], xs[7]);\n        bool res = intersection(p0, p1, p2, p3);\n        printf(\"%d\\n\", res ? 1 : 0);\n    }\n}\n\nint main() {\n    solve_CGL_2_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(fabs(naiseki/(norm1*norm2)+1) < 0.00000001){ //cos?? == -1\n\t\treturn 1;\n\t}else if(fabs(naiseki-norm1*norm2)< 0.00000001){ //cos?? == 0\n\t\tif(norm1 >= norm2){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}else if(gaiseki > 0){ //???????????£????????????????¨???????????§???????180??\\???\n\t\treturn -1;\n\t}else{\n\t\treturn 1;\n\t}\n}\n\n\nint main(){\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tint q;\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n\n\t\tif(func(x1,y1,x2,y2,x3,y3)*func(x1,y1,x2,y2,x4,y4) <= 0 &&\n\t\t\t\tfunc(x3,y3,x4,y4,x1,y1) * func(x3,y3,x4,y4,x2,y2) <= 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum POSITION{ONLINE_BACK = -2, CLOCKWISE = -1, ON_SEGMENT = 0,\n              COUNTER_CLOCKWISE = 1, ONLINE_FRONT = 2};\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\ndouble get_dot(Vector v1, Vector v2){\n    return v1.x * v2.x + v1.y * v2.y;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nPOSITION get_position(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return CLOCKWISE;\n    if (cross < -1e-10) return COUNTER_CLOCKWISE;\n    // if (get_dot(base, obj) < 0) return ONLINE_BACK;\n    // if (get_dot(base, base) < get_dot(obj, obj)) return ONLINE_FRONT;\n    if (get_dot(base, obj) < 0) return CLOCKWISE;\n    if (get_dot(base, base) < get_dot(obj, obj)) return COUNTER_CLOCKWISE;\n    return ON_SEGMENT;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_position(s2.p1, s1) * get_position(s2.p2, s1) <= 0 &&\n        get_position(s1.p1, s2) * get_position(s1.p2, s2) <= 0) {\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(0,vec(a),vec(b))==0;}\nbool parallel(L a,L b) {return sdet(0,vec(a),vec(b))==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n\tR u=det(a.s,b.s,b.t)/det(0,vec(a),vec(b));\n\treturn (1-u)*a.s+u*a.t;\n}\n\t\n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n\tP h=proj(l,p);\n\tif(sdot(l.s,l.t,p)) h=l.s;\n\tif(sdot(l.t,l.s,p)) h=l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << (sgn(dss(s1,s2))==0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\t\t//fs->sc\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nD inf=1e50,eps=1e-10;\n//template<class T> bool eq(T a, T b) { return abs(a-b)<eps;}\n//template<class T> int sig(T a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\nbool eq(D a, D b) { return abs(a-b)<eps;}\nbool eq(P a, P b) { return abs(a-b)<eps;}\nint sig(D a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\nenum ENCCW{CCW=1, CW=-1, FRONT=2, BACK=-2, ON=0};\t//!!MAEHARAとFRONT,BACKが逆\n//ON優先(including endpoint)\ninline int ccw (P a, P b, P c){\n//\tcout << cro(b-a,c-a) << endl;\n\tif(sig(cro(b-a,c-a))==1) return CCW;\n\tif(sig(cro(b-a,c-a))==-1) return CW;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return ON;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return FRONT;\n\tif(eq(abs(c-a)+abs(a-b),abs(c-b))) return BACK;\n\tassert(false);\n}\ninline P proj(P a, P b){\t\t//ベクトルaのbへの射影\n\treturn (dot(a,b)/norm(b))*b;\n}\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\ninline bool ispal(L a, L b){\n\treturn sig(cro(a.fs-a.sc,b.fs-b.sc))==0;\n}\ninline bool ovLL(L a, L b){\n\treturn ispal(a,b) && sig(cro(a.fs-a.sc,b.fs-a.sc))==0;\n}\ninline bool iLL(L a, L b){\t\t//intersect or overload\n\treturn !ispal(a,b) || ovLL(a,b);\n}\ninline bool iLS(L l, L s){\t\t//intersect(including endpoint) or overload\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\ninline bool iLP(L l, P p){\t\t//on line\n\treturn sig(cro(l.sc-p,l.fs-p));\n}\ninline bool iSS(L a, L b){\t\t//intersect(including endpoint) or overload\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\ninline bool iSP(L s, P p){\t\t//intersect(including endpoint) or overload\n\treturn ccw(s.fs,p,s.sc)==ON;\n}\ninline D dLP(L l, P p) { return abs(perp(l,p)-p);}\ninline D dLL(L a, L b) { return iLL(a,b) ? 0 : dLP(a,b.fs);}\ninline D dLS(L l, L s) { return iLS(l,s) ? 0 : min(dLP(l,s.fs),dLP(l,s.sc));}\ninline D dSP(L s, P p) {\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline D dSS(L a, L b) {\n\tif(iSS(a,b)) return 0;\n\treturn min(min(dSP(a,b.fs),dSP(a,b.sc)),min(dSP(b,a.fs),dSP(b,a.sc)));\n}\ninline P intLL(L a, L b) {\t//intersection\n\tassert(!ispal(a,b));\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nenum ENICP{INC=1,ONC=0,OUTC=-1};\ninline int iCP(C c, P p){\n\tD d=abs(p-c.p);\n\treturn eq(d,c.r) ? ONC : (d<c.r ? INC : OUTC);\n}\ninline int iCL(C c, L l){\t\t//num of intersection(s)\n\tD d=dLP(l,c.p);\n\treturn eq(d,c.r) ? 1 : (d<c.r ? 2 : 0);\n}\n//inline int iCS\n//inline int iCC(C a, C b){\n\n/*inline P intCL1(C c, L l){\t\t//iCL=1\n\tassert(iCL(c,l)==1);\n}\ninline L intCL2(C c, L l){\t\t//iCL=2\n\tassert(iCL(c,l)==2);\n}*/\nD aTri(P a, P b, P c){ return cro(b-a,c-a)/2;}\nD aPol(Pol p){\t\t\t//点集合はCCWに与える\n\tint n=p.size();\n\tD ret=0;\n\trep(i,n) ret+=cro(p[i],p[(i+1)%n])/2;\n\treturn ret;\n}\nP gPol(Pol p){\t\t\t//多角形内部が一様な重さを持つときの重心\n\tint n=p.size();\n\tP g;\n\tD s=aPol(p);\n\tassert(s>eps);\n\trep(i,n){\n\t\tD ds=cro(p[i],p[(i+1)%n])/2;\n\t\tg+=ds/3*(p[i]+p[(i+1)%n]);\n\t}\n\treturn g/s;\n}\nenum ENCONT{INP=1,ONP=0,OUTP=-1};\nint contain(Pol pol, P p){\n\tbool in=false;\n\trep(i,pol.size()){\n\t\tP a=pol[i],b=pol[(i+1)%pol.size()];\n\t\tif(ccw(a,b,p)==ON) return ONP;\n\t\tif(!iLS(L(p,p+1.),L(a,b))) continue;\n\t\tif(ovLL(L(p,p+1.),L(a,b))){\n\t\t\tif(sig(max(real(a),real(b))-real(p))>=0) in=!in;\n\t\t\tcontinue;\n\t\t}\n\t\tif(sig(real(intLL(L(p,p+1.),L(a,b)))-real(p))>=0) in=!in;\n\t}\n\treturn in ? INP : OUTP;\n}\ninline D heron(D a, D b, D c){\n\tdouble s=(a+b+c)/2;\n\tif(s-a<eps || s-b<eps || s-c<eps) return 0;\t\t//S=0 || 三角形できない\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\nint main(){\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tD a,b,c,d,e,f,g,h;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&a,&b,&c,&d,&e,&f,&g,&h);\n\t\tL l=L(P(a,b),P(c,d)),m=L(P(e,f),P(g,h));\n\t\tprintf(\"%d\\n\",iSS(l,m) ? 1: 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef complex<double> P;\n\nP read()\n{\n    double x,y;\n    cin>>x>>y;\n    return P(x,y);\n}\n\ndouble ccw(P a,P b)\n{\n    return (a*conj(b)).imag();\n}\n\nbool online(P a,P b)\n{\n    P p=a*conj(b);\n    return p.imag()==0&&p.real()>=0&&abs(a)>abs(b);\n}\n\nint main()\n{\n    int q;\n    cin>>q;\n\n    while(q--)\n    {\n        P a=read(),b=read(),c=read(),d=read();\n        cout<<(ccw(b-a,c-a)*ccw(b-a,d-a)<0&&ccw(d-c,a-c)*ccw(d-c,b-c)<0\n               ||online(b-a,c-a)||online(b-a,d-a)||online(d-c,a-c)||online(d-c,b-c))<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct OwnVector2\n{\n\tdouble x, y;\n\tOwnVector2(double x,double y):x(x),y(y){}\n\tOwnVector2() :OwnVector2(0, 0) {}\n\tOwnVector2 operator+(const OwnVector2& v)const\n\t{\n\t\treturn OwnVector2(x + v.x, y + v.y);\n\t}\n\tOwnVector2 operator-(const OwnVector2& v)const\n\t{\n\t\treturn OwnVector2(x - v.x, y - v.y);\n\t}\n};\n\nbool SegmentIntersection(OwnVector2 p1, OwnVector2 p2, OwnVector2 p3, OwnVector2 p4)\n{\n\tOwnVector2 p12, p13, p14, p34, p31, p32;\n\tp12 = p2 - p1; p13 = p3 - p1; p14 = p4 - p1; p34 = p4 - p3; p31 = p1 - p3; p32 = p2 - p3;\n\n\tif (p1.x < p2.x)\n\t{\n\t\tif ((p3.x < p1.x&&p4.x < p1.x) || (p2.x < p3.x&&p2.x < p4.x))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((p3.x < p2.x&&p4.x < p2.x) || (p1.x < p3.x&&p1.x < p4.x))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (p1.y < p2.y)\n\t{\n\t\tif ((p3.y < p1.y&&p4.y < p1.y) || (p2.y < p3.y&&p2.y < p4.y))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((p3.y < p2.y&&p4.y < p2.y) || (p1.y < p3.y&&p1.y < p4.y))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ((p12.x*p13.y - p12.y*p13.x)*(p12.x*p14.y - p12.y*p14.x)>0)\n\t{\n\t\treturn false;\n\t}\n\tif ((p34.x*p31.y - p34.y*p31.x)*(p34.x*p32.y - p34.y*p32.x)>0)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n\t\tOwnVector2 p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\n\t\tprintf(SegmentIntersection(p0, p1, p2, p3) ? \"1\\n\" : \"0\\n\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tG g(4);\n\t\trep(i,4)g[i]=pin();\n\t\tcout<<intersectSS(L(g[0],g[1]),L(g[2],g[3]))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif((p2-p1).det(p2-p0)!=0) return 0;\n\t\tif(((p2-p0).dot(p2-p1)<=0)||((p3-p0).dot(p3-p1)<=0) || ((p1-p2).dot(p1-p3)<=0)){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Point{double x,y;};\nPoint operator -(Point a,Point b){return (Point){a.x-b.x,a.y-b.y};}\ndouble cross(Point a,Point b){return a.x*b.y-a.y*b.x;}\ndouble dot(Point a,Point b){return a.x*b.x+a.y*b.y;}\ndouble norm(Point a){return a.x*a.x+a.y*a.y;}\nvoid read(Point &a){a.x=read(),a.y=read();}\nint Clockwise(Point p0,Point p1,Point p2)\n{\n\tPoint v1=p1-p0,v2=p2-p0;\n\tif(cross(v1,v2)>0)return -2;\n\tif(cross(v1,v2)<0)return 2;\n\tif(dot(v1,v2)<0)return -1;\n\tif(norm(v1)<norm(v2))return 1;\n\treturn 0;\n}\nbool Intersect(Point p0,Point p1,Point p2,Point p3)\n{\n\tif(Clockwise(p0,p1,p2)*Clockwise(p0,p1,p3)>0)return 0;\n\tif(Clockwise(p2,p3,p0)*Clockwise(p2,p3,p1)>0)return 0;\n\treturn 1;\n}\nint main()\n{\n\tint q=read();while(q--)\n\t{\n\t\tPoint p0,p1,p2,p3;\n\t\tread(p0),read(p1),read(p2),read(p3);\n\t\tprintf(\"%d\\n\",Intersect(p0,p1,p2,p3));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\n\nusing Real = double;\nusing Point = complex<Real>;\nconst Real Pi = acos(-1), EPS = 1e-9;\ninline bool eq(Real a, Real b) { return fabs(a - b) < EPS; }\n\n//scalar\nPoint operator*(const Point &p, const Real &c)\n{\n    return Point(c * real(p), c * imag(p));\n}\n\n//add\nPoint operator+(const Point &p, const Point &q)\n{\n    return Point(real(p) + real(q), imag(p) + imag(q));\n}\n\nPoint operator-(const Point &p, const Point &q)\n{\n    return Point(real(p) - real(q), imag(p) - imag(q));\n}\n//equal\nbool operator==(const Point &p, const Point &q)\n{\n    return (real(p) == real(q)) && (imag(p) == imag(q));\n}\n\nReal radian_to_degree(Real r)\n{\n    return (r * 180.0 / Pi);\n}\n\nReal degree_to_radian(Real d)\n{\n    return (d * Pi / 180.0);\n}\n\n//rotate\nPoint rot(Real theta, const Point &p)\n{\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n//norm\nReal norm(Point const &p)\n{\n    return (real(p) * real(p) + imag(p) * imag(p));\n}\n\n//argumant [0, 2 * Pi)\nReal arg(Point const &p)\n{\n    Real a = atan2(imag(p), real(p));\n    if (a < 0)\n        a = fabs(a) + Pi;\n    return a;\n}\n\nReal dot(const Point &p, const Point &q)\n{\n    return (real(p) * real(q) + imag(p) * imag(q));\n}\n\n// regard z - component is zero\nReal cross(const Point &p, const Point &q)\n{\n    return real(p) * imag(q) - imag(p) * real(q);\n}\n\n//input\nistream &operator>>(istream &is, Point &p)\n{\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n//output\nostream &operator<<(ostream &os, Point &p)\n{\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\n// a line given two points\nstruct Line\n{\n    Point a, b;\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    // Ax + By = C\n    Line(Real A, Real B, Real C)\n    {\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend istream &operator>>(istream &is, Line &a)\n    {\n        return is >> a.a >> a.b;\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p)\n    {\n        return os << p.a << \" to \" << p.b;\n    }\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Lines = vector<Line>;\n\n//For given three points p1,p2,p, find the projection point x of p onto p1p2.\nPoint projection(const Line &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b); // direction vector\n    return l.a + (l.a - l.b) * t;\n}\n\n//For given three points p1,p2,p, find the reflection point x of p onto p1p2.\nPoint reflection(const Line &l, const Point &p)\n{\n    return p + (projection(l, p) - p) * 2.0;\n}\n\n// Counter_Clockwise, a is standard point\nint ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS)\n        return +1; // counter clockwise\n    if (cross(b, c) < -EPS)\n        return -1; // clockwise\n    if (dot(b, c) < 0)\n        return +2; // c--a--b on line\n    if (norm(b) < norm(c))\n        return -2; // a--b--c on line\n    return 0;      // c on segment a-b\n}\n\n// two lines are parallel\nbool Parallel(const Line &L1, const Line &L2)\n{\n    return eq(cross(L1.b - L1.a, L2.b - L2.a), 0.0);\n}\n\n// two lines are orthogonal\nbool Orthogonal(const Line &L1, const Line &L2)\n{\n    return eq(dot(L1.b - L1.a, L2.b - L2.a), 0.0);\n}\n\nbool intersect(const Line &L1, const Line &L2)\n{\n    // non-parallel || same line\n    bool r = (abs(cross(L1.b - L1.a, L2.b - L2.a)) < EPS) || (abs(cross(L1.b - L1.a, L2.a - L1.a)) < EPS);\n    return r;\n}\n\nstruct Segment : Line\n{\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nusing segments = vector<Segment>;\n\nbool intersect(const Segment &s, const Segment &t)\n{\n    bool r = ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    return r;\n}\n\nint main()\n{\n    int Q;\n    cin >> Q;\n    for (int i = 0; i < Q; i++)\n    {\n        Segment S, T;\n        cin >> S >> T;\n        if (intersect(S, T) == true)\n        {\n            cout << 1 << endl;\n        }\n        else\n        {\n            cout << 0 << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*<<head>> {{{*/\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)-1;\n\n// ------- 变量 ------- //\n\n/* 注意\n  1. 点、向量\n    1. 如果角度出现 -pi ，可以加上 2pi 修正为 pi\n    2. atan2(y, x) 的参数是浮点数时，可能出现 -pi ，如 atan2(-0.0, -1.0)\n  2. 线段、直线\n    1. 线段严格相交定义为：每条线段的两个端点落在另一条线段两边，形象来说，就是可以在图形里看到四个端点和一个交点\n*/\n\ntypedef db T;\nconst db eps = 1e-7, pi = acosl(-1.);\nint sgn(T x) { return (x > eps) - (x < -eps); }\nbool inMid(T a, T x, T b) { return sgn(a - x) * sgn(b - x) <= 0; }  // 数 x 在区间 [a, b] 内（包括边界）\n\n// 点、向量\nstruct P {\n    T x, y; P () {} P(T x, T y) : x(x), y(y) {}\n    P operator + (const P &b) const { return P(x + b.x, y + b.y); }  // 向量加\n    P operator - (const P &b) const { return P(x - b.x, y - b.y); }  // 向量减\n    T operator * (const P &b) const { return x * b.x + y * b.y; }    // 向量点积\n    T operator / (const P &b) const { return x * b.y - y * b.x; }    // 向量叉积\n    P operator * (const T &k) const { return P(x * k, y * k); }      // 向量数乘\n    P operator / (const T &k) const { return P(x / k, y / k); }      // 向量数除\n    bool operator < (const P &b) const { return sgn(x - b.x) ? x < b.x : y < b.y; }  // 左小右大，下小上大\n    bool operator == (const P &b) const { return !sgn(x - b.x) && !sgn(y - b.y); }   // 向量相等\n    P rot(T t) { return P(x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)); }  // 向量逆时针旋转 t 弧度\n    P rot90() { return P(-y, x); }           // 向量逆时针旋转 90 度\n    db arg() const { return atan2(y, x); }   // 方位角 (-pi, pi]\n    T abs() { return sqrt(x * x + y * y); }  // 向量模长\n    T abs2() { return x * x + y * y; }       // 向量模长的平方\n    P unit() { return (*this) / abs(); }     // 单位向量\n    void scan() { db tx, ty; scanf(\"%lf%lf\", &tx, &ty); x = tx; y = ty; }  // 输入\n    void print() { printf(\"%.11lf %.11lf\\n\", x, y); }                      // 输出\n    P toR() { return (sgn(x) == -1 || !sgn(x) && sgn(y) == -1) ? (*this)*(-1) : (*this); }  // 若向量在 2 3 象限，则取其相反向量\n    bool isUp() const { return sgn(y) == 1 || !sgn(y) && sgn(x) == -1; }                    // 向量是否在 1 2 象限\n};\nT dis(P a, P b) { return (b - a).abs(); }   // 点 a 到点 b 的距离\nP symmetry(P p, P a) { return a + a - p; }  // 点 p 关于点 a 的中心对称点\nT cross(P o, P a, P b) { return (a - o) / (b - o); }         // 向量 oa 与 ob 的叉积\nint crossSgn(P o, P a, P b) { return sgn(cross(o, a, b)); }  // 向量 oa 与 ob 的叉积符号\ndb rad(P a, P b) { return atan2(a / b, a * b); }             // 向量 a 与 b 的夹角（弧度制）\nbool order(const P &a, const P &b) { return a.isUp() < b.isUp() || a.isUp() == b.isUp() && sgn(a/b) > 0; }  // 极角排序\n\n// 线段、直线\nstruct L { P s, t; L () {} L(P s, P t) : s(s), t(t) {} };\nbool onPS(P p, L a) { return sgn((a.t-a.s)/(p-a.s))==0 && sgn((p-a.s)*(p-a.t))<=0; }   // 点 p 是否在线段 st 上\nbool inRec(P p, L a) { return inMid(a.s.x, p.x, a.t.x) && inMid(a.s.y, p.y, a.t.y); }  // 点 p 在以直线 a 为对角线的矩形内\nP proj(P p, L a) { return (a.t-a.s) * ( (p-a.s) * (a.t-a.s) / (a.t-a.s).abs2() ) + a.s; }   // 点 p 关于直线 a 的投影点\nP reflect(P p, L a) { return proj(p, a) * 2 - p; }                                          // 点 p 关于直线 a 的对称点\nbool xSSr(const L &a, const L &b) {  // 线段 a 和线段 b 严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0;\n}\nbool xSS(L a, L b) {                 // 线段 a 和线段 b 不严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n           sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n           sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n           sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n           sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\nbool xSL(L a, L b) {  // 线段 a 与直线 b 相交 ( 不严格 : <= ; 严格 : < )\n    return sgn( (b.t - b.s) / (a.s - b.s) ) * sgn( (b.t - b.s) / (a.t - b.s) ) <= 0;\n}\nP xLL(L a, L b) {  // 直线 a 和直线 b 的交点\n    T s1 = (b.t - b.s) / (a.s - b.s), s2 = -( (b.t - b.s) / (a.t - b.s) );\n    return (a.s * s2 + a.t * s1) / (s1 + s2);\n}\ndb disPL(P p, L a) { return fabs( (a.t-a.s) / (p-a.s) ) / (a.t-a.s).abs(); }  // 点 p 到直线 a 的距离\ndb disPS(P p, L a) {                                                          // 点 p 到线段 a 的距离\n    return sgn( (a.t-a.s) * (p-a.s) ) * sgn( (a.s-a.t) * (p-a.t) ) != 1\n           ? disPL(p, a) : min( (p-a.s).abs(), (p-a.t).abs() );\n}\ndb disSS(L a, L b){                                                           // 线段 a 到线段 b 的距离\n    if (xSS(a,b)) return 0;\n    return min( min( disPS(a.s,b), disPS(a.t,b) ), min( disPS(b.s,a), disPS(b.t,a) ) );\n}\ndb disLL(L a, L b) { return (a.t-a.s) / (b.t-b.s) ? 0 : disPL(a.s, b); }      // 直线 a 到直线 b 的距离\n\n// 多边形、凸包\ntypedef vector<P> polygon;\npolygon Convex(polygon A) {  // 求凸包，逆时针排序（ 内角 <180 : (<=) ; 内角 <=180 : (<) ）\n    int n = sz(A); if (n <= 1) return A;\n    sort(all(A));\n    polygon B;\n    for (int i = 0; i < n; B.pb(A[i++]))\n        while (sz(B) > 1 && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 更改这里的 <\n    for (int i = n - 2, t = sz(B); i >= 0; B.pb(A[i--]))\n        while (sz(B) > t && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 同上\n    B.pop_back(); return B;\n}\nT area(polygon A) {  // 多边形 A 的面积，整型可以返回面积的两倍，保持精度\n    T res = 0;\n    rep(i, 0, sz(A)) res += A[i] / A[ (i+1) % sz(A) ];\n    return fabs(res) / 2;\n}\nbool isConvex(polygon A) {  // 多边形 A 是否是凸包，要求 A 的点集按逆时针排序\n    rep(i, 0, 2) A.pb(A[i]);\n    rep(i, 0, sz(A)-2) if ( sgn( (A[i+1]-A[i]) / (A[i+2]-A[i]) ) < 0 ) return 0;\n    return 1;\n}\nint inPpolygon(P p, polygon A) {  // 点和多边形关系 ( -1 : on , 0 : out , 1 : in )\n    int res = 0;\n    rep(i, 0, sz(A)) {\n        P u = A[i], v = A[ (i+1) % sz(A) ];\n        if (onPS(p, L(u, v))) return -1;\n        T cross = sgn((v-u)/(p-u)), d1 = sgn(u.y-p.y), d2 = sgn(v.y-p.y);\n        if (cross > 0 && d1 <= 0 && d2 > 0) ++res;\n        if (cross < 0 && d2 <= 0 && d1 > 0) --res;\n    }\n    return res != 0;\n}\n\nstruct C {\n    P o; db r; C () {} C (P o, db r) : o(o), r(r) {}\n};\n\nC getC(P a,P b,P c){  // 三点确定一个圆 （ 三角形外接圆 ）\n    db a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\n    db a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\n    db d = a1 * b2 - a2 * b1;\n    P o = P(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);\n    return C(o, dis(a, o));\n}\n\nP p[3];\n\n// ------- 函数 ------- //\n\nvoid Init() {\n}\n\nint Solve() {\n    int q; scanf(\"%d\", &q);\n    while (q--) {\n        rep(i, 0, 4) p[i].scan();\n        L s1 = L(p[0], p[1]), s2 = L(p[2], p[3]);\n        if (xSS(s1, s2)) puts(\"1\");\n        else puts(\"0\");\n    }\n    return 0;\n}\n\n// ------- main ------- //\n\nint main ()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    //Pre();\n    //int t; scanf(\"%d\", &t); while (t--) {\n    //while (~scanf(\"%d\", &n)) {\n    //while(fgets(s, N, stdin)) {   // 注意 fgets 会读入换行符\n        //if (n == 0) break;\n        //static int kase = 0; printf(\"Case %d: \", ++kase);\n        Init();\n        Solve();\n        //if (t) puts(\"\");\n    //}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define _GLIBCXX_DEBUG\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...on_seg(p1,p2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n\tint q;\n\tcin>>q;\n\tfor(int cnt=0;cnt<q;cnt++)\n\t{\n\t\tvector<point> p;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tdouble c,d;\n\t\t\tcin>>c>>d;\n\t\t\tp.push_back(point(c,d));\n\t\t}\n\t\tif(on_seg(p[0],p[1],intersection(p[0],p[1],p[2],p[3])))\n\t\t\tcout<<1<<endl;\n\t\telse\n\t\t\tcout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n//?????????????????????double??§\nstruct Point{ double x, y; };\n//Point????¨?????????????setter getter\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n//?????????point????????????????¨????????????????????????????\n//????????????????????????????????????\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n//??????????????????v1*v2+v1*v2\ndouble dot(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vx) + (v1.vy * v2.vy);\n}\n//????????????\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n//norm??§?????????????????????\ndouble onenorm(const Vector &v)\n{\n    return abs(v.vx) + abs(v.vy);\n}\n//counter clock \nint ccw(const Point &P0, const Point &P1, const Point &P2)\n{  //?????????????????????????????????\n    Vector V1 = set_v(P0, P1);\n    Vector V2 = set_v(P0, P2);\n    //???????±???????\n    double c = cross(V1, V2);\n    //????????????????????????,????¨?????????????????????????????¨???¨???\n    if(c > 0){ return 1; }else if(c < 0){ return -1; }\n    if(dot(V1, V2) < 0){ return -2; }\n    //?????????V1?????????????°????????????????????????????????????????\n    if(onenorm(V1) < onenorm(V2)){ return 2; }\n    return 0;\n}\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n    //double??§?????£?????????\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        //??????????????§?¨??????????\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n        if(ccw(P0, P1, P2) * ccw(P0, P1, P3) <= 0 && ccw(P2, P3, P0) * ccw(P2, P3, P1) <= 0){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - p3.x);\n    double td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - p4.x);\n    return tc * td < 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>eps) return 1;\n\t\tif(Getmp<-eps) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define MP make_pair\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){\n\treturn sign(a-b);\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool intersect(db l1,db r1,db l2,db r2){\n\tif(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); \n\treturn !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSegment(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\nint main(){\n\tint n;cin>>n;\n\trep(i,0,n){\n\t\tP p1,p2,q1,q2;\n\t\tp1.read(),p2.read(),q1.read(),q2.read();\n\n\t\tcout<<isSS(p1,p2,q1,q2)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.a - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n};\n \nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\n\nint main(){\n  int q;\n  S s1, s2;\n\n  cin >> q;\n  while(q--){\n    cin >> s1 >> s2;\n    cout << geo.Intersect( s1, s2) << endl;\n  }\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n// 端点 (x0, y0), (x1, y1) の線分と (x0, y0), (x1, y1) の線分が共有点を持つかを返す\ntemplate <typename T>\nbool intersection(T x0, T y0, T x1, T y1, T x2, T y2, T x3, T y3){\n\tT a1 = y1 - y0, b1 = x0 - x1, c1 = x0 * (y1 - y0) - y0 * (x1 - x0);\n\tT a2 = y3 - y2, b2 = x2 - x3, c2 = x2 * (y3 - y2) - y2 * (x3 - x2);\n\t// 線分が平行な場合\n\tif(a1 * b2 == b1 * a2){\n\t\t// 同一直線上にない場合\n\t\tif(x0 * a1 + y0 * b1 != x2 * a1 + y2 * b1){\n\t\t\treturn false;\n\t\t}\n\t\t// 線分が重なってない場合\n\t\telse if(max(x0, x1) < min(x2, x3) || max(x2, x3) < min(x0, x1) || max(y0, y1) < min(y2, y3) || max(y2, y3) < min(y0, y1)){\n\t\t\treturn false;\n\t\t}\n\t\t// 線分が重なっている場合\n\t\treturn true;\n\t}\n\t// 一方の端点がもう一方の直線をまたいでいる場合、交点を持つ\n\treturn (a1 * x2 + b1 * y2 - c1) * (a1 * x3 + b1 * y3 - c1) <= 0 && (a2 * x0 + b2 * y0 - c2) * (a2 * x1 + b2 * y1 - c2) <= 0;\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\tfor(int loop = 0; loop < q; loop++){\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tcout << intersection<long long int>(x0, y0, x1, y1, x2, y2, x3, y3) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\ndouble sgn(double d) {\n  if (dcmp(d))\n    return 0;\n  if (d > 0)\n    return 1;\n  return -1;\n}\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) { return dcmp(a * p.x + b * p.y + c); }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() { return line(p1, p2); }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    return ok;\n  }\n  bool intersect(segment s) {\n    vec v0 = p2 - p1;\n    vec v1 = s.p2 - s.p1;\n    if (v0.parallel(v1)) {\n      return (contains(s.p1) || contains(s.p2)) ||\n             (s.contains(p1) || s.contains(p2));\n    }\n    point a = p1, b = p2, c = s.p1, d = s.p2;\n    return sgn((a - b).cross(b - c)) != sgn((a - b).cross(b - d)) &&\n           sgn((c - d).cross(d - a)) != sgn((c - d).cross(d - b));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1);\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Intersection Determination\n#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;    // 許容誤差。問題によって変える\ntypedef complex<double> P;  // Point\n#define X real()\n#define Y imag()\ndouble norm(P &p1, P &p2){\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\nnamespace std{\n    bool operator<(const P p1, const P p2){\n        return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n    }\n    P operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\n    P operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\n    P operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\n    P operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n} \n\n//Segment/Line\nstruct Segment{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\n//外積cross(a,b) = |a||b|sinθ=a1b2+a2b1\ndouble cross(const P &a, const P &b){\n    return (conj(a) * b).Y;\n}\n//内積dot(a,b) = |a||b|cosθ=a1b1+a2b2\ndouble dot(const P &a, const P &b){\n    return (conj(a) * b).X;\n}\n\n//位置関係判定(線分abを軸にcがどちら側にあるか)\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a; //aからの向きを考える\n    if (cross(b, c) > EPS)\n        return +1; //clockwise\n    else if (cross(b, c) < -EPS)\n        return -1; //counter clockwise\n    else if (dot(b, c) < -EPS)\n        return +2; //c-a-b\n    else if (norm(b) < norm(c))\n        return -2; //a-b-c\n    else\n        return 0; //他\n}\n\n//Intersection Determination\nbool intersectLL(const Line &l, const Line &m){\n    return abs(cross(l.p2 - l.p1, m.p2 - m.p1)) > EPS || // non-parallel\n        abs(cross(l.p2 - l.p1, m.p1 - l.p1))  < EPS;       // same line\n                                                      \n}\nbool intersectLS(const Line &l, const Line &s){\n    return cross(l.p2 - l.p1, s.p1 - l.p1) * // s.p1 is left of l\n               cross(l.p2 - l.p1, s.p2 - l.p1) <EPS; // s.p2 is right of l\n}\nbool intersectLP(const Line &l, const P &p){\n    return abs(cross(l.p2 - p, l.p1 - p)) < EPS;\n}\nbool intersectSS(const Line &s, const Line &t){\n    return ccw(s.p1, s.p2, t.p1) * ccw(s.p1, s.p2, t.p2) <= 0 &&\n           ccw(t.p1, t.p2, s.p1) * ccw(t.p1, t.p2, s.p2) <= 0;\n}\nbool intersectSP(const Line &s, const P &p){\n    return abs(s.p1 - p) + abs(s.p2 - p) - abs(s.p2 - s.p1) < EPS; // triangle inequality\n}\n\n//Verify\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\nint main(){\n    int q;\n    cin>>q;\n    for (int i = 0; i < q;i++){\n        double x0,x1,x2,x3,y0,y1,y2,y3;\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        P p0 = P(x0, y0), p1 = P(x1, y1), p2 = P(x2, y2), p3 = P(x3, y3);\n        const Line l1 = Line(p0, p1), l2 = Line(p2, p3);\n        if (intersectSS(l1, l2) )\n            cout << \"1\" << endl;\n        else\n            cout << \"0\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nstruct Vec2\n{\n\tVec2(){}\n\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\n\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\tVec2 operator*(T s) const { return Vec2(x*s, y*s); }\n\tVec2 operator/(T s) const { return Vec2(x/s, y/s); }\n\tT dot(const Vec2& rhs) const { return x*rhs.x + y*rhs.y; }\n\tT cross(const Vec2& rhs) const { return x*rhs.y - y*rhs.x; }\n\tT sqlength() const { return x*x + y*y; }\n\tdouble length() const { return sqrt(sqlength()); }\n\tbool operator<(const Vec2& rhs) const\n\t{\n\t\tif (x != rhs.x) return x < rhs.x;\n\t\treturn y < rhs.y;\n\t}\n\n\tT x;\n\tT y;\n};\n\ntemplate<class T>\nT cross(const Vec2<T> &O, const Vec2<T> &A, const Vec2<T> &B)\n{\n\treturn (A - O).cross(B - O);\n}\n\ntemplate<class T>\nbool IsIntSegments(const Vec2<T>& A1, const Vec2<T>& A2, const Vec2<T>& B1, const Vec2<T>& B2)\n{\n\treturn (cross(A1, A2, B1)*cross(A1, A2, B2) < 0 && cross(B1, B2, A1)*cross(B1, B2, A2) < 0);\n}\n\ntemplate<class T>\nbool IsPointOnSegment(const Vec2<T>& P, const Vec2<T>& S, const Vec2<T>& E)\n{\n\tVec2<T> dir = E - S;\n\tif ((P - S).cross(dir) != 0) {\n\t\treturn false;\n\t}\n\tT prd = (P - S).dot(dir);\n\tif (prd < 0) {\n\t\treturn false;\n\t}\n\treturn prd <= dir.dot(dir);\n}\n\nint main()\n{\n\ttypedef Vec2<long long> Vec;\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tVec P[4];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> P[j].x >> P[j].y;\n\t\t}\n\n\t\tif (IsIntSegments(P[0], P[1], P[2], P[3]) ||\n\t\t\tIsPointOnSegment(P[0], P[2], P[3]) ||\n\t\t\tIsPointOnSegment(P[1], P[2], P[3]) ||\n\t\t\tIsPointOnSegment(P[2], P[0], P[1]) ||\n\t\t\tIsPointOnSegment(P[3], P[0], P[1])) {\n\t\t\tputs(\"1\");\n\t\t}\n\t\telse {\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/12/3.\n//\n\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\n#define EPSLON 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPSLON)\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK -2\n#define ONLINE_FRONT 2\n#define ON_SEGMENT 0\nusing namespace std;\n\n// 点\nclass Point {\npublic:\n    double x;\n    double y;\n\n    Point() {}\n\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator+(Point a) {\n        return Point(x + a.x, y + a.y);\n    }\n\n    Point operator-(Point a) {\n        return Point(x - a.x, y - a.y);\n    }\n\n    Point operator*(double a) {\n        return Point(x * a, y * a);\n    }\n\n    Point operator/(double a) {\n        return Point(x / a, y / a);\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n\n    double absVector() {\n        return sqrt(norm());\n    }\n\n    bool operator==(Point a) const {\n        return equals(x, a.x) && equals(y, a.y);\n    }\n};\n\ntypedef Point Vector;\n\n// 线段\nclass Segment {\npublic:\n    Point a, b;\n};\n\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Segment s, Point p) {\n    Vector v1 = s.b - s.a;\n    Vector v2 = p - s.a;\n    if (cross(v1, v2) > 0) return COUNTER_CLOCKWISE;\n    if (cross(v1, v2) < 0) return CLOCKWISE;\n    if (dot(v1, v2) < 0) return ONLINE_BACK;\n    if (v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersection(Segment s1, Segment s2){\n    return (ccw(s1, s2.a) * ccw(s1, s2.b) <= 0 && ccw(s2, s1.a) * ccw(s2, s1.b) <= 0);\n}\n\n\nint n;\n\n\nint main() {\n    Segment s[2];\n    Point p[4];\n    scanf(\"%d\", &n);\n    Point point;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            double x, y;\n            scanf(\"%lf %lf\", &x, &y);\n            point = Point(x, y);\n            p[j] = point;\n        }\n        s[0].a = p[0];\n        s[0].b = p[1];\n        s[1].a = p[2];\n        s[1].b = p[3];\n        printf(\"%d\\n\", intersection(s[0], s[1]));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{x+p.x,y+p.y};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{x-p.x,y-p.y};\n\t}\n\tpoint operator*(double p){\n\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n\t}\n};\n\ntypedef pair<point,point> pp;\nconst point O{0,0};\n\nclass Geom{\n\tpublic:\n\tdouble Length(point x,point y){\n\t\tpoint z=y-x;\n\t\treturn sqrt(z.x*z.x+z.y*z.y);\n\t}\n\tdouble IP(point p,point q){\n\t\treturn p.x*q.x+p.y*q.y;\n\t}\n\tdouble CP(point p,point q){\n\t\treturn p.x*q.y-q.x*p.y;\n\t}\n\tstring Counter_Clockwise(pp a,point x){\n\t\tpoint A=a.second-a.first;\n\t\tpoint X=x-a.first;\n\t\tdouble ip=IP(A,X),cp=CP(A,X),Al=Length(O,A),Xl=Length(O,X);\n\t\tif(cp>eps) return \"Counter_Clockwise\";\n\t\tif(cp<-eps) return \"Clockwise\";\n\t\tif(ip<-eps) return \"Online_Back\";\n\t\tif(Xl<Al||fabs(Xl-Al)<eps) return \"On_Segment\";\n\t\treturn \"Online_Front\";\n\t}\n\tstring Parallel_Orthogonal(pp a,pp b){\n\t\tpoint A=a.second-a.first,B=b.second-b.first;\n\t\tdouble ip=IP(A,B),cp=CP(A,B);\n\t\tstring f=Counter_Clockwise(pp(a.first,a.second),b.first),s=Counter_Clockwise(pp(a.first,a.second),b.second);\n\t\tif(f[0]!='C'&&s[0]!='C') return \"Agreement\";\n\t\tif(cp<eps&&cp>-eps) return \"Parallel\";\n\t\tif(ip<eps&&ip>-eps) return \"Orthogonal\";\n\t\telse return \"Commonly\";\n\t}\n\tstring Intersection(pp a,pp b){\n\t\tpoint p=Cross_Point(a,b);\n\t\tstring s=Counter_Clockwise(a,p),t=Counter_Clockwise(b,p);\n\t\tif(s[3]=='S'&&t[3]=='S') return \"Intersection\";\n\t\telse return \"not_Intersection\";\n\t}\n\tpoint Inter(pp  a,double x,double y){\n\t\treturn (a.first*y+a.second*x)/(x+y);\n\t}\n\tpoint Exterior(pp a,double x,double y){\n\t\treturn (a.first*-y+a.second*x)/(x-y);\n\t}\n\tpoint Projection(pp a,point x){\n\t\tpoint A=x-a.first,B=a.second-a.first;\n\t\tdouble l=Length(O,B);\n\t\treturn B*IP(A,B)/(l*l)+a.first;\n\t}\n\tpoint Cross_Point(pp a,pp b){\n\t\tstring s=Parallel_Orthogonal(a,b);\n\t\tif(s[0]=='A') return point{inf,inf};\n\t\tif(s[0]=='P') return point{inf,0};\n\t\tpoint p=Projection(a,b.first),q=Projection(a,b.second);\n\t\tdouble pl=Length(b.first,p),ql=Length(b.second,q);\n\t\tstring S=Counter_Clockwise(a,b.first),T=Counter_Clockwise(a,b.second);\n\t\tif(S==T) return Exterior(b,pl,ql);\n\t\telse return Inter(b,pl,ql);\n\t}\n\tvoid Point_in(point& p){\n\t\tcin>>p.x>>p.y;\n\t}\n\tvoid Point_out(point p){\n\t\tcout<<p.x<<' '<<p.y<<endl;\n\t}\n};\n\nint Q;\nvector<point> p(4);\n\nint main(){\n\tcout<<syosu(10);\n\tGeom geo;\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<4;j++) geo.Point_in(p[j]);\n\t\tstring ans=geo.Intersection(pp(p[0],p[1]),pp(p[2],p[3]));\n\t\tif(ans==\"Intersection\") cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (Point p) { return Point(x * p.x, y * p.y); }\n\tPoint operator * (double p) { return Point(x * p, y * p); }\n\tPoint operator / (Point p) { return Point(x / p.x, y / p.y); }\n\tPoint operator / (double p) { return Point(x / p, y / p); }\n\tvoid insert(double a, double b) { x = a; y = b; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tVector p1, p2;\n\tSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0):\n\t\tp1(x1, y1), p2(x2, y2) {}\n\tSegment(Point a1, Point a2) : p1(a1), p2(a2) {}\n\tvoid insert(Vector a1, Vector a2) { p1 = a1; p2 = a2; }\n};\ntypedef Segment Line;\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\ninline bool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\ninline bool isOrthogonal(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\ninline bool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\ninline bool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\ninline bool isParallel(Vector a1, Vector a2, Vector b1, Vector b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\ninline bool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(Point &p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point &p1, Point &p2, Point &p3, Point &p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment &s1, Segment &s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistance(Point &a, Point &b) { return (a - b).abs(); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tint q; cin >> q;\n\tPoint p1, p2, p3, p4;\n\trep(i, 0, q) {\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y;\n\t\tP(intersect(p1, p2, p3, p4) ? 1 : 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct Point{\n    double x;\n    double y;\n    Point(double x, double y) : x(x), y(y){}\n    Point operator-(Point p){\n        return Point(x - p.x, y - p.y);\n    }\n};\ntypedef Point Vector;\ndouble get_cross(Vector v1, Vector v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\nstruct Segment{\n    Point p1;\n    Point p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n};\nint get_direction(Point p, Segment s){\n    Vector base = s.p2 - s.p1;\n    Vector obj  = p    - s.p1;\n    double cross = get_cross(base, obj);\n    if (cross >  1e-10) return 1;\n    if (cross < -1e-10) return -1;\n    return 0;\n}\nbool is_intersection(Segment s1, Segment s2){\n    if (get_direction(s1.p1, s2) * get_direction(s1.p2, s2) > 0) {\n        return false;\n    }\n    if (get_direction(s2.p1, s1) *  get_direction(s2.p2, s1) > 0) {\n        return false;\n    }\n    return true;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3;\n        cin >> x_p0 >> y_p0 >> x_p1 >> y_p1;\n        cin >> x_p2 >> y_p2 >> x_p3 >> y_p3;\n        Point p0(x_p0, y_p0);\n        Point p1(x_p1, y_p1);\n        Point p2(x_p2, y_p2);\n        Point p3(x_p3, y_p3);\n        Segment s1(p0, p1);\n        Segment s2(p2, p3);\n        int ans = 0;\n        if (is_intersection(s1, s2)) ans = 1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define equals(a, b) (fabs((a)-(b)) < EPS)\nconst double EPS = (1e-10);\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a) {\n        return Point(x*a, y*a);\n    }\n    Point operator / (double a) {\n        return Point(x/a, y/a);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n    double norm() {\n        return x*x + y*y;\n    }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n// 内積\ndouble dot(Vector a, Vector b) {\n    return a.x*b.x + a.y*b.y;\n}\n// 外積\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q; cin >> q;\n\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1\n            >> x2 >> y2 >> x3 >> y3;\n        Segment s1(Point(x0, y0), Point(x1, y1));\n        Segment s2(Point(x2, y2), Point(x3, y3));\n\n        if (intersect(s1, s2)) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \";} cout<<endl;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\ntypedef complex<double> P;\ndouble dot(P a, P b){ //内積\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b){ //外積\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orth(P a1, P a2, P b1, P b2){ //垂直か\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\nbool is_para(P a1, P a2, P b1, P b2){ //平行か\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\nbool is_online(P a, P b, P c){ //cが線分上か\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\nbool distance_lp(P a, P b, P c){ //直線abと点cの距離\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble norm(P a){\n  return a.real() * a.real() +a.imag() *a.imag();\n}\n\nint ccw(P p0,P p1,P p2){\n  P a = p1-p0;\n  P b = p2-p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(abs(a) < abs(b)) return -2;\n  return 0;\n}\n\nbool is_intersect(P p1, P p2, P p3, P p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n      ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nP intersect_pos(P a1, P a2, P b1, P b2){ //直線同士の交点\n    P a = a2 - a1;\n    P b = b2 - b1;\n    return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\n#define printP(P) cout << \"(\" << P.real() << \", \" << P.imag() << \")\" << endl;\n\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll q;\n    cin >> q;\n    while(q--){\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        P p0(x0,y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n        if(is_intersect(p0,p1,p2,p3)){\n            print(\"1\");\n        }else{\n            print(\"0\");\n        }\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<=0&&p3*p4<=0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> \ninline void read(T& x)\n{\n\tchar c = getchar(); T p = 1, n = 0;\n\twhile(c < '0' || c > '9'){if(c == '-') p = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9'){n = n * 10 + c - '0'; c = getchar();}\n\tx = p * n;\n}\ntemplate<class T, class U>\ninline void read(T& x, U& y){read(x), read(y);}\ntemplate<class T, class U, class V>\ninline void read(T& x, U& y, V& z){read(x), read(y), read(z);}\nconst double eps = 1e-6;\nstruct Point\n{\n\tdouble x, y;\n\tPoint(int a, int b){x = a, y = b;}\n\tPoint(double a = .0, double b = .0){x = a, y = b;}\n\tPoint operator+(const Point& r){return Point(x + r.x, y + r.y);}\n\tPoint operator-(const Point& r){return Point(x - r.x, y - r.y);}\n\tPoint operator*(double r){return Point(x * r, y * r);}\n\tdouble operator*(const Point& r){return x * r.y - y * r.x;}\n};\ntypedef Point Vector;\ninline double dot(Vector l, Vector r){return l.x * r.x + l.y * r.y;}\ninline double norm(Vector l){return dot(l, l);}\ninline int ccw(Point x, Point y, Point z)\n{double cross = (y - x) * (z - x); return cross < -eps ? -1 : (cross > eps ? 1 : 0);}\nstruct Segment\n{\n\tPoint a, b;\n\tSegment(){}\n\tSegment(Point x, Point y){a = x, b = y;}\n};\ninline bool isIntersection(Segment l, Segment r)\n{return (ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0) && (ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0);}\nint main()\n{\n\tint q, x0, y0, x1, y1, x2, y2, x3, y3; read(q);\n\twhile(q--)\n\t{\n\t\tread(x0, y0), read(x1, y1), read(x2, y2), read(x3, y3);\n\t\tputs(isIntersection(Segment(Point(x0, y0), Point(x1, y1)), Segment(Point(x2, y2), Point(x3, y3))) ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nclass Vector\n{\npublic:\n  double x;\n  double y;\n\n  Vector(){}\n  Vector( double x, double y ) : x(x), y(y) {}\n\n  Vector operator + ( const Vector v ) { return Vector( x + v.x, y + v.y ); }\n  Vector operator - ( const Vector v ) { return Vector( x - v.x, y - v.y ); }\n  Vector operator * ( const double k ) { return Vector( x * k, y * k ); }\n  Vector operator / ( const double k ) { return Vector( x / k, y / k ); }\n  bool operator < ( const Vector &v ) const { return x * x + y * y < v.x * v.x + v.y * v.y; }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  static double dot( Vector v1, Vector v2 ) { return v1.x * v2.x + v1.y * v2.y; }\n  static double cross( Vector v1, Vector v2 ) { return v1.x * v2.y - v1.y * v2.x; }\n};\n\nclass Intersection\n{\npublic:\n  Vector p0, p1, p2, p3;\n  Intersection(){}\n  Intersection( Vector p0, Vector p1, Vector p2, Vector p3 ) : p0(p0), p1(p1), p2(p2), p3(p3) {}\n  int solve();\n};\n\nint Intersection::solve()\n{\n  Vector p10 = p1 - p0;\n  Vector p20 = p2 - p0;\n  Vector p30 = p3 - p0;\n  Vector p32 = p3 - p2;\n  Vector p02 = p0 - p2;\n  Vector p12 = p1 - p2;\n  \n  double c0 = Vector::cross( p10, p20 );\n  double c1 = Vector::cross( p10, p30 );\n  double c2 = Vector::cross( p32, p02 );\n  double c3 = Vector::cross( p32, p12 );\n  \n  if ( c0 == 0 && c1 == 0 && c2 == 0 && c3 == 0 )\n    {\n      Vector p01 = p0 - p1;\n      Vector p21 = p2 - p1;\n      Vector p31 = p3 - p1;\n\n      if ( Vector::dot( p10, p20) < 0 && Vector::dot( p10, p30 ) )\n        cout << \"0\" << endl;\n      else if ( Vector::dot( p01, p21 ) < 0 && Vector::dot( p01, p31 ) < 0 )\n        cout << \"0\" << endl;\n      else\n        cout << \"1\" << endl;\n    }\n  else if ( c0 * c1 <= 0 && c2 * c3 <= 0 )\n    cout << \"1\" << endl;\n  else\n    cout << \"0\" << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int q;\n  cin >> q;\n\n  for ( auto i = 0; i < q; ++i )\n    {\n      double x0, y0, x1, y1, x2, y2, x3, y3;\n      cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n      Intersection s( Vector(x0, y0), Vector(x1, y1), Vector(x2, y2), Vector(x3, y3) );\n      s.solve();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr double eps = 1e-8;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\ntypedef struct _PT {\n  double x, y;\n  _PT() {}\n  _PT(long double x,long double y) : x(x), y(y) {} \n  _PT operator + (_PT p){\n     return _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n     return _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (long double d){\n     return _PT(d*x, d*y);\n  }\n\n  long double norm(void){\n    return sqrt(x*x + y*y);\n  }\n\n  long double twiceNorm(void){\n    return x*x + y*y;\n  }\n\n  long double dist(_PT p){ //pとの距離の2乗\n     return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n     return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n     return x == e.x? (y > e.y) : x > e.x;\n  }\n\n  long double dot(_PT p){ //pとの内積\n     return x * p.x + y * p.y;\n  }\n  \n  long double det(_PT p){ // (x,p)の外積\n     return x * p.y - p.x * y;\n  }\n}P;\n\nP intersection(P p1,P p2,P q1,P q2) { //線分 p1-p2とq1-q2の交点\n  \treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool on_seq(P p1,P p2,P q) { // 線分p1-p2上に点qがあるか\n    return (abs((p1 - q).det(p2 - q)) < eps) && ((p1 - q).dot(p2 - q) < eps);\n}\n\nint main(void) {\n\tlong N;\n\tcin >> N;\n\tREP(i,N) {\n\t\tP p1,p2,q1,q2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> q1.x >> q1.y >> q2.x >> q2.y;\n\t\tif (abs((p1-p2).det(q1-q2)) > eps) {\n\t\t\tP r = intersection(p1,p2,q1,q2);\n\t\t\tif (on_seq(p1,p2,r) && on_seq(q1,q2,r)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t\telse {\n\t\t\tif (on_seq(p1,p2,q1) || on_seq(p1,p2,q2) || on_seq(q1,q2,p1) || on_seq(q1,q2,p2)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<iomanip>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS 1e-9\n#define shosu(x) fixed<<setprecision(x)\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C{\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {//3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(L l, P p){//pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(L l, P p){//点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isOrthogonal(L l, L m){//2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isParallel(L l, L m){//2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(L l, L m){//2直線の交差判定\n  return !isParallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP inP(){\n  double x,y;\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1=inP();\n  P p2=inP();\n  L l(p1,p2);\n  return l;\n}\n\nint main(){\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    L l1,l2;\n    l1=inL();\n    l2=inL();\n\n    if(intersectSS(l1,l2)){\n      cout<<1<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\n\nclass Vec{\npublic:\n  double x, y;\n  Vec(double x = 0, double y = 0):x(x),y(y){}\n\n  void read(){\n    cin >> x >> y;\n  }\n  \n  Vec operator+(const Vec &other)\n  {\n    Vec result = *this;\n    result.x += other.x;\n    result.y += other.y;\n    return result;\n  }\n\n  Vec operator-(const Vec &other)\n  {\n    Vec result = *this;\n    result.x -= other.x;\n    result.y -= other.y;\n    return result;\n  }\n\n  Vec operator*(const float &k)\n  {\n    Vec result = *this;\n    result.x *= k;\n    result.y *= k;\n    return result;\n  }\n\n  Vec operator/(const float &k)\n  {\n    Vec result = *this;\n    result.x /= k;\n    result.y /= k;\n    return result;\n  } \n  \n  double cross(const Vec &other)\n  {\n    return x*other.y - y*other.x;\n  }\n\n  double dot(const Vec &other){\n    return x*other.x + y*other.y;\n  }\n  \n  bool operator==(const Vec &other) const\n  {\n    return abs(x - other.x) < EPS && abs(y - other.y) < EPS;\n  }\n\n  float norm()\n  {\n    return sqrt(x*x+y*y);\n  }\n\n  float norm2()\n  {\n    return x*x+y*y;\n  }\n\n  Vec standard(){\n    Vec result = *this;\n    return result/result.norm();\n  }\n};\n\n//ccw:1, cw:-1, other:0\nInt CCW(Vec a, Vec b, Vec c){\n  b = b - a;\n  c = c - a;\n  if(b.cross(c) > EPS)return -1;\n  if(b.cross(c) < -EPS)return 1;\n  return 0;\n}\n\n\n\nclass Line{\npublic:\n  Vec a, b;\n  Vec vect;\n  Line(Vec a = Vec(), Vec b = Vec()):a(a),b(b),vect(b-a){}\n\n  //projection\n  Vec proj(Vec p){\n    p = p - a;\n    return a + vect * vect.dot(p) / vect.norm2();\n  }\n\n  //reflection\n  Vec reflect(Vec p){\n    return proj(p) * 2 - p;\n  }\n\n  bool onSegment(Vec p){\n    return abs((p-a).cross(b-a)) < EPS && (p-a).dot(p-b) < EPS;\n  }\n\n  //other -> LineSegment(not inclusive), this -> Line\n  bool intersect(Line &other){\n    return CCW(a, b, other.a) * CCW(a, b, other.b) < 0;\n  }\n};\n\n\nint main(){\n  Int q;\n  cin >> q;\n  while(q--){\n    Vec p0, p1, p2, p3;\n    p0.read();\n    p1.read();\n    p2.read();\n    p3.read();\n    Line l1(p0, p1), l2(p2, p3);\n    if(l1.onSegment(p2) || l1.onSegment(p3) || l2.onSegment(p1) || l2.onSegment(p0) || l1.intersect(l2) && l2.intersect(l1))cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n    sizeは(int)とキャストしよう\n    cin.tie(0);\n    ios::sync_with_stdio(false);<- これら、printfとかと併用しない方が良さそう\n\n*/\n\nconst ll mod = 1e9+7;\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n\n// 線分 ab の偏角 返り値は[-π, π]\ndouble argument(const pair<double, double> &a, const pair<double, double> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n\nlong double const EPS = (1e-10);\nbool equal(long double const a, long double const b) { return fabs(a-b) < EPS; }\n\nstruct Point {\n    long double x, y;\n    Point(long double _x=0, long double _y=0) : x(_x), y(_y) {}\n\n    Point operator + (Point const & p) const { return Point{x + p.x, y + p.y}; }\n    Point & operator += (Point const & p) { x += p.x; y += p.y; return *this; }\n    Point operator - (Point const & p) const { return Point{x - p.x, y - p.y}; }\n    Point & operator -= (Point const & p) { x -= p.x; y -= p.y; return *this; }\n    Point operator * (long double a) const { return Point{a*x, a*y}; }\n    Point & operator *= (long double a) { x *= a; y *= a; return *this; }\n    Point operator / (long double a) const { return Point{x/a, y/a}; }\n\n    long double norm() { return x*x + y*y; }\n    long double abs() { return sqrt(norm()); }\n    \n    bool operator < (Point const & p) const { return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (Point const & p) const { return equal(x, p.x) && equal(y, p.y); }\n\n    void print() { cout << x << ' ' << y << \"\\n\"; }\n};\nusing Vector = Point;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point _p1, Point _p2)\n        : p1(_p1), p2(_p2) {}\n};\nusing Line = Segment;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point _c, double _r)\n        : c(_c), r(_r) {}\n};\nusing Polygon = vector<Point>;\n\n// 内積 外積 外積は大きさを返す\n// https://mathtrain.jp/gaiseki\nlong double dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\nlong double cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n// ベクトルの直交判定　平行判定\nbool isOrthogonal(Vector const & a, Vector const & b) { return equal(dot(a, b), 0.0); }\nbool isOrthogonal(Point const & a1, Point const & a2, Point const & b1, Point const & b2) { return isOrthogonal(a1-a2, b1-b2); }\nbool isOrthogonal(Segment const & s1, Segment const & s2) { return isOrthogonal(s1.p1 - s1.p2, s2.p1 - s2.p2); }\nbool isParallel(Vector const & a, Vector const & b) { return equal(cross(a, b), 0); }\nbool isParallel(Point const & a1, Point const & a2, Point const & b1, Point const & b2) { return isParallel(a1-a2, b1-b2); }\nbool isParallel(Segment const & s1, Segment const & s2) { return isParallel(s1.p1-s1.p2, s2.p1-s2.p2); }\n\n// 線分 s に対する点 p の射影\nPoint project(Segment const & s, Point const & p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n// 線分 s を対称軸とした点 p の線対称点\nPoint reflect(Segment const & s, Point const & p) { return p + (project(s, p) - p) * 2.0; }\n\n// 線分p0-p1 に対して線分 p0-p2 が反時計回りなのか直線上なのか線分上なのか...\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2-p0-p1\nstatic const int ONLINE_FRONT = -2; // p0-p1-p2\nstatic const int ON_SEGMENT = 0;    // p0-p2-p1\nint ccw(Point const & p0, Point const & p1, Point const & p2){\n    Vector a = p1 - p0, b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// 線分 p1-p2 と線分 p3-p4 の交差判定（交点を持てば true）\nbool intersect(Point const & p1, Point const & p2, Point const & p3, Point const & p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment const & s1, Segment const & s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点と直線の距離\nlong double getDistanceLP(Line const & l, Point const & p) {\n    return abs(cross(l.p2-l.p1, p-l.p1) / (l.p2-l.p1).abs());\n}\n\n// 点と線分の距離\nlong double getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2-s.p1, p-s.p1) < 0.0) return (p-s.p1).abs();\n    if (dot(s.p1-s.p2, p-s.p2) < 0.0) return (p-s.p2).abs();\n    return getDistanceLP(s, p);\n}\n\n// 線分と線分の距離\nlong double getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int q; cin >> q;\n    while(q--) {\n        int a, b, c, d, e, f, g, h; cin >> a >> b >> c >> d >> e >> f >> g >> h;\n        Point p1(a, b), p2(c, d), p3(e, f), p4(g, h);\n        cout << intersect(p1, p2, p3, p4) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nint main() {\n    int n;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> n;\n    while (n--)\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >>y3;\n        Point z1(x1 - x0, y1 - y0); \n        Point z2(x2 - x0, y2 - y0);\n        Point z3(x3 - x0, y3 - y0);\n        Point w1 = z3 - z2;\n        Point w2 = -z2;\n        Point w3 = z1 - z2;\n        if ((z2 * conj(z1)).imag() * (z3 * conj(z1)).imag() > 0\n            || (w2 * conj(w1)).imag() * (w3 * conj(w1)).imag() > 0)\n            cout << \"0\\n\";\n        else cout << \"1\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define EPS  (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\n// 点类\nclass Point {\npublic :\n\tdouble x, y;\n\tPoint() {};\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n// 线段类\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() {};\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {};\n};\n// 圆类\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle() {};\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n// 定义向量\ntypedef Point Vector;\n// 定义直线\ntypedef Segment Line;\n// 定义多边形\ntypedef vector<Point> Polygon;\n\n/***************************点、向量****************************/\n\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\n// 向量的内积\ndouble dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 向量的外积\ndouble cross(Point a, Point b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 向量a，b是否正交 <==> 内积为0\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n// 向量a，b是否平行 <==> 外积为0\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn equals(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// 点p在线段s上的投影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r ;\n}\n\n//以线段s为对称轴与点p成线对称的点\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n// 点a到点b的距离\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n// 线段l和点p的距离\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1) );\n}\n\n// 线段s与点p的距离\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n\n\n/*************************线段********************************/\n// 线段s1，s2是否正交 <==> 内积为0\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 线段s1，s2是否平行 <==> 外积为0\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// 逆时针方向ccw（Counter-Clockwise）\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// 判断线段p1p2和线段p3p4是否相交\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//判断线段s1和s2是否相交\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 线段s1和线段s2的距离\ndouble getDistance(Segment s1, Segment s2) {\n\t// 相交\n\tif (intersect(s1, s2))\n\t\treturn 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 线段s1与线段s2的交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/***************************圆****************************/\n\n// 圆c和直线l的交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n// 圆c1和圆c2的交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/***************************多边形****************************/\n// 点的内包\n/*\n\tIN 2\n\tON 1\n\tOUT 0\n*/\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)\n\t\t\tx = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n// 凸包\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tint len = s.size();\n\tif (len < 3) return s;\n\t// 以x，y为基准升序排序\n\tsort(s.begin(), s.end());\n\t// 将x值最小的两个点添加到u\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\n\t// 将x值最大的两个点添加到l\n\tl.push_back(s[len - 1]);\n\tl.push_back(s[len - 2]);\n\n\t// 构建凸包上部\n\tfor (int i = 2; i < len; i++) {\n\t\tfor (int j = u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], s[i]) != CLOCKWISE; j--)\n\t\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\n\t// 构建凸包下部\n\tfor (int i = len - 3; i >= 0; i--) {\n\t\tfor (int j = l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], s[i]) != CLOCKWISE; j--)\n\t\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\n\t// 按顺时针方向生成凸包的点的序列\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)\n\t\tl.push_back(u[i]);\n\n\treturn l;\n}\n\n\nint main() {\n\tSegment s1, s2;\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &s1.p1.x, &s1.p1.y,\n\t\t\t&s1.p2.x, &s1.p2.y, &s2.p1.x, &s2.p1.y,\n\t\t\t&s2.p2.x, &s2.p2.y);\n\t\tprintf(\"%d\\n\", intersect(s1, s2) ? 1 : 0);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef int scalar;\n\nclass point{\n\tpublic:\n\tscalar x,y;\n\tvoid input(void){\n\t\tcin >> x >> y;\n\t}\n\tvoid print(void){\n\t\tcout << x << \" \" << y;\n\t}\n\tpoint(scalar ax=0, scalar ay=0): x(ax), y(ay){};\n\tpoint operator =(point a){\n\t\tx = a.x;\n\t\ty = a.y;\n\t\treturn *this;\n\t}\n\tpoint operator +(point a){return point(x+a.x, y+a.y);}\n\tpoint operator -(point a){return point(x-a.x, y-a.y);}\n\t\n};\n\nint cross(point p, point q, point r, point s){\n\tpoint a,b,c;\n\tscalar det;\n\tscalar inv1,inv2,inv3,inv4;\n\tscalar t,tau;\n\ta = q - p;\n\tb = r - s;\n\tc = r - p;\n\tdet = a.x * b.y - b.x * a.y;\n\tif(det == 0)return 0;//??????????????????????????§????????´???????????????????????????????????????\n\telse{\n\t\tinv1 = b.y;\n\t\tinv2 = -b.x;\n\t\tinv3 = -a.y;\n\t\tinv4 = a.x;\n\t\tt   = inv1 * c.x + inv2 * c.y;\n\t\ttau = inv3 * c.x + inv4 * c.y;\n\t\tif(det < 0){\n\t\t\tif(det <= t && t <= 0 && det <= tau && tau <= 0)return 1;\n\t\t}else{\n\t\t\tif(0 <= t && t <= det && 0 <= tau && tau <= det)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint q;\n\tpoint p0, p1, p2, p3;\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tp0.input();\n\t\tp1.input();\n\t\tp2.input();\n\t\tp3.input();\n\t\tcout << cross(p0, p1, p2,p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<float.h>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) fabs((a)-(b))<DBL_EPSILON*fmax(1,fmax(fabs(a),fabs(b)))\n//点のクラス\nclass Point{\n    public:\n        double x,y;\n        Point(double x=0,double y=0):x(x),y(y){}\n\n        Point operator + (Point p){return Point(x+p.x,y+p.y);}\n        Point operator - (Point p){return Point(x-p.x,y-p.y);}\n        Point operator * (double a){return Point(a*x,a*y);}\n        Point operator / (double a){return Point(x/a,y/a);}\n\n        double norm(){return x*x+y*y;}\n        double abs(){return sqrt(norm());}    \n\n        bool operator < (const Point &p)const{\n            return x!=p.x?x<p.x:y<p.y;\n        }\n        bool operator == (const Point &p)const{\n            return equals(x,p.x)&&equals(y,p.y);\n        }\n};\ntypedef Point Vector;\nstruct Segment{ Point p1,p2; };\ntypedef Segment Line;\n//内積\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\n//外戚\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n//ベクトルa,bの位置関係\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;//p0,p1,p2が反時計回り\n    if(cross(a,b)<-EPS) return -1;//p0,p1,p2が時計回り\n    if(dot(a,b)<-EPS) return 2;//p1,p0,p2の順で一直線\n    if(a.norm()<b.norm()) return -2;//p0,p1,p2の順で一直線\n    return 0; //p0,p2,p1の順で一直線\n}\n//交差判定　p389\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);//p1,p2,p3,p4の順で一直線になるのを除く\n}\nint main(){\n    int q;\n    cin>>q;\n    Point p[4];\n    for(int i=0;i<q;i++){\n        cin>>p[0].x>>p[0].y>>p[1].x>>p[1].y;\n        cin>>p[2].x>>p[2].y>>p[3].x>>p[3].y;\n        if(intersect(p[0],p[1],p[2],p[3]))cout<<1<<\"\\n\";\n        else cout<<0<<\"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define o(x) cerr << #x << \" \" << x << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293);\t// さん\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\nstruct Point{ ll x,y; };\nil Point operator+( const Point &a , const Point &b ){ return {a.x+b.x,a.y+b.y}; }\nil Point operator-( const Point &a , const Point &b ){ return {a.x-b.x,a.y-b.y}; }\nil ll operator^( const Point &a , const Point &b ){ return a.x*b.x + a.y*b.y; }\nil ll operator*( const Point &a , const Point &b ){ return a.x*b.y - b.x*a.y; }\nil bool operator==( const Point &a , const Point &b ){ return a.x == b.x and a.y == b.y; }\n\nil bool OnLine( const Point &a , const Point &b , const Point &c ){\n\tPoint ab = b-a, ac = c-a;\n\tif( ab*ac != 0 ) return 0;\n\tif( (ab^ac) < 0 ) return 0;\n\tif( abs(ab.y*ab.y+ab.x*ab.x) > abs(ac.y*ac.y+ac.x*ac.x) ) return 0;\n\t// cout << a.x << \" \" << a.y << \"  \" << b.x << \" \" << b.y << \"  \" << c.x << \" \" << c.y << endl;\n\treturn 1;\n}\n\nbool Ins( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif( p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 ) return 1;\n\tif( OnLine(p1,p3,p2) or OnLine(p1,p4,p2) or OnLine(p3,p1,p4) or OnLine(p3,p2,p4) ) return 1;\n\tif( ((p2-p1)*(p3-p1)<0) == ((p2-p1)*(p4-p1)<0) ) return 0;\n\tif( ((p4-p3)*(p1-p3)<0) == ((p4-p3)*(p2-p3)<0) ) return 0;\n\treturn 1;\n}\n\nint main(){\n\tFILEIO();\n\n\tiRead(T);\n\tFor(Ti,T){\n\t\tiRead4(x1,y1,x2,y2);\n\t\tiRead4(x3,y3,x4,y4);\n\t\tPoint p1{x1,y1}, p2{x2,y2}, p3{x3,y3}, p4{x4,y4};\n\t\tint ans = Ins(p1,p2,p3,p4);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\tEND();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ninline db sqr(db x) { return x * x; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(FAC), y(FAC) {}\n\n    Point(db _x, db _y) : x(_x + FAC), y(_y + FAC) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n\n    Point rotac() { return Point(-y, x); }\n    Point rotcl() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    void read() { cin >> x >> y; }\n    void write() { cout << '(' << x << \", \" << y << \")\\n\"; }\n};\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    // 1 -> On Counter-clockwise\n    // 2 -> On Clockwise\n    // 3 -> On Line BUT MAY NOT ON THE SEGMENT!\n    int relation(Point p)\n    {\n        int c = sgn((p - s) ^ (e - s));\n        if (c < 0)\n            return 1;\n        else if (c > 0)\n            return 2;\n        return 3;\n    }\n\n    bool checkOn(Point p) { return relation(p) == 3 && sgn((p - s) ^ (p - e)) <= 0; }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Formal Intersection\n    // 1 -> Informal\n    // 2 -> Not Intersect\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Formal Intersection\n    // 1 -> Informal\n    // 2 -> Not Intersect\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point crossP(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void write()\n    {\n        cout << \"Line:\\n\";\n        s.write();\n        e.write();\n    }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        Line l1, l2;\n        l1.read();\n        l2.read();\n        if (l1.crossSS(l2))\n            cout << \"1\\n\";\n        else\n            cout << \"0\\n\";\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\ndouble sgn(double d) {\n  if (dcmp(d))\n    return 0;\n  if (d > 0)\n    return 1;\n  return -1;\n}\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 (c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) { return dcmp(a * p.x + b * p.y + c); }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() { return line(p1, p2); }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    return ok;\n  }\n  bool intersect(segment s) {\n    vec v0 = p2 - p1;\n    vec v1 = s.p2 - s.p1;\n    if (v0.parallel(v1)) {\n      return contains(s.p1) || contains(s.p2);\n    }\n    point a = p1, b = p2, c = s.p1, d = s.p2;\n    return sgn((a - b).cross(b - c)) != sgn((a - b).cross(b - d)) &&\n           sgn((c - d).cross(d - a)) != sgn((c - d).cross(d - b));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1);\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma warning(disable : 4267) // \"int n = (unsigned)size\"\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nstruct pt_t {\n\tdouble x, y;\n\tpt_t operator+(const pt_t &p) { return { x + p.x, y + p.y }; }\n\tpt_t operator-(const pt_t &p) { return { x - p.x, y - p.y }; }\n\tpt_t operator*(const double &c) { return { x * c, y * c }; }\n};\n\n// ax + by + c = 0\nstruct line_t {\n\tdouble a, b, c;\n};\n\npt_t cross_point(line_t l, line_t m) {\n\tpt_t ret = { INFD, INFD };\n\tdouble d = l.a * m.b - m.a * l.b;\n\tif (nearlyeq(d, 0)) return ret;\n\tdouble x = l.b * m.c - m.b * l.c;\n\tdouble y = l.a * m.c - m.a * l.c;\n\tret = { x / d, y / -d };\n\treturn ret;\n}\n\n// normal vector = (a, b), passing p\nline_t solve_line(double a, double b, pt_t p) {\n\treturn { a, b, -a * p.x - b * p.y };\n}\n\n// t should be radius\npt_t rot(pt_t p, double r) {\n\treturn {\n\t\tcos(r) * p.x - sin(r) * p.y,\n\t\tsin(r) * p.x + cos(r) * p.y\n\t};\n}\n\ndouble abs(pt_t p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\n// angle [0, 2PI) of vector p to vector q\ndouble angle(pt_t p, pt_t q) {\n\tp = p * (1.0 / abs(p));\n\tq = q * (1.0 / abs(q));\n\tdouble r0 = acos(max(min(p.x * q.x + p.y * q.y, 1.0), -1.0));\n\tdouble r1 = asin(max(min(p.x * q.y - p.y * q.x, 1.0), -1.0));\n\tif (r1 >= 0) return r0;\n\telse return 2 * M_PI - r0;\n}\n\ndouble dist(line_t l, pt_t p) {\n\treturn abs(l.a * p.x + l.b * p.y + l.c)\n\t\t/ sqrt(l.a * l.a + l.b * l.b);\n}\n\nbool on_same_line(pt_t p, pt_t q) {\n\tline_t l = solve_line(p.y, -p.x, p);\n\tif (dist(l, q) < eps) return true;\n\telse return false;\n}\n\ndouble in_segment(pt_t s, pt_t t, pt_t p) {\n\tif (on_same_line) {\n\t\tif (abs(p - s) > abs(t - s) + eps) return false;\n\t\tif (abs(p - t) > abs(t - s) + eps) return false;\n\t\treturn true;\n\t}\n\telse return false;\n}\n\nint main() {\n\tint qr; cin >> qr;\n\tLoop(i, qr) {\n\t\tpt_t p[4];\n\t\tLoop(j, 4) {\n\t\t\tcin >> p[j].x >> p[j].y;\n\t\t}\n\t\tline_t l = solve_line(p[1].y - p[0].y, p[0].x - p[1].x, p[0]);\n\t\tline_t m = solve_line(p[3].y - p[2].y, p[2].x - p[3].x, p[2]);\n\t\tpt_t q = cross_point(l, m);\n\t\tif (in_segment(p[0], p[1], q)) {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma warning(disable : 4267) // \"int n = (unsigned)size\"\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nstruct pt_t {\n\tdouble x, y;\n\tpt_t operator+(const pt_t &p) { return { x + p.x, y + p.y }; }\n\tpt_t operator-(const pt_t &p) { return { x - p.x, y - p.y }; }\n\tpt_t operator*(const double &c) { return { x * c, y * c }; }\n};\n\n// ax + by + c = 0\nstruct line_t {\n\tdouble a, b, c;\n};\n\npt_t cross_point(line_t l, line_t m) {\n\tpt_t ret = { INFD, INFD };\n\tdouble d = l.a * m.b - m.a * l.b;\n\tif (nearlyeq(d, 0)) return ret;\n\tdouble x = l.b * m.c - m.b * l.c;\n\tdouble y = l.a * m.c - m.a * l.c;\n\tret = { x / d, y / -d };\n\treturn ret;\n}\n\n// normal vector = (a, b), passing p\nline_t solve_line(double a, double b, pt_t p) {\n\treturn { a, b, -a * p.x - b * p.y };\n}\n\n// t should be radius\npt_t rot(pt_t p, double r) {\n\treturn {\n\t\tcos(r) * p.x - sin(r) * p.y,\n\t\tsin(r) * p.x + cos(r) * p.y\n\t};\n}\n\ndouble abs(pt_t p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\n// angle [0, 2PI) of vector p to vector q\ndouble angle(pt_t p, pt_t q) {\n\tp = p * (1.0 / abs(p));\n\tq = q * (1.0 / abs(q));\n\tdouble r0 = acos(max(min(p.x * q.x + p.y * q.y, 1.0), -1.0));\n\tdouble r1 = asin(max(min(p.x * q.y - p.y * q.x, 1.0), -1.0));\n\tif (r1 >= 0) return r0;\n\telse return 2 * M_PI - r0;\n}\n\ndouble dist(line_t l, pt_t p) {\n\treturn abs(l.a * p.x + l.b * p.y + l.c)\n\t\t/ sqrt(l.a * l.a + l.b * l.b);\n}\n\nbool on_same_line(pt_t p, pt_t q) {\n\tline_t l = solve_line(p.y, -p.x, p);\n\tif (dist(l, q) < eps) return true;\n\telse return false;\n}\n\ndouble in_segment(pt_t s, pt_t t, pt_t p) {\n\tif (on_same_line) {\n\t\tif (abs(p - s) > abs(t - s) + eps) return false;\n\t\tif (abs(p - t) > abs(t - s) + eps) return false;\n\t\treturn true;\n\t}\n\telse return false;\n}\n\nint main() {\n\tint qr; cin >> qr;\n\tLoop(i, qr) {\n\t\tpt_t p[4];\n\t\tLoop(j, 4) {\n\t\t\tcin >> p[j].x >> p[j].y;\n\t\t}\n\t\tline_t l = solve_line(p[1].y - p[0].y, p[0].x - p[1].x, p[0]);\n\t\tline_t m = solve_line(p[3].y - p[2].y, p[2].x - p[3].x, p[2]);\n\t\tpt_t q = cross_point(l, m);\n\t\tif (in_segment(p[0], p[1], q) && in_segment(p[2], p[3], q)) {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n\nusing namespace std;\n\nconst double eps = 1e-10;\ntypedef complex<double> Point;\n\ninline double cross(const Point& a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ninline double dot(const Point& a, const Point& b){\n    return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps) return  1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)     return  2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(const Point& a, const Point& b):vector<Point>{a, b}{}\n};\n\ninline bool interSS(const Line& s, const Line& t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    while(q--){\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Line l(Point(x0, y0), Point(x1, y1)), m(Point(x2, y2), Point(x3, y3));\n        cout << (interSS(l, m)? 1: 0) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long unsigned int ll;\n\n// 参考サイト\n// 前原 貴憲\n// http://www.prefield.com/algorithm/index.html\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> Point; //複素数で平面定義\ntypedef Point P;\n\n// system // {{{\n// オペレーター< を定義、後々楽\nnamespace std{\n    bool operator < ( const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 外積\ndouble cross( const P& a, const P& b ){\n    return imag(conj(a)*b);\n}\n// 内積\ndouble dot( const P& a, const P& b ){\n    return real(conj(a)*b);\n}\n// }}}\n// Line L vector<P> PolyGon G vector<P> Circle C(P,int rad) // {{{\n// 直線 Line\n// 線分 Segment\nstruct L : public vector<P> {\n    L(const P &a, const P &b ){\n        push_back(a); push_back(b);\n    }\n};\n\n// 単純多角形 PolyGon\ntypedef vector<P> G;\n\n// 円 cirlce\nstruct C {\n    P p; double r;\n    C(const P &p, double r ) : p(p), r(r) {}\n};\n// }}}\n// counter clockwise // {{{\n//\nint ccw( P a, P b, P c ){\n    b -= a; c -= a;\n    if( cross(b,c) > 0 )   return +1; //counter clockwise\n    if( cross(b,c) < 0 )   return -1; //clockwise\n    if( dot(b,c) < 0 )     return +2; //online_back\n    if( norm(b) < norm(c)) return -2; //online_front\n    return 0; // on_segment\n} //}}}\n// 交点判定 LSPtoLSP // {{{\nbool intersectLL( const L &l, const L &m ){\n    return abs( cross(l[1]-l[0], m[1]-m[0]) ) > EPS || // cross(l,m) != 0 <-> not paralell\n           abs( cross(l[1]-l[0], m[0]-l[0]) ) < EPS;   // cross(l,(m-l)) == 0 <-> same line\n}\nbool intersectLS( const L &l, const L &s ){\n    return cross( l[1]-l[0], s[0]-l[0] ) *\n           cross( l[1]-l[0], s[1]-l[0] ) < EPS;\n}\nbool intersectLP( const L &l, const P &p ){\n    return abs( cross(l[0]-p, l[1]-p) );\n}\nbool intersectSS( const L &s, const L &t ){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( const L &s, const P &p ){\n    return abs( s[0]-p )+abs( s[1]-p )-abs(s[1]-s[0]) < EPS;\n}\n// }}}\n// 射影 反射 距離 LSPtoLSP // {{{\nP projection( const L &l, const P &p ){\n    double t = dot( p-l[0], l[0]-l[1] ) / norm( l[0]-l[1] );\n    return l[0] + t*(l[0]-l[1]);\n}\nP reflection( const L &l, const P &p ){\n    return p + 2.0*( projection(l,p) - p );\n}\n// bool intersectLL( const L &l, const L &m ){\n//     return abs( cross(l[1]-l[0], m[1]-m[0]) ) > EPS || // cross(l,m) != 0 <-> not paralell\n//            abs( cross(l[1]-l[0], m[0]-l[0]) ) < EPS;   // cross(l,(m-l)) == 0 <-> same line\n// }\n// bool intersectLS( const L &l, const L &s ){\n//     return cross( l[1]-l[0], s[0]-l[0] ) *\n//            cross( l[1]-l[0], s[1]-l[0] ) < EPS;\n// }\n// bool intersectLP( const L &l, const P &p ){\n//     return abs( cross(l[0]-p, l[1]-p) );\n// }\n// bool intersectSS( const L &s, const L &t ){\n//     return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n//            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n// }\n// bool intersectSP( const L &s, const P &p ){\n//     return abs( s[0]-p )+abs( s[1]-p )-abs(s[1]-s[0]) < EPS;\n// }\n// }}}\n// imagePointDescription(点表示) // {{{ \nvoid imagePointDescription( const vector<P> &p ){\n    int here[51][51] = {};\n    int i = 0;\n    for( P t : p ){\n        i++;\n        int y = round(imag(t)-EPS);\n        int x = round(real(t)-EPS);\n        if( abs(y) > 25 ) continue;\n        if( abs(x) > 25 ) continue;\n        here[y+25][x+25] = i;\n    }\n\n    for( i = 50; i >= 0; i-- ){\n        for( int j = 0; j <= 50; j++ ){\n            if( here[i][j] ) printf (\"%2d\", here[i][j] );\n            else if( i == 25 && j == 25 ) printf (\"-+\");\n            else if( i == 25 ) printf (\"--\");\n            else if( j == 25 ) printf (\" |\");\n            else if( j % 5 == 0 && i % 5 == 0)printf (\" .\");\n            else printf (\"  \");\n        }\n        printf (\"\\n\");\n    }\n\n} // }}}\n\nint main() {\n\n    double a,b,c,d;\n    G points(4);\n\n\n    int q;\n    cin >> q;\n\n    while(q--){\n        cin >> a >> b >> c >> d;\n        P p1(a,b);\n        P p2(c,d);\n        cin >> a >> b >> c >> d;\n        P p3(a,b);\n        P p4(c,d);\n        L l1(p1,p2);\n        L l2(p3,p4);\n        points[0] = p1;\n        points[1] = p2;\n        points[2] = p3;\n        points[3] = p4;\n        // imagePointDescription(points);\n        printf (\"%d\\n\", intersectSS(l1,l2) );\n        // printf (\"%1.10lf %1.10lf\\n\", real(x), imag(x) );\n    }\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define INF (1 << 29)\n#define LLINF (1LL << 61)\n#define MOD7 1000000007\n#define MOD9 1000000009\n#define EPS 1e-9\n#define P pair<int, int>\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pul pair<ull, ull>\n#define all(a) (a).begin(), (a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n#define TO_STRING(VariableName) # VariableName\n\nvoid YES() { cout << \"YES\" << endl; }\nvoid NO() { cout << \"NO\" << endl; }\nvoid Yes() { cout << \"Yes\" << endl; }\nvoid No() { cout << \"No\" << endl; }\nvoid yes() { cout << \"yes\" << endl; }\nvoid no() { cout << \"no\" << endl; }\n\nclass Point;\nclass Segment;\nclass Circle;\n\nusing Vector = Point;\nusing Line = Segment;\nusing Polygon = vector<Point>;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double k) { return Point(x * k, y * k); }\n\tPoint operator/(double k) { return Point(x / k, y / k); }\n\n\tbool operator<(const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator==(const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n\tfriend istream& operator>>(istream& stream, Point& p) {\n\t\tdouble x, y;\n\t\tstream >> x >> y;\n\t\tp.x = x;\n\t\tp.y = y;\n\t\treturn stream;\n\t}\n\n\tfriend ostream& operator<<(ostream& stream, const Point& p) {\n\t\tstream << fixed << setprecision(10) << p.x << \" \" << p.y;\n\t\treturn stream;\n\t}\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tdouble dot(Vector v) {\n\t\treturn x * v.x + y * v.y;\n\t}\n\n\tdouble cross(Vector v) {\n\t\treturn x * v.y - y * v.x;\n\t}\n};\n\n#define CLOCKWISE 1\n#define COUNTER_CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\t\n\tfriend istream& operator>>(istream& stream, Segment& s) {\n\t\tPoint p1, p2;\n\t\tstream >> p1 >> p2;\n\t\ts.p1 = p1;\n\t\ts.p2 = p2;\n\t\treturn stream;\n\t}\n\n\tfriend ostream& operator<<(ostream& stream, const Segment& s) {\n\t\tstream << fixed << setprecision(10) << s.p1.x << \" \" << s.p1.y << \" \";\n\t\tstream << fixed << setprecision(10) << s.p2.x << \" \" << s.p2.y;\n\t\treturn stream;\n\t}\n\n\tPoint project(Point p) {\n\t\tPoint base = p2 - p1;\n\t\tdouble r = (p - p1).dot(base) / base.norm();\n\t\treturn p1 + base * r;\n\t}\n\n\tPoint refrect(Point p) {\n\t\treturn p + (project(p) - p) * 2;\n\t}\n\n\tint ccw(Point p) {\n\t\tVector a = p2 - p1;\n\t\tVector b = p - p1;\n\t\tif (a.cross(b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (a.cross(b) < -EPS) return CLOCKWISE;\n\t\tif (a.dot(b) < -EPS) return ONLINE_BACK;\n\t\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\n\tbool orthogonal(Segment s) {\n\t\treturn fabs((p2 - p1).dot(s.p2 - s.p1)) < EPS;\n\t}\n\n\tbool parallel(Segment s) {\n\t\treturn fabs((p2 - p1).cross(s.p2 - s.p1)) < EPS;\n\t}\n\n\tbool intersect(Segment s) {\n\t\treturn ccw(s.p1) * ccw(s.p2) <= 0 && s.ccw(p1) * s.ccw(p2) <= 0;\n\t}\n};\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) : c(c), r(r) {}\n};\n\nint main() {\n\tSegment s1, s2;\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> s1 >> s2;\n\t\tcout << s1.intersect(s2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<utility>\nusing namespace std;\nconst double eps = 1e-10;\ntypedef complex<double> Point;\ntypedef Point Vector;\npair <Point,Point> Line1,Line2;\n\ndouble dot(Point& a,Point& b)\n{\n    return real(conj(a)*b);\n}\n\ndouble cross(Point& a, Point& b)\n{\n    return imag(conj(a)*b);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if (cross(t1, t2) > 0)   return +1;       // counter clockwise\n    if (cross(t1, t2) < 0)   return -1;       // clockwise\n    if (dot(t1, t2) < 0)     return +2;       // c--a--b on line\n    if (norm(t1) < norm(t2)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool isintersaction(pair <Point,Point> a, pair <Point,Point> b)\n{\n    return (ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0 && ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0);\n}\n\nint main()\n{\n    int vol;\n    scanf(\"%d\",&vol);\n    while(vol--)\n    {\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        scanf(\"%d%d%d%d%d%d%d%d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n        Line1 = make_pair(Point(x0, y0), Point(x1, y1)), Line2 = make_pair(Point(x2, y2), Point(x3, y3));\n        printf(\"%d\\n\",isintersaction(Line1, Line2));\n    }\n    return 0;\n}\n/*\n\n1\n0 0 5 0 1 0 1 2\n\n*/\n/*\n\n00.00 sec    1056 KB    71 lines     1960 bytes    2013-07-31 16:54\n#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nint main(){\n\tint T,x1,y1,x2,y2;\n\tfor(scanf(\"%d\",&T);T--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL A(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL B(P(x1,y1),P(x2,y2));\n\t\tprintf(\"%d\\n\",intersectSS(A,B));\n\t}\n}\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\ntypedef struct _PT {\n  double x, y;\n  _PT() {}\n  _PT(double x, double y) : x(x), y(y) {} \n  _PT operator + (_PT p){\n     return _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n     return _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (double d){\n     return _PT(d*x, d*y);\n  }\n\n  double norm(void){\n    return sqrt(x*x + y*y);\n  }\n\n  double twiceNorm(void){\n    return x*x + y*y;\n  }\n\n  double dist(_PT p){ //pとの距離の2乗\n     return (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n     return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n     return x == e.x? (y > e.y) : x > e.x;\n  }\n\n  double dot(_PT p){ //pとの内積\n     return x * p.x + y * p.y;\n  }\n  \n  double det(_PT p){ // (x,p)の外積\n     return x * p.y - p.x * y;\n  }\n}P;\n\nP intersection(P p1,P p2,P q1,P q2) { //線分 p1-p2とq1-q2の交点\n  \treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool on_seq(P p1,P p2,P q) { // 線分p1-p2上に点qがあるか\n    return (abs((p1 - q).det(p2 - q)) < eps) && ((p1 - q).dot(p2 - q) < eps);\n}\n\nint main(void) {\n\tlong N;\n\tcin >> N;\n\tREP(i,N) {\n\t\tP p1,p2,q1,q2;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> q1.x >> q1.y >> q2.x >> q2.y;\n\t\tif (abs((p1-p2).det(q1-q2)) > eps) {\n\t\t\tP r = intersection(p1,p2,q1,q2);\n\t\t\tif (on_seq(p1,p2,r) && on_seq(q1,q2,r)) cout << \"1\" << endl;\n\t\t\telse cout << \"0\" << endl;\n\t\t}\n\t\telse cout << \"0\" << endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equal(x,y)  (fabs(x-y)<EPS)\nenum Status{\n\tCOUNTER_CLOCKWISE=1,CLOCKWISE=-1,ONLINE_BACK=2,ONLINE_FRONT=-2,ON_SEGMENT=0\n};\nstruct Point{\n\tdouble x,y;\n\tPoint(double _x,double _y): x(_x),y(_y){ }\n\tPoint operator+(const Point & p){\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator-(const Point & p){\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator*(double k){\n\t\treturn Point(k*x,k*y);\n\t}\n};\ntypedef Point Vector;\ndouble dot(const Vector &v1,const Vector & v2 ){\n\treturn v1.x*v2.x+v1.y*v2.y;\n}\ndouble cross(const Vector &v1,const Vector & v2){\n\treturn v1.x*v2.y-v1.y*v2.x;\n}\ndouble norm(const Vector & v){\n\treturn dot(v,v);\n}\ndouble abs(const Vector & v){\n\treturn sqrt(norm(v));\n}\nint ccw( Point p1, Point p2,  Point p3){\n\tVector v1=p2-p1,v2=p3-p1;\n\tif(cross(v1,v2)<-EPS) return CLOCKWISE;\n\tif(cross(v1,v2)>EPS) return COUNTER_CLOCKWISE;\n\tif(dot(v1,v2)<-EPS) return ONLINE_BACK;\n\tif(norm(v1)<norm(v2)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n\t\t\t\tccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nint main(){\n\tdouble x[4],y[4];\n\tint q;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];\n\t\tcin>>x[2]>>y[2]>>x[3]>>y[3];\n\t\tcout<< intersect(Point(x[0],y[0]),Point(x[1],y[1]),Point(x[2],y[2]),Point (x[3],y[3])) <<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\nconstexpr auto INF = 2147483647;\nstatic const double EPS = pow(10,-10);\ntypedef long long ll;\nstatic int COUNTER_CLOCKWISE = 1;\nstatic int CLOCKWISE = -1;\nstatic int ONLINE_BACK = 2;\nstatic int ONLINE_FRONT = -2;\nstatic int ON_SEGMENT = 0;\n\n\n\n\nclass Vector2{\n  public:\n  double x, y;\n  Vector2(){}\n  Vector2(double x, double y): x(x), y(y) {}\n\n  Vector2 operator + (Vector2 v) {\n    return Vector2(x + v.x , y + v.y);\n  }\n  Vector2 operator - (Vector2 v) {\n    return Vector2(x - v.x , y - v.y);\n  }\n\n  Vector2 operator * (double d){\n    return Vector2(d*x, d*y);\n  }\n\n  double norm(){\n    return pow(x,2) + pow(y,2);\n  }\n\n};\n\ndouble dot(Vector2 a, Vector2 b){\n  return a.x * b.x + a.y * b.y; \n}\n\ndouble cross(Vector2 a, Vector2 b){\n  return a.x * b.y - a.y*b.x;\n}\n\nVector2 projection(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 base = b - a;\n  Vector2 hypo = p - a;\n  double norm_base = pow(base.x,2) + pow(base.y,2);\n\n  Vector2 x;\n  x = a + base*(dot(hypo,base) / norm_base);\n  return x;\n}\n\nVector2 refrection(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 v, p_projection;\n  p_projection = projection(a,b,p); \n  v = p_projection + (p_projection - p);\n  return v;\n}\n\nint ccw(Vector2 a, Vector2 b, Vector2 p){\n  Vector2 hypo = p - a;\n  Vector2 base = b - a;\n  if(cross(base,hypo) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(base,hypo) < -EPS) return CLOCKWISE;\n  if(dot(base,hypo) < -EPS) return ONLINE_BACK;\n  if(hypo.norm() > base.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Vector2 a,Vector2 b,Vector2 p,Vector2 q){\n  int t1, t2;\n  t1 =ccw(a,b,p)*ccw(a,b,q);\n  t2 =ccw(p,q,a)*ccw(p,q,b);\n  if(t1 <= 0 && t2 <= 0) return true;\n  else return false;\n}\n\n\n\n\nint main(){\n  Vector2 a,b,p,q;\n  int queri;\n  cin >> queri;\n  rep(i,queri){\n    cin >> a.x >> a.y >> b.x >> b.y;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    if(intersect(a,b,p,q)) cout <<  1;\n    else cout << 0;\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>eps) return 1;\n\t\tif(Getmp<-eps) return 2;\n\t\tif(IP(Ge1,Ge2)<eps) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tif(four_JUD(Gex.first,Gex.second,Gey.first,Gey.second)){\n\t\t\tint Ge1=PJUD(Gex.first,Gey.first,Gex.second),Ge2=PJUD(Gex.first,Gey.second,Gex.second),Ge3=PJUD(Gey.first,Gex.first,Gey.second),Ge4=PJUD(Gey.first,Gex.second,Gey.second);\n\t\t\tcout<<Ge1<<' '<<Ge2<<' '<<Ge3<<' '<<Ge4<<endl;\n\t\t\tif((Ge1==3||Ge1==4)&&(Ge2==3||Ge2==4)&&(Ge3==3||Ge3==4)&&(Ge4==3||Ge4==4)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif(LJUD(Gex,Gey)==2) return 0;\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tbool four_JUD(point Gea,point Geb,point Gec,point Ged){\n\t\tint Ge1=PJUD(Gea,Geb,Gec),Ge2=PJUD(Gea,Geb,Ged);\n\t\tif(Ge1!=1&&Ge1!=2&&Ge2!=1&&Ge2!=2) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nint main(){\n  int n;cin>>n;\n  double x0,y0,x1,y1,x2,y2,x3,y3;\n  while(n--){\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    Point p0=Point(x0,y0),p1=Point(x1,y1),p2=Point(x2,y2),p3=Point(x3,y3);\n    cout << intersect(p0,p1,p2,p3) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\nint ccw(point a,point b,point c)\n{\n    point temp1=b-a;\n    point temp2=c-a;\n    if(cross(temp1,temp2)>eps){return COUNTER_CLOCKWISE;}\n    if(cross(temp1,temp2)<-eps){return CLOCKWISE;}\n    if(dot(temp1,temp2)<-eps){return ONLINE_BACK;}\n    if(temp1.norm()<temp2.norm()){return ONLINE_FRONT;}\n    return ON_SEGMENT;\n}\n\nint intersect(point a,point a1,point b,point b1)\n{\n    if(ccw(a,a1,b)*ccw(a,b,b1)<=0&&ccw(b,b1,a)*ccw(b,b1,a1)<=0){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n\nint main()\n{\n    int q;\n    cin>>q;\n    point a,a1,b,b1;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>a1.x>>a1.y>>b.x>>b.y>>b1.x>>b1.y;\n        if(intersect(a,a1,b,b1)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n\nusing Real = long double;\n\nconst Real EPS = 1e-10;\n\n// 宇宙船演算子\ninline Real compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\ntemplate <class T>\ninline T sq(T x) { return x * x; }\n\n\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\n\ninline Real length(Segment s) {\n    return std::abs(s.second - s.first);\n}\n\n// inner product\ninline Real dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n// outer product\ninline Real cross(Point x, Point y) {\n    return std::imag(std::conj(x) * (y));\n}\n\n// lに対するxの正射影\nPoint proj(Segment s, Point p) {\n    Real ratio = dot(s.second - s.first, p - s.first) / sq(length(s));\n    return s.first + (s.second - s.first) * ratio;\n}\n\n// lを軸としてxに対称な点\nPoint refl(Segment s, Point p) {\n    Point t = proj(s, p);\n    return t + (t - p);\n}\n\n// lに対するpの位置\n// counter clockwise -> 1, clockwise   -> -1\n// online front      -> 2, online back -> -2\n// on segment        -> 0\nint side(Segment s, Point p) {\n    Real c = cross(s.second - s.first, p - s.first);\n    if (compare(c, 0) != 0) return compare(c, 0);\n\n    Real d = dot(s.second - s.first, p - s.first);\n    if (compare(d, 0) < 0) return -2;\n\n    return (compare(length(Segment(s.first, p)), length(s)) > 0 ? 2 : 0);\n}\n\ninline bool isorthogonal(Segment s1, Segment s2) {\n    return compare(dot(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\ninline bool isparallel(Segment s1, Segment s2) {\n    return compare(cross(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return (side(s1, s2.first) * side(s1, s2.second) <= 0) &&\n           (side(s2, s1.first) * side(s2, s1.second) <= 0);\n}\n\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int Q;\n    cin >> Q;\n\n    for (int q = 0; q < Q; ++q) {\n        Segment s[2];\n        for (int i = 0; i < 2; ++i) {\n            Point p[2];\n            for (int j = 0; j < 2; ++j) {\n                Real x, y;\n                cin >> x >> y;\n                p[j] = Point(x, y);\n            }\n            s[i] = Segment(p[0], p[1]);\n        }\n        cout << intersect(s[0], s[1]) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n            if(x1>x2)swap(x1, x2);\n            if(y1>y2)swap(y1, y2);\n            if(x3>x4)swap(x3, x4);\n            if(y3>y4)swap(y3, y4);\n            \n            if(x1<=x3&&x3<=x2&&y1<=y3&&y3<=y2)return 1;\n            if(x1<=x4&&x4<=x2&&y1<=y4&&y4<=y2)return 1;\n            if(x3<=x1&&x1<=x4&&y3<=y1&&y1<=y4)return 1;\n            if(x3<=x2&&x2<=x4&&y3<=y3&&y3<=y4)return 1;\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\n/* ?¨±?????????????????  */\n#define EPS (1e-10)\n\n/* ?????? (cross product) : a??b = |a||b|sin */\ndouble cross(const P& a, const P& b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n/* a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????????? */\nint isIntersectedLS(P a1, P a2, P b1, P b2) {\n  if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main() {\n  int n;\n  int ax, ay, bx, by, cx, cy, dx, dy;\n  scanf(\"%d\", &n);\n\n  while(n--) {\n    scanf(\"%d %d %d %d %d %d %d %d\", &ax, &ay, &bx, &by, &cx, &cy, &dx, &dy);\n    P a(ax, ay), b(bx, by), c(cx, cy), d(dx, dy);\n\n    printf(\"%d\\n\", isIntersectedLS(a, b, c, d));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mkp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\ntypedef long long ll;\n\nconst ll MOD=1e9+7;\nconst double EPS=1e-9;\nconst double PI=acos(-1.0);\n//const long double PI=acos(-1.0L);\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n\n    Point operator +(const Point &b) const {return Point(x+b.x,y+b.y);}\n    Point operator -(const Point &b) const {return Point(x-b.x,y-b.y);}\n    Point operator *(const double b) const {return Point(x*b,y*b);}\n    Point operator /(const double b) const {return Point(x/b,y/b);}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point a,Point b):a(a),b(b){}\n};\n\nint sgn(double a) {return (a>EPS)-(a<-EPS);}\nint sgn(double a,double b) {return sgn(a-b);}\n\ndouble dot(const Point &a,const Point &b) {return (a.x*b.x+a.y*b.y);}\ndouble cross(const Point &a,const Point &b) {return (a.x*b.y-a.y*b.x);}\ndouble norm(const Point &p) {return dot(p,p);}\ndouble abs(const Point &p) {return sqrt(norm(p));}\n\nPoint projection(const Point &p,const Line &l){\n    double r=dot(p-l.a,l.b-l.a)/norm(l.b-l.a);\n    return l.a+(l.b-l.a)*r;\n}\n\nPoint reflection(const Point &p,const Line &l){\n    return p+(projection(p,l)-p)*2;\n}\n\n//1:Counter_Clockwise -1:Clockwise\n//2:a-b-c -2:c-a-b 0:a-c-b\nint ccw(const Point &p,const Point &q){\n    int s=sgn(cross(p,q));\n    if(s!=0) return s;\n    if(dot(p,q)<0) return -2;\n    if(norm(p)<norm(q)) return 2;\n    return 0;\n}\nint ccw(const Point &a,const Point &b,const Point &c){return ccw(b-a,c-a);}\n\nbool isParallel(const Line &l,const Line &r){\n    if(sgn(cross(l.b-l.a,r.b-r.a))==0) return true;\n    return false;\n}\nbool isOrthogonal(const Line &l,const Line &r){\n    if(sgn(dot(l.b-l.a,r.b-r.a))==0) return true;\n    return false;\n}\n\nbool isIntersected(const Line &l,const Line &r){\n    if(ccw(l.b-l.a,r.a-l.a)*ccw(l.b-l.a,r.b-l.a)>0) return false;\n    if(ccw(r.b-r.a,l.a-r.a)*ccw(r.b-r.a,l.b-r.a)>0) return false;\n    return true;\n}\n\nint main(){\n    int Q;\n    cin>>Q;\n\n    for(int q=0;q<Q;q++){\n        Point P1,P2;\n        cin>>P1.x>>P1.y>>P2.x>>P2.y;\n        Point P3,P4;\n        cin>>P3.x>>P3.y>>P4.x>>P4.y;\n\n        Line L1(P1,P2);\n        Line L2(P3,P4);\n        if(isIntersected(L1,L2)) cout<<\"1\"<<endl;\n        else cout<<\"0\"<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define kakkei vec<ten>\nusing namespace std;\nvoid solve();\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed;\n\tsolve();\n}\nstruct pea{\n\tll f,s;\n\tbool operator<(const pea &p)const{\n\t\treturn f!=p.f?f<p.f:s<p.s;\n\t};\n};\nstruct tri{\n\tll f,s,t;\n\tbool operator<(const tri &p)const{return f<p.f;};\n};\nclass ten{\npublic:\n\tld x,y;\n\tten operator+(ten p){return{x+p.x,y+p.y};}\n\tten operator-(ten p){return{x-p.x,y-p.y};}\n\tten operator*(ld k){return{k*x,k*y};}\n\tten operator/(ld k){return{x/k,y/k};}\n\tld abs(){return sqrt(abs2());}\n\tld abs2(){return x*x+y*y;};\n\tbool operator<(const ten &p)const{return x!=p.x?x<p.x:y<p.y;};\n\tbool operator==(const ten &p)const{return (-MIN<x-p.x)&&(x-p.x<MIN)&&(-MIN<y-p.y)&&(y-p.y<MIN);};\n\tld naiseki(v2 b){return x*b.x+y*b.y;}\n\tld gaiseki(v2 b){return x*b.y-y*b.x;}\n};\nstruct senbun{ten p1,p2;};\nstruct en{ten o;ld r;};\nten shaei(ten p,chokusen l){\n\tv2 a=l.p2-l.p1;\n\treturn l.p1+a*a.naiseki(p-l.p1)/a.abs2();\n}\nten hansha(ten p,chokusen l){return shaei(p,l)*2-p;}\nld tenchoku(ten p,chokusen l){\n\tv2 a=l.p2-l.p1;\n\treturn abs(a.gaiseki(p-l.p1))/a.abs();\n}\nld tensen(ten p,senbun s){\n\tif((p-s.p1).naiseki(s.p2-s.p1)<0)return (p-s.p1).abs();\n\tif((p-s.p2).naiseki(s.p1-s.p2)<0)return (p-s.p2).abs();\n\treturn tenchoku(p,s);\n}\nll ccw(ten p0,ten p1,ten p2){\n\tv2 a=p1-p0,b=p2-p0;\n\tif(a.gaiseki(b)>MIN)return -1;//012反時計回り\n\tif(a.gaiseki(b)<-MIN)return 1;//012時計回り\n\tif(a.naiseki(b)<-MIN)return -2;//102\n\tif(a.abs2()<b.abs2())return 2;//012\n\treturn 0;//021\n}\nbool majiwaru(senbun s,senbun t){return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2)<=0&&ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;}\nld sensen(senbun s,senbun t){\n\tif(majiwaru(s,t))return 0;\n\treturn min({tensen(s.p1,t),tensen(s.p2,t),tensen(t.p1,s),tensen(t.p2,s)});\n}\nvoid solve(){\n\tll n;cin>>n;\n\trep(i,0,n){\n\t\tsenbun s1,s2;\n\t\tld a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\ts1={{a,b},{c,d}};\n\t\tcin>>a>>b>>c>>d;\n\t\ts2={{a,b},{c,d}};\n\t\tcout<<majiwaru(s1,s2)<<kai;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\n#define CCW 1\n#define YCW -1\n#define ONB 3\n#define ONF 4\n#define ONS 0\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nint clockwise(Point p0, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\t\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tPoint p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (doIntersect(p0, p1, p2, p3))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (clockwise(p1, p2, p3) *  clockwise(p1, p2, p4) * clockwise(p3, p4, p1) * clockwise(p3, p4, p1) == 0) {\n\t\treturn true;\n\t} else if (-1 <= clockwise(p1, p2, p3) * clockwise(p1, p2, p4) && clockwise(p1, p2, p3) * clockwise(p1, p2, p4) <= 0 && -1 <= clockwise(p3, p4, p1) * clockwise(p3, p4, p2) && clockwise(p3, p4, p1) * clockwise(p3, p4, p2) <= 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nint clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\treturn ONS;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif ((p1 - p0).norm() < (p2 - p0).norm()) {\n\t\t\t//cout << \"ONLINE_FRONT\" << endl;\n\t\t\treturn ONF;\n\t\t} else {\n\t\t\t//cout << \"ON_SEGMENT\" << endl;\n\t\t\treturn ONS;\n\t\t}\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\t//cout << \"ONLINE_BACK\" << endl;\n\t\treturn ONB;\n\t} else {\n\t\tif (angle(p1 - p0, p2 - p0) > 0.0) {\n\t\t\t//cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\t\treturn CCW;\n\t\t} else {\n\t\t\t//cout << \"CLOCKWISE\" << endl;\n\t\t\treturn YCW;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-7;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(p.y, -p.x); } // 時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nstruct Segment {\n    Point a, b;\n    Segment() {}\n    Segment(const Point& a, const Point& b) : a(a), b(b) {}\n};\nbool intersects(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\nistream& operator>>(istream& is, Segment& s) { return is >> s.a >> s.b; }\nint main() {\n    int Q; cin >> Q;\n    for (int i = 0; i < Q; i++) {\n        Segment s, t;\n        cin >> s >> t;\n        cout << intersects(s, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint n;\n\nint ccw(P p0,P p1,P p2)\n{\n\tP a = P(p1.first - p0.first,p1.second - p0.second);\n\tP b = P(p2.first - p0.first,p2.second - p0.second);\n\tll dot = (ll)a.first*b.first + (ll)a.second*b.second;\n\tll cross = (ll)a.first*b.second - (ll)a.second*b.first;\n\tll na = (ll)a.first*a.first + (ll)a.second*a.second;\n\tll nb = (ll)b.first*b.first + (ll)b.second*b.second;\n\tif(cross > EPS){\n\t\treturn 1;\n\t}else if(cross < -EPS){\n\t\treturn -1;\n\t}else if(dot < -EPS){\n\t\treturn 2;\n\t}else if(na < nb){\n\t\treturn -2;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\nbool isIntersection(P p0,P p1,P p2,P p3)\n{\n\treturn ccw(p0,p1,p2)*ccw(p0,p1,p3) <= 0 && ccw(p2,p3,p0)*ccw(p2,p3,p1) <= 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint a[8];\n\t\trep(j,8){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",isIntersection(P(a[0],a[1]),P(a[2],a[3]),P(a[4],a[5]),P(a[6],a[7])));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nnamespace Geometry{\n    typedef long double D;\n    typedef complex<long double> P;\n    typedef pair<P,D> C;\n    \n    const D EPS=1e-9;\n    const D PI=asin(1)*2;\n    const D INF=1e18;\n    \n    const static bool comp(const P &p1,const P &p2){\n        if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n        return p1.real()<p2.real();\n    }\n    \n    const static bool comp_y(const P &p1,const P &p2){\n        if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n        return p1.imag()<p2.imag();\n    }\n    \n    D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n    D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n    P project(P vec,P x){return vec*(x/vec).real();}\n    \n    P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n    P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n    P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n    bool intersectSL(P p1,P p2,P vec){\n        vec/=abs(vec); p1/=vec; p2/=vec;\n        return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n    }\n    \n    bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n    bool intersectSS(P p1,P p2,P p3,P p4){\n        if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n        if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n        return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n    }\n    \n    D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n    D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n    D distSP(P p1,P p2,P x){\n        if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n        if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n        return distLP(p1,p2,x);\n    }\n    \n    D distSS(P p1,P p2,P p3,P p4){\n        if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n        return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n            distSP(p3,p4,p1),distSP(p3,p4,p2)});\n    }\n    \n    P crosspointLL(P p1,P p2,P vec){\n        if(abs(cross(p2-p1,vec))<EPS){return vec;}\n        return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n    }\n    \n    P crosspointLL(P p1,P p2,P p3,P p4){\n        return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n    }\n    \n    P crosspointSS(P p1,P p2,P p3,P p4){\n        if(distSP(p1,p2,p3)<EPS){return p3;}\n        if(distSP(p1,p2,p4)<EPS){return p4;}\n        return crosspointLL(p1,p2,p3,p4);\n    }\n    \n    bool intersectShL(P p1,P p2,P vec){\n        vec/=abs(vec);\n        return intersectSL(p1,p2,vec) &&\n        crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n    }\n    \n    bool intersectShL(P p1,P p2,P p3,P p4){\n        return intersectShL(p1-p3,p2-p3,p4-p3);\n    }\n    \n    //1::in,0::on edge,-1::out\n    int contain(const vector<P> &poly,const P &p){\n        vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n        vector<bool> cnt(5,false);\n        for(int i=0;i<(int)poly.size();i++){\n            int j=(i+1)%poly.size();\n            if(distSP(poly[i],poly[j],p)<EPS){return 0;}\n            for(int j=0;j<5;j++){\n                if(intersectShL(poly[i],poly[j],p,p+A[j])){cnt[j]=!cnt[j];}\n            }\n        }\n        int in=0;\n        for(int j=0;j<5;j++){if(cnt[j]){in++;}}\n        return in>=3?1:-1;\n    }\n    \n    vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n        vector<P> ret;\n        for(int i=0;i<(int)poly.size();i++){\n            int j=(i+1)%poly.size();\n            if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n            if(intersectSL(poly[i],poly[j],p1,p2) &&\n               distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n                ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly){\n        D ans=0;\n        for(int i=2;i<(int)poly.size();i++){\n            ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n        }\n        return abs(ans)/2;\n    }\n    \n    vector<P> convexhull(vector<P> pts){\n        vector<P> ret;\n        sort(pts.begin(),pts.end(),comp);\n        auto fnc=[&](){\n            for(auto &I:pts){\n                if(!ret.empty() && I==ret.back()){continue;}\n                while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){\n                    ret.pop_back();\n                }\n                ret.push_back(I);\n            }\n        };\n        fnc();\n        reverse(pts.begin(),pts.end());\n        fnc();\n        if(ret[0]==ret.back()){ret.pop_back();}\n        return ret;\n    }\n    \n    //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n    int intersectCC(C c1,C c2){\n        D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n        if(d<EPS && dif<EPS){return -1;}\n        if(d-r>EPS){return 4;}\n        if(d-r>-EPS){return 3;}\n        if(d-dif>EPS){return 2;}\n        if(d-dif>-EPS){return 1;}\n        return 0;\n    }\n    \n    vector<P> crosspointLC(P p1,P p2,C c){\n        vector<P> ret;\n        P pr=project(p1,p2,c.F);\n        D d=distLP(p1,p2,c.F);\n        if(d-c.S>EPS){return ret;}\n        if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n        P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n        ret.push_back(pr-vec);\n        ret.push_back(pr+vec);\n        return ret;\n    }\n    \n    vector<P> crosspointSC(P p1,P p2,C c){\n        vector<P> ret;\n        for(auto &I:crosspointLC(p1,p2,c)){\n            if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n        }\n        return ret;\n    }\n    \n    vector<P> crosspointCC(C c1,C c2){\n        vector<P> ret;\n        P vec=c2.F-c1.F;\n        D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n        D h=sqrt(c1.S*c1.S-base*base);\n        vec/=abs(vec);\n        ret.push_back(c1.F+vec*P(base,-h));\n        ret.push_back(c1.F+vec*P(base,h));\n        return ret;\n    }\n    \n    vector<P> tangentCP(C c,P p){\n        return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n    }\n    \n    vector<pair<P,P>> tangentCC(C c1,C c2){\n        vector<pair<P,P>> ret;\n        P d=c2.F-c1.F;\n        for(D i:{-1,1}){\n            D r=c1.S+c2.S*i;\n            if(intersectCC(c1,c2)>i+1){\n                for(P s:{-1i,1i}){\n                    P p=r+s*sqrt(norm(d)-norm(r));\n                    ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n                }\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly,C c){\n        D ret=0;\n        for(int i=0;i<(int)poly.size();i++){\n            P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n            if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n            else{\n                vector<P> A=crosspointSC(a,b,{0,c.S});\n                if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n                else{\n                    ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n                    ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n                    ret+=cross(A[0],A.back());\n                }\n            }\n        }\n        return abs(ret)/2;\n    }\n    \n    //反時計回り\n    D diameter(const vector<P> &poly){\n        D ret=0;\n        ll l=0,r=0,n=poly.size();\n        if(n==2){return abs(poly[0]-poly[1]);}\n        for(int i=0;i<n;i++){\n            if(comp(poly[l],poly[i])){l=i;}\n            if(comp(poly[i],poly[r])){r=i;}\n        }\n        ll sl=r,sr=l;\n        while(sl!=l || sr!=r){\n            ret=max(ret,abs(poly[r]-poly[l]));\n            if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n            else{(++r)%=n;}\n        }\n        return ret;\n    }\n    \n    D closestpair(vector<P> pt){\n        sort(pt.begin(),pt.end(),comp);\n        D ret=INF;\n        int N=pt.size();\n        for(int i=1;i<N;i<<=1){\n            for(int j=0;i+j<N;j+=i*2){\n                int m=i+j;\n                vector<P> R;\n                D l=-INF,r=INF;\n                for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n                for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n                for(int k=0;m+k<N && k<i;k++){\n                    if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n                }\n                int idx=0;\n                for(int k=j;k<m;k++){\n                    if(r-pt[k].real()>ret){continue;}\n                    int M=R.size();\n                    while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n                    for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n                        ret=min(ret,abs(R[s]-pt[k]));\n                    }\n                }\n                auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n                inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n            }\n        }\n        return ret;\n    }\n    \n    P centerofgravity(const vector<P> &pt){\n        P ret(0,0);\n        D wt=0;\n        for(int i=2;i<(int)pt.size();i++){\n            D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n            P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n            wt+=w2;\n            ret+=p*w2;\n        }\n        return ret/wt;\n    }\n    \n    istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n    istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n};\n\nusing namespace Geometry;\n\n\nint main(){\n    cout<<fixed<<setprecision(12);\n    ll n;\n    cin>>n;\n    while(n--){\n        P p1,p2,p3,p4;\n        cin>>p1>>p2>>p3>>p4;\n        cout<<intersectSS(p1,p2,p3,p4)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define eps (1e-10)\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point &p){return point(x+p.x,y+p.y);}\n    point operator - (point &p){return point(x-p.x,y-p.y);}\n    point operator * (double k){return point(x*k,y*k);}\n    point operator / (double k){return point(x/k,y/k);}\n\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator == (const point &p){\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n//内积\ndouble dot(point a,point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n//外积\ndouble cross(point a,point b){\n    return a.x*b.y-a.y*b.x;\n}\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\nint ccw(point a,point b,point c)\n{\n    point temp1=b-a;\n    point temp2=c-a;\n    if(cross(temp1,temp2)>eps){return COUNTER_CLOCKWISE;}\n    if(cross(temp1,temp2)<-eps){return CLOCKWISE;}\n    if(dot(temp1,temp2)<-eps){return ONLINE_BACK;}\n    if(temp1.norm()<temp2.norm()){return ONLINE_FRONT;}\n    return ON_SEGMENT;\n}\n\nint intersect(point a,point a1,point b,point b1)\n{\n    if(ccw(a,a1,b)*ccw(a,a1,b1)<=0&&ccw(b,b1,a)*ccw(b,b1,a1)<=0){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n\nint main()\n{\n    int q;\n    cin>>q;\n    point a,a1,b,b1;\n    for(int i=0;i<q;i++){\n        cin>>a.x>>a.y>>a1.x>>a1.y>>b.x>>b.y>>b1.x>>b1.y;\n        if(intersect(a,a1,b,b1)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c (cw)\n *          a -> bで反時計方向に折れてb -> c (ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c (front)\n *          a -> bで逆を向いてb -> cまたは、b == c (on)\n */\nenum struct orientation {\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t abs2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t abs(const vector_t& v)\n{\n    return std::sqrt(abs2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / abs2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orientation ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orientation::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orientation::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orientation::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(abs2(p1), abs2(p2)))       { return orientation::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orientation::on;\n}\n\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\ncoord_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{  \n    return std::min(pi.x, pj.x) <= pk.x && pk.x <= std::max(pi.x, pj.x)\n        && std::min(pi.y, pj.y) <= pk.y && pk.y <= std::max(pi.y, pj.y);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    coord_t d1 = direction(p3, p4, p1);\n    coord_t d2 = direction(p3, p4, p2);\n    coord_t d3 = direction(p1, p2, p3);\n    coord_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint across(P p1,P p2,P p3,P p4){\n    P s1(p2-p1);\n    P s2(p4-p3);\n    if(s1.real()*s2.imag()==s1.imag()*s2.real())return 2;//parallel\n    if(dot(s1,s2)==0)return 1;//Orthogonal\n    return 0;//others\n}\n\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(p1==p3 || p1==p4 || p2==p3 || p2==p4){\n      cout<<\"1\"<<endl;\n      continue;\n    }\n\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){//parallel\n      if(ccw(p1,p3,p4)==2||ccw(p2,p3,p4)==2 || ccw(p3,p1,p2)==2||ccw(p4,p1,p2)==2)\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    return d < 0? -1 : 1;\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x=0, double y=0): x(x), y(y){\n    }\n};\n\ntypedef Vector Point;\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nbool intersectProp(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double c1 = cross(a2 - a1, b1 - a1);\n    double c2 = cross(a2 - a1, b2 - a1);\n    double c3 = cross(b2 - b1, a1 - b1);\n    double c4 = cross(b2 - b1, a2 - b1);\n    \n    return dcmp(c1 * c2) == -1 && dcmp(c3 * c4) == -1;\n}\n\nbool onSegment(const Point& a, const Point& b, const Point& p) {\n    Vector pa = a - p;\n    Vector pb = b - p;\n    return dcmp(cross(pa, pb)) == 0 && dcmp(dot(pa, pb)) < 0;\n}\n\nbool intersect(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return intersectProp(a1, a2, b1, b2) || onSegment(a1, a2, b1) \n            || onSegment(a1, a2, b2) || onSegment(b1, b2, a1) || onSegment(b1, b2, a2);\n}\n\nint main() {\n    Point points[4];\n    int q;\n    cin >> q;\n    for (int kase = 0; kase < q; kase++) {\n        for (int i = 0; i < 4; i++) {\n            cin >> points[i].x >> points[i].y;\n        }\n        Vector v1 = points[1] - points[0];\n        Vector v2 = points[3] - points[2];\n\n        int ans =  intersect(points[0], points[1], points[2], points[3])? 1 : 0;\n        \n        cout << ans << endl;\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ON_SEGMENT = 0;\nstatic const int ONLINE_FRONT = 2;\nstatic const int ONLINE_BACK = -2;\nconst double EPS = 1e-10;\n\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tPoint operator / (double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {};\n\n\tPoint project(Point p) {\n\t\tVector a = Vector(p.x - p1.x, p.y - p1.y);\n\t\tVector b = Vector(p2.x - p1.x, p2.y - p1.y);\n\t\treturn p1 + p2 * (dot(a, b) / b.norm());\n\t}\n\n\tPoint refrect(Point p) {\n\t\tPoint pro = project(p);\n\t\treturn pro * 2 - p;\n\t}\n};\n\nint check(Vector v0, Vector v1) {\n\tdouble c = cross(v0, v1);\n\tif (equals(c, 0)) {\n\t\tif (dot(v0, v1) < 0) return ONLINE_BACK;\n\t\telse if (v1.norm() > v0.norm()) return ONLINE_FRONT;\n\t\telse return ON_SEGMENT;\n\t} else if (c > 0) {\n\t\treturn COUNTER_CLOCKWISE;\n\t} else {\n\t\treturn CLOCKWISE;\n\t}\n}\n\nint intersect(Segment s1, Segment s2) {\n\tPoint p1 = s1.p1, p2 = s1.p2, p3 = s2.p1, p4 = s2.p2;\n\tVector v0 = Vector((p2 - p1).x, (p2 - p1).y);\n\tVector v1 = Vector((p3 - p1).x, (p3 - p1).y);\n\tVector v2 = Vector((p4 - p1).x, (p4 - p1).y);\n\tVector v3 = Vector((p4 - p3).x, (p4 - p3).y);\n\tVector v4 = Vector((p1 - p3).x, (p1 - p3).y);\n\tVector v5 = Vector((p2 - p3).x, (p2 - p3).y);\n\tif (check(v0, v1) * check(v0, v2) == 0) return 1;\n\tif (check(v0, v1) * check(v0, v2) == -4) return 1;\n\tif (check(v0, v1) * check(v0, v2) == -1) {\n\t\tif (check(v3, v4) * check(v3, v5) > 0) return 0;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tSegment s1 = Segment(Point(x0, y0), Point(x1, y1));\n\t\tSegment s2 = Segment(Point(x2, y2), Point(x3, y3));\n\t\tcout << intersect(s1, s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static bool crossing(P p1,P p2,P q1,P q2){double x = ((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1)); return x<=1 && x>=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n};\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid swap(int *a, int *b){\n\tif(*a != *b){\n\t\t*a ^= *b;\n\t\t*b ^= *a;\n\t\t*a ^= *b;\n\t}\n}\n\nint main() {\n\tint n, xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3, d1, d2, d3, d4;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;++i){\n\t\tcin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n\t\td1 = (yp2 - yp0)*(xp1 - xp0) - (xp2 - xp0)*(yp1 - yp0);\n\t\td2 = (yp3 - yp0)*(xp1 - xp0) - (xp3 - xp0)*(yp1 - yp0);\n\t\td3 = (yp0 - yp2)*(xp3 - xp2) - (xp0 - xp2)*(yp3 - yp2);\n\t\td4 = (yp1 - yp2)*(xp3 - xp2) - (xp1 - xp2)*(yp3 - yp2);\n\t\t\n\t\tif( d1 == 0 && d2 == 0){\n\t\t\tif(xp0 != xp1){//not parallel with y axis\n\t\t\t\tif(xp0 > xp1)swap(&xp0, &xp1);\n\t\t\t\tif(xp2 > xp3)swap(&xp2, &xp3);\n\t\t\t\t\n\t\t\t\tif(xp0 <= xp3 && xp1 >= xp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}else{//parallel with y axis\n\t\t\t\tif(yp0 > yp1)swap(&yp0, &yp1);\n\t\t\t\tif(yp2 > yp3)swap(&yp2, &yp3);\n\t\t\t\t\n\t\t\t\tif(yp0 <= yp3 && yp1 >= yp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( d1 * d2 <= 0 && d3 * d4 <= 0){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(d / x, d / y); }\n\n  bool operator < (const Point &p) const {\n    return (x == p.x ? y < p.y : x < p.x);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nstruct Segment {\n  Point p0, p1;\n};\n\ndouble cross (Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\ndouble dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\ndouble norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nint ccw(Segment s, Point p2) {\n  if (cross(s.p1 - s.p0, p2 - s.p0) > EPS) return -1;\n  if (cross(s.p1 - s.p0, p2 - s.p0) < -EPS) return 1;\n  if (dot(s.p1 - s.p0, p2 - s.p0) < -EPS) return 99;\n  if (norm(s.p1 - s.p0) < norm(p2 - s.p0)) return 99;\n  return 0;\n}\n\nbool intersect(Segment s0, Segment s1) {\n  if (ccw(s0, s1.p0) * ccw(s0, s1.p1) <= 0 &&\n      ccw(s1, s0.p0) * ccw(s1, s0.p1) <= 0)\n    return true;\n\n  return false;\n}\n\nint main() {\n  int xs[4];\n  int ys[4];\n  Segment ss[2];\n\n  int q; cin >> q;\n\n  while (q--) {\n    for (int i = 0; i < 4; i++) {\n      cin >> xs[i];\n      cin >> ys[i];\n    }\n\n    Segment s0;\n    s0.p0 = Point(xs[0], ys[0]);\n    s0.p1 = Point(xs[1], ys[1]);\n\n    Segment s1;\n    s1.p0 = Point(xs[2], ys[2]);\n    s1.p1 = Point(xs[3], ys[3]);\n\n    cout << intersect(s0, s1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n//--\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = Y-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\n#define re real()\n#define im imag()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<double> pt;\ntypedef pair<pt,pt> line; //sX+tY\n\ndouble dot(pt a,pt b){return (conj(a)*b).real();}\ndouble cros(pt a,pt b){return (conj(a)*b).imag();}\npt proj(pt a,pt to){\n  return dot(a,to)/norm(to)*to;\n}\n\npt refle(pt a,pt mirror){\n  return pt(2)*proj(a,mirror)-a;\n}\n\nint pt3(pt a,pt b,pt c){\n  pt p=b-a,q=c-a;\n  double tmp;\n  tmp=cros(p,q);\n  if(tmp>0){\n    return 0;\n  }else if(tmp<0){\n    return 1;\n  }else if(norm(p+q)<max(norm(p),norm(q))){\n    return 2;//back\n  }else if(norm(q)>norm(p)){\n    return 3;//front\n  }else if(norm(q)<norm(p)){\n    return 4;\n  }\n  return 5;\n}\n\npt dir(line a){return a.Y-a.X;}\n\nint line2(line a,line b){\n  if(dot(dir(a),dir(b))==0)\n    return 1;//直交\n  if(cros(dir(a),dir(b))==0)\n    return 2;//平行\n  return 0;\n}\n\nint intersect(line a,line b){\n  if(line2(a,b)==2)\n    return pt3(a.X,a.Y,b.X)>3 || pt3(a.X,a.Y,b.Y)>3\n      || pt3(b.X,b.Y,a.X)>3 || pt3(b.X,b.Y,a.Y)>3;\n  return cros(dir(a),b.X-a.X)*cros(dir(a),b.Y-a.X)<=0\n    && cros(dir(b),a.X-b.X)*cros(dir(b),a.Y-b.X)<=0;\n}\n\nint main(){\n  int i,j,k,n,re;\n  line s1,s2;\n  double a[8];\n  cin>>n;\n  rep(i,n){\n    rep(j,8)\n      cin>>a[j];\n    s1.X=pt(a[0],a[1]);\n    s1.Y=pt(a[2],a[3]);\n    s2.X=pt(a[0+4],a[1+4]);\n    s2.Y=pt(a[2+4],a[4+3]);\n    cout<<intersect(s1,s2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define uint unsigned int\n#define pii pair<int, int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORR(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) FOR(i,0,n)\n#define REPR(i,n) FORR(i,n,0)\n#define ALL(c) ((c).begin(),(c).end())\n#define PB(a) push_back(a)\n#define EMPB(...) emplace_back(__VA_ARGS__)\n#define EMP(...) emplace(__VA_ARGS__)\n#define MP(a,b) make_pair(a,b)\n#define MT(...) make_tuple(__VA_ARGS__)\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define PW(n) (1LL<<(n))\nusing namespace std;\ntemplate <class T> inline bool CHMIN(T& a, T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <class T> inline bool CHMAX(T& a, T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <class T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <class T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <class T> inline void UNI(T& a) { SORT(a); a.erase(unique(ALL(a)),a.end()); }\ntemplate <class S, class T> ostream& operator<<(ostream& os, const pair<S,T> a) {\n  return os << a.first << ' ' << a.second;\n}\nconst int MOD = 1000000007;\n// const int INF = 0x3f3f3f3f3f3f3f3f;\n// const double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* 基本要素 */\nusing D = double; // 座標値の型 doubleかlong double\nusing P = complex<D>; // Point\nusing L = pair<P,P>;  // Line\nusing VP = vector<P>;\nconst double EPS = 1e-8;  // 許容誤差\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS) // n <= m ?\n#define GE(n,m) ((n)+EPS>(m)) // n >= m ?\n#define EQ(n,m) (abs((n)-(m))<EPS)\n\nnamespace std {\n  istream& operator >> (istream& is, P& p) {\n    int F, S;\n    is >> F >> S;\n    p = P(F,S);\n    return is;\n  }\n}\n\n// 内積\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n// 点aから見た、点bから点cへの方向\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b,c) > 0) return +1;  // counter clockwise\n  if (cross(b,c) < 0) return -1;  // clockwise\n  if (dot(b,c) < 0) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2; // a--b--c on line or a==b\n  return 0;                     // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定 直線・線分は縮退してはならない．接する場合は交差するとみなす */\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1,a2,b)) != 1;\n}\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1,b2-b1,0) || isecLP(a1,b1,b2);\n}\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS;\n}\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 && ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int q;\n  cin >> q;\n  REP(i,q) {\n    P p0, p1, p2, p3;\n    cin >> p0 >> p1 >> p2 >> p3;\n    cout << isecSS(p0,p1,p2,p3) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <complex>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\ntypedef double coordinate_t;\n\nstruct coordinate {\n  coordinate_t x, y;\n  bool operator<(const coordinate & another) const {\n    return x != another.x ? x < another.x : y < another.y;\n  }\n};\n\nstruct line {\n  coordinate_t a, b, c;\n  coordinate p, q;\n};\n\n// is p in [l.x, r.x] * [l.y, r.y] ?\nbool in_section(coordinate p, coordinate l, coordinate r) {\n  coordinate_t lx, ly, rx, ry;\n  lx = min(l.x, r.x);\n  rx = max(l.x, r.x);\n  ly = min(l.y, r.y);\n  ry = max(l.y, r.y);\n  if (lx <= p.x && p.x <= rx && ly <= p.y && p.y <= ry) return true;\n  else return false;\n}\n\n// the intersections of 2 lines\ncoordinate cross_of_2_lines(line k, line l) {\n  coordinate_t dn = l.a * k.b - k.a * l.b;\n  if (dn == 0) return{ NAN, NAN };\n  else {\n    coordinate ret;\n    ret.x = (l.b * k.c - k.b * l.c) / dn;\n    ret.y = (k.a * l.c - l.a * k.c) / dn;\n    if (in_section(ret, k.p, k.q) && in_section(ret, l.p, l.q)) return ret;\n    else return{ NAN, NAN };\n  }\n}\n\n\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (!isnan(p.x )&& !isnan(p.y)) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n\n// the line through 2 coordinates\nline line_through_2_coordinates(coordinate p, coordinate q) {\n  if (p.x == q.x && p.y == q.y) return{ NAN, NAN, NAN, p, q };\n  else {\n    if (p.x == q.x) {\n      if (p.y < q.y) return { 1, 0, -p.x, p, q };\n      else return{ 1, 0, -p.x, q, p };\n    }\n    else {\n      if (p.x < q.x) return { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, p, q };\n      else return{ (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, q, p };\n    }\n  }\n}\n\n\n\nint main() {\n  int q; cin >> q;\n  cout << setprecision(18);\n  Loop(i, q) {\n    coordinate p, q;\n    line s, t;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    s = line_through_2_coordinates(p, q);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    t = line_through_2_coordinates(p, q);\n    coordinate r = cross_of_2_lines(s, t);\n    if (isnan(r.x)) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nstatic const int COUNTER_CLOCKWISE = 1,CLOCKWISE = -1,ONLINE_BACK = 2,ONLINE_FRONT = -2,ON_SEGMENT = 0;\n//???\nclass Point{\n\tpublic:\t\n\t\tdouble x,y;\n\t\tPoint(double x = 0,double y = 0):x(x),y(y){}\n\t\t//?????????\n\t\tPoint operator + (Point p) { return Point(x + p.x,y + p.y);}\n\t\tPoint operator - (Point p) { return Point(x - p.x,y - p.y);}\n\t\tPoint operator * (double a) { return Point(x*a,y*a);}\n\t\tPoint operator / (double a) { return Point(x/a,y/a);}\n\t\t//???????????¨??§??????\n\t\tdouble abs() {return sqrt(norm());}\n\t\tdouble norm() {return x*x+y*y;}\n\n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n//??????\nstruct Segment{Point p1,p2;};\n//????????????\ntypedef Point Vector;\n//??´???\ntypedef Segment Line;\n//???\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(),double r = 0.0): c(c),r(r){}\n};\n//????§???¢\n//typedef Vector<Point> Polygon;\n//????????¨??????\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint check(Point p0,Point p1,Point p2){\n\tVector v1 = p1 - p0;\n\tVector v2 = p2 - p0;\n\tif(cross(v1,v2) > EPS){\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\tif(cross(v1,v2) < -EPS){\n\t\treturn CLOCKWISE;\n\t}\n\tif(dot(v1,v2) < -EPS){\n\t\treturn ONLINE_BACK;\n\t}\n\tif(v1.norm() < v2.norm()){\n\t\treturn ONLINE_FRONT;\n\t}\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p0,Point p1,Point p2,Point p3){\n\treturn (check(p0,p1,p2)*check(p0,p1,p3) <= 0 && check(p3,p2,p0)*check(p3,p2,p1) <= 0);\n}\n\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tPoint p0,p1,p2,p3;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n\t\tif(intersect(p0,p1,p2,p3)){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr double EPS = 1e-14;\n\nstruct vec2 {\n    double x, y;\n    vec2 operator+(const vec2 rhs) {\n        return {x + rhs.x, y + rhs.y};\n    }\n    vec2 operator-(const vec2 rhs) {\n        return {x - rhs.x, y - rhs.y};\n    }\n    vec2 operator*(const double k) {\n        return {x * k, y * k};\n    }\n    vec2 operator/(const double k) {\n        return {x / k, y / k};\n    }\n};\n\ndouble dot(vec2 a, vec2 b) {\n    return a.x * b.x + a.y * b.y;\n};\n\ndouble norm2(vec2 a) {\n    return dot(a, a);\n}\n\nstruct line {\n    vec2 p, l;\n};\n\nline make_line(vec2 a, vec2 b) {\n    return {a, b - a};\n}\n\ndouble cross(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(vec2 a, vec2 b) {\n    return abs(cross(a, b)) < EPS;\n}\n\nbool is_parallel(line a, line b) {\n    return is_parallel(a.l, b.l);\n}\n\ndouble operator/(vec2 a, vec2 b) {\n    assert(is_parallel(a, b));\n    return a.x / b.x;\n}\n\nvoid printvec2(vec2 p, int precision) {\n    cout << setprecision(precision) << fixed << p.x << \" \" << p.y << endl;\n}\n\nvec2 intersection(line l1, line l2) {\n    assert(!is_parallel(l1, l2));\n    double a = l1.p.x, b = l1.p.y, c = l1.l.x, d = l1.l.y;\n    double e = l2.p.x, f = l2.p.y, g = l2.l.x, h = l2.l.y;\n    double k = (h * (a - e) - g * (b - f)) / (g * d - c * h);\n    return {\n        a + k * c,\n        b + k * d\n    };\n}\n\nvec2 get_normal(vec2 p) {\n    return {-p.y, p.x};\n}\n\nvec2 foot(vec2 p, line l) {\n    line normal = {p, get_normal(l.l)};\n    return intersection(normal, l);\n}\n\nvec2 reflect(vec2 p, line l) {\n    vec2 f = foot(p, l);\n    return {2 * f.x - p.x, 2 * f.y - p.y};\n}\n\ndouble dist2(vec2 p, line l) {\n    return norm2(foot(p, l) - p);\n}\n\ndouble dist2(vec2 p, vec2 q) {\n    return norm2(q - p);\n}\n\nint sgn(double a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nstruct segment {\n    vec2 a, b;\n};\n\nsegment make_segment(vec2 a, vec2 b) {\n    return {a, b};\n}\n\ndouble dist2(vec2 p, segment s) {\n    vec2 l = s.a, r = s.b;\n    for (int i = 0; i < 100; i++) {\n        vec2 ml = (l + r) / 3;\n        vec2 mr = (l + r) * 2 / 3;\n        if (dist2(p, ml) > dist2(p, mr)) {\n            l = ml;\n        } else {\n            r = mr;\n        }\n    }\n    return dist2(p, l);\n}\n\ntemplate<class T>\nstruct ext {\n    double val;\n    T x, y;\n};\n\ntemplate<class T>\next<T> ternary_2d(function<double(T, T)> f, T xl, T xr, T yl, T yr, bool maximum = true) {\n    if (!maximum) {\n        function<double(T, T)> g = [&](T a, T b){return -f(a, b);};\n        ext<T> ret = ternary_2d(g, xl, xr, yl, yr, true);\n        return {-ret.val, ret.x, ret.y};\n    }\n    // fix y\n    function<ext<T>(T, T, T)> fx = [&](T y, T l, T r) {\n        for (int i = 0; i < 100; i++) {\n            T ml = (l * 2 + r) / 3.0;\n            T mr = (l + r * 2) / 3.0;\n            if (f(ml, y) < f(mr, y)) {\n                l = ml;\n            } else {\n                r = mr;\n            }\n        }\n        ext<T> ret;\n        ret.x = l;\n        ret.y = y;\n        ret.val = f(l, y);\n        return ret;\n    };\n\n    for (int i = 0; i < 100; i++) {\n        T ml = (yl * 2 + yr) / 3.0;\n        T mr = (yl + yr * 2) / 3.0;\n        if (f(fx(ml, xl, xr).x, ml) < f(fx(mr, xl, xr).x, mr)) {\n            yl = ml;\n        } else {\n            yr = mr;\n        }\n    }\n    ext<T> ret;\n    ret.x = fx(yl, xl, xr).x;\n    ret.y = yl;\n    ret.val = f(ret.x, ret.y);\n    return ret;\n}\n\ndouble dist2(segment s, segment t) {\n    ext<vec2> ans;\n    function<double(vec2, vec2)> d = [&](vec2 a, vec2 b) {\n        return norm2(b - a);\n    };\n    ans = ternary_2d(d, s.a, s.b, t.a, t.b, false);\n    return ans.val;\n}\n\nint main() {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        segment a = make_segment({x0, y0}, {x1, y1}), b = make_segment({x2, y2}, {x3, y3});\n        if (dist2(a, b) < EPS) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>\n#define INF         1e9\n#define EPS         1e-9\n#define REP(i,n)    for(lint i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)   for(lint i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)   for(lint i=(n)-1;i>=0;--i)\n#define REPR1(i,n)  for(lint i=(n);i>0;--i)\n#define REPC(i,obj) for(auto i:obj)\n#define R_UP(a,b)   (((a)+(b)-1)/(b))\n#define ALL(obj)    (obj).begin(),(obj).end()\n#define SETP        cout << fixed << setprecision(10)\nusing namespace std;\nusing lint = long long;\ntemplate<typename T = lint>inline T in() { T x; cin >> x; return x; }\nclass vec2d {\npublic:\n\tdouble x, y;\n\tvec2d(double x, double y) :x(x), y(y) {}\n\tdouble norm() const {\n\t\treturn sqrt(x * x + y * y);\n\t}\n\tvec2d operator+(vec2d v) {\n\t\treturn vec2d(x + v.x, y + v.y);\n\t}\n\tvec2d operator-(vec2d v) {\n\t\treturn vec2d(x - v.x, y - v.y);\n\t}\n\tvec2d operator*(double k) const {\n\t\treturn vec2d(x * k, y * k);\n\t}\n\tvec2d operator/(double k)const {\n\t\treturn vec2d(x / k, y / k);\n\t}\n\tbool operator==(const vec2d&v)const {\n\t\treturn x == v.x && y == v.y;\n\t}\n\tstatic double inner_product(const vec2d&a, const vec2d&b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\tstatic double cros_product(const vec2d&a, const vec2d&b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\tstatic double argument(const vec2d&a, const vec2d&b) {\n\t\treturn atan2(cros_product(a, b), inner_product(a, b));\n\t}\n\tstatic double distance(const vec2d&a, const vec2d&b) {\n\t\treturn hypot(b.x - a.x, b.y - a.y);\n\t}\n\tstatic vec2d projection(const vec2d&a, const vec2d&b) {\n\t\tdouble n = a.norm();\n\t\treturn a * vec2d::inner_product(a, b) / n / n;\n\t}\n\tstatic vec2d cross_point(const vec2d&v0, const vec2d&v1, const vec2d&v2, const vec2d&v3) {\n\t\treturn vec2d(((v1.x * v0.y - v0.x * v1.y) * (v3.x - v2.x) - (v3.x * v2.y - v2.x * v3.y) * (v1.x - v0.x)) / ((v1.x - v0.x) * (v3.y - v2.y) - (v3.x - v2.x) * (v1.y - v0.y)), ((v1.x * v0.y - v0.x * v1.y) * (v3.y - v2.y) - (v3.x * v2.y - v2.x * v3.y) * (v1.y - v0.y)) / ((v1.x - v0.x) * (v3.y - v2.y) - (v3.x - v2.x) * (v1.y - v0.y)));\n\t}\n};\nsigned main() {\n\tSETP;\n\tint q = in();\n\tREP(i, q) {\n\t\tdouble xp0 = in(), yp0 = in(), xp1 = in(), yp1 = in(), xp2 = in(), yp2 = in(), xp3 = in(), yp3 = in();\n\t\tvec2d v0(xp0, yp0), v1(xp1, yp1), v2(xp2, yp2), v3(xp3, yp3);\n\t\tvec2d cross = vec2d::cross_point(v0, v1, v2, v3);\n\t\tif (std::isnan(cross.x) && std::isnan(cross.y)) {\n\t\t\tvector<double> dis = {\n\t\t\tvec2d::distance(v0, v1),\n\t\t\tvec2d::distance(v0, v2),\n\t\t\tvec2d::distance(v0, v3),\n\t\t\tvec2d::distance(v1, v2),\n\t\t\tvec2d::distance(v1, v3),\n\t\t\tvec2d::distance(v2, v3)\n\t\t\t};\n\t\t\tdouble dis_sum = dis[0] + dis[5];\n\t\t\tdouble dis_max = *max_element(ALL(dis));\n\t\t\tcout << (dis_max < dis_sum || abs(dis_max - dis_sum) < EPS ? '1' : '0') << endl;\n\t\t} else if (std::isinf(cross.x) || std::isinf(cross.y)) {\n\t\t\tcout << '0' << endl;\n\t\t} else {\n\t\t\tv1 = v1 - v0;\n\t\t\tcross = cross - v0;\n\t\t\tdouble ks0 = v1.x != 0 ? cross.x / v1.x : cross.y / v1.y;\n\t\t\tv3 = v3 - v2;\n\t\t\tcross = cross + v0 - v2;\n\t\t\tdouble ks1 = v3.x != 0 ? cross.x / v3.x : cross.y / v3.y;\n\t\t\tcout << (0 <= ks0 && ks0 <= 1 && 0 <= ks1 && ks1 <= 1 ? '1' : '0') << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point() {};\n  Point(double x, double y): x(x), y(y) {}\n\n  Point operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n  Point operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double d) { return Point(d * x, d * y); }\n  Point operator / (double d) { return Point(d / x, d / y); }\n\n  bool operator < (const Point &p) const {\n    return (x == p.x ? y < p.y : x < p.x);\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend ostream& operator << (ostream &os, Point &p) {\n    return os << \"Point(\" << p.x << \", \" << p.y << \")\";\n  }\n};\n\nstruct Segment {\n  Point p0, p1;\n};\n\ndouble cross (Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\ndouble dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\ndouble norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nint ccw(Segment s, Point p2) {\n  if (cross(s.p1 - s.p0, p2 - s.p0) > EPS) return -1;\n  if (cross(s.p1 - s.p0, p2 - s.p0) < -EPS) return 1;\n  if (dot(s.p1 - s.p0, p2 - s.p0) < -EPS) return 2;\n  if (norm(s.p1 - s.p0) < norm(p2 - s.p0)) return 4;\n  return 0;\n}\n\nvoid debug(Segment s0, Segment s1) {\n  cout << ccw(s0, s1.p0) << ' '\n       << ccw(s0, s1.p1) << ' '\n       << ccw(s1, s0.p0) << ' '\n       << ccw(s1, s0.p1) << endl;\n  cout << ccw(s0, s1.p0) * ccw(s0, s1.p1) << ' '\n       << ccw(s1, s0.p0) * ccw(s1, s0.p1) << endl;\n}\n\nbool intersect(Segment s0, Segment s1) {\n//  debug(s0, s1);\n\n  if (\n      (ccw(s0, s1.p0) * ccw(s0, s1.p1) <= 0 &&\n       ccw(s1, s0.p0) * ccw(s1, s0.p1) <= 0\n       ) ||\n      ccw(s0, s1.p0) * ccw(s0, s1.p1) == 8 ||\n      ccw(s1, s0.p0) * ccw(s1, s0.p1) == 8\n      )\n    return true;\n\n  return false;\n}\n\nint main() {\n  int xs[4];\n  int ys[4];\n  Segment ss[2];\n\n  int q; cin >> q;\n\n  while (q--) {\n    for (int i = 0; i < 4; i++) {\n      cin >> xs[i];\n      cin >> ys[i];\n    }\n\n    Segment s0;\n    s0.p0 = Point(xs[0], ys[0]);\n    s0.p1 = Point(xs[1], ys[1]);\n\n    Segment s1;\n    s1.p0 = Point(xs[2], ys[2]);\n    s1.p1 = Point(xs[3], ys[3]);\n\n    cout << intersect(s0, s1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> qua;\nconst double epx=1e-7;\nint ccw(qua a,qua b,qua c)\n{\n    b-=a,c-=a,a=c*conj(b);\n    if(a.imag()>epx) return 1;\n    if(a.imag()<-epx) return -1;\n    if(a.real()<-epx) return 2;\n    if(abs(b)+epx<abs(c)) return -2;\n    return 0;\n}\nint isintersect(qua a,qua b,qua c,qua d)\n{\n    return (ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0);\n}\nint main()\n{\n    int t;\n    for(scanf(\"%d\",&t); t; --t)\n    {\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n        printf(\"%d\\n\",isintersect(qua(x1,y1),qua(x2,y2),qua(x3,y3),qua(x4,y4)));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\ndouble dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\ndouble atan(Point p) { return atan2(p.y, p.x); }\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble distancePP(Point p, Point o) { return sqrt(norm(o - p)); }\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(cross(b, c) > 0.0) return +1;\t//conter clockwise\n\tif(cross(b, c) < 0.0) return -1;\t//clockwise\n\tif(dot(b, c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(norm(b) < norm(c)) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\nstruct Line {\n\tPoint a, b;\n\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \")-(\" << l.b.x << \",\" << l.b.y << \")\";\n\treturn os;\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n};\n\nostream& operator << (ostream& os, const Seg& s) {\n\tos << \"(\" << s.a.x << \", \" << s.a.y << \")-(\" << s.b.x << \",\" << s.b.y << \")\";\n\treturn os;\n}\n\nbool isOrthogonal(Line l1, Line l2) { return equals(dot((l1.b - l1.a), (l2.b - l2.a)), 0.0); }\n\nbool isParallel(Line l1, Line l2) { return equals(cross((l1.b - l1.a), (l2.b - l2.a)), 0.0); }\n\nbool sameLine(Line l1, Line l2){ return abs(cross(l1.b - l1.a, l2.b - l1.a)) < EPS; }\n\nbool isIntersect(Seg s1, Seg s2) { \n\treturn ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 \n\t\t&& ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tSeg s1, s2;\n\trep(i, q) {\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\n\t\tif(isIntersect(s1, s2)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return -1;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 1;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n    double x,y;\n    Point(){}\n    Point(double x, double y) : x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){sqrt(norm());}\n    bool operator == (const Point &p) const {return equals(x,p.x)&&equals(y,p.y);}\n};\ntypedef Point P;\n\ndouble norm(P a){return a.x*a.x+a.y*a.y;}\ndouble abs(P a){return sqrt(norm(a));}\n\n// 線分\nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\n\n// 内積\ndouble dot(Point a, Point b) {return a.x*b.x + a.y*b.y;}\n\n// 外積\ndouble cross(Point a, Point b) {return a.x*b.y-a.y*b.x;}\n// 2直線の直行判定\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return equals(dot(a1-a2, b1-b2), 0.0);\n}\n// 2直線の平行判定\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return equals(cross(a1-a2, b1-b2), 0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2) {\n    P a = p1-p0;\n    P b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool is_intersected_ls(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0&&ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nint main() {\n    int q;\n    cin>>q;\n    rep(i,q){\n        double x0,y0,x1,y1,x2,y2,x3,y3;\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        P p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n        if (is_intersected_ls(p0,p1,p2,p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define EPS 1e-10\n#define equals (fabs((a)-(b)<EPS)\nint n;\n\nstruct Point\n{\n    double x, y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator -(Point a)\n    {\n        return Point(x-a.x,y-a.y);\n    }\n};\ndouble cross(Point a,Point b)\n{\n    return a.x*b.y-b.x*a.y;\n}\ndouble dot(Point a,Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\nPoint p0,p1,p2,p3;\nint ccw(Point p0,Point p1,Point p2)\n{\n    if(cross(p1-p0,p2-p0)>EPS) return 1;\n    else if(cross(p1-p0,p2-p0)<-EPS) return -1;\n\n    return 0;\n}\nvoid solve()\n{\n   if(ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0&&ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0) printf(\"1\\n\");\n   else printf(\"0\\n\");\n}\n\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p0.x,&p0.y,&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y);\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x=0, double y=0):x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a * x, a * y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y;}\n\tbool operator < (const Point &p) const {\n\t\t// first x, second y\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment{\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2){\n\t\tthis->p1 = p1;\n\t\tthis->p2 = p2;\n\t}\n};\n\ndouble dot(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Orthogonal\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1- b2);\n}\n\n// Orthogonal\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1- b2);\n}\n\n// ???p????????????s???????????????????????????\nPoint project(Segment s, Point p){\n\t// ??\\??????????????????\n\t// hypo -> p - p1, base -> p2 - p1\n\t// t = |hypo|cos??\n\t// cos?? = dot(hypo,base)/|hypo||base|\n\t// project = s.p1 + base/|base| * t\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(hypo, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n// ???p????????????s???????§°?????¨?????????\nPoint reflection(Segment s, Point p){\n\tPoint pr = project(s, p);\n\treturn p + (pr - p) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// p0??????p1????????????????????????????????????p2?????????\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a,b) <-EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????????????????? ??????p1->p2, p3->p4\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n// ?????????????????????\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???????????¢\ndouble distance(Point a, Point b){\n\treturn (a - b).abs();\n}\n\n// ?????¨??´???????????¢\ndouble distanceLinePoint(Segment s, Point p){\n\t// sin?? = |cross(hypo, base)|/|hypo||base|\n\t// distance = |hypo|sin?? = |cross(hypo, base)|/|base|\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\treturn abs(cross(hypo, base)) / base.abs();\n}\n\n// ?????¨??????????????¢\ndouble distanceSegmentPoint(Segment s, Point p){\n\t// (p2-p1)??¨???p-p1??????90???????????§????????´??????p??¨p1????????¢\n\t// (p1-p2)??¨???p-p2??????90???????????§????????´??????p??¨p2????????¢\n\t// ????????\\????????´???????????¨??´???????????¢\n\tif(dot(s.p2-s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n\treturn distanceLinePoint(s, p);\n}\n\n// ????????¨??????????????¢\n// TODO\n\nint Q;\n\nint main() {\n\n\tcin >> Q;\n\trep(i, Q){\n        Point p0, p1;\n        cin >> p0.x >> p0.y >> p1.x >> p1.y;\n        Point p2, p3;\n        cin >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << (intersect(p0, p1, p2, p3) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nstruct point{\n\tint x, y;\n\tpoint(int _x = 0, int _y = 0){ x = _x, y = _y; }\n\tvoid read(){ scanf(\"%d%d\", &x, &y); }\n\tpoint operator + (const point &rhs) const { return point(x + rhs.x, y + rhs.y); }\n\tpoint operator - (const point &rhs) const { return point(x - rhs.x, y - rhs.y); }\n}A, B, C, D;\nint q;\nint dot_product(point a, point b){\n\treturn a.x * b.x + a.y * b.y;\n}\nint cross_product(point a, point b){\n\treturn a.x * b.y - a.y * b.x;\n}\nbool intersection(point a, point b, point c, point d){\n\tif (std :: min(a.x, b.x) > std :: max(c.x, d.x)) return 0;\n\tif (std :: min(c.x, d.x) > std :: max(a.x, b.x)) return 0;\n\tif (std :: min(a.y, b.y) > std :: max(c.y, d.y)) return 0;\n\tif (std :: min(c.y, d.y) > std :: max(a.y, b.y)) return 0;\n\tint p1 = cross_product(b - a, c - a), p2 = cross_product(b - a, d - a);\n\tif (1ll * p1 * p2 > 0) return 0;\n\tp1 = cross_product(d - c, a - c), p2 = cross_product(d - c, b - c);\n\tif (1ll * p1 * p2 > 0) return 0;\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d\", &q);\n\tfor (register int i = 1; i <= q; ++i){\n\t\tA.read(), B.read(), C.read(), D.read();\n\t\tif (intersection(A, B, C, D)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second)) <= 0 && (ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second)) <= 0;\n}\n\n#endif\n\n#include <iostream>\nusing namespace std;\nint q, xa, ya, xb, yb; Segment s1, s2;\nint main() {\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> xa >> ya >> xb >> yb; s1 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tcin >> xa >> ya >> xb >> yb; s2 = make_pair(Point(xa, ya), Point(xb, yb));\n\t\tif (intersect(s1, s2, true)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n#define Pi 3.141592653589793238\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) {\n\t\tps.push_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = norm(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / sqrt(g);\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / sqrt(g);\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tPolygon u, l;\n\tif (p.size() < 3) return p;\n\tsort(p.begin(), p.end());\n\tu.push_back(p[0]); u.push_back(p[1]);\n\tl.push_back(p[p.size() - 1]); l.push_back(p[p.size() - 2]);\n\tfor (int i = 2; i < (int)p.size(); ++i) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], p[i]) == COUNTER_CLOCKWISE; --n)\n\t\t\tu.pop_back();\n\t\tu.push_back(p[i]);\n\t}\n\tfor (int i = p.size() - 3; i >= 0; --i) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], p[i]) == COUNTER_CLOCKWISE; --n)\n\t\t\tl.pop_back();\n\t\tl.push_back(p[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\treturn l;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0.0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * atan2(d.y, d.x);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tvector<Point> ps{ a,u[0],u[1],b };\n\t\tfor (int i = 1; i < ps.size(); ++i) res += dfs(c, ps[i - 1], ps[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.lower_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointLL(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\n\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1; cin >> c1.c.x >> c1.c.y >> c1.r;\n\tCircle c2; cin >> c2.c.x >> c2.c.y >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n    //CGL1C();\n\t//CGL2A();\n\tCGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\t//CGL4B();\n\t//CGL4C();\n\t//CGL5A();\n\t//CGL6A();\n\t//CGL7A();\n\t//CGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nauthor:w2sc\ndate:2019/12/19\ntime:20:10:42\n*/\n#include <bits/stdc++.h>\n#define ull unsigned long long\n#define ll long long\nusing namespace std;\nconst double EPS=1e-10;\nint dcmp(double x){return x<-EPS?-1:x>EPS;}\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double xx,double yy){x=xx,y=yy;}\n    Point operator -(Point A){return Point(x-A.x,y-A.y);}\n    double operator ^(Point A){return x*A.y-y*A.x;}\n    double operator *(Point A){return x*A.x+y*A.y;}\n};\ntypedef Point Vec;\nstruct Line{\n    Point A,B;\n    Vec v;\n    Line(){}\n    Line(Point AA,Point BB){A=AA,B=BB;v=B-A;}\n    bool on_seg(Point P){return dcmp((A-P)^(B-P))==0 && dcmp((A-P)*(B-P))<=0;}\n};\nint q;\nint main()\n{\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        Point A,B;\n        Line a,b;\n        scanf(\"%lf%lf%lf%lf\",&A.x,&A.y,&B.x,&B.y);\n        a=Line(A,B);\n        scanf(\"%lf%lf%lf%lf\",&A.x,&A.y,&B.x,&B.y);\n        b=Line(A,B);\n        printf(\"%d\\n\",(dcmp(((b.A-a.A)^(a.v))*((b.B-a.A)^a.v))<0 &&\n            dcmp(((a.A-b.A)^(b.v))*((a.B-b.A)^b.v))<0) ||\n            b.on_seg(a.A) || b.on_seg(a.B) || a.on_seg(b.A) || a.on_seg(b.B));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl(point A, point B, point P){ // reflection point of P int segment AB\n    return proj(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n\nint n;\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        point p[4];\n        for (int j = 0; j < 4; j++){\n            p[j].read();\n        }\n        printf(\"%d\\n\", check_SS(p[0], p[1], p[2], p[3]));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y =0.0):x(x),y(y){}\n\tPoint operator + (const Point& p){ return Point(x+p.x,y+p.y);\t}\n\tPoint operator - (const Point& p){ return Point(x-p.x,y-p.y); }\n\tPoint operator * (double k){ return Point(x*k,y*k);\t}\n\tPoint operator / (double k){ return Point(x/k,y/k); }\n\n\tdouble norm(){return x*x+y*y;}\n\tdouble abs(){return sqrt(norm());}\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\n\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\n\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){}\n\tSegment(double a,double b,double c,double d):p1(Point(a,b)),p2(Point(c,d)){}\n};\n\ntypedef Segment Line;\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c),r(r){}\n};\ntypedef vector<Point> Polygon;\n\nbool isOrthgonal(Vector a, Vector b){\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthgonal(a1-a2,b1-b2);\n}\n\nbool isOrthgonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p-s.p1,base)/base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s,p) - p) * 2.0;\n}\n\ndouble getDistance(Point a,Point b){\n\treturn abs(a-b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p-l.p1) / abs(l.p2 - l.p1));\n}\n\n\n//????¨???¨????????§??????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Vector a, Vector b){\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n//??????????????????\nbool intersect(Point p1, Point p2, Point p3,Point p4){\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2, s2.p1,s2.p2);\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n;cin>>n;\n\twhile(n--){\n\t\tint a,b,c,d,e,f,g,h;\n\t\tcin>>a>>b >>c>>d>>e>>f>>g>>h;\n\t\tif(intersect(Segment(a,b,c,d),Segment(e,f,g,h)))cout << 1 << endl;\n\t\telse cout <<0 << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct F {\n\tlong long a, b;\n\tF() {}\n\tF(long long _a, long long _b) : a(_a), b(_b) {}\n\tF operator + (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a + a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator - (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a - a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator * (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator / (const F &f) {\n\t\tlong long x = a * f.b, y = b * f.a;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ninline int sign(double a) {\n\treturn a < -eps ? -1 : a > eps;\n}\ninline int cmp(double a, double b) {\n\treturn sign(a - b);\n}\ndouble add(double a, double b) {\n\tif (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\ntypedef long long data;\nstruct P {\n\tdata x, y;\n\tP() {}\n\tP(data x, data y) : x(x), y(y) {}\n\tP operator + (const P &p) { return P(x + p.x, y + p.y); }\n\tP operator - (const P &p) { return P(x - p.x, y - p.y); }\n\tP operator * (data d) { return P(x * d, y * d); }\n\tP operator / (data d) { return P(x / d, y / d); }\n\tdata dot(const P &p) { return x * p.x + y * p.y; }\n\tdata det(const P &p) { return x * p.y - y * p.x; }\n\tdata disto(const P &p) { return (*this - p).abs(); }\n\tdata alpha() { return atan2(y, x); }\n\tdata abs() { return sqrt(abs2()); }\n\tdata abs2() { return x * x + y * y; }\n\tP rot90() { P(-y, x); }\n\tP unit() { return *this / abs(); }\n\tbool operator < (P p) const {\n\t\tint c = cmp(x, p.x);\n\t\tif (c) return c == -1;\n\t\treturn cmp(y, p.y) == -1;\n\t}\n\tfriend istream& operator>>(istream &in, P &p) {\n\t\tin >> p.x >> p.y;\n\t\treturn in;\n\t}\n\tfriend ostream& operator<<(ostream& out, P &p) {\n\t\tout << p.x << ' ' << p.y;\n\t\treturn out;\n\t}\n};\nP projection(P p1, P p2, P q) {\n\tP dir = p2 - p1;\n\treturn p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\nP reflection(P p1, P p2, P q) {\n\treturn projection(p1, p2, q) * 2 - q;\n}\nbool is_midddle(data a, data m, data b) {\n\treturn sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\nbool is_midddle(P a, P m, P b) {\n\treturn is_midddle(a.x, m.x, b.x) && is_midddle(a.y, m.y, b.y);\n}\nbool on_seg(P p1, P p2, P q) {\n\treturn (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n\t// return (p1 - q).det(p2 - q) == 0 && is_middle(p1, q, p2);\n}\nP intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\nbool intersect(data l1, data r1, data l2, data r2) {\n\tif(l1 > r1) swap(l1, r1);\n\tif(l2 > r2) swap(l2, r2);\n\treturn cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nbool intersect(P p1, P p2, P q1, P q2) {\n\treturn intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)\n\t&& (p1 - q1).det(p2 - q1) * (p1 - q2).det(p2 - q2) <= 0\n\t&& (q1 - p1).det(q2 - p1) * (q1 - p2).det(q2 - p2) <= 0;\n}\n\nint main() {\n#ifdef LOCAL_DEFINE\n\t//freopen(\"data.in\", \"rt\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tauto _start = chrono::high_resolution_clock::now();\n#endif\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tcout << intersect(p0, p1, p2, p3) << '\\n';\n\t}\n\n#ifdef LOCAL_DEFINE\n\tauto _end = chrono::high_resolution_clock::now();\n\tcerr << \"elapsed time: \" << chrono::duration<double, milli>(_end - _start).count() << \" ms\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    double length() const { return std::sqrt(x * x + y * y); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  using Vector = Point;\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n  using Segment = Line;\n  Point projection(const Line& line, const Point& point) {\n    double x1 = line.p1.x, y1 = line.p1.y, x2 = line.p2.x, y2 = line.p2.y;\n    double x0 = point.x, y0 = point.y;\n    double x01 = x1 - x0, y01 = y1 - y0, x12 = x2 - x1, y12 = y2 - y1;\n    double sd12 = x12 * x12 + y12 * y12;\n    double x = (x12 * x12 * x0 + y12 * y12 * x1 - x12 * y12 * y01) / sd12;\n    double y = (x12 * x12 * y1 + y12 * y12 * y0 - x12 * y12 * x01) / sd12;\n    return Point(x, y);\n  }\n  Point reflection(const Line& line, const Point& point) {\n    Point proj = projection(line, point);\n    return proj + proj - point;\n  }\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length() < v2.length()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n  bool is_parallel(const Line& l1, const Line& l2) {\n    return abs(cross_product(l1.to_vector(), l2.to_vector())) < eps;\n  }\n  bool is_orthogonal(const Line& l1, const Line& l2) {\n    return abs(inner_product(l1.to_vector(), l2.to_vector())) < eps;\n  }\n  bool is_intersect(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  int q;\n  cin >> q;\n  rep(_, q) {\n    Segment s1, s2;\n    cin >> s1 >> s2;\n    cout << is_intersect(s1, s2) << '\\n';\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-10;\nbool dcmp(double d, double d2 = 0) { return abs(d - d2) < eps; }\n\nstruct vec {\n  double x, y;\n  vec(double x, double y) : x(x), y(y) {}\n  vec() : x(0), y(0) {}\n  const bool operator==(const vec &v) const {\n    return dcmp(x, v.x) && dcmp(y, v.y);\n  }\n  const bool operator!=(const vec &v) const { return !(*this == v); }\n  const vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }\n  const vec operator-() const { return vec(-x, -y); }\n  const vec operator-(const vec &v) const { return *this + (-v); }\n  const vec operator*(const double d) const { return vec(x * d, y * d); }\n  const vec operator/(const double d) const { return *this * (1 / d); }\n  const vec unit() const { return *this / len(); };\n  const double len() const { return sqrt(x * x + y * y); }\n  const double dot(const vec &v) const { return x * v.x + y * v.y; }\n  const double cross(const vec &v) const { return x * v.y - y * v.x; }\n  const bool parallel(const vec &v) const { return dcmp(cross(v)); }\n  const bool perpendicular(const vec &v) const { return dcmp(dot(v)); }\n};\n\ntypedef vec point;\n\ntemplate <class T> struct optional {\n  bool has;\n  T val;\n  optional() : has(false) {}\n  optional(T t) : has(true), val(t) {}\n};\n\nstruct line {\n  double a, b, c;\n  line(point p1, point p2) {\n    a = p1.y - p2.y;\n    b = p2.x - p1.x;\n    c = (p1.x - p2.x) * p1.y + (p2.y - p1.y) * p1.x;\n    // printf(\"Line: %lfx + %lfy + %lf = 0\\n\", a, b, c);\n    // printf(\"Point: (%lf, %lf), (%lf, %lf)\\n\", p1.x, p1.y, p2.x, p2.y);\n    double m1 = a * p1.x + b * p1.y + c;\n    double m2 = a * p2.x + b * p2.y + c;\n    // printf(\"M1 = %lf, M2 = %lf\\n\", m1, m2);\n    // printf(\"OK: %d %d\\n\", dcmp(m1), dcmp(m2));\n  }\n  optional<point> intersect(line l) {\n    if (dcmp(a * l.b, b * l.a))\n      return optional<point>();\n    return point(-(c * l.b - b * l.c) / (a * l.b - b * l.a),\n                 -(c * l.a - a * l.c) / (a * l.b - b * l.a));\n  }\n  bool contains(point p) {\n    // printf(\"%lfx + %lfy + %lf = 0 contains (%lf, %lf): %d [%lf]\\n\", a, b, c,\n    //        p.x, p.y, dcmp(a * p.x + b * p.y + c), a * p.x + b * p.y + c);\n    return dcmp(a * p.x + b * p.y + c);\n  }\n};\n\nstruct segment {\n  point p1, p2;\n  segment(point p1, point p2) : p1(p1), p2(p2) {}\n  line sline() {\n    // printf(\"Sline: (%lf, %lf) and (%lf, %lf)\\n\", p1.x, p1.y, p2.x, p2.y);\n    return line(p1, p2);\n  }\n  bool contains(point p) {\n    double x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);\n    double y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);\n    bool ok = sline().contains(p) && (x1 <= p.x && p.x <= x2) &&\n              (y1 <= p.y && p.y <= y2);\n    // printf(\"Segment (%lf, %lf) - (%lf, %lf) contains (%lf, %lf): %d\\n\", p1.x,\n    //        p1.y, p2.x, p2.y, p.x, p.y, ok);\n    return ok;\n  }\n  optional<point> intersect(segment s) {\n    optional<point> r = sline().intersect(s.sline());\n    if (!r.has)\n      return r;\n    point p = r.val;\n    if (contains(p) && s.contains(p))\n      return r;\n    return optional<point>();\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    segment l0(p0, p1);\n    segment l1(p2, p3);\n    line ll0 = l0.sline();\n    line ll1 = l1.sline();\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll0.a, ll0.b, ll0.c);\n    // printf(\"%lfx + %lfy + %lf = 0\\n\", ll1.a, ll1.b, ll1.c);\n    bool has = l0.intersect(l1).has;\n    cout << (has ? 1 : 0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n    ll x,y;\n    Point(){ x = y = 0.0; }\n    Point(ll _x, ll _y) : x(_x), y(_y){}\n\n    Point operator+ (Point p)\n    {\n        return Point(p.x + x, p.y + y);\n    }\n\n    Point operator- (Point p)\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    ll operator* (Point p)\n    {\n        return p.x * x + p.y * y;\n    }\n\n    Point operator* (ll t)\n    {\n        return Point(x*t, y*t);\n    }\n\n    ll operator~ ()\n    {\n        return x * x + y * y;\n    }\n\n    ll operator% (Point p)\n    {\n        return x * p.y - y * p.x;\n    }\n\n};\n\nbool intersect(Point a, Point b, Point p, Point q)\n{\n    Point v1=(b-a);\n    Point v2=(q-p);\n    double t,t1;\n    if( v1 % v2 != 0 )\n    {\n        t = (double)(( p - a ) % v2) / (double)(v1 % v2);\n        t1 = (double)(( a - p ) % v1) / (double)(v2 % v1);\n        if( t >= 0.0 && t <= 1.0 && t1 >= 0.0 && t1 <= 1.0) return true;\n        else return false;\n    }\n    else\n    {\n        if( v1 % v2 == 0 && (p - a) % v1 == 0 )\n        {\n            t = (double)((p - a)*v1) /  (double)(v1*v1);\n            t1 = (double)((p+v2-a)*v1) / (double)(v1*v1);\n            if( v1 * v2 < 0 )\n            {\n                if( t1 <= 1.0 && 0.0 <= t ) return true;\n            }\n            else\n            {\n//                cout <<fixed << setprecision(6)<< t << \" \" << t1 << \" \" << v1*v2 << endl;\n                if( t <= 1.0 && 0.0 <= t1 ) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    Point p0,p1,p2,p3;\n    Point vec, vec1;\n    int q;\n    cin >> q;\n    while(q--)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << intersect(p0,p1,p2,p3) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nconst double eps = 1e-15;\n\nbool IsEq(double d1, double d2)\n{\n    if (d1 - d2 > -eps && d1 - d2 < eps){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nclass Point2D {\npublic:\n    double x, y;\n    Point2D() : x(0), y(0) {}\n    Point2D(double _x, double _y) : x(_x), y(_y) {}\n    virtual ~Point2D() {}\n};\n\nistream& operator >> (istream& input, Point2D& P)\n{\n    input >> P.x >> P.y;\n    return input;\n}\n\nclass Segment {\npublic:\n    Point2D P, Q;\n    Segment() {}\n    Segment(const Point2D& _P, const Point2D& _Q) : P(_P), Q(_Q) {}\n};\n\nistream& operator >> (istream& input, Segment& Seg)\n{\n    input >> Seg.P >> Seg.Q;\n    return input;\n}\n\nclass Vector2D : public Point2D {\npublic:\n    Vector2D(const Point2D& P) : Point2D(P) {}\n    Vector2D(const Segment Seg) : Point2D(Seg.Q.x - Seg.P.x, Seg.Q.y - Seg.P.y) {}\n    Vector2D(const Point2D Start, Point2D End) : Point2D(End.x - Start.x, End.y - Start.y) {}\n    double InnerProd(const Vector2D Vec) const\n    {\n        return x * Vec.x + y * Vec.y;\n    }\n    double OuterProd(const Vector2D Vec) const\n    {\n        return x * Vec.y - y * Vec.x;\n    }\n    double Length() const\n    {\n        return sqrt((*this).InnerProd(*this));\n    }\n};\n\ndouble Dist(const Point2D P, const Segment Seg)\n{\n    Vector2D V1(Seg);\n    Vector2D V2(Seg.P, P);\n    return V1.InnerProd(V2) / V1.Length();\n}\n\ndouble Dist(const Point2D P, const Point2D Q)\n{\n    Vector2D V(P, Q);\n    return V.Length();\n}\n\nbool IsPara(Segment Seg1, Segment Seg2)\n{\n    Vector2D V1(Seg1), V2(Seg2);\n    return IsEq(V1.OuterProd(V2), 0.);\n}\n\nbool IsOnSeg(Point2D P, Segment Seg)\n{\n    Vector2D V(Seg);\n    return IsEq(V.Length(), Dist(P, Seg.P) + Dist(P, Seg.Q));\n}\n\nbool IsIntersect(Segment Seg1, Segment Seg2) {\n    Vector2D P1(Seg1.P), P2(Seg2.P);\n    Vector2D V1(Seg1), V2(Seg2);\n    if (!IsPara(Seg1, Seg2)) {\n        double t = (P2.OuterProd(V2) - P1.OuterProd(V2)) / V1.OuterProd(V2);\n        double s = (P2.OuterProd(V1) - P1.OuterProd(V1)) / V1.OuterProd(V2);\n        return t > -eps && t < 1 + eps && s > -eps && s < 1 + eps;\n    } else {\n        if (IsOnSeg(Seg1.P, Seg2) || IsOnSeg(Seg1.Q, Seg2) || IsOnSeg(Seg2.P, Seg1) || IsOnSeg(Seg2.Q, Seg1)) return true;\n        return false;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int q;\n    Segment Seg1, Seg2;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> Seg1 >> Seg2;\n        if (IsIntersect(Seg1, Seg2)) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n//using P = pair<int, int>;\nusing namespace std;\n\nconst double eps = 1e-10;\n#define equals(a, b) (fabs((a)-(b)) < eps)\n\n// 点\nstruct Point\n{\n    double x, y;\n    Point(double x=0, double y=0): x(x), y(y) {}\n    double norm()\n    {\n        return x*x+y*y;\n    }\n    double abs()\n    {\n        return sqrt(norm());\n    }\n\n    Point operator+(const Point& p)const\n    {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator-(const Point& p)const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator*(const double k)const\n    {\n        return Point(x * k, y * k);\n    }\n    Point operator/(const double k)const\n    {\n        return Point(x / k, y / k);\n    }\n    bool operator<(const Point& p)const\n    {\n        if (x != p.x)\n        {\n            return x < p.x;\n        }\n        return y < p.y;\n    }\n    bool operator==(const Point& p)const\n    {\n        return fabs(x - p.x) < eps and fabs(y - p.y) < eps;\n    }\n};\n\nusing Vector = Point;\n\n// 内積\ndouble dot(Vector a, Vector b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n// 外積\ndouble cross(Vector a, Vector b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n// 線分\nstruct Segment\n{\n    Segment(Point a=Point(), Point b=Point()):p1(a), p2(b) {}\n    Point p1, p2;\n};\nusing Line = Segment;\n\n// 円\nclass Circle\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 多角形\nusing Polygon = vector<Point>;\n\n\n// ベクトルaとbの直行判定\n// Verify\nbool isOrthogonal(Vector a, Vector b) {\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// ベクトルaとbの平行判定\n// Verify\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// 射影\n// verify\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / base.norm();\n    return s.p1 + base * r;\n}\n\n// 反射\n// verify\nPoint reflect(Segment s, Point p) {\n    return p + (project(s, p) - p) * 2.0;\n}\n\n// ２点間の距離\ndouble getDistance(Point a, Point b) {\n    return (a-b).abs();\n}\n\n// 直線Lと、点Pの距離\n// verify\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.p2 - l.p1, p - l.p1) / Point(l.p2 - l.p1).abs());\n}\n\n// 線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n    if (dot(s.p1 - s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n    return getDistanceLP((Line)s, p);\n}\n\n\n// 反時計回り\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// verify\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > eps) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -eps) return CLOCKWISE;\n    if (dot(a, b) < -eps) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// 線分の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n// verify\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 線分s1と線分s2の距離\n//verify\ndouble getDistance(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\n// 線分の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n// 円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n    //assert(intersect(c, l)); ?\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n    double base = sqrt(c.r * c.r - (pr - c.c).norm());\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n// 円と円の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n    // assert(intersect(c1, c2));\n    double d = (c1.c - c2.c).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2  * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t-a));\n}\n\n// 点の内包\n// IN 2, ON 1, OUT 0\n\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < eps and dot(a, b) < eps) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < eps and eps < b.y and cross(a, b) > eps) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\n// 凸包\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for (int i = 2; i < s.size(); ++i) {\n        for (int n = u.size(); n >= 2 and ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; --n) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = s.size()-3; i>=0; --i) {\n        for (int n = l.size(); n>=2 and ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; --n) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n    return l;\n}\n\n// 平面走査\n#define BOTTOM 0\n#define LEFT 1\n#define RIGHT 2\n#define TOP 3\n\nclass EndPoint {\npublic:\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint &ep) const {\n        if (p.y == ep.p.y) {\n            return st < ep.st;\n        }else return p.y < ep.p.y;\n    }\n};\n\nEndPoint EP[2 * 100000];\n\nint manhattanIntersection(vector<Segment> S) {\n    int n = S.size();\n\n    for (int i = 0, k = 0; i < n; ++i) {\n        if (S[i].p1.y == S[i].p2.y) {\n            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n        } else if (S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\n        if (S[i].p1.y == S[i].p2.y) {\n            EP[k++] = EndPoint(S[i].p1, i, LEFT);\n            EP[k++] = EndPoint(S[i].p2, i, RIGHT);\n        }\n        else {\n            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n            EP[k++] = EndPoint(S[i].p2, i, TOP);\n        }\n    }\n\n    sort(EP, EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(100000001); // 番兵\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * n; ++i) {\n        if (EP[i].st == TOP) {\n            BT.erase(EP[i].p.x);\n        }\n        else if (EP[i].st == BOTTOM) {\n            BT.insert(EP[i].p.x);\n        }\n        else if (EP[i].st == LEFT) {\n            auto b = lower_bound(BT.begin(), BT.end(), S[EP[i].seg].p1.x);\n            auto e = upper_bound(BT.begin(), BT.end(), S[EP[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n\n}\n\nint main() {\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int x1, y1, x2, y2, x3, y3, x4, y4;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n        Point a(x1, y1), b(x2, y2), c(x3, y3), d(x4, y4);\n        cout << intersect(a, b, c, d) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cfloat>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\ntypedef double coordinate_t;\n\nstruct coordinate {\n  coordinate_t x, y;\n  bool valid;\n  bool operator<(const coordinate & another) const {\n    return x != another.x ? x < another.x : y < another.y;\n  }\n};\n\nstruct line {\n  coordinate_t a, b, c;\n  coordinate p, q;\n  bool valid;\n};\n\n// is p in [l.x, r.x] * [l.y, r.y] ?\nbool in_section(coordinate p, coordinate l, coordinate r) {\n  coordinate_t lx, ly, rx, ry;\n  lx = min(l.x, r.x);\n  rx = max(l.x, r.x);\n  ly = min(l.y, r.y);\n  ry = max(l.y, r.y);\n  if (lx <= p.x && p.x <= rx && ly <= p.y && p.y <= ry) return true;\n  else return false;\n}\n\n// the intersections of 2 lines\ncoordinate cross_of_2_lines(line k, line l) {\n  coordinate ret = { NAN, NAN, false };\n  coordinate_t dn = l.a * k.b - k.a * l.b;\n  if (k.valid && l.valid && dn != 0) {\n    ret.x = (l.b * k.c - k.b * l.c) / dn;\n    ret.y = (k.a * l.c - l.a * k.c) / dn;\n    if (in_section(ret, k.p, k.q) && in_section(ret, l.p, l.q)) ret.valid = true;\n  }\n  return ret;\n}\n\n\n// the intersections of n lines\nvector<coordinate> crosses_of_lines(vector<line> lines) {\n  int n = lines.size();\n  set<coordinate> st;\n  Loop(i, n) {\n    Loop(j, i) {\n      coordinate p = cross_of_2_lines(lines[i], lines[j]);\n      if (p.valid) st.insert(p);\n    }\n  }\n  vector<coordinate> ret;\n  for (auto itr = st.begin(); itr != st.end(); itr++) {\n    ret.push_back(*itr);\n  }\n  return ret;\n}\n\n\n// the line through 2 coordinates\nline line_through_2_coordinates(coordinate p, coordinate q) {\n  if (p.x == q.x && p.y == q.y) return{ NAN, NAN, NAN, p, q, false };\n  else {\n    if (p.x == q.x) {\n      if (p.y < q.y) return { 1, 0, -p.x, p, q, true };\n      else return{ 1, 0, -p.x, q, p, true };\n    }\n    else {\n      if (p.x < q.x) return { (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, p, q, true };\n      else return{ (q.y - p.y), (p.x - q.x), q.x * p.y - p.x * q.y, q, p, true };\n    }\n  }\n}\n\n\n\nint main() {\n  int q; cin >> q;\n  cout << setprecision(18);\n  Loop(i, q) {\n    coordinate p, q;\n    p.valid = true;\n    q.valid = true;\n    line s, t;\n    cin >> p.x >> p.y >> q.x >> q.y;\n    s = line_through_2_coordinates(p, q);\n    cin >> p.x >> p.y >> q.x >> q.y;\n    t = line_through_2_coordinates(p, q);\n    coordinate r = cross_of_2_lines(s, t);\n    if (!r.valid) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n// #define double long double\nusing namespace std;\n\nconst int maxN = 100003;\nconst double eps = 1e-8;\ninline double absolute(double x) { return x >= 0 ? x : -x; }\ninline double square(double x) { return x * x; }\n\nstruct Vector {\n    double x, y;\n    Vector() {}\n    Vector(double x, double y) : x(x), y(y) {}\n    friend Vector operator+(const Vector& a, const Vector& b) { return Vector(a.x + b.x, a.y + b.y); }\n    friend Vector operator-(const Vector& a, const Vector& b) { return Vector(a.x - b.x, a.y - b.y); }\n    friend Vector operator*(const Vector& a, const double& b) { return Vector(a.x * b, a.y * b); }\n    friend Vector operator/(const Vector& a, const double& b) { return Vector(a.x / b, a.y / b); }\n    inline double length() { return sqrt(square(x) + square(y)); }\n    inline void read() { cin >> x >> y; }\n    inline void write() { cout << fixed << setprecision(10) << x << ' ' << y << '\\n'; }\n};\ninline double distance(Vector a, Vector b) { return sqrt(square(b.x - a.x) + square(b.y - a.y)); }\ninline double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ninline double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ninline Vector project(Vector a, Vector b, Vector c) {\n    b = a - b;\n    return b * (dot(b, c - a) / square(b.length())) + a;\n}\ninline Vector reflect(Vector a, Vector b, Vector c) {\n    a = project(a, b, c);\n    return a * 2 - c;\n}\n\ninline bool intersect(Vector a, Vector b, Vector c, Vector d) {\n    if (max(min(a.x, b.x), min(c.x, d.x)) > min(max(a.x, b.x), max(c.x, d.x)) + eps || \n        max(min(a.y, b.y), min(c.y, d.y)) > min(max(a.y, b.y), max(c.y, d.y)) + eps || \n        cross(a - c, d - c) * cross(d - c, b - c) + eps < 0 || \n        cross(c - a, b - a) * cross(b - a, d - a) + eps < 0)\n        return 0;\n    return 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int Q;\n    Vector a, b, c, d;\n    for (cin >> Q; Q; --Q) {\n        a.read(), b.read(), c.read(), d.read();\n        printf(\"%d\\n\", intersect(a, b, c, d));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n, xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;++i){\n\t\tcin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n\t\t\n\t\tif( ((yp2 - yp0)*(xp1 - xp0) - (xp2 - xp0)*(yp1 - yp0)) * ((yp3 - yp0)*(xp1 - xp0) - (xp3 - xp0)*(yp1 - yp0)) <= 0 &&\n\t\t((yp0 - yp2)*(xp3 - xp2) - (xp0 - xp2)*(yp3 - yp2)) * ((yp1 - yp2)*(xp3 - xp2) - (xp1 - xp2)*(yp3 - yp2)) <= 0){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint projection(Point p1, Point p2, Point p0){\n    if(p1 == p0){\n        return p0;\n    }\n    if(p2 == p0){\n        return p0;\n    }\n    return p1 + (p2 - p1) / (p2 - p1).abs() * (p0 - p1).abs() * getCos(p2 - p1, p0 - p1);\n}\n\nPoint reflection(Point p1, Point p2, Point p0){\n    Point p = projection(p1, p2, p0);\n    return p0 + (p - p0) * 2;\n}\n\ndouble getDistanceSP(Point p1, Point p2, Point p0){\n    if(dot(p2 - p1, p0 - p1) < 0.0) return (p0 - p1).abs();\n    if(dot(p1 - p2, p0 - p2) < 0.0) return (p0 - p2).abs();\n    return (projection(p1, p2, p0) -  p0).abs();\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 3\n#define ONLINE_FRONT 4\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n        if(counterClockwise(p1, p2, p3) * counterClockwise(p1, p2, p4) <= 0){\n            if(counterClockwise(p3, p4, p2) * counterClockwise(p3, p4, p1) <= 0){\n                return true;\n            }\n        }\n\n    return false;\n}\n\ndouble getDistance(Point p0, Point p1, Point p2, Point p3){\n    if(intersect(p0, p1, p2, p3)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(p0, p1, p2), getDistanceSP(p0, p1, p3)),\n                min(getDistanceSP(p2, p3, p0), getDistanceSP(p2, p3, p1)));\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n        \n        Point p0 = Point(xp0, yp0);\n        Point p1 = Point(xp1, yp1);\n        Point p2 = Point(xp2, yp2);\n        Point p3 = Point(xp3, yp3);\n\n        if(intersect(p0, p1, p2, p3)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n}\n\n/*\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n\n        printf(\"%.10f\\n\", getDistance(Point(xp0, yp0), Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3)));\n    }\n\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <limits.h>\n#include <string>\n#include <string.h>\n#include <sstream>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\nconst double EPS = 1e-10;\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Vector {\n  public:\n  double x;\n  double y;\n\n  Vector(double y = 0.0, double x = 0.0){\n    this->y = y;\n    this->x = x;\n  }\n\n  Vector operator+(Vector p){\n    return Vector(y + p.y, x + p.x);\n  }\n\n  Vector operator-(Vector p){\n    return Vector(y - p.y, x - p.x);\n  }\n\n  Vector operator*(double a){\n    return Vector(a * y, a * x);\n  }\n\n  Vector operator/(double a){\n    return Vector(y / a, x / a);\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n};\n\n// ????????????a??¨b?????????\ndouble dot(Vector a, Vector b){\n  return a.x * b.x + a.y * b.y;\n}\n\n// ????????????a??¨b?????????\ndouble cross(Vector a, Vector b){\n  return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Vector p0, Vector p1, Vector p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n\n  if(cross(a, b) > EPS){\n    return COUNTER_CLOCKWISE;\n  }\n  if(cross(a, b) < -EPS){\n    return CLOCKWISE;\n  }\n  if(dot(a, b) < -EPS){\n    return ONLINE_BACK;\n  }\n  if(a.norm() < b.norm()){\n    return ONLINE_FRONT;\n  }\n\n  return ON_SEGMENT;\n}\n\nbool intersect(Vector p1, Vector p2, Vector p3, Vector p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n      ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint main(){\n  int n;\n  Vector p0, p1, p2, p3;\n\n  cin >> n;\n\n  for(int i = 0; i < n; i++){\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &p0.x, &p0.y, &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y);\n\n    if(intersect(p0, p1, p2, p3)){\n      cout << \"1\" << endl;\n    }else{\n      cout << \"0\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n// cout<<fixed<<setprecision(15)\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\n//点またはベクトル\nclass Point{\n  public:\n  double x,y;\n  \n  Point(double x=0, double y=0): x(x),y(y) {}\n  \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point &p){return Point(x-p.x,y-p.y);}\n  Point operator*(double a){return Point(a*x,a*y);}\n  Point operator/(double a){return Point(x/a,y/a);}\n  \n  bool operator<(const Point &p) const{\n    return x != p.x ? x<p.x : y<p.y;\n  }\n  \n  bool operator==(const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point Vector;\n//ベクトルの二乗和と絶対値\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\ndouble abs(Point p){return sqrt(norm(p));}\n//線分または直線\nstruct Segment{Point p1,p2;};\ntypedef Segment Line;\n//円\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(), double r=0.0): c(c), r(r) {}\n};\n//多角形\ntypedef vector<Point> Polygon;\n//内積\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n//外積\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n//直交判定\nbool isOrthgonal(Vector a,Vector b){return equals(dot(a,b), 0.0);}\n//平行判定\nbool isParallel(Vector a,Vector b){return equals(cross(a,b), 0.0);}\n//射影\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n//反射\nPoint reflect(Segment s,Point p){return p+(project(s,p)-p)*2.0;}\n//点と点の距離\ndouble getDisPP(Point a,Point b){return abs(a-b);}\n//直線と点の距離\ndouble getDisLP(Line l,Point p){return abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);}\n//線分と点の距離\ndouble getDisSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n  return getDisLP(s,p);\n}\n//線分と線分の距離\ndouble getDisSS(Segment s1,Segment s2){\n//  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDisSP(s1,s2.p1),getDisSP(s1,s2.p2)),\n             min(getDisSP(s2,s1.p1),getDisSP(s2,s1.p2)));\n}\n//反時計周りCounter-Clockwise\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS) return CLOCKWISE;\n  if(dot(a,b)<-EPS) return ONLINE_BACK;\n  if(norm(a)<norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//線分の交差判定\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n\nint main(){\n  Point p0,p1,p2,p3;\n  int q;\n  cin>>q;\n  \n  rep(i,q){\n    cin>>p0.x>>p0.y>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;\n    cout<<intersect(p0,p1,p2,p3)<<endl;\n  }\n    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nconst double eps = 1e-15;\n\nbool IsEq(double d1, double d2)\n{\n    if (d1 - d2 > -eps && d1 - d2 < eps){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nclass Point2D {\npublic:\n    double x, y;\n    Point2D() : x(0), y(0) {}\n    Point2D(double _x, double _y) : x(_x), y(_y) {}\n    virtual ~Point2D() {}\n};\n\nistream& operator >> (istream& input, Point2D& P)\n{\n    input >> P.x >> P.y;\n    return input;\n}\n\nclass Segment {\npublic:\n    Point2D P, Q;\n    Segment() {}\n    Segment(const Point2D& _P, const Point2D& _Q) : P(_P), Q(_Q) {}\n};\n\nistream& operator >> (istream& input, Segment& Seg)\n{\n    input >> Seg.P >> Seg.Q;\n    return input;\n}\n\nclass Vector2D : public Point2D {\npublic:\n    Vector2D(const Point2D& P) : Point2D(P) {}\n    Vector2D(const Segment Seg) : Point2D(Seg.Q.x - Seg.P.x, Seg.Q.y - Seg.P.y) {}\n    Vector2D(const Point2D Start, Point2D End) : Point2D(End.x - Start.x, End.y - Start.y) {}\n    double InnerProd(const Vector2D Vec) const\n    {\n        return x * Vec.x + y * Vec.y;\n    }\n    double OuterProd(const Vector2D Vec) const\n    {\n        return x * Vec.y - y * Vec.x;\n    }\n    double Length() const\n    {\n        return sqrt((*this).InnerProd(*this));\n    }\n};\n\ndouble Dist(const Point2D P, const Segment Seg)\n{\n    Vector2D V1(Seg);\n    Vector2D V2(Seg.P, P);\n    return V1.InnerProd(V2) / V1.Length();\n}\n\ndouble Dist(const Point2D P, const Point2D Q)\n{\n    Vector2D V(P, Q);\n    return V.Length();\n}\n\nbool IsPara(Segment Seg1, Segment Seg2)\n{\n    Vector2D V1(Seg1), V2(Seg2);\n    return IsEq(V1.OuterProd(V2), 0.);\n}\n\nbool IsOnSeg(Point2D P, Segment Seg)\n{\n    Vector2D V(Seg);\n    return IsEq(V.Length(), Dist(P, Seg.P) + Dist(P, Seg.Q));\n}\n\nbool IsIntersect(Segment Seg1, Segment Seg2) {\n    Vector2D P1(Seg1.P), P2(Seg2.P);\n    Vector2D V1(Seg1), V2(Seg2);\n    if (!IsPara(Seg1, Seg2)) {\n        double t = (P2.OuterProd(V2) - P1.OuterProd(V2)) / V1.OuterProd(V2);\n        double s = (P2.OuterProd(V1) - P1.OuterProd(V1)) / V1.OuterProd(V2);\n        return t > -eps && t < 1 + eps && s > -eps && s < 1 + eps;\n    } else {\n        if (IsOnSeg(Seg1.P, Seg2) || IsOnSeg(Seg1.Q, Seg2)) return true;\n        return false;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int q;\n    Segment Seg1, Seg2;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        cin >> Seg1 >> Seg2;\n        if (IsIntersect(Seg1, Seg2)) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> \ninline void read(T& x)\n{\n\tchar c = getchar(); T p = 1, n = 0;\n\twhile(c < '0' || c > '9'){if(c == '-') p = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9'){n = n * 10 + c - '0'; c = getchar();}\n\tx = p * n;\n}\ntemplate<class T, class U>\ninline void read(T& x, U& y){read(x), read(y);}\ntemplate<class T, class U, class V>\ninline void read(T& x, U& y, V& z){read(x), read(y), read(z);}\nconst double eps = 1e-10;\nstruct Point\n{\n\tdouble x, y;\n\tPoint(int a, int b){x = a, y = b;}\n\tPoint(double a = .0, double b = .0){x = a, y = b;}\n\tPoint operator+(const Point& r){return Point(x + r.x, y + r.y);}\n\tPoint operator-(const Point& r){return Point(x - r.x, y - r.y);}\n\tPoint operator*(double r){return Point(x * r, y * r);}\n\tdouble operator*(const Point& r){return x * r.y - y * r.x;}\n};\ntypedef Point Vector;\ninline double dot(Vector l, Vector r){return l.x * r.x + l.y * r.y;}\ninline double norm(Vector l){return dot(l, l);}\ninline int ccw(Point x, Point y, Point z)\n{\n\tdouble cross = (y - x) * (z - x); \n\tif(cross > -eps) return 1;\n\tif(cross < -eps) return -1;\n\treturn 0;\n}\nstruct Segment\n{\n\tPoint a, b;\n\tSegment(){}\n\tSegment(Point x, Point y){a = x, b = y;}\n};\ninline bool isIntersection(Segment l, Segment r)\n{return (ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0) && (ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0);}\nint main()\n{\n\tint q, x0, y0, x1, y1, x2, y2, x3, y3; read(q);\n\twhile(q--)\n\t{\n\t\tread(x0, y0), read(x1, y1), read(x2, y2), read(x3, y3);\n\t\tputs(isIntersection(Segment(Point(x0, y0), Point(x1, y1)), Segment(Point(x2, y2), Point(x3, y3))) ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_lp(s, t.a) || isis_lp(s, t.b) || isis_lp(t, s.a);\n}\n\nint main()\n{\n\tint q;\n\tld x1, x2, x3, x4, y1, y2, y3, y4;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tLine l1 = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tLine l2 = { (Point) { x3, y3 }, (Point) { x4, y4 } };\n\t\tcout << isis_ss(l1, l2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Intersection\n//#include<bits/stdc++.h>\n//#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n//#include<random>\n#include<cstdlib>\n#include<ctime>\n#include<fstream>\n#include<map>\n#include<stack>\n#include<queue>\n#define FAST ios::sync_with_stdio(false)\n#define DEV_RND ((int)rand()*RAND_MAX+rand())\n#define RND(L,R) (DEV_RND%((R)-(L)+1)+(L))\n//#define abs(a) ((a)>=0?(a):-(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define mem(a,b) memset(a,b,sizeof(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,n) for(int i=a;i<n;++i)\n#define repn(i,a,n,t) for(int i=a;i<n;i+=t)\n#define per(i,n,a) for(int i=n-1;i>=a;--i)\n#define pern(i,n,a,t) for(int i=n-1;i>=a;i-=t)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define li inline\n#define re register\nusing namespace std;\n//typedef uniform_int_distribution<int> RNDI;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\nconst int maxn = 1e5+5;\nconst int maxm = 100000+5;\nconst int inf=0x3f3f3f3f;\nconst double eps = 1e-9;\nconst double pi=acos(-1);\nconst int mod = 1e9+7;\n//int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n//li int f(int x){return x==par[x]?par[x]:par[x]=f(par[x]);}\n//mt19937 eng(time(0));\nli ll lowbit(ll x){return x&(-x);}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\n//li int RND(int L,int R){RNDI rnd(L,R);return rnd(eng);}\nvoid ex_gcd(ll a,ll b,ll &d,ll &x,ll &y){if(!b){d=a,x=1,y=0;}else{ex_gcd(b,a%b,d,y,x);y-=x*(a/b);}}//x=(x%(b/d)+(b/d))%(b/d);\nli ll qpow(ll a,ll b,ll MOD=mod){ll res=1;a%=MOD;while(b>0){if(b&1)res=res*a%MOD;a=a*a%MOD;b>>=1;}return res;}\nli ll qmul(ll a,ll b,ll MOD=mod){return (a*b-(ll)((long double)a/MOD*b)*MOD+MOD)%MOD;}\nli ll Qpow(ll a,ll b,ll MOD){ll res=1;while(b>0){if(b&1) res=qmul(res,a,MOD);a=qmul(a,a,MOD);b>>=1;}return res;}\nli ll inv(ll x,ll p){return qpow(x,p-2,p);}\nli ll Jos(ll n,ll k,ll s=1){ll res=0;rep(i,1,n+1) res=(res+k)%i;return (res+s)%n;}\nli void debug(){ofstream fout(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\");fout.close();}\nnamespace IO\n{\n\tli int read()\n\t{\n\t\tint x=0,sign=1;char c=getchar();\n\t\twhile(c>'9'||c<'0') {if(c=='-') sign=-1;c=getchar();}\n\t\twhile('0'<=c&&c<='9') x=x*10+c-'0',c=getchar();\n\t\treturn x*sign;\n\t}\n\ttemplate<typename T>\n\tli void write(T x,char t='\\n')\n\t{\n\t\tif(x<0){x=-x;putchar('-');};\n\t\tstatic int sta[25];int top=0;\n\t\tdo{sta[top++]=x%10,x/=10;}while(x);\n\t\twhile(top) putchar(sta[--top]+'0');\n\t\tputchar(t);\n\t}\n}\nusing namespace IO;\n/*-------------head-------------*/\nli int sign(db k){return k<-eps?-1:k>eps;}\nli int cmp(db a,db b){return sign(a-b);}\nli bool inmid(db l,db m,db r){return sign(l-m)*sign(r-m)<=0;}\n//点类 \nstruct P\n{\n\tdb x,y;\n\tP(){}\n\tP(db _x,db _y):x(_x),y(_y){}\n\tP operator + (const P& a) const {return (P){x+a.x,y+a.y};}\n\tP operator - (const P& a) const {return (P){x-a.x,y-a.y};}\n\tP operator * (db a) const {return (P){x*a,y*a};}\n\tP operator / (db a) const {return (P){x/a,y/a};}\n\tbool operator < (const P& a)const\n\t{return cmp(x,a.x)?cmp(x,a.x)==-1:cmp(y,a.y)==-1;}\n\tbool operator == (const P& a)const\n\t{return cmp(x,a.x)==0&&cmp(y,a.y)==0;}\n\tdb alpha(){return atan2(y,x);}\n\tdb abs2(){return x*x+y*y;}\n\tdb abs(){return sqrt(abs2());}\n\tdb disTo(P a){return (*this-a).abs();}\n\tdb dot(P a){return x*a.x+y*a.y;}\n\tdb det(P a){return x*a.y-y*a.x;}\n\tP unit(){return *this/abs();}\n\tP rot(db an){return (P){x*cos(an)-y*sin(an),x*sin(an)+y*cos(an)};}\n\tP rot90(){return (P){-y,x};}\n\tint quad() const {return sign(y)==1||(sign(y)==0&&sign(x)>=0);}\n\tvoid read(){db _x,_y;scanf(\"%lf%lf\",&_x,&_y);x=_x;y=_y;}\n\tvoid write(){printf(\"%.10f %.10f\\n\",x,y);}\n};\nbool angcmp(P a,P b){return a.quad()!=b.quad()?a.quad()<b.quad():sign(a.det(b))==-1;}\nbool inmid(P a,P m,P b){return inmid(a.x,m.x,b.x)&&inmid(a.y,m.y,b.y);}\ndb rad(P a,P b){return atan2l(a.det(b),a.dot(b));}\ndb cro(P q,P p1,P p2){return (p1.x-q.x)*(p2.y-q.y)-(p1.y-q.y)*(p2.x-q.x);}\nint croOp(P q,P p1,P p2){return sign(cro(q,p1,p2));}\n//线段相交\nbool intersect(db l1,db r1,db l2,db r2)\n{\n\tif(l1>r1)swap(l1,r1);if(l2>r2)swap(l2,r2);\n\treturn !(cmp(r1,l2)==-1||cmp(r2,l1)==-1);\n}\nbool isSS(P p1,P p2,P q1,P q2)\n{\n\treturn intersect(p1.x,p2.x,q1.x,q2.x)&&intersect(p1.y,p2.y,q1.y,q2.y)\n\t&&croOp(p1,p2,q1)*croOp(p1,p2,q2)<=0\n\t&&croOp(q1,q2,p1)*croOp(q1,q2,p2)<=0;\n}\nbool isSS_strict(P p1,P p2,P q1,P q2)\n{\n\treturn croOp(p1,p2,q1)*croOp(p1,p2,q2)<0\n\t&&croOp(q1,q2,p1)*croOp(q1,q2,p2)<0;\n}\nP p1,p2,q1,q2;\nint n; \nli void solve()\n{\n\tp1.read(),p2.read();\n\tq1.read(),q2.read();\n\tif(isSS(p1,p2,q1,q2)) write(1);\n\telse write(0);\n\t//puts(\"\");\n}\nint main()\n{\n\t//srand(time(0));debug();\n\t//clock_t start_time=clock();\n\t//freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\",\"r\",stdin);\n\tfor(int QwQ=read();QwQ;QwQ--) solve();\n\t//while(~scanf(\"%d\",&n)) solve();\n\t//cerr<<\"Time:\"<<clock()-start_time<<\"ms\\n\";\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint onCheck(P &p, P &q, P &r){\n\tbool a = ((q-p).det(r-p)==0);\n\tbool b = ((p-q).dot(r-q) >=0 );\n\tbool c = ((p-r).dot(q-r)  >= 0 );\n\tif(a&&b&&c){\n\t\treturn 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tbool a =onCheck(p0,p2, p3) ;\n\t\tbool b =onCheck(p1,p2, p3) ;\n\t\tbool c = onCheck(p2,p0, p1) ;\n\t\tbool d = onCheck(p3,p0, p1);\n\t\tif (!a && !b && !c && !d){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tbool e = onCheck(r, p0, p1);\n\tbool f = onCheck(r, p2, p3);\n\tif(e && f){\n\t\treturn 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\n/*\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif((p2-p1).det(p2-p0)!=0) return 0;\n\t\tif(((p2-p0).dot(p2-p1)<=0)||((p3-p0).dot(p3-p1)<=0) || ((p1-p2).dot(p1-p3)<=0)){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n*/\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nint main()\n{\n\tint q;\n\tld x1, x2, x3, x4, y1, y2, y3, y4;\n\tcout << fixed << setprecision(10);\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tLine l1 = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tLine l2 = { (Point) { x3, y3 }, (Point) { x4, y4 } };\n\t\tcout << eq(dist_ss(l1, l2), 0.0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a)-(b)) < EPS)\n\n  class Point{\n  public:\n    double x,y;\n\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const{\n      return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n      return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS);\n    }\n\n    friend ostream& operator << (ostream &os,Point &p){\n      return os << p.x << \" \" << p.y << \"\\n\";\n    }\n\n    friend istream& operator >> (istream &is,Point &p){\n      return is >> p.x >> p.y;\n    }\n  };\n  typedef Point Vector;\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &p){\n      return os << p.p1.x << \" \" << p.p1.y << \" \" << p.p2.x << \" \" << p.p2.y << \"\\n\";\n    }\n\n    friend istream& operator >> (istream &is,Segment &p){\n      return is >> p.p1.x >> p.p1.y >> p.p2.x >> p.p2.y;\n    }\n  };\n  typedef Segment Line;\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){\n      return os << c.c.x << c.c.y << c.r << \"\\n\";\n    }\n\n    friend istream& operator >> (istream &is,Circle &c){\n      return is >> c.c.x >> c.c.y >> c.r;\n    }\n  };\n\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){\n    return  a.x * a.x + a.y * a.y;\n  }\n\n  double abs(Vector a){\n    return sqrt(norm(a));\n  }\n\n  double dot(Vector a,Vector b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  double cross(Vector a,Vector b){\n    return a.x * b.y - a.y * b.x;\n  }\n\n  bool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n  }\n\n  bool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1 - a1,b1 - b2);\n  }\n\n  bool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0);\n  }\n\n  bool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n  }\n\n  bool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1 - a2 , b1 - b2);\n  }\n\n  bool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n  }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base / norm(base));\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n\n  bool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n  }\n\n  double getDistance(Vector a,Vector b){\n    return abs(a - b);\n  }\n\n  double getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1));\n  }\n\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n              min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    // assert(intersect(c,l));\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){\n    return atan2(p.y,p.x);\n  }\n\n  Vector polar(double a,double r){\n    return Point(cos(r) * a, sin(r) * a);\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    // assert(intersect(c1,c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n\n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y < b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Line a,b;\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> a >> b;\n    if(intersect(a,b))puts(\"1\");\n    else puts(\"0\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  cgl_1_b.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Oct 23 00:28:22 2017\n//\n#include <cmath>\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n#define EPS 1e-10\n#define equals(x, y) (fabs(x - y) < EPS)\n\nstruct vector_t {\n  double x;\n  double y;\n\n  vector_t(double a, double b) : x(a), y(b)\n  {\n  }\n\n  double norm2()\n  {\n    return x * x + y * y;\n  }\n\n  double dot(vector_t a)\n  {\n    return x * a.x + y * a.y;\n  }\n\n  double cross(vector_t a)\n  {\n    return x * a.y - y * a.x;\n  }\n\n  vector_t operator*(double a)\n  {\n    return vector_t(a * x, a * y);\n  }\n};\n\nstruct point_t {\n  double x;\n  double y;\n\n  point_t operator+(const point_t a)\n  {\n    return point_t({x + a.x, y + a.y});\n  }\n\n  void print()\n  {\n    cout << fixed << setprecision(10) << x << \" \" << y << endl;\n  }\n\n  point_t operator+(const vector_t vec)\n  {\n    return point_t({x + vec.x, y + vec.y});\n  }\n\n  vector_t operator-(const point_t p)\n  {\n    return vector_t({x - p.x, y - p.y});\n  }\n\n  point_t project(point_t p1, point_t p2)\n  {\n    vector_t vec1(x - p1.x, y - p1.y);\n    vector_t vec2(p2.x - x, p2.y - y);\n    return point_t({x, y}) + vec1 * (vec1.dot(vec2) / vec1.norm2());\n  }\n\n  point_t reflect(point_t p1, point_t p2)\n  {\n    point_t proj = project(p1, p2);\n    return p2 + (proj - p2) * 2.0;\n  }\n};\n\nenum pos_t {\n  CCLOCKWISE = -1,\n  CLOCKWISE = 1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\npos_t ccw(point_t p0, point_t p1, point_t p2)\n{\n  if ((p1 - p0).cross(p2 - p0) > EPS) {\n    return CCLOCKWISE;\n  } else if ((p1 - p0).cross(p2 - p0) < -EPS) {\n    return CLOCKWISE;\n  } else if ((p1 - p0).dot(p2 - p0) < -EPS) {\n    return ONLINE_BACK;\n  } else {\n    if ((p1 - p0).norm2() < (p2 - p0).norm2()) {\n      return ONLINE_FRONT;\n    } else {\n      return ON_SEGMENT;\n    }\n  }\n}\n\nbool intersection(point_t p0, point_t p1, point_t p2, point_t p3)\n{\n  // cout << \"--\" << endl;\n  // cout << ccw(p0, p1, p2) << endl;\n  // cout << ccw(p0, p1, p3) << endl;\n  // cout << ccw(p2, p3, p0) << endl;\n  // cout << ccw(p2, p3, p1) << endl;\n  // cout << \"--\" << endl;\n  return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) && (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0);\n}\n\nstruct segment_t {\n  point_t x;\n  point_t y;\n};\n\nint32_t main()\n{\n  uint32_t q;\n  cin >> q;\n\n  for (uint32_t i = 0; i < q; i++) {\n    double x, y;\n    cin >> x >> y;\n    point_t p0({x, y});\n    cin >> x >> y;\n    point_t p1({x, y});\n    cin >> x >> y;\n    point_t p2({x, y});\n    cin >> x >> y;\n    point_t p3({x, y});\n    cout << (int)intersection(p0, p1, p2, p3) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <array>\n#include <vector>\n#include <cmath>\n\nconst double EPSILON = 1e-10;\n\ninline bool equals(double a, double b) {\n    return std::fabs(a - b) < EPSILON;\n}\n\nstruct Point {\n    double x;\n    double y;\n\n    bool operator < (const Point& p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point& p) const {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\nPoint operator + (const Point& p1, const Point& p2) {\n    return Point{p1.x + p2.x, p1.y + p2.y};\n}\n\nPoint operator - (const Point& p1, const Point& p2) {\n    return Point{p1.x - p2.x, p1.y - p2.y};\n}\n\nPoint operator * (const Point& p1, double k) {\n    return Point{p1.x * k, p1.y * k};\n}\n\nstruct Segment {\n    Point p1, p2;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\nusing Vector = Point;\nusing Line = Segment;\nusing Polygon = std::vector<Point>;\n\n\ndouble norm(const Vector& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const Vector& p) {\n    return std::sqrt(norm(p));\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n\nVector projection(const Segment& s, const Point& p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nVector reflection(const Segment& s, const Point& p) {\n    return p + (projection(s, p) - p) * 2.0;\n}\n\nbool is_orthogonal(const Vector& a, const Vector& b) {\n    return equals(dot(a, b), 0.0);\n}\n\nbool is_orthogonal(const Segment& s1, const Segment& s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool is_parallel(const Vector& a, const Vector& b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool is_parallel(const Segment& s1, const Segment& s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nenum {\n    COUNTER_CLOCKWISE = 1,\n    CLOCKWISE = -1,\n    ONLINE_BACK = 2,\n    ONLINE_FRONT = -2,\n    ON_SEGMENT = 0,\n};\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n    auto a = p1 - p0;\n    auto b = p2 - p0;\n    if (cross(a, b) > EPSILON) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPSILON) return CLOCKWISE;\n    if (dot(a, b) < -EPSILON) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    auto area = [](const Point& p0, const Point& p1, const Point& p2) {\n        auto a = p1 - p0;\n        auto b = p2 - p0;\n        return cross(a, b);\n    };\n    return (area(p1, p2, p3) * area(p1, p2, p4) <= 0 &&\n            area(p3, p4, p1) * area(p3, p4, p2) <= 0);\n}\n\nbool intersect(const Segment& s1, const Segment& s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return abs(a - b);\n}\n\ndouble distanceLP(const Line& l, const Point& p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment& s, const Point& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distanceLP(s, p);\n}\n\ndouble distance(const Segment& s1, const Segment& s2) {\n    using std::min;\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n               min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)));\n}\n\n\nint main() {\n    using namespace std;\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        array<Point, 4> points;\n        for (auto& p : points) {\n            cin >> p.x >> p.y;\n        }\n        Segment s1{points[0], points[1]};\n        Segment s2{points[2], points[3]};\n        cout << intersect(s1, s2) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nclass Point{\npublic:\n\tPoint(const int argx = 0, const int argy = 0):x(argx),y(argy){};\n\tint x, y;\n};\nclass Line{\npublic:\n\tLine(const int x1, const int y1, const int x2, const int y2):p1(x1, y1),p2(x2, y2),X(x1 - x2),Y(y1 - y2){\n\t\tif (x1 > x2){\n\t\t\tmaxx = (x1);\n\t\t\tminx = (x2);\n\t\t}else{\n\t\t\tmaxx = (x2);\n\t\t\tminx = (x1);\n\t\t}\n\t\tif (y1 > y2){\n\t\t\tmaxy = (y1);\n\t\t\tminy = (y2);\n\t\t}else{\n\t\t\tmaxy = (y2);\n\t\t\tminy = (y1);\n\t\t}\n\t};\n\tbool is_parallel(const Line &other) const {\n\t\treturn (X * other.Y) == (Y * other.X);\n\t}\n\tbool is_over_x(const Line &other) const {\n\t\treturn (X * X + other.X * other.X > (maxx - other.maxx) * (maxx - other.maxx) + (minx - other.minx) * (minx - other.minx));\n\t}\n\tbool is_over_y(const Line &other) const {\n\t\treturn (Y * Y + other.Y * other.Y > (maxy - other.maxy) * (maxy - other.maxy) + (miny - other.miny) * (miny - other.miny));\n\t}\n\tint get_Xy(const int &other_x) const {return (Y * other_x + (X * p2.y - Y * p2.x));}\n\tint get_Yx(const int &other_y) const {return (X * other_y + (Y * p2.x - X * p2.y));}\n\tbool is_cross_x(const Line &other) const {\n\t\treturn (other.X * p1.y - other.get_Xy(p1.x)) * (other.X * p2.y - other.get_Xy(p2.x)) <= 0;\n\t}\n\tbool is_cross_y(const Line &other) const {\n\t\treturn (other.Y * p1.x - other.get_Yx(p1.y)) * (other.Y * p2.x - other.get_Yx(p2.y)) <= 0;\n\t}\n\tbool is_intersection(const Line &other) const {\n\t\tif (is_parallel(other)){\n\t\t\tif (X * Y == 0){\n\t\t\t\tif (X == 0){\n\t\t\t\t\treturn p1.x == other.p1.x and is_over_y(other);\n\t\t\t\t}else{\n\t\t\t\t\treturn p1.y == other.p1.y and is_over_x(other);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn is_cross_x(other) and is_over_x(other);\n\t\t\t}\n\n\t\t}else{\n\t\t\tif (Y == 0 or other.Y == 0){\n\t\t\t\treturn is_cross_x(other) and other.is_cross_x((*this));\n\t\t\t}else{\n\t\t\t\treturn is_cross_y(other) and other.is_cross_y((*this));\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\tPoint p1, p2;\n\tint X, Y, maxx, maxy, minx, miny;\n\tint x_diff() const {if (X < 0){return -X;}else{return X;}}\n\tint y_diff() const {if (Y < 0){return -Y;}else{return Y;}}\n};\nint main(){\n\tint q;\n\tstd::scanf(\"%d\", &q);\n\tfor (auto i = 0; i < q; ++i){\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tstd::scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tLine l1(x0, y0, x1, y1), l2(x2, y2, x3, y3);\n\t\tif (l1.is_intersection(l2)){\n\t\t\tstd::printf(\"1\\n\");\n\t\t}else{\n\t\t\tstd::printf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\n\t\n\tPoint(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p)==ON;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\n\nint main(){\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\tint q;\n\tcin >> q;\n\n\trep(i,q){\n\t\tPoint p1,p2,p3,p4;\n\t\tcin >> p1 >> p2 >> p3 >> p4;\n\t\tcout << intersect(Segment(p1,p2),Segment(p3,p4)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//点を表す構造体\nclass Point {\n  public:\n  double x,y;\n  Point(double x=0,double y=0): x(x),y(y){}\n\n  //各種演算\n  Point operator+ (Point p) { return Point(x+p.x,y+p.y); }\n  Point operator- (Point p) { return Point(x-p.x,y-p.y); }\n  Point operator* (double a) {return Point(a*x,a*y); }\n  Point operator/ (double a) {return Point(x/a,y/a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x+y*y; }\n\n  bool operator< (const Point &p) const{\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n\n  bool operator> (const Point &p) const{\n    return x!=p.x ? x>p.x : y>p.y;\n  }\n\n  bool operator== (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\n//ベクトルを表す構造体\ntypedef Point Vector;\n\n//線分を表す構造体\nstruct Segment{\n  Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n  Point p1,p2;\n};\n\n//直線を表す構造体\ntypedef Segment Line;\n\n//円を表すクラス\nclass Circle{\n  public:\n  //円の中心\n  Point c;\n  //半径\n  double r;\n  Circle(Point c=Point(),double r=0.0): c(c),r(r) {}\n};\n\n//多角形の表現\ntypedef vector<Point> Polygon;\n\n//ベクトルaとbの内積\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\n\n//ベクトルaとbの外積\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\n//ベクトルaとbの直交判定\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//ベクトルaとbの平行判定\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n//線分sに対する点pの射影\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/base.norm();\n  return s.p1+base*r;\n}\n\n//線分sを対称軸とした点pの線対称の点\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n//反時計回りCCW\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS) return CLOCKWISE;\n  if(dot(a,b)<-EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\n//点aと点bの距離\ndouble getDistace(Point a,Point b){\n  return (a-b).abs();\n}\n//直線lと点pの距離\ndouble getDistaceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n} \n//線分sと点pの距離\ndouble getDistaceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n  if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n  return getDistaceLP(s,p);\n}\n//線分s1と線分s2の距離\ndouble getDistace(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistaceSP(s1,s2.p1),getDistaceSP(s1,s2.p2))\n  ,min(getDistaceSP(s2,s1.p1),getDistaceSP(s2,s1.p2)));\n}\n\n//線分s1と線分s2の交点(ダメらしい)\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false); \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x0,x1,x2,x3,y0,y1,y2,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    Point p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n    cout<<intersect(p0,p1,p2,p3)<<'\\n';\n  }\n  return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef int scalar;\n\nclass point{\n\tpublic:\n\tscalar x,y;\n\tvoid input(void){\n\t\tcin >> x >> y;\n\t}\n\tvoid print(void){\n\t\tcout << x << \" \" << y;\n\t}\n\tpoint(scalar ax=0, scalar ay=0): x(ax), y(ay){};\n\tpoint operator =(point a){\n\t\tx = a.x;\n\t\ty = a.y;\n\t\treturn *this;\n\t}\n\tpoint operator +(point a){return point(x+a.x, y+a.y);}\n\tpoint operator -(point a){return point(x-a.x, y-a.y);}\n\t\n};\n\nint cross(point p, point q, point r, point s){\n\tpoint a,b,c;\n\tdouble det;\n\tdouble inv1,inv2,inv3,inv4;\n\tdouble t,tau;\n\ta = q - p;\n\tb = r - s;\n\tc = r - p;\n\tdet = a.x * b.y - b.x * a.y;\n\tif(det == 0)return 0;//??????????????????????????§????????´???????????????????????????????????????\n\telse{\n\t\tinv1 = b.y / det;\n\t\tinv2 = -b.x / det;\n\t\tinv3 = -a.y / det;\n\t\tinv4 = a.x / det;\n\t\tt   = inv1 * c.x + inv2 * c.y;\n\t\ttau = inv3 * c.x + inv4 * c.y;\n\t\tif(0 <= t && t <= 1 && 0 <= tau && tau <=1)return 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint q;\n\tpoint p0, p1, p2, p3;\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tp0.input();\n\t\tp1.input();\n\t\tp2.input();\n\t\tp3.input();\n\t\tcout << cross(p0, p1, p2,p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint baseP;\nbool sortT(Point a, Point b){return (gt(cross(a - baseP, b - baseP), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    baseP = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p1)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p3) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint n;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tPoint p0, p1, p2, p3;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &p0.x, &p0.y, &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y);\n\t\tif (isIntersectSS(p0, p1, p2, p3)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n//const\n#define EPS 1e-8\n#define EQ (abs((a) - (b)) < EPS)\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ninline int signum(double x) { return (abs(x) < EPS) ? 0 : (x > 0) ? 1 : -1; }\n\n//-----definition-----\ntypedef complex<double> P;\n\n//-----standard-----\npair<P, P> norm_vec(P a) {\n    return make_pair(a * P(0, 1), a * P(0, -1));\n}\n\nP unit_vec(P a) { a / abs(a); }\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    int sign = signum(cross(b, c));\n    if (sign != 0) return sign;\n    if (signum(dot(b, c)) < 0) return -2;//left\n    if (abs(b) < abs(c)) return 2;//right\n    return 0; //mid\n}\n\n//-----line-----\nbool is_paral(P a1, P a2, P b1, P b2) {\n    return signum(cross(a2 - a1, b2 - b1)) == 0;\n}\n\nbool is_orth(P a1, P a2, P b1, P b2) {\n    return signum(dot(a2 - a1, b2 - b1)) == 0;\n}\n\nbool is_p_on_li(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    return signum(cross(b, c)) == 0;\n}\n\nbool is_p_on_li_s(P a, P b, P c) {\n    return abs(c - a) + abs(b - c) < abs(b - a) + EPS;\n}\n\ndouble dis_p_li(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    return abs(cross(b, c)) / abs(b);\n}\n\ndouble dis_p_li_ss(P a, P b, P c) {\n    P x1 = b - a;\n    P y1 = c - a;\n    P x2 = a - b;\n    P y2 = c - b;\n    if (cross(x1, y1) < EPS) return abs(y1);\n    if (cross(x2, y2) < EPS) return abs(y2);\n    return dis_p_li(a, b, c);\n}\n\nbool is_inter_li_ss(P a1, P a2, P b1, P b2) {\n    return (ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0) && (ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0);\n\n}\n\nint main() {\n\n    int Q;\n    cin >> Q;\n\n    while (Q--) {\n\n        vector<P> p(4);\n        for (int i = 0; i < 4; i++) {\n            double x, y;\n            cin >> x >> y;\n            p[i] = P(x, y);\n        }\n\n        if (is_inter_li_ss(p[0], p[1], p[2], p[3])) {\n            cout << 1 << endl;\n        } else {\n            cout << 0 << endl;\n        }\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    int q;\n\n    cin >> q;\n\n    //内積\n    for( int i = 0; i < q; i++ )\n    {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        double a, b, c, d, x, y;\n        a = x1 - x0;\n        b = y1 - y0;\n        c = x3 - x2;\n        d = y3 - y2;\n\n        double sx1, lx1; \n        if( x0 < x1 )\n        {\n            sx1 = x0;\n            lx1 = x1;\n        }\n        else\n        {\n            sx1 = x1;\n            lx1 = x0;\n        }\n\n        double sx2, lx2;\n        if( x2 < x3 )\n        {\n            sx2 = x2;\n            lx2 = x3;\n        }\n        else\n        {\n            sx2 = x3;\n            lx2 = x2;\n        }\n\n        double sy1, ly1;\n        if( y0 < y1 )\n        {\n            sy1 = y0;\n            ly1 = y1;\n        }\n        else\n        {\n            sy1 = y1;\n            ly1 = y0;\n        }\n\n        double sy2, ly2;\n        if( y2 < y3 )\n        {\n            sy2 = y2;\n            ly2 = y3;\n        }\n        else\n        {\n            sy2 = y3;\n            ly2 = y2;\n        }\n\n        if( a == 0 )\n        {\n            if( c == 0 )\n            {\n                if( x0 != x2 || x0 == x2 && ly2 < sy1 || x0 == x2 && ly1 < sy2 )\n                    cout << 0 << endl;\n                else\n                    cout << 1 << endl;\n            }\n            else if( d == 0 && sy1 <= y2 && y2 <= ly1 && sx2 <= x0 && x0 <= lx2 )\n                cout << 1 << endl;\n            else if( d == 0 )\n                cout << 0 << endl;\n            else\n            {\n                x = x0;\n                y = d * x0 / c + y2 - d * x2 / c;\n                if( sx2 <= x && x <= lx2 && sy1 <= y && y <= ly1 )\n                    cout << 1 << endl;\n                else\n                    cout << 0 << endl;\n            }\n        }\n        else if( b == 0 )\n        {\n            if( c == 0 && sx1 <= x2 && x2 <= lx1 && sy2 <= y0 && y0 <= ly2 )\n                cout << 1 << endl;\n            else if( c == 0 )\n                cout << 0 << endl;\n            else if( d == 0 )\n            {\n                if( y0 != y2 )\n                    cout << 0 << endl;\n                else\n                    if( sx1 <= sx2 && sx2 <= lx1 || sx2 <= sx1 && sx1 <= lx2 )\n                        cout << 1 << endl;\n                    else\n                        cout << 0 << endl;\n            }\n            else\n            {\n                x = ( y0 - y2 + d * x2 / c ) / ( d / c );\n                y = y0;\n                if( sx1 <= x && x <= lx1 && sy2 <= y && y <= ly2 )\n                    cout << 1 << endl;\n                else\n                    cout << 0 << endl;\n            }\n        }\n        else if( c == 0 )\n        {\n            x = x2;\n            y = b * x / a + y0 - b * x0 / a;\n            if( sx1 <= x && x <= lx1 && sy2 <= y && y <= ly2 )\n                cout << 1 << endl;\n            else\n                cout << 0 << endl;\n        }\n        else if( d == 0 )\n        {\n            x = ( y2 - y0 + b * x0 / a ) / ( b / a );\n            y = y2;\n            if( sx2 <= x && x <= lx2 && sy1 <= y && y <= ly1 )\n                cout << 1 << endl;\n            else\n                cout << 0 << endl;\n        }\n        else\n        {\n            if( b / a == d / c )\n            {\n                if( y0 - b * x0 / a != y2 - d * x2 / c )\n                    cout << 0 << endl;\n                else\n                {\n                    if( sx1 <= sx2 && sx2 <= lx1 || sx1 <= lx2 && lx2 <= lx1 )\n                        cout << 1 << endl;\n                    else if( sx2 <= sx1 && sx1 <= lx2 )\n                        cout << 1 << endl;\n                    else\n                        cout << 0 << endl;\n                }\n            }\n            else\n            {\n                x = - ( y0 - y2 + d * x2 / c - b * x0 / a ) / ( b / a - d / c );\n                y = b * x / a + y0 - b * x0 / a;\n                if( sx1 <= x && x <= lx1 && sy2 <= y && y <= ly2 )\n                    cout << 1 << endl;\n                else\n                    cout << 0 << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = Point(b-a);\n\tPoint v2 = Point(c-a);\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m) {\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(abs(s1)<EPS && abs(s2)<EPS) return false;\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nbool crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return false;\n    return crosspoint_ll(l,m,p);\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0;\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1;\n    return 2;\n}\n\nint contains(Polygon g,Point p){\n\tfor(int i=0;i<g.size();i++){\n\t\t\n\t}\n}\n \nint main(){\n\tLine l,m;\n\tint Q;\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tl.input(); m.input();\n\t\tif(intersect_ss(l,m)==true) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point{\n    public:\n    double x,y;\n    Point(double x=0,double y=0):x(x),y(y){}\n    Point operator+(const Point &p){\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator-(const Point &p){\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator*(const double &a){\n        return Point(a*x,a*y);\n    }\n    Point operator/(const double &a){\n        return Point(x/a,y/a);\n    }\n    double abs(){\n        return sqrt(norm());\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n    bool operator<(const Point &p){\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator==(const Point &p){\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\ntypedef Point Vector;\nstruct Segment{\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;   \n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2;\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1))/(l.p2-l.p1).abs();\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0){\n        return (p-s.p1).abs();\n    }\n    if(dot(s.p1-s.p2,p-s.p2)<0){\n        return (p-s.p2).abs();\n    }\n    return getDistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS) return 2;\n    if(a.norm()<b.norm()) return -2;\n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n        ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n        min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint main(){\n    int q;\n    double a,b,c,d,e,f,g,h;\n    cin>>q;\n    Point p1,p2,p3,p4;\n    for(int i=0;i<q;i++){\n        cin>>a>>b>>c>>d>>e>>f>>g>>h;\n        p1=Point(a,b);\n        p2=Point(c,d);\n        p3=Point(e,f);\n        p4=Point(g,h);\n        cout<<intersect(p1,p2,p3,p4)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n \n#define eps (1e-10)\n#define INF (1e20)\n\nstatic const double PI = acos(-1);\nbool eq(double a,double b){\n  return ( -eps < a-b && a-b < eps);\n}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n};\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n  Vector base(){\n    return p2-p1;\n  }\n};\ntypedef Segment Line;\n\nbool eq(Point a,Point b){ return (eq(a.x,b.x)&&eq(a.y,b.y)); }\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b){\n  return eq(cross(a,b),0);\n}\n\nVector unit(Vector v){\n  if(eq(abs(v),0))return v;\n  else return v/abs(v);\n}\n\nPoint getCrossPoint(Line a,Line b){\n  return a.p1+(a.p2-a.p1)*(cross(b.p2-b.p1,b.p1-a.p1)/cross(b.p2-b.p1,a.p2-a.p1));\n} \n\nbool onSegment(Segment a,Point p){\n  return eq( abs(a.p1-p)+abs(a.p2-p) , abs(a.p1-a.p2) );\n}\n\nbool intersect(Segment a,Segment b){\n  if(isParallel(a.base(),b.base())){\n    return (onSegment(a,b.p1)\n            ||onSegment(a,b.p2)\n            ||onSegment(b,a.p1)\n            ||onSegment(b,a.p2));\n  }\n  Point p=getCrossPoint(a,b);\n  return onSegment(a,p);\n}\n\nvoid scan(Segment &a){\n  cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y;\n}\n\nint main(){\n  Segment a,b;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    scan(a);\n    scan(b);\n    cout<<intersect(a,b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint q;\n\tint ans[1000];\n\tint x0,x1,x2,x3,y0,y1,y2,y3;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tans[i]=0;\n\t\tscanf(\"%d %d %d %d %d %d %d %d\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tif(x1==x0){\n\t\t\tdouble k=(y3-y2)/(x3-x2);\n\t\t\tdouble d=k*(x0-x3)+y3;\n\t\t\tif((d>=y0&&d<=y1)||(d>=y1&&d<=y0)){\n\t\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\tif(x2==x3){\n\t\t\t  double t=(y1-y0)/(x1-x0);\n\t\t\t  double e=t*(x2-x1)+y1;\n\t\t\t  if((e>=y2&&e<=y3)||(e>=y3&&e<=y2)){\n\t\t\t  \tans[i]=1;\n\t\t\t  }\n\t\t\t }\n\t\tif(x1!=x0&&x3!=x2){\n\t\tdouble t=(y1-y0)/(x1-x0);\n\t\tdouble k=(y3-y2)/(x3-x2);\n\t\tif(t!=k){\n\t\tdouble c=(t*x1+y1-k*x3+y3)/(t-k); //?????????x??§?¨?\n\t\tif((c>=x0&&c<=x1)||(c>=x1&&c<=x0)){\n\t\t\tans[i]=1;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\ntypedef struct point{ // 繝吶け繝医Ν(蜴溽せ・峨繧・xy蠎ｧ讓・\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x,double y) :x(x),y(y){};\n\t//繝吶け繝医Ν逧・ｨ育ｮ・\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y) ;}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y) ;}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y ,x*p.y+y*p.x ) ;}\n\tpoint operator * (double k){ return point(x*k,y*k) ;}\n\tpoint operator / (double k){ return point(x/k,y/k) ;}\n\t//螟ｧ蟆城未菫ゅx蠎ｧ讓吶蜆ｪ蜈・\n\tbool operator <  (const point &p) { return x!=p.x ? x<p.x : y < p.y;}\n\tbool operator >  (const point &p) { return x!=p.x ? x>p.x : y > p.y;}\n\tbool operator ==  (const point &p) { return fabs(x-p.x) <= EPS && fabs(y-p.y) <=  EPS ;}\n\t//髢｢謨ｰ\n\tdouble norm(){ return x*x+y*y;}\n\tdouble abs(){ return sqrt(norm() );}\t\n\tvoid print(){ cout<<x<<' '<<y<<endl; }\n\tvoid make(){ cin>>x>>y;}\n}point;\n\ntypedef struct segment{// 邱壼・ s -> e\n\tpoint s,e;\n\tsegment(){};\n\tsegment(point &s,point &e) : s(s),e(e){};\n\t//髢｢謨ｰ\n\tpoint vec() { return e-s;}\n\tdouble abs(){ return (e-s).abs();}\n\tvoid print(){ cout<<\"(\"<<s.x<<\",\"<<s.y<<\") (\"<<e.x<<\",\"<<e.y<<\")\"<<endl;}\n\tvoid make(){ s.make(),e.make(); }\n\tvoid swap() { point tmp = s; s = e;e = tmp;}\n\t\n}segment;\n//蜀・ｩ・\ndouble dot(point &a,point &b){return a.x*b.x + a.y*b.y; }\n//螟也ｩ・\ndouble cross(point &a,point &b){return a.x*b.y-a.y*b.x; }\n\n\n// p1~p2 荳翫↓縲p3縺後≠繧九°蛻､螳・\ndouble direction(point &p1,point &p2,point &p3){ point a = p3-p1, b = p2-p1; return cross( a ,b  ); }\nbool on_segment(point &p1,point &p2,point &p3){\n\t//if( abs(  direction(p1,p2,p3)  ) < EPS ) //segments_intersect縺ｧ縺ｯ蠢・ｦ√↑縺・\n\t\tif( min(p1.x,p2.x) <= p3.x && p3.x <= max(p1.x,p2.x)   ) return true;\n\treturn false;  \n}\n//莠､轤ｹ讀懷・\nbool segments_intersect(point &p1,point &p2,point &p3,point &p4){\n\tdouble d1 = direction(p3,p4,p1);\n\tdouble d2 = direction(p3,p4,p2);\n\tdouble d3 = direction(p1,p2,p3);\n\tdouble d4 = direction(p1,p2,p4);\n\tif(  ( (d1 > 0 and d2 < 0 ) or (d1 < 0 and d2 > 0) ) and ( ( d3 > 0 and d4 < 0) or ( d3 < 0 and d4 > 0) )  ) return true;   \n\tif( ( abs(d1) <= EPS )  and on_segment(p3,p4,p1) ) return true;\n\tif( ( abs(d2) <= EPS )  and on_segment(p3,p4,p2) ) return true;\n\tif( ( abs(d3) <= EPS )  and on_segment(p1,p2,p3) ) return true;\n\tif( ( abs(d4) <= EPS )  and on_segment(p1,p2,p4) ) return true;\n\treturn false;\n}\nbool segments_intersect(segment &s1,segment &s2){ return segments_intersect(s1.s,s1.e,s2.s,s2.e) ; }\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tsegment s1,s2;\n\t\ts1.make();\n\t\ts2.make();\n\t\tif(segments_intersect(s1,s2) ) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\nconst double EPS=1e-9;\nconst double PI=3.141592653589793238;//18 ragham\n\n#define double long double\nbool Equal(double d1,double d2)\n{ return fabs(d1-d2)<EPS;}\n\nstruct line{double a,b,c;};\nstruct vec\n{\n  double x,y;\n  vec(double _x=0,double _y=0)\n  {x=_x;  y=_y;}\n};\n  \nstruct point_i\n{\n  int x,y;\n  point_i(int _x=0,int _y=0){x=_x;y=_y;}\n};\nstruct point\n{\n  double x,y;\n  point(double _x=0,double _y=0){x=_x;y=_y;}\n  bool operator < (point other)\n  {  \n    if(fabs(x-other.x)<EPS)\n      return y<other.y;\n    return x<other.x;}\n  bool operator == (point other)\n  {return (fabs(x-other.x)<EPS) && (fabs(y-other.y)<EPS) ;}\n  \n  \n};\ndouble Hypot(double dx,double dy)\n{\n  return sqrt(dx*dx+dy*dy);\n}\ndouble DistancePoint(point p1,point p2)\n{\n  return hypot(p1.x-p2.x,p1.y-p2.y);\n}\ndouble DEG_to_RAD(double theta)\n{\n  return theta*PI/180;\n}\ndouble RAD_to_DEG(double rad)\n{\n  return rad*180/PI;\n}\npoint rotate(point p, double theta)//theta is degree\n{\n  \n  //rotation matrixR(theta) = [cos(theta) - sin(theta)]\n  //                          [sin(theta) + cos(theta)]\n  //usage: [x'] = R(theta)* [x]\n  //       [y']             [y]\n  double rad=DEG_to_RAD(theta);\n  return point(p.x * cos(rad) - p.x * sin(rad) ,\n\t       p.y * sin(rad) + p.y * cos(rad)  );\n}\nvoid PointsToLine(point p1,point p2,line *l)\n{\n  if(p1.x==p2.x) // vertical line handled here\n    { l->a=1.0;   l->b= 0.0 ; l->c=-p1.x;}\n  else\n    {\n      l->a=-(double)(p1.y-p2.y)/(p1.x-p2.x);\n      l->b=1.0;\n      l->c=-(double)(l->a * p1.x) - (l->b*p1.y);\n    }\n}\nbool AreParallel(line l1,line l2)\n{\n  return Equal(l1.a,l2.a) && Equal(l1.b,l2.b);\n}\nbool AreSame(line l1,line l2)\n{\n  return AreParallel(l1,l2) && Equal(l1.c,l2.c);\n}\nbool AreIntersect(line l1,line l2,point *p)//TO BE CHECKED (mine)\n{\n  if(AreSame(l1,l2))\n    return false;\n  if(AreParallel(l1,l2))\n    return false;\n\n  //solving\n  double delta=(double)l1.a*l2.b - l1.b*l2.a;\n  if(Equal(delta,0))//this if should never be true because lines are't parallel\n    return false;\n  //a1x+b1y=-c1\n  //a2x+b2y=-c2\n  p->x= (double)(-l1.c*l2.b+l2.c*l1.b) / delta;\n  p->y= (double)(-l1.a*l2.c+l2.a*l1.c) / delta;\n  return true;\n}\nvec ToVector(point p1,point p2)\n{\n  return vec(p2.x-p1.x,p2.y-p1.y);\n}\nvec ScaleVector(vec v, double s) // v*=s\n{\n  return vec(v.x*s,v.y*s);\n}\npoint Translate(point p,vec move)//moves point p in direction of vector move\n{\n  return point(p.x+move.x , p.y + move.y);\n}\ndouble Dot(double x1,double y1 ,double x2,double y2)\n{ return x1*x2+y1*y2;};\ndouble Determinant(double x1,double y1,double x2,double y2)\n{\n  //cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n  return x1*y2-x2*y1;};\n//angle A<BC (radian (PI) )\ndouble Angle(point A,point B,point C)\n{\n  double dot=Dot(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  double det=Determinant(B.x-A.x,B.y-A.y,B.x-C.x,B.y-C.y);\n  //cout<<dot<<\" aaaa \"<<det<<endl;\n  //atan2(y,x), or atan2(sin,cos)\n  return atan2(det,dot);\n}\ndouble Cross(point p,point q,point r)\n{\n  return (r.x-q.x)*(p.y-q.y)-(r.y-q.y)*(p.x-q.x);\n}\nbool Collinear(point p,point q,point r)\n{\n  return Equal(Cross(p,q,r),0);\n}\n//returns true if point r is on the left side of line pq\nbool CCW(point p,point q,point r)\n{\n   //can be modified to accept collinear ( >0 instead of >EPS )\n  if(Cross(p,q,r) > EPS)\n    return true;\n  return false;\n}\n\n//returns the distance from p to line AB\n// A and B must be different\n//closest point is in *c\ndouble DistToLine(point p,point A,point B,point *c)\n{// formula : c= A+ (p-A).(A-B)/|B-A|*(B-A)\n  double scale= (double)\n    ((p.x-A.x)*(B.x-A.x)+(p.y-A.y)*(B.y-A.y))/\n    ((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));\n  c->x= A.x + scale*(B.x - A.x);\n  c->y= A.y + scale*(B.y - A.y);\n  \n  return DistancePoint(p,*c);\n}\ndouble DistToLineSegment(point p,point A,point B,point *c)\n{\n  if((B.x-A.x) * (p.x-A.x)+ (B.y-A.y)*(p.y-A.y) <EPS)\n    { c->x=A.x ; c->y= A.y;\n      return DistancePoint(p,A);}//closer to A\n \n  if((A.x-B.x) * (p.x-B.x)+ (A.y-B.y)*(p.y-B.y) <EPS)\n    { c->x=B.x ; c->y= B.y;\n      return DistancePoint(p,B);}//closer to B\n\n  return DistToLine(p,A,B,c);\n  \n}\n//returns true if p is on segment AB\nbool IsOnLineSegment(point p,point A,point B)\n{\n   if(Collinear(p,A,B)==false)\n    return false;\n  if(p==A || p==B)\n    return true;\n  double angle=Angle(A,p,B);\n  //cout<<\"angle:\"<<RAD_to_DEG(angle)<<endl;\n  //cout<<\"and \"<<angle<<\" \"<<angle/PI<<\" \"<<endl;\n  //if(Equal(angle,0))\n  //cout<<\"chisssssssss\";\n  if(Equal ( DistancePoint(p,A)+DistancePoint(p,B) , DistancePoint(A,B) ) )\n    return true;\n  if(Equal( angle, PI ) || Equal(angle,-PI) ||  Equal(RAD_to_DEG(angle),180) )\n    return true;\n  return false;\n}\nbool AreSegmentsIntersect(point A,point B,point C,point D,point *p)\n{\n  line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2))\n    {\n      //cout<<\"A\"<<endl;\n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))cnt++;\n      if(IsOnLineSegment(B,C,D))cnt++;\n      if(IsOnLineSegment(C,A,B))cnt++;\n      if(IsOnLineSegment(D,A,B))cnt++;\n      if(cnt!=2)\n\treturn false;\n      if(A==C || A==D){\n\tp->x=A.x;\n\tp->y=A.y;\n\treturn true;}\n      if(B==C || B==D){\n\tp->x=B.x;\n\tp->y=B.y;\n\treturn true;}\n      return false;\n    }\n \n  if(AreIntersect(l1,l2,p))\n    {\n      //cout<<\"B\"<<endl;\n      // cout<<p->x<<\" \"<<p->y<<endl;\n      if(IsOnLineSegment(*p,A,B) && IsOnLineSegment(*p,C,D))\n\treturn true;\n      return false;\n    }\n  //cout<<\"C\"<<endl;\n  return false;\n}\nbool SegmentRangeIntersection(point A,point B,point C,point D)\n{\n    line l1,l2;\n  PointsToLine(A,B,&l1);\n  PointsToLine(C,D,&l2);\n  if(AreSame(l1,l2)==false)\n    return false;\n  //cout<<\"AA\"<<endl;\n  \n  \n      int cnt=0;\n      if(IsOnLineSegment(A,C,D))cnt++;\n      if(IsOnLineSegment(B,C,D))cnt++;\n      if(IsOnLineSegment(C,A,B))cnt++;\n      if(IsOnLineSegment(D,A,B))cnt++;\n      if(cnt)\n\treturn true;//special case : one point\n      //cout<<\"BB\"<<endl;\n  return false;\n}\n///*****************### End of Library ###*******************///\n\n\n\n\n\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    {\n      int x,y;\n      point A,B,C,D,p;\n      cin>>x>>y;\n      A=point(x,y);\n      \n      cin>>x>>y;\n      B=point(x,y);\n      \n      cin>>x>>y;\n      C=point(x,y);\n      \n      cin>>x>>y;\n      D=point(x,y);\n      if(AreSegmentsIntersect(A,B,C,D,&p) || SegmentRangeIntersection(A,B,C,D))\n\tcout<<1<<endl;\n      else\n\tcout<<0<<endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\n\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\n//robust less\nbool rless(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        if (!rless(l.s, l.t)) swap(l.s, l.t);\n        if (!rless(m.s, m.t)) swap(m.s, m.t);\n        if (!rless(l.s, m.s)) swap(l, m);\n        if (ccw(l, m.s) == 0) {\n            r = m.s;\n            if (near(l.t, m.s)) return 1;\n            return -1;\n        }\n        return 0;\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / (v.x*v.x + v.y*v.y));\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v+di, v-di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//共通内接線\nint internal_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(c.r + d.r, di) == 1) return 0;\n    D th = acos((c.r+d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p - P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p - P::polar(d.r, ar+th);\n    if (sgn(di, c.r + d.r) == 0) return 1;\n    return 2;\n}\n\n//共通外接線\nint external_tangent(const C &c, const C &d, L &l, L &r) {\n    D di = (c.p - d.p).abs();\n    if (sgn(abs(c.r - d.r), di) == 1) return 0;\n    assert(sgn(di)); // prohibit same circles\n    D th = acos((c.r-d.r) / di);\n    D ar = (d.p - c.p).arg();\n    l.s = c.p + P::polar(c.r, ar-th);\n    l.t = d.p + P::polar(d.r, ar-th);\n    r.s = c.p + P::polar(c.r, ar+th);\n    r.t = d.p + P::polar(d.r, ar+th);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n\n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << crossSS(l1, l2, p) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n \nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n \n// Problem Specific Parameter:\n \n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n \ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n \n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n \n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a,L b) {return sdot(O,a.t-a.s,b.t-b.s)==0;}\nbool parallel(L a,L b) {return sdet(O,a.t-a.s,b.t-b.s)==0;}\nbool eql(L a,L b){ return parallel(a,b) and sdet(a.s,a.t,b.s)==0;}\n \n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n    int sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n    int sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n    return max(sa,sb)<0;\n}\n \n// crossing point \n// verified: AOJ CGL_2_C\nP cross(L a,L b){\n    R u=det(a.s,b.s,b.t)/det(O,a.t-a.s,b.t-b.s);\n    return u*a.s+(1-u)*a.t;\n}\n     \n// distance \n// verified: AOJ CGL_2_D\nR dsp(L l,P p){\n    P h=proj(l,p);\n    if(sdot(l.s,l.t,p)<=0) h=l.s;\n    if(sdot(l.t,l.s,p)<=0) h=l.t;\n    return abs(p-h);\n}\n \nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n \nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n){\n        P a,b,c,d;\n        cin >> a >> b >> c >> d;\n        L s1={a,b},s2={c,d};\n        cout << (sgn(dss(s1,s2))==0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define int long long\n#define db double\n#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool f=0;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn f?-x:x;\n}\nvoid write(ll x){\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);putchar(x%10+'0');\n}\nvoid writeln(ll x){write(x);puts(\"\");}\nvoid writep(ll x){write(x);putchar(' ');}\n\nint const N=1e5+3;\nint top,n,m,cnt,sta[N];\nstruct point{\n\tdb x,y;\n    point operator - (point A) const{return (point){x-A.x,y-A.y};}\n    point operator + (point A) const{return (point){x+A.x,y+A.y};}\n    void print(){printf(\"%.10lf %.10lf\\n\",x,y);}\n}A,B,C,D,c[N],p1[N],p2[N];\n\npoint operator *(db x,point A){return (point){x*A.x,x*A.y};}\ndb CJ(point A,point B){return A.x*B.y-B.x*A.y;}//叉积 \ndb DJ(point A,point B){return A.x*B.x+A.y*B.y;}//点积 \ndb dis(point A){return sqrt(A.x*A.x+A.y*A.y);}//向量长度 \nbool cmp(point A,point B){return (CJ(A,B)>0 || CJ(A,B)==0 && dis(A)<dis(B));}//按极角排序 \nvoid Convex(point *A,int &n){//求凸包 \n\tfor (int i=1;i<=n;i++)\n\t  if (A[i].y<A[1].y || A[i].y==A[1].y && A[i].x<A[1].x) swap(A[i],A[1]);\n    point base=A[1];top=0;\n\tfor (int i=1;i<=n;i++) A[i]=A[i]-base;\n\tsort(A+2,A+n+1,cmp);\n\tsta[++top]=1;\n\tfor (int i=2;i<=n;sta[++top]=i,i++)\n\t  while (top>1 && CJ(A[i]-A[sta[top-1]],A[sta[top]]-A[sta[top-1]])>=0) top--;\n\tfor (int i=1;i<=top;i++) A[i]=A[sta[i]]+base;\n\tn=top;A[n+1]=A[1];\n}\nvoid Minkowski(point A[],point B[]){//闵可夫斯基（凸包合并） \n\tfor (int i=1;i<=n;i++) p1[i]=A[i+1]-A[i];\n\tfor (int i=1;i<=m;i++) p2[i]=B[i+1]-B[i];\n\tint i=1,j=1;c[cnt=1]=A[1]+B[1];\n\twhile (i<=n && j<=m)\n\t  if (CJ(p1[i],p2[j])>=0) cnt++,c[cnt]=c[cnt-1]+p1[i++];\n\t  else cnt++,c[cnt]=c[cnt-1]+p2[j++];\n\twhile (i<=n) cnt++,c[cnt]=c[cnt-1]+p1[i++];\n\twhile (j<=m) cnt++,c[cnt]=c[cnt-1]+p2[j++];\t\n}\nint check(point p){//判断一个点是否在凸包内 \n\tif (CJ(p,c[2])>0 || CJ(c[cnt],p)>0) return 0;\n\tint pos=lower_bound(c+1,c+cnt+1,p,cmp)-c-1;\n\treturn CJ(c[pos%cnt+1]-c[pos],p-c[pos])>=0; \n}\npoint CGL_1_A(point A,point B,point C){//点在直线上的投影点\n\tdb d=dis(B-A);\n\treturn (A+(DJ(C-A,B-A)/d/d*(B-A)));\n}\npoint CGL_1_B(point A,point B,point C){//点关于直线的对称点\n\tpoint P=CGL_1_A(A,B,C);\n\treturn (C+2*(P-C));\n}\nint CGL_1_C(point A,point B,point C){//向量的位置关系(向量AC和向量AB) \n    if (CJ(B-A,C-A)>0) return 1;//逆时针 \n    if (CJ(B-A,C-A)<0) return 2;//顺时针 \n    if (DJ(C-A,B-A)<0) return 3;//方向相反\n\tif (dis(C-A)>dis(B-A)) return 4;//方向相同 AC>AB\n\tif (dis(C-A)<=dis(B-A)) return 5;//方向相同 AB>AC\n}\nint CGL_2_A(point A,point B,point C,point D){//判断直线平行、垂直\n\tif (CJ(B-A,D-C)==0) return 2;//平行 \n\tif (DJ(B-A,D-C)==0) return 1;//垂直 \n\treturn 0;//相交 \n}\nint CGL_2_B(point A,point B,point C,point D){//判断线段是否有交\n\tif (min(A.x,B.x)>max(C.x,D.x) || min(C.x,D.x)>max(A.x,B.x) || min(A.y,B.y)>max(C.y,D.y) || min(C.y,D.y)>max(A.y,B.y)) return 0;//快速排斥实验(两个矩形是否相交)\n\treturn CJ(B-A,C-A)*CJ(B-A,D-A)<=0 && CJ(D-C,A-C)*CJ(D-C,B-C)<=0;//跨立实验\n}\n\nsigned main(){\n\tfor (int q=read();q;q--){\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&A.x,&A.y,&B.x,&B.y,&C.x,&C.y,&D.x,&D.y);\n\t\twriteln(CGL_2_B(A,B,C,D));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   double x,y;\n   Point(){}\n   Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nPoint line_intersect(Line a,Line b)// 两直线交点\n{\n   double t=cross(b.v,a.p-b.p)/cross(a.v,b.v);\n   return a.p+a.v*t;\n}\ndouble x[5],y[5];\nint a[555];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   //freopen(\"in.txt\",\"w\",stdout);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   \t  Line l1=Line(Point(x[1],y[1]),Vector(x[2]-x[1],y[2]-y[1]));\n   \t  Line l2=Line(Point(x[3],y[3]),Vector(x[4]-x[3],y[4]-y[3]));\n\n   \t  double p=cross(l1.v,l2.v);  \n   \t  if(fabs(p)<1e-8)\n   \t  {\n   \t    double w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(fabs(w)<1e-8)\n   \t    {\n   \t    \tdouble ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tdouble e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tdouble eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tdouble eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<=1e-10||e<=1e-10||eee<=1e-10||eeee<=1e-10) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t Point j=line_intersect(l1,l2);\n      \t if(j.x<=max(x[1],x[2])&&j.x>=min(x[1],x[2])&&j.x>=min(x[3],x[4])&&j.x<=max(x[3],x[4])\n      \t   &&j.y<=max(y[1],y[2])&&j.y>=min(y[1],y[2])&&j.y>=min(y[3],y[4])&&j.y<=max(y[3],y[4])\t)\n      \t \tputs(\"1\");\n      \t else puts(\"0\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\nint64_t cross(int64_t v1x, int64_t v1y, int64_t v2x, int64_t v2y) {\n    return v1x * v2y - v2x * v1y;\n}\n\nint main() {\n    int64_t q;\n\n    std::cin >> q;\n    \n    for (auto i = 0; i < q; ++i) {\n        int64_t x0, y0, x1, y1, x2, y2, x3, y3;\n        std::cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        auto v1x = x1 - x0;\n        auto v1y = y1 - y0;\n        auto v2x = x3 - x2;\n        auto v2y = y3 - y2;\n\n        bool ans;\n        // 線分が同一直線上に存在する場合\n        if (cross(v1x, v1y, x2-x0, y2-y0) == 0 && cross(v1x, v1y, x3-x0, y3-y0) == 0) {\n            auto f0 = (v1x * (x2-x0) + v1y * (y2-y0)) * (v1x * (x3-x0) + v1y * (y3-y0));\n            auto f1 = (v1x * (x2-x1) + v1y * (y2-y1)) * (v1x * (x3-x1) + v1y * (y3-y1));\n            auto f2 = (v2x * (x0-x2) + v2y * (y0-y2)) * (v2x * (x1-x2) + v2y * (y1-y2));\n            auto f3 = (v2x * (x0-x3) + v2y * (y0-y3)) * (v2x * (x1-x3) + v2y * (y1-y3));\n\n            ans = (f0 <= 0) || (f1 <= 0) || (f2 <= 0) || (f3 <= 0);\n        } else {\n            auto c0 = cross(v1x, v1y, x2-x0, y2-y0);\n            auto c1 = cross(v1x, v1y, x3-x0, y3-y0);\n            auto c2 = cross(v2x, v2y, x0-x2, y0-y2);\n            auto c3 = cross(v2x, v2y, x1-x2, y1-y2);\n\n            ans = c0 * c1 <= 0 && c2 * c3 <= 0;\n        }\n\n        std::cout << ( ans ? 1 : 0 ) << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nclass Point{\npublic:\n    double x, y;\n\n    Point(double x_ = 0, double y_ = 0){\n        x = x_;\n        y = y_;\n    }\n\n    Point operator+ (Point p){\n        return Point(x + p.x, y + p.y);\n    };\n\n    Point operator- (Point p){\n        return Point(x - p.x, y - p.y);\n    };\n\n    Point operator* (double k){\n        return Point(x * k, y * k);\n    }\n\n    Point operator/ (double k){\n        return Point(x / k, y / k);\n    }\n\n    double norm(){\n        return x * x + y * y;\n    }\n\n    double abs(){\n        return sqrt(norm());\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n;\ndouble getCos(Vector a, Vector b){\n    return dot(a, b) / (a.abs() * b.abs());\n}\n\ndouble dist(Point p1, Point p2){\n    return sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n}\n\nPoint projection(Point p1, Point p2, Point p0){\n    if(p1 == p0){\n        return p0;\n    }\n    if(p2 == p0){\n        return p0;\n    }\n    return p1 + (p2 - p1) / (p2 - p1).abs() * (p0 - p1).abs() * getCos(p2 - p1, p0 - p1);\n}\n\nPoint reflection(Point p1, Point p2, Point p0){\n    Point p = projection(p1, p2, p0);\n    return p0 + (p - p0) * 2;\n}\n\ndouble getDistanceSP(Point p1, Point p2, Point p0){\n    if(dot(p2 - p1, p0 - p1) < 0.0) return (p0 - p1).abs();\n    if(dot(p1 - p2, p0 - p2) < 0.0) return (p0 - p2).abs();\n    return (projection(p1, p2, p0) -  p0).abs();\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nint counterClockwise(Point p0, Point p1, Point p2){\n    Vector v1 = p1 - p0;\n    Vector v2 = p2 - p0;\n    if(cross(v1, v2) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(v1, v2) < -EPS) return CLOCKWISE;\n    if(dot(v1, v2) < -EPS) return ONLINE_BACK;\n    if(v1.norm() < v2.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    int t1 = counterClockwise(p1, p2, p3);\n    int t2 = counterClockwise(p1, p2, p4);\n    int t3 = counterClockwise(p3, p4, p2);\n    int t4 = counterClockwise(p3, p4, p1);\n    if(t1 * t2 <= 0){\n        if (t1 != ONLINE_BACK && t2 != ONLINE_FRONT){\n            return true;\n        }\n    }\n    if(t3 * t4 <= 0){\n        if (t2 != ONLINE_BACK && t4 != ONLINE_FRONT){\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble getDistance(Point p0, Point p1, Point p2, Point p3){\n    if(intersect(p0, p1, p2, p3)){\n        return 0.0;\n    }\n    return min(min(getDistanceSP(p0, p1, p2), getDistanceSP(p0, p1, p3)),\n                min(getDistanceSP(p2, p3, p0), getDistanceSP(p2, p3, p1)));\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n        \n        Point p0 = Point(xp0, yp0);\n        Point p1 = Point(xp1, yp1);\n        Point p2 = Point(xp2, yp2);\n        Point p3 = Point(xp3, yp3);\n\n        if(intersect(p0, p1, p2, p3)){\n            printf(\"1\\n\");\n        }else{\n            printf(\"0\\n\");\n        }\n    }\n}\n\n/*\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        scanf(\"%d\", &xp0);\n        scanf(\"%d\", &yp0);\n        scanf(\"%d\", &xp1);\n        scanf(\"%d\", &yp1);\n        scanf(\"%d\", &xp2);\n        scanf(\"%d\", &yp2);\n        scanf(\"%d\", &xp3);\n        scanf(\"%d\", &yp3);\n\n        printf(\"%.10f\\n\", getDistance(Point(xp0, yp0), Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3)));\n    }\n\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   double x,y;\n   Point(){}\n   Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nPoint line_intersect(Line a,Line b)// 两直线交点\n{\n   double t=cross(b.v,a.p-b.p)/cross(a.v,b.v);\n   return a.p+a.v*t;\n}\ndouble x[5],y[5];\nint a[555];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   freopen(\"in.txt\",\"w\",stdout);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   \t  Line l1=Line(Point(x[1],y[1]),Vector(x[2]-x[1],y[2]-y[1]));\n   \t  Line l2=Line(Point(x[3],y[3]),Vector(x[4]-x[3],y[4]-y[3]));\n\n   \t  double p=cross(l1.v,l2.v);  \n   \t  if(fabs(p)<1e-8)\n   \t  {\n   \t    double w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(fabs(w)<1e-8)\n   \t    {\n   \t    \tdouble ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tdouble e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tdouble eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tdouble eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<=1e-10||e<=1e-10||eee<=1e-10||eeee<=1e-10) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t Point j=line_intersect(l1,l2);\n      \t if(j.x<=max(x[1],x[2])&&j.x>=min(x[1],x[2])&&j.x>=min(x[3],x[4])&&j.x<=max(x[3],x[4])\n      \t   &&j.y<=max(y[1],y[2])&&j.y>=min(y[1],y[2])&&j.y>=min(y[3],y[4])&&j.y<=max(y[3],y[4])\t)\n      \t \tputs(\"1\");\n      \t else puts(\"0\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<eps && \n    cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1)<eps;\n}\n\nint N,Q;\nint X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\n#include <complex>\n#include <vector>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\n\n#define FOR(i,bg,ed) for(int i = (bg);<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline\nnamespace geo{\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tB comp(const P& l, const P& r)\n\t{\n\t\treturn (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n\t}\n\ttypedef pair<P, P> L;\n\ttypedef pair<P, P> LS;\n\ttypedef pair<P, D> C;\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\n\t//Decomposition Macro\n#define DCI(a,b,l) P(a),(b);tie(a,b)=l;\n#define DCc(a,b,c) P(a);D(b);tie(a,b)=c;\n\n\t//A dot B\n\tIL D dot(P a, P b)\n\t{\n\t\treturn a.X*b.X + a.Y*b.Y;\n\t}\n\tIL D cross(P a, P b)\n\t{\n\t\treturn a.X*b.Y - a.Y*b.X;\n\t}\n\tIL D ccw(P a, P b, P c)\n\t{\n\t\treturn cross(b - a, c - a);\n\t}\n\n\tIL int sgn(P a, P b, P c){\n\t\tif (cross(b - a, c - a) > EPS)return 1;\n\t\tif (cross(b - a, c - a) < -EPS)return -1;\n\t\tif (dot(b - a, c - a) < -EPS)return 2;\n\t\tif (dot(a - b, c - b) < -EPS)return -2;\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l){\n\t\tDCI(a, b, l);\n\t\treturn cross(b - a, p - a) / abs(b - a);\n\t}\n\tIL D dinstance_P_L(P p, L l){\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\tIL D distance_P_LS(P p, LS ls){\n\t\tDCI(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS)return abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS)return abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\tIL B is_L_L(L p, L q){\n\t\tDCI(a, b, p);\n\t\tDCI(c, d, q);\n\t\treturn abs(cross(a - b, c - d))>EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS; \n\t}\n\tIL B is_LS_LS(LS p, LS q){\n\t\tDCI(a, b, p);\n\t\tDCI(c, d, q);\n\t\treturn sgn(a, b, c) * sgn(a, b, d) <= 0 &&\n\t\t\tsgn(c, d, a) * sgn(c, d, b) <= 0;\n\t}\n}\n\nusing namespace geo;\n\n\nint main()\n{\n\tint n;\n\n\tcin >> n;\n\twhile (n--){\n\t\tD x1, x2, x3, y1, y2, y3, x4, y4;\n\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tP a(x1 - x2, y1 - y2), b(x3 - x4, y3 - y4);\n\n\t\tP p(x1,y1),q(x2,y2),r(x3,y3),s(x4,y4);\n\n\t\tif (is_LS_LS({ p, q }, { r, s })){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point{\n\tpublic:\n\t\tdouble x, y;\n\n\t\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\t\tPoint operator + (Point p){ return Point(x + p.x, y + p.y);}\n\t\tPoint operator - (Point p){ return Point(x - p.x, y - p.y);}\n\t\tPoint operator * (double a){ return Point(a * x, a * y);}\n\t\tPoint operator / (double a){ return Point(x / a, y / a);}\n\n\t\tdouble abs(){ return sqrt(norm());}\n\t\tdouble norm(){ return x * x + y * y;}\n\n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n};\ntypedef Segment Line;\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(){\n\tint q;\n\tSegment s1, s2;\n\tcin >> q;\n\tfor(int i=1;i<=q;i++){\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tif(intersect(s1, s2) == true) cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(double x = 0,double y = 0) : x(x), y(y) {}\n\n  Point operator + (const Point &p)const{\n    return Point(x + p.x , y + p.y);\n  }\n\n  Point operator - (const Point &p)const{\n    return Point(x - p.x , y - p.y);\n  }\n\n  Point operator * (const double &k)const{\n    return Point(x * k , y * k);\n  }\n\n  Point operator / (const double &k)const{\n    return Point(x / k , y / k);\n  }\n\n  bool operator < (const Point &p)const{\n    if(x != p.x) return x < p.x;\n    else return y < p.y;\n  }\n\n  double dot(const Point &p)const{\n    return x*p.x + y*p.y;\n  }\n\n  double cross(const Point &p)const{\n    return x*p.y - p.x*y;\n  }\n\n  double dist(const Point &p)const{\n    return sqrt(pow(x-p.x,2) + pow(y-p.y,2));\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double Abs(){\n    return sqrt(norm());\n  }\n};\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(a.cross(b) > EPS){\n    return COUNTER_CLOCKWISE;\n  }else if(a.cross(b) < -EPS){\n    return CLOCKWISE;\n  }else if(a.dot(b) < -EPS){\n    return ONLINE_BACK;\n  }else if(a.norm() < b.norm()){\n    return ONLINE_FRONT;\n  }else{\n    return ON_SEGMENT;\n  }\n}\n\nstruct Line{\n  Vector s,t;\n \n  Line(){}\n  Line(Vector s, Vector t) : s(s), t(t) {}\n\n  bool isOrthogonal(Line &l){\n    Vector a = t - s;\n    Vector b = l.t - l.s;\n    if(equal(a.dot(b),0.0)){\n      return true;\n    }else{\n      return false;\n    }\n  }\n\n  bool isParallel(Line &l){\n    Vector a = t - s;\n    Vector b = l.t - l.s;\n    if(equal(a.cross(b),0.0)){ \n      return true; \n    }else{\n      return false;\n    }\n  }\n\n  Point Projection(Point &p){\n    Vector u = t - s;\n    double v = u.dot(p - s) / u.norm();\n    return s + u * v;\n  }\n\n  Point CrossPoint(Line &l){\n    Vector v = l.t - l.s;\n    double a = abs(v.cross(s-l.s));\n    double b = abs(v.cross(t-l.s));\n    double c = a / (a + b);\n    return s + (t - s) * c;\n  }\n\n  Point Reflection(Point &p){\n    return p + (Projection(p) - p) * 2.0;\n  }\n\n  bool isIntersect(Point p0,Point p1,Point p2,Point p3){\n    return (ccw(p0,p1,p2)*ccw(p0,p1,p3) <= 0 &&\n            ccw(p2,p3,p0)*ccw(p2,p3,p1) <= 0);\n  }\n  \n  bool isIntersect(Line &l){\n    return isIntersect(s,t,l.s,l.t);\n  }\n};\n\nint main(){\n  int Q;\n  cin >> Q;\n  while(Q--){\n    Line s1,s2;\n    cin >> s1.s.x >> s1.s.y >> s1.t.x >> s1.t.y;\n    cin >> s2.s.x >> s2.s.y >> s2.t.x >> s2.t.y;\n    cout << s1.isIntersect(s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\nconst double eps=1e-9;\ndouble ABS(double n){return n>=0?n:-n;}\nbool same(double a,double b){return ABS(a-b)<eps;}\nstruct point{\n\tdouble x;\n\tdouble y;\n\tpoint(){}\n\tpoint(double a,double b){x=a;y=b;}\n\tpoint operator +(const point &a){return point(x+a.x,y+a.y);}\n\tpoint operator -(const point &a){return point(x-a.x,y-a.y);}\n\tpoint operator *(const double &a){return point(x*a,y*a);}\n\tpoint operator /(const double &a){return point(x/a,y/a);}\n\tvoid operator =(const point &a){x=a.x;y=a.y;}\n\tvoid operator +=(const point &a){x+=a.x;y+=a.y;}\n\tvoid operator -=(const point &a){x-=a.x;y-=a.y;}\n\tvoid operator *=(const double &a){x*=a;y*=a;}\n\tvoid operator /=(const double &a){x/=a;y/=a;}\n\tbool operator <(const point &a){return x<a.x||(same(x,a.x)&&y<a.y);}\n\tbool operator ==(const point &a){return same(x,a.x)&&same(y,a.y);}\n\tdouble length(){return sqrt(x*x+y*y);}\n\tvoid in(){scanf(\"%lf%lf\",&x,&y);}\n\tvoid out(){printf(\"%.20lf %.20lf\\n\",x,y);}\n};\nstruct segment{\n\tpoint a;\n\tpoint b;\n\tsegment(){}\n\tsegment(point x,point y){a=x;b=y;}\n};\nstruct line{\n\tdouble A;\n\tdouble B;\n\tdouble C;\n\tline(){}\n\tline(double a,double b,double c){A=a;B=b;C=c;}\n\tline(point a,point b){\n\t\tA=a.y-b.y;\n\t\tB=b.x-a.x;\n\t\tC=A*a.x+B*a.y;\n\t}\n\tline(double a,double b,point p){\n\t\tA=a;\n\t\tB=b;\n\t\tC=A*p.x+B*p.y;\n\t}\n\tline(segment s){\n\t\tA=s.a.y-s.b.y;\n\t\tB=s.b.x-s.a.x;\n\t\tC=A*s.a.x+B*s.a.y;\n\t}\n};\ndouble dist(point a,point b){return (a-b).length();}\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-b.x*a.y;}\n//angle only returns positive value\ndouble angle(point a,point b){return acos(dot(a,b)/(a.length()*b.length()));}\ndouble area(point a,point b,point c){return ABS(cross(b-a,c-a));}\ndouble distancetoline(point a,line b){return (b.A*a.x+b.B*a.y-b.C)/sqrt(b.A*b.A+b.B*b.B);}\nbool between(point a,point b,point c){\n\tif((a.x-b.x<=eps&&b.x-c.x<=eps)||(eps>=b.x-a.x&&eps>=c.x-b.x))\n\tif((a.y-b.y<=eps&&b.y-c.y<=eps)||(eps>=b.y-a.y&&eps>=c.y-b.y))\n\treturn true;\n\treturn false;\n}\nbool parallel(line a,line b){return same(a.A*b.B,b.A*a.B);}\nbool same(line a,line b){return parallel(a,b)&&same(a.A*b.B*b.C,a.B*b.A*b.C)&&same(a.A*b.B*b.C,a.C*b.A*b.B);}\nbool vertical(line a,line b){return ABS(a.A*b.A+a.B*b.B)<=eps;}\npoint intersect(line a,line b){\n\tdouble x,y,det;\n\tx=(a.C*b.B-b.C*a.B);\n\ty=(a.A*b.C-b.A*a.C);\n\tdet=(a.A*b.B-b.A*a.B);\n\treturn point(x,y)/det;\n}\nbool hasintersect(segment a,segment b){\n\tline l(a),r(b);\n\tif(parallel(l,r)){\n\t\tif(same(l,r))return between(a.a,b.a,a.b)||between(a.a,b.b,a.b)||between(b.a,a.a,b.b)||between(b.a,a.b,b.b);\n\t\telse return false;\n\t}\n\telse{\n\t\tpoint p(intersect(l,r));\n\t\treturn between(a.a,p,a.b)&&between(b.a,p,b.b);\n\t}\n}\npoint intersect(segment a,segment b){return intersect(line(a),line(b));}\npoint projection(point a,line b){return intersect(line(b.B,-b.A,a),b);}\npoint reflection(point a,line b){return projection(a,b)*2-a;}\nbool online(point p,line l){return ABS(l.A*p.x+l.B*p.y-l.C)<eps;}\nbool onseg(point p,segment s){return online(p,line(s))&&between(s.a,p,s.b);}\nvoid solve(){\n\tsegment a,b;\n\tpoint x,y;\n\tx.in();\n\ty.in();\n\ta=segment(x,y);\n\tx.in();\n\ty.in();\n\tb=segment(x,y);\n\tif(hasintersect(a,b))printf(\"1\\n\");\n\telse printf(\"0\\n\");\n\treturn ;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nbool eq(ld a, ld b){\n\treturn abs(a-b) < EPS;\n}\n\nstruct PT{\n\tld x, y;\n\tPT (ld x = 0, ld y = 0) : x(x), y(y) {}\n\tPT operator + (PT ro) const{\n\t\treturn PT(x+ro.x, y+ro.y);\n\t}\n\tPT operator - (PT ro) const{\n\t\treturn PT(x-ro.x, y-ro.y);\n\t}\n\tPT operator * (ld co) const{\n\t\treturn PT(x*co, y*co);\n\t}\n\tPT operator / (ld co) const{\n\t\treturn PT(x/co, y/co);\n\t}\n\tld operator * (PT ro) const{\n\t\treturn x*ro.x + y*ro.y;\n\t}\n\tld operator ^ (PT ro) const{\n\t\treturn x*ro.y - y*ro.x;\n\t}\n};\n\nistream& operator>> (istream &is, PT &p){\n\tld val;\n\tis >> val;\n\tp.x = val;\n\tis >> val;\n\tp.y = val;\n\treturn is;\n}\n\nPT operator * (ld co, PT p){\n\treturn p*co;\n}\n\nld len(PT a){\n\treturn sqrt(a*a);\n}\n\nPT unit(PT a){\n\treturn a/len(a);\n}\n\nPT clrot(PT a){\n\treturn PT(-a.y, a.x);\n}\n\nPT proj(PT a, PT b, PT c){\n\tb = b-a, c = c-a;\n\treturn a + (b*c)/(b*b)*b;\n}\n\nPT reflect(PT a, PT b, PT c){\n\tPT d = c;\n\tb = b-a, c = c-a;\n\treturn d + (c^b)/len(b)*clrot(unit(b))*2;\n}\n\nint sgn(PT a, PT b, PT c){\n\tld cr = (b-a)^(c-a);\n\treturn cr > EPS ? 1 : (cr + EPS < 0 ? -1 : 0);\n}\n\nint main(){\n\tfor (int i = in(); i; i--){\n\t\tPT a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint as = sgn(c, d, a),\n\t\t\tbs = sgn(c, d, b),\n\t\t\tcs = sgn(a, b, c),\n\t\t\tds = sgn(a, b, d);\n\t\tif (as && as == bs || cs && cs == ds)\n\t\t\tcout << 0 << endl;\n\t\telse if (as == 0 && as == bs || cs == 0 && cs == ds){\n\t\t\tld mx = min(a.x, b.x),\n\t\t\t   Mx = max(a.x, b.x),\n\t\t\t   my = min(a.y, b.y),\n\t\t\t   My = max(a.y, b.y);\n\t\t\tif (c.x + EPS > mx && c.x < Mx + EPS && c.y + EPS > my && c.y < My + EPS ||\n\t\t\t\t\td.x + EPS > mx && d.x < Mx + EPS && d.y + EPS > my && d.y < My + EPS)\n\t\t\t\tcout << 1 << endl;\n\t\t\telse\n\t\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse\n\t\t\tcout << 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector <Vector> Polygon;\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\n// ?????????|a||b|cos\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;\n}\n// ?????????|a||b|sin\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;\n}\n\n// 1:???????¨??????? -1:????¨??????? 2:p2-p0-p1 -2:p0-p1-p2 0:p2???p0-p1???\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if (cross(a, b) > EPS) return 1;\n  if (cross(a, b) < -EPS) return -1;\n  if (dot(a, b) < -EPS) return 2;\n  if (a.norm() < b.norm()) return -2;\n\n  return 0;\n}\n\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b) {\n  return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1-a2, b1-b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// ????????????\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1-a2, b1-b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n  return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n// ????????????\n// p1!=p2????????????p3!=p4????????¶\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nint main() {\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    Segment s1, s2;\n    cin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y\n        >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n    cout << intersect(s1, s2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble EPS = 0.00000001;\nint sign(double x){\n\tif (x > EPS){\n\t\treturn 1;\n\t} else if (x < -EPS){\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\nbool equals(double x, double y){\n\treturn abs(x - y) < EPS;\n}\nstruct point{\n\tdouble x;\n\tdouble y;\n\tpoint(){\n\t\tx = 0;\n\t\ty = 0;\n\t}\n\tpoint(double X, double Y){\n\t\tx = X;\n\t\ty = Y;\n\t}\n\tpoint operator +(){\n\t\treturn point(x, y);\n\t}\n\tpoint operator -(){\n\t\treturn point(-x, -y);\n\t}\n\tpoint operator +(point P){\n\t\treturn point(x + P.x, y + P.y);\n\t}\n\tpoint operator -(point P){\n\t\treturn point(x - P.x, y - P.y);\n\t}\n\tpoint& operator +=(point P){\n\t\tx += P.x;\n\t\ty += P.y;\n\t\treturn *this;\n\t}\n\tpoint& operator -=(point P){\n\t\tx -= P.x;\n\t\ty -= P.y;\n\t\treturn *this;\n\t}\n\tpoint operator *(double k){\n\t\treturn point(x * k, y * k);\n\t}\n\tpoint operator /(double k){\n\t\treturn point(x / k, y / k);\n\t}\n\tpoint& operator *=(double k){\n\t\tx *= k;\n\t\ty *= k;\n\t\treturn *this;\n\t}\n\tpoint& operator /=(double k){\n\t\tx /= k;\n\t\ty /= k;\n\t\treturn *this;\n\t}\n\tbool operator ==(point P){\n\t\treturn equals(x, P.x) && equals(y, P.y);\n\t}\n\tbool operator !=(point P){\n\t\treturn !(*this == P);\n\t}\n\tbool operator <(point P){\n\t\treturn sign(P.x - x) == 1 || equals(x, P.x) && sign(P.y - y) == 1;\n\t}\n\tbool operator >(point P){\n\t\treturn (P < *this);\n\t}\n\tpoint& rotate(double t){\n\t    double X = x * cos(t) - y * sin(t);\n\t    double Y = x * sin(t) + y * cos(t);\n\t    x = X;\n\t    y = Y;\n\t    return *this;\n\t}\n\tpoint& rotate(point P, double t){\n\t    *this -= P;\n\t    (*this).rotate(t);\n\t    *this += P;\n\t    return *this;\n\t}\n\tpoint& rotate90(){\n\t    swap(x, y);\n\t    x = -x;\n\t    return *this;\n\t}\n};\nistream& operator >>(istream &is, point &p){\n\tdouble x, y;\n\tis >> x >> y;\n\tp = point(x, y);\n\treturn is;\n}\nostream& operator <<(ostream &os, point p){\n\tos << p.x << ' ' << p.y;\n\treturn os;\n}\ndouble norm(point P){\n\treturn P.x * P.x + P.y * P.y;\n}\ndouble abs(point P){\n\treturn sqrt(norm(P)); \n}\ndouble dot(point P, point Q){\n\treturn P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\nint ccw(point P, point Q, point R){\n\tQ -= P;\n\tR -= P;\n\tif (sign(cross(Q, R)) == 1){\n\t\treturn 1;\n\t} else if (sign(cross(Q, R)) == -1){\n\t\treturn -1;\n\t} else if (sign(dot(Q, R)) == -1){\n\t\treturn -2;\n\t} else if (sign(abs(R) - abs(Q)) == 1){\n\t\treturn 2;\n\t} else {\n\t\treturn 0;\n\t}\n}\nstruct line{\n\tpoint A;\n\tpoint B;\n\tline(){\n\t}\n\tline(point P){\n\t  B = P;\n\t}\n\tline(point P, point Q){\n\t\tA = P;\n\t\tB = Q;\n\t}\n\tline(double a, double b){\n\t\tA = point(0, b);\n\t\tB = point(1, a + b);\n\t}\n\tline(double a, double b, double c){\n\t\tif (sign(b) == 0){\n\t\t\tA = point(-c / a, 0);\n\t\t\tB = point(-c / a, 1);\n\t\t} else {\n\t\t\tA = point(0, -c / a);\n\t\t\tB = point(1, -(b + c) / a);\n\t\t}\n\t}\n\tbool operator == (line L){\n\t\treturn abs(ccw(A, B, L.A)) != 1 && abs(ccw(A, B, L.B)) != 1;\n\t}\n\tbool operator !=(line L){\n\t\treturn !(*this == L);\n\t}\n\tbool operator <(line L){\n\t\treturn A < L.A || A == L.A && B < L.B;\n\t}\n\tbool operator >(line L){\n\t\treturn (L < *this);\n\t}\n};\nusing ray = line;\nusing segment = line;\nistream& operator >>(istream &is, line &L){\n\tpoint A, B;\n\tis >> A >> B;\n\tL = line(A, B);\n\treturn is;\n}\nostream& operator <<(ostream &os, line L){\n\tos << L.A << ' ' << L.B;\n\treturn os;\n}\npoint vec(line L){\n\treturn L.B - L.A;\n}\nbool is_orthogonal(line a, line b){\n\treturn sign(dot(vec(a), vec(b))) == 0;\n}\nbool is_parallel(line a, line b){\n  return sign(cross(vec(a), vec(b))) == 0;\n}\nbool is_on_line(point P, line L){\n\treturn abs(ccw(L.A, L.B, P)) != 1;\n}\nbool is_on_ray(point P, ray L){\n  int x = ccw(L.A, L.B, P);\n  return x == 0 || x == 2;\n}\nbool is_on_segment(point P, segment L){\n\treturn ccw(L.A, L.B, P) == 0;\n}\nbool is_intersecting_line(line a, line b){\n\treturn !is_parallel(a, b);\n}\npair<bool, point> line_intersection(line L1, line L2){\n\tif (L1 == L2){\n\t\treturn make_pair(true, L1.A);\n\t} else if (is_parallel(L1, L2)){\n\t\treturn make_pair(false, point());\n\t} else {\n\t  point P = L1.A + vec(L1) * cross(vec(L2), L2.A - L1.A) / cross(vec(L2), vec(L1));\n\t\treturn make_pair(true, P);\n\t}\n}\npair<bool, point> segment_intersection(segment S1, segment S2){\n\tif (S1 == S2){\n\t\tif (is_on_segment(S2.A, S1)){\n\t\t\treturn make_pair(true, S2.A);\n\t\t} else if (is_on_segment(S2.B, S1)){\n\t\t\treturn make_pair(true, S2.B);\n\t\t} else if (is_on_segment(S1.A, S2)){\n\t\t\treturn make_pair(true, S1.A);\n\t\t} else {\n\t\t\treturn make_pair(false, point());\n\t\t}\n\t}\n\tpair<bool, point> P = line_intersection(S1, S2);\n\tif (!P.first){\n\t\treturn P;\n\t} else if (is_on_segment(P.second, S1) && is_on_segment(P.second, S2)){\n\t\treturn P;\n\t} else {\n\t\treturn make_pair(false, point());\n\t}\n}\nint main(){\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++){\n\t  segment s1, s2;\n\t  cin >> s1 >> s2;\n\t  if (segment_intersection(s1, s2).first){\n\t    cout << 1 << endl;\n\t  } else {\n\t    cout << 0 << endl;\n\t  }\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=(m);i<(n);i++)\n\nconst bool DEBUG = true;\n#define double long double\nconst double EPS = 1e-8;\ntypedef complex<double> point;\nistream &operator>>(istream &is, point &p) {\n  double a, b;\n  is >> a >> b;\n  p = point(a, b);\n  return is;\n}\n\npoint operator*(const point&p, const double &d) {\n\treturn point(real(p)*d, imag(p)*d);\n}\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\t//istream &operator>>(istream &stream, point &p) {\n\t//\tstream >> p.real >> p.imag;\n\t//\treturn stream;\n\t//}\n}\n//bool intersectLL(const Line &l1, const Line &l2);\n//bool intersectLS(const Line &l, const Line &s);\n//bool intersectLP(const Line &l, const point &p);\n//bool intersectSS(const Line &s, const Line &t);\n//bool intersectSP(const Line &s, const point &p);\n\n//直線or線分\nstruct Line : public vector<point> {\n\tLine(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<Line>Lines;\n\n\ndouble cross(const point& a, const point& b) {\n  return real(a)*imag(b)-imag(a)*real(b);\n}\ndouble dot(const point& a, const point& b) {\n  return real(a)*real(b)+imag(a)*imag(b);\n}\nint ccw(point a, point b, point c) {\n\tb =b-a; c =c - a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) < -EPS)   return -1;       // clockwise\n\tif (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n//交差判定\nbool intersectLL(const Line &l1, const Line &l2) {\n\treturn abs(cross(l1[1] - l1[0], l2[1] - l2[0])) > EPS || //non-parallel\n\t\tabs(cross(l1[1] - l1[0], l2[0] - l1[0])) < EPS; //same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])* // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const Line &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n//端点に乗ってたらfalse\nbool intersectSP_without_endpoint(const Line &s, const point &p) {\n\tif (abs(s[0] - p) < EPS || abs(s[1] - p) < EPS)return false;\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; //triangle inequality\n}\n\nbool intersectSP(const Line &s, const point &p) { //verified on 2020/04/03 https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; //triangle inequality\n}\nbool connectSS(const Line &s, const Line &t) {\n\tif (intersectSP(s, t[0]) || intersectSP(s, t[1]) || intersectSP(t, s[0]) || intersectSP(t, s[1]))return true;\n\telse return false;\n}\nbool isSamePoint(const point &p1,const point &p2){\n\treturn abs(p1-p2)<EPS;\n}\nbool connectSS_with_endpoint(const Line &s,const Line &t){\n\tREP(i,2)REP(j,2){\n\t\t//if(isSamePoint(s[i],t[j]))return true;\n\t\tif(s[i]==t[j])return true;\n\t}\n\treturn false;\n}\nbool intersectSS(const Line &s, const Line &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSS_strict(const Line &s, const Line &t) {\n\t//端点が線分上に乗っている場合はfalseにする\n\tif (connectSS(s, t))return false;\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isOn(const Line &l,const point &p){\n\tif(l[0]==p||l[1]==p)return false;\n\tpoint d=l[1]-l[0];\n\tpoint p0=(p-l[0])/d;\n\treturn p0.imag()==0.0&&0.0<p0.real()&&p0.real()<1.0;\n}\nbool intersect(const Line &l0,const Line &l1, point &p){\n\tif(connectSS_with_endpoint(l0,l1)||isOn(l0,l1[0])||isOn(l0,l1[1])||isOn(l1,l0[0])||isOn(l1,l0[1]))return false;\n\tpoint d = l0[1]-l0[0];\n\tpoint p0=(l1[0]-l0[0])/d;\n\tpoint p1=(l1[1]-l0[0])/d;\n\tif(p0.imag()*p1.imag()>=0)return false;\n\tdouble t=p0.imag()/(p0.imag()-p1.imag());\n\tdouble s=p0.real()*(1-t)+p1.real()*t;\n\tif(s<=0.0||1.0<=s)return false;\n\tp=l0[0]+d*s;\n\treturn true;\n}\n\n//距離,交点\n//射影 直線lにpから下した垂線との交点\n\npoint projection(const Line &l, const point &p) { //verified on 2020/04/03 https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1])*t;\n}\n//射影 直線lを対象軸としてpと線対称にある点\npoint reflection(const Line &l, const point &p) {\n\treturn p + (projection(l, p) - p) * 2;\n}\ndouble distancePP(const point& a, const point& b) {\n\treturn sqrt(norm(a - b));\n}\ndouble distanceLP(const Line &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const Line&l, const Line &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const Line &l, const Line &s) {\n\tif (intersectLS(l, s))return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r))return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) { //verified on 2020/04/03 https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n\tif (intersectSS(s, t))return 0;\n\treturn min({ distanceSP(s,t[0]),distanceSP(s,t[1]),distanceSP(t,s[0]),distanceSP(t,s[1]) });\n}\npoint crosspoint(const Line &l, const Line &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS&&abs(B) < EPS)return m[0];//same line\n\tif (abs(A) < EPS)assert(false); // Precondition not satisfied\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist(point &p1, point &p2) {\n\treturn abs(p1 - p2);\n}\n\n//線分同士の交点で分割して端点以外の共有点を持たないようにする\nvoid splitSegments(Lines &ls) {\n\t//端点が線分上に乗っている場合の分割\n\tfor (size_t i = 0; i < ls.size(); i++)for (size_t j = i + 1; j < ls.size(); j++) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t//if(isOn(ls[i],ls[j][k])){\n\t\t\tif (intersectSP_without_endpoint(ls[i], ls[j][k])) {\n\t\t\t\tls.push_back(Line(ls[i][0], ls[j][k]));\n\t\t\t\tls[i][0] = ls[j][k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//else if(isOn(ls[j],ls[i][k])){\n\t\t\telse if (intersectSP_without_endpoint(ls[j], ls[i][k])) {\n\t\t\t\tls.push_back(Line(ls[j][0], ls[i][k]));\n\t\t\t\tls[j][0] = ls[i][k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//cerr << \"split-1\" << endl;\n\t//線分が交差している場合の分割\n\tfor (size_t i = 0; i < ls.size(); i++) {\n\t\tLine li = ls[i];\n\t\tfor (size_t j = i + 1; j < ls.size(); j++) {\n\t\t\tpoint cross_p;\n\t\t\tif(intersect(ls[i],ls[j],cross_p)!=intersectSS(ls[i],ls[j])){\n\t\t\t\tif(intersect(ls[i],ls[j],cross_p))cerr<<\"intersect\"<<endl;\n\t\t\t\telse cerr<<\"not intersect\"<<endl;\n\t\t\t\tcerr<<ls[i][0]<<\" \"<<ls[i][1]<<endl;\n\t\t\t\tcerr<<ls[j][0]<<\" \"<<ls[j][1]<<endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif(intersect(ls[i],ls[j],cross_p)){\n\t\t\t//if (intersectSS(ls[i], ls[j])) {\n\t\t\t\t//cross_p = crosspoint(ls[i], ls[j]);\n\t\t\t\tls.push_back(Line(ls[i][0], cross_p));\n\t\t\t\tls[i][0] = cross_p;\n\t\t\t\tls.push_back(Line(ls[j][0], cross_p));\n\t\t\t\tls[j][0] = cross_p;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//線分の集合(split済み)を連結成分に分解する(union-find)\nstruct Equiv {\n\tvector<int>links;\n\t//大きさ1の同値類をn個作る\n\tEquiv(int n) :links(n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlinks[i] = i;\n\t\t}\n\t}\n\t//xの属する同値類の代表元を返す\n\tint find(int x) {\n\t\tint xx = links[x];\n\t\tif (xx == x)return x;\n\t\treturn links[x] = find(xx);\n\t}\n\tvoid unify(int x, int y) {\n\t\tint xx = find(x), yy = find(y);\n\t\tif (xx <= yy)links[yy] = xx;\n\t\telse links[xx] = yy;\n\t}\n};\n\ntypedef vector<Lines>vLines;\nvLines connectedComponent(const Lines &ls) {\n\tvLines ret;\n\tEquiv equiv(ls.size());\n\tfor (int i = 0; i < (int)ls.size(); i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (connectSS_with_endpoint(ls[i], ls[j])) {\n\t\t\t\tequiv.unify(i, j);\n\t\t\t}\n\t\t}\n\t}\n\t//cerr << \"connected-1\" << endl;\n\tfor (int i = 0; i < (int)ls.size(); i++) {\n\t\tif (equiv.find(i) == i) {\n\t\t\tLines newLs;\n\t\t\tnewLs.push_back(ls[i]);\n\t\t\tfor (int j = i + 1; j < (int)ls.size(); j++) {\n\t\t\t\tif (equiv.find(j) == i)newLs.push_back(ls[j]);\n\t\t\t}\n\t\t\tret.push_back(newLs);\n\t\t}\n\t}\n\treturn ret;\n}\n//左手法でのトレース\n//偏角でソートされた隣接点のvectorを得る\ntypedef pair<double, point>doublePoint;\ntypedef vector<doublePoint> vDoublePoint;\ntypedef map<point, vDoublePoint> adjPoint;\ntypedef vector<point>points;\n//移動前の点と隣接点のリストから移動先を決定\npoint findNext(const vDoublePoint &vdp, const point &p) {\n\tfor (int i = 0; i < (int)vdp.size() - 1; i++) {\n\t\tif (p == vdp[i].second) {\n\t\t\treturn vdp[i + 1].second;\n\t\t}\n\t}\n\treturn vdp[0].second;\n}\n//左手法でトレースして通った点の列を返す\npoints trace(const Lines &ls) {\n\tadjPoint aPoint;\n\t//隣接点(偏角付き)のリストを作成\n\tfor (int i = 0; i < (int)ls.size(); i++) {\n\t\taPoint[ls[i][0]].push_back(doublePoint(arg(ls[i][1] - ls[i][0]), ls[i][1]));\n\t\taPoint[ls[i][1]].push_back(doublePoint(arg(ls[i][0] - ls[i][1]), ls[i][0]));\n\t}\n\t//x座標最小の点の計算と隣接点リストのソート\n\tpoint minPoint(INT_MAX, INT_MAX);\n\tadjPoint::iterator it;\n\tfor (it = aPoint.begin(); it != aPoint.end(); ++it) {\n\t\tpoint p = it->first;\n\t\tminPoint = min(minPoint, p);\n\t\tvDoublePoint &vdp = it->second;\n\t\tsort(vdp.begin(), vdp.end());\n\t}\n\tpoints ret;\n\tret.push_back(minPoint);\n\t//最初の移動先\n\tpoint curP = aPoint[minPoint][0].second;\n\tpoint lastP = minPoint;\n\t//トレースの繰り返し\n\tint cnt =0;\n\twhile (curP != minPoint) {\n\t\tif(DEBUG)cerr<<curP<<endl;\n\t\tcnt++;\n\t\tassert(cnt<1000000);\n\t\tret.push_back(curP);\n\t\tpoint nextP = findNext(aPoint[curP], lastP);\n\t\t//if(isSamePoint(curP,nextP))break;\n\t\tlastP = curP;\n\t\tcurP = nextP;\n\t}\n\t//開始点を最後にも追加\n\tret.push_back(minPoint);\n\treturn ret;\n}\n\nbool isInside(const points &ps) {\n\tLine l0(point(0, 0), point(51.0, 1.0 / 20000.0));\n\tint count = 0;\n\tfor (int i = 0; i < (int)ps.size() - 1; i++) {\n\t\tpoint dummy;\n\t\tLine l1(ps[i], ps[i + 1]);\n\t\tif (intersect(l0, l1,dummy))count++;\n\t}\n\treturn (count & 1) == 1;\n}\n\n\n//円\nstruct Circle {\n\tpoint p; double r;\n\tCircle(const point &p_, double r_) : p(p_), r(r_) { }\n};\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//2点を通る半径Rの円の中心\npair<point, point> get_circle_from_2points(point &p1, point &p2, double R) {\n\tdouble d = dist(p1, p2);\n\tdouble x1 = p1.real(), x2 = p2.real();\n\tdouble y1 = p1.imag(), y2 = p2.imag();\n\tif (p1.imag() == p2.imag()) {\n\t\tdouble x = (x1 + x2) / 2.0;\n\t\tdouble dy = sqrt(R - d * d / 4);\n\t\treturn { { x,y1 + dy },{ x,y1 - dy } };\n\t}\n\telse {\n\t\tdouble m = (x1 - x2) / (y2 - y1);\n\t\tdouble t = sqrt(R*R - d * d / 4);\n\t\tdouble dx = sqrt((t*t) / (m*m + 1));\n\t\tdouble dy = sqrt(t*t - dx * dx);\n\t\tdouble gx = (x1 + x2) / 2;\n\t\tdouble gy = (y1 + y2) / 2;\n\t\tif (m > EPS) {\n\t\t\treturn { { gx + dx,gy + dy },{ gx - dx,gy - dy } };\n\t\t}\n\t\telse {\n\t\t\treturn { { gx + dx,gy - dy },{ gx - dx,gy + dy } };\n\t\t}\n\t}\n}\n//長方形\nstruct Square {\n\tdouble lx, ly, rx, ry;\n\tSquare(double lx_, double ly_, double rx_, double ry_) :lx(lx_), ly(ly_), rx(rx_), ry(ry_) {};\n\tbool include(point &p) {\n\t\treturn p.real() + EPS >= lx && p.real() - EPS <= rx && p.imag() + EPS >= ly && p.imag() - EPS <= ry;\n\t}\n};\n\nstruct Polygon : public vector<point> {\n\t//0->OUT, 1->ON, 2->IN\n\tint contains(const point &p) {\n\t\tbool in = false;\n\t\tint N = this->size();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpoint a = this->at(i) - p;\n\t\t\tpoint b = this->at((i + 1) % N) - p;\n\t\t\tif (imag(a) > imag(b)) {\n\t\t\t\tstd::swap(a, b);\n\t\t\t}\n\t\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\t\tif (cross(a, b) < 0)in = !in;\n\t\t\tif (cross(a, b) == 0 && dot(a, b) <= 0)return 1;\n\t\t}\n\t\treturn in ? 2 : 0;\n\t}\n};\n\nbool trapAll() {\n\tint N; cin >> N;\n\tif (N == 0)exit(0);\n\tLines ls;\n\tREP(i, N) {\n\t\tdouble x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tpoint p1(x1, y1);\n\t\tpoint p2(x2, y2);\n\t\tls.push_back(Line(p1, p2));\n\t}\n\tsplitSegments(ls);\n\t// for(auto l:ls){\n\t// \tcerr<<l[0]<<\" \"<<l[1]<<endl;\n\t// }\n\t//cerr << \"splitted\" << endl;\n\tvLines vls = connectedComponent(ls);\n\tfor (auto lines : vls) {\n\t\tPolygon poly;\n\t\tpoints ps= trace(lines);\n\t\tfor (auto p : ps) {\n\t\t\tpoly.push_back(p);\n\t\t}\n\t\tif (poly.contains(point(0, 0)))return true;\n\t}\n\treturn false;\n}\nvoid solve() {\n\tif (trapAll())cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\tif(DEBUG)cerr<<\"+++++++++++++\"<<endl;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t// while (true)\n\t// \tsolve();\n\tint q;cin>>q;\n\twhile(q--){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tpoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tLine l0(p0,p1),l1(p2,p3);\n\t\tif(intersectSS(l0,l1))cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersection(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersection(Segment s1, Segment s2) {\n\treturn intersection(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n\tint q, x[4], y[4];\n\tPoint p[4];\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> x[j] >> y[j];\n\t\t\tp[j] = Point(x[j], y[j]);\n\t\t}\n\t\tcout << intersection(p[0], p[1], p[2], p[3]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\n#include <cstdio>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repc(i, s, n) for (int i = (s); i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepc(i, s, n) for (int i = (s); i >= (n); i--)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n/*================================================\n\tGeometry\n================================================*/\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\nstruct Segment { Point p1, p2; };\ntypedef Segment Line;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n\ndouble Distance_PP(Point a, Point b) { return (a - b).abs(); }\ndouble Distance_PL(Point p, Line l) { return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs(); }\ndouble Distance_PS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn Distance_PL(p, s);\n}\ndouble Distance_SS(Segment s1, Segment s2) {\n\tdouble op1, op2, op3, op4, distance;\n\n\tif (intersect(s1, s2)) return 0.0;\n\n\top1 = Distance_PS(s1.p1, s2);\n\top2 = Distance_PS(s1.p2, s2);\n\top3 = Distance_PS(s2.p1, s1);\n\top4 = Distance_PS(s2.p2, s1);\n\n\tdistance = min(op1, op2);\n\tdistance = min(distance, op3);\n\tdistance = min(distance, op4);\n\n\treturn distance;\n}\n\nint main()\n{\n\tint q;\n\tSegment s1, s2;\n\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y;\n\t\tcin >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tcout << intersect(s1, s2) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine a, b;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &a.a.x, &a.a.y, &a.b.x, &a.b.y, &b.a.x, &b.a.y, &b.b.x, &b.b.y);\n\t\tif(!cmp(dis_segment_segment(a, b)))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t\t//~ Point res;\n\t\t//~ if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\t\t//~ puts(\"1\");\n\t\t//~ else\n\t\t\t//~ puts(\"0\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ld long double\n\n/* 幾何ライブラリ */\n\n// 定数\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ld PI_2 = 2 * PI;\nconst ld EPS = 1e-12L; // 誤差\n\n// 2次元座標, 2次元ベクトル\nusing pos = pair<ld, ld>;\n\n// 加算\npos add(pos p1, pos p2) {\n\treturn { p1.first + p2.first, p1.second + p2.second };\n}\n// 減算\npos sub(pos p1, pos p2) {\n\treturn { p1.first - p2.first, p1.second - p2.second };\n}\n// 内積\nld inner_product(pos p1, pos p2) {\n\treturn p1.first * p2.first + p1.second * p2.second;\n}\n// 定数倍\npos mul(ld c, pos p) {\n\treturn { c * p.first, c * p.second };\n}\n\n// ノルムの2乗\nld norm2(pos p) {\n\treturn p.first * p.first + p.second * p.second;\n}\n// ノルム\nld norm(pos p) {\n\treturn sqrt(norm2(p));\n}\n\n// 平行判定\nbool is_parallel(pos v1, pos v2) {\n\treturn abs(v1.first * v2.second - v1.second * v2.first) < EPS;\n}\n// 直行判定\nbool is_orthogonal(pos v1, pos v2) {\n\treturn abs(inner_product(v1, v2)) < EPS;\n}\n\n// 射影\n// pをp1, p2を通る直線に射影する\n// 検証済み(https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_A)\npos projection(pos p1, pos p2, pos p) {\n\tpos q = sub(p2, p1);\n\tpos tmp = mul(inner_product(q, sub(p, p1)) / norm2(q), q);\n\treturn add(p1, tmp);\n}\n\n// 反射\n// pをp1, p2を通る直線に関して対称移動する\n// 検証済み(https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_B)\npos reflection(pos p1, pos p2, pos p) {\n\tpos tmp = projection(p1, p2, p);\n\treturn add(p, mul(2.0, sub(tmp, p)));\n}\n\n// 位置関係\n// p0を基準に、p1, p2の位置関係を求める\n// p2が\n//\tp1から反時計回り方向 : COUNTER_CLOCKWISE\n//\tp1から時計回り方向 : CLOCKWISE\n//\tp1と反対方向(p2, p0, p1がこの順に同一直線上) : ONLINE_BACK\n//\tp1の延長線上(p0, p1, p2がこの順に同一直線上) : ONLINE_FRONT\n//\tp1の途中(線分p0p1の上) : ON_SEGMENT\n// 検証済み(https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_C)\nstring positional_relation(pos p0, pos p1, pos p2) {\n\tpos v1 = sub(p1, p0), v2 = sub(p2, p0);\n\tif (abs(v2.first) < EPS && abs(v2.second) < EPS) return \"ON_SEGMENT\";\n\tld r1 = atan2l(v1.second, v1.first), r2 = atan2l(v2.second, v2.first);\n\tif (abs(r1 - r2) < EPS || (abs(r1 - r2) > PI - EPS && abs(r1 - r2) < PI + EPS)) { // ONLINE\n\t\tif (v1.first * v2.first < 0 || v1.second * v2.second < 0)\n\t\t\treturn \"ONLINE_BACK\";\n\t\tif (abs(v1.first) < abs(v2.first) || abs(v1.second) < abs(v2.second))\n\t\t\treturn \"ONLINE_FRONT\";\n\t\treturn \"ON_SEGMENT\";\n\t}\n\t// NOT ONLINE\n\tif (r2 - r1 + (r2 - r1 < 0 ? PI_2 : 0) < PI)\n\t\treturn \"COUNTER_CLOCKWISE\";\n\treturn \"CLOCKWISE\";\n}\n\n// 線分の交差判定\n// 線分p0p1, q0q1が交叉するか、端点を含むかどうかは最後の引数(デフォルトは有効)\nbool cross(pos p0, pos p1, pos q0, pos q1, bool end_point = true) {\n\tld ta = (q0.first - q1.first) * (p0.second - q0.second)\n\t\t+ (q0.second - q1.second) * (q0.first - p0.first);\n\tld tb = (q0.first - q1.first) * (p1.second - q0.second)\n\t\t+ (q0.second - q1.second) * (q0.first - p1.first);\n\tld tc = (p0.first - p1.first) * (q0.second - p0.second)\n\t\t+ (p0.second - p1.second) * (p0.first - q0.first);\n\tld td = (p0.first - p1.first) * (q1.second - p0.second)\n\t\t+ (p0.second - p1.second) * (p0.first - q1.first);\n\tif (tc * td < -EPS && ta * tb < -EPS) return true;\n\telse if (!end_point) return false;\n\tif (positional_relation(p0, p1, q0) == \"ON_SEGMENT\"\n\t\t|| positional_relation(p0, p1, q1) == \"ON_SEGMENT\")\n\t\treturn true;\n\tif (positional_relation(q0, q1, p0) == \"ON_SEGMENT\"\n\t\t|| positional_relation(q0, q1, p1) == \"ON_SEGMENT\")\n\t\treturn true;\n\treturn false;\n}\n\nint main() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tpos p0, p1, p2, p3;\n\t\tcin >> p0.first >> p0.second;\n\t\tcin >> p1.first >> p1.second;\n\t\tcin >> p2.first >> p2.second;\n\t\tcin >> p3.first >> p3.second;\n\t\tbool f = cross(p0,p1,p2,p3);\n\t\tcout << (f ? 1 : 0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n?\n?\nusing namespace std;\n?\ntypedef double Real;\n?\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n?\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n?\nstruct Point{? \n??Real add(Real a, Real b){\n????if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n????return a+b;\n??}\n?\n??Real x, y;\n??Point(){}\n??Point(Real x,Real y) : x(x) , y(y){}\n?\n??Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n??Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n??Point operator * (Real d){return Point(x*d,y*d);}\n??Point operator / (Real d){return Point(x/d,y/d);}\n??bool operator == (Point p){return !sgn(dist(p));}\n??bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n??Real norm(){return sqr(x*x+y*y);}\n??Real dist(Point a){return (*this-a).norm();}\n??Real dot(Point a){return x*a.x+y*a.y;}\n??Real cross(Point a){return x*a.y-y*a.x;}\n??//点pを中心に角度r(radius)だけ半時計回りに回転する\n??Point rotate(Real r,Point p = Point(0,0)){\n????Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n????Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n????return Point(ta,tb);\n??}\n??Real arg(){\n????if(sgn(x)>0)return atan(y/x);\n????if(sgn(x)<0)return atan(y/x)+PI;\n????if(sgn(y)>0)return PI/2;\n????if(sgn(y)<0)return 3*PI/2;\n????return 0;\n??}\n};\n?\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n??b = b-a; c = c-a;\n??if (b.cross(c) > 0)?? return +1;?????? // counter clockwise\n??if (b.cross(c) < 0)?? return -1;?????? // clockwise\n??if (b.dot(c) < 0)???? return +2;?????? // c--a--b on line\n??if (b.norm() < c.norm()) return -2;??? // a--b--c on line\n??return 0;????????????????????????????? // a--c--b on line\n}\n?\nstruct Line{\n??Point a,b;\n?\n??Line(){}\n??Line(Point a,Point b):a(a),b(b){}\n?\n??bool on(Point c){return abs(ccw(a,b,c))!=1;}\n??Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n??bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n??bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n??bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n??//平行でない前提\n??Point intersectionPoint(Line l){\n????return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n??}\n?\n};\n?\nstruct Segment: public Line{\n??Point a,b;\n???\n??bool on(Point c){return ccw(a,b,c)==0;}\n??bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n?\n??Real dist(Point c){\n????if((b-a).dot(c-a)<EPS)return c.dist(a);\n????if((a-b).dot(c-b)<EPS)return c.dist(b);\n????return abs((b-a).cross(c-a))/b.dist(a);??? \n??}\n?\n??Point intersectionPoint(Segment s){\n????Point q=s.b-s.a;\n????Real d1=abs(q.cross(a-s.a));\n????Real d2=abs(q.cross(b-s.a));\n????Real t=d1/(d1+d2);\n????return a+(b-a)*t;\n??}\n?\n??//この線分が直線lの上に載っていない前提\n??bool isIntersection(Line l){\n????int p=ccw(a,b,l.a);\n????int q=ccw(a,b,l.b);\n????return (p==1 && q==-1)||(p==-1 && q==1);\n??}\n?\n??bool isIntersection(Segment s){\n????return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n????????ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n??}\n};\n?\nint main(void){\n?\n??int q;\n??cin >> q;\n??while(q--){\n????Segment a,b;\n????cin >> a.a.x >> a.a.y >> a.b.x >> a.b.y;\n????cin >> b.a.x >> b.a.y >> b.b.x >> b.b.y;\n????cout << a.isIntersection(b) << endl;\n??}\n?\n??return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nbool equals(double a, double b){ return (fabs(a) - fabs(b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint q;\n\t\n\tcin>>q;\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tSegment s1, s2;\n\t\tcin>>s1.p1.x>>s1.p1.y>>s1.p2.x>>s1.p2.y;\n\t\tcin>>s2.p1.x>>s2.p1.y>>s2.p2.x>>s2.p2.y;\n\t\t\n\t\tcout<<intersect(s1, s2)<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\n//定義系\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//Point\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {\n\t}\n\tPoint operator + (Point p) {\n\t\treturn Point(add(x, p.x), add(y, p.y));\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(add(x, -p.x), add(y, -p.y));\n\t}\n\tPoint operator * (double d) {\n\t\treturn Point(x*d, y*d);\n\t}\n\tPoint operator / (double d) {\n\t\treturn Point(x / d, y / d);\n\t}\n\t//内積\n\tdouble dot(Point p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(Point p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\t//点の大小比較\n\tbool operator <(const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\n//ベクトル。使い分けるといいかも\ntypedef Point Vector;\n\n//ベクトルの大きさの2乗\ndouble norm(Vector p) {\n\treturn p.x*p.x + p.y*p.y;\n}\n\n//ベクトルの大きさ\ndouble abs(Vector p) {\n\treturn sqrt(norm(p));\n}\n\n//線分\nstruct Segment {\n\tPoint p1, p2;\n};\n\n//直線\ntypedef Segment Line;\n\n//中心c,半径rの円\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n\n\n\n//計算・アルゴリズム系\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (a.det(b) > EPS)return COUNTER_CLOCKWISE;\n\tif (a.det(b) < -EPS)return CLOCKWISE;\n\tif (a.dot(b) < -EPS)return ONLINE_BACK;\n\tif (norm(a)<norm(b))return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルa,bの直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn a.dot(b) == 0.0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).dot(s2.p2 - s2.p1) == 0.0;\n}\n\n//ベクトルa,bの並行判定\nbool isParallel(Vector a, Vector b) {\n\treturn a.det(b) == 0.0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).det(s2.p2 - s2.p1) == 0.0;\n}\n\n//射影(点p1と点p2を通る直線に点pから垂線を引いた交点xを求める)\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = (p - s.p1).dot(base) / norm(base);\n\treturn s.p1 + base*r;\n}\n\n//反射(点p1と点p2を通る直線を対象軸として点pと線対称の位置にある点xを求める)\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\n//点aと点bの距離\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n//直線lと点pの距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs((l.p2 - l.p1).det(p - l.p1) / abs(l.p2 - l.p1));\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif ((s.p2 - s.p1).dot(p - s.p1) < 0.0)return abs(p - s.p1);\n\tif ((s.p1 - s.p2).dot(p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n//線分s1と線分s2の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n//距離の二乗\ndouble dist(Point p, Point q) {\n\treturn (p - q).dot(p - q);\n}\n\n//辞書順で比較\nbool cmp_x(const Point& p, const Point& q) {\n\tif (p.x != q.x)return  p.x < q.x;\n\treturn p.y < q.y;\n}\n\n//凸包を求める\nvector<Point> convex_hull(Point* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;//凸法の頂点数\n\tvector<Point> qs(n * 2);//構築中の凸包\n\n\t\t\t\t\t\t//下限凸包の作成\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\n\t//上限凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint main() {\n\tSegment s1, s2;\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tcout << fixed<<setprecision(13)<< intersect(s1, s2) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n  static bool crossing(P p1,P p2,P q1,P q2)\n  {\n    if((p2-p1).sign(q2-q1)==0) return (q2-p1).sign(q1-p1) == 0;\n    double x=(q2-q1).det(q1-p1)/(q2-q1).det(p2-p1);\n    double y=(p2-p1).det(p1-q1)/(p2-p1).det(q2-q1);\n    return x<=1 && x>=0 && y<=1 && y>=0;\n  }\n};\n\n\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n};\n\n//1?¬?\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\n//??????\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//??????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//??´?????????\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) { return isOrthogonal(a1 - a2, b1 - b2); }\nbool isOrthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isParallel(Point a1, Point a2, Point b1, Point b2) { return isParallel(a1 - a2, b1 - b2); }\nbool isParallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//?????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//???????????????\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//2??????????????¢\ndouble getDistance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n//????????¨??????????????¢\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tscanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\t\t}\n\t\tcout << intersect(p[0], p[1], p[2], p[3]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (!isis_ll(s, t)) return false;\n\tPoint is = is_ll(s, t);\n\treturn isis_sp(s, is) && isis_sp(t, is);\n}\n\nint main()\n{\n\tint q;\n\tld x1, x2, x3, x4, y1, y2, y3, y4;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n\t\tLine l1 = { (Point) { x1, y1 }, (Point) { x2, y2 } };\n\t\tLine l2 = { (Point) { x3, y3 }, (Point) { x4, y4 } };\n\t\tcout << isis_ss(l1, l2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nconst double eps = 1e-10;\nclock_t START, END;\n\nint X, Y, E;\n\n//basic defitition\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n};\ntypedef Point Vector;\nVector operator + (Vector A, Vector B) { return Vector(A.x + B.x, A.y + B.y); }\nVector operator - (Point A, Point B) { return Vector(A.x - B.x, A.y - B.y); }\nVector operator * (Vector A, double p) { return Vector(A.x * p, A.y * p); }\nVector operator / (Vector A, double p) { return Vector(A.x / p, A.y / p); }\nbool operator < (const Point& a, const Point& b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }\nint dcmp(double x) { if (fabs(x) < eps)return 0; else return x < 0 ? -1 : 1; }\nbool operator == (const Point& a, const Point& b) { return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0; }\n// basic operator\ndouble Dot(Vector A, Vector B) { return A.x * B.x + A.y * B.y; }\ndouble Length(Vector A) { return sqrt(Dot(A, A)); }\ndouble Angle(Vector A, Vector B) { return acos(Dot(A, B) / Length(A) / Length(B)); }\ndouble Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }\ndouble Area2(Point A, Point B, Point C) { return Cross(B - A, C - A); }\nVector Rotate(Vector A, double rad) { return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); }\nVector Normal(Vector A) { double L = Length(A); return Vector(-A.y / L, A.x / L); } //A is not zero vector\n//point and line\nPoint GetLineIntersection(Point P, Vector v, Point Q, Vector w) {\n\tVector u = P - Q;\n\tdouble t = Cross(w, u) / Cross(v, w);\n\treturn P + v * t;\n}//two lines only have one intersection and Cross(v,w) is not zero\ndouble DistanceToLine(Point P, Point A, Point B) {\n\tVector v1 = B - A, v2 = P - A;\n\treturn fabs(Cross(v1, v2)) / Length(v1);\n}\ndouble DistanceToSegment(Point P, Point A, Point B) {\n\tif (A == B) return Length(P - A);\n\tVector v1 = B - A, v2 = P - A, v3 = P - B;\n\tif (dcmp(Dot(v1, v2)) < 0) return Length(v2);\n\telse if (dcmp(Dot(v1, v3)) > 0) return Length(v3);\n\telse return fabs(Cross(v1, v2)) / Length(v1);\n}\nPoint GetLineProjection(Point P, Point A, Point B) {\n\tVector v = B - A;\n\treturn A = v * (Dot(v, P - A) / Dot(v, v));\n}\nbool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) {\n\tdouble c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n\treturn dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;\n}\nbool OnSegment(Point p, Point a1, Point a2) {\n\treturn dcmp(Cross(a1 - p, a2 - p)) == 0 && dcmp(Dot(a1 - p, a2 - p)) <= 0;\n}\n//polygon\ndouble ConvexPolygonArea(Point* p, int n) {\n\tdouble area = 0;\n\tfor (int i = 1; i < n - 1; i++)\n\t\tarea == Cross(p[i] - p[0], p[i + 1] - p[0]);\n\treturn area / 2;\n}\n\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint q;\n\tPoint A, B, C, D;\n\tint a, b, c, d;\n\tbool ans;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y, &C.x, &C.y, &D.x, &D.y);\n\t\ta = dcmp(Cross(B - A, C - A));\n\t\tb = dcmp(Cross(B - A, D - A));\n\t\tc = dcmp(Cross(D - C, A - C));\n\t\td = dcmp(Cross(D - C, B - C));\n\t\tif (a * b < 0 && c * d < 0)\n\t\t\tcout << \"1\" << endl;\n\t\telse if (a * b > 0 && c * d > 0)\n\t\t\tcout << \"0\" << endl;\n\t\telse {\n\t\t\tans = false;\n\t\t\tif (!a && OnSegment(C, A, B))\n\t\t\t\tans = true;\n\t\t\tif (!b && OnSegment(D, A, B))\n\t\t\t\tans = true;\n\t\t\tif (!c && OnSegment(A, C, D))\n\t\t\t\tans = true;\n\t\t\tif (!d && OnSegment(B, C, D))\n\t\t\t\tans = true;\n\t\t\tif (ans)\n\t\t\t\tcout << \"1\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"0\" << endl;\n\t\t}\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nclass Vector\n{\npublic:\n  double x;\n  double y;\n\n  Vector(){}\n  Vector( double x, double y ) : x(x), y(y) {}\n\n  Vector operator + ( const Vector v ) { return Vector( x + v.x, y + v.y ); }\n  Vector operator - ( const Vector v ) { return Vector( x - v.x, y - v.y ); }\n  Vector operator * ( const double k ) { return Vector( x * k, y * k ); }\n  Vector operator / ( const double k ) { return Vector( x / k, y / k ); }\n  bool operator < ( const Vector &v ) const { return x * x + y * y < v.x * v.x + v.y * v.y; }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  static double dot( Vector v1, Vector v2 ) { return v1.x * v2.x + v1.y * v2.y; }\n  static double cross( Vector v1, Vector v2 ) { return v1.x * v2.y - v1.y * v2.x; }\n};\n\nclass Intersection\n{\npublic:\n  Vector p0, p1, p2, p3;\n  Intersection(){}\n  Intersection( Vector p0, Vector p1, Vector p2, Vector p3 ) : p0(p0), p1(p1), p2(p2), p3(p3) {}\n  int solve();\n};\n\nint Intersection::solve()\n{\n  Vector p10 = p1 - p0;\n  Vector p20 = p2 - p0;\n  Vector p30 = p3 - p0;\n  Vector p32 = p3 - p2;\n  Vector p02 = p0 - p2;\n  Vector p12 = p1 - p2;\n  \n  double c0 = Vector::cross( p10, p20 );\n  double c1 = Vector::cross( p10, p30 );\n  double c2 = Vector::cross( p32, p02 );\n  double c3 = Vector::cross( p32, p12 );\n  \n  if ( c0 == 0 && c1 == 0 && c2 == 0 && c3 == 0 )\n    {\n      Vector p01 = p0 - p1;\n      Vector p21 = p2 - p1;\n      Vector p31 = p3 - p1;\n\n      if ( Vector::dot( p10, p20) < 0 && Vector::dot( p10, p30 ) < 0 )\n        cout << \"0\" << endl;\n      else if ( Vector::dot( p01, p21 ) < 0 && Vector::dot( p01, p31 ) < 0 )\n        cout << \"0\" << endl;\n      else\n        cout << \"1\" << endl;\n    }\n  else if ( c0 * c1 <= 0 && c2 * c3 <= 0 )\n    cout << \"1\" << endl;\n  else\n    cout << \"0\" << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int q;\n  cin >> q;\n\n  for ( auto i = 0; i < q; ++i )\n    {\n      double x0, y0, x1, y1, x2, y2, x3, y3;\n      cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n      Intersection s( Vector(x0, y0), Vector(x1, y1), Vector(x2, y2), Vector(x3, y3) );\n      s.solve();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\nusing vec = complex<double>;\nusing line = pair<vec,vec>;\nconst double eps = 0.0000001;\n\ndouble inner_product(vec u,vec v){\n    return real(u*conj(v));\n}\ndouble cross_product(vec u,vec v){\n    return imag(conj(u)*v);\n}\n\ndouble norm(vec& u){\n    return abs(u);\n}\n\nvec projection(line l,vec p){//p???l???????°???±\n    vec s=l.first, t=l.second;\n    double k = inner_product(t-s,p-s)/inner_product(t-s,t-s);\n    return (1.0-k)*s+k*t;\n}\n\nvec reflection(line l,vec p){\n    return 2.0*projection(l,p)-p;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = cross_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\n//???????????§???????????????\n\nbool isIntersect(line l0, line l1){\n    int s = ccw(l0.first,l0.second,l1.first)*ccw(l0.first,l0.second,l1.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    s=ccw(l1.first,l1.second,l0.first)*ccw(l1.first,l1.second,l0.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    else return true;\n}\n\nint main(void){\n    int q;\n    cin >> q;\n    while(q--){\n        int x,y;\n        cin>>x>>y;\n        vec p0(x,y);\n        cin>>x>>y;\n        vec p1(x,y);\n        cin>>x>>y;\n        vec p2(x,y);\n        cin>>x>>y;\n        vec p3(x,y);\n        if(isIntersect(line(p0,p1),line(p2,p3))) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n//#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n//#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n             ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nint main(){\n    int n;\n\n    cin >> n;\n    while(n--){\n        double a[8];\n        rep(i,8) cin >> a[i];\n\n        cout << isIntersectedLs(Point(a[0], a[1]), Point(a[2], a[3]), Point(a[4], a[5]), Point(a[6], a[7])) << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////\n// 平面幾何\n\n// 型変換できるもの\n//   double  -> Point\n//   Segment -> Line\n\n// 誤差の話：絶対誤差でも相対誤差でも死ぬ例\n// int main(){\n//   const double EPS = 1e-9;\n//   double a = 1.3, b = 1e8, c = a + b;\n//   c = c - b;\n//   printf(\"%d\\n\", equal(a, c));          // => 0\n//   printf(\"%d\\n\", relative_equal(a, c)); // => 0\n// }\n\n////////////////////\n// ライブラリ\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// 定数\nconst double EPS = 1e-9;                // |EPS|未満の数は0として扱う\n////////////////////\n// 構造体\nstruct Point {\n  double x, y;\n  Point(const double d = 0.0) :x(d), y(d) {}\n  Point(const double x, const double y) :x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) :initial(initial), terminal(terminal) {}\n  Segment(const double x1, const double y1, const double x2, const double y2) :initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) :initial(initial), terminal(terminal) {}\n  Line(const double x1, const double y1, const double x2, const double y2) :initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) :initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// 実装\nbool relative_equal(const double d1, const double d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// 演算子オーバーロード\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x > rhs.x : lhs.y > rhs.y;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// 点\ndouble abs(const Point& p) {return std::hypot(p.x, p.y);}\ndouble norm(const Point& p) {return p.x * p.x + p.y * p.y;}\ndouble dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\ndouble cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// 線\nbool parallel(const Line& l1, const Line& l2) {return std::abs(cross(l2.terminal - l2.initial, l1.terminal - l1.initial)) < EPS;}\nbool orthogonal(const Line& l1, const Line& l2) {return std::abs(dot(l2.terminal - l2.initial, l1.terminal - l1.initial)) < EPS;}\n// 点の位置関係\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK}; \nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(relative_equal(norm(v2), - norm(v1))) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// 交差判定\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// 点の移動\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// 距離\ndouble distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\ndouble distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\ndouble distance(const Segment& s, const Point& p) {return distance(p, s);}\ndouble distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\ndouble distance(const Line& l, const Point& p) {return distance(p, l);}\ndouble distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\ndouble distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\ndouble distance(const Line& l,const Segment& s) {return distance(s, l);}\ndouble distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// 交点\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // 平行なときl1の始点を返す\n  double A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  double B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  Point cp = crosspoint(Line(s), l);\n  assert(intersect(s, cp));\n  return cp;\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // 平行なときいずれかの端点を返す\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// デバッグ用\n#include<bits/stdc++.h>\nusing namespace std;\nvoid print(const Point& p) {cout<<\"point: \"; cout<<\"(\"<<p.x<<\",\"<<p.y<<\")\";}\nvoid print(const Segment& l) {cout<<\"segment: \"; print(l.initial); cout<<\" - \";print(l.terminal);}\nvoid print(const Line& l) {cout<<\"line: \"; print(l.initial); cout<<\" - \";print(l.terminal);}\n////////////////////////////////////////////////////////////////////////////////\n// 多角形\n//   辺をメンバ変数にしない→メモリ節約・edge(void)がO(頂点数)\n#include<vector>\n#include<algorithm>\n#include<utility>\nclass Polygon {\npublic:\n  void add(const Point& p) {\n    if(!vertex_.empty()) {\n      if(!edge_.empty()) edge_.pop_back();\n      edge_.push_back(Segment(vertex_.back(), p));\n      edge_.push_back(Segment(p, vertex_.front()));\n    }\n    vertex_.push_back(p);\n  }\n  int size() const {return vertex_.size();}\n  Point vertex(const int n) const {return vertex_.at(n);}\n  Segment edge(const int n) const {return edge_.at(n);}\n  const std::vector<Point>& vertex() const {return vertex_;}\n  const std::vector<Segment>& edge() const {return edge_;}\n  bool touch(const Point& p) const {\n    return std::any_of(edge_.begin(), edge_.end(), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n  }\n  bool intersect(const Point& p) const {\n    bool in = false;                    // p=(x,y)から(INF,y)への半直線と多角形とが交差する回数 mod 2\n    for(const auto& e: edge()) {\n      if(::intersect(p, e)) return true;\n      Point a = e.initial  - p;\n      Point b = e.terminal - p;\n      if(a.y > b.y) std::swap(a, b);\n      if(a.y <= EPS && -EPS < b.y && cross(a, b) < EPS) in = !in;\n    }\n    return in;\n  }\n  void clear() {\n    vertex_.clear();\n    edge_.clear();\n  };\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  for(cin >> n; n > 0; --n) {\n    int a, b, c, d, e, f, g, h;\n    cin >> a >> b >> c >> d >> e >> f >> g >> h;\n    Segment s(Point(a, b), Point(c, d));\n    Segment t(Point(e, f), Point(g, h));\n//     cout << (parallel(s, t) ? 2 : (orthogonal(s, t) ? 1 : 0)) << endl;\n    cout << (intersect(s, t) ? 1 : 0) << endl;\n//     auto cp = crosspoint(s, t);\n//     cout<<setprecision(10)<<fixed<<cp.x<<\" \"<<cp.y<<endl;\n  }\n\n//   Polygon polygon;\n//   for(cin >> n; n > 0; --n) {\n//     int x, y;\n//     cin >> x >> y;\n//     polygon.add(Point(x, y));\n//   }\n\n//   int q;\n//   for(cin >> q; q > 0; --q) {\n//     int x, y;\n//     cin >> x >> y;\n//     Point p(x, y);\n//     cout << (polygon.touch(p) ? 1 : (polygon.intersect(p) ? 2 : 0)) << endl;\n//   }\n}"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define eps 1e-14\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nint cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_intersect(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) <= 0)\n\t\t\t&& (cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) <= 0);\n}\n\nint ax, ay, bx, by;\nint n;\nvector<P> v;\nP A, B;\n//void solve() {\n//\tcin >> ax >> ay >> bx >> by;\n//\tA = P(ax, ay);\n//\tB = P(bx, by);\n//\tcin >> n;\n//\trep(i,0,n)\n//\t{\n//\t\tint x, y;\n//\t\tcin >> x >> y;\n//\t\tv.push_back(P(x, y));\n//\t}\n//\tint cnt = 0;\n//\tfor (int i = 1; i <= n; ++i) {\n//\t\tP p1 = v[i - 1], p2 = v[i % n];\n//\t\tif (is_intersect(A, B, p1, p2)) {\n//\t\t\tcnt++;\n//\t\t}\n//\t}\n//\tcout << cnt / 2 + 1 << endl;\n//}\n\nvoid solve() {\n\tint q;\n\tcin >> q;\n\trep(i,0,q)\n\t{\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tcout\n\t\t\t\t<< (is_intersect(P(x0, y0), P(x1, y1), P(x2, y2), P(x3, y3)) ?\n\t\t\t\t\t\t1 : 0) << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nclass Point{\npublic:\n\tPoint(const int argx = 0, const int argy = 0):x(argx),y(argy){};\n\tint x, y;\n};\nclass Line{\npublic:\n\tLine(const int x1, const int y1, const int x2, const int y2):p1(x1, y1),p2(x2, y2),X(x1 - x2),Y(y1 - y2){\n\t\tif (x1 > x2){\n\t\t\tmaxx = (x1);\n\t\t\tminx = (x2);\n\t\t}else{\n\t\t\tmaxx = (x2);\n\t\t\tminx = (x1);\n\t\t}\n\t\tif (y1 > y2){\n\t\t\tmaxy = (y1);\n\t\t\tminy = (y2);\n\t\t}else{\n\t\t\tmaxy = (y2);\n\t\t\tminy = (y1);\n\t\t}\n\t};\n\tbool is_parallel(const Line &other) const {\n\t\treturn (X * other.Y) == (Y * other.X);\n\t}\n\tbool is_over_x(const Line &other) const {\n\t\treturn (X * X + other.X * other.X >= (maxx - other.maxx) * (maxx - other.maxx) + (minx - other.minx) * (minx - other.minx));\n\t}\n\tbool is_over_y(const Line &other) const {\n\t\treturn (Y * Y + other.Y * other.Y >= (maxy - other.maxy) * (maxy - other.maxy) + (miny - other.miny) * (miny - other.miny));\n\t}\n\tint get_Xy(const int &other_x) const {return (Y * other_x + (X * p2.y - Y * p2.x));}\n\tint get_Yx(const int &other_y) const {return (X * other_y + (Y * p2.x - X * p2.y));}\n\tbool is_cross_x(const Line &other) const {\n\t\treturn (other.X * p1.y - other.get_Xy(p1.x)) * (other.X * p2.y - other.get_Xy(p2.x)) <= 0;\n\t}\n\tbool is_cross_y(const Line &other) const {\n\t\treturn (other.Y * p1.x - other.get_Yx(p1.y)) * (other.Y * p2.x - other.get_Yx(p2.y)) <= 0;\n\t}\n\tbool is_intersection(const Line &other) const {\n\t\tif (is_parallel(other)){\n\t\t\tif (X * Y == 0){\n\t\t\t\tif (X == 0){\n\t\t\t\t\treturn p1.x == other.p1.x and is_over_y(other);\n\t\t\t\t}else{\n\t\t\t\t\treturn p1.y == other.p1.y and is_over_x(other);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn is_cross_x(other) and is_over_x(other);\n\t\t\t}\n\n\t\t}else{\n\t\t\tif (Y == 0 or other.Y == 0){\n\t\t\t\treturn is_cross_x(other) and other.is_cross_x((*this));\n\t\t\t}else{\n\t\t\t\treturn is_cross_y(other) and other.is_cross_y((*this));\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\tPoint p1, p2;\n\tint X, Y, maxx, maxy, minx, miny;\n\tint x_diff() const {if (X < 0){return -X;}else{return X;}}\n\tint y_diff() const {if (Y < 0){return -Y;}else{return Y;}}\n};\nint main(){\n\tint q;\n\tstd::scanf(\"%d\", &q);\n\tfor (auto i = 0; i < q; ++i){\n\t\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tstd::scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tLine l1(x0, y0, x1, y1), l2(x2, y2, x3, y3);\n\t\tif (l1.is_intersection(l2)){\n\t\t\tstd::printf(\"1\\n\");\n\t\t}else{\n\t\t\tstd::printf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*******************??????********************/\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {//??????\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??????\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\nstruct C {//???\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {//??????????????????\n\tb -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n\t//non-parallel || sameline\n\treturn abs(cross(l[1]-l[0],m[1]-m[0])) > EPS || abs(cross(l[1]-l[0],m[0]-l[0])) < EPS;\n}\nbool intersectLS(const L& l,const L& s){\n\t// s[0] is left of l,s[1] is right of l\n\treturn cross(l[1]-l[0],s[0]-l[0]) * cross(l[1]-l[0],s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectLP(const L& l,const P& p){\n\treturn abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool intersectSP(const L& s,const P& p){\n\treturn abs(s[0]-p)+abs(s[1]-p) - abs(s[1]-s[0]) < EPS;// triangle inequality\n}\n// ??´???????????????\nbool orthogonalLL(const L &l1, const L &l2){\n\treturn (dot(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && dot(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// ??????????????????\nbool parallelLL(const L &l1, const L &l2){\n\treturn (cross(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && cross(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n\nP projection(const L& l,const P& p){\n\tdouble t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L& l,const P& p){\n\treturn p + 2. * (projection(l,p) - p);\n}\ndouble distanceLP(const L& l,const P& p){\n\treturn abs(p - projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m){\n\treturn intersectLL(l,m) ? 0 : distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s){\n\tif(intersectLS(l,s)) return 0;\n\treturn min(distanceLP(l, s[0]),distanceLP(l, s[1]));\n}\n\nint main(void){\n\tint q;\n\tcin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tvector<P> p(4);\n\t\tint x,y;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tcin >> x >> y;\n\t\t\tp[j] = P(x,y);\n\t\t}\n\t\tL l0(p[0],p[1]),l1(p[2],p[3]);\n\t\tif(intersectSS(l0,l1))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n  double x;\n  double y;\n  \n  Point(){}\n  Point(double x,double y) : x(x),y(y){}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); } //演算子のオーバーロード\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double k) { return Point(x * k, y * k); }\n  Point operator / (double k) { return Point(x / k, y / k ); }\n  bool operator == (Point p1) {\n    if(p1.x == x && p1.y == y)\n      return true;\n    else \n      return false;\n  }\n\n};\n\ndouble norm(Point p0, Point p1) {\n  return sqrt(pow(p1.x - p0.x, 2) + pow(p1.y - p0.y, 2));\n}\n\ndouble dot(Point p0, Point p1, Point p2) {\n  return (p1.x - p0.x) * (p2.x - p0.x) + (p1.y - p0.y) * (p2.y - p0.y);\n}\n\ndouble cross(Point p0, Point p1, Point p2) {\n  return ( p1.x - p0.x ) * ( p2.y - p0.y ) - ( p2.x - p0.x) * (p1.y - p0.y);\n}\n\nint positional_relationship(Point p0, Point p1, Point p2) {\n  if(cross(p0, p1, p2) > 0) //反時計回り\n    return 1;\n  else if(cross(p0, p1, p2) < 0) //時計回り\n    return -1;\n  else if(dot(p0, p1, p2) < 0) //一直線上で反転向き\n    return 2;\n  else if(norm(p0, p1) < norm(p0, p2)) // 一直線上で同じ向き\n    return -2;\n  else //線分上に存在\n    return 0;  \n}\n\nbool isIntersected(Point p0, Point p1, Point p2, Point p3) {\n  if(positional_relationship(p0, p1, p2) * positional_relationship(p0, p1, p3) <= 0 && positional_relationship(p2, p3 ,p0) * positional_relationship(p2, p3, p1) <= 0)\n    return true;\n  return false;\n};\n\n\nint main(void) {\n  int q;\n  cin >> q;\n  Point p0, p1, p2, p3;\n\n  for(int i = 0; i < q; i++) {\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    \n    if(isIntersected(p0, p1, p2, p3))\n      cout << \"1\" << endl;\n    else \n      cout << \"0\" << endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (c == P(0, 0) || c == b) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nint crossSS(L l, L m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        r = max(min(l.s, l.t), min(m.s, m.t));\n        P q = min(max(l.s, l.t), max(m.s, m.t));\n        return (r == q) ? 1 : (q < r ? 0 : -1);\n    }\n    if (ccw(l, r) == 0 && ccw(m, r) == 0) return 1;\n    return 0;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n \n    int q;\n    cin >> q;\n    for (int ph = 0; ph < q; ph++) {\n        D x, y;\n        P p1, p2, p3, p4;\n        cin >> x >> y; p1 = P(x, y);\n        cin >> x >> y; p2 = P(x, y);\n        cin >> x >> y; p3 = P(x, y);\n        cin >> x >> y; p4 = P(x, y);\n        L l1 = L(p1, p2), l2 = L(p3, p4);\n        P p;\n        cout << abs(crossSS(l1, l2, p)) << endl;\n    }    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps (1e-10)\nusing namespace std;\nclass Point\n{\n\tpublic:\n\tdouble x,y;\n\tPoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y);} \n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);} \n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble ABS(){return sqrt(norm());} //俩点间的距离 \n};\nstruct Segment\n{\n\tPoint p1,p2;\t\n};\n\ndouble dot(Point a,Point b)//求内积 就是向量a*b \n{\n\treturn a.x*b.x+a.y*b.y;\n}\n//外积的值为a与b向量构成的平行四边形面积的值 \ndouble cross(Point a,Point b)//求外积 \n{\n\treturn a.x*b.y-a.y*b.x;\n} \n\n\n//判断是否正交 向量内积：a*b=|a||b|*cos(Y) 当cos为0时正交(90,-90垂直) \n//a*b=a.x*b.x+a.y*b.y;\nbool solve1(Point a,Point b)//是否正交 \n{\n\tdouble f=a.x*b.x+a.y*b.y; \n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n//判断是否平行  向量外积：|a*b|=|a||b|sin(Y) 当sin为0时平行(180,0平行)\n//|a*b|=|a|*|b|*sin(Y) \nbool solve2(Point a,Point b)//是否平行 \n{\n\tdouble f=a.x*b.y-a.y*b.x;\n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求 \n*/\nPoint solve3(Segment s,Point p)//求投影点 \n{\n\tPoint base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r; \n}\n/*\n求投影点x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线为对称轴与点p\n成线对称点为x \n通过求solve3的垂足延长一倍就可以求x \n*/\nPoint solve4(Segment s,Point p)//求映象 \n{\n\treturn p+(solve3(s,p)-p)*2.0;\n}\n\n/*\n点a与点b之间的距离等于向量a-b或b-a的绝对值。 \n*/ \ndouble getdis(Point a,Point b)//求俩点间的距离                    \n{\n\treturn (a-b).ABS();\n} \n\n/*\n设直线p1 p2上的向量为a=p2-p1,p与p1构成的向量b=p-p1\n则点p与直线p1p2的距离d就等于a,b构成的平行四边形的高\n用a与b外积的大小(平行四边形的面积)除以a的大小|a|即可求出高d\nd=|a*b|/|a|=|(p2-p1)*(p-p1)|/|p2-p1|; \n*/\n//注意：这里Segmet s是不规范的应该是 Line s 才对 \ndouble getdis_Li(Segment s,Point p)//点与直线的距离 \n{\n\treturn abs(cross(s.p2-s.p1,p-s.p1)/(s.p2-s.p1).ABS());\n}\n/*\nPoint a=p1-p0;\nPoint b=p2-p0;\n1.外积大小cross(a,b)为正时,可确定b在a的逆时针方向\n\tsin(Y)（Y在0-180）所以是正数\n2. 外积大小cross(a,b)为负时,可确定b在a的顺时针方向\n3.（1,2）不符合 表示p2在直线p0p1上(注意是直线),cos(Y)大于90或小于-90\n\t度时为负，因此a与b的内积dot(a,b)负时，可确定p2位于线段p0p1后方\n\t即p2->p0->p1\n4.不是3时，有俩种p0->p1-p2或者p0->p2->p1如果b的大小大于a的大小，即为\n\tp0->p1->p2;\n5.不符合4，可以确定p2位于线段p0p1上 \n*/ \nint ccw(Point p0,Point p1,Point p2)//判断三个点相对位置 \n{\n\tPoint a=p1-p0;\n\tPoint b=p2-p0;\n\tif(cross(a,b)>eps) return 1;//p0,p1,p2成逆时针方向 \n\tif(cross(a,b)<-eps) return -1;//p0,p1,p2成顺时针方向 \n\t//if(dot(a,b)<-eps) return 2;//p2 p0 p1一次排列在同一直线上 \n\t//if(a.norm()<b.norm()) return -2;// p0 p1 p2一次排列在同一直线上 \n\treturn 0;//p2在线段p0p1上 \n\t\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nint main()\n{\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tif(intersect(p0,p1,p2,p3)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<cstdio>\nusing namespace std;\n#define EPS 1e-10\nstatic const int COUNTER_CLOCKWISE = 1;\t\t\t\t\t//逆时针   \nstatic const int CLOCKWISE = -1;\t\t\t\t\t\t\t//顺时针\nstatic const int ONLINE_BACK = 2;\t\t\t\t\t\t//p2 在直线后面\nstatic const int ONLINE_FRONT = -2;\t\t\t\t\t\t//p2 在直线前面\nstatic const int ON_SEGMENT = 0;\t\t\t\t\t\t//p2 在直线上\nint equals(double a, double b) { return fabs(a - b) < EPS; };\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x=0, double y=0) :x(x), y(y) { };\n\tPoint operator + (Point& p) {\n\t\treturn Point(p.x + x, p.y + y);\n\t}\n\tPoint operator - (Point& p) {\n\t\t\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k*x, k*y);\n\t}\n\tdouble abs() {\t\t\t\t\t//向量长度;\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ntypedef Point Vector;\ndouble dot(Vector a, Vector b) {\t\t\t//内积 x1*x2 + y1*y2\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\t\t  //外积  x1*y2 - x2*y1\n\treturn a.x * b.y - a.y * b.x;\n}\nstruct Segment           //线段\n{\n\tPoint a, b;\n};\ntypedef Segment Line;   //线段表示直线；\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double x = 0) :c(c), r(x) {};\n};\nvoid Parallel_Orthogonal() {\t\t\t\t//判断平行或正交\n\tPoint a, b,c,d;\n\tPoint e, f;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a.x >> a.y >> b.x >> b.y>>c.x>>c.y>>d.x>>d.y;\n\t\te = a - b;\n\t\tf = c - d;\n\t\tif (equals(dot(e, f), 0)) cout << \"1\" << endl;\n\t\telse if (equals(cross(e, f), 0))cout << \"2\" << endl;\n\t\telse cout <<\"0\" <<endl;\n\t}\n}\nPoint Projection(Point& a, Point& b, Point& c) {\t\t//计算投影点\n\tPoint p;\n\tVector v1 = b - a;\n\tVector v2 = c - a;\n\tdouble len = dot(v1, v2);\n\tdouble len2 = len/ v1.abs();\n\tp.x = a.x + len2 / v1.abs() * v1.x;\n\tp.y = a.y + len2 / v1.abs() * v1.y;\n\treturn p;\n}\nPoint Reflection(Point& a, Point& b, Point& c) {\t//算映像\n\tPoint p = Projection(a, b, c);\t\t\t\t\t//算出映射点\n\treturn p*2 - c;\t\t\t\t\t\t\t\t\t//映射点 是 该点与映像点中点  x + c = 2*p；\n}\ndouble getDistancePP(Point a, Point b) {\t\t\t\t//两点距离;\n\treturn ((a - b).abs());\n}\ndouble getDistancePL(Point a, Line b) {\t\t\t//求点到直线距离 外积 = |a|.|b|.sin0  在直线上取两点，然后以其中一点为端点求出外\n\tVector m = b.a - b.b;\t\t\t\t\t\t//积的大小 再除以直线上的向量大小 则可以求解。\n\tVector m2 = a - b.b;\n\treturn cross(m, m2) / m.abs();\n}\nint ccw(Point a, Point b, Point c) {\t\t\t//三个点的位置关系\n\tVector p = b - a;\n\tVector p2 = c - a;\n\tif (cross(p, p2) > EPS) return COUNTER_CLOCKWISE;\t\t//逆时针方向向外 结果为正\n\tif (cross(p, p2) < -EPS) return CLOCKWISE;\t\t\t\t//顺时针方向为内 结果为负\n\tif (dot(p, p2) < -EPS) return ONLINE_BACK;\n\tif (dot(p, p2) > EPS&& p2.abs() > p.abs()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\ndouble getDistancePS(Point a, Segment b) {\t\t//点到线段的距离;\n\tPoint p1, p2;\n\tp1 = a - b.a;\n\tp2 = b.b - b.a;\n\tif (dot(p1, p2) < 0) {\n\t\treturn p1.abs();\n\t}\n\tp1 = a - b.b;\n\tp2 = b.a - b.b;\n\tif (dot(p1, p2) < 0) {\n\t\treturn p1.abs();\n\t}\n\telse {\n\t\treturn getDistancePL(a, b);\n\t}\n}\nbool Intersection(Point a, Point b, Point c, Point d) {    //判断两线段是否相交  如果相交 则两个边的两个个端点会在另一条边的两边或线上\n\treturn (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n//double Distance(Segment a, Segment b) {             //计算两线段距离\n// \n//}\nint main(void) {\t\t\t\t\n\tPoint a, b, c, d;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y;\n\t\tcout << Intersection(a, b, c, d) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\n//END CUT HERE\n\n//Projection\nsigned CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/04/22\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//Common Tangent\nsigned CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\nsigned main(){\n  //CGL1A();\n  //CGL1B();\n  //CGL1C();\n\n  //CGL2A();\n  CGL2B();\n  //CGL2C();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/20\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t  = long double;\nusing point_t = std::complex<elem_t>;\nusing vec2_t  = point_t;\nusing geom_t  = std::vector<point_t>;\n\n\n\nnamespace limits {\n    const auto pi  = std::acos(-1.0);\n    const auto eps = 1e-10;\n    const auto inf = 1e12;\n}\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const point_t& a ベクトルa\n * @param  const point_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic inline elem_t det(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::imag(b) - std::imag(a) * std::real(b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const point_t& a  ベクトルa\n * @param  const point_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic inline elem_t cross(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::imag(b) - std::imag(a) * std::real(b);\n    // return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const point_t& a  ベクトルa\n * @param  const point_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic inline elem_t dot(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::real(b) + std::imag(a) * std::imag(b);\n}\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\nstatic inline elem_t direction(const point_t& pi, const point_t& pj, const point_t& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n\n/**\n * @brief  絶対許容誤差(absolute tolerance)を比較します\n *\n * @note   2つの浮動小数点数値が等しいかどうか比較するためのイプシロン許容誤差の利用は、\n *         イプシロンの値が固定されているので、絶対許容誤差(absolute tolerance)と呼ばれている\n *         絶対許容誤差の欠点は適切なイプシロンの値を見つけるのが困難なことである\n *         イプシロンの値は入力データの値の範囲、および使用している浮動小数点の形式に依存する\n *         浮動小数点数の範囲全体に対するイプシロンの値を1つだけ選ぶことは不可能である\n *         xおよびyの値が非常に小さな(互いに等しくない)値の場合は、その差は常にイプシロンよりも小さくなる可能性があり、\n *         逆に大きな値の場合は、その差はイプシロンよりも常に大きくなるかもしれない. 別の見方として、\n *         判定している数が大きくなればなるほど、絶対値による判定が成立するために必要な桁数はどんどん大きくなっていく\n *\n * @note   固定されているイプシロンよりも数値が十分大きくなったとき、数値が正確に等しくない限り判定は常に失敗する\n *         これは通常、意図したことではない. 絶対許容誤差は数値の桁数の大きさが予めわかっており、\n *         許容誤差の値をそれに応じて設定することができる場合にのみ利用するべきである\n */\nstatic inline bool absolute_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps;\n}\n\n\n/**\n * @brief  相対許容誤差(relatice tolerance)を比較します\n *\n * @note   基本的な考え方はある数を別の数によって除算し、その結果がどのくらい1に近づいているかを見るというものである\n *\n *\n * @note   |x| <= |y|を仮定すると、判定は以下のようになる\n *           if (Abs(x/y - 1.0) <= epsilon)...\n *         これは以下のように書き直せる\n *           if (Abs((x - y) / y) <= epsilon)...\n *         コストのかかる除算を避け、ゼロによる除算のエラーから守るために、後者の式の両辺にAbs(y)を乗算して、以下のように単純化する\n *           if (Abs(x - y) <= epsilon * Abs(y))...\n *         仮定|x| <= |y|を取り除くと、式は最終的に以下のようになる\n *           if (Abs(x - y) <= epsilon * Max(Abs(x), Abs(y)))...  // 相対許容誤差の比較\n *\n *\n * @note   比較において相対的な判定は「より小さいか等しい」であり、「より小さい」ではないことは重要である\n *         もしそうでなければ、両方の数が正確にゼロだった場合、判定は失敗する。相対的な判定も問題がないわけではない\n *         判定の式はAbs(x)およびAbs(y)が1よりも大きいときには、望み通りの働きをするが、それらの数値が1よりも小さいときは、\n *         イプシロンはより小さくないと効力がなくなってしまい、それらの数値が小さくなるほど式を成立させるのに必要な桁数はより多く必要になる         \n */\nstatic inline bool relative_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * std::max(std::fabs(x), std::fabs(y));\n}\n\n\n/**\n * @brief  上記2つの判定を1つに結合させる\n * @note   数値の絶対値が1よりも大きい場合には、相対的な判定を用い、1よりも小さい場合には、絶対的な判定を用いる\n * @attention  この式はMax()が機械語による命令によって利用できない場合には高価な計算になる可能性がある\n */\nstatic inline bool combined_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * std::max({ std::fabs(x), std::fabs(y), static_cast<elem_t>(1.0) });\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n\n/**\n * @brief  pkが|pipjの端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分|pipjと同一直線上にあると仮定する\n */\nbool on_segment(const point_t& pi, const point_t& pj, const point_t& pk)\n{\n    elem_t xi = pi.real(), xj = pj.real(), xk = pk.real();\n    elem_t yi = pi.imag(), yj = pj.imag(), yk = pk.imag();\n    \n    return std::min(xi, xj) <= xk && xk <= std::max(xi, xj)\n        && std::min(yi, yj) <= yk && yk <= std::max(yi, yj);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分|p1p2がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分|p1p2と線分|p3p4が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point_t& p1, const point_t& p2,\n                       const point_t& p3, const point_t& p4)\n{\n    elem_t d1 = direction(p3, p4, p1);\n    elem_t d2 = direction(p3, p4, p2);\n    elem_t d3 = direction(p1, p2, p3);\n    elem_t d4 = direction(p1, p2, p4);\n\n    // 線分↑p1p2と線分↑p3p4が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // |p1p2が|p3p4を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // |p3p4が|p1p2を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (approximate_combined_tolerance_compare(d1, 0)\n        && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d2, 0)\n        && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d3, 0)\n        && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d4, 0)\n        && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        geom_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point_t(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif((xp2-xp0)*(xp2-xp1) < 0 || (xp3-xp0)*(xp3-xp1) < 0) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n//using ll=long long;\nconst double EPS = 1e-10;\ninline bool equals(double a, double b) { return fabs(a - b) < EPS; }\nconst double PI = 3.141592653589793238;\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint() {}\n\tPoint operator +(const Point &p) const{ return Point(x + p.x, y + p.y); };\n\tPoint operator -(const Point &p) const{ return Point(x - p.x, y - p.y); }\n\tPoint operator *(double k) { return Point(x*k, y*k); }\n\tPoint operator /(double k) { return Point(x / k, y / k); }\n};\n\nusing Vector = Point;\ninline double norm(Vector a) {\n\treturn a.x*a.x + a.y*a.y;\n}\ndouble absv(Vector a) {\n\treturn sqrt(norm(a));\n}\ninline double dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\ninline double cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\nstruct Segment {\n\tPoint p1, p2;\n};\n\nusing Line = Segment;\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>; \nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersection(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersection(Segment s1, Segment s2) {\n\treturn intersection(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n\tint q, x[4], y[4];\n\tPoint p[4];\n\tfor (int i = 0; i < q; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> x[j] >> y[j];\n\t\t\tp[j] = Point(x[j], y[j]);\n\t\t}\n\t\tcout << intersection(p[0], p[1], p[2], p[3]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nclass Point {\npublic:\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y) {}\n    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n    Point operator * (double a) {return Point(a*x,a*y);}\n    Point operator / (double a) {return Point(x/a,y/a);}\n\n    double abs() {return sqrt(norm());}\n    double norm() {return x*x+y*y;}\n\n    bool operator<(const Point &p) const {\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    bool operator==(const Point &p) const {\n        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n    }\n};\n\ntypedef Point Vector;\nstruct Segment {Point p1,p2;};\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0): c(c),r(r) {}\n};\n\ndouble dot(Vector a,Vector b) {\n    return  a.x*b.x+a.y*b.y;\n}\n\ndouble cross (Vector a,Vector b) {\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble getDistance(Point a,Point b) {\n    return (a-b).abs();\n}\n\ndouble getDistanceLP(Line l,Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s,Point p) {\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nint main(void) {\n    int q;cin>>q;\n    while(q) {\n        Point p1,p2,p3,p4;\n        cin>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y>>p4.x>>p4.y;\n        if(intersect(p1,p2,p3,p4)) cout<<1<<endl;\n        else cout<<0<<endl;\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   double x,y;\n   Point(){}\n   Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nPoint line_intersect(Line a,Line b)// 两直线交点\n{\n   double t=cross(b.v,a.p-b.p)/cross(a.v,b.v);\n   return a.p+a.v*t;\n}\ndouble x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   \t  Line l1=Line(Point(x[1],y[1]),Vector(x[2]-x[1],y[2]-y[1]));\n   \t  Line l2=Line(Point(x[3],y[3]),Vector(x[4]-x[3],y[4]-y[3]));\n\n   \t  double p=cross(l1.v,l2.v);  \n   \t  if(fabs(p)<1e-8)\n   \t  {\n   \t    double w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(fabs(w)<1e-8)\n   \t    {\n   \t    \tdouble ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tdouble e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tdouble eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tdouble eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<1e-8||e<1e-8||eee<1e-8||eeee<1e-8) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t Point j=line_intersect(l1,l2);\n      \t if(j.x<=max(x[1],x[2])&&j.x>=min(x[1],x[2])&&j.x>=min(x[3],x[4])&&j.x<=max(x[3],x[4])\n      \t   &&j.y<=max(y[1],y[2])&&j.y>=min(y[1],y[2])&&j.y>=min(y[3],y[4])&&j.y<=max(y[3],y[4])\t)\n      \t \tputs(\"1\");\n      \t else puts(\"0\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-10)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\ndouble distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n    return (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n           (cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return res / 2;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\nvector<Point> circle_inter_line_points(Circle a, Line l) {\n    vector<Point> v;\n    Real d = line_dis(l, a.first);\n    if (d < a.second + EPS) {\n        Point x = a.second * unit_vector(l.second - l.first);\n        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n        else x = a.first + x * Point(0, 1);\n        if (d + EPS < a.second) {\n            Real y = sqrt(a.second * a.second - d * d);\n            if (d == 0) d += EPS;\n            Real s = args_bac(y, d, a.second);\n            v.push_back(rotate_vector(x, s));\n            v.push_back(rotate_vector(x, -s));\n        } else if (EQ(d, a.second)) {\n            v.push_back(x);\n        }\n    }\n    return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\nint main() {\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n        bool ans = is_intersected_lines(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3));\n        if(ans){\n            cout << 1 << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst double kEps = 1e-10;\nconst double kInf = 1e15;\n\nint dcmp(double x) {\n  if (fabs(x) < kEps) return 0;\n  return x < 0 ? -1 : 1;\n}\n\nstruct Vector {\n  double x, y;\n  Vector() {}\n  Vector(double x, double y): x(x), y(y) {}\n  // Vector(const Point & p1, const Point & p2): x(p2.x - p1.x), y(p2.y - p1.y) {}\n  Vector(const Vector & v);\n\n  double Norm() const { return hypot(x, y); }\n  double NormSquared() const { return x * x + y * y; }\n  Vector Normalize() const {\n    return *this / this->Norm();\n  }\n  Vector operator-() const {\n    return Vector(-x, -y);\n  }\n  Vector operator+(const Vector & rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n  }\n  Vector operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  Vector operator*(const double rhs) const {\n    return Vector(rhs * x, rhs * y);\n  }\n  Vector operator/(const double rhs) const {\n    return *this * (1.0 / rhs);\n  }\n  double Dot(const Vector & rhs) const {\n    return x * rhs.x + y * rhs.y;\n  }\n  double Cross(const Vector & rhs) const {\n    return x * rhs.y - y * rhs.x;\n  }\n  bool operator==(const Vector & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Vector & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Point {\n  Point() {}\n  Point(double x, double y): x(x), y(y) {}\n  Point(const Point & p);\n\n  double x, y;\n\n  Point operator-() {\n    return Point(-x, -y);\n  }\n  Point operator+(const Vector & rhs) const {\n    return Point(x + rhs.x, y + rhs.y);\n  }\n  Point operator-(const Vector & rhs) const {\n    return *this + (-rhs);\n  }\n  bool operator==(const Point & rhs) const {\n    return dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) == 0;\n  }\n  bool operator<(const Point & rhs) const {\n    return dcmp(x - rhs.x) < 0 || (dcmp(x - rhs.x) == 0 && dcmp(y - rhs.y) < 0);\n  }\n};\n\nstruct Line {\n  Line() {}\n  Line(const Point & p1, const Point & p2): p1(p1), p2(p2) {\n    if (dcmp(p2.x - p1.x) == 0) {\n      slope = kInf;\n    } else {\n      slope = (p2.y - p1.y) / (p2.x - p1.x);\n    }\n  }\n  Line(double x1, double y1, double x2, double y2): p1(x1, y1), p2(x2, y2) {\n    if (dcmp(x2 - x1) == 0) {\n      slope = kInf;\n    } else {\n      slope = (y2 - y1) / (x2 - x1);\n    }\n  }\n  Line(const Line & l);\n\n  Point p1, p2;\n  double slope;\n};\n\n// minus: left, plus: right, 0: colinear\nint Direction(const Point & p0, const Point & p1, const Point & p2) {\n  Vector v1(p1.x - p0.x, p1.y - p0.y);\n  Vector v2(p2.x - p0.x, p2.y - p0.y);\n  return v2.Cross(v1);\n}\n\n// minus: back, plus: front, 0: on\nint SegmentDirection(const Point & p0, const Point & p1, const Point & p2) {\n  if (p2.x >= min(p0.x, p1.x) && p2.x <= max(p0.x, p1.x)\n      && p2.y >= min(p0.y, p1.y) && p2.y <= max(p0.y, p1.y)) { return 0; }\n  if ((p2.x - p0.x) * (p1.x - p0.x) > 0\n      || (p2.y - p0.y) * (p1.y - p0.y) > 0) { return 1; }\n  return -1;\n}\n\nbool IsIntersecting(const Line & l1, const Line & l2) {\n  auto d1 = Direction(l2.p1, l2.p2, l1.p1);\n  auto d2 = Direction(l2.p1, l2.p2, l1.p2);\n  auto d3 = Direction(l1.p1, l1.p2, l2.p1);\n  auto d4 = Direction(l1.p1, l1.p2, l2.p2);\n\n  if (d1 * d2 < 0 || d3 * d4 < 0) { return true; }\n  if (d1 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p1) == 0) { return true; }\n  if (d2 == 0 && SegmentDirection(l2.p1, l2.p2, l1.p2) == 0) { return true; }\n  if (d3 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p1) == 0) { return true; }\n  if (d4 == 0 && SegmentDirection(l1.p1, l1.p2, l2.p2) == 0) { return true; }\n  return false;\n}\n\nint main(int argc, char const *argv[]) {\n  double x0, y0, x1, y1;\n  Point p0(x0, y0);\n  Point p1(x1, y1);\n\n  int q;\n  cin >> q;\n  for (unsigned i = 0; i < q; ++i) {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    if (IsIntersecting(Line(x0, y0, x1, y1), Line(x2, y2, x3, y3))) {\n      cout << 1 << \"\\n\";\n    } else {\n      cout << 0 << \"\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x <<\" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<class T, class... Ts> void err(const T& arg,const Ts&... args) { cout << arg << \" \"; err(args...); }\n\ntypedef long double db;\nconst db eps = 1e-8;\nconst db pi = acosl(-1.0);\nint sgn(db x){if(fabs(x) < eps) return 0; return x < 0 ? -1 : 1;}\nstruct Point{\n    db x, y;\n    Point(){}\n    Point(db x, db y):x(x), y(y){}\n    void input(){cin >> x >> y;}\n    Point operator - (const Point &b) const{\n        return Point(x - b.x, y - b.y);\n    }\n    Point operator + (const Point &b) const{\n        return Point(x + b.x, y + b.y);\n    }\n    db operator ^ (const Point&b)const{\n        return x * b.y - y * b.x;\n    }\n    db operator * (const Point &b) const{\n        return x * b.x + y * b.y;\n    }\n    db len2(){\n        return x * x + y * y;\n    }\n    db len(){\n        return sqrtl(len2());\n    }\n};\nstruct Line{\n    Point s, e;\n    Line(){};\n    Line(Point s, Point e) :s(s), e(e){}\n    void input(){ s.input(); e.input(); }\n\n    int getPointPos(Point p) {\n        return sgn((e - s) ^ (p - s));\n    }\n    bool isPointOnSeg(Point p) {\n        return getPointPos(p) == 0 && sgn((p - s) * (p - e)) <= 0;\n    }\n    int getCrossTypeofSeg(Line v) {\n        int d1 = getPointPos(v.s);\n        int d2 = getPointPos(v.e);\n        int d3 = v.getPointPos(s);\n        int d4 = v.getPointPos(e);\n\n        if((d1 ^ d2) == -2 && (d3 ^ d4) == -2) return 2;\n        return isPointOnSeg(v.s) || isPointOnSeg(v.e) || v.isPointOnSeg(s) || v.isPointOnSeg(e);\n    }\n}l1, l2;\n\n\nint main(){\n#ifndef ONLINE_JUDGE\n//   freopen(\"i.in\",\"r\",stdin);\n//  freopen(\"o.out\",\"w\",stdout);\n#endif\n    \n    int T;scanf(\"%d\", &T);\n    while(T--){\n        l1.input(); l2.input();\n        cout << (l1.getCrossTypeofSeg(l2) > 0 ? 1 : 0) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#include <algorithm>\n#include <stdlib.h>\n#include <map>\n#include <set>\n#include <stdio.h>\n#include <time.h>\n#include<complex>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define lowBit(x) ((x)&(-x))\n#define rep(i,a,n) for (ll i=a;i<=n;i++)\n#define per(i,a,n) for (ll i=n;i>=a;i--)\n#define pb push_back\n#define SZ(x) ((ll)(x).size())\ntypedef vector<ll> VI;\nconst ll N=1e6+5;\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nll readn(){ll sum=0,f=1;char ch=getchar();\nwhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\nwhile(ch>='0'&&ch<='9'){sum=sum*10+(ch-'0');\nch=getchar();}return sum*f;}\n\n\nconst double epx=1e-7; \ntypedef complex<double> kk;\nint op(kk a,kk b,kk c)\n{\n    b-=a,c-=a,a=c*conj(b);\n    if(a.imag()>epx) return 1;\n    if(a.imag()<-epx) return -1;\n    if(a.real()<-epx) return 2;\n    if(abs(b)+epx<abs(c)) return -2;\n    return 0;\n}\nbool xiangjiao(kk a,kk b,kk c,kk d)\n{return (op(a,b,c)*op(a,b,d)<=0)&&(op(c,d,a)*op(c,d,b)<=0);}\n\nint main()\n{\n    int _;_=readn();\n    while(_--)\n    {\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n        printf(\"%d\\n\",xiangjiao(kk(x1,y1),kk(x2,y2),kk(x3,y3),kk(x4,y4)));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nclass Vector\n{\npublic:\n  double x;\n  double y;\n\n  Vector(){}\n  Vector( double x, double y ) : x(x), y(y) {}\n\n  Vector operator + ( const Vector v ) { return Vector( x + v.x, y + v.y ); }\n  Vector operator - ( const Vector v ) { return Vector( x - v.x, y - v.y ); }\n  Vector operator * ( const double k ) { return Vector( x * k, y * k ); }\n  Vector operator / ( const double k ) { return Vector( x / k, y / k ); }\n  bool operator < ( const Vector &v ) const { return x * x + y * y < v.x * v.x + v.y * v.y; }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  static double dot( Vector v1, Vector v2 ) { return v1.x * v2.x + v1.y * v2.y; }\n  static double cross( Vector v1, Vector v2 ) { return v1.x * v2.y - v1.y * v2.x; }\n};\n\nclass Intersection\n{\npublic:\n  Vector p0, p1, p2, p3;\n  Intersection(){}\n  Intersection( Vector p0, Vector p1, Vector p2, Vector p3 ) : p0(p0), p1(p1), p2(p2), p3(p3) {}\n  int solve();\n};\n\nint Intersection::solve()\n{\n  Vector p10 = p1 - p0;\n  Vector p20 = p2 - p0;\n  Vector p30 = p3 - p0;\n  Vector p32 = p3 - p2;\n  Vector p02 = p0 - p2;\n  Vector p12 = p1 - p2;\n  \n  if ( Vector::cross( p10, p20 ) * Vector::cross( p10, p30 ) <= 0 &&\n       Vector::cross( p32, p02 ) * Vector::cross( p32, p12 ) <= 0 )\n    cout << \"1\" << endl;\n  else\n    cout << \"0\" << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int q;\n  cin >> q;\n\n  for ( auto i = 0; i < q; ++i )\n    {\n      double x0, y0, x1, y1, x2, y2, x3, y3;\n      cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n      Intersection s( Vector(x0, y0), Vector(x1, y1), Vector(x2, y2), Vector(x3, y3) );\n      s.solve();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<61;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\ntypedef complex<double> vec;\n\n// ??\\???\nvoid In(vec& p){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp=vec(x,y);\n}\n\n// ??????\ndouble CP(vec p,vec q){\n\treturn p.real()*q.imag()-q.real()*p.imag();\n}\n\n// ????????¨?????????????????????\nbool is_Cross(vec a1,vec a2,vec b1,vec b2){\n\tvec A=a2-a1,B=b2-b1;\n\treturn CP(A,b1-a1)*CP(A,b2-a1)<eps&&CP(B,a1-b1)*CP(B,a2-b1)<eps;\n}\n\nint n;\nvec a,b,c,d;\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tIn(a);In(b);In(c);In(d);\n\t\tcout<<is_Cross(a,b,c,d)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\n\tdouble a[8];\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>a[0]>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]>>a[7];\n\t\tdouble x,y,z,l,m,n,d,e,r,t;\n\t\tx=a[3]-a[1];\n\t\ty=a[0]-a[2];\n\t\tz=(x*a[0])+(y*a[1]);\n\t\t\n\t\tl=a[7]-a[5];\n\t\tm=a[4]-a[6];\n\t\tn=(l*a[4])+(m*a[5]);\n\t\t\n\t\td=((n*y)-(z*m))/((x*m)-(y*l));\n\t\te=((z*l)-(n*x))/((x*m)-(y*l));\n\t\t\n\t\tr=sqrt(pow((a[0]-d),2)+pow((a[1]-e),2));\n\t\tt=sqrt(pow((a[0]-a[2]),2)+pow((a[1]-a[3]),2));\n\t\t\n\t\tif(r<=t) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nusing CP = complex<long double>;\n\nconst long double EPS = 1e-10;     // 許容する誤差ε\n#define EQ(a, b) (abs((a)-(b)) < EPS)   // 2つのスカラーが等しいかどうか\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))    // 2つのベクトルが等しいかどうか\n\n// double length = abs(a);     // ベクトルaの絶対値\n// double distance = abs(a-b);     // 2点a,b間の距離\n// CP b = a/abs(a);    // ベクトルaの単位ベクトル\n// CP n1 = a*CP(0,+1); CP n2 = a*CP(0,-1);  // ベクトルaの法線ベクトル\n// CP un1 = (a*CP(0,+1)/abs(a)); CP un2 = (a*CP(0,-1)/abs(a));  // ベクトルaの単位法線ベクトル\n\n// 内積(dot product) : a・b = |a||b|cosΘ\nlong double dot(CP a, CP b) {\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\nlong double cross(CP a, CP b) {\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// 直線の表現\nstruct Segment {\n    CP s, t;\n    Segment (long double sx = 0.0L, long double sy = 0.0L,\n             long double tx = 0.0L, long double ty = 0.0L)\n            : s(CP(sx, sy)), t(CP(tx, ty)) {}\n    Segment (CP _s, CP _t) : s(_s), t(_t) {}\n}; typedef Segment Line;\n\n// 2直線の直交判定 : a⊥b ⇔ dot(a,b) = 0\nint is_orthogonal(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n\n// 2直線の平行判定 : a//b ⇔ cross(a,b) = 0\nint is_parallel(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(CP a, CP b, CP c) {\n    return EQ(cross(b-a, c-a), 0.0);\n}\n\n// 点cが線分a,b上にあるかないか\nint is_point_on_lines(CP a, CP b, CP c) {\n    // |a-c|+|c-b| <= |a-b|なら線分上\n    return (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_lines(Segment a, Segment b) {\n    if(is_parallel(a.s, a.t, b.s, b.t)) {\n        // 平行なので線分の重なり判定\n        return is_point_on_lines(a.s, a.t, b.s) || is_point_on_lines(a.s, a.t, b.t) ||\n               is_point_on_lines(b.s, b.t, a.s) || is_point_on_lines(b.s, b.t, a.t);\n    }\n    return (cross(a.t-a.s, b.s-a.s)*cross(a.t-a.s, b.t-a.s) < EPS) &&\n           (cross(b.t-b.s, a.s-b.s)*cross(b.t-b.s, a.t-b.s) < EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nCP intersection_lines(CP a1, CP a2, CP b1, CP b2) {\n    CP b = b2-b1;\n    long double d1 = abs(cross(b, a1-b1));\n    long double d2 = abs(cross(b, a2-b1));\n    long double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_line(CP a1, CP a2, CP b1, CP b2) {\n    return !EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算(平行ではない前提)\nCP intersection_line(CP a1, CP a2, CP b1, CP b2) {\n    CP a = a2-a1; CP b = b2-b1;\n    return a1 + a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 点a,bを通る直線と点cとの距離\nlong double distance_line_p(CP a, CP b, CP c) {\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\nlong double distance_lines_p(CP a, CP b, CP c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分の最短距離\n/*long double distance_lines_lines(CP a1, CP a2, CP b1, CP b2) {\n    long double res = 1e18;\n    if(is_intersected_lines(a1, a2, b1, b2)) return 0.0L;\n    res = min(res, distance_lines_p(a1, a2, b1));\n    res = min(res, distance_lines_p(a1, a2, b2));\n    res = min(res, distance_lines_p(b1, b2, a1));\n    res = min(res, distance_lines_p(b1, b2, a2));\n    return res;\n}*/\n\n// s,tを通る直線に対する点pの射影\nCP projection(CP s, CP t, CP p) {\n    if(EQV(s, t)) return s;\n    CP base = t-s;\n    return s + base*(dot(p-s, base)/norm(base));\n}\n\n// s,tを通る直線に対する点pの反射\nCP reflection(CP s, CP t, CP p) {\n    CP tmp = projection(s, t, p) - p;\n    return p + tmp*2.0L;\n}\n\n// 角度Θ回転\nCP translate(CP v, long double theta) {\n    CP res = v * CP(cosl(theta), sinl(theta));\n    return res;\n}\n\n// n多角形の面積計算\nlong double polygon_area(const vector<CP> &v) {\n    int n = v.size();\n    long double res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(v[(i+n-1)%n], v[(i+n)%n]);\n    }\n    return fabsl(res)/2.0L;\n}\n\n// n多角形の凸性判定\nint is_convex(const vector<CP> &v) {\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        if(cross(v[(i+1)%n]-v[i], v[(i+2)%n]-v[(i+1)%n]) < -EPS) return 0;\n    }\n    return 1;\n}\n\n// 凸包\nvector<CP> convex_hull(vector<CP> &v) {\n    // x座標→y座標で頂点をソート\n    auto lmd = [&](const CP &l, const CP &r) {\n        if(l.imag() != r.imag()) return l.imag() < r.imag();\n        return l.real() < r.real();\n        return l.imag() < r.imag();\n    };\n    vector<CP> res;     // 凸包を構成する頂点\n    int n = v.size();\n    sort(v.begin(), v.end(), lmd);\n    int k = 0;\n    res.resize(n*2);\n    // 下側凸包\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    // 上側凸包\n    for(int i = n-2, t = k; i >= 0; --i) {\n        while(k > t && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\n// 凸多角形の直径\nlong double convex_diameter(vector<CP> &v) {\n    vector<CP> cv = convex_hull(v);\n    int n = cv.size();\n    if(n == 2) return abs(cv[0]-cv[1]);     // 凸包が潰れている例外処理\n    int i = 0, j = 0;   // x軸方向に最も遠い点対\n    for(int k = 0; k < n; ++k) {\n        if(cv[k].real() < cv[i].real()) i = k;\n        if(cv[k].real() > cv[j].real()) j = k;\n    }\n    long double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {     // 180度回転で終了\n        res = max(res, abs(cv[i]-cv[j]));\n        if(cross(cv[(i+1)%n]-cv[i], cv[(j+1)%n]-cv[j]) < 0) {\n            (++i) %= n;\n        }else {\n            (++j) %= n;\n        }\n    }\n    return res;\n}\n\n// 凸多角形を点s,tを通る直線で切断(左側が取得できる)\nvector<CP> convex_cut(const vector<CP> &v, const CP &s, const CP &t) {\n    vector<CP> res;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        CP nows = v[i], nowt = v[(i+1)%n];\n        if(cross(t-s, nows-s) >= -EPS) res.emplace_back(nows);\n        if(cross(t-s, nows-s)*cross(t-s, nowt-s) < 0) {\n            res.emplace_back(intersection_line(s, t, nows, nowt));\n        }\n    }\n    return res;\n}\n\n// n多角形に対する点pの包含関係(自己交差多角形は例外)\nint contain_polygon_point(const vector<CP> &v, CP p) {\n    int contain = 0, on_segment = 0;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        on_segment |= is_point_on_lines(v[i], v[(i+1)%n], p);   // 辺上判定\n        CP s = v[i]-p, t = v[(i+1)%n]-p;\n        if(s.imag() > t.imag()) swap(s, t);     // 下側を基準にする\n        if(s.imag()*t.imag() <= 0 && t.imag() > 0 && cross(s, t) > 0) {\n            contain = !contain;     // 交差回数が奇数なら内側\n        }\n    }\n    if(on_segment) return 1;    // 辺上\n    if(contain) return 2;       // 内側\n    return 0;       // 外側\n}\n\n// 最近点対距離\nlong double closest_pair(vector<CP> &v, int l = -1, \n                         int r = -1, bool reqsqrt = 0) {\n    if(l == r && l == -1) {\n        l = 0; r = v.size(); reqsqrt = 1;\n        // x座標→y座標で昇順ソート\n        auto lmd = [&](const CP &l, const CP &r) {\n            if(l.real() != r.real()) return l.real() < r.real();\n            return l.imag() < r.imag();\n        };\n        sort(v.begin(), v.end(), lmd);\n    }\n    if(r-l < 2) return 1e18;    // 2点存在しない\n    if(r-l == 2) {      // ちょうど2点の時\n        if(v[l].imag() > v[l+1].imag()) swap(v[l], v[l+1]);\n        if(reqsqrt) return abs(v[l]-v[l+1]);\n        return norm(v[l]-v[l+1]);\n    }\n    // 2点以上に関して分割統治法\n    int mid = (l+r)/2;\n    long double x = v[mid].real();  // 分断する線のx座標\n    // 左半分，右半分について再帰，同一領域内の最小距離resを求める\n    long double res = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    auto f = [](CP pl, CP pr) { return pl.imag() < pr.imag(); };\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, f);\n    vector<CP> tmp;\n    // 異なる領域の2点について最小距離res未満で探索\n    for(int i = l; i < r; ++i) {\n        long double dx = abs(v[i].real()-x);\n        int tsize = tmp.size();\n        if(dx*dx >= res) continue;\n        for(int j = 0; j < tsize; ++j) {\n            CP delta = v[i]-tmp[tsize-1-j];\n            if(delta.imag()*delta.imag() >= res) break;\n            res = min(res, norm(delta));\n        }\n        tmp.emplace_back(v[i]);\n    }\n    if(reqsqrt) res = sqrtl(res);\n    return res;\n}\n\n// 円の表現\nstruct Circle {\n    CP o;\n    long double r;\n    Circle(long double _x = 0.0L, long double _y = 0.0L,\n           long double _r = 0.0L)\n        : o(CP(_x, _y)), r(_r) {}\n    Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\n// 2円の位置関係\nint is_cross_circles(Circle l, Circle r) {\n    long double distlr = abs(l.o-r.o);\n    if(l.r+r.r+EPS < distlr) return 4;         // 交点無し外側\n    if(r.r+distlr+EPS < l.r) return -2;          // 交点無し内側(R in L)\n    if(l.r+distlr+EPS < r.r) return 2;          // 交点無し内側(L in R)\n    if(abs(l.r+r.r-distlr) < EPS) return 3;    // 外接\n    if(abs(l.r+distlr-r.r) < EPS) return -1;     // 内接(R in L)\n    if(abs(r.r+distlr-l.r) < EPS) return 1;     // 内接(L in R)\n    return 0;                                   // 2点で交わる\n}\n\n// 円と直線の交点\nvector<CP> intersection_circle_line(Circle ci, CP s, CP t) {\n    vector<CP> res(2);  // 1点の場合同じ座標\n    res[0] = res[1] = projection(s, t, ci.o);   // 2等分点の座標\n    long double d = sqrtl(ci.r*ci.r - norm(res[0]-ci.o));\n    CP ust = (t-s)/abs(t-s);    // stの単位ベクトル\n    res[0] += (ust*d);\n    res[1] -= (ust*d);\n    if(res[0].real() > res[1].real() ||\n       (res[0].real() == res[1].real() && res[0].imag() > res[1].imag())) {\n           swap(res[0], res[1]);\n    }\n    return res;\n}\n\n// 2円の交点(1つは交点が存在する)\nvector<CP> intersection_circle_circle(Circle c1, Circle c2) {\n    vector<CP> res(2);  // 1点の場合同じ座標\n    long double d = abs(c1.o-c2.o);\n    long double arg = acosl((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0L*c1.r*d));\n    CP c1p = (c2.o-c1.o)*CP(cosl(arg), sinl(arg));\n    CP uc1p = c1p/abs(c1p);     // c1の中心から交点p方向への単位ベクトル\n    res[0] = c1.o + c1.r*uc1p;\n    res[1] = reflection(c1.o, c2.o, res[0]);    // p,qの位置関係は反射\n    if(res[0].real() > res[1].real() ||\n       (res[0].real() == res[1].real() && res[0].imag() > res[1].imag())) {\n           swap(res[0], res[1]);\n    }\n    return res;\n}\n\n// 線分lrの垂直二等分線\nLine vertical_bisector(CP l, CP r) {\n    Circle c1 = Circle(l, abs(l-r)), c2 = Circle(r, abs(l-r));\n    vector<CP> res = intersection_circle_circle(c1, c2);\n    if(cross(r-l, res[0]-l) > 0) swap(res[0], res[1]);\n    return Line(res[0], res[1]);\n}\n\n// 点pを通る円の接線\nvector<CP> contact_circle_point(Circle ci, CP p) {\n    vector<CP> res(2);\n    long double d = abs(ci.o-p);\n    if(abs(d-ci.r) <= EPS) {\n        res[0] = res[1] = p;\n    }else if(d < ci.r) {\n        res[0] = res[1] = CP(-1e18, -1e18);\n    }else {\n        long double arg = asinl(ci.r/d);\n        CP p0 = (ci.o-p)*CP(cosl(arg), sinl(arg));\n        CP up0 = p0/abs(p0);\n        res[0] = p + d*cosl(arg)*up0;\n        res[1] = reflection(p, ci.o, res[0]);\n        if(res[0].real() > res[1].real() || \n           (res[0].real() == res[1].real() && res[0].imag() > res[1].imag())) {\n               swap(res[0], res[1]);\n        }\n    }\n    return res;\n}\n\n// 三角形の内接円\nCircle inscribed_circle(CP A, CP B, CP C) {\n    if(cross(B-A, C-A) < 0) swap(B, C);\n    long double a = abs(B-C), b = abs(C-A), c = abs(A-B);\n    long double alpha = acosl((b*b+c*c-a*a)/(2.0L*b*c));\n    long double beta = acosl((c*c+a*a-b*b)/(2.0L*c*a));\n    // AとxABを通る直線とBとxBCを通る直線の交点が内心\n    CP I = intersection_line(A, A+translate(B-A, alpha/2.0L), B, B+translate(C-B, beta/2.0L));\n    // ABとIの最短距離が内心半径\n    long double Ir = distance_lines_p(A, B, I);\n    return Circle(I, Ir);\n}\n\n// 三角形の外接円\nCircle circumscribed_circle(CP A, CP B, CP C) {\n    // 2つの垂直二等分線の交点\n    Line AB = vertical_bisector(A, B);\n    Line BC = vertical_bisector(B, C);\n    CP O = intersection_line(AB.s, AB.t, BC.s, BC.t);\n    long double Or = abs(A-O);\n    return Circle(O, Or);\n}\n\n// 3点の位置関係を判定\nint calc_clockwise(CP p0, CP p1, CP p2) {\n    CP x = p1-p0, y = p2-p0;\n    if(cross(x, y) > EPS) return 1;     // \"COUNTER_CLOCKWISE\"\n    if(cross(x, y) < -EPS) return -1;   // \"CLOCKWISE\"\n    if(dot(x, y) < 0) return 2;         // \"ONLINE_BACK\"\n    if(norm(x) < norm(y)) return -2;    // \"ONLINE_FRONT\"\n    return 0;                           // \"ON_SEGMENT\" \n}\n\nint main() {\n    int n; cin >> n;\n    while(n--) {\n        long double a, b, c, d; cin >> a >> b >> c >> d;\n        Segment l(CP(a, b), CP(c, d));\n        long double e, f, g, h; cin >> e >> f >> g >> h;\n        Segment r(CP(e, f), CP(g, h));\n        cout << is_intersected_lines(l, r) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = -1, ONLINE_BACK = 2, ONLINE_FRONT = -2, ON_SEGMENT = 0;\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point rhs) {\n\t\treturn Point(x + rhs.x, y + rhs.y);\n\t}\n\tPoint operator - (Point rhs) {\n\t\treturn Point(x - rhs.x, y - rhs.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tbool operator < (const Point& rhs) const {\n\t\treturn x != rhs.x ? x < rhs.x : y < rhs.y;\n\t}\n\tbool operator == (const Point& rhs) const {\n\t\treturn equals(x, rhs.x) && equals(y, rhs.y);\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\ntypedef Point Vector;\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0);\n}\nbool isOrthogonal(Segment a, Segment b) {\n\treturn isOrthogonal(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0);\n}\nbool isParallel(Segment a, Segment b) {\n\treturn isParallel(Vector(a.p2.x - a.p1.x, a.p2.y - a.p1.y), Vector(b.p2.x - b.p1.x, b.p2.y - b.p1.y));\n}\nPoint project(Point p, Segment s) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + (base * r);\n}\nPoint reflect(Point p, Segment s) {\n\treturn p + (project(p, s) - p) * 2;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS) return CLOCKWISE;\n\telse if (dot(a, b) < -EPS) return ONLINE_BACK;\n\telse if (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn (ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0); \n}\ndouble getDistance(Point a, Point b) {\n\treturn (b - a).abs();\n}\ndouble getDistancePL(Point p, Line l) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\ndouble getDistancePS(Point p, Segment s) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\telse return getDistancePL(p, s);\n}\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0;\n\treturn min(min(getDistancePS(s2.p1, s1), getDistancePS(s2.p2, s1)), min(getDistancePS(s1.p1, s2), getDistancePS(s1.p2, s2)));\n}\nint main() {\n    int q; \n    scanf(\"%d\", &q);\n    while (q--) {\n    \tdouble x0, y0, x1, y1;\n    \tscanf(\"%lf%lf%lf%lf\", &x0, &y0, &x1, &y1);\n    \tSegment s1 = Segment(Point(x0, y0), Point(x1, y1));\n    \tscanf(\"%lf%lf%lf%lf\", &x0, &y0, &x1, &y1);\n    \tSegment s2 = Segment(Point(x0, y0), Point(x1, y1));\n    \tif (intersect(s1, s2)) printf(\"1\\n\");\n    \telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ninline bool equals(double a, double b) { return abs(b - a) < EPS; }\nusing Point = complex<double>;\nnamespace std { bool operator < (const Point &a, const Point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); } }\nstruct Line\n{\n    Point a, b;\n    Line(Point a, Point b) : a(a), b(b) {}\n};\ninline double dot(const Point &a, const Point &b) { return real(a) * real(b) + imag(a) * imag(b); }\ninline double cross(const Point &a, const Point &b) { return real(a) * imag(b) - imag(a) * real(b); }\ninline bool isParallel(const Line &a, const Line &b) { return equals(cross(a.b - a.a, b.b - b.a), 0.0); }\ninline bool isOrthogonal(const Line &a, const Line &b) { return equals(dot(a.a - a.b, b.a - b.b), 0.0); }\ninline Point projection(const Line &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\ninline Point reflection(const Line &l, const Point &p) { return p + (projection(l, p) - p) * 2.0; }\ninline int ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\ninline bool isIntersect(const Point &a, const Point &b, const Point &c, const Point &d) { return (ccw(a, b, c) * ccw(a, b, d) <= 0) and (ccw(c, d, a) * ccw(c, d, b) <= 0); }\ninline bool isIntersect(const Line &l, const Line &m) { return isIntersect(l.a, l.b, m.a, m.b); }\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(8);\n    int n; cin >> n;\n    while(n--)\n    {\n        double x0, y0, x1, y1, x2, y2, x3, y3; cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Point a = Point(x0, y0), b = Point(x1, y1), c = Point(x2, y2), d = Point(x3, y3);\n        int res = isIntersect(Line(a, b), Line(c, d));\n        cout << res << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Geometry Template (Plane)\n//-------------------------------------------------\n\nusing lf = double;\nconst lf EPS = 1e-9;\nconst lf PI = acos(-1);\n\n#define sgn(x) (((x)<-EPS)?-1:((x)>EPS)?1:0)\n#define EQ(x,y) (sgn((y)-(x))==0)\n\nstruct V {\n    lf x,y;\n    V(){}\n    V(lf x, lf y):x(x),y(y){}\n    V(const V &v):x(v.x),y(v.y){}\n    V& operator+=(const V &v){x+=v.x; y+=v.y; return *this;}\n    V& operator-=(const V &v){x-=v.x; y-=v.y; return *this;}\n    V& operator*=(lf k){x*=k; y*=k; return *this;}\n    V& operator/=(lf k){x/=k; y/=k; return *this;}\n    V operator+(const V &v){return V(*this)+=v;}\n    V operator-(const V &v){return V(*this)-=v;}\n    V operator*(lf k){return V(*this)*=k;}\n    V operator/(lf k){return V(*this)/=k;}\n    V operator-(){return V(-x,-y);}\n    lf sq(){return x*x+y*y;}\n    lf norm(){return sqrt(sq());}\n    V unit(){return V(*this)/=norm();}\n    lf arg(){return atan2(y,x);}\n    V rot(lf c, lf s){return V(x*c-y*s,x*s+y*c);}\n    V rot(lf a){return rot(sin(a),cos(a));}\n    V rot90(){return V(-y,x);}\n    bool operator<(const V &v){return x<v.x;}\n    friend ostream& operator<<(ostream &os, const V &v){return os<<'('<<v.x<<\", \"<<v.y<<')';}\n};\n\nlf dot(const V &a, const V &b){return a.x*b.x+a.y*b.y;}\nlf det(const V &a, const V &b){return a.x*b.y-a.y*b.x;}\n\nint ccw(V a, V b, V c){\n    b-=a; c-=a;\n    if (sgn(det(b,c))>0) return 1;\n    else if(sgn(det(b,c))<0) return -1;\n    else if(sgn(dot(b,c))<0) return 2;\n    else if(sgn(b.norm()-c.norm())<0) return -2;\n    return 0;\n}\n\nstruct Line {\n    V p,q;\n    Line(){}\n    Line(const V &p, const V &q):p(p),q(q){}\n    Line(const Line &l):Line(l.p,l.q){}\n    V unit(){return (q-p).unit();}\n    lf arg(){return (q-p).arg();}\n    Line rot(lf c, lf s){return Line(p.rot(c,s),q.rot(c,s));}\n    Line rot(lf a){return Line(p.rot(a),q.rot(a));}\n    Line rot90(){return Line(p.rot90(),q.rot90());}\n};\n\nstruct Segment : Line {\n    Segment(){}\n    Segment(const V &p, const V &q):Line(p,q){}\n    Segment(const Segment &s):Line(s){}\n    lf sq(){return (Line::q-Line::p).sq();}\n    lf norm(){return (Line::q-Line::p).norm();}\n};\n\n// functions about lines\nbool parallel(V &a, V &b){return EQ(det(a,b),0.0);}\nbool parallel(Line &a, Line &b){return EQ(det(a.q-a.p,b.q-b.p),0.0);}\nbool orthogonal(V &a, V &b){return EQ(dot(a,b),0.0);}\nbool orthogonal(Line &a, Line &b){return EQ(dot(a.q-a.p,b.q-b.p),0.0);}\n\nbool samel(Line &a, Line &b){return parallel(a,b)&&EQ(det(a.q-a.p,b.p-a.p),0.0);}\nbool insec(Line &a, Line &b){return !parallel(a,b);}\nbool insec(Segment &a, Segment &b){\n    int c1 = ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q);\n    int c2 = ccw(b.p,b.q,a.p)*ccw(b.p,b.q,a.q);\n    return (c1<=0 && c2<=0);\n}\nbool insec(Line &a, Segment &b){return ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q)<=0;}\n\n// use only if lines have intersection\nV cpoint(Line &a, Line &b){\n    V r(a.q-a.p);\n    r *= det(b.p-a.p,b.q-b.p)/det(a.q-a.p,b.q-b.p);\n    return a.p+r;\n}\n\nlf distance(V &a, V &b){return (b-a).norm();}\nlf distance(Line &l, V &v){return abs(det((l.q-l.p).unit(),v-l.p));}\nlf distance(Line &a, Line &b){return (parallel(a,b))?distance(a,b.p):0.0;}\nlf distance(Segment &s, V &v){\n    if (sgn(dot(s.q-s.p,v-s.p))<0) return distance(s.p,v);\n    else if(sgn(dot(s.p-s.q,v-s.q))<0) return distance(s.q,v);\n    return distance((Line&)s,v);\n}\nlf distance(Segment &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    lf A=min(distance(a,b.p),distance(a,b.q));\n    lf B=min(distance(b,a.p),distance(b,a.q));\n    return min(A,B);\n}\nlf distance(Line &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    return min(distance(a,b.p),distance(a,b.q));\n}\n\nV subdiv(V &a, V &b, lf m, lf n){return (a*n+b*m)/(m+n);}\nV outside(V &a, V &b, lf m, lf n){return (-a*n+b*m)/(m-n);}\nV ppfoot(Line &l, V &v){\n    V u = (l.q-l.p).unit();\n    return l.p+u*dot(u,v-l.p);\n}\n\nLine vbsector(V &a, V &b){\n    V m = (a+b)/2;\n    return Line(m, m+(b-a).rot90());\n}\nLine absector(V &c, V &a, V &b){\n    lf m=(a-c).norm(), n=(b-c).norm();\n    return Line(c,subdiv(a,b,m,n));\n}\nLine perpend(V &c, V &a, V &b){return Line(c,c+(b-a).rot90());}\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t; cin>>t;\n    while(t--){\n        int a,b,c,d; cin>>a>>b>>c>>d;\n        Segment s1(V(a,b), V(c,d));\n        cin>>a>>b>>c>>d;\n        Segment s2(V(a,b), V(c,d));\n        cout<<insec(s1,s2)<<\"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#include<complex>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{//??´???\n  L(const P &a, const P &b){\n    push_back(a);push_back(b);\n  }\n};\n\nstruct C{//???\n  P c; double r;\n  C(const P &c,double r): c(c),r(r){}\n};\n\nnamespace std{//??????????????????\n  bool operator < (const P& a,const P& b){\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b){\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)   return +1;// counter clockwise \n  if(cross(b,c)<0)   return -1;// clockwise \n  if(dot(b,c)<0)     return +2;// c-a-b on line\n  if(norm(b)<norm(c))return -2;// a-b-c on line\n  return 0;                    // a-c-b on lone\n}\n\nP intersection(P a,P b,P c,P d){//2??´????????????\n  return a+(b-a)*(cross(d-c,c-a)/cross(d-c,b-a));\n}\n\nint main()\n{\n  int i;\n  int q;\n\n  cin>>q;\n\n  rep(i,q){\n    double xp,yp;\n\n    cin>>xp>>yp;  P p1(xp,yp);\n    cin>>xp>>yp;  P p2(xp,yp);\n    cin>>xp>>yp;  P p3(xp,yp);\n    cin>>xp>>yp;  P p4(xp,yp);\n\n    P s1(p2-p1);\n    P s2(p4-p3);\n\n    if(p1==p3 || p1==p4 || p2==p3 || p2==p4){\n      cout<<\"1\"<<endl;\n      continue;\n    }\n\n    if(s1.real()*s2.imag()==s1.imag()*s2.real()){//parallel\n      if(ccw(p1,p3,p4)==2||ccw(p2,p3,p4)==2 || ccw(p3,p1,p2)==2||ccw(p4,p1,p2)==2)\n\t  cout<<\"1\"<<endl;\n\telse\n\t  cout<<\"0\"<<endl;\n\n    }else{\n      P p=intersection(p1,p2,p3,p4);//??????\n      // cout<<p<<endl;\n      if(abs(p1-p)>abs(p1-p2) || abs(p2-p)>abs(p1-p2) ||\n\t abs(p3-p)>abs(p3-p4) || abs(p4-p)>abs(p3-p4))\n\tcout<<\"0\"<<endl;\n      else\n\tcout<<\"1\"<<endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld EPS = 1e-9;\nconst ld INF = 1e10;\nconst ld PI = M_PI;\n\nstruct Point{\n  ld x, y;\n  Point(ld x, ld y):x(x), y(y){}\n  Point(){}\n};\n\nPoint operator+(const Point &a, const Point &b){\n  return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b){\n  return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, const ld b){\n  return Point(a.x * b, a.y * b);\n}\nPoint operator*(const Point &a, const Point &b){\n  return Point(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nPoint operator/(const Point &a, const ld b){\n  return Point(a.x / b, a.y / b);\n}\n\nld cross(const Point &a, const Point &b){\n  return a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n  return a.x*b.x + a.y*b.y;\n}\n\nld norm(const Point &a){\n  return dot(a, a);\n}\n\nstruct Line:vector<Point>{\n  Line(Point a = Point(0, 0), Point b = Point(0, 0)){\n    this->push_back(a);\n    this->push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c){\n  b = b - a;\n  c = c - a;\n  if(cross(b, c) > EPS) return +1; // 反時計周り\n  if(cross(b, c) < -EPS) return -1; // 時計周り\n  if(dot(b, c) < 0) return +2; // c -- a -- b がこの順番に一直線上\n  if(norm(b) < norm(c)) return -2; // a -- b -- c がこの順番に一直線上\n  return 0; // a -- c -- b が一直線上\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main(){  \n  int q;\n  cin >> q;\n  while(q--){\n    Point p0, p1;\n    Line l1, l2;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y;\n    l1 = Line(p0, p1);\n    \n    cin >> p0.x >> p0.y >> p1.x >> p1.y;\n    l2 = Line(p0, p1);\n    \n    if(is_intersect_SS(l1, l2)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(ll i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\n\nusing P=complex<R>;\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nusing L=struct{P s,t;};\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tP a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tL s1={a,b},s2={c,d};\n\t\tcout << iss(s1,s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___GEOMETRY_LIBRARY\n#define ___GEOMETRY_LIBRARY\n\n#include <vector>\n#include <algorithm>\n\ntemplate<class type>\nclass point2d {\npublic:\n\ttype x, y;\n\tpoint2d() : x(type(0)), y(type(0)) {};\n\tpoint2d(type x_, type y_) : x(x_), y(y_) {};\n\tbool operator==(const point2d& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const point2d& p) { return x != p.x || y != p.y; }\n\tpoint2d& operator+=(const point2d& p) { x += p.x; y += p.y; return *this; }\n\tpoint2d& operator-=(const point2d& p) { x -= p.x; y -= p.y; return *this; }\n\tpoint2d& operator*=(type val) { x *= val; y *= val; return *this; }\n\tpoint2d& operator/=(type val) { x /= val; y /= val; return *this; }\n\tpoint2d operator+(const point2d& p) const { return point2d(*this) += p; }\n\tpoint2d operator-(const point2d& p) const { return point2d(*this) -= p; }\n\tpoint2d operator*(type val) const { return point2d(*this) *= val; }\n\tpoint2d operator/(type val) const { return point2d(*this) /= val; }\n\ttype norm() const { return x * x + y * y; }\n\ttype abs() const { return type(std::sqrt(x * x + y * y)); }\n\tlong double fabs() const { return std::sqrt((long double)(x * x + y * y)); }\n\ttype dot(const point2d& p) const { return x * p.x + y * p.y; }\n\ttype cross(const point2d& p) const { return x * p.y - y * p.x; }\n\tint ccw(const point2d& p1, const point2d& p2) const {\n\t\t// Centering at point p, p1 -> p2 is COUNTER-CLOCKWISE : (1)\n\t\t// Centering at point p, p1 -> p2 is CLOCKWISE : (-1)\n\t\t// Collinear with order p1 -> p -> p2 : (2)\n\t\t// Collinear with order p -> p1 -> p2 : (-2)\n\t\t// Collinear with order p -> p2 -> p1 : (0)\n\t\tpoint2d pr1 = p1 - point2d(*this);\n\t\tpoint2d pr2 = p2 - point2d(*this);\n\t\tif (pr1.cross(pr2) != 0) return pr1.cross(pr2) > 0 ? 1 : -1;\n\t\tif (pr1.dot(pr2) < 0) return 2;\n\t\treturn pr1.norm() < pr2.norm() ? -2 : 0;\n\t}\n};\n\ntemplate<class type>\nclass segment2d {\npublic:\n\tpoint2d<type> p1, p2;\n\tsegment2d() : p1(point2d<type>()), p2(point2d<type>()) {};\n\tsegment2d(const point2d<type>& p1_, const point2d<type>& p2_) : p1(p1_), p2(p2_) {};\n\ttype norm() const { return (p1 - p2).norm(); }\n\ttype abs() const { return (p1 - p2).abs(); }\n\tlong double fabs() const { return (p1 - p2).fabs(); }\n};\n\n// DETERMINE IF \"SEGMENT\" S1 AND S2 INTERSECTS\ntemplate<class type>\nbool intersect(const segment2d<type>& s1, const segment2d<type>& s2) {\n\tint f1 = s1.p1.ccw(s1.p2, s2.p1) * s1.p1.ccw(s1.p2, s2.p2);\n\tint f2 = s2.p1.ccw(s2.p2, s1.p1) * s2.p1.ccw(s2.p2, s1.p2);\n\treturn (f1 <= 0 && f2 <= 0);\n}\n\n#endif // ___GEOMETRY_LIBRARY\n\n#include <iostream>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint q;\n\tcin >> q;\n\tcout.precision(15);\n\tfor (int i = 0; i < q; ++i) {\n\t\tsegment2d<double> s1, s2;\n\t\tcin >> s1.p1.x >> s1.p1.y >> s1.p2.x >> s1.p2.y >> s2.p1.x >> s2.p1.y >> s2.p2.x >> s2.p2.y;\n\t\tcout << (intersect(s1, s2) ? \"1\\n\" : \"0\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\n/* ?¨±?????????????????  */\n#define EPS (1e-10)\n\n/* ?????? (cross product) : a??b = |a||b|sin */\ndouble cross(const P& a, const P& b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n/* a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????????? */\nint isIntersectedLS(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main() {\n  int n;\n  int ax, ay, bx, by, cx, cy, dx, dy;\n  scanf(\"%d\", &n);\n\n  while(n--) {\n    scanf(\"%d %d %d %d %d %d %d %d\", &ax, &ay, &bx, &by, &cx, &cy, &dx, &dy);\n    P a(ax, ay), b(bx, by), c(cx, cy), d(dx, dy);\n    if(isIntersectedLS(a, b, c, d)) puts(\"1\");\n    else puts(\"0\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n#define EPS 1e-7\nconst double PI = 3.14159265358979323846;\n\nbool equal(double f1, double f2) {\n    return abs(f1 - f2) < EPS;\n}\n\nstruct Vec {\n\n    double x, y;\n\n    double size() {\n        return sqrt(x * x + y * y);\n    }\n\n    double inner_product(Vec v2) {\n        return x * v2.x + y * v2.y;\n    }\n\n    Vec product(double rate) {\n        Vec v2;\n        v2.x = x * rate;\n        v2.y = y * rate;\n        return v2;\n    }\n};\n\n\nstruct Point {\n    double x, y;\n\n    Point plus(Vec vec) {\n        Point p;\n        p.x = x + vec.x;\n        p.y = y + vec.y;\n        return p;\n    }\n\n    Point minus(Point sub) {\n        Point p;\n        p.x = x - sub.x;\n        p.y = y - sub.y;\n        return p;\n    }\n\n\n    friend istream &operator>>(istream &is, Point &f) {\n        cin >> f.x >> f.y;\n        return is;\n    }\n\n    friend ostream &operator<<(std::ostream &os, Point const &f) {\n        printf(\"%.20f %.20f\\n\", f.x, f.y);\n        return os;\n    }\n};\n\nstruct Line {\n    Point start, end;\n\n    Vec to_vec() {\n        Vec vec;\n        vec.x = end.x - start.x;\n        vec.y = end.y - start.y;\n        return vec;\n    }\n\n    friend istream &operator>>(istream &is, Line &f) {\n        cin >> f.start >> f.end;\n        return is;\n    }\n\n    Line normalize() {\n        Line l;\n        l.start = {0, 0};\n        l.end = end.minus(start);\n        return l;\n    }\n\n    double atan2() {\n        Line l = normalize();\n        return std::atan2(l.end.y, l.end.x);\n    }\n\n    double rad(Line line) {\n        double f1 = atan2(),\n                f2 = line.atan2();\n\n        double diff = f1 - f2;\n        if (equal(diff, -PI)) {\n            return PI;\n        }\n        if (equal(diff, PI)) {\n            return PI;\n        }\n        if (diff < -PI) {\n            diff += (PI * 2);\n        }\n        if (diff > PI) {\n            diff -= (PI * 2);\n        }\n\n        return diff;\n    }\n\n    void clock_wise(Line line) {\n\n        double diff = rad(line);\n\n        if (equal(line.to_vec().size(), 0)) {\n            cout << \"ON_SEGMENT\" << endl;\n            return;\n        }\n\n        if (equal(diff, 0)) {\n            double s1 = to_vec().size();\n            double s2 = line.to_vec().size();\n\n            if (s1 > s2 || equal(s1, s2)) {\n                cout << \"ON_SEGMENT\" << endl;\n            } else {\n                cout << \"ONLINE_FRONT\" << endl;\n            }\n        } else if (equal(abs(diff), PI)) {\n            cout << \"ONLINE_BACK\" << endl;\n        } else if (diff < 0) {\n            cout << \"COUNTER_CLOCKWISE\" << endl;\n        } else {\n            cout << \"CLOCKWISE\" << endl;\n        }\n    }\n\n    static const int COUNTER_CLOCKWISE = 1;\n    static const int CLOCKWISE = -1;\n    static const int ONLINE_BACK = 2;   // p2->p0->p1\n    static const int ONLINE_FRONT = -2; // p0->p1->p2\n    static const int ON_SEGMENT = 0;    // p0->p2->p1\n\n    double dot(Point a, Point b) {\n        return a.x * b.x + a.y * b.y;\n    }\n\n    double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    double norm(Point a) {\n        return a.x * a.x + a.y * a.y;\n    }\n\n    int ccw(Point p0, Point p1, Point p2) {\n        Point a = p1.minus(p0);\n        Point b = p2.minus(p0);\n        if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n        if (cross(a, b) < -EPS) return CLOCKWISE;\n        if (dot(a, b) < -EPS) return ONLINE_BACK;\n        if (norm(a) < norm(b)) return ONLINE_FRONT;\n        return ON_SEGMENT;\n    }\n\n    bool intersect(Point p1, Point p2, Point p3, Point p4) {\n        return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n                ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n    }\n\n    bool intersect(Line s1) {\n        return intersect(start, end, s1.start, s1.end);\n    }\n\n};\n\n\nint main() {\n//    ofstream outfile(\"log.txt\");\n\n\n    int n;\n    cin >> n;\n    rep(i, n) {\n        Line l1, l2;\n        cin >> l1 >> l2;\n        bool b = l1.intersect(l2);\n        cout << b << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n#define EPS 1e-9\n\ndouble toRadian(double deg) {return ((deg*PI)/180.0);}\ndouble toDegree(double radian) {return ((radian*180.0)/PI);}\ndouble handleNegZero(double x) {return ((abs(x) < EPS)?0.0:x);}\n\nstruct point_i { int x, y;     // whenever possible, work with point_i\n  point_i() { x = y = 0; }                      // default constructor\n  point_i(int _x, int _y) : x(_x), y(_y) {} };         // user-defined\n\nstruct Point { //Integer Point\n    double x, y;\n    Point(){}\n    Point(double _x, double _y):x(_x), y(_y){}\n\n    bool operator < (Point other) const {\n        if(fabs(x - other.x) > EPS)\n            return x < other.x;\n        return y < other.y;\n    }\n\n    bool operator == (Point other) const {\n        return ((fabs(x - other.x) < EPS) && (fabs(y - other.y) < EPS));\n    }\n};\n\ndouble pointDistaceSquared2D (Point a, Point b) {return (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);}\ndouble dist (Point a, Point b) {return sqrt(pointDistaceSquared2D(a, b));}\n// rotate p by theta degrees CCW w.r.t origin (0, 0)\nPoint rotate(Point p, double theta) {\n    double rad = toRadian(theta);\n    return Point(p.x * cos(rad) - p.y * sin(rad),\n                 p.x * sin(rad) + p.y * cos(rad));\n}\n\nstruct line {double a, b, c;};\nvoid pointsToLine(Point p1, Point p2, line &l) {\n    if(fabs(p1.x-p2.x) < EPS) {\n        l.a = 1.0; l.b = 0.0; l.c = -p1.x;\n    } else {\n        l.a = -(double)(p1.y-p2.y) / (p1.x-p2.x);\n        l.b = 1.0;\n        l.c = -(double)(l.a*p1.x)-p1.y;\n    }\n}\n\nbool areParallel(line l1, line l2) {\n    return (fabs(l1.a-l2.a) < EPS) && (fabs(l1.b-l2.b) < EPS);\n}\n\nbool areSame(line l1, line l2) {\n    return areParallel(l1, l2) && (fabs(l1.c-l2.c) < EPS);\n}\n\nbool areIntersect(line l1, line l2, Point &p) {\n    if(areParallel(l1, l2)) return false;\n    p.x = (l2.b*l1.c-l1.b*l2.c) / (l2.a*l1.b-l1.a*l2.b);\n    if(fabs(l1.b) > EPS) p.y = -(l1.a*p.x+l1.c);\n    else                 p.y = -(l2.a*p.x+l2.c);\n    return true;\n}\n\n// Given three colinear points p, q, r, the function checks if\n// point q lies on line segment 'pr'\nbool onSegment(Point p, Point q, Point r)\n{\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n       return true;\n\n    return false;\n}\n\n// To find orientation of ordered triplet (p, q, r).\n// The function returns following values\n// 0 --> p, q and r are colinear\n// 1 --> Clockwise\n// 2 --> Counterclockwise\nint orientation(Point p, Point q, Point r)\n{\n    // See 10th slides from following link for derivation of the formula\n    // http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf\n    int val = (q.y - p.y) * (r.x - q.x) -\n              (q.x - p.x) * (r.y - q.y);\n\n    if (val == 0) return 0;  // colinear\n\n    return (val > 0)? 1: 2; // clock or counterclock wise\n}\n\n// The main function that returns true if line segment 'p1q1'\n// and 'p2q2' intersect.\nbool doIntersect(Point p1, Point q1, Point p2, Point q2)\n{\n    // Find the four orientations needed for general and\n    // special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n\n    // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n\n    // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n\n     // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false; // Doesn't fall in any of the above cases\n}\n\nstruct vec {\n    double x, y;\n    vec(){}\n    vec(double _x, double _y):x(_x), y(_y){}\n};\n\nvec toVec(Point a, Point b) {return vec(b.x - a.x, b.y - a.y);}\nvec scale(vec v, double s) {return vec(v.x*s, v.y*s);}\nPoint translate(Point p, vec v) {return Point(p.x + v.x, p.y + v.y);}// translate p according to v\ndouble dot(vec a, vec b) {return (a.x*b.x + a.y*b.y);}\ndouble norm_sq(vec v) {return v.x*v.x + v.y*v.y;}\n\n// returns the distance from p to the line defined by\n// two points a and b (a and b must be different)\n// the closest point is stored in the 4th parameter (byref)\ndouble distToLine(Point p, Point a, Point b, Point &c) {\n    // formula: c = a + u* ab\n    vec ap = toVec(a, p), ab = toVec(a, b);\n    double u = dot(ap, ab) / norm_sq(ab);\n    c = translate(a, scale(ab, u));\n    return dist(p, c);\n}\n\n// returns the distance from p to the line segment ab defined by\n// two points a and b (still OK if a == b)\n// the closest point is stored in the 4th parameter (byref)\ndouble distToLineSegment(Point p, Point a, Point b, Point &c) {\n    vec ap = toVec(a, p), ab = toVec(a, b);\n    double u = dot(ap, ab) / norm_sq(ab);\n    if (u < 0.0) {\n        c = Point(a.x, a.y);\n        return dist(p, a);\n    }\n\n    if(u > 1.0) {\n        c = Point(b.x, b.y);\n        return dist(p, b);\n    }\n\n    return distToLine(p, a, b, c);\n}\n\ndouble angle(Point a, Point o, Point b) { // returns angle aob in rad\n    vec oa = toVec(o, a), ob = toVec(o, b);\n    return acos(dot(oa, ob) / sqrt(norm_sq(oa) * norm_sq(ob)));\n}\n\ndouble cross(vec a, vec b) {return a.x*b.y - a.y*b.x;}\n// note: to accept collinear points, we have to change the '> 0'\n// returns true if point r is on the left side of line pq\nbool ccw(Point p, Point q, Point r) {return cross(toVec(p, q), toVec(p, r)) > 0;}\n// returns true if point r is on the same line as the line pq\nbool collinear(Point p, Point q, Point r) {\n    return fabs(cross(toVec(p, q), toVec(p, r))) < EPS;\n}\n\ndouble trianglePerimeter(double a, double b, double c) {return (a+b+c)*0.5;}\ndouble triangleArea(double b, double h) {return (b*h)*0.5;}\ndouble triangleArea(double a, double b, double c) {\n    double s = trianglePerimeter(a, b, c);\n    return sqrt( s*(s-a)*(s-b)*(s-c) );\n}\n\n//in radian\ndouble triangleAngle(double a, double b, double c) {//angle opposite to line c\n    double nume = a*a+b*b-c*c;\n    double denom = 2.0*a*b;\n    return acos(nume/denom);\n}\n\nint insideCircle(point_i p, point_i c, int r) { // all integer version\n  int dx = p.x - c.x, dy = p.y - c.y;\n  int Euc = dx * dx + dy * dy, rSq = r * r;             // all integer\n  return Euc < rSq ? 0 : Euc == rSq ? 1 : 2;\n} //inside/border/outside\n\n//Given the intersection point p1, p2 and radius r find centers\nbool circle2PtsRad(Point p1, Point p2, double r, Point &c) {\n  double d2 = (p1.x - p2.x) * (p1.x - p2.x) +\n              (p1.y - p2.y) * (p1.y - p2.y);\n  double det = r * r / d2 - 0.25;\n  if (det < 0.0) return false;\n  double h = sqrt(det);\n  c.x = (p1.x + p2.x) * 0.5 + (p1.y - p2.y) * h;\n  c.y = (p1.y + p2.y) * 0.5 + (p2.x - p1.x) * h;\n  return true;\n}         // to get the other center, reverse p1 and p2\n\ndouble circleCircumference(double r) {return 2.0*PI*r;}\ndouble circleArea(double r){return PI*r*r;}\ndouble circleSectorArea(double r, double theta) {\n    return (circleArea(r)*theta)/360.0;\n}\n\n//Given three sides of a triangle\ndouble inCircleRadius(double a, double b, double c) {\n    double area = triangleArea(a, b, c);\n    double s = trianglePerimeter(a, b, c);\n    return (area/s);\n}\n\n//Given three sides of a triangle\ndouble circumCircleRadius(double a, double b, double c) {\n    double  A = triangleAngle(b, c, a);\n    double  d = a / sin(A);\n    return d*=0.5;\n}\n\ndouble coneArea(double h, double r) {return (PI*r*r*h)/3.0;}\ndouble coneFrustumArea(double R, double r, double h) {return ((R*R+R*r+r*r)*PI*h)/3.0;}\n\n//Polygon\n// returns the perimeter, which is the sum of Euclidian distances\n// of consecutive line segments (polygon edges)\ndouble perimeter(const vector<Point> &P) {\n  double result = 0.0;\n  for (int i = 0; i < (int)P.size()-1; i++)  // remember that P[0] = P[n-1]\n    result += dist(P[i], P[i+1]);\n  return result; }\n\n// returns the area, which is half the determinant\ndouble area(const vector<Point> &P) {\n  double result = 0.0, x1, y1, x2, y2;\n  for (int i = 0; i < (int)P.size()-1; i++) {\n    x1 = P[i].x; x2 = P[i+1].x;\n    y1 = P[i].y; y2 = P[i+1].y;\n    result += (x1 * y2 - x2 * y1);\n  }\n  return fabs(result) / 2.0; }\n\n// returns true if we always make the same turn while examining\n// all the edges of the polygon one by one\nbool isConvex(const vector<Point> &P) {\n  int sz = (int)P.size();\n  if (sz <= 3) return false;   // a point/sz=2 or a line/sz=3 is not convex\n  bool isLeft = ccw(P[0], P[1], P[2]);               // remember one result\n  for (int i = 1; i < sz-1; i++)            // then compare with the others\n    if (ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) != isLeft)\n      return false;            // different sign -> this polygon is concave\n  return true; }                                  // this polygon is convex\n\n// returns true if point p is in either convex/concave polygon P\nbool inPolygon(Point pt, const vector<Point> &P) {\n  if ((int)P.size() == 0) return false;\n  double sum = 0;    // assume the first vertex is equal to the last vertex\n  for (int i = 0; i < (int)P.size()-1; i++) {\n    if (ccw(pt, P[i], P[i+1]))\n         sum += angle(P[i], pt, P[i+1]);                   // left turn/ccw\n    else sum -= angle(P[i], pt, P[i+1]); }                 // right turn/cw\n  return fabs(fabs(sum) - 2*PI) < EPS; }\n\n// line segment p-q intersect with line A-B.\nPoint lineIntersectSeg(Point p, Point q, Point A, Point B) {\n  double a = B.y - A.y;\n  double b = A.x - B.x;\n  double c = B.x * A.y - A.x * B.y;\n  double u = fabs(a * p.x + b * p.y + c);\n  double v = fabs(a * q.x + b * q.y + c);\n  return Point((p.x * v + q.x * u) / (u+v), (p.y * v + q.y * u) / (u+v)); }\n\n// cuts polygon Q along the line formed by Point a -> Point b\n// (note: the last Point must be the same as the first Point)\nvector<Point> cutPolygon(Point a, Point b, const vector<Point> &Q) {\n  vector<Point> P;\n  for (int i = 0; i < (int)Q.size(); i++) {\n    double left1 = cross(toVec(a, b), toVec(a, Q[i])), left2 = 0;\n    if (i != (int)Q.size()-1) left2 = cross(toVec(a, b), toVec(a, Q[i+1]));\n    if (left1 > -EPS) P.push_back(Q[i]);       // Q[i] is on the left of ab\n    if (left1 * left2 < -EPS)        // edge (Q[i], Q[i+1]) crosses line ab\n      P.push_back(lineIntersectSeg(Q[i], Q[i+1], a, b));\n  }\n  if (!P.empty() && !(P.back() == P.front()))\n    P.push_back(P.front());        // make P's first Point = P's last Point\n  return P; }\n\nint main() {\n\n    int q;\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    scanf(\"%d\", &q);\n\n    for(int i = 0; i < q; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point   a = Point(x0, y0),\n                b = Point(x1, y1),\n                c = Point(x2, y2),\n                d = Point(x3, y3);\n\n        printf(\"%d\\n\", doIntersect(a, b, c, d));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,a,b) for(register ll(i)=(ll)(a);(i)<=(ll)(b);++i)\nconst ll inf=1e9+7;\n#define y1 _y_1_\n#ifndef gc\n\t#define gc getchar\n#endif\n#ifndef pc\n\t#define pc putchar\n#endif\ninline ll read(){ll f=0,x=0;register char c=gc();while(!isdigit(c))f^=c=='-',c=gc();while(isdigit(c))x=(x<<3)+(x<<1)+(c^'0'),c=gc();return x=f?-x:x;}\ninline ll read(ll&x){ll f=0;x=0;register char c=gc();while(!isdigit(c))f^=c=='-',c=gc();while(isdigit(c))x=(x<<3)+(x<<1)+(c^'0'),c=gc();return x=f?-x:x;}\ninline void writeln(){pc('\\n');}\ninline void write(ll x){if(x<0)pc('-'),x=-x;if(x>9)write(x/10);pc(x%10+'0');}\ninline void writeln(const ll&x){write(x),pc('\\n');}\nusing namespace std;\nnamespace Computation_Geometry{\n\tconst ld eps=1e-6;\n\tstruct point{\n\t\tld x,y;\n\t\tinline point(){x=y=0;}\n\t\tinline point(const ld&X,const ld&Y){x=X,y=Y;}\n\t\tinline friend point operator +(const point&A,const point&B){return point(A.x+B.x,A.y+B.y);}\n\t\tinline friend point operator -(const point&A,const point&B){return point(A.x-B.x,A.y-B.y);}\n\t\tinline friend point operator *(const point&A,const ld&k){return point(A.x*k,A.y*k);}\n\t\tinline friend point operator /(const point&A,const ld&k){return A*(1.0/k);}\n\t};\n\tstruct vec{\n\t\tld x,y;\n\t\tinline bool is_zero(){return (abs(x)<=eps)&(abs(y)<=eps);}\n\t\tinline void scan(){x=read(),y=read();}\n\t\tinline vec(){x=y=0;}\n\t\tinline vec(const ld&X,const ld&Y){x=X,y=Y;}\n\t\tinline friend vec operator +(const vec&A,const vec&B){return vec(A.x+B.x,A.y+B.y);}\n\t\tinline friend vec operator -(const vec&A,const vec&B){return vec(A.x-B.x,A.y-B.y);}\n\t\tinline friend vec operator *(const vec&A,const ld&k){return vec(A.x*k,A.y*k);}\n\t\tinline friend vec operator /(const vec&A,const ld&k){return A*(1.0/k);}\n\t\tinline ld len(){return sqrt(x*x+y*y);}\n\t\tinline ld len(const ll&X,const ll&Y){return sqrt((x-X)*(x-X)+(y-Y)*(y-Y));}\n\t\tinline ld k(){return (x==0)?inf:y/x;}\n\t\tinline ld k(const ll&X,const ll&Y){return (x==X)?inf:(y-Y)/(x-X);}\n\t\tinline friend ld Dot(const vec&A,const vec&B){return A.x*B.x+A.y*B.y;}\n\t\tinline friend ld Cross(const vec&A,const vec&B){return A.x*B.y-B.x*A.y;}\n\t\tinline friend ld Theta(vec A,vec B){return acos(Cross(A,B)/A.len()/B.len());}\n\t\tinline friend ll ccw(vec p0,vec p1,vec p2){\n\t\t\tp1=p1-p0,p2=p2-p0;\n\t\t\tif (Cross(p1,p2)>=eps) return 1;//COUNTER_CLOCKWISE\n\t\t\telse if (Cross(p1,p2)<-eps) return -1;//CLOCKWISE\n\t\t\telse if (Dot(p1,p2)<-eps) return 2;//ONLINE_BACK\n\t\t\telse if (p1.len()<p2.len())return -2;//ONLINE_FRONT\n\t\t\treturn 0;//ON_SEGMENT\n\t\t}\n\t};\n\tstruct line{\n\t\tld A,B,C;\n\t\tinline line(){A=B=C=0;}\n\t\tinline line(const ld&_A,const ld&_B,const ld&_C){A=_A,B=_B,C=_C;}\n\t\tinline line(const ld&x1,const ld&y1,const ld&x2,const ld&y2){A=y2-y1,B=x1-x2,C=x2*y1-x1*y2;}\n\t\tinline line(const vec&_A,const vec&_B){A=_A.y-_B.y,B=_B.x-_A.x,C=Cross(_A,_B);}\n\t\tinline vec Vec(){return vec(A,B);}\n\t\tinline friend bool is_on_line(line A,point B){return abs(A.A*B.x+A.B*B.y+A.C)<=eps;}\n\t\tinline friend bool parallel(line A,line B){return abs(Cross(A.Vec(),B.Vec()))<=eps;}\n\t\tinline friend bool perpendicular(line A,line B){return abs(Dot(A.Vec(),B.Vec()))<=eps;}\n\t\tinline friend point intersection(const line A, const line B){return point(A.B*B.C-A.C*B.B,A.C*B.A-A.A*B.C)/(A.A*B.B-A.B*B.A);}\n\t};\n\tstruct segment{\n\t\tld x1,x2,y1,y2;\n\t\tinline segment(){x1=y1=x2=y2=0;}\n\t\tinline segment(const ld&X1,const ld&Y1,const ld&X2,const ld&Y2){x1=X1,y1=Y1,x2=X2,y2=Y2;}\n\t\tinline line Line(){return line(x1,y1,x2,y2);}\n\t\tinline friend bool is_on_segment(segment A,point B){\n\t\t\tif (!is_on_line(A.Line(),B)) return false;\n\t\t\treturn ((A.x1<=B.x&&B.x<=A.x2)||(A.x2<=B.x&&B.x<=A.x1))&&((A.y1<=B.y&&B.y<=A.y2)||(A.y2<=B.y&&B.y<=A.y1));\n\t\t}\n\t\tinline friend bool is_intersected(segment A,segment B){\n\t\t\tvec a=vec(A.x1,A.y1),b=vec(A.x2,A.y2),c=vec(B.x1,B.y1),d=vec(B.x2,B.y2);\n\t\t\treturn ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n\t\t}\n\t};\n}\nusing namespace Computation_Geometry;\nll Q;\nld x1,y1,x2,y2;\nsegment l1,l2;\nsigned main(){\n\tread(Q);while (Q--){\n\t\tx1=read(),y1=read(),x2=read(),y2=read();\n\t\tl1=segment(x1,y1,x2,y2);\n\t\tx1=read(),y1=read(),x2=read(),y2=read();\n\t\tl2=segment(x1,y1,x2,y2);\n\t\tif (is_intersected(l1,l2)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\tfclose(stdin);fclose(stdout);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tGeometry Template\n\tdouble !!!\n\tTODO: test everything!!!\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double INF = 1e17;\nconst double EPS = 1e-9;\nconst double PI = 2.0 * asin(1);\n\ninline bool is_in(double a, double b, double x) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\treturn (a - EPS <= x && x <= b + EPS);\n}\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double _x, double _y) : x(_x), y(_y) {}\n};\n\nbool operator < (const point &P, const point &Q) {\n\tif (abs(P.y - Q.y) > EPS) {\n\t\treturn P.y < Q.y;\n\t}\n\tif (abs(P.x - Q.x) > EPS) {\n\t\treturn P.x < Q.x;\n\t}\n\treturn false;\n}\n\nstruct compare_by_x {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.x - Q.x) > EPS) {\n\t\t\treturn P.x < Q.x;\n\t\t}\n\t\treturn P.y < Q.y;\n\t}\n};\n\nstruct compare_by_y {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.y - Q.y) > EPS) {\n\t\t\treturn P.y < Q.y;\n\t\t}\n\t\treturn P.x < Q.x;\n\t}\n};\ninline void read(point &P) {\n\tcin >> P.x >> P.y;\n}\n\npoint operator + (const point &P, const point &Q) {\n\treturn point(P.x + Q.x, P.y + Q.y);\n}\n\npoint operator - (const point &P, const point &Q) {\n\treturn point(P.x - Q.x, P.y - Q.y);\n}\n\npoint operator * (const point &P, const double k) {\n\treturn point(P.x * k, P.y * k);\n}\n\npoint operator / (const point &P, const double k) {\n\tassert(fabs(k) > EPS);\n\treturn point(P.x / k, P.y / k);\n}\n\ninline double dot(const point &P, const point &Q) {\n\treturn P.x * Q.x + P.y * Q.y;\n}\n\ninline double cross(const point &P, const point &Q) {\n\treturn P.x * Q.y - P.y * Q.x;\n}\n\ninline double norm2(const point &P) {\n\treturn dot(P, P);\n}\n\ninline double norm(const point &P) {\n\treturn sqrt(dot(P, P));\n}\n\ninline double dist2(const point &P, const point &Q) {\n\treturn norm2(P - Q);\n}\n\ninline double dist(const point &P, const point &Q) {\n\treturn sqrt(dot(P - Q, P - Q));\n}\n\n// returns true if P belongs in segment AB\ninline bool is_in(point A, point B, point P) {\n\tif (abs(cross(B - A, P - A)) > EPS) {\n\t\treturn false;\n\t}\n\treturn (is_in(A.x, B.x, P.x) && is_in(A.y, B.y, P.y));\n}\n\n\ninline point project(const point &P, const point &P1, const point &P2) {\n\treturn P1 + (P2 - P1) * (dot(P2 - P1, P - P1) / norm2(P2 - P1));\n}\n\ninline point reflect(const point &P, const point &P1, const point &P2) {\n\treturn project(P, P1, P2) * 2.0 - P;\n}\n\ninline double point_to_line(const point &P, const point &A, const point &B) {\n\t// return abs(cross(B - A, C - A) / norm(B - A));\n\treturn dist(P, project(P, A, B));\n}\n\ninline double point_to_segment(const point &P, const point &A, const point &B) {\n\tpoint PP = project(P, A, B);\n\tif (is_in(A, B, PP)) {\n\t\treturn dist(P, PP);\n\t}\n\treturn min(dist(P, A), dist(P, B));\n}\n\n// line to line intersection\n// A, B difine the first line\n// C, D define the second line\ninline point intersect(const point &A, const point &B, const point &C, const point &D) {\n\treturn A + (B - A) * (cross(C - A, C - D) / cross(B - A, C - D));\n}\n\ninline double segment_to_segment(const point &A, const point &B, const point &C, const point &D) {\n\tpoint I = intersect(A, B, C, D);\n\tif (is_in(A, B, I) && is_in(C, D, I)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(point_to_segment(A, C, D), point_to_segment(B, C, D)),\n\t\t\t\t\t\t min(point_to_segment(C, A, B), point_to_segment(D, A, B)));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\n\tint q;\n\tcin >> q;\n\n\twhile (q--) {\n\t\tpoint A, B, C, D;\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> D.x >> D.y;\n\t\tdouble answer = segment_to_segment(A, B, C, D);\n\t\tcout << ((answer < EPS) ? \"1\" : \"0\") << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tP p[4];\n\t\tPIN(p,4);\n\t\tP a=p[1]-p[0];\n\t\tP b=p[3]-p[2];\n\t\tif((cross(a,p[2]-p[0])*cross(a,p[3]-p[0])<EPS)&&(cross(b,p[1]-p[2])*cross(b,p[0]-p[2])<EPS))cout<<1<<endl;\n\t\telse cout<<0<<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct CWW{\n    CWW(){\n        cin.tie(0);\n        ios_base::sync_with_stdio(0);\n        cout<<fixed<<setprecision(15);\n    }\n}STAR;\n\nusing D=double;\n\nconst D EPS=1e-8;\nconst D INF=1e9;\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_FRONT=2;\nconst int ONLINE_BACK=-2;\nconst int ON_SEGMENT=0;\n\nusing Point=complex<D>;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point c;\n    D r;\n    Circle(const Point &c=Point(),const D &r=0.0):c(c),r(r){}\n};\n\nusing Polygon=vector<Point>;\n\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nistream& operator>>(istream &is,Point &a){\n    D x,y;\n    is>>x>>y;\n    a=Point(x,y);\n    return is;\n}\n\nostream& operator<<(ostream& os,const Point &a){\n    os<<real(a)<<\" \"<<imag(a);\n    return os;\n}\n\nistream& operator>>(istream &is,Line &l){\n    Point p1,p2;\n    is>>p1>>p2;\n    l=Line(p1,p2);\n    return is;\n}\n\nistream& operator>>(istream &is,Segment &s){\n    Point p1,p2;\n    is>>p1>>p2;\n    s=Segment(p1,p2);\n    return is;\n}\n\n\nD dot(const Point &a,const Point &b){\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n\nD cross(const Point &a,const Point &b){\n    return real(a)*imag(b)-imag(a)*real(b);\n}\n\nPoint projection(const Point &a,const Point &b){\n    return a*real(b/a);\n}\n\nPoint projection(const Line &l,const Point &a){\n    return l.p1+projection(l.p2-l.p1,a-l.p1);\n}\n\nPoint reflection(const Line &l,const Point &a){\n    Point p=projection(l,a);\n    return 2.0*p-a;\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(b,c)<-EPS)return CLOCKWISE;\n    if(dot(b,c)<-EPS)return ONLINE_BACK;\n    if(norm(b)+EPS<norm(c))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isOrthogonal(const Point &a,const Point &b){\n    return EQ(dot(a,b),0.0);\n}\n\nbool isOrthogonal(const Point &a1,const Point &a2,const Point &b1,const Point &b2){\n    return isOrthogonal(a2-a1,b2-b1);\n}\n\nbool isOrthogonal(const Line &l,const Line &m){\n    return isOrthogonal(l.p1,l.p2,m.p1,m.p2);\n}\n\nbool isParallel(const Point &a,const Point &b){\n    return EQ(cross(a,b),0.0);\n}\n\nbool isParallel(const Point &a1,const Point &a2,const Point &b1,const Point &b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(const Line &l,const Line &m){\n    return isParallel(l.p1,l.p2,m.p1,m.p2);\n}\n\nbool intersect(const Point &a1,const Point &a2,const Point &b1,const Point &b2){\n    return ccw(a1,a2,b1)*ccw(a1,a2,b2)<=0&&\n            ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0;\n}\n\nbool intersect(Segment &s,Segment &t){\n    return intersect(s.p1,s.p2,t.p1,t.p2);\n}\n\n\nint main(){\n    int Q;cin>>Q;\n    while(Q--){\\\n        Segment s,t;\n    cin>>s>>t;\n        cout<<intersect(s,t)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n\tdouble dot(const Point &o) const { return x * o.x + y * o.y; }\n\n\tdouble atan() const { return atan2(y, x); }\n\n\tdouble norm() const { return sqrt(dot(*this)); }\n\n\tdouble distance(const Point &o) const { return (o - (*this)).norm(); }\n\n\tdouble area(const Point &a,const Point &b) {\n\t\tPoint p = a - (*this), p2 = b - (*this); \n\t\treturn p.cross(p2);\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const {\n\t\tPoint p = a - (*this), p2 = b - (*this);\n\t\treturn fabs(p.cross(p2)) / 2.0;\n\t}\t\n\n\t//??????ab?????????????????????????????????????????????????????????\n\tint between(const Point &a,const Point &b) {\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)  return ((a.x <= x) && (x <= b.x)) || ((a.x >= x) && (x >= b.x));\n\t\telse return ((a.y <= y) && (y <= b.y)) || ((a.y >= y) && (y >= b.y));\n\t}      \n\n\tdouble distance_seg(const Point& a,const Point& b) {\n\t\tif((b-a).dot(*this-a) < EPS) {\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS) {\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(b.cross(c) > 0.0) return +1;\t//conter clockwise\n\tif(b.cross(c) < 0.0) return -1;\t//clockwise\n\tif(b.dot(c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }\n\n\tbool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }\n\n\t// bool isIntersect(Seg &s) {\n\t// \tif(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {\n\t// \t\treturn true;\n\t// \t}\n\t// \treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t// }\n\n\tbool isIntersect(Seg &s) {\n\t\tif(ccw(a, b, s.a) == 0 || ccw(a, b, s.b) == 0 || ccw(s.a, s.b, a) == 0 || ccw(s.a, s.b, b) ==  0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t}\n\n\tbool distance(Seg &s) {\n\t\tif((*this).isIntersect(s)) return 0.0;\n\n\t\treturn min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));\n\t}\n\n\tPoint getCrossPoint(Seg &s) {\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n\tPoint project(Point &p) {\n\t\tPoint base = b - a;\n\t\tdouble t = base.dot(p-a) / base.dot(base);\n\t\treturn a + base * t;\n\t}\n\n\tPoint reflect(Point &p) {\n\t\treturn p + (project(p) - p) * 2.0;\n\t}\n};\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tSeg s1, s2;\n\trep(i, q) {\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\n\t\tif(s1.isIntersect(s2)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n\n    Point() = default;\n    Point(int x, int y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(x + rhs.x, y + rhs.y);\n    }\n\n    Point operator-(const Point &rhs) const {\n        return Point(x - rhs.x, y - rhs.y);\n    }\n\n    long long operator*(const Point &rhs) const {\n        return 1ll * x * rhs.x + 1ll * y * rhs.y;\n    }\n\n    long long operator%(const Point &rhs) const {\n        return 1ll * x * rhs.y - 1ll * y * rhs.x;\n    }\n};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    if (max(p1.x, p2.x) < min(p3.x, p4.x) || max(p3.x, p4.x) < min(p1.x, p2.x)) return false;\n    if (max(p1.y, p2.y) < min(p3.y, p4.y) || max(p3.y, p4.y) < min(p1.y, p2.y)) return false;\n    return ((p3 - p1) % (p4 - p1)) * ((p3 - p2) % (p4 - p2)) <= 0 &&\n           ((p1 - p3) % (p2 - p3)) * ((p1 - p4) % (p2 - p4)) <= 0;\n}\n\nint main() {\n    int q; cin >> q;\n    while (q--) {\n        Point p1, p2, p3, p4;\n        cin >> p1.x >> p1.y;\n        cin >> p2.x >> p2.y;\n        cin >> p3.x >> p3.y;\n        cin >> p4.x >> p4.y;\n        cout << (intersect(p1, p2, p3, p4) ? 1 : 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nnamespace LibraryOfComputationalGeometry {\n\ttypedef long double ld;\n\tconst ld eps = 1e-9;\n\tstruct point {ld x, y; };\n\tstruct line {point a, b; }; //Be sure that a and b are distinct.\n\tvoid ReadPointInt(point &a) {read(a.x), read(a.y); }\n\tvoid ReadLineInt(line &a) {ReadPointInt(a.a), ReadPointInt(a.b); }\n\tvoid CerrPoint(point a) {cerr << a.x << ' ' << a.y << endl; }\n\tvoid CerrLine(line a) {cerr << a.a.x << ' ' << a.a.y << ' ' << a.b.x << ' ' << a.b.y << endl; }\n\tpoint operator + (point a, point b) {return (point) {a.x + b.x, a.y + b.y}; }\n\tpoint operator - (point a, point b) {return (point) {a.x - b.x, a.y - b.y}; }\n\tpoint operator * (point a, ld b) {return (point) {a.x * b, a.y * b}; }\n\tld dot(point a, point b) {return a.x * b.x + a.y * b.y; }\n\tld operator * (point a, point b) {return a.x * b.y - a.y * b.x; }\n\tld moo(point a) {return sqrtl(a.x * a.x + a.y * a.y); }\n\tld dist(point a, point b) {return moo(a - b); }\n\tpoint unit(point a) {\n\t\tld tmp = moo(a);\n\t\tassert(tmp > eps);\n\t\treturn a * (1.0 / tmp);\n\t}\n\tpoint Projection(point x, line a) {\n\t\tld d = dot(x - a.a, a.b - a.a) / dist(a.a, a.b);\n\t\treturn a.a + unit(a.b - a.a) * d;\n\t}\n\tpoint Reflection(point x, line a) {\n\t\treturn Projection(x, a) * 2 - x;\n\t}\n\tbool OnLine(point x, line a) {\n\t\treturn fabsl((a.b - a.a) * (x - a.a)) <= eps;\n\t}\n\tbool OnSegment(point x, line a) {\n\t\treturn dist(x, a.a) + dist(x, a.b) - dist(a.a, a.b) <= eps;\n\t}\n\tbool Parallel(line a, line b) {\n\t\treturn fabsl((a.b - a.a) * (b.b - b.a)) <= eps;\n\t}\n\tbool Orthogonal(line a, line b) {\n\t\treturn fabsl(dot(a.b - a.a, b.b - b.a)) <= eps;\n\t}\n\tbool SegmentIntersect(line a, line b) {\n\t\tif (Parallel(a, b)) return OnSegment(b.a, a) || OnSegment(b.b, a) || OnSegment(a.a, b) || OnSegment(a.b, b);\n\t\tld tmp = ((a.b - a.a) * (b.a - a.a)) * ((a.b - a.a) * (b.b - a.a));\n\t\tld tnp = ((b.b - b.a) * (a.a - b.a)) * ((b.b - b.a) * (a.b - b.a));\n\t\treturn tmp <= eps && tnp <= eps;\n\t}\n}\nint main() {\n\tusing namespace LibraryOfComputationalGeometry;\n\tint q; read(q);\n\twhile (q--) {\n\t\tline a, b;\n\t\tReadLineInt(a);\n\t\tReadLineInt(b);\n\t\tif (SegmentIntersect(a, b)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\nbool crit(const Point &p0, const Point &p1, const Point &p2, const Point &p3)\n{\n\t// det2(V01, V02) * det2(V01, V03) > 0 ? true : false.\n\tdouble d2 = (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);\n\tdouble d3 = (p1.x - p0.x) * (p3.y - p0.y) - (p3.x - p0.x) * (p1.y - p0.y);\n\treturn ((d2 > 0 && d3 > 0) || (d2 < 0 && d3 < 0) ? true : false);\n}\n\nint main()\n{\n    int q;\n    double d12, d13;\n    scanf(\"%d\", &q);\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n    for(int i = 0; i < q; i++){\n        scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        Point P0 = set_p(x0, y0), P1 = set_p(x1, y1), P2 = set_p(x2, y2), P3 = set_p(x3, y3);\n        if(crit(P0, P1, P2, P3) || crit(P2, P3, P0, P1)){\n            printf(\"0\\n\");\n        }else{\n            printf(\"1\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\ntypedef Segment Line;                               //??´???\ntypedef struct Circle{Point c; double r;}Circle;    //???\ntypedef vector<Point> Polygon;                      //????§???¢\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n//????????????a?????§??????\ndouble absolute(Vector a){\n    return sqrt(norm(a));\n}\n\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//????????????a??¨b?????´?????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\n\n//????????????a??¨b???????????????\n//a??¨b?????´????????´??????????????????0?????????\nbool isParallel(Vector a , Vector b){\n    return equals(cross(a,b), 0.0);\n}\n\n//??????s(p1p2)???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//??????s(p1p2)???????§°?????¨?????????p???????±????\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\n//???a,???b???????????¢\ndouble getDistance(Point a, Point b){\n    return absolute(a - b);\n}\n\n//??´???s??¨???p????????¢\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / absolute(l.p2 - l.p1));\n}\n\n//??????s(?§????p1/??????p2)??¨???p????????¢d????±???????\n//??\\???????????????????????§??´?????????\n//??????????????????p2-p1??¨???????????????p-p1??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p1??¨????????¢\n//??????????????????p1-p2??¨???????????????p-p2??????????§???????90???????????§????????´???????????????-90?????????????°?????????´?????????d??????p??¨???p2??¨????????¢\n//??????????????\\???????????????????????´??????d??????p??¨??´???p1p2????????¢\ndouble getDistanceSP(Segment s, Point p){\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return absolute(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return absolute(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p3) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n//??????s1??¨??????s2????????¢\n//??\\????????????????????¢????????§????????????????????????\n//????????????s1??¨??????s2????§????s2.p1????????¢\n//????????????s1??¨??????s2?????????s2.p2????????¢\n//????????????s2??¨??????s1????§????s1.p1????????¢\n//????????????s2??¨??????s1?????????s1.p2????????¢\ndouble getDistance(Segment s1, Segment s2){\n    if ( intersect(s1, s2) ) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n    \n}\n\n//??????s1??¨??????s2?????????????±???????\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n//?????¨??????l?????????????±???????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / absolute(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????????±???????\nVector polar(double a, double r){\n    //??????a,?§????r???point????±???????\n    return Point(cos(r) * a, sin(r) * a);\n}\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    Vector v = c2.c - c1.c;\n    double d = absolute(v);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d) );\n    double t = atan2(v.y, v.x);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\n\n\nint main(){\n    \n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    \n    int q;\n    \n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        if(\n           intersect(\n                     Point(x0, y0),\n                     Point(x1, y1),\n                     Point(x2, y2),\n                     Point(x3, y3)\n                     )\n        ) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\nconst double EPS = 1e-10;\n\n// 内積 |a||b|cosθ\ndouble dot(Point a, Point b){\n\t// return a.real() * b.real() + a.imag() * b.imag();\n\treturn (conj(a) * b).real();\n}\n// 外積、符号付面積の２倍　|a||b|sinθ\ndouble cross(Point a, Point b){\n\t// return a.real() * b.imag() - a.imag() * b.real();\n\treturn (conj(a) * b).imag();\n}\n// 点の位置関係　2点a,bから見た点cの位置関係\nint ccw(Point a, Point b, Point c){\n    // COUNTER_CLOCKWISE\n    if(cross(b - a, c - a) > EPS) return 1;\n    // CLOCKWISE\n    if(cross(b - a, c - a) < -EPS) return -1;\n    // ONLINE_BACK\n    if(dot(b - a, c - a) < -EPS) return 2;\n    // ONLINE_FRONT\n    if(abs(b - a) + EPS < abs(c - a)) return -2;\n    // ON_SEGMENT\n    return 0;\n}\n// 線分の交差判定\nbool is_cross(Line a, Line b){\n    if(ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 && ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        double x, y;\n        Point p[4];\n        for(int j = 0; j < 4; j++){\n            cin >> x >> y;\n            p[j] = {x, y};\n        }\n        Line s1 = {p[0], p[1]};\n        Line s2 = {p[2], p[3]};\n        cout << is_cross(s1, s2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\ntypedef struct point{ // 繝吶け繝医Ν(蜴溽せ・峨繧・xy蠎ｧ讓・\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x,double y) :x(x),y(y){};\n\t//繝吶け繝医Ν逧・ｨ育ｮ・\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y) ;}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y) ;}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y ,x*p.y+y*p.x ) ;}\n\tpoint operator * (double k){ return point(x*k,y*k) ;}\n\tpoint operator / (double k){ return point(x/k,y/k) ;}\n\t//螟ｧ蟆城未菫ゅx蠎ｧ讓吶蜆ｪ蜈・\n\tbool operator <  (const point &p) { return x!=p.x ? x<p.x : y < p.y;}\n\tbool operator >  (const point &p) { return x!=p.x ? x>p.x : y > p.y;}\n\tbool operator ==  (const point &p) { return fabs(x-p.x) <= EPS && fabs(y-p.y) <=  EPS ;}\n\t//髢｢謨ｰ\n\tdouble norm(){ return x*x+y*y;}\n\tdouble abs(){ return sqrt(norm() );}\t\n\tvoid print(){ cout<<x<<' '<<y<<endl; }\n\tvoid make(){ cin>>x>>y;}\n}point;\n\ntypedef struct segment{// 邱壼・ s -> e\n\tpoint s,e;\n\tsegment(){};\n\tsegment(point &s,point &e) : s(s),e(e){};\n\t//髢｢謨ｰ\n\tpoint vec() { return e-s;}\n\tdouble abs(){ return (e-s).abs();}\n\tvoid print(){ cout<<\"(\"<<s.x<<\",\"<<s.y<<\") (\"<<e.x<<\",\"<<e.y<<\")\"<<endl;}\n\tvoid make(){ s.make(),e.make(); }\n\tvoid swap() { point tmp = s; s = e;e = tmp;}\n\t\n}segment;\n//蜀・ｩ・\ndouble dot(point &a,point &b){return a.x*b.x + a.y*b.y; }\n//螟也ｩ・\ndouble cross(point &a,point &b){return a.x*b.y-a.y*b.x; }\n\n\n// p1~p2 荳翫↓縲p3縺後≠繧九°蛻､螳・\ndouble direction(point &p1,point &p2,point &p3){ point a = p3-p1, b = p2-p1; return cross( a ,b  ); }\nbool on_segment(point &p1,point &p2,point &p3){\n\t//if( abs(  direction(p1,p2,p3)  ) < EPS ) //segments_intersect縺ｧ縺ｯ蠢・ｦ√↑縺・\n\t\tif(  min(p1.x,p2.x) <= p3.x && p3.x <= max(p1.x,p2.x)  ) return true;\n\treturn false;  \n}\n//莠､轤ｹ讀懷・\nbool segments_intersect(point &p1,point &p2,point &p3,point &p4){\n\tdouble d1 = direction(p3,p4,p1);\n\tdouble d2 = direction(p3,p4,p2);\n\tdouble d3 = direction(p1,p2,p3);\n\tdouble d4 = direction(p1,p2,p4);\n\tif(  ( (d1 > 0 and d2 < 0 ) or (d1 < 0 and d2 > 0) ) and ( ( d3 > 0 and d4 < 0) or ( d3 < 0 and d4 > 0) )  ) return true;   \n\tif( ( abs(d1) <= EPS )  and on_segment(p3,p4,p1) ) return true;\n\tif( ( abs(d2) <= EPS )  and on_segment(p3,p4,p2) ) return true;\n\tif( ( abs(d3) <= EPS )  and on_segment(p1,p2,p3) ) return true;\n\tif( ( abs(d4) <= EPS )  and on_segment(p1,p2,p4) ) return true;\n\treturn false;\n}\nbool segments_intersect(segment &s1,segment &s2){ return segments_intersect(s1.s,s1.e,s2.s,s2.e) ; }\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tsegment s1,s2;\n\t\ts1.make();\n\t\ts2.make();\n\t\tif(segments_intersect(s1,s2) ) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef complex<double> point;\nstruct segment { point p, q; };\n\ndouble dot(point a, point b) { return real(conj(a) * b); }\n\ndouble cross(point a, point b) { return imag(conj(a) * b); }\n\ndouble area2(point a, point b, point c) { return cross(b - a, c - a); }\n\nint ccw(point a, point b, point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0) return +1; // counter clockwise\n\tif (cross(b, c) < 0) return -1; // clockwise\n\tif (dot(b, c) < 0) return \n\t+2; // c--a--b on line\n\tif (dot(b, b) < dot(c, c)) return -2; // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const segment &s, const segment &t)\n{\n\treturn ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0 &&\n\t\t\tccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n}\n\npoint read(){\n\tdouble x, y; cin >> x >> y;\n\treturn point(x, y);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i){\n\t\tpoint p = read(), q = read();\n\t\tsegment s1 = {p, q};\n\t\tp = read(), q = read();\n\t\tsegment s2 = {p, q};\n\t\tif (intersectSS(s1, s2)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\t// parallel\n\t\tif((t0==0 && t1==0) || (t2==0 && t3==0)){\n\t\t\tif(((xp2-xp0)*(xp2-xp1) <= 0 || (xp3-xp0)*(xp3-xp1) <= 0) && ((yp2-yp0)*(yp2-yp1) <= 0 || (yp3-yp0)*(yp3-yp1) <= 0)) ret = 1;\n\t\t\telse if((((xp2-xp0)*(xp2-xp1) <= 0 && (xp3-xp0)*(xp3-xp1) <= 0) || ((xp0-xp2)*(xp0-xp3) <= 0 && (xp1-xp2)*(xp1-xp3) <= 0)) \n\t\t\t\t&& \n\t\t\t\t     ((yp2-yp0)*(yp2-yp1) <= 0 && (yp3-yp0)*(yp3-yp1) <= 0) || ((yp0-yp2)*(yp0-yp3) <= 0 && (yp1-yp2)*(yp1-yp3) <= 0)) ret = 1;\n\t\t}else{\n\t\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma region Geometry\nconst double EPS=1e-8,PI=acos(-1);\ninline bool EQ(double a,double b){return fabs(b-a)<EPS;}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) const {return Point{x+p.x,y+p.y};}\n    Point operator-(Point p) const {return Point{x-p.x,y-p.y};}\n    Point operator*(double t) const {return Point{x*t,y*t};}\n    Point operator*(Point p) const {return Point{x*p.x-y*p.y,x*p.y+y*p.x};}\n    Point operator/(double t) const {return Point{x/t,y/t};}\n    bool operator<(const Point &p) const {\n        return x!=p.x?x<p.x:y<p.y;\n    }\n    bool operator==(const Point &p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n    friend istream &operator>>(istream &is,Point &p){\n        is >> p.x >> p.y;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Point p){\n        os << fixed << setprecision(10) << p.x << ' ' << p.y;\n        return os;\n    }\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point a,Point b):a(a),b(b){}\n    friend istream &operator>>(istream &is,Line &l){\n        is >> l.a >> l.b;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Line l){\n        os << l.a << \" to \" << l.b;\n        return os;\n    }\n};\n\nstruct Segment:Line{\n    Segment(){}\n    Segment(Point a,Point b):Line(a,b){}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c,double r):c(c),r(r){}\n    friend istream &operator>> (istream &is,Circle &c){\n        is >> c.c >> c.r;\n        return is;\n    }\n    friend ostream &operator<<(ostream &os,Circle &c){\n        os << c.c << ' ' << c.r;\n        return os;\n    }\n};\n\ntypedef vector<Point> Polygon;\nistream &operator>>(istream &is,Polygon &p){\n    for (int i=0;i<p.size();++i) is >> p[i];\n    return is;\n}\n\ndouble dot(const Point &a,const Point &b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(const Point &a,const Point &b){\n    return a.x*b.y-a.y*b.x;\n}\ndouble norm(const Point &a){\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(const Point &a){\n    return sqrt(norm(a));\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\nPoint proj(const Line &l,const Point &p){\n    double t=dot(p-l.a,l.b-l.a)/norm(l.b-l.a);\n    return l.a+(l.b-l.a)*t;\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\nPoint refl(const Line &l,const Point &p){\n    return p+(proj(l,p)-p)*2.0;\n}\n\nPoint rotate(const Point &p,double theta){\n    return Point(cos(theta)*p.x-sin(theta)*p.y,sin(theta)*p.x+cos(theta)*p.y);\n}\ndouble arg(const Point &p){\n    return atan2(p.y,p.x);\n}\ndouble get_angle(const Point &a,const Point &b,const Point &c){\n    const Point v=b-a,w=c-b;\n    double alpha=arg(v),beta=arg(w);\n    if (alpha>beta) swap(alpha,beta);\n    double theta=beta-alpha;\n    return min(theta,2*PI-theta);\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\nint ccw(const Point &a,Point b,Point c){\n    b=b-a,c=c-a;\n    if (cross(b,c)>EPS) return COUNTER_CLOCKWISE;\n    if (cross(b,c)<-EPS) return CLOCKWISE;\n    if (dot(b,c)<-EPS) return ONLINE_BACK;\n    if (norm(b)<norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\nbool orthogonal(const Point &a,const Point &b){\n    return EQ(dot(a,b),0.0);\n}\nbool orthogonal(const Point &a,const Point &b,const Point &c,const Point &d){\n    return orthogonal(b-a,d-c);\n}\nbool orthogonal(const Line &l,const Line &m){\n    return EQ(dot(l.b-l.a,m.b-m.a),0.0);\n}\n// https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\nbool parallel(const Point &a,const Point &b){\n    return EQ(cross(a,b),0.0);\n}\nbool parallel(const Point &a,const Point &b,const Point &c,const Point &d){\n    return parallel(b-a,d-c);\n}\nbool parallel(const Line &l,const Line &m){\n    return EQ(cross(l.b-l.a,m.b-m.a),0.0);\n}\n\nbool intersect(const Line &l,const Point &p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\nbool intersect(const Line &l,const Line &m){\n    return abs(cross(l.b-l.a,m.b-m.a)>EPS||abs(cross(l.b-l.a,m.b-m.a))<EPS);\n}\nbool intersect(const Line &l,const Segment &s){\n    return cross(l.b-l.a,s.a-l.a)*cross(l.b-l.a,s.b-l.a)<EPS;\n}\nbool intersect(const Segment &s,const Point &p){\n    return ccw(s.a,s.b,p)==0;\n}\nbool intersect(const Segment &s,const Segment &t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0&&ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\nbool intersect(const Circle &c,const Line &l){\n    return (norm(proj(l,c.c)-c.c)-c.r*c.r)<=EPS;\n}\nint intersect(const Circle &c,const Segment &s){\n    if (norm(proj(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n    double d1=abs(c.c-s.a),d2=abs(c.c-s.b);\n    if (d1<c.r+EPS&&d2<c.r+EPS) return 0;\n    if (d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS) return 1;\n    const Point h=proj(s,c.c);\n    if (dot(s.a-h,s.b-h)<0) return 2;\n    return 0;\n}\nint intersect(Circle c,Circle d){\n    if (c.r<d.r) swap(c,d);\n    double dist=abs(c.c-d.c);\n    if (c.r+d.r<dist) return 4;\n    if (EQ(c.r+d.r,dist)) return 3;\n    if (c.r-d.r<dist) return 2;\n    if (EQ(c.r-d.r,dist)) return 1;\n    return 0;\n}\n\ndouble distance(const Point &a,const Point &b){\n    return abs(b-a);\n}\ndouble distance(const Line &l,const Point &p){\n    return abs(p-proj(l,p));\n}\ndouble distance(const Line &l,const Line &m){\n    return intersect(l,m)?0:distance(l,m.a);\n}\ndouble distance(const Segment &s,const Point &p){\n    Point h=proj(s,p);\n    return intersect(s,h)?abs(h-p):min(abs(s.a-p),abs(s.b-p));\n}\ndouble distance(const Segment &s,const Segment &t){\n    if (intersect(s,t)) return 0;\n    return min({distance(s,t.a),distance(s,t.b),distance(t,s.a),distance(t,s.b)});\n}\ndouble distance(const Line &l,const Segment &s){\n    return intersect(l,s)?0:min(distance(l,s.a),distance(l,s.b));\n}\n\nPoint crosspoint(const Line &l,const Line &m){\n    double d1=cross(l.b-l.a,m.b-m.a),d2=cross(l.b-l.a,l.b-m.a);\n    if (EQ(abs(d1),0.0)&&EQ(abs(d2),0.0)) return m.a;\n    return m.a+(m.b-m.a)*d2/d1;\n}\nPoint crosspoint(const Segment &s,const Segment &t){\n    assert(intersect(s,t));\n    return crosspoint(Line(s),Line(t));\n}\nvector<Point> crosspoint(const Circle &c,const Line &l){\n    Point pr=proj(l,c.c);\n    Point e=(l.b-l.a)/abs(l.b-l.a);\n    if (EQ(distance(l,c.c),c.r)) return {pr};\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return {pr-e*base,pr+e*base};\n}\nvector<Point> crosspoint(const Circle &c,const Segment &s){\n    Line l=Line(s);\n    assert(intersect(c,l));\n    auto res=crosspoint(c,l);\n    if (intersect(c,l)==2) return res;\n    if (dot(l.a-res[0],l.b-res[0])<0) res.emplace_back(res[0]);\n    else res.pop_back();\n    return res;\n}\nvector<Point> crosspoint(const Circle &c,const Circle &d){\n    double dist=abs(c.c-d.c);\n    double a=acos((c.r*c.r+dist*dist-d.r*d.r)/(2*c.r*dist));\n    double t=arg(d.c-c.c);\n    Point p1=c.c+Point(cos(t+a),sin(t+a))*c.r,p2=c.c+Point(cos(t-a),sin(t-a))*c.r;\n    return {p1,p2};\n}\n\nCircle circumcenter(Point a,Point b,const Point &c){\n    a=(a-c)*0.5;\n    b=(b-c)*0.5;\n    Point center=c+crosspoint(Line(a,a*Point{1,1}),Line{b,b*Point{1,1}});\n    return Circle{center,abs(a-center)};\n}\nvector<Point> center_given_radius(const Point &a,const Point &b,const double &r){\n    Point m=(b-a)*0.5;\n    double d1=abs(m);\n    vector<Point> res;\n    if (EQ(d1,0.0)||d1>r) return res;\n    double d2=sqrt(r*r-d1*d1);\n    Point n=m*Point{0.0,1.0}*d2/d1;\n    res.emplace_back(a+m+n);\n    if (d2>EPS) res.emplace_back(a+m-n);\n    return res;\n}\n\nbool convex(const Polygon &p){\n    int n=p.size();\n    for (int i=0;i<n;++i){\n        if (ccw(p[(i+n-1)%n],p[i],p[(i+1)%n])==-1){\n            return false;\n        }\n    }\n    return true;\n}\n\nPolygon convex_hull(Polygon p){\n    int n=p.size(),k=0;\n    if (n<=2) return p;\n    sort(p.begin(),p.end());\n    Polygon ch(2*n);\n    for (int i=0;i<n;ch[k++]=p[i++]){\n        while(k>=2&&cross(ch[k-1]-ch[k-2],p[i]-ch[k-1])<EPS) --k;\n    }\n    for (int i=n-2,t=k+1;i>=0;ch[k++]=p[i--]){\n        while(k>=t&&cross(ch[k-1]-ch[k-2],p[i]-ch[k-1])<EPS) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int q; cin >> q;\n    for (;q--;){\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        Segment l1(p0,p1),l2(p2,p3);\n        cout << (intersect(l1,l2)?1:0) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n\n#define EPS 1e-10\n\nusing namespace std;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tint q;\n\tscanf(\"%d\",&q);\n\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n\n\t\tif(func(x1,y1,x2,y2,x3,y3)*func(x1,y1,x2,y2,x4,y4) <= 0 &&\n\t\t\t\tfunc(x3,y3,x4,y4,x1,y1) * func(x3,y3,x4,y4,x2,y2) <= 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing ui = unsigned int;\nusing ull = unsigned long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\nusing VULL = vector<ull>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\nconst double EPS = 1E-10;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nclass Point2D{\n    double x, y;\npublic:\n    Point2D(double X=0, double Y=0): x(X), y(Y){}\n    Point2D(const Point2D& v): x(v.x), y(v.y){}\n    template<class T>\n    Point2D(const vector<T> &v){\n        assert(v.size() == 2);\n        x = v[0]; y = v[1];\n    }\n    template<class T, class T2>\n    Point2D(const pair<T, T2> &p){\n        x = p.first; y = p.second;\n    }\n\n    void setX(double X){x = X;}\n    double getX(){return x;}\n    void setY(double Y){y = Y;}\n    double getY(){return y;}\n\n    Point2D operator+() const{return *this;}\n    Point2D operator-() const{return Point2D(-x, -y);}\n\n    Point2D& operator=(const Point2D& v){\n        x = v.x; y = v.y;\n        return *this;\n    }\n\n    Point2D& operator+=(const Point2D& v){\n        x += v.x; y += v.y;\n        return *this;\n    }\n\n    Point2D& operator-=(const Point2D& v){\n        x -= v.x; y -= v.y;\n        return *this;\n    }\n\n    Point2D& operator*=(const double a){\n        x *= a; y *= a;\n        return *this;\n    }\n\n    Point2D& operator/=(const double a){\n        x /= a; y /= a;\n        return *this;\n    }\n\n    Point2D operator+(const Point2D& v) const{\n        Point2D tmp(*this);\n        return tmp += v;\n    }\n\n    Point2D operator-(const Point2D& v) const{\n        Point2D tmp(*this);\n        return tmp -= v;\n    }\n\n    Point2D operator*(const double a) const{\n        Point2D tmp(*this);\n        return tmp *= a;\n    }\n\n    friend Point2D operator*(double a, const Point2D v){\n        return v * a;\n    }\n\n    Point2D operator/(const double a) const{\n        Point2D tmp(*this);\n        return tmp /= a;\n    }\n\n    double norm(){return x*x + y*y;}\n    friend double norm(Point2D v){return v.norm();}\n    double abs(){return sqrt(norm());}\n    friend double abs(Point2D v){return v.abs();}\n\n    bool operator<(const Point2D &v) const{\n        return x != v.x ? x < v.x : y < v.y;\n    }\n\n    bool operator>(const Point2D &v) const{\n        return x != v.x ? x > v.x : y > v.y;\n    }\n\n    bool operator==(const Point2D &v) const{\n        return std::abs(x - v.x) < EPS\n            && std::abs(y - v.y) < EPS;\n    }\n\n    bool operator<=(const Point2D &v) const{\n        return (*this < v) || (*this == v);\n    }\n\n    bool operator>=(const Point2D &v) const{\n        return (*this > v) || (*this == v);\n    }\n\n    friend double dot(Point2D a, Point2D b){\n        return a.x*b.x + a.y*b.y;\n    }\n\n    friend double cross(Point2D a, Point2D b){\n        return a.x*b.y - a.y*b.x;\n    }\n\n    friend double distance(Point2D a, Point2D b){\n        return (a - b).abs();\n    }\n\n    friend bool isParallel(Point2D a, Point2D b){\n        return std::abs(cross(a, b)) < EPS;\n    }\n\n    friend bool isOrthogonal(Point2D a, Point2D b){\n        return std::abs(dot(a, b)) < EPS;\n    }\n\n    friend int ccw(Point2D a, Point2D b){\n        if(cross(a, b) > EPS) return 1;//反時計\n        if(cross(a, b) < -EPS) return -1;//時計\n        if(dot(a, b) < -EPS) return 2;//逆向き\n        if(a.norm() < b.norm()) return -2;//同じ向きbが大きい\n        return 0;//同じ向きaが大きい\n    }\n\n    friend int ccw(Point2D p0, Point2D p1, Point2D p2){\n        return ccw(p1-p0, p2-p0);\n    }\n\n    friend bool intersect(Point2D p1, Point2D p2, Point2D p3, Point2D p4){\n        return(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n               ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n    }\n};\nusing Vector2D = Point2D;\n\nclass Line2D{\n    Point2D p1, p2;\npublic:\n    Line2D(){}\n    Line2D(Point2D a, Point2D b): p1(a), p2(b){}\n\n    void setP1(const Point2D p){p1 = p;}\n    Point2D getP1(){return p1;}\n    void setP2(const Point2D p){p2 = p;}\n    Point2D getP2(){return p2;}\n\n    friend Point2D project(Line2D l, Point2D p){\n        Point2D base = l.p2 - l.p1;\n        double r = dot(p - l.p1, base) / norm(base);\n        return l.p1 + base * r;\n    }\n\n    friend Point2D reflect(Line2D l, Point2D p){\n        return p + 2.0 * (project(l, p) - p);\n    }\n\n    friend bool isParallel(Line2D s1, Line2D s2){\n        return isParallel(s1.p2 - s1.p1, s2.p2- s2.p1);\n    }\n\n    friend bool isOrthogonal(Line2D s1, Line2D s2){\n        return isOrthogonal(s1.p2 - s1.p1, s2.p2- s2.p1);\n    }\n\n    friend bool intersect(Line2D s1, Line2D s2){\n        return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n    }\n};\nusing Segment2D = Line2D;\n\n\n\nint main(){\n    int q; cin >> q;\n    REP(i, q){\n        vector<Point2D> p(4);\n        REP(j, 4){\n            double x, y;\n            cin >> x >> y;\n            p[j].setX(x); p[j].setY(y);\n        }\n        cout << (intersect(p[0], p[1], p[2], p[3]) ? 1 : 0) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs(a-b)<EPS)\nstatic const int CCW=1;//?????¶???\nstatic const int CW=-1;//?????¶???\nstatic const int BACK=-2;//?????¢\nstatic const int FRONT=2;//?????¢\nstatic const int ON=0;//?????????\n\nstruct Point//???\n{\n    double x, y;\n    Point(double x=0, double y=0):x(x), y(y){}\n};\ntypedef Point Vector;//??????\n\nstruct Segment{ Point p1, p2; };//??????\ntypedef Segment Line;//??´???\n\nclass Circle//???\n{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(), double r=0.0):c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;//????????¢\n\nPoint operator + (Point a, Point b){ return Point(a.x+b.x, a.y+b.y); }\nPoint operator - (Point a, Point b){ return Point(a.x-b.x, a.y-b.y); }\nPoint operator * (Point a, double p){ return  Point(a.x*p, a.y*p); }\nPoint operator / (Point a, double p){ return Point(a.x/p, a.y/p); }\n\ndouble norm(Vector a){ return a.x*a.x+a.y*a.y; }//?????°????¨?????????????\ndouble abs(Vector a){ return sqrt(norm(a)); }//?¨?\ndouble dot(Vector a, Vector b){ return a.x*b.x+a.y*b.y; }//??????\ndouble cross(Vector a, Vector b){ return a.x*b.y-a.y*b.x; }//??????\n\nbool isOrthgonal(Vector a, Vector b){ return equals(dot(a, b), 0.0); }//???????????´????????????\nbool isOrthgonal(Point a1, Point a2, Point b1, Point b2){ return isOrthgonal(a1-a2, b1-b2); }//???????????´???4?????????\nbool isOrthgonal(Segment s1, Segment s2){ return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0); }//???????????´????????????\n\nbool isParallel(Vector a, Vector b){ return equals(cross(a, b), 0.0); }//????????????????????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2){ return isParallel(a1-a2, b1-b2); }//???????????????4?????????\nbool isParallel(Segment s1, Segment s2){ return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0); }//????????????????????????\n\nPoint project(Segment s, Point p)//?±?????¶?\n{\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1, base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s, Point p)//?±??????°??´??????????§°???\n{\n    return p+(project(s, p)-p)*2.0;\n}\n\ndouble getDistance(Point a, Point b){ return abs(a-b); }//????????´?????????\ndouble getDistanceLP(Line l, Point p){ return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1)); }//?????°??´????????????\ndouble getDistanceSP(Segment s, Point p)//?????°???????????????\n{\n    if(dot(s.p2-s.p1, p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2)//??????P0,P1,P2??????????????????\n{\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if( cross(a, b)>EPS ) return CCW;\n    if( cross(a, b)<-EPS ) return CW;\n    if( dot(a, b)<-EPS ) return BACK;\n    if( norm(a)<norm(b) ) return FRONT;\n    return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)//???????????????4?????????\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 &&\n            ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0);\n}\n\nbool intersect(Segment s1, Segment s2)//???????????????????????????\n{\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2)//???????????´?????????\n{\n    if(intersect(s1, s2)) return 0.0;\n    return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2)),\n                min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)) );\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while(T--)\n    {\n        Segment S1,S2;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &S1.p1.x, &S1.p1.y, &S1.p2.x, &S1.p2.y, &S2.p1.x, &S2.p1.y, &S2.p2.x, &S2.p2.y);\n        printf(\"%d\\n\", intersect(S1,S2));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(double xx=0,double yy=0){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble abs(){\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm(){\n\t\treturn x*x+y*y;\n\t}\n};\n\nstruct Segment{\n\tP p1,p2;\n\tSegment(P pp1=P(),P pp2=P()){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef P Vector;\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<-EPS)return -1;\n\tif(dot(a,b)<-EPS)return 2;\n\tif(a.norm()<b.norm())return -2;\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main(void){\n\tint q;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tSegment s1,s2;\n\t\tscanf(\"%lf %lf\",&s1.p1.x,&s1.p1.y);\n\t\tscanf(\"%lf %lf\",&s1.p2.x,&s1.p2.y);\n\t\tscanf(\"%lf %lf\",&s2.p1.x,&s2.p1.y);\n\t\tscanf(\"%lf %lf\",&s2.p2.x,&s2.p2.y);\n\t\tprintf(\"%d\\n\",intersect(s1,s2)?1:0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nbool eq(ld a, ld b){\n\treturn abs(a-b) < EPS;\n}\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nstring pos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (c.imag() > EPS)\n\t\treturn \"COUNTER_CLOCKWISE\";\n\tif (c.imag() + EPS < 0)\n\t\treturn \"CLOCKWISE\";\n\tif (c.real() + EPS < 0)\n\t\treturn \"ONLINE_BACK\";\n\tif (c.real() > 1 + EPS)\n\t\treturn \"ONLINE_FRONT\";\n\treturn \"ON_SEGMENT\";\n}\n\nint sgn(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn cr > EPS ? 1 : (cr + EPS < 0 ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = sgn(c, d, a),\n\t\tbs = sgn(c, d, b),\n\t\tcs = sgn(a, b, c),\n\t\tds = sgn(a, b, d);\n\tif (as && as == bs || cs && cs == ds)\n\t\treturn false;\n\telse if (as || bs || cs || ds)\n\t\treturn true;\n\tfor (int j = 0; j < 2; j++){\n\t\tld mx = min(a.X, b.X),\n\t\t   Mx = max(a.X, b.X),\n\t\t   my = min(a.Y, b.Y),\n\t\t   My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++){\n\t\t\tif (c.X + EPS > mx && c.X < Mx + EPS && c.Y + EPS > my && c.Y < My + EPS)\n\t\t\t\treturn true;\n\t\t\tswap(c, d);\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t}\n\treturn false;\n}\n\n\nint main(){\t\n\tfor (int i = in(); i; i--){\n\t\tPT a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tcout << intersect(a, b, c, d) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t(dot(b - a, c - a) > -EPS) &&\n\t\t(dot(a - b, c - b) > -EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (is_point_on_line(p0, p1, p2) || is_point_on_line(p0, p1, p3)) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_parallel(p0, p1, p2, p3)) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//计算几何 板子\n#include<bits/stdc++.h>\nusing namespace std ;\n#define eps 1e-10\n#define equals(a , b) (fabs((a) - (b)) < eps)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1 ;\nstatic const int ONCLICK_BACK = 2 ;\nstatic const int ONLINE_FRONT = -2 ;\nstatic const int ON_SEGMENT = 0 ;\n\nclass Point\n{\npublic:\n    double x , y;\n\n    Point(double x = 0 ,double y = 0):x(x) , y(y) {}\n\n    Point operator +(Point p){return Point(x + p.x , y + p.y) ;}\n    Point operator -(Point p){return Point(x - p.x , y - p.y) ;}\n    Point operator *(double a){return Point(a * x , a * y) ;}\n    Point operator /(double a){return Point(x / a , y / a) ;}\n\n    double abs() {return sqrt(norm()) ;}\n    double norm() {return x * x + y * y ;}\n\n    bool operator < (const Point &p) const\n    {\n        return x != p.x ? x < p.x : y < p.y ;\n    }\n\n    bool operator == (const Point &p) const\n    {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps ;\n    }\n\n};\n\ntypedef Point Vector;\n\nstruct Segment  //表示线段结构体\n{\n    Point p1 , p2 ;\n};\n\ndouble dot(Vector a , Vector b)  // 向量a,b的内积,就是向量a*b\n{\n    return a.x * b.x + a.y * b.y ;\n}\n\ndouble cross(Vector a, Vector b)  //向量a,b外积\n{\n\treturn a.x * b.y - a.y * b.x ;\n}\n\nbool isOrthogonal(Vector a , Vector b)  //判断是否正交\n{\n    return equals(dot(a , b) , 0.0) ;\n}\n\nbool isOrthogonal(Point a1 , Point a2 , Point b1 , Point b2)\n{\n    return isOrthogonal(a1 - a2 , b1 - b2) ;\n}\n\nbool  isOrthogonal(Segment s1 , Segment s2)\n{\n    return equals(dot(s1.p2 - s1.p1 , s2.p2 - s2.p1) , 0.0) ;\n}\n\nbool isParallel(Vector a, Vector b)  //判断是否平行\n{\n\treturn equals(cross(a, b), 0.0) ;\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn isParallel(a1 - a2, b1 - b2) ;\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0) ;\n}\n\nPoint project(Segment s, Point p)  //p在s上的投影\n{\n    Point base = s.p2 - s.p1 ;\n    double r = dot(p - s.p1 , base) / base.norm() ;\n    return s.p1 +base * r ;\n}\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求\n*/\n\nPoint reflect(Segment s , Point p)\n{\n    return p + (project(s , p) - p) * 2.0 ;\n}\n\nint ccw(Point p0 , Point p1 , Point p2)//判断三个点相对位置  // 判断逆时针方向的时候也可以使用\n{\n\tPoint a = p1 - p0 ;\n\tPoint b = p2 - p0 ;\n\tif(cross(a , b) > eps) return 1 ;  //p0,p1,p2成逆时针方向\n\tif(cross(a , b) < -eps) return -1 ;  //p0,p1,p2成顺时针方向\n\tif(dot(a , b) < -eps) return 2 ;  //p2 p0 p1一次排列在同一直线上\n\tif(a.norm() < b.norm()) return -2 ;  // p0 p1 p2一次排列在同一直线上\n\treturn 0 ;  //p2在线段p0p1上\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)  //判断是否相交 通过ccw来判断\n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1 , Segment s2)\n{\n    return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2) ;\n}\n\ndouble getdis(Point a , Point b)  //求俩点间的距离\n{\n\treturn (a - b) . abs() ; //点a与点b之间的距离等于向量a-b或b-a的绝对值。\n}\n\n//注意：这里Segmet s是不规范的应该是 Line s 才对\ndouble getdis_Li(Segment s , Point p)  //点与直线的距离\n{\n\treturn fabs(cross(s.p2 - s.p1 , p - s.p1)/(s.p2-s.p1).abs());\n}\n\ndouble getdis_sp(Segment s , Point p)  //点与线段的距离\n{\n\tif(dot(s.p2 - s.p1 , p - s.p1) < 0.0) return (p-s.p1).abs();\n\tif(dot(s.p1 - s.p2 , p - s.p2) < 0.0) return (p-s.p2).abs();\n\treturn getdis_Li(s , p) ;\n}\n\ndouble getdis_ss(Segment s1 , Segment s2)  //线段与线段之间的距离\n{\n\tif(intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2)) return 0.0 ;\n\treturn min(min(getdis_sp(s1 , s2.p1) , getdis_sp(s1 , s2.p2)) , min(getdis_sp(s2 , s1.p1) , getdis_sp(s2 , s1.p2))) ;\n}\n\n\n\nint main()\n{\n    int t ;\n    cin >> t ;\n    Point p0 , p1 , p2 , p3 ;\n    while(t --)\n    {\n        cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n        int sum = intersect(p0 , p1 , p2 , p3) ;\n        if(sum <= 0)\n            cout << 0 << endl ;\n        else\n            cout << 1 << endl ;\n\n    }\n    return 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\n//点を表す構造体\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x=0, double y=0){\n    this->x = x;\n    this->y = y;\n  }\n\n  Point operator+(const Point &seg2){\n    return Point(x+seg2.x, y+seg2.y);\n  }\n\n  Point operator-(const Point &seg2){\n    return Point(x-seg2.x, y-seg2.y);\n  }\n\n  Point operator*(const double k){\n    return Point(x*k, y*k);\n  }\n\n  bool operator < (const Point &p) const{\n    return x != p.x? x<p.x : y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return equals(x, p.x) && equals(y, p.y);\n  }\n\n};\n\n//ベクトルを点の別表記でも表せるようにしておく\nclass Vector : public Point{\npublic:\n  Vector() : Point() {}\n\n  Vector(double x, double y) : Point(x, y) {}\n\n  Vector(Point p) : Point(){\n    x = p.x;\n    y = p.y;\n  }\n\n  double norm(){\n    return x*x + y*y;\n  }\n\n  double abs(){\n    return sqrt(norm());\n  }\n\n  static double dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n  }\n\n  static bool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n  }\n};\n\n//線分(ベクトルを用いて)を表す構造体。両端の点が定義されている点に注意\nclass Segment{\npublic:\n  Point p1, p2;\n\n  Segment(Point p1, Point p2){\n    this->p1 = p1;\n    this->p2 = p2;\n    x = p2.x-p1.x;\n    y = p2.y-p1.y;\n  }\n\n  static bool isOrthogonal(Segment a, Segment b){\n    return equals(dot(a, b), 0.0);\n  }\n\n  static bool isParallel(Segment a, Segment b){\n    return equals(cross(a, b), 0.0);\n  }\n\nprivate:\n  int x, y;\n  static double dot(Segment a, Segment b){\n    return a.x*b.x + a.y*b.y;\n  }\n\n  static double cross(Segment a, Segment b){\n    return a.x*b.y - a.y*b.x;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\nstring ccw_str(Point p0, Point p1, Point p2){\n  //enum res {COUNTER_CLOCKWISE=0, CLOCKWISE, ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return \"COUNTER_CLOCKWISE\";\n  if(Vector::cross(a, b) < -EPS) return \"CLOCKWISE\";\n  if(Vector::dot(a, b) < -EPS) return \"ONLINE_BACK\";\n  if(a.norm() < b.norm()) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\nint ccw_int(Point p0, Point p1, Point p2){\n  enum res {COUNTER_CLOCKWISE=-1, CLOCKWISE=1, ONLINE_BACK=2, ONLINE_FRONT=-2, ON_SEGMENT=0};\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(Vector::cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(Vector::cross(a, b) < -EPS) return CLOCKWISE;\n  if(Vector::dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint project(Segment s, Point p){\n  Vector base = s.p2-s.p1;\n  double r = Vector::dot(p - s.p1, base) / base.norm();\n  return s.p1 + base*r;\n}\n\nPoint reflect(Segment s, Point p){\n  Point pro = project(s, p);\n  return p + (pro-p)*2.0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return ccw_int(p1, p2, p3)*ccw_int(p1, p2, p4)<=0 && ccw_int(p3, p4, p1)*ccw_int(p3, p4, p2)<=0;\n}\n\nint main(){\n  int q; cin >> q;\n\n  double p1_x, p1_y, p2_x, p2_y, p3_x, p3_y, p4_x, p4_y;\n\n  for(int i=0; i<q; i++){\n    cin >> p1_x >> p1_y >> p2_x >> p2_y >> p3_x >> p3_y >> p4_x >> p4_y;\n    Point p1(p1_x, p1_y), p2(p2_x, p2_y), p3(p3_x, p3_y), p4(p4_x, p4_y);\n    cout << intersect(p1, p2, p3, p4) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<fstream>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n//#define cout fout\n//#define cin fin\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y); \n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double a) {\n\t\treturn Point(a * x, a * y);\n\t}\n\tPoint operator / (double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\n#ifdef cin\nifstream fin(\"CGL_1_C-in29.txt\");\n#endif\n\n#ifdef cout\nofstream fout(\"out.txt\");\n#endif\n\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistanceSP(Point p, Point p1, Point p2);\ndouble angle(Vector a, Vector b);\nbool doIntersect(Point p1, Point p2, Point p3, Point p4);\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4);\nvoid clockwise(Point p0, Point p1, Point p2);\n\nint main() {\n    int i, q;\n\tdouble x0, x1, x2, x3, y0, y1, y2, y3;\n\t\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tPoint p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tif (doIntersect(p0, p1, p2, p3))cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n#ifdef cin\n\tfin.close();\n#endif\n\n#ifdef cout\n\tfout.close();\n#endif\n\treturn 0;\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble getDistanceSP(Point p, Point p1, Point p2) {\n\tif (dot(p - p1, p2 - p1) < 0.0)return (p - p1).abs();\n\telse if (dot(p - p2, p1 - p2) < 0.0)return (p - p2).abs();\n\telse return  fabs(cross(p2 - p1, p - p1)) / (p2 - p1).abs();\n}\n\n\ndouble angle(Vector a, Vector b) {\n\tif (equals(dot(a, b), a.abs() * b.abs()))return 0.0;\n\telse if (equals(dot(a, b), (-1) * a.abs() * b.abs()))return M_PI;\n\tif (cross(a, b) > 0.0)return acos(dot(a, b) / a.abs() / b.abs());\n\telse return (-1) * acos(dot(a, b) / a.abs() / b.abs());\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n\tif (angle(p2 - p1, p4 - p1) == 0.0 || angle(p2 - p1, p4 - p1) == M_PI && angle(p2 - p1, p3 - p1) == 0 || angle(p2 - p1, p3 - p1) == M_PI)return false;\n\telse if (angle(p3 - p1, p4 - p1) >= angle(p3 - p1, p2 - p1) && angle(p3 - p1, p2 - p1) >= 0.0 && angle(p2 - p3, p1 - p3) >= angle(p2 - p3, p4 - p3) && angle(p2 - p3, p4 - p3) >= 0.0)return true;\n\telse if (angle(p3 - p2, p4 - p2) >= angle(p3 - p2, p1 - p2) && angle(p3 - p2, p1 - p2) >= 0.0 && angle(p1 - p3, p2 - p3) >= angle(p1 - p3, p4 - p3) && angle(p1 - p3, p4 - p3) >= 0.0)return true;\n\telse return false;\n}\n\ndouble getDistanceSS(Point p1, Point p2, Point p3, Point p4) {\n\tif (doIntersect(p1, p2, p3, p4))return 0;\n\telse return min({ getDistanceSP(p4, p1, p2), getDistanceSP(p3, p1, p2), getDistanceSP(p1, p3, p4), getDistanceSP(p2, p3, p4) });\n}\n\nvoid clockwise(Point p0, Point p1, Point p2) {\n\tif (p2 == p0 || p2 == p1) {\n\t\tcout << \"ON_SEGMENT\" << endl;\n\t} else if (angle(p1 - p0, p2 - p0) == 0.0) {\n\t\tif((p1 - p0).norm() < (p2 - p0).norm())cout << \"ONLINE_FRONT\" << endl;\n\t\telse cout << \"ON_SEGMENT\" << endl;\n\t} else if(angle(p1 - p0, p2 - p0) == M_PI){\n\t\tcout << \"ONLINE_BACK\" << endl;\n\t} else {\n\t\tif(angle(p1 - p0, p2 - p0) > 0.0)cout << \"COUNTER_CLOCKWISE\" << endl;\n\t\telse cout << \"CLOCKWISE\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing ld = long double;\nusing Point = std::complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\nclass Circle\n{\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// l:line, m:line が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// l:line, s:segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// s:segment, t:segment\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l:line 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// p から l に下ろした足との交点\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// l:line, t:line の交点\nPoint is_ll(Line l, Line m)\n{\n    Point lv = l.b - l.a, mv = m.b - m.a;\n    assert(cross(lv, mv) != 0);\n    return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\n\n// p, l:line の距離\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return std::min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\n// 直線 l, m のなす角を求める\nld degree_ll(Line l, Line m)\n{\n    ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n    if (cos_shita < -1.0)\n        cos_shita = -1.0;\n    if (cos_shita > 1.0)\n        cos_shita = 1.0;\n    ld shita = acos(cos_shita);\n    // shita = sita * 180.0 / PI;\n    return shita;\n}\n\n// c1, c2 の交点\nstd::vector<Point> is_cc(Circle c1, Circle c2)\n{\n    std::vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.emplace_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.emplace_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nstd::vector<Point> is_lc(Circle c, Line l)\n{\n    std::vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.emplace_back(proj(l, c.p) + len * nor);\n        res.emplace_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nstd::vector<Point> is_sc(Circle c, Line l)\n{\n    std::vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.emplace_back(p);\n    return res;\n}\n\n// p から c への接線\nstd::vector<Line> tangent_cp(Circle c, Point p)\n{\n    std::vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (std::isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.emplace_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.emplace_back(Line(p, p + v2));\n    return ret;\n}\n\n// c1, c2 の共通接線\nstd::vector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    std::vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        std::vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.emplace_back(Line(q1, q1 + v));\n        ret.emplace_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\nusing Polygon = std::vector<Point>;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    for (int i = 0; i < n; i++)\n    {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(std::vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n// 凸包カット\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    for (int i = 0; i < n; i++)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.emplace_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.emplace_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(std::vector<Point> &ps, Point p)\n{\n    for (Point q : ps)\n        if (abs(q - p) < eps)\n            return;\n    ps.emplace_back(p);\n}\n\n// Voronoi 図: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3668810\n// polygon を ps でボロノイ分割する時の ps[index] に割り当てられる多角形\nPolygon voronoi(const Polygon &polygon, const std::vector<Point> &ps, int index)\n{\n    Polygon p = polygon;\n    int n = ps.size();\n    for (int j = 0; j < n; j++)\n    {\n        if (index == j)\n            continue;\n        Line l = bisector(ps[index], ps[j]);\n        p = convex_cut(p, l);\n    }\n    return p;\n}\n\nvoid solve_cgl_1_a()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_b()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << 2 * ret.real() - p.real() << \" \" << 2 * ret.imag() - p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_c()\n{\n    auto p0 = input_point(), p1 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p2 = input_point();\n        int ret = ccw(p0, p1, p2);\n        if (ret == 1)\n            cout << \"COUNTER_CLOCKWISE\" << endl;\n        else if (ret == -1)\n            cout << \"CLOCKWISE\" << endl;\n        else if (ret == 2)\n            cout << \"ONLINE_BACK\" << endl;\n        else if (ret == -2)\n            cout << \"ONLINE_FRONT\" << endl;\n        else\n            cout << \"ON_SEGMENT\" << endl;\n    }\n}\n\nvoid solve_cgl_2_a()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line l(p0, p1), m(p2, p3);\n        if (!isis_ll(l, m))\n        {\n            cout << 2 << endl;\n        }\n        else if (eq(dot(l.b - l.a, m.b - m.a), 0))\n        {\n            cout << 1 << endl;\n        }\n        else\n        {\n            cout << 0 << endl;\n        }\n    }\n}\n\nvoid solve_cgl_2_b()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << (isis_ss(s1, s2) ? 1 : 0) << endl;\n    }\n}\n\nvoid solve_cgl_2_c()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        auto ret = is_ll(s1, s2);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_2_d()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << fixed << setprecision(10) << dist_ss(s1, s2) << endl;\n    }\n}\n\nvoid solve_cgl_3_a()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    cout << fixed << setprecision(10) << area(p) << endl;\n}\n\nvoid solve_cgl_3_b()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    auto cv = convex_hull(p);\n    cout << (p == cv ? 1 : 0) << endl;\n}\n\nvoid solve_cgl_3_c()\n{\n    Polygon ps;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        int ret = is_in_polygon(ps, p);\n        cout << ret + 1 << endl;\n    }\n}\n\nvoid solve_cgl_4_a()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convex_hull(ps);\n    for (auto p : ret)\n    {\n        cout << fixed << setprecision(10) << p.real() << \" \" << p.imag() << endl;\n    }\n}\n\n// cgl_4_b: 凸多角形の直径\n\nvoid solve_cgl_4_c()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        auto l = Line(p0, p1);\n        auto ret = convex_cut(ps, l);\n        cout << fixed << setprecision(10) << area(ret) << endl;\n    }\n}\n\n// cgl_5_a: 最近点対\n\n// cgl_6_a: 線分交差\n\nvoid solve_cgl_7_a()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    cout << ls.size() << endl;\n}\n\nvoid solve_cgl_7_d()\n{\n    auto p = input_point();\n    ld r;\n    cin >> r;\n    Circle c(p, r);\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        Line l(p0, p1);\n        auto ret = is_lc(c, l);\n        assert(ret.size() <= 2);\n        sort(ret.begin(), ret.end());\n        cout << ret[0].real() << \" \" << ret[0].imag();\n        if (ret.size() == 2)\n        {\n            cout << \" \" << ret[1].real() << \" \" << ret[1].imag();\n        }\n        cout << endl;\n    }\n}\n\nvoid solve_cgl_7_e()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ret = is_cc(c0, c1);\n    if ((int)ret.size() == 1)\n        ret.push_back(ret[0]);\n    sort(ret.begin(), ret.end());\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_f()\n{\n    auto p = input_point();\n    auto p0 = input_point();\n    ld r0;\n    cin >> r0;\n    Circle c(p0, r0);\n    auto ls = tangent_cp(c, p);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_lc(c, l);\n        assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_g()\n{\n    ld r0, r1;\n    auto p0 = input_point();\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_sc(c0, l);\n        assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    for (auto p : ret)\n    {\n        cout << fixed << setprecision(10) << p.real() << \" \" << p.imag() << endl;\n    }\n}\n\n// cgl_7_h: 円と多角形の共通部分(は?)\n// 参考実装: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2114290\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    solve_cgl_2_b();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x=0, double y=0):x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a * x, a * y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y;}\n\tbool operator < (const Point &p) const {\n\t\t// first x, second y\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment{\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2){\n\t\tthis->p1 = p1;\n\t\tthis->p2 = p2;\n\t}\n};\n\ndouble dot(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\t//|a||b|cos(theta)\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Orthogonal\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1- b2);\n}\n\n// Orthogonal\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1- b2);\n}\n\n// ???p????????????s???????????????????????????\nPoint project(Segment s, Point p){\n\t// ??\\??????????????????\n\t// hypo -> p - p1, base -> p2 - p1\n\t// t = |hypo|cos??\n\t// cos?? = dot(hypo,base)/|hypo||base|\n\t// project = s.p1 + base/|base| * t\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(hypo, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\n// ???p????????????s???????§°?????¨?????????\nPoint reflection(Segment s, Point p){\n\tPoint pr = project(s, p);\n\treturn p + (pr - p) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// p0??????p1????????????????????????????????????p2?????????\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a,b) <-EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????????????????? ??????p1->p2, p3->p4\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n// ?????????????????????\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???????????¢\ndouble distance(Point a, Point b){\n\treturn (a - b).abs();\n}\n\n// ?????¨??´???????????¢\ndouble distanceLinePoint(Segment s, Point p){\n\t// sin?? = |cross(hypo, base)|/|hypo||base|\n\t// distance = |hypo|sin?? = |cross(hypo, base)|/|base|\n\tVector hypo = p - s.p1;\n\tVector base = s.p2 - s.p1;\n\treturn abs(cross(hypo, base)) / base.abs();\n}\n\n// ?????¨??????????????¢\ndouble distanceSegmentPoint(Segment s, Point p){\n\t// (p2-p1)??¨???p-p1??????90???????????§????????´??????p??¨p1????????¢\n\t// (p1-p2)??¨???p-p2??????90???????????§????????´??????p??¨p2????????¢\n\t// ????????\\????????´???????????¨??´???????????¢\n\tif(dot(s.p2-s.p1, p-s.p1) < 0.0) return (p - s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2) < 0.0) return (p - s.p2).abs();\n\treturn distanceLinePoint(s, p);\n}\n\n// ????????¨??????????????¢\n// TODO\n\nint Q;\n\nint main() {\n\n\tcin >> Q;\n\trep(i, Q){\n        Point p0, p1;\n        cin >> p0.x >> p0.y >> p1.x >> p1.y;\n        Point p2, p3;\n        cin >> p2.x >> p2.y >> p3.x >> p3.y;\n        cout << (intersect(p0, p1, p2, p3) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nbool eq(ld a, ld b){\n\treturn abs(a-b) < EPS;\n}\n\nstruct PT{\n\tld x, y;\n\tPT (ld x = 0, ld y = 0) : x(x), y(y) {}\n\tPT operator + (PT ro) const{\n\t\treturn PT(x+ro.x, y+ro.y);\n\t}\n\tPT operator - (PT ro) const{\n\t\treturn PT(x-ro.x, y-ro.y);\n\t}\n\tPT operator * (ld co) const{\n\t\treturn PT(x*co, y*co);\n\t}\n\tPT operator / (ld co) const{\n\t\treturn PT(x/co, y/co);\n\t}\n\tld operator * (PT ro) const{\n\t\treturn x*ro.x + y*ro.y;\n\t}\n\tld operator ^ (PT ro) const{\n\t\treturn x*ro.y - y*ro.x;\n\t}\n};\n\nistream& operator>> (istream &is, PT &p){\n\tld val;\n\tis >> val;\n\tp.x = val;\n\tis >> val;\n\tp.y = val;\n\treturn is;\n}\n\nPT operator * (ld co, PT p){\n\treturn p*co;\n}\n\nld len(PT a){\n\treturn sqrt(a*a);\n}\n\nPT unit(PT a){\n\treturn a/len(a);\n}\n\nPT clrot(PT a){\n\treturn PT(-a.y, a.x);\n}\n\nPT proj(PT a, PT b, PT c){\n\tb = b-a, c = c-a;\n\treturn a + (b*c)/(b*b)*b;\n}\n\nPT reflect(PT a, PT b, PT c){\n\tPT d = c;\n\tb = b-a, c = c-a;\n\treturn d + (c^b)/len(b)*clrot(unit(b))*2;\n}\n\nint sgn(PT a, PT b, PT c){\n\tld cr = (b-a)^(c-a);\n\treturn cr > EPS ? 1 : (cr + EPS < 0 ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = sgn(c, d, a),\n\t\tbs = sgn(c, d, b),\n\t\tcs = sgn(a, b, c),\n\t\tds = sgn(a, b, d);\n\tif (as && as == bs || cs && cs == ds)\n\t\treturn false;\n\telse if (as || bs || cs || ds)\n\t\treturn true;\n\tfor (int j = 0; j < 2; j++){\n\t\tld mx = min(a.x, b.x),\n\t\t   Mx = max(a.x, b.x),\n\t\t   my = min(a.y, b.y),\n\t\t   My = max(a.y, b.y);\n\t\tfor (int k = 0; k < 2; k++){\n\t\t\tif (c.x + EPS > mx && c.x < Mx + EPS && c.y + EPS > my && c.y < My + EPS)\n\t\t\t\treturn true;\n\t\t\tswap(c, d);\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor (int i = in(); i; i--){\n\t\tPT a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tcout << intersect(a, b, c, d) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing flt = double;\nconst flt eps = 1e-12, inf = 1e18, PI = acos(-1.0);\ntemplate<typename T>\ninline T sqr(T x) {return x * x;}\ninline flt cmp(flt a, flt b, flt e = eps) {\n  return fabs(a - b) >= e + fabs(a) * e ? a - b : 0;\n}\ninline int sgn(flt x, flt e = eps) {return x < -e ? -1 : (x > e);}\ninline flt fix(flt x, flt e = eps) {return cmp(x, 0, e);}\n\nstruct point {\n  flt x, y;\n  point(flt x = 0, flt y = 0): x(x), y(y) {}\n  bool operator < (const point &rhs) const {\n    return cmp(x, rhs.x) < 0 || (cmp(x, rhs.x) == 0 && cmp(y, rhs.y) < 0);\n  }\n  bool operator == (const point &rhs) const {\n    return cmp(x, rhs.x) == 0 && cmp(y, rhs.y) == 0;\n  }\n  point operator + (const point &rhs) const {\n    return point(x + rhs.x, y + rhs.y);\n  }\n  point operator - (const point &rhs) const {\n    return point(x - rhs.x, y - rhs.y);\n  }\n  point operator * (const flt k) const {\n    return point(x * k, y * k);\n  }\n  point operator / (const flt k) const {\n    return point(x / k, y / k);\n  }\n  point operator ~ () const {// counter clockwise rotate 90 degree\n    return point(-y, x);\n  }\n  flt dot(const point &rhs) const {\n    return x * rhs.x + y * rhs.y;\n  }\n  flt det(const point &rhs) const {\n    return x * rhs.y - y * rhs.x;\n  }\n  flt norm2() const {\n    return x * x + y * y;\n  }\n  flt norm() const {\n    return hypot(x, y);\n  }\n  point rot(flt a) const {// counter clockwise rotate A rad\n    return point(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));\n  }\n  point rot(flt cosa, flt sina) const {// counter clockwise rotate using cos/sin\n    return point(x * cosa - y * sina, x * sina + y * cosa);\n  }\n  point trunc(flt a = 1.0) const {\n    return (*this) * (a / this->norm());\n  }\n};\n\n// check if point O is on segment AB\nbool on_segment(const point &A, const point &B, const point &O) {\n  return sgn((A - O).det(B - O)) == 0 && sgn((A - O).dot(B - O)) <= 0;\n}\n\n// check if AB is parallel to CD\nbool is_parallel(const point &A, const point &B, const point &C, const point &D) {\n  return sgn((B - A).det(D - C)) == 0;\n}\n\n// check intersection of segments AB and CD\nbool segment_intersect(const point &A, const point &B, const point &C, const point &D, point &res) {\n  if (on_segment(A, B, C)) {res = C; return true;}\n  if (on_segment(A, B, D)) {res = D; return true;}\n  if (on_segment(C, D, A)) {res = A; return true;}\n  if (on_segment(C, D, B)) {res = B; return true;}\n  point AB(B - A), CD(D - C);\n  if (sgn(AB.det(CD)) == 0) return false; // parallel\n  int d1 = sgn(AB.det(C - A)) * sgn(AB.det(D - A));\n  int d2 = sgn(CD.det(A - C)) * sgn(CD.det(B - C));\n  res = A + AB * (CD.det(C - A) / CD.det(AB));\n  return d1 < 0 && d2 < 0;\n}\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; ++i) {\n    point A, B, C, D, O;\n    scanf(\"%lf%lf%lf%lf\", &A.x, &A.y, &B.x, &B.y);\n    scanf(\"%lf%lf%lf%lf\", &C.x, &C.y, &D.x, &D.y);\n    if (segment_intersect(A, B, C, D, O)) puts(\"1\");\n    else puts(\"0\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lb long double\n#define eps 1e-9\nusing namespace std;\nstruct Po{lb x,y;}p1,p2,q1,q2;\nint t;\nvoid get(Po &x){scanf(\"%Lf %Lf\",&x.x,&x.y);}\nPo operator -(Po x,Po y){return (Po){x.x-y.x,x.y-y.y};}\nlb operator *(Po x,Po y){return x.x*y.y-x.y*y.x;}\nbool onsegment(Po x,Po y,Po z){\n\tif (x.x>y.x) swap(x,y);\n\tif (z.x<x.x-eps||z.x>y.x+eps) return 0;\n\tif (x.y>y.y) swap(x,y);\n\tif (z.y<x.y-eps||z.y>y.y+eps) return 0;\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d\",&t);\n\twhile (t--){\n\t\tget(p1);get(p2);get(q1);get(q2);\n\t\tlb d1=(p2-p1)*(q1-p1),d2=(p2-p1)*(q2-p1),d3=(q2-q1)*(p1-q1),d4=(q2-q1)*(p2-q1);\n\t\tif (d1*d2<-eps&&d3*d4<eps){puts(\"1\");continue;}\n\t\tif (fabs(d1)<eps&&onsegment(p1,p2,q1)){puts(\"1\");continue;}\n\t\tif (fabs(d2)<eps&&onsegment(p1,p2,q2)){puts(\"1\");continue;}\n\t\tif (fabs(d3)<eps&&onsegment(q1,q2,p1)){puts(\"1\");continue;}\n\t\tif (fabs(d4)<eps&&onsegment(q1,q2,p2)){puts(\"1\");continue;}\n\t\tputs(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<min(x[3],x[4])||min(x[1],x[2])>max(x[3],x[4])||max(y[1],y[2])<min(y[3],y[4])||min(y[1],y[2])>max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<0&&p3*p4<0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\n/*class Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};*/\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´???\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶??????\ndouble abs(Point p){return sqrt(norm(p));}\n//??????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//??????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???±\nPoint projec(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°?\nPoint reflec(seg s,Point p){\n  return  p+(projec(s,p)-p)*2.0;\n}\n//2???????????¢\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//??´?????´????????¢(????°?)\ndouble getDistanceLL(seg a,seg b){\n  double p[4];\n  p[0]=getDistanceLP(a,b.p1);\n  p[1]=getDistanceLP(a,b.p2);\n  p[2]=getDistanceLP(b,a.p1);\n  p[3]=getDistanceLP(b,a.p2);\n  sort(p,p+4);\n  return p[0];\n}\nmain(){\n  int n;\n  seg a,b;\n  cin>>n;\n  while(n--){\n    cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    printf(\"%.11f\\n\",getDistanceLL(a,b));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nstring ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return \"COUNTER_CLOCKWISE\";\n  if(cross(d,e)<0) return \"CLOCKWISE\";\n  if(dot(d,e)<0) return \"ONLINE_BACK\";\n  if(abs(d) < abs(e)) return \"ONLINE_FRONT\";\n  return \"ON_SEGMENT\";\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*abs(d.y))/(abs(d.y)-abs(c.y));\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint q = 0;\n\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble p0x = 0, p0y = 0, p1x = 0, p1y = 0, p2x = 0, p2y = 0, p3x = 0, p3y = 0,\n\t\t\t   u = 0, s = 0, t = 0;\n\t\tint n = 0;\n\n\t\tcin >> p0x >> p0y >> p1x >> p1y >> p2x >> p2y >> p3x >> p3y;\n\n\t\tu = (p3y - p0y) * (p2x - p0x) - (p3x - p0x) * (p2y - p0y);\n\n\t\tif (u != 0) {\n\t\t\ts = ((p3y - p0y) * (p1x - p0x) - (p3x - p0x) * (p1y - p0y)) / u;\n\t\t\tt = -((p2y - p0y) * (p1x - p0x) - (p2x - p0x) * (p1y - p0y)) / u;\n\n\t\t\tif (s >= 0 && t >= 0) {\n\t\t\t\tif (s + t >= 1)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdouble t0 = (p2x - p0x) * (p3x - p0x) + (p2y - p0y) * (p3y - p0y),\n\t\t\t\tt1 = (p2x - p1x) * (p3x - p1x) + (p2y - p1y) * (p3y - p1y),\n\t\t\t\tt2 = (p0x - p2x) * (p1x - p2x) + (p0y - p2y) * (p1y - p2y);\n\n\t\t\tif ((p1y - p0y) * (p2x - p0x) - (p1x - p0x) * (p2y - p0y) != 0) {\n\t\t\t\tif (t0 <= 0)\n\t\t\t\t\tn = 1;\n\t\t\t}\n\t\t\telse if ( (t0 <= 0) || (t1 <= 0) || (t2 <= 0))\n\t\t\t\tn = 1;\n\t\t}\n\n\t\tcout << n << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if(a1*x3+b1*y3+c1==0){//一直線上にある.\n\n            \n            if(x1<=x3&&x3<=x2)return 1;\n            if(x1<=x4&&x4<=x2)return 1;\n            if(x3<=x1&&x1<=x4)return 1;\n            if(x3<=x2&&x2<=x4)return 1;\n            if(x2<=x3&&x3<=x1)return 1;\n            if(x2<=x4&&x4<=x1)return 1;\n            if(x4<=x1&&x1<=x3)return 1;\n            if(x4<=x2&&x2<=x3)return 1;\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long; using ld = long double; using ull = unsigned long long; using uint = unsigned int;\nusing vi  = vector<int>; using vb  = vector<bool>; using vd  = vector<double>; using vl  = vector<ll>;\nusing vvi = vector<vi>;  using vvb = vector<vb>;   using vvd = vector<vd>;     using vvl = vector<vl>;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define FOR(i,b,n) for(ll i=(b); i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TEN(x) ((ll)1e##x)\n\ntemplate<typename T> inline string join(const vector<T>& vec, string sep = \" \") { stringstream ss; REP(i, vec.size()) ss << vec[i] << ( i+1 == vec.size() ? \"\" : sep ); return ss.str(); }\n\n\n///////////////\n\n#define EPS (1e-10)\n#define NEXT(x, i) (x[(i + 1) % x.size()])\n\ntemplate<class T> using CR = const T &;\nusing P = complex<ld>;\nusing G = vector<P>;\n\nint sgn(ld a, ld b = 0) {\n\tif (a > b + EPS) return 1;\n\tif (a < b - EPS) return -1;\n\treturn 0;\n}\n\nld dot(P a, P b) { return real(conj(a)*b); }\nld cross(P a, P b) { return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (sgn(cross(b, c))) return sgn(cross(b, c)); // clockwise or counter clockwise\n\tif (sgn(dot(b, c)) == -1) return 2;            // c--a--b\n\tif (sgn(norm(b), norm(c)) == -1) return -2;    // a--b--c\n\treturn 0;                                      // a--c--b\n}\n\nstruct L : public vector<P> {\n    L(P a, P b) { push_back(a); push_back(b); }\n};\n\nbool iSS(CR<L> s, CR<L> t, bool strict = false) {\n\treturn (strict ? 0 : 1) > ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1])\n\t\t&& (strict ? 0 : 1) > ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]);\n}\n\n\n//////////////\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(30);\n\tll n; cin >> n;\n\twhile (n--) {\n\t\tld x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tcout << iSS(L{ p0, p1 }, L{ p2, p3 }) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n// 2次元ベクトルクラス\nclass Vector {\npublic:\n    float x, y;\n    \n    Vector() {\n        x = 0.0;\n        y = 0.0;\n    }\n    \n    Vector(float nx, float ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void set(float nx, float ny) {\n        x = nx;\n        y = ny;\n    }\n    \n    void setX(float nx) {\n        x = nx;\n    }\n    \n    void setY(float ny) {\n        y = ny;\n    }\n    \n    // 外積を求める\n    float cross(const Vector& vec) const {\n        return x * vec.y - y * vec.x;\n    }\n    \n    // ベクトルの大きさを求める\n    float norm() const {\n        return sqrt(x * x + y * y);\n    }\n    \n    // 単位ベクトルを返す\n    Vector getUnit() const {\n        Vector v;\n        float n = norm();\n        if (n == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / n, y / n);\n        }\n        return v;\n    }\n    \n    \n    void operator = (const Vector& vec) {\n        x = vec.x;\n        y = vec.y;\n    }\n    \n    Vector operator + (const Vector& vec) const {\n        Vector v(x + vec.x, y + vec.y);\n        return v;\n    }\n    \n    Vector operator - (const Vector& vec) const {\n        Vector v(x - vec.x, y - vec.y);\n        return v;\n    }\n    \n    Vector operator * (const Vector& vec) const {\n        Vector v(x * vec.x, y * vec.y);\n        return v;\n    }\n    \n    Vector operator * (float f) const {\n        Vector v(x * f, y * f);\n        return v;\n    }\n    \n    Vector operator / (const Vector& vec) const {\n        Vector v;\n        if (vec.x == 0.0) {\n            v.setX(0.0);\n        } else {\n            v.setX(x / vec.x);\n        }\n        \n        if (vec.y == 0.0) {\n            v.setY(0.0);\n        } else {\n            v.setY(y / vec.y);\n        }\n        return v;\n    }\n    \n    Vector operator / (float f) const {\n        Vector v;\n        if (f == 0.0) {\n            v.set(0.0, 0.0);\n        } else {\n            v.set(x / f, y / f);\n        }\n        return v;\n    }\n    \n    void operator += (const Vector& vec) {\n        x += vec.x;\n        y += vec.y;\n    }\n    \n    void operator -= (const Vector& vec) {\n        x -= vec.x;\n        y -= vec.y;\n    }\n    \n    void operator *= (const Vector& vec) {\n        x *= vec.x;\n        y *= vec.y;\n    }\n    \n    void operator /= (const Vector& vec) {\n        if (vec.x == 0.0) {\n            x = 0.0;\n        } else {\n            x /= vec.x;\n        }\n        \n        if (vec.y == 0.0) {\n            y = 0.0;\n        } else {\n            y /= vec.y;\n        }\n    }\n    \n    bool operator == (const Vector& vec) const {\n        if (x == vec.x && y == vec.y) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nclass LineSegment {\nprivate:\n    Vector start; // 始点\n    Vector end; // 終点\n    \npublic:\n    //コンストラクタ\n    LineSegment () {}\n    \n    // 始点と終点を設定する\n    void setStartEnd(float sx, float sy, float ex, float ey) {\n        start.set(sx, sy);\n        end.set(ex, ey);\n    }\n    \n    // 始点を取得する\n    Vector getStart() const {\n        return start;\n    }\n    \n    //　終点を取得する\n    Vector getEnd() const {\n        return end;\n    }\n    \n    // 指定の線分を含むか\n    // このメソッドは線分同士が平行の時しか使用しない\n    bool isInLine(const LineSegment& l) const {\n        bool b1 = isPointInLine(l.getStart());\n        bool b2 = isPointInLine(l.getEnd());\n        if (b1 || b2) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    bool isPointInLine(const Vector& p) const {\n        if (start == p) {\n            return true;\n        }\n        \n        Vector l1 = end - start;\n        Vector l2 = p - start;\n        Vector u1 = l1.getUnit();\n        Vector u2 = l2.getUnit();\n\n        if (u1 == u2 && l2.norm() <= l1.norm()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    // 指定の線分と交差しているか\n    // @return 0(交差していない), 1(交差している)\n    int isCross(const LineSegment& l) {\n        Vector l1 = end - start;\n        float c1 = l1.cross(l.getStart() - start);\n        float c2 = l1.cross(l.getEnd() - start);\n        \n        Vector l2 = l.getEnd() - l.getStart();\n        float c3 = l2.cross(start - l.getStart());\n        float c4 = l2.cross(end - l.getStart());\n        \n        if (c1 * c2 == 0.0 && c3 * c4 == 0.0) { // 平行のとき\n            LineSegment ls;\n            ls.setStartEnd(start.x, start.y, end.x, end.y);\n            if (isInLine(l) || l.isInLine(ls)) {\n                return 1;\n            }\n            return 0;\n        } else if ((c1 * c2 < 0.0 && c3 * c4 <= 0.0)\n                   || (c1 * c2 <= 0.0 && c3 * c4 < 0.0)\n                   || (c1 * c2 < 0.0 && c3 * c4 < 0.0)) { // 交差するとき\n            return 1;\n        } else { // 交差しないとき\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LineSegment l1, l2;\n    vector<int> result;\n    for (int i = 0; i < n; i++) {\n        float sx1, sy1, ex1, ey1, sx2, sy2, ex2, ey2;\n        cin >> sx1 >> sy1 >> ex1 >> ey1 >> sx2 >> sy2 >> ex2 >> ey2;\n        l1.setStartEnd(sx1, sy1, ex1, ey1);\n        l2.setStartEnd(sx2, sy2, ex2, ey2);\n        result.push_back(l1.isCross(l2));\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/19 ~ 2016/05/16\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orientation {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvの大きさの2乗を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t abs2(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(abs2(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    elem_t r = dot(hypo, base) / abs2(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief  絶対許容誤差(absolute tolerance)を比較します\n *\n * @note   2つの浮動小数点数値が等しいかどうか比較するためのイプシロン許容誤差の利用は、\n *         イプシロンの値が固定されているので、絶対許容誤差(absolute tolerance)と呼ばれている\n *         絶対許容誤差の欠点は適切なイプシロンの値を見つけるのが困難なことである\n *         イプシロンの値は入力データの値の範囲、および使用している浮動小数点の形式に依存する\n *         浮動小数点数の範囲全体に対するイプシロンの値を1つだけ選ぶことは不可能である\n *         xおよびyの値が非常に小さな(互いに等しくない)値の場合は、その差は常にイプシロンよりも小さくなる可能性があり、\n *         逆に大きな値の場合は、その差はイプシロンよりも常に大きくなるかもしれない. 別の見方として、\n *         判定している数が大きくなればなるほど、絶対値による判定が成立するために必要な桁数はどんどん大きくなっていく\n *\n * @note   固定されているイプシロンよりも数値が十分大きくなったとき、数値が正確に等しくない限り判定は常に失敗する\n *         これは通常、意図したことではない. 絶対許容誤差は数値の桁数の大きさが予めわかっており、\n *         許容誤差の値をそれに応じて設定することができる場合にのみ利用するべきである\n */\nstatic inline bool absolute_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps;\n}\n\n\n/**\n * @brief  相対許容誤差(relatice tolerance)を比較します\n *\n * @note   基本的な考え方はある数を別の数によって除算し、その結果がどのくらい1に近づいているかを見るというものである\n *\n *\n * @note   |x| <= |y|を仮定すると、判定は以下のようになる\n *           if (Abs(x/y - 1.0) <= epsilon)...\n *         これは以下のように書き直せる\n *           if (Abs((x - y) / y) <= epsilon)...\n *         コストのかかる除算を避け、ゼロによる除算のエラーから守るために、後者の式の両辺にAbs(y)を乗算して、以下のように単純化する\n *           if (Abs(x - y) <= epsilon * Abs(y))...\n *         仮定|x| <= |y|を取り除くと、式は最終的に以下のようになる\n *           if (Abs(x - y) <= epsilon * Max(Abs(x), Abs(y)))...  // 相対許容誤差の比較\n *\n *\n * @note   比較において相対的な判定は「より小さいか等しい」であり、「より小さい」ではないことは重要である\n *         もしそうでなければ、両方の数が正確にゼロだった場合、判定は失敗する。相対的な判定も問題がないわけではない\n *         判定の式はAbs(x)およびAbs(y)が1よりも大きいときには、望み通りの働きをするが、それらの数値が1よりも小さいときは、\n *         イプシロンはより小さくないと効力がなくなってしまい、それらの数値が小さくなるほど式を成立させるのに必要な桁数はより多く必要になる         \n */\nstatic inline bool relative_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max(std::fabs(x), std::fabs(y));\n}\n\n\n/**\n * @brief  上記2つの判定を1つに結合させる\n * @note   数値の絶対値が1よりも大きい場合には、相対的な判定を用い、1よりも小さい場合には、絶対的な判定を用いる\n * @attention  この式はMax()が機械語による命令によって利用できない場合には高価な計算になる可能性がある\n */\nstatic inline bool combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * std::max({ std::fabs(x), std::fabs(y), static_cast<elem_t>(1.0) });\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(elem_t x, elem_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(elem_t x, elem_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orientation cw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orientation::cw;    }  // クロス積(p1-p0)x(p2-p0)が正の場合、cw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orientation::ccw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、ccw ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orientation::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(abs2(p1), abs2(p2)))       { return orientation::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orientation::on;\n}\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\nelem_t direction(const point& pi, const point& pj, const point& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n/**\n * @brief  pkがpipj|の端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分pipj|と同一直線上にあると仮定する\n */\nbool on_segment(const point& pi, const point& pj, const point& pk)\n{\n    elem_t xi = pi.x, xj = pj.x, xk = pk.x;\n    elem_t yi = pi.y, yj = pj.y, yk = pk.y;\n    \n    return std::min(xi, xj) <= xk && xk <= std::max(xi, xj)\n        && std::min(yi, yj) <= yk && yk <= std::max(yi, yj);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分p1p2|がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分p1p2|と線分p3p4|が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point& p1, const point& p2,\n                       const point& p3, const point& p4)\n{\n    elem_t d1 = direction(p3, p4, p1);\n    elem_t d2 = direction(p3, p4, p2);\n    elem_t d3 = direction(p1, p2, p3);\n    elem_t d4 = direction(p1, p2, p4);\n\n    // 線分p1p2↑と線分p3p4↑が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // p1p2|がp3p4|を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // p3p4|がp1p2|を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (eq(d1, 0) && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (eq(d2, 0) && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (eq(d3, 0) && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (eq(d4, 0) && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        polygon_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double norm(const Point& a) { return a.px*a.px + a.py*a.py; }\nint ccw(Point p0, Point p1, Point p2) { Point a, b; a.px = p1.px - p0.px; a.py = p1.py - p0.py; b.px = p2.px - p0.px; b.py = p2.py - p0.py; if (crs(a, b) > 1e-10) return 1; if (crs(a, b) < -1e-10) return -1; if (dot(a, b) < -1e-10) return 2; if (norm(a) < norm(b)) return -2; return 0; }\nbool its(Point p1, Point p2, Point p3, Point p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nint main() { int N; Point A1, A2, A3, A4; cin >> N; for (int i = 0; i < N; i++) { cin >> A1.px >> A1.py >> A2.px >> A2.py >> A3.px >> A3.py >> A4.px >> A4.py; bool res = its(A1, A2, A3, A4); if (res == true) { cout << \"1\" << endl; } else { cout << \"0\" << endl; } } }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <string>\n#include <utility>\n#include <map>\n#include <queue>\n#include <list>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nconst int INF = 100000000;\nconst long long LINF = 1000000000000000000;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-6;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing pLL = std::pair<ll, ll>;\n#define SORT(v) std::sort(v.begin(), v.end())\n#define RSORT(v) std::sort(v.rbegin(), v.rend())\nusing Point = complex<double>;\n\n#define X real()\n#define Y imag()\ndouble dot(Point a, Point b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\nusing Line = pair<Point, Point>;\nPoint Projection(Line s, Point p) {\n    Point vase = s.second - s.first;\n    p -= s.first;\n    return s.first + dot(p, vase) / norm(vase) * vase;\n}\nPoint Reflection(Line s, Point p) {\n    return p + (Projection(s, p) - p) * 2.0;\n}\ndouble cross(Point a, Point b) {\n    return a.X * b.Y - a.Y * b.X;\n}\nint ccw(Point a, Point b, Point c) {\n    if (cross(b - a, c - a) > EPS)return 1;\n    if (cross(b - a, c - a) < -EPS)return -1;\n    if (dot(b - a, c - a) < -EPS)return 2;\n    if (abs(b - a) + EPS < abs(c - a))return -2;\n    return 0;\n}\nbool isOrthogonal(Line a, Line b) {\n    return dot(a.second - a.first, b.second - b.first) ? 0 : 1;\n}\nbool isParallel(Line a, Line b) {\n    return cross(a.second - a.first, b.second - b.first) ? 0 : 1;\n}\nbool isCross(Line a, Line b) {\n    if (ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second)<=0 and\n        ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second)<=0) {\n        return true;\n    }\n    return false;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Point p1, p2, p3, p4;\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        double x1, x2, y1, y2, x3, x4, y3, y4;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;\n        p1 = Point(x1, y1);\n        p2 = Point(x2, y2);\n        p3 = Point(x3, y3);\n        p4 = Point(x4, y4);\n        Line l1 = Line(p1, p2), l2 = Line(p3, p4);\n        if (isCross(l1, l2))cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<n;i++)\nusing namespace std;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\ntemplate<class T>\nbool equals(T a,T b){ return fabs((a)-(b)) < eps; }\n\nstruct Point{\n    double x, y;\n    Point(){}\n    Point(double x, double y) : x(x), y(y){}\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n    double norm() {return x*x+y*y;}\n    double abs() {return sqrt(norm());}\n\n    bool operator < (const Point &p) const {\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    bool operator == (const Point &p) const {\n        return fabs(x-p.x) < eps && fabs(y-p.y) < eps;\n    }\n};\n\nbool sort_x(Point a, Point b){ return !equals(a.x,b.x)?a.x<b.x:a.y<b.y; }\nbool sort_y(Point a, Point b){ return !equals(a.y,b.y)?a.y<b.y:a.x<b.x; }\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm(Vector a) { return a.x*a.x+a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y-a.y*b.x; }\n\nstruct Segment {\n    Point p1, p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c, double r) : c(c),r(r) {}\n};\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n    if(cross(a,b)< -eps) return CLOCKWISE;\n    if(dot(a,b)< -eps) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point  p3, Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s, Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a-b);\n}\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2-l.p1, p-l.p1))/abs(l.p2-l.p1);\n}\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\ndouble getDistanceSS(Segment s1, Segment s2){\n\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    ll q;cin>>q;\n    rep(Q,q){\n        double x0,y0,x1,y1,x2,y2,x3,y3;\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        Point p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n        if(intersect(p0,p1,p2,p3)) cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <complex>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;for(char c;c=gcu(),c!=' '&&c!='\\n';)s+=c;return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;if((c=gcu())=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n\t_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\nusing P = complex<double>;\n\nP read() {\n\tint x{in}, y {in};\n\treturn P(x, y);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a, a = b * conj(c);\n\treturn imag(a) > 0 ? 1 : imag(a) < 0 ? -1 : real(a) < 0 ? 2 : norm(b) < norm(c) ? -2 : 0;\n}\n\nbool intersection(P &p0, P &p1, P &p2, P &p3) {\n\treturn (ccw(p1, p0, p2) * ccw(p1, p0, p3) <= 0) && (ccw(p3, p2, p0) * ccw(p3, p2, p1) <= 0);\n}\nint main() {\n\ttimes(n, in) {\n\t\tP p0 {read()}, p1 {read()}, p2 {read()}, p3 {read()};\n\t\toutl(intersection(p0, p1, p2, p3));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tP p[4];\n\t\tdouble x,y;\n\t\trep(i,4){cin>>x>>y;p[i]=P(x,y);}\n\t\tP a=p[1]-p[0];\n\t\tP b=p[3]-p[2];\n\t\tif((cross(a,p[2]-p[0])*cross(a,p[3]-p[0])<EPS)&&(cross(b,p[1]-p[2])*cross(b,p[0]-p[2])<EPS))cout<<1<<endl;\n\t\telse cout<<0<<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ?????? a1, a2 ??¨?????? b1, b2 ???????????????\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\nint main() {\n    P a, b, c, d; \n    int q; cin >> q;\n    rep(i,0,q) {\n        cin >> a.X >> a.Y >> b.X >> b.Y >> c.X >> c.Y >> d.X >> d.Y;\n        if(isec_ss(a,b,c,d)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> \ninline void read(T& x)\n{\n\tchar c = getchar(); T p = 1, n = 0;\n\twhile(c < '0' || c > '9'){if(c == '-') p = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9'){n = n * 10 + c - '0'; c = getchar();}\n\tx = p * n;\n}\ntemplate<class T, class U>\ninline void read(T& x, U& y){read(x), read(y);}\ntemplate<class T, class U, class V>\ninline void read(T& x, U& y, V& z){read(x), read(y), read(z);}\nconst double eps = 1e-10;\nstruct Point\n{\n\tdouble x, y;\n\tPoint(int a, int b){x = a, y = b;}\n\tPoint(double a = .0, double b = .0){x = a, y = b;}\n\tPoint operator+(const Point& r){return Point(x + r.x, y + r.y);}\n\tPoint operator-(const Point& r){return Point(x - r.x, y - r.y);}\n\tPoint operator*(double r){return Point(x * r, y * r);}\n\tdouble operator*(const Point& r){return x * r.y - y * r.x;}\n};\ntypedef Point Vector;\ninline double dot(Vector l, Vector r){return l.x * r.x + l.y * r.y;}\ninline double norm(Vector l){return dot(l, l);}\ninline int ccw(Point x, Point y, Point z)\n{double cross = (y - x) * (z - x); return cross < -eps ? -1 : (cross > eps ? 1 : 0);}\nstruct Segment\n{\n\tPoint a, b;\n\tSegment(){}\n\tSegment(Point x, Point y){a = x, b = y;}\n};\ninline bool isIntersection(Segment l, Segment r)\n{return (ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0) && (ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0);}\nint main()\n{\n\tint q, x0, y0, x1, y1, x2, y2, x3, y3; read(q);\n\twhile(q--)\n\t{\n\t\tread(x0, y0), read(x1, y1), read(x2, y2), read(x3, y3);\n\t\tputs(isIntersection(Segment(Point(x0, y0), Point(x1, y1)), Segment(Point(x2, y2), Point(x3, y3))) ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   double x,y;\n   Point(){}\n   Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nPoint line_intersect(Line a,Line b)// 两直线交点\n{\n   double t=cross(b.v,a.p-b.p)/cross(a.v,b.v);\n   return a.p+a.v*t;\n}\ndouble x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   \t  Line l1=Line(Point(x[1],y[1]),Vector(x[2]-x[1],y[2]-y[1]));\n   \t  Line l2=Line(Point(x[3],y[3]),Vector(x[4]-x[3],y[4]-y[3]));\n\n   \t  double p=cross(l1.v,l2.v);  \n   \t  if(fabs(p)<1e-8)\n   \t  {\n   \t    double w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(fabs(w)<1e-8)\n   \t    {\n   \t    \tdouble ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tdouble e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tdouble eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tdouble eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<1e-8||e<1e-8||eee<1e-8||eeee<1e-8) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t Point j=line_intersect(l1,l2);\n      \t if(j.x<=max(x[1],x[2])&&j.x>=min(x[1],x[2])&&j.x>=min(x[3],x[4])&&j.x<=max(x[3],x[4]))\n      \t \tputs(\"1\");\n      \t else puts(\"0\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <iomanip>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\n#define NAN_M 0x800000000000\n#define EPS 0.0000000001\n\ntemplate<typename T>\nclass Vector2D {\npublic:\n    T x;\n    T y;\n\n    Vector2D() {\n        x = y = 0;\n    }\n\n    Vector2D(T x_, T y_) {\n        x = x_;\n        y = y_;\n    }\n\n    T operator*(const Vector2D<T> *e) {\n        return this->x * e->x + this->y * e->y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x - e->x, this->y - e->y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> *e) {\n        return Vector2D<T>(this->x + e->x, this->y + e->y);\n    }\n\n    T operator*(const Vector2D<T> e) {\n        return this->x * e.x + this->y * e.y;\n    }\n\n    Vector2D<T> operator-(const Vector2D<T> e) {\n        return Vector2D<T>(this->x - e.x, this->y - e.y);\n    }\n\n    Vector2D<T> operator+(const Vector2D<T> e) {\n        return Vector2D<T>(this->x + e.x, this->y + e.y);\n    }\n\n    Vector2D<T> operator*(const T r) {\n        return Vector2D<T>(this->x * r, this->y * r);\n    }\n\n    Vector2D<T> operator/(const T r) {\n        return Vector2D<T>(this->x / r, this->y / r);\n    }\n\n    double abs() {\n        return sqrt(x * x + y * y);\n    }\n\n    T abs2() {\n        return x * x + y * y;\n    }\n\n    T cross(Vector2D<T> e) {\n        if(x * e.y >= y * e.x) return (x * e.y) - (y * e.x);\n        else return (y * e.x) - (x * e.y);\n    }\n\n    double cos(Vector2D<T> e) {\n        if((e.abs() * abs()) == 0) return NAN_M;\n        return (e * (*this)) / (e.abs() * abs());\n    }\n\n    double sin(Vector2D<T> e) {\n        if((e.abs() * abs()) == 0) return NAN_M;\n//        cout << ((x * e.y) - (y * e.x)) / (e.abs() * abs()) << endl;\n        return ((x * e.y) - (y * e.x)) / (e.abs() * abs());\n    }\n};\n\ntypedef Vector2D<double> vdd;\n\ndouble dist__(double x0, double y0, double x1, double y1, double xx, double yy) {\n    int b = 0;\n    vdd p[3] = {vdd(x0, y0), vdd(x1, y1), vdd(xx, yy)};\n    if (((p[0] - p[1]) * (p[2] - p[1])) < 0) b = -1;\n    if (((p[1] - p[0]) * (p[2] - p[0])) < 0) b = 1;\n    if (b == 1) return (p[2] - p[0]).abs();\n    if (b == -1) return (p[2] - p[1]).abs();\n    return (p[1] - p[0]).cross(p[2] - p[0]) / (p[1] - p[0]).abs();\n}\n\ndouble dist(double x0, double y0, double x1, double y1, double xx, double yy){\n    double res = dist__(x0,y0,x1,y1,xx,yy);\n    return res;\n}\n\nint main() {\n    int q;\n    cin >> q;\n    loop(i, 0, q) {\n        vdd v[4];\n        for(auto& e:v) {\n            cin >> e.x >> e.y;\n        }\n        if ((v[0] - v[1]).sin(v[2] - v[1]) * (v[0] - v[1]).sin(v[3] - v[1]) <= 0 && (v[2] - v[3]).sin(v[0] - v[3]) * (v[2] - v[3]).sin(v[1] - v[3]) <= 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(b==c||a==d) return true;\n  if(ccw(a,b,c)==ccw(a,b,d)) return false;\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\n#define _ << \" \" <<\n#define all(X) (X).begin(), (X).end()\n#define len(X) (X).size()\n#define Pii pair<int, int>\n#define Pll pair<ll, ll>\n#define Tiii tuple<int, int, int>\n#define Tlll tuple<ll, ll, ll>\n\ndouble eps = 1e-8;\n\nstruct point /* vec */ {\n    double x, y;\n    point operator+(const point &p) {\n        return {x + p.x, y + p.y};\n    }\n    point operator-(const point &p) {\n        return {x - p.x, y - p.y};\n    }\n};\n\nstruct line {\n    // ax + by + c = 0\n    double a, b, c;\n};\n\nstruct circle {\n    point p;\n    double r;\n};\n\ndouble dot(point P, point Q) {\n    return P.x*Q.x + P.y*Q.y;\n}\n\ndouble cross_2d(point P, point Q) {\n    return P.x*Q.y - P.y*Q.x;\n}\n\ndouble points_distance(point A, point B, int deg) {\n    point C = B - A;\n    return pow(C.x*C.x + C.y*C.y, 0.5 * deg);\n}\n\nline line_2points(point P, point Q) {\n    return {P.y - Q.y, Q.x - P.x, P.x*Q.y - P.y*Q.x};\n}\n\npoint lines_intersection(line l, line m) {\n    if (abs(l.a*m.b - l.b*m.a) < eps) {\n        assert(-1);\n    }\n    return {- (l.b*m.c - l.c*m.b) / (l.b*m.a - l.a*m.b),\n            - (l.a*m.c - l.c*m.a) / (l.a*m.b - l.b*m.a)};\n}\n\nbool line_same(line l, line m) {\n    if (l.c * m.c == 0) {\n        if (l.c == m.c) {\n            if (l.b * m.b == 0) {\n                if (l.b == m.b) return 1;\n                else return 0;\n            }\n            else return l.a / l.b == m.a / m.b; \n        }\n        else return 0;\n    }\n    else return l.a / l.c == m.a / m.c && l.b / l.c == m.b / m.c;\n}\n\nbool on_line(point P, point Q, point R) {\n    if (P.x > Q.x) swap(P, Q);\n    if (P.y > Q.y) swap(P.y, Q.y);\n    return (P.x <= R.x && R.x <= Q.x && P.y <= R.y && R.y <= Q.y);\n}\n\ndouble point_line_distance(point P, line l) {\n    return abs(l.a * P.x + l.b * P.y + l.c) / sqrt(l.a*l.a + l.b*l.b);\n}\n\ndouble is_segments_intersect(point p1, point p2, point q1, point q2) {\n    line s0 = line_2points(p1, p2);\n    line s1 = line_2points(q1, q2);\n    if (abs(s0.a*s1.b - s0.b*s1.a) < eps) {\n        if (p1.x > p2.x) swap(p1, p2);\n        if (p1.y > p2.y) swap(p1.y, p2.y);\n        if (q1.x > q2.x) swap(q1, q2);\n        if (q1.y > q2.y) swap(q1.y, q2.y);\n        if (line_same(s0, s1)) {\n            return (q1.x <= p2.x && p1.x <= q2.x && q1.y <= p2.y && p1.y <= q2.y);\n        }\n        else return 0;\n    }\n    return cross_2d(p2 - p1, q1 - p1) * cross_2d(p2 - p1, q2 - p1) < eps\n        && cross_2d(q2 - q1, p1 - q1) * cross_2d(q2 - q1, p2 - q1) < eps;\n}\n\nvector<point> circles_intersection(circle A, circle B) {\n    vector<point> ret;\n    point X = A.p;\n    B.p = B.p - A.p;\n    A.p = {0, 0};\n\n    if (points_distance(A.p, B.p, 2) - pow(A.r + B.r, 2) > eps) return ret;\n\n    double K = (B.p.x*B.p.x + B.p.y*B.p.y + A.r*A.r - B.r*B.r) / 2;\n    double SQ = (B.p.x*B.p.x + B.p.y*B.p.y)*A.r*A.r - K * K;\n    double DS = points_distance(A.p, B.p, 2);\n    //cerr << K _ SQ _ DS << endl;\n    if (abs(SQ) < eps) {\n        ret.push_back({K*B.p.x / DS + X.x, K*B.p.y / DS + X.y});\n        return ret;\n    }\n    ret.push_back({(K*B.p.x + B.p.y*sqrt(SQ)) / DS + X.x,\n                   (K*B.p.y - B.p.x*sqrt(SQ)) / DS + X.y});\n    ret.push_back({(K*B.p.x - B.p.y*sqrt(SQ)) / DS + X.x,\n                   (K*B.p.y + B.p.x*sqrt(SQ)) / DS + X.y});\n    return ret;\n}\n \nint main() {\n    //cout << fixed << setprecision(10);\n    int q;\n    cin >> q;\n    while (q--) {\n        point p[4];\n        for (int i = 0; i < 4; i++) {\n            cin >> p[i].x >> p[i].y;\n        }\n        cout << is_segments_intersect(p[0], p[1], p[2], p[3]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int q;\n    double x1,y1,x2,y2,x3,y3,x4,y4,x,y,a1,b1,c1,a2,b2,c2;\n    cin>>q;\n    while(q--)\n    {\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        a1=y2-y1;\n        b1=-(x2-x1);\n        c1=-((a1*x1)+(b1*y1));\n        a2=y4-y3;\n        b2=-(x4-x3);\n        c2=-((a2*x3)+(b2*y3));\n        if(b1==0 && b2==0 || a1==0 && a2==0)\n        {\n            if(c1!=c2)\n            {\n                cout<<\"0\"<<endl;\n            }\n\n            else if((x3>=min(x1,x2) && x3<=max(x1,x2) && y3>=min(y1,y2) && y3<=max(y1,y2))|| (x4>=min(x1,x2) && x4<=max(x1,x2) && y4>=min(y1,y2) && y4<=max(y1,y2))||(x1>=min(x3,x4) && x1<=max(x3,x4) && y1>=min(y3,y4) && y1<=max(y3,y4))||(x2>=min(x3,x4) && x2<=max(x3,x4) && y2>=min(y3,y4) && y2<=max(y3,y4)))\n            {\n                cout<<\"1\"<<endl;\n            }\n            else\n            {\n                cout<<\"0\"<<endl;\n            }\n\n        }\n        else if(b1==0 && a2==0)\n        {\n            x=x2;\n            y=y4;\n            if(x>=min(x1,x2) && x<=max(x1,x2) && y>=min(y1,y2) && y<=max(y1,y2) && x>=min(x3,x4) && x<=max(x3,x4) && y>=min(y3,y4) && y<=max(y3,y4))\n            {\n                cout<<\"1\"<<endl;\n            }\n            else\n            {\n                cout<<\"0\"<<endl;\n            }\n        }\n        else if(b2==0 && a1==0)\n        {\n            x=x4;\n            y=y2;\n            if(x>=min(x1,x2) && x<=max(x1,x2) && y>=min(y1,y2) && y<=max(y1,y2) && x>=min(x3,x4) && x<=max(x3,x4) && y>=min(y3,y4) && y<=max(y3,y4))\n            {\n                cout<<\"1\"<<endl;\n            }\n            else\n            {\n                cout<<\"0\"<<endl;\n            }\n\n        }\n        else if(a1/-b1 ==a2/-b2)\n        {\n             if(c1!=c2)\n            {\n                cout<<\"0\"<<endl;\n            }\n\n            else if((x3>=min(x1,x2) && x3<=max(x1,x2) && y3>=min(y1,y2) && y3<=max(y1,y2))|| (x4>=min(x1,x2) && x4<=max(x1,x2) && y4>=min(y1,y2) && y4<=max(y1,y2))||(x1>=min(x3,x4) && x1<=max(x3,x4) && y1>=min(y3,y4) && y1<=max(y3,y4))||(x2>=min(x3,x4) && x2<=max(x3,x4) && y2>=min(y3,y4) && y2<=max(y3,y4)))\n            {\n                cout<<\"1\"<<endl;\n            }\n            else\n            {\n                cout<<\"0\"<<endl;\n            }\n        }\n        else\n        {\n\n            x=((b1*c2)-(b2*c1))/((a1*b2)-(a2*b1));\n            y=((a2*c1)-(a1*c2))/((a1*b2)-(a2*b1));\n            if(x>=min(x1,x2) && x<=max(x1,x2) && y>=min(y1,y2) && y<=max(y1,y2) && x>=min(x3,x4) && x<=max(x3,x4) && y>=min(y3,y4) && y<=max(y3,y4))\n            {\n                cout<<\"1\"<<endl;\n            }\n            else\n            {\n                cout<<\"0\"<<endl;\n            }\n        }\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\n// #include \"./競プロ用テンプレート/Geometry.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nint d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\n// #define EPS (1e-10)\n// #define equals(a,b) (fabs(a,b) < EPS)\n\n// class Point{\n// public:\n//   double x,y;\n\n//   Point(double x = 0,double y = 0): x(x),y(y) {}\n\n//   Point operator + (const Point &p){ return Point(x+p.x , y+p.y); }\n//   Point operator - (const Point &p){ return Point(x-p.x , y-p.y); }\n//   Point operator * (double a){ return Point(x * a , y * a); }\n//   Point operator / (double a){ return Point(x / a , y / a); }\n\n//   double abs(){ return sqrt(norm()); }\n//   double norm(){ return x * x + y * y; }\n\n//   bool operator < (const Point &p) const{ return (x != p.x) ? x < p.x : y < p.y; }\n//   bool operator == (const Point &p) const{ return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS); }\n//   friend istream& operator >> (istream &is,Point &p){ return (is >> p.x >> p.y); }\n//   friend ostream& operator << (ostream &os,Point &p){ return (os << p.x << \" \" << p.y); }\n// };\n\n// class Circle{\n// public:\n//   Point c;\n//   double r;\n//   Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n//   friend istream& operator >> (istream &is,Circle c){return (is >> c.c >> c.r);}\n//   friend ostream& operator << (ostream &os,Circle c){return (os << c.c << \" \" << c.r);}\n// };\n\n// typedef Point Vector;\n\n// double norm(Point p){\n//   return p.x * p.x + p.y * p.y;\n// }\n\n// double abs(Point p){\n//   return sqrt(norm(p));\n// }\n\n// using namespace Geometry;\n\nnamespace Geometry{\n  #define EPS (1e-10)\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(10) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(10) << (X) << \" \" << (Y) << endl\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return (fabs(x - p.x) < EPS) && (fabs(y - p.y) < EPS); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double getDistance(Vector a,Vector b){ return abs(a - b); }\n  double getDistanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  Polygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0;i--){\n      for(int n = l.size();n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--)l.push_back(u[i]);\n    return l;\n  }\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\n/*\nPoint is OK.\nSegment is OK.\nCircle is OK.\n\nOrthogonal is OK.\nParallex is OK.\nReflect is OK.\nCCW is OK.\n\n*/\n\nint main(){\n  Segment a,b;\n  cin >> n;\n  rep(i,0,n){\n    cin >> a >> b;\n    print(intersect(a,b));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> xy;\nconst double eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nxy projection(xy p,xy b) {return b*dot_product(p,b)/norm(b);}\nxy projection2(xy p1,xy p2,xy p){\n    p -= p1; p2 -= p1;\n    xy proj = projection(p,p2);\n    return p1+proj;\n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<eps;\n}\n\nint Q;\ndouble X[5],Y[5];\nint main(){\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        for(int j=1;j<=4;j++){\n            cin >> X[j] >> Y[j];\n        }\n        cout << (is_intersected(xy(X[1],Y[1]),xy(X[2],Y[2]),xy(X[3],Y[3]),xy(X[4],Y[4]))? 1:0) << endl;       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x), add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x), add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot (P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det (P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print (){\n\t\tcout << x << \" \" << y <<endl;\n\t\treturn;\n\t}\n};\n\nint intersectionCheck(P &p0, P &p1, P &p2, P &p3){\n\tP q0 = p1-p0;\n\tP q1 = p3-p2;\n\tif(q0.det(q1)==0){\n\t\tif((p1-p0).det(p2-p0)==0){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP r = p0 + (p1-p0)*(q1.det(p2-p0)/q1.det(q0));\n\tif ((p0-r).dot(p1-r) <=0 && (p2-r).dot(p3-r) <=0){\n\t\treturn 1;\n\t} else{\n\t\treturn 0;\n\t}\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\n\tREP(i, q){\n\t\tP p0, p1, p2, p3;\n\t\tcin >> p0.x >> p0.y >>p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y ;\n\t\tcout << intersectionCheck(p0, p1, p2, p3) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    return d < 0? -1 : 1;\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x=0, double y=0): x(x), y(y){\n    }\n};\n\ntypedef Vector Point;\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\nbool intersectProp(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double c1 = cross(a2 - a1, b1 - a1);\n    double c2 = cross(a2 - a1, b2 - a1);\n    double c3 = cross(b2 - b1, a1 - b1);\n    double c4 = cross(b2 - b1, a2 - b1);\n    \n    return dcmp(c1 * c2) == -1 && dcmp(c3 * c4) == -1;\n}\n\nbool onSegment(const Point& a, const Point& b, const Point& p) {\n    Vector pa = a - p;\n    Vector pb = b - p;\n    return dcmp(cross(pa, pb)) == 0 && dcmp(dot(pa, pb)) <= 0;\n}\n\nbool intersect(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    return intersectProp(a1, a2, b1, b2) || onSegment(a1, a2, b1) \n            || onSegment(a1, a2, b2) || onSegment(b1, b2, a1) || onSegment(b1, b2, a2);\n}\n\nint main() {\n    Point points[4];\n    int q;\n    cin >> q;\n    for (int kase = 0; kase < q; kase++) {\n        for (int i = 0; i < 4; i++) {\n            cin >> points[i].x >> points[i].y;\n        }\n        Vector v1 = points[1] - points[0];\n        Vector v2 = points[3] - points[2];\n\n        int ans =  intersect(points[0], points[1], points[2], points[3])? 1 : 0;\n        \n        cout << ans << endl;\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n#define ll long long\n#define inf  999999999\n#define pa pair<int,int>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a) {return Point(x*a,y*a);}\n\tPoint operator / (double a) {return Point(x/a,y/a);}\n\tdouble absv() {return sqrt(norm());}\n\tdouble norm() {return x*x+y*y;}\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x<p.x: y<p.y;\n\t}\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//----------------kokomade temple------------\n\n\nint main(){\nint n;\ncin>>n;\ndouble a1,a2,a3,a4,a5,a6,a7,a8;\nPoint p0,p1,p2,p3;\nVector v01,v31,v02,v03,v23,v21,v20;\nfor(int i=0;i<n;i++){\ncin>>a1>>a2>>a3>>a4>>a5>>a6>>a7>>a8;\np0.x=a1,p0.y=a2;\n//cout<<a2<<endl;\np1.x=a3,p1.y=a4;\np2.x=a5,p2.y=a6;\np3.x=a7,p3.y=a8;\nv01=p0-p1;\nv02=p0-p2;\nv03=p0-p3;\nv23=p2-p3;\nv21=p2-p1;\nv20=p2-p0;\nv31=p3-p1;\n//cout<<p0.y<<endl;\nif(fabs(cross(v01,v02))<EPS && fabs(cross(v01,v03))<EPS){\nif(dot(v03,v02)<=EPS|| dot(v21,v31)<=EPS) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n//cout<<v03.x<<\" \"<<v03.y<<\" \"<<p0.y<<\" \"<<p2.y<<endl;\n}\nelse if(cross(v01,v02)*cross(v01,v03)<=0 && cross(v23,v21)*cross(v23,v20)<=0) cout<<\"1\"<<endl;\nelse cout<<\"0\"<<endl;\n\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps (1e-10)\nusing namespace std;\nclass Point\n{\n\tpublic:\n\tdouble x,y;\n\tPoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y);} \n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){return Point(a*x,a*y);} \n\tPoint operator / (double a){return Point(x/a,y/a);}\n\tdouble norm(){return x*x+y*y;}\n\tdouble ABS(){return sqrt(norm());} //俩点间的距离 \n};\nstruct Segment\n{\n\tPoint p1,p2;\t\n};\n\ndouble dot(Point a,Point b)//求内积 就是向量a*b \n{\n\treturn a.x*b.x+a.y*b.y;\n}\n//外积的值为a与b向量构成的平行四边形面积的值 \ndouble cross(Point a,Point b)//求外积 \n{\n\treturn a.x*b.y-a.y*b.x;\n} \n\n\n//判断是否正交 向量内积：a*b=|a||b|*cos(Y) 当cos为0时正交(90,-90垂直) \n//a*b=a.x*b.x+a.y*b.y;\nbool solve1(Point a,Point b)//是否正交 \n{\n\tdouble f=a.x*b.x+a.y*b.y; \n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n//判断是否平行  向量外积：|a*b|=|a||b|sin(Y) 当sin为0时平行(180,0平行)\n//|a*b|=|a|*|b|*sin(Y) \nbool solve2(Point a,Point b)//是否平行 \n{\n\tdouble f=a.x*b.y-a.y*b.x;\n\tif(fabs(f-0.0)<eps) return true;\n\telse return false;\n}\n\n/*\n求垂足x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线引一条垂线\nbase=p2-p1;\nhypo=p-p1;\n x=s.p1+base*(hypo*base/|base|^2); hypo*base 可以用向量内积求 \n*/\nPoint solve3(Segment s,Point p)//求投影点 \n{\n\tPoint base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/base.norm();\n\treturn s.p1+base*r; \n}\n/*\n求投影点x：对于给定的三点p1,p2,p从点p向通过p1,p2的直线为对称轴与点p\n成线对称点为x \n通过求solve3的垂足延长一倍就可以求x \n*/\nPoint solve4(Segment s,Point p)//求映象 \n{\n\treturn p+(solve3(s,p)-p)*2.0;\n}\n\n/*\n点a与点b之间的距离等于向量a-b或b-a的绝对值。 \n*/ \ndouble getdis(Point a,Point b)//求俩点间的距离                    \n{\n\treturn (a-b).ABS();\n} \n\n/*\n设直线p1 p2上的向量为a=p2-p1,p与p1构成的向量b=p-p1\n则点p与直线p1p2的距离d就等于a,b构成的平行四边形的高\n用a与b外积的大小(平行四边形的面积)除以a的大小|a|即可求出高d\nd=|a*b|/|a|=|(p2-p1)*(p-p1)|/|p2-p1|; \n*/\n//注意：这里Segmet s是不规范的应该是 Line s 才对 \ndouble getdis_Li(Segment s,Point p)//点与直线的距离 \n{\n\treturn abs(cross(s.p2-s.p1,p-s.p1)/(s.p2-s.p1).ABS());\n}\n/*\nPoint a=p1-p0;\nPoint b=p2-p0;\n1.外积大小cross(a,b)为正时,可确定b在a的逆时针方向\n\tsin(Y)（Y在0-180）所以是正数\n2. 外积大小cross(a,b)为负时,可确定b在a的顺时针方向\n3.（1,2）不符合 表示p2在直线p0p1上(注意是直线),cos(Y)大于90或小于-90\n\t度时为负，因此a与b的内积dot(a,b)负时，可确定p2位于线段p0p1后方\n\t即p2->p0->p1\n4.不是3时，有俩种p0->p1-p2或者p0->p2->p1如果b的大小大于a的大小，即为\n\tp0->p1->p2;\n5.不符合4，可以确定p2位于线段p0p1上 \n*/ \nint ccw(Point p0,Point p1,Point p2)//判断三个点相对位置 \n{\n\tPoint a=p1-p0;\n\tPoint b=p2-p0;\n\tif(cross(a,b)>eps) return 1;//p0,p1,p2成逆时针方向 \n\tif(cross(a,b)<-eps) return -1;//p0,p1,p2成顺时针方向 \n\t//if(dot(a,b)<-eps) return 2;//p2 p0 p1一次排列在同一直线上 \n\t//if(a.norm()<b.norm()) return -2;// p0 p1 p2一次排列在同一直线上 \n\treturn 0;//p2在线段p0p1上 \n\t\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nint main()\n{\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tif(intersect(p0,p1,p2,p3)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 線分を扱います\n * @date  2016/03/20\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t  = long double;\nusing point_t = std::complex<elem_t>;\nusing vec2_t  = point_t;\nusing geom_t  = std::vector<point_t>;\n\n\n\nnamespace limits {\n    const auto pi  = std::acos(-1.0);\n    const auto eps = 1e-10;\n    const auto inf = 1e12;\n}\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const point_t& a ベクトルa\n * @param  const point_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic inline elem_t det(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::imag(b) - std::imag(a) * std::real(b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const point_t& a  ベクトルa\n * @param  const point_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic inline elem_t cross(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::imag(b) - std::imag(a) * std::real(b);\n    // return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const point_t& a  ベクトルa\n * @param  const point_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic inline elem_t dot(const point_t& a, const point_t& b)\n{\n    return std::real(a) * std::real(b) + std::imag(a) * std::imag(b);\n}\n\n\n/**\n * @brief  3点(pi, pj, pk)を引数に取り、クロス積(pk - pi) x (pj - pi)を返す\n * @note   direction > epsのとき、cw(clockwise)...ただし、定義によってはccw\n *         direction < -epsのとき、ccw(counterclockwise)...ただし、定義によってはcw\n *         それ以外のとき、0であり、境界条件が発生する. このとき、ベクトルは同一直線上(colinear)にあり、\n *         それらの方向は同じか互いに逆である     \n */\nstatic inline elem_t direction(const point_t& pi, const point_t& pj, const point_t& pk)\n{\n    return cross(pk - pi, pj - pi);\n}\n\n\n\n/**\n * @brief  絶対許容誤差(absolute tolerance)を比較します\n *\n * @note   2つの浮動小数点数値が等しいかどうか比較するためのイプシロン許容誤差の利用は、\n *         イプシロンの値が固定されているので、絶対許容誤差(absolute tolerance)と呼ばれている\n *         絶対許容誤差の欠点は適切なイプシロンの値を見つけるのが困難なことである\n *         イプシロンの値は入力データの値の範囲、および使用している浮動小数点の形式に依存する\n *         浮動小数点数の範囲全体に対するイプシロンの値を1つだけ選ぶことは不可能である\n *         xおよびyの値が非常に小さな(互いに等しくない)値の場合は、その差は常にイプシロンよりも小さくなる可能性があり、\n *         逆に大きな値の場合は、その差はイプシロンよりも常に大きくなるかもしれない. 別の見方として、\n *         判定している数が大きくなればなるほど、絶対値による判定が成立するために必要な桁数はどんどん大きくなっていく\n *\n * @note   固定されているイプシロンよりも数値が十分大きくなったとき、数値が正確に等しくない限り判定は常に失敗する\n *         これは通常、意図したことではない. 絶対許容誤差は数値の桁数の大きさが予めわかっており、\n *         許容誤差の値をそれに応じて設定することができる場合にのみ利用するべきである\n */\nstatic inline bool absolute_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps;\n}\n\n\n/**\n * @brief  相対許容誤差(relatice tolerance)を比較します\n *\n * @note   基本的な考え方はある数を別の数によって除算し、その結果がどのくらい1に近づいているかを見るというものである\n *\n *\n * @note   |x| <= |y|を仮定すると、判定は以下のようになる\n *           if (Abs(x/y - 1.0) <= epsilon)...\n *         これは以下のように書き直せる\n *           if (Abs((x - y) / y) <= epsilon)...\n *         コストのかかる除算を避け、ゼロによる除算のエラーから守るために、後者の式の両辺にAbs(y)を乗算して、以下のように単純化する\n *           if (Abs(x - y) <= epsilon * Abs(y))...\n *         仮定|x| <= |y|を取り除くと、式は最終的に以下のようになる\n *           if (Abs(x - y) <= epsilon * Max(Abs(x), Abs(y)))...  // 相対許容誤差の比較\n *\n *\n * @note   比較において相対的な判定は「より小さいか等しい」であり、「より小さい」ではないことは重要である\n *         もしそうでなければ、両方の数が正確にゼロだった場合、判定は失敗する。相対的な判定も問題がないわけではない\n *         判定の式はAbs(x)およびAbs(y)が1よりも大きいときには、望み通りの働きをするが、それらの数値が1よりも小さいときは、\n *         イプシロンはより小さくないと効力がなくなってしまい、それらの数値が小さくなるほど式を成立させるのに必要な桁数はより多く必要になる         \n */\nstatic inline bool relative_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * std::max(std::fabs(x), std::fabs(y));\n}\n\n\n/**\n * @brief  上記2つの判定を1つに結合させる\n * @note   数値の絶対値が1よりも大きい場合には、相対的な判定を用い、1よりも小さい場合には、絶対的な判定を用いる\n * @attention  この式はMax()が機械語による命令によって利用できない場合には高価な計算になる可能性がある\n */\nstatic inline bool combined_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * std::max({ std::fabs(x), std::fabs(y), static_cast<elem_t>(1.0) });\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(elem_t x, elem_t y)\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n\n/**\n * @brief  pkが|pipjの端点の間にあるか否かを判定する\n *\n * @note   この手続きは、pkが線分|pipjと同一直線上にあると仮定する\n */\nbool on_segment(const point_t& pi, const point_t& pj, const point_t& pk)\n{\n    elem_t xi = pi.real(), xj = pj.real(), xk = pk.real();\n    elem_t yi = pi.imag(), yj = pj.imag(), yk = pk.imag();\n    \n    return std::min(xi, xj) <= xk && xk <= std::max(xi, xj)\n        && std::min(yi, yj) <= yk && yk <= std::max(yi, yj);\n}\n\n\n/**\n * @brief  2本の線分の交差判定\n *\n * @note   2本の線分の交差性を判定するために、各線分が他方を含む直線を跨ぐか否か調べる\n *         線分|p1p2がある直線を跨ぐ(straddle)のは、点p1がこの直線の一方の側にあり、\n *         点p2が他方の側にあるときである. 境界となるのは、p1かp2が直線上にある場合である\n *         2本の線分が交差するための必要十分条件は次の条件の一方(あるいは両方)が成り立つときである\n *\n *           1. どちらの線分も他方を含む直線を跨ぐ\n *           2. 一方の線分の端点が線分上にある(この条件は境界上にある場合から発生する)\n *\n * @note   このアイデアを次の手続きで実現する. SEGMENT-INTERSECTは、線分|p1p2と線分|p3p4が交差するときに\n *         TRUEを返し、そうでないときはFALSEを返す. この手続きは、サブルーチンDIRECTIONを呼び出して\n *         クロス積法を用いて相対的な方向を求め、ON-SEGMENTを呼び出して、線分を含む直線上にあることが分かっている点が\n *         この線分上にあるかどうかを判定する\n */\nbool segment_intersect(const point_t& p1, const point_t& p2,\n                       const point_t& p3, const point_t& p4)\n{\n    elem_t d1 = direction(p3, p4, p1);\n    elem_t d2 = direction(p3, p4, p2);\n    elem_t d3 = direction(p1, p2, p3);\n    elem_t d4 = direction(p1, p2, p4);\n\n    // 線分↑p1p2と線分↑p3p4が互いに他方の直線を跨ぐ場合\n    if (   ((d1 > limits::eps && d2 < -limits::eps) || (d1 < -limits::eps && d2 > limits::eps))\n        && ((d3 > limits::eps && d4 < -limits::eps) || (d3 < -limits::eps && d4 > limits::eps)))  {\n        // |p1p2が|p3p4を含む直線を跨ぐから、クロス積(p1-p3)x(p2-p1)と(p4-p2)x(p2-p3)の符号は異なる\n        // |p3p4が|p1p2を含む直線を跨ぐから、クロス積(p3-p1)x(p2-p1)と(p4-p1)x(p2-p1)の符号は異なる\n        return true;\n    }\n\n    // そうではないとき、これらの線分が互いに他方を跨ぐことはないが、端点が他方の線分上にある余地は残る\n    // どの相対的な方向も0でなければこの可能性は消える\n\n    // ある相対的方向dkが0のときには、pkは他方の線分と同一直線上にある\n    // pkがこの線分上にあるための必要十分条件は、これがこの線分の端点の間にあることである\n\n    // ON-SEGMENT呼び出しにおいて、この線分は、第一引数を端点とする線分と異なる方の線分である\n\n    else if (approximate_combined_tolerance_compare(d1, 0)\n        && on_segment(p3, p4, p1)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d2, 0)\n        && on_segment(p3, p4, p2)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d3, 0)\n        && on_segment(p1, p2, p3)) {\n        return true;\n    }\n\n    else if (approximate_combined_tolerance_compare(d4, 0)\n        && on_segment(p1, p2, p4)) {\n        return true;\n    }\n\n    else {\n        return false;  // 0判定はすべて失敗し、FALSEを返す\n    }\n}\n\n\nint main()\n{\n    using namespace std;\n    \n    int q;\n    cin >> q;\n\n    const int points_num = 4;\n    while (q) {\n        geom_t p(points_num);\n        int x, y;\n        for (int i = 0; i < points_num; i++) {\n            cin >> x >> y;\n            p[i] = point_t(x, y);\n        }\n        cout << segment_intersect(p[0], p[1], p[2], p[3]) << endl;\n        q--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\n\n\nnamespace Geometory {\n    const double EPS = 1e-10;\n\n    inline bool equals(double a, double b) {\n        return fabs(a - b) < EPS;\n    }\n\n    struct Point {\n        double x, y;\n\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n        Point operator+(const Point &p) {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator-(const Point &p) {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator*(const double k) {\n            return Point(x * k, y * k);\n        }\n\n        double norm() const {\n            return x * x + y * y;\n        }\n\n        double abs() const {\n            return sqrt(norm());\n        }\n\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n\n        bool operator<(const Point &p) const {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator==(const Point &p) const {\n            return equals(x, p.x) && equals(y, p.y);\n//            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n\n\n    };\n\n    using Vector = Point;\n\n    struct Segment {\n        Point p1, p2;\n\n        Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n        Segment(double x1, double y1, double x2, double y2) : p1(x1, y1), p2(x2, y2) {}\n    };\n\n    using Line = Segment;\n\n\n    double norm(Vector p) {\n        return p.x * p.x + p.y * p.y;\n    }\n\n    double abs(Vector a) {\n        return sqrt(norm(a));\n    }\n\n    double dot(Vector a, Vector b) {\n        return a.dot(b);\n    }\n\n    double cross(Vector a, Vector b) {\n        return a.cross(b);\n    }\n\n    //直行判定\n    bool is_orthogonal(Vector a, Vector b) {\n        return equals(dot(a, b), 0.0);\n    }\n\n    bool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n        return is_orthogonal(a1 - a2, b1 - b2);\n    }\n\n    bool is_orthogonal(Segment s1, Segment s2) {\n        return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //平行判定\n    bool is_parallel(Vector a, Vector b) {\n        return equals(cross(a, b), 0.0);\n    }\n\n    bool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n        return is_parallel(a1 - a2, b1 - b2);\n    }\n\n    bool is_parallel(Segment s1, Segment s2) {\n        return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //反時計回り\n    static const int CCW = 1; // Counter Clockwise\n    static const int CW = -1; // Clockwise\n    static const int OB = 2; // Online Back\n    static const int OF = -2; // Online Front\n    static const int OS = 0; // On Segment\n\n    // p0を中心としたとき、p2は{反時計回り、時計回り、p2->p0->p1で同一直線上、p0->p1->p2で直線上、p2がp0p1線分上} (後ろの3つの説明は雑)\n    int ccw(Point p0, Point p1, Point p2) {\n        Vector a = p1 - p0;\n        Vector b = p2 - p0;\n        if (cross(a, b) > EPS) return CCW;\n        if (cross(a, b) < -EPS) return CW;\n        if (dot(a, b) < -EPS) return OB;\n        if (a.norm() < b.norm()) return OF;\n\n        return OS;\n    }\n\n    //交差判定\n    bool is_intersect(Point p1, Point p2, Point p3, Point p4) {\n        return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n               ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n    }\n\n    //交差判定\n    bool is_intersect(Segment s1, Segment s2) {\n        return is_intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n    }\n\n    //射影を求める\n    //pからsに垂直に線を引いたときの座標を返す\n    Point project(Segment s, Point p) {\n        Vector base = s.p2 - s.p1;\n        double r = dot(p - s.p1, base) / norm(base);\n        return s.p1 + base * r;\n    }\n\n    // 反射\n    // pを線分sを対称軸として線対称の位置にある点を求める。\n    Point reflect(Segment s, Point p) {\n//        return p + (project(s, p) - p) * 2;\n        return project(s, p) * 2 - p;\n    }\n\n\n    //距離シリーズ\n    //2点間の距離\n    double get_distance(Point a, Point b) {\n        return abs(a - b);\n    }\n\n    // 直線lと点pの距離\n    double get_distanceLP(Line l, Point p) {\n        return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n    }\n\n    // 線分sと点pの距離\n    double get_distanceSP(Segment s, Point p) {\n        if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n        if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n        return get_distanceLP(s, p);\n    }\n\n    //線分と線分の距離\n    double get_distance(Segment s1, Segment s2) {\n        if (is_intersect(s1, s2)) return 0.0;\n        return min({get_distanceSP(s1, s2.p1),\n                    get_distanceSP(s1, s2.p2),\n                    get_distanceSP(s2, s1.p1),\n                    get_distanceSP(s2, s1.p2),\n                   });\n    }\n\n\n    struct Circle {\n        Point c;\n        double r;\n\n        Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n    };\n\n    using Polygon = vector<Point>;\n\n    std::ostream &operator<<(std::ostream &os, const Point &p) {\n//        os << \"(\" << p.x << \", \" << p.y << \")\";\n        os << \"\" << p.x << \" \" << p.y << \"\";\n        return os;\n    }\n\n};\n\nusing namespace Geometory;\n\n\nclass Solve {\npublic:\n    void solve() {\n        Int q;\n        cin >> q;\n        while (q--) {\n            vector<Point> p(4);\n            for (int i = 0; i < 4; ++i) {\n                cin >> p[i].x >> p[i].y;\n            }\n            Segment s1(p[0], p[1]), s2(p[2], p[3]);\n            cout << is_intersect(s1, s2) << endl;\n        }\n\n\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return make_pair(q,r);\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nstruct Vector {\n    f64 x, y;\n\n    Vector() : Vector(0.0,0.0) {}\n    Vector(f64 xx, f64 yy) : x(xx), y(yy) {}\n\n    Vector& operator+=(const Vector& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n    Vector& operator-=(const Vector& rhs) {\n        x -= rhs.x;\n        y -= rhs.y;\n        return *this;\n    }\n    Vector& operator*=(f64 rhs) {\n        x *= rhs;\n        y *= rhs;\n        return *this;\n    }\n    Vector& operator/=(f64 rhs) {\n        x /= rhs;\n        y /= rhs;\n        return *this;\n    }\n\n    f64 norm() const { return x*x + y*y; }\n    f64 abs() const { return sqrt(norm()); }\n};\n\nconst Vector operator+(const Vector& lhs, const Vector& rhs) { return Vector(lhs) += rhs; }\nconst Vector operator-(const Vector& lhs, const Vector& rhs) { return Vector(lhs) -= rhs; }\nconst Vector operator*(const Vector& lhs, f64 rhs) { return Vector(lhs) *= rhs; }\nconst Vector operator*(f64 lhs, const Vector& rhs) { return Vector(rhs) *= lhs; }\nconst Vector operator/(const Vector& lhs, f64 rhs) { return Vector(lhs) /= rhs; }\n\nbool operator==(const Vector& lhs, const Vector& rhs) {\n    return feq(lhs.x,rhs.x) && feq(lhs.y,rhs.y);\n}\n\nstruct Line {\n    Vector p1, p2;\n\n    Line(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Line(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n\n    Vector vec() const { return p2 - p1; }\n};\n\nf64 geo_dot(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.x + lhs.y*rhs.y;\n}\n\nf64 geo_cross(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.y - lhs.y*rhs.x;\n}\n\nVector geo_project(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    f64 r = geo_dot(p-line.p1, v) / v.norm();\n    return line.p1 + r*v;\n}\n\nenum ABC {\n    ABC_CCW        =  1,\n    ABC_CW         = -1,\n    ABC_ON_BACK    =  2,\n    ABC_ON_FRONT   = -2,\n    ABC_ON_SEGMENT =  0,\n};\n\nABC geo_abc(const Vector& a, const Vector& b, const Vector& c) {\n    Vector x = b - a;\n    Vector y = c - a;\n    f64 cross = geo_cross(x,y);\n    if(cross > 0) return ABC_CCW;\n    if(cross < 0) return ABC_CW;\n    f64 dot = geo_dot(x,y);\n    if(dot < 0) return ABC_ON_BACK;\n    if(x.norm() < y.norm()) return ABC_ON_FRONT;\n    return ABC_ON_SEGMENT;\n}\n\nvoid RD(Vector& v) {\n    RD(v.x);\n    RD(v.y);\n}\n\nbool geo_intersect(const Vector& p1, const Vector& p2, const Vector& p3, const Vector& p4) {\n    return geo_abc(p1,p2,p3) * geo_abc(p1,p2,p4) <= 0 &&\n           geo_abc(p3,p4,p1) * geo_abc(p3,p4,p2) <= 0;\n}\n\nvoid solve() {\n    i64 Q; RD(Q);\n    REP(_, Q) {\n        Vector p0; RD(p0);\n        Vector p1; RD(p1);\n        Vector p2; RD(p2);\n        Vector p3; RD(p3);\n        bool ans = geo_intersect(p0,p1,p2,p3);\n        PRINTLN(ans ? 1 : 0);\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n// ------ Defines ------ //\n#define Point complex<long double>\n#define px real()\n#define py imag()\n// ------ Classes ------ //\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tLine(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Line& s1, const Line& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Line& s1, const Line& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-8) return 1;\n\tif (crs(a, b) < -1e-8) return -1;\n\tif (dot(a, b) < -1e-8) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn ((ccw(p1, p2, p3) * ccw(p1, p2, p4)) <= 0 && (ccw(p3, p4, p1) * ccw(p3, p4, p2)) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ------ Main ------ //\nint q, xp1, yp1, xp2, yp2, xq1, yq1, xq2, yq2;\nint main() {\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d\", &xp1, &yp1, &xp2, &yp2, &xq1, &yq1, &xq2, &yq2);\n\t\tprintf(\"%d\\n\", (its(Segment(xp1, yp1, xp2, yp2), Segment(xq1, yq1, xq2, yq2)) ? 1 : 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> \ninline void read(T& x)\n{\n\tchar c = getchar(); T p = 1, n = 0;\n\twhile(c < '0' || c > '9'){if(c == '-') p = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9'){n = n * 10 + c - '0'; c = getchar();}\n\tx = p * n;\n}\ntemplate<class T, class U>\ninline void read(T& x, U& y){read(x), read(y);}\ntemplate<class T, class U, class V>\ninline void read(T& x, U& y, V& z){read(x), read(y), read(z);}\nconst double eps = 1e-10;\nstruct Point\n{\n\tdouble x, y;\n\tPoint(int a, int b){x = a, y = b;}\n\tPoint(double a = .0, double b = .0){x = a, y = b;}\n\tPoint operator+(const Point& r){return Point(x + r.x, y + r.y);}\n\tPoint operator-(const Point& r){return Point(x - r.x, y - r.y);}\n\tPoint operator*(double r){return Point(x * r, y * r);}\n\tdouble operator*(const Point& r){return x * r.y - y * r.x;}\n};\ntypedef Point Vector;\ninline double dot(Vector l, Vector r){return l.x * r.x + l.y * r.y;}\ninline double norm(Vector l){return dot(l, l);}\ninline int ccw(Point x, Point y, Point z)\n{double cross = (y - x) * (z - x); return cross < 0 ? -1 : (cross > 0 ? 1 : 0);}\nstruct Segment\n{\n\tPoint a, b;\n\tSegment(){}\n\tSegment(Point x, Point y){a = x, b = y;}\n};\ninline bool isIntersection(Segment l, Segment r)\n{return (ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0) && (ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0);}\nint main()\n{\n\tint q, x0, y0, x1, y1, x2, y2, x3, y3; read(q);\n\twhile(q--)\n\t{\n\t\tread(x0, y0), read(x1, y1), read(x2, y2), read(x3, y3);\n\t\tputs(isIntersection(Segment(Point(x0, y0), Point(x1, y1)), Segment(Point(x2, y2), Point(x3, y3))) ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(n) for(int i=0;i<n;i++)\n\n\nint main(void){\n\n\tint q; cin >> q;\n\trep(q){\n\t\tdouble xp0, yp0, xp1, yp1; cin>>xp0>>yp0>>xp1>>yp1;\n\t\tdouble xp2, yp2, xp3, yp3; cin>>xp2>>yp2>>xp3>>yp3;\n\t\tdouble t0 = (xp2-xp3)*(yp0-yp2) - (yp2-yp3)*(xp0-xp2);\n\t\tdouble t1 = (xp2-xp3)*(yp1-yp2) - (yp2-yp3)*(xp1-xp2);\n\t\tdouble t2 = (xp0-xp1)*(yp2-yp0) - (yp0-yp1)*(xp2-xp0);\n\t\tdouble t3 = (xp0-xp1)*(yp3-yp0) - (yp0-yp1)*(xp3-xp0);\n\t\tint ret = 0;\n\t\tif(t0*t1 <= 0 && t2*t3 <= 0) ret = 1;\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point Gep){\n\t\treturn point{x+Gep.x,y+Gep.y};\n\t}\n\tpoint operator-(point Gep){\n\t\treturn point{x-Gep.x,y-Gep.y};\n\t}\n\tpoint operator*(double Gex){\n\t\treturn point{x*Gex,y*Gex};\n\t}\n\tpoint operator/(double Gex){\n\t\tif(!Gex) return point{0,0}; \n\t\treturn point{x/Gex,y/Gex};\n\t}\n\tbool operator==(point Gep){\n\t\treturn fabs(x-Gep.x)<eps&&fabs(y-Gep.y)<eps;\n\t}\n};\n\nclass Geom{\n\tprivate:\n\tvector<point> Ge;\n\tvector<pair<point,point> > Geseg,Geline;\n\tpublic:\n\tvoid line_push(point Gex,point Gey){\n\t\tGeline.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid seg_push(point Gex,point Gey){\n\t\tGeseg.push_back(make_pair(Gex,Gey));\n\t}\n\tvoid point_push(point Gex){\n\t\tGe.push_back(Gex);\n\t}\n\tpoint DIP(pair<point,point> Gex,pdd Gey){\n\t\tdouble Gea=Gey.first,Geb=Gey.second;\n\t\tpoint Ge1=Gex.first,Ge2=Gex.second;\n\t\treturn (Ge1*Geb+Ge2*Gea)/(Gea+Geb);\n\t}\n\tpoint POI(pair<point,point>Gex,pair<point,point> Gey){\n\t\tpair<point,point> Ge1(PRO(Gex,Gey.first),PRO(Gex,Gey.second));\n\t\tpdd Ger(EXTLEN(Gey.first,Ge1.first),EXTLEN(Gey.second,Ge1.second));\n\t\treturn DIP(Ge1,Ger);\n\t}\n\tdouble IP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.x+Gex.y*Gey.y;\n\t}\n\tdouble CP(point Gex,point Gey){\n\t\treturn Gex.x*Gey.y-Gey.x*Gex.y;\n\t}\n\tdouble LEN(point Gex){\n\t\treturn sqrt(Gex.x*Gex.x+Gex.y*Gex.y);\n\t}\n\tdouble EXTLEN(point Gex,point Gey){\n\t\treturn LEN(Gex-Gey);\n\t}\n\tpoint PRO(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=Gex-Gea.second,Ge2=Gea.first-Gea.second;\n\t\treturn Ge2*(IP(Ge1,Ge2)/(LEN(Ge2)*LEN(Ge2)))+Gea.second;\n\t}\n\tpoint REF(pair<point,point> Gea,point Gex){\n\t\tpoint Ge1=PRO(Gea,Gex);\n\t\treturn Ge1*2-Gex;\n\t}\n\tint PJUD(point Gea,point Geb,point Gex){\n\t\tif(Gea==Geb||Gex==Geb) return 0;\n\t\tpoint Ge1=Gea-Gex,Ge2=Geb-Gex;\n\t\tdouble Getmp=CP(Ge1,Ge2);\n\t\tif(Getmp>0) return 1;\n\t\tif(Getmp<0) return 2;\n\t\tif(IP(Ge1,Ge2)<0) return 3;\n\t\tif(LEN(Ge1)<LEN(Ge2)) return 4;\n\t\treturn 5;\n\t}\n\tint SJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Getmp=POI(Gex,Gey);\n\t\tint Ge1=PJUD(Gex.first,Getmp,Gex.second),Ge2=PJUD(Gey.first,Getmp,Gey.second);\n\t\tif((!Ge1||Ge1==5)&&(!Ge2||Ge2==5)) return 1;\n\t\treturn 0;\n\t}\n\tint LJUD(pair<point,point> Gex,pair<point,point> Gey){\n\t\tpoint Ge1=Gex.first-Gex.second,Ge2=Gey.first-Gey.second;\n\t\tif(!CP(Ge1,Ge2)) return 2;\n\t\tif(!IP(Ge1,Ge2)) return 1;\n\t\treturn 0;\n\t}\n\tpair<point,point> line_open(int Gex){\n\t\treturn Geline[Gex];\n\t}\n\tpoint point_open(int Gex){\n\t\treturn Ge[Gex];\n\t}\n\tpair<point,point> seg_open(int Gex){\n\t\treturn Geseg[Gex];\n\t}\n};\n\nint q;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tGeom geo;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tgeo.seg_push(point{a,b},point{c,d});\n\t\t}\n\t\tcout<<geo.SJUD(geo.seg_open(0),geo.seg_open(1))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-9;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n  double x;\n  double y;\n\n  Point(double x = 0.0, double y = 0.0) {\n    this->x = x;\n    this->y = y;\n  }\n\n  Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n  Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n  Point operator*(double a) { return Point(a * x, a * y); }\n\n  Point operator/(double a) { return Point(x / a, y / a); }\n\n  double norm() { return x * x + y * y; }\n\n  double abs() { return sqrt(norm()); }\n\n  bool operator<(const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\nstruct Segment {\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\ndouble dot(const Vector &a, const Vector &b) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Vector &a, const Vector &b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nclass Circle {\npublic:\n  Point c;\n  double r;\n\n  Circle(Point c = Point(), double r = 0.0) {\n    this->c = c;\n    this->r = r;\n  }\n};\n\ntypedef vector <Point> Polygon;\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n  return (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return fabs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\n  return getDistanceLP(s, p);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min(\n    min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n    min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n  );\n}\n\nint main() {\n  int Q;\n  cin >> Q;\n\n  int x0, x1, x2, x3;\n  int y0, y1, y2, y3;\n\n  for (int i = 0; i < Q; ++i) {\n    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n    Point p1(x0, y0);\n    Point p2(x1, y1);\n    Point p3(x2, y2);\n    Point p4(x3, y3);\n\n    if (intersect(p1, p2, p3, p4)) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; };\n\n\tbool operator < (const Point& p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator ==(const Point& p)const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\ntypedef Segment  Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn fabs(cross(l.p2 - l.p1, p - l.p1)/abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\t//if (intersect(s1, s2))return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm()<b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s2.p2, s2.p1, s2.p2);\n}\n\n\nint main() {\n\tint q,x1,y1,x2,y2,x3,y3,x0,y0;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x0>>y0>>x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\n\t\tif (intersect(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3))) {\n\t\t\tcout << \"1\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"0\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0.0, double y = 0.0) :\n\t\t\tx(x), y(y) {\n\t}\n\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(double k) {\n\t\treturn Point(x * k, y * k);\n\t}\n\tPoint operator /(double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator <(Point p) {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(Point p) {\n\t\treturn equals(x, p.x) && equals(y, p.y);\n\t}\n};\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :\n\t\t\tp1(p1), p2(p2) {\n\t}\n};\ntypedef Segment Line;\n\ndouble dot(Vector v1, Vector v2) {\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\ndouble cross(Vector v1, Vector v2) {\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\nbool isOrthogonal(Vector v1, Vector v2) {\n\treturn equals(dot(v1, v2), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isOrthogonal(Point l1, Point l2, Point m1, Point m2) {\n\treturn isOrthogonal(l2 - l1, m2 - m1);\n}\nbool isParallel(Vector v1, Vector v2) {\n\treturn equals(cross(v1, v2), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Point l1, Point l2, Point m1, Point m2) {\n\treturn isParallel(l1 - l2, m1 - m2);\n}\n\ndouble distancePP(Point p1, Point p2) {\n\treturn (p1 - p2).abs();\n}\ndouble distanceLP(Line l, Point p) {\n\treturn cross(l.p2 - l.p1, p - l.p1) / dot(l.p2, l.p1);\n}\ndouble distanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t\treturn distancePP(s.p1, p);\n\telse if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t\treturn distancePP(s.p2, p);\n\telse\n\t\treturn distanceLP(s, p);\n}\n//double distanceSS(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2))\n//\t\treturn 0.0;\n//\telse {\n//\t\treturn min(\n//\t\t\t\t{ distanceSP(s1, s2.p1), distanceSP(s1, s2.p2), distanceSP(s2,\n//\t\t\t\t\t\ts1.p1), distanceSP(s2, s1.p2) });\n//\t}\n//}\n\nenum PositionSP {\n\tCOUNTER_CLOCKWISE = -1,\n\tCLOCKWISE = 1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nPositionSP ccw(Point p1, Point p2, Point p) {\n\tVector a = p2 - p1, b = p - p1;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\telse if (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\telse if (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\telse if (a.norm() < b.norm())\n\t\treturn ONLINE_FRONT;\n\telse\n\t\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tSegment s1, s2;\n\t\tcin >> s1.p1.x >> s1.p1.y;\n\t\tcin >> s1.p2.x >> s1.p2.y;\n\t\tcin >> s2.p1.x >> s2.p1.y;\n\t\tcin >> s2.p2.x >> s2.p2.y;\n\t\tcout << intersect(s1, s2) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = -1;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = 1;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\nint main(){\n    int n;\n    Point p1,p2,p3,p4;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&p1.x,&p1.y,&p2.x,&p2.y,&p3.x,&p3.y,&p4.x,&p4.y);\n        if(intersect(p1,p2,p3,p4)) printf(\"1\\n\");\n        else printf(\"0\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\ntypedef long double D;\nconst D PI = acos(-1.0);\nconst D EPS = 1e-10;\nclass P { public:\n  D x, y;\n  P(D x=0, D y=0) : x(x), y(y) {}\n\n  P& operator+=(const P& o) { x += o.x; y += o.y; return *this; }\n  P& operator-=(const P& o) { x -= o.x; y -= o.y; return *this; }\n  P& operator*=(const P& o) { return *this = {x*o.x - y*o.y, x*o.y + y*o.x}; }\n  P& operator*=(const D& r) { x *= r; y *= r; return *this; }\n  P& operator/=(const D& r) { x /= r; y /= r; return *this; }\n  P operator-() const { return {-x, -y}; }\n\n  D norm() const { return x*x + y*y; }\n  D abs() const { return sqrt(norm()); }\n  D arg() const { return atan2(y, x); }\n  bool isZero() const { return std::abs(x) < EPS && std::abs(y) < EPS; }\n  /** 象限 */\n  int orth() const { return y >= 0 ? (x >= 0 ? 1 : 2) : (x < 0 ? 3 : 4); }\n  static P polar(const D& rho, const D& theta = 0) { return {rho * cos(theta), rho * sin(theta)}; }\n};\nstd::ostream &operator<<(std::ostream &os, P const &p) { return os << \"(\" << p.x << \", \" << p.y << \")\"; }\nstd::istream &operator>>(std::istream &is, P &p) { D a, b; is >> a >> b; p = P(a, b); return is; }\nP operator+(const P& p, const P& q) { return P(p) += q; }\nP operator-(const P& p, const P& q) { return P(p) -= q; }\nP operator*(const P& p, const P& q) { return P(p) *= q; }\nP operator*(const P& p, const D& r) { return P(p) *= r; }\nP operator/(const P& p, const D& r) { return P(p) /= r; }\nP operator*(const D& r, const P& p) { return P(p) *= r; }\nP operator/(const D& r, const P& p) { return P(p) /= r; }\nD crs(const P& a, const P& b){ return a.x*b.y - a.y*b.x; }\nD dot(const P& a, const P& b){ return a.x*b.x + a.y*b.y; }\nint signum(D x) {return x > EPS ? +1 : x < -EPS ? -1 : 0;}\n// 辞書順ソート\nbool operator<(const P& a, const P& b) {\n  if (a.x != b.x) return a.x < b.x;\n  return a.y < b.y;\n}\n// // 偏角ソート\n// bool operator<(const P& a, const P& b) {\n//   // atan2を使う方法。誤差に注意\n//   // return a.arg() < b.arg();\n\n//   // cosを使う方法。(0,0)の扱いに注意\n//   if (a.isZero() != b.isZero()) return a.isZero() > b.isZero();\n//   if (a.orth() != b.orth()) return a.orth() < b.orth();\n//   return crs(a, b) > 0;\n// }\n/** ベクトルpをベクトルbに射影したベクトル */\nP proj(const P& p, const P& b) {\n  P t = b * dot(p, b);\n  return t / b.norm();\n}\n/** 点pから直線abに引いた垂線の足となる点 */\nP footOfLP(const P& a, const P& b, const P& p) {\n  return a + proj(p-a, b-a);\n}\n/** 直線abを挟んで点pと対称な点 */\nP reflection(const P&a, const P&b, const P& p) {\n  return 2 * footOfLP(a, b, p) - p;\n}\nint ccw(const P& a, P b, P c) {\n  // return signum(crs(b - a, c - a));\n  b -= a; c -= a;\n  if (crs(b, c) > 0)       return +1;       // counter clockwise\n  if (crs(b, c) < 0)       return -1;       // clockwise\n  if (dot(b, c) < 0)       return +2;       // c--a--b on line\n  if (b.norm() < c.norm()) return -2;       // a--b--c on line\n  return 0;\n}\n/** 2直線の直行判定 : a⊥b <=> dot(a, b) = 0 */\nbool isOrthogonal(const P& a1, const P& a2, const P& b1, const P& b2) {\n  return abs(dot(a1-a2, b1-b2)) < EPS;\n}\n/** 2直線の平行判定 : a//b <=> crs(a, b) = 0 */\nbool isParallel(const P& a1, const P& a2, const P& b1, const P& b2) {\n  return abs(crs(a1-a2, b1-b2)) < EPS;\n}\n/** 点cが線分ab上にあるか : |a-c| + |c-b| <= |a-b| なら線分上 */\nbool isIntersectSP(const P& a, const P& b, const P& c){\n  return ((a-c).abs() + (c-b).abs() < (a-b).abs() + EPS);\n}\n/** 直線aと直線bの交差判定 */\nbool isIntersectLL(const P& a, const P& b, const P& c, const P& d){\n  return abs(crs(b-a, d-c)) > EPS || // non-parallel\n         abs(crs(b-a, c-a)) < EPS;   // same line\n}\n/** 直線abと線分cdの交差判定 */\nbool isIntersectLS(const P& a, const P& b, const P& c, const P& d){\n  return crs(b-a, c-a) *      //c is left of ab\n         crs(b-a, d-a) < EPS; //d is right of ab\n}\n/** 線分と線分の交差判定。端点が重なってもtrue */\nbool isIntersectSS(const P& a1, const P& a2, const P& b1, const P& b2){\n  return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n         ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n\n\nint main2() {\n  int N; cin >> N;\n  P p[4];\n  REP(i, N) {\n    REP(j, 4) cin >> p[j];\n    if (isIntersectSS(p[0], p[1], p[2], p[3])) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ON_SEGMENT = 0;\nstatic const int ONLINE_FRONT = 2;\nstatic const int ONLINE_BACK = -2;\nconst double EPS = 1e-10;\n\nbool equals(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double k) {\n\t\treturn Point(k * x, k * y);\n\t}\n\tPoint operator / (double k) {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {};\n\n\tPoint project(Point p) {\n\t\tVector a = Vector(p.x - p1.x, p.y - p1.y);\n\t\tVector b = Vector(p2.x - p1.x, p2.y - p1.y);\n\t\treturn p1 + p2 * (dot(a, b) / b.norm());\n\t}\n\n\tPoint refrect(Point p) {\n\t\tPoint pro = project(p);\n\t\treturn pro * 2 - p;\n\t}\n};\n\nint check(Vector v0, Vector v1) {\n\tdouble c = cross(v0, v1);\n\tif (equals(c, 0)) {\n\t\tif (dot(v0, v1) < 0) return ONLINE_BACK;\n\t\telse if (v1.norm() > v0.norm()) return ONLINE_FRONT;\n\t\telse return ON_SEGMENT;\n\t} else if (c > 0) {\n\t\treturn COUNTER_CLOCKWISE;\n\t} else {\n\t\treturn CLOCKWISE;\n\t}\n}\n\nint intersect(Segment s1, Segment s2) {\n\tPoint p1 = s1.p1, p2 = s1.p2, p3 = s2.p1, p4 = s2.p2;\n\tVector v0 = Vector((p2 - p1).x, (p2 - p1).y);\n\tVector v1 = Vector((p3 - p1).x, (p3 - p1).y);\n\tVector v2 = Vector((p4 - p1).x, (p4 - p1).y);\n\tVector v3 = Vector((p4 - p3).x, (p4 - p3).y);\n\tVector v4 = Vector((p1 - p3).x, (p1 - p3).y);\n\tVector v5 = Vector((p2 - p3).x, (p2 - p3).y);\n\tif (check(v0, v1) * check(v0, v2) <= 0 && check(v3, v4) * check(v3, v5) <= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\tint x0, y0, x1, y1, x2, y2, x3, y3;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tSegment s1 = Segment(Point(x0, y0), Point(x1, y1));\n\t\tSegment s2 = Segment(Point(x2, y2), Point(x3, y3));\n\t\tcout << intersect(s1, s2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reint register int\n#define coint const int\n#define codb const double\n\nusing namespace std;\n\ncodb EPS = 1e-8;\n\nstruct Vector {\n    double x, y;\n\n    inline Vector operator+(const Vector &v) const {\n        return (Vector){ x + v.x, y + v.y };\n    }\n\n    inline double dot(const Vector &v) const { return x * v.x + y * v.y; }\n    inline double cross(const Vector &v) const { return x * v.y - y * v.x; }\n    inline double length(void) const { return sqrt(x * x + y * y); }\n    inline double square(void) const { return x * x + y * y; }\n    inline double getAngle(void) const { return atan2(y, x); }\n\n    inline Vector operator*(const double a) const {\n        return (Vector){ x * a, y * a };\n    }\n};\n\nstruct Point {\n    double x, y;\n\n    inline Vector operator-(const Point &p) const {\n        return (Vector){ x - p.x, y - p.y };\n    }\n\n    inline Point operator+(const Vector &v) const {\n        return (Point){ x + v.x, y + v.y };\n    }\n};\n\nstruct Segment {\n    Point s, t;\n\n    inline int isIntersectWith(const Segment &seg) const {\n        codb minX1 = min(s.x, t.x), maxX1 = max(s.x, t.x);\n        codb minY1 = min(s.y, t.y), maxY1 = max(s.y, t.y);\n        codb minX2 = min(seg.s.x, seg.t.x), maxX2 = max(seg.s.x, seg.t.x);\n        codb minY2 = min(seg.s.y, seg.t.y), maxY2 = max(seg.s.y, seg.t.y);\n        if (minX1 - EPS > maxX2 || maxX1 + EPS < minX2\n            || minY1 - EPS > maxY2 || maxY1 + EPS < minY2)\n            return 0;\n        const Vector vec1 = t - s, vec2 = seg.t - seg.s;\n        codb prof1 = (s - seg.s).cross(vec2) * vec2.cross(t - seg.s);\n        codb prof2 = (seg.s - s).cross(vec1) * vec1.cross(seg.t - s);\n        if (prof1 + EPS > 0 && prof2 + EPS > 0)\n            return 1;\n        else return 0;\n    }\n};\n\ninline int isEq(const double a, const double b) {\n    return abs(a - b) < EPS;\n}\n\nint main(void) {\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        Point p0, p1, p2, p3;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",\n              &p0.x, &p0.y, &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y);\n        const Segment seg1 = (Segment){ p0, p1 }, seg2 = (Segment){ p2, p3 };\n        printf(\"%d\\n\", seg1.isIntersectWith(seg2));\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\n\n\nint main(){\n    int q;\n    cin >> q;\n\n    while(q-- > 0){\n        double x[8];\n        for(int i = 0; i < 8; i++)  cin >> x[i];\n        cout << intersect(Point(x[0],x[1]), Point(x[2],x[3]), \n                          Point(x[4],x[5]), Point(x[6],x[7])) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n\tdouble dot(const Point &o) const { return x * o.x + y * o.y; }\n\n\tdouble atan() const { return atan2(y, x); }\n\n\tdouble norm() const { return sqrt(dot(*this)); }\n\n\tdouble distance(const Point &o) const { return (o - (*this)).norm(); }\n\n\tdouble area(const Point &a,const Point &b) {\n\t\tPoint p = a - (*this), p2 = b - (*this); \n\t\treturn p.cross(p2);\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const {\n\t\tPoint p = a - (*this), p2 = b - (*this);\n\t\treturn fabs(p.cross(p2)) / 2.0;\n\t}\t\n\n\t//??????ab?????????????????????????????????????????????????????????\n\tint between(const Point &a,const Point &b) {\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)  return ((a.x <= x) && (x <= b.x)) || ((a.x >= x) && (x >= b.x));\n\t\telse return ((a.y <= y) && (y <= b.y)) || ((a.y >= y) && (y >= b.y));\n\t}      \n\n\tdouble distance_seg(const Point& a,const Point& b) {\n\t\tif((b-a).dot(*this-a) < EPS) {\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS) {\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(b.cross(c) > 0.0) return +1;\t//conter clockwise\n\tif(b.cross(c) < 0.0) return -1;\t//clockwise\n\tif(b.dot(c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg() : a(Point(0, 0)), b(Point(0, 0)) {}\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }\n\n\tbool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }\n\n\t// bool isIntersect(Seg &s) {\n\t// \tif(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {\n\t// \t\treturn true;\n\t// \t}\n\t// \treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t// }\n\n\tbool isIntersect(Seg &s) {\n\t\treturn ccw(a, b, s.a) * ccw(a, b, s.b) <= 0 && ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0;\n\t}\n\n\tbool distance(Seg &s) {\n\t\tif((*this).isIntersect(s)) return 0.0;\n\n\t\treturn min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));\n\t}\n\n\tPoint getCrossPoint(Seg &s) {\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n\tPoint project(Point &p) {\n\t\tPoint base = b - a;\n\t\tdouble t = base.dot(p-a) / base.dot(base);\n\t\treturn a + base * t;\n\t}\n\n\tPoint reflect(Point &p) {\n\t\treturn p + (project(p) - p) * 2.0;\n\t}\n};\n\nostream& operator << (ostream& os, const Seg& s) {\n\tos << \"(\" << s.a.x << \", \" << s.a.y << \")-(\" << s.b.x << \",\" << s.b.y << \")\";\n\treturn os;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tSeg s1, s2;\n\trep(i, q) {\n\t\tcin >> s1.a.x >> s1.a.y >> s1.b.x >> s1.b.y >> s2.a.x >> s2.a.y >> s2.b.x >> s2.b.y;\n\n\t\tif(s1.isIntersect(s2)) {\n\t\t\tcout << 1 << endl;\n\t\t} else {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxdis;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\nint main() {\n  int q;\n  cin >> q;\n  while (q--) {\n    Segment a, b;\n    cin >> a >> b;\n    cout << Intersect(a, b) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n//外積\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\n//内積\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n//線 (線分)\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint main() {\n  int Q; cin >>Q;\n  REP(q, Q){\n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n    L l1 = L(P(x0, y0), P(x1, y1)), l2 = L(P(x2, y2), P(x3, y3));\n    if(intersectSS(l1, l2)) cout <<1 <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n//???\nclass Point {\npublic:\n    double x, y;\n    \n    Point (double x = 0, double y = 0):x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(a * x, a * y);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    \n    double norm(){return x*x + y*y;};\n    double absolute(){return sqrt(norm());};\n    \n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n    \n    bool operator == (const Point &p) const{\n        return equals(x, p.x) && equals(y, p.y);\n    }\n    \n};\ntypedef Point Vector;                               //????????????\ntypedef struct Segment{Point p1, p2;}Segment;       //??????\n//????????????a????????????\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n//????????????a,b?????????\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n//????????????a,b?????????\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\n//??????p0, p1, p2???????????????????????????p0p1???????????????p2??????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//??????S1(p1p2)??¨??????s2(p2p3)????????????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return  ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n            &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p1);\n}\n\n\nint main(){\n    \n    int x0, y0, x1, y1, x2, y2, x3, y3;\n    \n    int q;\n    \n    cin >> q;\n    \n    for (int i = 0; i < q; i++) {\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        \n        Point p0 = Point(x0, y0);\n        Point p1 = Point(x1, y1);\n        Point p2 = Point(x2, y2);\n        Point p3 = Point(x3, y3);\n        \n        \n        if( intersect(p0, p1, p2, p3) ) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a*x, a*y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\n\ndouble norm(Vector a) {\n\treturn a.norm();\n}\n\ndouble abs(Vector a) {\n\treturn a.abs();\n}\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint project(Segment s, Point p) {\n\tdouble alpha = dot(p - s.p2, s.p1 - s.p2) / (s.p1 - s.p2).norm();\n\treturn s.p2 + (s.p1 - s.p2)*alpha;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn project(s, p)*2.0 - p;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\tint p1p2p3, p1p2p4, p3p4p1, p3p4p2;\n\tp1p2p3 = ccw(p1, p2, p3);\n\tp1p2p4 = ccw(p1, p2, p4);\n\tp3p4p1 = ccw(p3, p4, p1);\n\tp3p4p2 = ccw(p3, p4, p2);\n\n\tif (p1p2p3 == ON_SEGMENT) return true;\n\tif (p1p2p4 == ON_SEGMENT) return true;\n\tif (p1p2p3 == ONLINE_FRONT && p1p2p4 == ONLINE_BACK) return true;\n\tif (p1p2p3 == ONLINE_BACK && p1p2p4 == ONLINE_FRONT) return true;\n\tif (p1p2p3 == COUNTER_CLOCKWISE && p1p2p4 == CLOCKWISE && p3p4p1 == CLOCKWISE && p3p4p2 == COUNTER_CLOCKWISE) return true;\n\tif (p1p2p3 == CLOCKWISE && p1p2p4 == COUNTER_CLOCKWISE && p3p4p1 == COUNTER_CLOCKWISE && p3p4p2 == CLOCKWISE) return true;\n\treturn false;\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//int main() {\n//\tSegment S1, S2;\n//\tint q;\n//\tcin >> q;\n//\tfor (int i = 0; i < q; i++) {\n//\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n//\t\tcout << fixed << setprecision(15);\n//\t\tcout << distSegSeg(S1, S2) << endl;\n//\t}\n//\n//\treturn 0;\n//}\n\nint main() {\n\tSegment S1, S2;\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> S1.p1.x >> S1.p1.y >> S1.p2.x >> S1.p2.y >> S2.p1.x >> S2.p1.y >> S2.p2.x >> S2.p2.y;\n\t\tcout << fixed << setprecision(15);\n\t\tcout << intersect(S1, S2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\n// BEGIN CUT HERE\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int q; cin >> q;\n  while (q--) {\n    L s, t; cin >> s.s >> s.t >> t.s >> t.t;\n    cout << !sgn(distSS(s, t)) << '\\n';\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3573104#1\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\ntypedef complex<double> C;\ntypedef pair<C,C> pp;\ntypedef vector<C> VP;\n#define eq(a,b) (fabs(a-b)<eps)\n#define veq(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\nconst C O{0,0};\n\nvoid In(C& p){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp=C(x,y);\n}\n\nvoid Out(C p){\n\tcout<<p.real()<<' '<<p.imag()<<endl;\n}\n\ndouble Dot(C p,C q){\n\treturn p.real()*q.real()+p.imag()*q.imag();\n}\n\ndouble Det(C p,C q){\n\treturn p.real()*q.imag()-q.real()*p.imag();\n}\n\nC Normal(C p){\n\treturn C(p.imag(),-p.real());\n}\n\nbool Comp(C p,C q){\n\tif(eq(p.real(),q.real())) return p.imag()<q.imag();\n\treturn p.real()<q.real();\n}\n\nint Clock(C a,C b,C c){\n\tdouble t=Det(b-a,c-a);\n\tif(t>eps) return 1;\n\tif(t<-eps) return -1;\n\tif(Dot(b-a,c-a)<-eps) return 2;\n\tif(Dot(a-b,c-b)<-eps) return -2;\n\treturn 0;\n}\n\nbool is_Orthgonal(C a,C b,C c,C d){\n\treturn eq(Dot(a-b,c-d),0);\n}\n\nbool is_Parallel(C a,C b,C c,C d){\n\treturn eq(Det(a-b,c-d),0);\n}\n\nbool is_Cross(C a,C b,C c,C d){\n\tif(is_Parallel(a,b,c,d)){\n\t\tif(Clock(a,b,c)==0||Clock(a,b,d)==0) return 1;\n\t\treturn 0;\n\t}\n\treturn Clock(a,b,c)*Clock(a,b,d)<=0&&Clock(c,d,a)*Clock(c,d,b)<=0;\n}\n\nint n;\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tC a,b,c,d;\n\t\tIn(a);In(b);In(c);In(d);\n\t\tcout<<is_Cross(a,b,c,d)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef double db;\ndb eps=1e-9;\nstruct point {\n\tdb x,y;\n\tpoint() {}\n\tpoint(db x,db y):x(x),y(y) {}\n\tvoid input() { scanf(\"%lf%lf\",&x,&y); }\n\tvoid output() { printf(\"%.10f %.10f\\n\",x,y); }\n\tdb len() { return sqrt(x*x+y*y); }\n\tdb len2() { return x*x+y*y; }\n};\npoint operator + (const point &a,const point &b) { return point(a.x+b.x,a.y+b.y);}\npoint operator - (const point &a,const point &b) { return point(a.x-b.x,a.y-b.y);}\npoint operator * (const point &a,const db &b) { return point(a.x*b,a.y*b);}\npoint operator / (const point &a,const db &b) { return point(a.x/b,a.y/b);}\ndb dot(const point &a,const point &b) { return a.x*b.x+a.y*b.y; }\ndb det(const point &a,const point &b) { return a.x*b.y-a.y*b.x; }\nstruct line {\n\tpoint a,b;\n\tline() {}\n\tline(point a,point b):a(a),b(b) {}\n};\npoint proj(const line &a,const point &b) {\n\treturn a.a+(a.b-a.a)*dot(a.b-a.a,b-a.a)/(a.b-a.a).len2();\n}\npoint reflect(const line &a,const point &b) {\n\treturn proj(a,b)*2-b;\n}\nint sign(db x) {\n\treturn fabs(x)<eps?0:(x>0?1:-1);\n}\nint relation(const line &a,const point &b) {\n\tint x=sign(det(a.b-a.a,b-a.a));\n\tif (x==1) return 0; // COUNTER_CLOCKWISE ?????¶???\n\telse if (x==-1) return 1; // CLOCKWISE ?????¶???\n\telse {\n\t\tx=sign(dot(b-a.a,a.b-a.a));\n\t\tif (x==-1) return 2; // ONLINE_BACK\n\t\telse {\n\t\t\tx=sign(dot(b-a.b,a.b-a.a));\n\t\t\tif (x==1) return 3; // ONLINE_FRONT\n\t\t\telse return 4; // ON_SEGMENT\n\t\t}\n\t}\n}\nbool parallel(const line &a,const line &b) { return sign(det(a.a-a.b,b.a-b.b))==0;}\nbool ismiddle(const line &a,const point &b) {\n\treturn sign(dot(b-a.a,a.b-a.a))>=0&&sign(dot(b-a.b,a.b-a.a))<=0;\n}\nint segcrossseg(const line &a, const line &b) {\n\tif (sign(min(b.a.x,b.b.x)-max(a.a.x,a.b.x))==1) return 0;\n\tif (sign(max(b.a.x,b.b.x)-min(a.a.x,a.b.x))==-1) return 0;\n\tif (sign(min(b.a.y,b.b.y)-max(a.a.y,a.b.y))==1) return 0;\n\tif (sign(max(b.a.y,b.b.y)-min(a.a.y,a.b.y))==-1) return 0;\n\tint d1=sign(det(a.b-a.a,b.a-a.a))*sign(det(a.b-a.a,b.b-a.a));\n\tint d2=sign(det(b.b-b.a,a.a-b.a))*sign(det(b.b-b.a,a.b-b.a));\n\tif (d1==-1&&d2==-1) return 2; // ?§??????????\n\telse if (d1<=0&&d2<=0) return 1; // ????§??????????\n\telse return 0; // ?????????\n}\n\nint q;\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,0,q) {\n\t\tpoint p1,p2,q1,q2;\n\t\tp1.input(); p2.input(); q1.input(); q2.input();\n\t\tputs(segcrossseg(line(p1,p2),line(q1,q2))>=1?\"1\":\"0\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)    //誤差\ntypedef complex<double> P;\n\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\nint main(){\n\n    int q; cin >> q;\n    for(int i = 0; i < q; i++){\n        P p0, p1, p2, p3; cin >> p0.real() >> p0.imag() >> p1.real() >> p1.imag() >> p2.real() >> p2.imag() >> p3.real() >> p3.imag();\n        if(is_intersected_ls(p0, p1, p2, p3)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid swap(int *a, int *b){\n\tif(*a != *b){\n\t\t*a ^= *b;\n\t\t*b ^= *a;\n\t\t*a ^= *b;\n\t}\n}\n\nint main() {\n\tint n, xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3, d1, d2, d3, d4;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;++i){\n\t\tcin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n\t\td1 = (yp2 - yp0)*(xp1 - xp0) - (xp2 - xp0)*(yp1 - yp0);\n\t\td2 = (yp3 - yp0)*(xp1 - xp0) - (xp3 - xp0)*(yp1 - yp0);\n\t\td3 = (yp0 - yp2)*(xp3 - xp2) - (xp0 - xp2)*(yp3 - yp2);\n\t\td4 = (yp1 - yp2)*(xp3 - xp2) - (xp1 - xp2)*(yp3 - yp2);\n\t\t\n\t\tif( d1 == 0 && d2 == 0){\n\t\t\tif(xp0 != xp1){//not parallel with y axis\n\t\t\t\tif(xp0 > xp1)swap(&xp0, &xp1);\n\t\t\t\tif(xp2 > xp3)swap(&xp2, &xp3);\n\t\t\t\t\n\t\t\t\tif(xp0 < xp3 && xp1 > xp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}else{//parallel with y axis\n\t\t\t\tif(yp0 > yp1)swap(&yp0, &yp1);\n\t\t\t\tif(yp2 > yp3)swap(&yp2, &yp3);\n\t\t\t\t\n\t\t\t\tif(yp0 < yp3 && yp1 > yp2){\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( d1 * d2 <= 0 && d3 * d4 <= 0){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define _GLIBCXX_DEBUG\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn (p1-q).cross(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...\n//on_seg(p1,p2,intersection(p1,p2,q1,q2)) && on_seg(q1,q2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n\tint q;\n\tcin>>q;\n\tfor(int cnt=0;cnt<q;cnt++)\n\t{\n\t\tvector<point> p;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tdouble c,d;\n\t\t\tcin>>c>>d;\n\t\t\tp.push_back(point(c,d));\n\t\t}\n\t\tif((p[1]-p[0]).cross(p[3]-p[2])==0)\n\t\t{\n\t\t\tint ans=on_seg(p[0],p[1],p[2])||on_seg(p[0],p[1],p[3])||on_seg(p[2],p[3],p[0])||on_seg(p[2],p[3],p[1]);\n\t\t\tcout<<ans<<endl;\n\t\t}else{\n\t\t\tpoint x=intersection(p[0],p[1],p[2],p[3]);\n\t\t\t//cerr<<x.x<<\" \"<<x.y<<endl;\n\t\t\tif(on_seg(p[0],p[1],x) && on_seg(p[2],p[3],x))\n\t\t\t\tcout<<1<<endl;\n\t\t\telse\n\t\t\t\tcout<<0<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   int x,y;\n   Point(){}\n   Point(int x,int y):x(x),y(y){}\n};\ntypedef Point Vector;\ninline int cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline int dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nint x[5],y[5];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%d%d\",&x[i],&y[i]);\n   \t  if(max(x[1],x[2])<min(x[3],x[4])||min(x[1],x[2])>max(x[3],x[4])||max(y[1],y[2])<min(y[3],y[4])||min(y[1],y[2])>max(y[3],y[4])) \n   \t  {\n   \t  \tputs(\"0\");\n   \t  \tcontinue;\n   \t  }\t\n   \t  ll p1=cross(Point(x[3]-x[1],y[3]-y[1]),Point(x[2]-x[1],y[2]-y[1])); \n   \t  ll p2=cross(Point(x[4]-x[1],y[4]-y[1]),Point(x[2]-x[1],y[2]-y[1]));\n   \t  ll p3=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[4]-x[3],y[4]-y[3]));  \n   \t  ll p4=cross(Point(x[2]-x[3],y[2]-y[3]),Point(x[4]-x[3],y[4]-y[3]));   \n   \t  if(p1*p2<=0&&p3*p4<=0) puts(\"1\");\n   \t  else puts(\"0\");\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tP p[4];\n\t\tPIN(p,4);\n\t\tP a=p[1]-p[0];\n\t\tP b=p[3]-p[2];\n\t\tif(cross(a,p[2]-p[0])*cross(a,p[3]-p[0])<EPS&&cross(b,p[1]-p[2])*cross(b,p[0]-p[2])<EPS)cout<<1<<endl;\n\t\telse cout<<0<<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long; using ld = long double; using ull = unsigned long long; using uint = unsigned int;\nusing vi  = vector<int>; using vb  = vector<bool>; using vd  = vector<double>; using vl  = vector<ll>;\nusing vvi = vector<vi>;  using vvb = vector<vb>;   using vvd = vector<vd>;     using vvl = vector<vl>;\n \n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define FOR(i,b,n) for(ll i=(b); i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TEN(x) ((ll)1e##x)\n \ntemplate<typename T> inline string join(const vector<T>& vec, string sep = \" \") { stringstream ss; REP(i, vec.size()) ss << vec[i] << ( i+1 == vec.size() ? \"\" : sep ); return ss.str(); }\n \n \n///////////////\n \n#define EPS (1e-10)\n#define NEXT(x, i) (x[(i + 1) % x.size()])\n \ntemplate<class T> using CR = const T &;\nusing P = complex<ld>;\nusing G = vector<P>;\n \nint sgn(ld a, ld b = 0) {\n    if (a > b + EPS) return 1;\n    if (a < b - EPS) return -1;\n    return 0;\n}\n \nld dot(P a, P b) { return real(conj(a)*b); }\nld cross(P a, P b) { return imag(conj(a)*b); }\n \nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    if (sgn(cross(b, c))) return sgn(cross(b, c)); // clockwise or counter clockwise\n    if (sgn(dot(b, c)) == -1) return 2;            // c--a--b\n    if (sgn(norm(b), norm(c)) == -1) return -2;    // a--b--c\n    return 0;                                      // a--c--b\n}\n \nstruct L : public vector<P> {\n    L(P a, P b) { push_back(a); push_back(b); }\n};\n \nbool iSS(CR<L> s, CR<L> t, bool strict = false) {\n\tint ccwa = ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]);\n\tint ccwb = ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]);\n\treturn ccwa <= 0 && (!strict || ccwa == -1)\n\t    && ccwb <= 0 && (!strict || ccwb == -1);\n}\n \n//////////////\n \nint main() {\n#ifdef INPUT_FROM_FILE\n    ifstream cin(\"sample.in\");\n    ofstream cout(\"sample.out\");\n#endif\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(30);\n    ll n; cin >> n;\n    while (n--) {\n        ld x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        P p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n        cout << iSS(L{ p0, p1 }, L{ p2, p3 }) << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef complex<double> Point;\ntypedef Point Vector;\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\nconstexpr double EPS = (1e-9L);\nenum CCW { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\ndouble dot(const Point& p1, const Point& p2) { return (conj(p1) * p2).real(); }\ndouble cross(const Point& p1, const Point& p2) { return (conj(p1) * p2).imag(); }\nconstexpr bool eq(double a) { return abs(a) < EPS; }\nPoint project(Segment s, Point p) {\n\tVector base = s.fi - s.se;\n\tdouble r = dot(p - s.fi, base) / norm(base);\n\treturn s.fi + base * r;\n}\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (cross(a, b) > EPS) return 1;\n\tif (cross(a, b) < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment &s1, Segment &s2) {\n\treturn intersect(s1.fi, s1.se, s2.fi, s2.se);\n}\ndouble getDistance(Point &a, Point &b) { return abs(a - b); }\ndouble getDistanceLP(Line &l, Point &p) {\n\treturn abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi));\n}\ndouble getDistanceSP(Segment &s, Point &p) {\n\tif(dot(s.se - s.fi, p - s.fi) < 0.0) return abs(p - s.fi);\n\tif(dot(s.fi - s.se, p - s.se) < 0.0) return abs(p - s.se);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistance(Segment &s1, Segment &s2) {\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se)),\n\t\t\t\tmin(getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se)));\n}\nint main() {\n\tcout << setprecision(10) << fixed;\n\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\tint q; cin >> q;\n\trep(i, 0, q) {\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP(intersect(Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3)) ? 1 : 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0) :x(x), y(y) {};\n\n\tpoint operator + (point p) { return point(x + p.x, y + p.y); }\n\tpoint operator - (point p) { return point(x - p.x, y - p.y); }\n\tpoint operator * (double s) { return point(x * s, y * s); }\n\tpoint operator / (double s) { return point(x / s, y / s); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const point &p) const\n\t{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const point &p) const\n\t{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\n\ndouble dot(point a, point b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(point a, point b, point c)\n{\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > EPS) return 1;//???????¨????????????????a,b,c??¨?????¶\n\tif (cross(b, c) < -EPS) return -1;//???????¨????????????????a,c,b??¨?????¶\n\tif (dot(b, c) < 0) return 2;//??´?????????c,a,b??????????????¶\n\tif (b.norm() < c.norm()) return -2;//??´?????????a,b,c??????????????¶\n\treturn 0;//??´?????????a,c,b??????????????¶\n}\n\nstruct line\n{\n\tpoint a, b;\n\tline(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0) :a(point(x1, y1)), b(point(x2, y2)) {};\n\n\tpoint univec() { return (b - a) / (b - a).norm(); }\n};\n\nbool isis_ss(line s, line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) >= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) >= 0);\n}\n\nint main()\n{\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tint a[8];\n\t\tREP(i, 8) cin >> a[i];\n\t\tline s(a[0], a[1], a[2], a[3]);\n\t\tline t(a[4], a[5], a[6], a[7]);\n\t\tif (isis_ss(s, t)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,sum1,sum2,xa,xb,xc,xd,ya,yb,yc,yd;\nlong long xp1,xp2,xp3,xp4,yp1,yp2,yp3,yp4;\nint main(){\t\n\tscanf(\"%lld\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&xp1,&yp1,&xp2,&yp2);\n\t\tscanf(\"%lld%lld%lld%lld\",&xp3,&yp3,&xp4,&yp4);\n\t\txa=min(xp1,xp2);\n\t\txb=max(xp1,xp2);\n\t\tya=min(yp1,yp2);\n\t\tyb=max(yp1,yp2);\n\t\txc=min(xp3,xp4);\n\t\txd=max(xp3,xp4);\n\t\tyc=min(yp3,yp4);\n\t\tyd=max(yp3,yp4);\n\t\tif(xc>xb||xa>xd||yc>yb||ya>yd){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\txb=xp4-xp3;\n\t\tyb=yp4-yp3;\n\t\txa=xp1-xp3;\n\t\tya=yp1-yp3;\n\t\tsum1=xa*yb-xb*ya;\n\t\txa=xp2-xp3;\n\t\tya=yp2-yp3;\n\t\tsum2=xa*yb-xb*ya;\n\t\tif(sum1*sum2>0){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\txb=xp2-xp1;\n\t\tyb=yp2-yp1;\n\t\txa=xp3-xp1;\n\t\tya=yp3-yp1;\n\t\tsum1=xa*yb-xb*ya;\n\t\txa=xp4-xp1;\n\t\tya=yp4-yp1;\n\t\tsum2=xa*yb-xb*ya;\n\t\tif(sum1*sum2>0){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define LOOP(i) while(i--)\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nclass Point2D{\n\tT pos[2];\npublic:\n\tPoint2D()=default;\n\tPoint2D(T x,T y){\n\t\tpos[0]=x,pos[1]=y;\n\t}\n\tPoint2D operator-(const Point2D& r){\n\t\tPoint2D temp(*this);\n\t\ttemp.pos[0] -= r.pos[0];\n\t\ttemp.pos[1] -= r.pos[1];\n\t\treturn temp;\n\t}\n\tT& operator[](int index){return pos[index];}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in();\n\tLOOP(N){\n\t\tPoint2D<int> P[4];\n\t\tREP(i,4){\n\t\t\tP[i][0]=in();\n\t\t\tP[i][1]=in();\n\t\t}\n\t\tPoint2D<double> v[2],u;\n\t\tREP(i,2){\n\t\t\tREP(j,2){\n\t\t\t\tv[i][j] = (P[2*i+1]-P[2*i])[j];\n\t\t\t}\n\t\t\tu[i] = P[2][i]-P[0][i];\n\t\t}\n\n\t\tauto cross = [](Point2D<double>& l,Point2D<double>& r){\n\t\t\treturn l[0]*r[1]-l[1]*r[0];\n\t\t};\n\n\t\tif(abs(cross(v[0],v[1]))<=1e-10){\n\t\t\tPoint2D<double> w;\n\t\t\tREP(i,2){\n\t\t\t\tw[i] = P[3][i]-P[0][i];\n\t\t\t}\n\t\t\tdouble nv[2],nu,nw;\n\t\t\tnv[0] = hypot(v[0][0],v[0][1]);\n\t\t\tnv[1] = hypot(v[1][0],v[1][1]);\n\t\t\tnu = hypot(u[0],u[1]);\n\t\t\tnw = hypot(w[0],w[1]);\n\t\t\tREP(i,2){\n\t\t\t\tv[0][i] /= nv[0];\n\t\t\t\tv[1][i] /= nv[1];\n\t\t\t\t//w[i] /= nw;\n\t\t\t\t//u[i] /= nu;\n\t\t\t}\n\t\t\tdouble k1,k2;\n\t\t\tk1 = v[0][0]*u[0]+v[0][1]*u[1];\n\t\t\tk2 = v[0][0]*w[0]+v[0][1]*w[1];\n\n\t\t\tif((nv[1]+nu>nw) && (nv[1]+nw>nu) && (nw+nu>nv[1])){\n\t\t\t\tout(0);\n\t\t\t}\n\t\t\telse if((0<=k1 && k1<=nv[0]) || (0<=k2 && k2<=nv[0]) || (0>=k1 && k2>=nv[0]) || (0>=k2 && k1>=nv[0])){\n\t\t\t\tout(1);\n\t\t\t}\n\t\t\telse out(0);\n\t\t\tcontinue;\n\t\t}\n\t\tdouble t1 = (cross(u,v[0]))/(cross(v[0],v[1]));\n\t\tdouble t2 = (cross(u,v[1]))/(cross(v[0],v[1]));\n\t\tif(0<=t1 && t1<=1 && 0<=t2 && t2<=1){\n\t\t\tout(1);\n\t\t}\n\t\telse{\n\t\t\tout(0);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<iostream>\n#include<set>\n#include<map>\n#define re register\n#define ll long long\nusing namespace std;\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9'|| ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn sum*f;\n}\nconst double eps=1e-10,Pi=acos(-1.0);\nstruct node{\n\tdouble x,y;\n\tnode operator+(node b){return (node){x+b.x,y+b.y};}\n\tnode operator-(node b){return (node){x-b.x,y-b.y};}\n\tnode operator*(double b){return (node){x*b,y*b};}\n\tdouble len(){return sqrt(x*x+y*y);}\n};\nint fh(double a){return fabs(a)<eps?0:a>eps?1:-1;}\ndouble cross(node a,node b){return a.x*b.y-a.y*b.x;}\ndouble dot(node a,node b){return a.x*b.x+a.y*b.y;}\nnode projection(node p1,node p2,node p){node v=p2-p1;return p1+v*(dot(v,p-p1)/dot(v,v));}\nnode reflection(node p1,node p2,node p){node P=projection(p1,p2,p);P=P*2-p;return P;}\nvoid Counter_Clockwise(node p1,node p2,node p){\n\tif(cross(p2-p1,p-p1)>eps){puts(\"COUNTER_CLOCKWISE\");return;}\n\tif(cross(p2-p1,p-p1)<-eps){puts(\"CLOCKWISE\");return;}\n\tif(dot(p2-p1,p-p1)<-eps){puts(\"ONLINE_BACK\");return;}\n\tif(dot(p2-p1,p2-p1)>=dot(p-p1,p2-p1)){puts(\"ON_SEGMENT\");return;}\n\tputs(\"ONLINE_FRONT\");\n}\nbool insegment(node A,node B,node p){\n\tif(fh(cross(B-A,p-A)))return false;\n\treturn ((fh(p.x-A.x)>=0 && fh(B.x-p.x)>=0) || (fh(p.x-A.x)<=0 && fh(B.x-p.x)<=0)) && ((fh(p.y-A.y)>=0 && fh(B.y-p.y)>=0) || (fh(p.y-A.y)<=0 && fh(B.y-p.y)<=0));\n}\nbool intersection(node A1,node A2,node B1,node B2){\n\tif(!fh(cross(B2-B1,A2-A1))){\n\t\tif(insegment(A1,A2,B1) || insegment(A1,A2,B2) || insegment(B1,B2,A1) || insegment(B1,B2,A2))return true;\n\t\treturn false;\n\t}\n\treturn fh(cross(A1-B1,B2-B1)*cross(A2-B1,B2-B1))<=0 && (fh(cross(B1-A1,A2-A1)*cross(B2-A1,A2-A1))<=0);\n}\nint main(){\n\tnode p1,p2,p3,p4;\n\tint Q=gi();\n\twhile(Q--){\n\t\tp1.x=gi();p1.y=gi();p2.x=gi();p2.y=gi();\n\t\tp3.x=gi();p3.y=gi();p4.x=gi();p4.y=gi();\n\t\tif(intersection(p1,p2,p3,p4))puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define LEFT_TOP POS(10001, 10001)\n#define NO_INTERSECT POS(-12345, -12345)\n#define PARALLEL POS(-10001, -10001)\n#define COLINE POS(12345, 12345)\nconst double PI = acos(-1.0);\n\ntypedef long double T;\n\nclass POS {\npublic:\n    T x, y;\n    POS(const T& x = 0, const T& y = 0) : x(x), y(y) {}\n    POS(const POS& x) : x(x.x), y(x.y) {}\n\n    bool operator==(const POS& rhs) const {\n        return x == rhs.x && y == rhs.y;\n    }\n\n    POS& operator+=(const POS& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n\n    POS operator -() {\n        POS tmp(-x, -y);\n        return tmp;\n    }\n\n    T dist(const POS& rhs) const {\n        T tmp_x = x-rhs.x, tmp_y = y-rhs.y;\n        return sqrt(tmp_x*tmp_x+tmp_y*tmp_y);\n    }\n\n    friend ostream& operator<<(ostream& out, const POS& pos) {\n        out << pos.x << \" \" << pos.y;\n        return out;\n    }\n};\n\nPOS const operator+(const POS& lhs, const POS& rhs) {\n    return POS(lhs) += rhs;\n}\n\nPOS const operator-(const POS& lhs, const POS& rhs) {\n    POS tmp = rhs;\n    tmp = -tmp;\n    return POS(lhs) += (tmp);\n}\n\nbool cmp_convex(const POS& lhs, const POS& rhs) {\n    return (lhs.x < rhs.x) || ( (lhs.x == rhs.x)&&(lhs.y < rhs.y) );\n}\n\ninline T cross(const POS& o, const POS& a, const POS& b) {\n    T value = (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);\n    if (fabs(value) < EPS) return 0;\n    return value;\n}\n\nvoid convex_hull(POS* points, POS* need, int& n) {\n    sort(points, points+n, cmp_convex);\n    int index = 0;\n    for (int i = 0; i < n; ++i) {\n        while (index >= 2 && cross(need[index-2], need[index-1], points[i]) <= 0) index--;\n        need[index++] = points[i];\n    }\n    int half_point = index+1;\n    for (int i = n-2; i >= 0; --i) {\n        while (index >= half_point && cross(need[index-2], need[index-1], points[i]) <= 0) index--;\n        need[index++] = points[i];\n    } /* be careful that start point will appear in fisrt and last in need array */\n    n = index;\n}\n\nclass LINE {\npublic:\n    POS start, end, vec;\n    T angle;\n    LINE() {}\n    LINE(const T& st_x, const T& st_y, const T& ed_x, const T& ed_y) :\n        start(st_x, st_y), end(ed_x, ed_y), vec(end - start), angle(atan2(vec.x, vec.y)) {}\n\n    LINE(const POS& start, const POS& end) :\n        start(start), end(end), vec(end - start), angle(atan2(vec.x, vec.y)) {}\n\n    LINE(const POS& end) : /* start point is origin */\n        start(0, 0), end(end), vec(end), angle(atan2(vec.x, vec.y)) {}\n\n    LINE(const T a, const T b, const T c) : /* given line by ax+by+c = 0 */\n        start(0, 0), end(0, 0), vec(-b, a) {\n        if (a == 0) {\n            start.y = end.y = -c/b;\n            end.x = -b;\n        }\n        else if (b == 0) {\n            start.x = end.x = -c/a;\n            end.y = a;\n        }\n        else if (c == 0) {\n            end.x = -b; end.y = a;\n        }\n        else {\n            start.y = -c/b; end.x = -c/a;\n            vec.x = -c/a; vec.y = c/b;\n        }\n        angle = atan2(vec.x, vec.y);\n    }\n\n    LINE build_orthogonal(const POS& point) const {\n        T c = -(vec.x*point.x + vec.y*point.y);\n        return LINE(vec.x, vec.y, c);\n    }\n\n    T length2() const { /* square */\n        T x = start.x - end.x, y = start.y - end.y;\n        return x*x + y*y;\n    }\n\n    void modify(T x, T y) {\n        this->end.x += x;\n        this->end.y += y;\n        this->vec.x += x;\n        this->vec.y += y;\n    }\n\n    bool on_line(const POS& a) const {\n        if (vec.x == 0) {\n            if (start.x != a.x) return false;\n            return true;\n        }\n        if (vec.y == 0) {\n            if (start.y != a.y) return false;\n            return true;\n        }\n        return fabs(( (a.x-start.x)/vec.x*vec.y + start.y )- a.y) < EPS;\n    }\n\n    bool operator/(const LINE& rhs) const { /* to see if this line parallel to LINE rhs */\n        return (vec.x*rhs.vec.y == vec.y*rhs.vec.x);\n    }\n\n    bool operator==(const LINE& rhs) const { /* to see if they are same line */\n        return (*this/rhs) && (rhs.on_line(start));\n    }\n\n    POS intersect(const LINE& rhs) const {\n        if (*this==rhs) return COLINE; /* return co-line */\n        if (*this/rhs) return PARALLEL; /* return parallel */\n\n        T A1 = vec.y, B1 = -vec.x, C1 = end.x*start.y - start.x*end.y;\n        T A2 = rhs.vec.y, B2 = -rhs.vec.x, C2 = rhs.end.x*rhs.start.y - rhs.start.x*rhs.end.y;\n        return POS( (B2*C1-B1*C2)/(A2*B1-A1*B2), (A1*C2-A2*C1)/(A2*B1-A1*B2) ); /* sometimes has -0 */\n    }\n\n    T dist(const POS& a) const {\n        return fabs(vec.y*a.x - vec.x*a.y + vec.x*start.y - vec.y*start.x)/sqrt(vec.y*vec.y+vec.x*vec.x);\n    }\n\n    T dist(const LINE& rhs) const {\n        POS intersect_point = intersect(rhs);\n        if (intersect_point == PARALLEL) {\n            return dist(rhs.start);\n        }\n        return 0;\n    }\n\n    friend ostream& operator<<(ostream& out, const LINE& line) {\n        out << line.start << \"-->\" << line.end << \" vec: \" << line.vec;\n        return out;\n    }\n};\n\nclass LINESEG : public LINE {\npublic:\n    LINESEG() : LINE(POS(0, 0)) {}\n    LINESEG(const LINE& input) : LINE(input) {}\n    LINESEG(const POS& start, const POS& end) : LINE(start, end) {}\n\n    bool on_lineseg(const POS& a) const {\n        if (!on_line(a)) return false;\n        bool first, second;\n        if (vec.x >= 0) first = (a.x >= start.x)&&(a.x <= end.x);\n        else first = (a.x <= start.x)&&(a.x >= end.x);\n        if (vec.y >= 0) second = (a.y >= start.y)&&(a.y <= end.y);\n        else second = (a.y <= start.y)&&(a.y >= end.y);\n        return first&&second;\n    }\n\n    bool operator==(const LINESEG& rhs) const {\n        return ( (rhs.start == start && rhs.end == end) ||\n              (rhs.start == end && rhs.end == start) );\n    }\n\n    bool operator==(const LINE& rhs) const {\n        return this->LINE::operator==(rhs);\n    }\n\n    T dot(const LINESEG& rhs) const {\n        return vec.x*rhs.vec.x + vec.y*rhs.vec.y;\n    }\n\n    T cross(const LINESEG& rhs) const {\n        return vec.x*rhs.vec.y - vec.y*rhs.vec.x;\n    }\n\n    bool clockwise(const LINE& a) const { /* to see if LINE a is in b's clockwise way */\n        return cross(a) > 0;\n    }\n\n    T dist(const POS& a) const {\n        T ortho_dist = this->LINE::dist(a);\n        LINE ortho_line = build_orthogonal(a);\n        POS intersect_point = this->LINE::intersect(ortho_line);\n        if (on_lineseg(intersect_point)) return ortho_dist;\n        else return min(a.dist(this->start), a.dist(this->end));\n    }\n\n    T dist(const LINE& line) const {\n        POS intersect_point = this->LINE::intersect(line);\n        if (intersect_point == COLINE) return 0;\n        if (intersect_point == PARALLEL) return dist(line.start);\n        if (on_lineseg(intersect_point)) return 0;\n        return min(line.dist(start), line.dist(end));\n    }\n\n    T dist(const LINESEG& line) const {\n        return min( min(dist(line.start), dist(line.end)),\n                    min(line.dist(start), line.dist(end)) );\n    }\n\n    POS intersect(const LINESEG& rhs) const {\n        LINE a1b1(start, rhs.start);\n        LINE a1b2(start, rhs.end);\n        LINE b1a1(rhs.start, start);\n        LINE b1a2(rhs.start, end);\n\n        POS tmp(this->LINE::intersect(rhs));\n\n        if (tmp == COLINE) {\n            if ( (start==rhs.start) && (!rhs.on_lineseg(end)) && (!on_lineseg(rhs.end)) ) return start;\n            if ( (start==rhs.end) && (!rhs.on_lineseg(end)) && (!on_lineseg(rhs.start)) ) return start;\n            if ( (end==rhs.start) && (!rhs.on_lineseg(start)) && (!on_lineseg(rhs.end)) ) return end;\n            if ( (end==rhs.end) && (!rhs.on_lineseg(start)) && (!on_lineseg(rhs.start)) ) return end;\n            if (on_lineseg(rhs.start) || on_lineseg(rhs.end) || rhs.on_lineseg(start) || rhs.on_lineseg(end)) return COLINE;\n            return NO_INTERSECT;\n        }\n\n        bool intersected =  ( (cross(a1b1)*cross(a1b2)<0) && (rhs.cross(b1a1)*rhs.cross(b1a2)<0) );\n        if (!intersected) return NO_INTERSECT;\n        if (!on_lineseg(tmp) || !rhs.on_lineseg(tmp)) return NO_INTERSECT;\n        return tmp;\n    }\n};\n\nint main()\n{\n    int q;\n    cin >> q;\n    cout << fixed << setprecision(10);\n    while(q--){\n        int xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n        cin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n        POS p0(xp0, yp0), p1(xp1, yp1), p2(xp2, yp2), p3(xp3, yp3);\n        LINESEG l0(p0, p1), l1(p2, p3);\n        if(l0.intersect(l1) == NO_INTERSECT){\n            cout << 0 << endl;\n        } else {\n            cout << 1 << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n \n#define eps (1e-10)\n#define INF (1e20)\n\nstatic const double PI = acos(-1);\nbool eq(double a,double b){\n  return ( -eps < a-b && a-b < eps);\n}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n};\ntypedef Point Vector;\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n  Vector base(){\n    return p2-p1;\n  }\n};\ntypedef Segment Line;\n\nbool eq(Point a,Point b){ return (eq(a.x,b.x)&&eq(a.y,b.y)); }\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b){\n  return eq(cross(a,b),0);\n}\n\nVector unit(Vector v){\n  if(eq(abs(v),0))return v;\n  else return v/abs(v);\n}\n\nPoint getCrossPoint(Line a,Line b){\n  return a.p1+(a.p2-a.p1)*(cross(b.p2-b.p1,b.p1-a.p1)/cross(b.p2-b.p1,a.p2-a.p1));\n} \n\nbool intersect(Segment a,Segment b){\n  Point p=getCrossPoint(a,b);\n  return eq( abs(a.p1-p)+abs(a.p2-p) , abs(a.p1-a.p2) );\n}\n\nvoid scan(Segment &a){\n  cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y;\n}\n\nint main(){\n  Segment a,b;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    scan(a);\n    scan(b);\n    cout<<intersect(a,b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e16;\nconst ll mod = 1000000007;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint ctoi(char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return 0;\n}\nll factorial(ll n) {\n  if (n == 1) {\n    return 1;\n  }\n  ll ans = factorial(n-1);\n  return ans*n;\n}\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\nll lcm(ll a, ll b) {\n  return (a/gcd(a, b))*b;\n}\nbool is_prime(ll n) {\n  for (ll i = 2; i*i <= n; i++) {\n    if (n%i == 0) return false;\n  }\n  return n != 1;\n}\nll mod_pow(ll x, ll n, ll mod) {\n  if (n == 0) return 1;\n  ll res = mod_pow(x*x%mod, n/2, mod);\n  if (n & 1) res = res * x % mod;\n  return res;\n}\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\n  public:\n  double x, y;\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n  double norm() { return x*x + y*y; }\n  double abs() { return pow(norm(), 0.5); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\ntypedef Point Vector;\nstruct Segment {\n  Point p1, p2;\n};\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p-s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\ndouble cross(Point a, Point b) {\n  return a.x*b.y - a.y*b.x;\n}\nll ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) > EPS) return 1;\n  if (cross(a, b) < -EPS) return -1;\n  if (dot(a, b) < -EPS) return 2;\n  if (a.norm() < b.norm()) return -2;\n  return 0;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return ccw(p1, p2, p3)*ccw(p1, p2, p4)<=0 && ccw(p3, p4, p1)*ccw(p3, p4, p2)<=0;\n}\n\nint main() {\n  ll n;\n  cin >> n;\n  Point p1, p2, p3, p4;\n  rep(i, n) {\n    cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y;\n    if (intersect(p1, p2, p3, p4)) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\ndouble distance(Segment l, Point c){\n    if(dot(l.b-l.a, c-l.a) < EPS) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) < EPS) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nbool intersect(Segment l1, Segment l2){\n    return (ccw(l1.a, l1.b, l2.a)*ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a)*ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nPoint crossPoint(Segment l1, Segment l2){\n    real d1 = abs(cross(l1.b-l1.a, l2.b-l2.a));\n    real d2 = abs(cross(l1.b-l1.a, l1.b-l2.a));\n    if(d1 < EPS && d2 < EPS) return l2.a;\n    return l2.a+(l2.b-l2.a)*d2/d1;\n}\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nint main() {\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        Point a, b, c, d;\n        cin >> a >> b >> c >> d;\n        Segment s(a, b), t(c, d);\n        cout << intersect(s, t) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll  long long\n//#define int long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define pa pair<int,int>\n#define mkp(a,b) make_pair(a,b)\nconst int N=2e5+10;\nconst int mod=998244353;\nusing namespace std;\n\n\nstruct Point\n{\n   double x,y;\n   Point(){}\n   Point(double x,double y):x(x),y(y){}\n};\ntypedef Point Vector;\nVector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\nVector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\nVector operator * (Vector a,double mul){return Vector(a.x*mul,a.y*mul);}\nVector operator / (Vector a,double div){return Vector(a.x/div,a.y/div);}\ninline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\ninline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\nstruct Line\n{\n   Point p; Vector v;\n   Line(){}\n   Line(Point p,Vector v): p(p),v(v){}\n};\nPoint line_intersect(Line a,Line b)// 两直线交点\n{\n   double t=cross(b.v,a.p-b.p)/cross(a.v,b.v);\n   return a.p+a.v*t;\n}\ndouble x[5],y[5];\nint a[555];\nint32_t main()\n{\n   //ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);\n   //freopen(\"in.txt\",\"w\",stdout);\n   int q; scanf(\"%d\",&q);\n   while(q--)\n   {\n   \t  for(int i=1;i<=4;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   \t  Line l1=Line(Point(x[1],y[1]),Vector(x[2]-x[1],y[2]-y[1]));\n   \t  Line l2=Line(Point(x[3],y[3]),Vector(x[4]-x[3],y[4]-y[3]));\n\n   \t  double p=cross(l1.v,l2.v);  \n   \t  if(fabs(p)<1e-8)\n   \t  {\n   \t    double w=cross(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    if(fabs(w)<1e-8)\n   \t    {\n   \t    \tdouble ee=dot(Point(x[1]-x[3],y[1]-y[3]),Point(x[1]-x[4],y[1]-y[4]));\n   \t    \tdouble e=dot(Point(x[2]-x[3],y[2]-y[3]),Point(x[2]-x[4],y[2]-y[4]));\n   \t    \tdouble eee=dot(Point(x[3]-x[1],y[3]-y[1]),Point(x[3]-x[2],y[3]-y[2]));\n   \t    \tdouble eeee=dot(Point(x[4]-x[1],y[4]-y[1]),Point(x[4]-x[2],y[4]-y[2]));\n   \t    \t//cout<<ee<<\" \"<<e<<endl;\n   \t    \tif(ee<=0||e<=0||eee<=0||eeee<=0) puts(\"1\"); else puts(\"0\");\n   \t    }\n   \t    else puts(\"0\");\n   \t  }\n   \t  else\n      {\n      \t Point j=line_intersect(l1,l2);\n      \t if(j.x<=max(x[1],x[2])&&j.x>=min(x[1],x[2])&&j.x>=min(x[3],x[4])&&j.x<=max(x[3],x[4])\n      \t   &&j.y<=max(y[1],y[2])&&j.y>=min(y[1],y[2])&&j.y>=min(y[3],y[4])&&j.y<=max(y[3],y[4])\t)\n      \t \tputs(\"1\");\n      \t else puts(\"0\");\n      }\n   }\nreturn 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    if(a*x1+b*y1+c==0){//(x1,y1)が直線上にある.\n        *x2=x1;\n        *y2=y1;\n        return;\n    }\n    \n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return /*2*M_PI- */ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    if(x1==x2&&y1==y2)return 0.0;\n    \n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    if(x1==x2&&y1==y2)return 0.0;\n    if(x3==x2&&y3==y2)return 0.0;\n    \n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    double ret = 2*M_PI-( angle+(M_PI-angle2) );\n    if(ret<0)ret+=2*M_PI;\n    if(ret>=2*M_PI)ret-=2*M_PI;\n    \n    \n    \n    return ret;\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用前に sort(a, a+n); をおこなう*/\n/*使用注意 他と仕様が違う*/\n/*点にpairを使っている*/\n\n\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double> >b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n//-------------------------------------------------------------------------------------\n/* 2点(x1,y1) (x2,y2)を通る直線に点(px,py)から引いた垂線の直線との交点(x, y)を返す */\nvoid intersection_of_the_normal_to_the_straight_line_passing_through_the_two_points(double px,double py,double x1, double y1,double x2, double y2,double *x, double *y){\n    double a,b,c;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    *x = px-(a*px+b*py+c)/(a*a+b*b)*a;\n    *y = py-(a*px+b*py+c)/(a*a+b*b)*b;\n}\n                                      \nint main(){\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    double a,b,c,d,e,f;\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n        //straight_line_passing_through_the_two_points(x0, y0, x1, y1, &a, &b, &c);\n        //straight_line_passing_through_the_two_points(x2, y2, x3, y3, &d, &e, &f);\n        cout<<line_segment_cross_decision(x0, y0, x1, y1, x2, y2, x3, y3)<<endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\n// // ????????¨???P??¨??????????????????????????¢\n// double norm(const P& a, const P& b) {\n//     return dot(\n//     return real(conj(a)*b);\n// }\n\nint main(){\n    int Q;\n    cin >> Q;\n    REP(q, Q) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        P p0(x0, y0);\n        P p1(x1, y1);\n        P p2(x2, y2);\n        P p3(x3, y3);\n        L s0(p0, p1);\n        L s1(p2, p3);\n        cout << intersectSS(s0, s1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 0;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return 0;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\npoint projection(point a,point b,point c){\n  point d = b - a;\n  return a+d*(dot(c-a,d)/(abs(d)*abs(d)));\n}\n\npoint reflection(point a,point b,point c){\n  return 2.0*projection(a,b,c)-c;\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n  /*if(ccw(a,b,c) == ccw(a,b,d)) return false;\n  b-=a;\n  c-=a;\n  d-=a;\n  c *= conj(b)/abs(b);\n  d *= conj(b)/abs(b);\n  point e = d+((c-d)*d.y)/(d.y-c.y);\n  if(e.x > abs(b) || e.x < 0) return false;\n  return true;*/\n}\n\nint main(){\n  point a,b,c,d;\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++) {\n    cin >>a.x>>a.y>>b.x>>b.y>>c.x>>c.y>>d.x>>d.y;\n    cout << intersection(a,b,c,d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n\nconst int MAX = 1e2 + 5;\nconst int L = 2;\nconst LL MOD = 10000;\nconst int dir[MAX][MAX] = {{0,1},{0,-1},{1,0},{-1,0},{-1,-1},{-1,1},{1,1},{1,-1}};\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\ntypedef struct Point Point;\ntypedef struct Line Line;\n\nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \nstruct Point\n{\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double a, double b): x(a), y(b) {}\n\n\tfriend Point operator -(Point a, Point b)\n\t{\n\t\treturn Point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend Point operator +(Point a, Point b)\n\t{\n\t\treturn Point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend bool operator ==(Point a, Point b)\n\t{\n\t\treturn cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n\t}\n\tfriend Point operator *(Point a, double b)\n\t{\n\t\treturn Point(a.x*b,a.y*b);\n\t}\n\tfriend Point operator *(double a, Point b)\n\t{\n\t\treturn Point(a*b.x,a*b.y);\n\t}\n\tfriend Point operator /(Point a, double b)\n\t{\n\t\treturn Point(a.x/b,a.y/b);\n\t}\n\tdouble norm()\n\t{\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n};\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n\tLine(Point x, Point y): a(x), b(y) {}\n};\n\nbool parallel(Line a, Line b)\n{\n\treturn !cmp(det(a.a-a.b,b.a-b.b));\n}\n\t\nbool orthogonal(Line a, Line b)\n{\n\treturn !cmp(dot(a.a - a.b, b.a - b.b));\n}\n\nPoint PointProjLine(Point p, Line l)\n{\n\tPoint ans;\n\tdouble r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n\tans = l.a + r*(l.b-l.a);\n\treturn ans;\n}\n\nint cmp(double x)\n{\n\tif(abs(x) < EPS)\n\t\treturn 0;\n\tif(x > 0)\n\t\treturn 1;\n\treturn -1;\n}\n\ndouble dis_point_segment(Point p, Line l)\n{\n\tif(cmp(dot(p-l.a,l.b-l.a))<0)\n\t\treturn (p-l.a).norm();\n\tif(cmp(dot(p-l.b,l.a-l.b))<0)\n\t\treturn (p-l.b).norm();\n\treturn abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\n\nbool line_make_point(Line a, Line b, Point &res)\n{\n\tif(parallel(a,b))\n\t\treturn false;\n\tdouble s1 = det(a.a-b.a,b.b-b.a);\n\tdouble s2 = det(a.b-b.a,b.b-b.a);\n\tres = (s1*a.b-s2*a.a)/(s1-s2);\n\treturn true;\n}\n\ndouble dis_segment_segment(Line a, Line b)\n{\n\tPoint res;\n\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\treturn 0.;\n\treturn min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\n\ndouble sqr(double x)\n{\n\treturn x * x;\n}\n\ndouble det(Point a, Point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Point a, Point b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n\treturn (a-b).norm();\n}\n\nPoint rotate_point(Point p, double A)\n{\n\tdouble tx = p.x, ty = p.y;\n\treturn Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\n\nPoint reflect(Line l, Point p)\n{\n\treturn p + ((PointProjLine(p, l) - p) * 2.0);\n}\n\nbool in_segment(Line l, Point p)\n{\n\tbool fa = false, fb = false;\n\tif((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n\t\tfa = true;\n\tif((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n\t\tfb = true;\n\treturn fa && fb;\n}\n\nint main()\n{\t\n#ifdef LOCAL\n\t//~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tint T;\n\tsfi(T);\n\twhile(T--)\n\t{\n\t\tLine a, b;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &a.a.x, &a.a.y, &a.b.x, &a.b.y, &b.a.x, &b.a.y, &b.b.x, &b.b.y);\n\t\tPoint res;\n\t\tif(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nvoid vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならばfalseを返す*/\nbool intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false)return 0;\n    \n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\nint main(int argc, const char * argv[]){\n    int q;\n    cin>>q;\n    for(int i=0; i<q; i++){\n        double x1,x2,x3,x4,y1,y2,y3,y4;\n        cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n        int ans = line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4);\n        cout<<ans<<endl;\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nclass P\n{\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){P t;t.x=x+q.x;t.y=y+q.y;return t;}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){P t;t.x=x-q.x;t.y=y-q.y;return t;}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  template<typename T> P operator/(T d){return P(x/d,y/d);}\n  template<typename T> P operator/=(T d){x/=d;y/=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  double norm(void){return sqrt(x*x+y*y);}\n  double arg(void){return acos(x/this->norm())*P(1,0).sign(*this);}\n  P nvec(){return P(y,-x);}\n  P rotate(double t){double c=cos(t),s=sin(t);return P(c*x-s*y,s*x+c*y);}\n  P reverseX(void){return P(-x,y);}\n  P reverseY(void){return P(x,-y);}\n  P unit(void){return (*this).norm()==0?P(0,0):(*this)/(*this).norm();}\n  P floor(void){return P((int)x,(int)y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  int sign(const P&q){double d = (*this).det(q); return (d>0)-(d<0);}\n  static bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  static P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n  static bool crossing(P p1,P p2,P q1,P q2)\n  {\n    double x=(q2-q1).det(q1-p1)/(q2-q1).det(p2-p1);\n    double y=(p2-p1).det(p1-q1)/(p2-p1).det(q2-q1);\n    return x<=1 && x>=0 && y<=1 && y>=0;\n  }\n};\n\n\nint main()\n{\n  int q; cin >> q;\n  REP(i,q)\n  {\n    int ans;\n    double x0,y0,x1,y1,x2,y2,x3,y3;\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n    cout << P::crossing(P(x0,y0),P(x1,y1),P(x2,y2),P(x3,y3)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef complex<double> Point;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\ndouble dot(Point a, Point b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nint main(void){\n\tint q;\n\tcin>>q;\n\trep(i,q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tcout<<isecSS({x0,y0},{x1,y1},{x2,y2},{x3,y3})<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad\nimport Data.Complex\nimport Data.Maybe\n\ntype Point = Complex Double\ntype Vector = Complex Double\n\neps :: Double\neps = 1e-7\n\ndot :: Vector -> Vector -> Double\ndot a b = realPart $ conjugate a * b\n\ncross :: Vector -> Vector -> Double\ncross a b = imagPart $ conjugate a * b\n\nreadWords :: Read a => IO [a]\nreadWords = map read . words <$> getLine\n\ndata Line = Line {\n  a :: Double,\n  b :: Double,\n  c :: Double\n}\n\ndata LineSeg = LineSeg {\n  p :: Point,\n  q :: Point,\n  l :: Line\n}\n\nmkLine :: Point -> Point -> Line\nmkLine p1@(x:+y) p2 = Line a b c where\n  (nx:+ny) = (p2-p1)*(0:+1)\n  a = nx\n  b = ny\n  c = -(a*x+b*y)\n\nmkLineSeg :: Point -> Point -> LineSeg\nmkLineSeg p1 p2 = LineSeg p1 p2 $ mkLine p1 p2\n\nintersect :: Line -> Line -> Maybe Point\nintersect (Line a1 b1 c1) (Line a2 b2 c2)\n  | abs ((a1:+b1)`cross`(a2:+b2)) < eps = Nothing\n  | otherwise = Just (x/det:+y/det)\n  where\n    det = a1*b2-b1*a2\n    x = c2*b1-c1*b2\n    y = a2*c1-a1*c2\n\nintersectLS :: LineSeg -> LineSeg -> Maybe Point\nintersectLS (LineSeg p1 q1 l1) (LineSeg p2 q2 l2)\n  | cpM == Nothing && q1 == p2 = Just q1\n  | cpM == Nothing && p1 == q2 = Just p1\n  | cpM == Nothing = Nothing\n  | onSeg p1 q1 cp && onSeg p2 q2 cp = Just cp\n  | otherwise = Nothing\n  where\n    cpM = intersect l1 l2\n    cp = fromJust cpM\n    onSeg p q cp = (cp-p)`dot`(cp-q) < eps\n\nmain :: IO ()\nmain = do\n  q <- readLn\n  qs <- replicateM q $ do\n    [x0,y0,x1,y1,x2,y2,x3,y3] <- readWords :: IO [Double]\n    let\n      p0 = x0:+y0\n      p1 = x1:+y1\n      p2 = x2:+y2\n      p3 = x3:+y3\n    return (p0,p1,p2,p3)\n\n  forM_ qs $ \\(p0,p1,p2,p3) -> do\n    let cp = intersectLS (mkLineSeg p0 p1) (mkLineSeg p2 p3)\n\n    print $ if cp == Nothing\n      then 0\n      else 1"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.Ratio ((%))\n\ndata Line = Vert Rational | Line { slope :: Rational\n                               , interact :: Rational\n                               } deriving Show\n\nmain = do\n  n <- readLn\n  replicateM_ n solve\n\nsolve :: IO ()\nsolve = do\n  [x0,y0,x1,y1,x2,y2,x3,y3] <- fmap (map read.words) getLine\n  let (l1,l2) = (corrLine (x0,y0) (x1,y1), corrLine (x2,y2) (x3,y3))\n  putStrLn $ isCross l1 l2\n\nisCross l1 l2 = if isParallel l1 l2 then \"0\"\n                                    else \"1\"\n\nisVert :: Line -> Bool\nisVert (Vert _) = True\nisVert (Line _ _) = False\n\nisParallel :: Line -> Line -> Bool\nisParallel l1 l2\n  | isVert l1 = isVert l2\n  | isVert l2 = False\n  | otherwise = slope l1 == slope l2\n\nisOrthogonal :: Line -> Line -> Bool\nisOrthogonal l1 l2\n  | isVert l1 && isVert l2 = False\n  | isVert l1 = slope l2 == 0\n  | isVert l2 = slope l1 == 0\n  | otherwise = slope l1 * slope l2 == -1\n\ncorrLine :: (Integer,Integer) -> (Integer, Integer) -> Line\ncorrLine (x1,y1) (x2,y2)\n  | x1 == x2 = Vert (x1%1)\n  | otherwise = Line a b\n  where a = (y2 - y1) % (x2 - x1)\n        b = (y1%1) - a*(x1%1)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad\nimport Data.Complex\nimport Data.List ((\\\\), nub)\nimport Data.Maybe\n\ntype Point = Complex Double\ntype Vector = Complex Double\n\neps :: Double\neps = 1e-7\n\ndot :: Vector -> Vector -> Double\ndot a b = realPart $ conjugate a * b\n\ncross :: Vector -> Vector -> Double\ncross a b = imagPart $ conjugate a * b\n\nreadWords :: Read a => IO [a]\nreadWords = map read . words <$> getLine\n\ndata Line = Line {\n  a :: Double,\n  b :: Double,\n  c :: Double\n}\n\ndata LineSeg = LineSeg {\n  p :: Point,\n  q :: Point,\n  l :: Line\n}\n\nmkLine :: Point -> Point -> Line\nmkLine p1@(x:+y) p2 = Line a b c where\n  (nx:+ny) = (p2-p1)*(0:+1)\n  a = nx\n  b = ny\n  c = -(a*x+b*y)\n\nmkLineSeg :: Point -> Point -> LineSeg\nmkLineSeg p1 p2 = LineSeg p1 p2 $ mkLine p1 p2\n\nintersect :: Line -> Line -> Maybe Point\nintersect (Line a1 b1 c1) (Line a2 b2 c2)\n  | abs ((a1:+b1)`cross`(a2:+b2)) < eps = Nothing\n  | otherwise = Just (x/det:+y/det)\n  where\n    det = a1*b2-b1*a2\n    x = c2*b1-c1*b2\n    y = a2*c1-a1*c2\n\nintersectLS :: LineSeg -> LineSeg -> Maybe Point\nintersectLS (LineSeg p1 q1 l1) (LineSeg p2 q2 l2)\n  | cpM == Nothing && not (null dup) = Just (head dup)\n  | cpM == Nothing = Nothing\n  | onSeg p1 q1 cp && onSeg p2 q2 cp = Just cp\n  | otherwise = Nothing\n  where\n    cpM = intersect l1 l2\n    cp = fromJust cpM\n    onSeg p q cp = (cp-p)`dot`(cp-q) < eps\n    pts = [p1,q1,p2,q2]\n    dup = pts \\\\ nub pts\nmain :: IO ()\nmain = do\n  q <- readLn\n  qs <- replicateM q $ do\n    [x0,y0,x1,y1,x2,y2,x3,y3] <- readWords :: IO [Double]\n    let\n      p0 = x0:+y0\n      p1 = x1:+y1\n      p2 = x2:+y2\n      p3 = x3:+y3\n    return (p0,p1,p2,p3)\n\n  forM_ qs $ \\(p0,p1,p2,p3) -> do\n    let cp = intersectLS (mkLineSeg p0 p1) (mkLineSeg p2 p3)\n\n    print $ if cp == Nothing\n      then 0\n      else 1"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad\nimport Data.Complex\nimport Data.List ((\\\\), nub, sort)\nimport Data.Maybe\n\ntype Point = Complex Double\ntype Vector = Complex Double\n\neps :: Double\neps = 1e-7\n\ndot :: Vector -> Vector -> Double\ndot a b = realPart $ conjugate a * b\n\ncross :: Vector -> Vector -> Double\ncross a b = imagPart $ conjugate a * b\n\nnormalize :: Vector -> Vector\nnormalize = signum\n\nreadWords :: Read a => IO [a]\nreadWords = map read . words <$> getLine\n\ndata Line = Line {\n  a :: Double,\n  b :: Double,\n  c :: Double\n}\n\ndata LineSeg = LineSeg {\n  p :: Point,\n  q :: Point,\n  l :: Line\n}\n\nmkLine :: Point -> Point -> Line\nmkLine p1@(x:+y) p2 = Line a b c where\n  (nx:+ny) = (p2-p1)*(0:+1)\n  a = nx\n  b = ny\n  c = -(a*x+b*y)\n\nmkLineSeg :: Point -> Point -> LineSeg\nmkLineSeg p1 p2 = LineSeg p1 p2 $ mkLine p1 p2\n\nintersect :: Line -> Line -> Maybe Point\nintersect (Line a1 b1 c1) (Line a2 b2 c2)\n  | abs ((a1:+b1)`cross`(a2:+b2)) < eps = Nothing\n  | otherwise = Just (x/det:+y/det)\n  where\n    det = a1*b2-b1*a2\n    x = c2*b1-c1*b2\n    y = a2*c1-a1*c2\n\nintersectLS :: LineSeg -> LineSeg -> Maybe Point\nintersectLS (LineSeg p1 q1 l1) (LineSeg p2 q2 l2)\n  | cpM == Nothing && online && t1 <= t4 && t3 <= t2 = Just p1\n  | cpM == Nothing = Nothing\n  | onSeg p1 q1 cp && onSeg p2 q2 cp = Just cp\n  | otherwise = Nothing\n  where\n    cpM = intersect l1 l2\n    cp = fromJust cpM\n    onSeg p q cp = (cp-p)`dot`(cp-q) < eps\n    [t1',t2',t3',t4'] = map (`dot` (normalize (q1-p1))) [p1,q1,p2,q2]\n    [t1,t2] = sort [t1',t2']\n    [t3,t4] = sort [t3',t4']\n    proj p q r = p+((r-p)`dot`d:+0)*d where\n      d = normalize (q-p)\n    online = magnitude (p2-proj p1 q1 p2) < eps\n    \nmain :: IO ()\nmain = do\n  q <- readLn\n  qs <- replicateM q $ do\n    [x0,y0,x1,y1,x2,y2,x3,y3] <- readWords :: IO [Double]\n    let\n      p0 = x0:+y0\n      p1 = x1:+y1\n      p2 = x2:+y2\n      p3 = x3:+y3\n    return (p0,p1,p2,p3)\n\n  forM_ qs $ \\(p0,p1,p2,p3) -> do\n    let cp = intersectLS (mkLineSeg p0 p1) (mkLineSeg p2 p3)\n\n    print $ if cp == Nothing\n      then 0\n      else 1"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad\nimport Data.Complex\nimport Data.Maybe\n\ntype Point = Complex Double\ntype Vector = Complex Double\n\neps :: Double\neps = 1e-7\n\ndot :: Vector -> Vector -> Double\ndot a b = realPart $ conjugate a * b\n\ncross :: Vector -> Vector -> Double\ncross a b = imagPart $ conjugate a * b\n\nreadWords :: Read a => IO [a]\nreadWords = map read . words <$> getLine\n\ndata Line = Line {\n  a :: Double,\n  b :: Double,\n  c :: Double\n}\n\ndata LineSeg = LineSeg {\n  p :: Point,\n  q :: Point,\n  l :: Line\n}\n\nmkLine :: Point -> Point -> Line\nmkLine p1@(x:+y) p2 = Line a b c where\n  (nx:+ny) = (p2-p1)*(0:+1)\n  a = nx\n  b = ny\n  c = -(a*x+b*y)\n\nmkLineSeg :: Point -> Point -> LineSeg\nmkLineSeg p1 p2 = LineSeg p1 p2 $ mkLine p1 p2\n\nintersect :: Line -> Line -> Maybe Point\nintersect (Line a1 b1 c1) (Line a2 b2 c2)\n  | abs ((a1:+b1)`cross`(a2:+b2)) < eps = Nothing\n  | otherwise = Just (x/det:+y/det)\n  where\n    det = a1*b2-b1*a2\n    x = c2*b1-c1*b2\n    y = a2*c1-a1*c2\n\nintersectLS :: LineSeg -> LineSeg -> Maybe Point\nintersectLS (LineSeg p1 q1 l1) (LineSeg p2 q2 l2)\n  | cpM == Nothing = Nothing\n  | onSeg p1 q1 cp && onSeg p2 q2 cp = Just cp\n  | otherwise = Nothing\n  where\n    cpM = intersect l1 l2\n    cp = fromJust cpM\n    onSeg p q cp = (cp-p)`dot`(cp-q) < eps\n\nmain :: IO ()\nmain = do\n  q <- readLn\n  qs <- replicateM q $ do\n    [x0,y0,x1,y1,x2,y2,x3,y3] <- readWords :: IO [Double]\n    let\n      p0 = x0:+y0\n      p1 = x1:+y1\n      p2 = x2:+y2\n      p3 = x3:+y3\n    return (p0,p1,p2,p3)\n\n  forM_ qs $ \\(p0,p1,p2,p3) -> do\n    let cp = intersectLS (mkLineSeg p0 p1) (mkLineSeg p2 p3)\n\n    print $ if cp == Nothing\n      then 0\n      else 1"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.Ratio ((%))\n\ndata Line = Vert {pos :: Rational, low :: Rational, high :: Rational} | Line { slope :: Rational\n                                                                             , intersect :: Rational\n                                                                             , left :: Rational\n                                                                             , right :: Rational\n                                                                             } deriving Show\n\nmain = do\n  n <- readLn\n  replicateM_ n solve\n\nsolve :: IO ()\nsolve = do\n  [x0,y0,x1,y1,x2,y2,x3,y3] <- fmap (map read.words) getLine\n  let (l1,l2) = (corrLine (x0,y0) (x1,y1), corrLine (x2,y2) (x3,y3))\n  putStrLn $ isCross l1 l2\n\nisCross l1 l2 = if isParallel l1 l2 then \"0\"\n                                    else checkCross l1 l2\n\ncheckCross l1 l2\n  | isVert l1 = vertCheck l1 l2\n  | isVert l2 = vertCheck l2 l1 \n  | otherwise = lineCheck l1 l2\n\nvertCheck (Vert x l h) line@(Line sl i s b)\n  | highest < s || lowest > h = \"0\"\n  | b < x || s > x = \"0\"\n  | y' >= l && y' <= h = \"1\"\n  | otherwise = \"0\"\n  where highest = getY line s `max` getY line b\n        lowest = getY line s `min` getY line b\n        y' = getY line x\n\nlineCheck l1 l2\n  | left l1 > right l2 || left l2 > right l2 = \"0\"\n  | highl1 < lowl2 || highl2 < lowl2 = \"0\"\n  | otherwise = \"1\"\n  where highl1 = getY l1 (left l1) `max` getY l1 (right l1)\n        lowl1  = getY l1 (left l1) `min` getY l1 (right l1)\n        highl2 = getY l2 (left l2) `max` getY l2 (right l2)\n        lowl2  = getY l2 (left l2) `min` getY l2 (right l2)\n\n\ngetY :: Line -> Rational ->Rational\ngetY l1 x = slope l1 * x + intersect l1\n\nisVert :: Line -> Bool\nisVert (Vert _ _ _) = True\nisVert (Line _ _ _ _) = False\n\nisParallel :: Line -> Line -> Bool\nisParallel l1 l2\n  | isVert l1 = isVert l2\n  | isVert l2 = False\n  | otherwise = slope l1 == slope l2\n\nisOrthogonal :: Line -> Line -> Bool\nisOrthogonal l1 l2\n  | isVert l1 && isVert l2 = False\n  | isVert l1 = slope l2 == 0\n  | isVert l2 = slope l1 == 0\n  | otherwise = slope l1 * slope l2 == -1\n\ncorrLine :: (Integer,Integer) -> (Integer, Integer) -> Line\ncorrLine (x1,y1) (x2,y2)\n  | x1 == x2 = Vert (x1%1) (min (y1%1) (y2%1)) (max (y1%1) (y2%2))\n  | otherwise = Line a b (min (x1%1) (x2%1)) (max (x1%1) (x2%2))\n  where a = (y2 - y1) % (x2 - x1)\n        b = (y1%1) - a*(x1%1)"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport qualified Data.ByteString.Char8 as B\nimport           Text.Printf\n\nreadi :: B.ByteString -> Int\nreadi b | Just (n, _) <- B.readInt b = n\n\n--\n\nnewtype VDouble =\n    VDouble Double\n    deriving (Show, Read, Num, Floating, Fractional)\n\ninstance Eq VDouble where\n    VDouble a == VDouble b = abs (a - b) < 1e-10\n\ninstance Ord VDouble where\n    VDouble a `compare` VDouble b\n        | VDouble a == VDouble b = EQ\n        | a <  b                 = LT\n        | otherwise              = GT\n\n--\n\nnewtype V2 =\n    V2 (VDouble, VDouble)\n    deriving (Show)\n\n(|+|) :: V2 -> V2 -> V2\nV2 (a, b) |+| V2 (c, d) = V2 (a + c, b + d)\n\n(|-|) :: V2 -> V2 -> V2\nV2 (a, b) |-| V2 (c, d) = V2 (a - c, b - d)\n\n(*|) :: VDouble -> V2 -> V2\nk *| V2 (c, d) = V2 (k * c, k * d)\n\nnorm :: V2 -> VDouble\nnorm (V2 (a, b)) = a * a + b * b\n\nabs' :: V2 -> VDouble\nabs' = sqrt . norm\n\ndot :: V2 -> V2 -> VDouble\nV2 (a, b) `dot` V2 (c, d) = a * c + b * d\n\ncross :: V2 -> V2 -> VDouble\nV2 (a, b) `cross` V2 (c, d) = a * d - b * c\n\n--\n\ndata Wise\n    = COUNTER_CLOCKWISE\n    | CLOCKWISE\n    | ONLINE_BACK\n    | ONLINE_FRONT\n    | ON_SEGMENT\n    deriving (Show)\n\nw2i :: Wise -> Int\nw2i COUNTER_CLOCKWISE = 1\nw2i CLOCKWISE         = -1\nw2i ONLINE_BACK       = 2\nw2i ONLINE_FRONT      = -2\nw2i ON_SEGMENT        = 0\n\nccw :: V2 -> V2 -> V2 -> Wise\nccw p0 p1 p2\n    | cross a b > 0   = COUNTER_CLOCKWISE\n    | cross a b < 0   = CLOCKWISE\n    | dot a b < 0     = ONLINE_BACK\n    | norm a < norm b = ONLINE_FRONT\n    | otherwise       = ON_SEGMENT\n  where\n    a = p1 |-| p0\n    b = p2 |-| p0\n\nintersect :: V2 -> V2 -> V2 -> V2 -> Bool\nintersect p0 p1 p2 p3 = b1 && b2\n  where\n    b1 = w2i (ccw p0 p1 p2) * w2i (ccw p0 p1 p3) <= 0\n    b2 = w2i (ccw p2 p3 p0) * w2i (ccw p2 p3 p1) <= 0\n\nmain :: IO ()\nmain = do\n    q <- readLn\n    replicateM_ q $ do\n        [a, b, c, d, e, f, g, h] <-\n            fmap (fromIntegral . readi) . B.words <$> B.getLine\n        let p0 = V2 (a, b)\n        let p1 = V2 (c, d)\n        let p2 = V2 (e, f)\n        let p3 = V2 (g, h)\n        if intersect p0 p1 p2 p3\n            then putStrLn \"1\"\n            else putStrLn \"0\"\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PREC 1e-12\n\nint main() {\n    int x, y, x0, y0, x1, y1, x2, y2, x3, y3;\n    int q;\n    double s, t, num1, num2, denom;\n    int judge;\n\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d %d %d %d %d %d %d %d\",\n              &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        num1 = (y3-y2)*(x2-x0)-(x3-x2)*(y2-y0);\n        num2 = (y1-y0)*(x2-x0)-(x1-x0)*(y2-y0);\n        denom = (x1-x0)*(y3-y2) - (y1-y0)*(x3-x2);\n        if (fabs(denom) < PREC) {\n            if (fabs(num1) < PREC && fabs(num2) < PREC)\n                judge = 1;\n            else\n                judge = 0;\n        }\n        else {\n            s = num1 / denom;\n            t = num2 / denom;\n            if (s < 0 || s > 1 || t < 0 || t > 1) {\n                judge = 0;\n            }\n            else {\n                judge = 1;\n            }\n        }\n        printf(\"%d\\n\", judge);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define swap( x, y ) do { double tmp; tmp = x; x = y; y = tmp; } while ( 0 )\n\nint rel_l_l( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\tswap( x0, x1 );\n\t\tswap( y0, y1 );\n\t}\n\tif ( x3 < x2 ) {\n\t\tswap( x2, x3 );\n\t\tswap( y2, y3 );\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\tif ( x0 == x2 ) {\n\t\t\t\tif ( y1 < y0 )\n\t\t\t\t\tswap( y0, y1 );\n\t\t\t\tif ( y3 < y2 )\n\t\t\t\t\tswap( y2, y3 );\n\n\t\t\t\tif ( y3 < y0 || y1 < y2 )\n\t\t\t\t\trel = 3;\n\t\t\t\telse if ( y3 == y0 || y1 == y2 ) {\n\t\t\t\t\t*y = y3 == y0 ? y0 : y1;\n\t\t\t\t\trel = 4;\n\t\t\t\t} else\n\t\t\t\t\trel = 5;\n\t\t\t} else\n\t\t\t\trel = 2;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\t*y = a * *x + b;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else {\n\t\t\tif ( a == c ) {\n\t\t\t\tif ( b == d )\n\t\t\t\t\tif ( x3 < x0 || x1 < x2 )\n\t\t\t\t\t\trel = 3;\n\t\t\t\t\telse if ( x3 == x0 || x1 == x2 ) {\n\t\t\t\t\t\t*x = x3 == x0 ? x0 : x1;\n\t\t\t\t\t\trel = 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\trel = 5;\n\t\t\t\telse\n\t\t\t\t\trel = 2;\n\t\t\t} else {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t\t\t*y = a * *x + b;\n\t\t}\n\t}\n\n\treturn rel;\n}\n\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_l_l( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\n\t\tprintf( \"%d\\n\", rel == 1 || rel == 4 || rel == 5 ? 1 : 0 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\n\t\tif(ta*tb<=0 && tc*td<=0) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  return ((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid closs(double a1[2], double b1[2],\n            double a2[2], double b2[2],double ans[2]);\n\nint main(void)\n{\n    double a1[2], b1[2], a2[2], b2[2], ans[2];\n    int n, i;\n    double maxx1, minx1, maxx2, minx2, maxy1, miny1, maxy2, miny2;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n        scanf(\"%lf%lf%lf%lf\", &a1[0], &a1[1], &b1[0], &b1[1]);\n        scanf(\"%lf%lf%lf%lf\", &a2[0], &a2[1], &b2[0], &b2[1]);\n\n        closs(a1, b1, a2, b2, ans);\n\n        //printf(\"%lf\\n%lf\\n\", ans[0], ans[1]);\n\n        maxx1 = (a1[0] < b1[0]) ? b1[0] : a1[0];\n        minx1 = (a1[0] >= b1[0]) ? b1[0] : a1[0];\n        maxx2 = (a2[0] < b2[0]) ? b2[0] : a2[0];\n        minx2 = (a2[0] >= b2[0]) ? b2[0] : a2[0];\n        maxy1 = (a1[1] < b1[1]) ? b1[1] : a1[1];\n        miny1 = (a1[1] >= b1[1]) ? b1[1] : a1[1];\n        maxy2 = (a2[1] < b2[1]) ? b2[1] : a2[1];\n        miny2 = (a2[1] >= b2[1]) ? b2[1] : a2[1];\n\n        if (minx1 <= ans[0] && ans[0] <= maxx1\n                && minx2 <= ans[0] && ans[0] <= maxx2\n                && miny1 <= ans[1] && ans[1] <= maxy1\n                && miny2 <= ans[1] && ans[1] <= maxy2 ) {\n            puts(\"1\");\n        } else {\n            puts(\"0\");\n        }\n    }\n    return 0;\n}\n\nvoid closs(double a1[2], double b1[2],\n            double a2[2], double b2[2],double ans[2]) \n{\n    double s1, s2;\n\n    s1 = ((b2[0] - a2[0])*(a1[1] - a2[1]) \n            - ((b2[1] - a2[1])*(a1[0] - a2[0]))) / 2;\n\n    s2 = ((b2[0] - a2[0])*(a2[1] - b1[1]) \n            - ((b2[1] - a2[1])*(a2[0] - b1[0]))) / 2;\n\n    ans[0] = a1[0] + (b1[0] - a1[0])*s1/(s1 + s2);\n    ans[1] = a1[1] + (b1[1] - a1[1])*s1/(s1 + s2);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint is_crossing_line(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\n\tdouble S,T,D;\n\n\t//\t分母を先に計算。計算量を減らすため、分子は後で行う。\n\tD = (x3-x1) * (y4-y1) - (y3-y1) * (x4-x1);\n\t\n\t//\tD の符号に応じて分岐\n\tif(D < 0){\n\t\tS = (y4-y1)*(x2-x1) - (x4-x1)*(y2-y1);\n\t\tT = (x3-x1)*(y2-y1) - (y3-y1)*(x2-x1);\n\t\t\n\t\treturn S <= 0 && T <= 0 && (S+T)/D >= 1;\n\t}\n\telse if(D > 0){\n\t\tS = (y4-y1)*(x2-x1) - (x4-x1)*(y2-y1);\n\t\tT = (x3-x1)*(y2-y1) - (y3-y1)*(x2-x1);\n\t\t\n\t\treturn S >= 0 && T >= 0 && (S+T)/D >= 1;\n\t}\n\t\n\t//\tD = 0 の時には、点が線分の上かどうかを判定する。\n\treturn (x3-x1)*(x4-x1)+(y3-y1)*(y4-y1) <= 0\n\t    || (x3-x2)*(x4-x2)+(y3-y2)*(y4-y2) <= 0\n\t    || (x1-x3)*(x2-x3)+(y1-y3)*(y2-y3) <= 0;\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\n\t\tif(is_crossing_line(x1, y1, x2, y2, x3, y3, x4, y4)) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_2_B Intersection\n// 2018.5.2 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define INF\t\t\t1e8\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn hypot(p1.x-p2.x, p1.y-p2.y); };\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint ccw(PP p, PP q, PP r) {\n\tdouble dx, dy, dx_, dy_, t;\n\tdx  = q.x - p.x, dy  = q.y - p.y;\n\tdx_ = r.x - p.x, dy_ = r.y - p.y;\n\tt = dx * dy_ - dy * dx_;\n\tif (fabs(t) < EPS) return 0;\n\tif (t <= 0) return -1;\n\treturn 1;\n}\n\nint is_intersectSS(SEG s1, SEG s2)\n{\n\treturn ccw(s1.s, s1.e, s2.s) * ccw(s1.s, s1.e, s2.e) <= 0 &&\n\t\t   ccw(s2.s, s2.e, s1.s) * ccw(s2.s, s2.e, s1.e) <= 0;\n}\n\nint main()\n{\n\tint q, x, y;\n\tPP p0, p1, p2, p3;\n\tSEG s1, s2;\n\n\tq = in();\n\twhile (q--) {\n\t\tx = in(), y = in(), p0 = vset(x, y);\n\t\tx = in(), y = in(), p1 = vset(x, y);\n\t\tx = in(), y = in(), p2 = vset(x, y);\n\t\tx = in(), y = in(), p3 = vset(x, y);\n\t\ts1.s = p0, s1.e = p1;\n\t\ts2.s = p2, s2.e = p3;\n\t\tputchar('0' + is_intersectSS(s1, s2)), putchar('\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    if(x1 == x2 && x2 == x3 && x3 == x4){\n        l0 = (y1 - y3) * (y2 - y4);\n        l1 = (y1 - y4) * (y2 - y3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if(y1 == y2 && y2 == y3 && y3 == y4){\n        l0 = (x1 - x3) * (x2 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if((y2-y1)*(x4-x3) == (y4-y3)*(x2-x1)){\n        l0 = (x1 - x3) * (x2 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else{\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 <= 0 && l2 * l3 <= 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n    }\n}\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*(-x4)+y1*(-y4),d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=(-x4)*x7+(-y4)*y7;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4>0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x=p0[0],x0=p1[0]-x,x1=p2[0]-x,x2=p3[0]-x,x3=x2-x1,x6=x1-x0,x7=x2-x0;\n  long long y=p0[1],y0=p1[1]-y,y1=p2[1]-y,y2=p3[1]-y,y3=y2-y1,y6=y1-y0,y7=y2-y0;\n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y6-y3*x6)*(x3*y1-y3*x1);\n  long long d1=x1*x6+y1*y6,d2=x6*x7+y6*y7,d3=x2*x7+y2*y7,d4=x1*x2+y1*y2;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4>0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\n\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n                if ((v[0].x * v[1].x + v[0].y * v[1].y) < 0\n                        && (v[0].x * v[2].x + v[0].y * v[2].y) < 0) {\n                        return 1;\n                } else if ((v[0].x * v[1].x + v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) > 0){\n                        return 0;\n                } else {\n                        return -1;\n                }\n        }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint tf(int n) {\n        if(n < 0) return 0;\n        return 1;\n}\n\nint main(void) {\n        int i,j,k;\n        int kaisu;\n        int pm = 0;\n        int ans;\n        double sen[2][2][2];\n        double katamuki[3];\n        double temp;\n\n\n\n        scanf(\"%d\",&kaisu);\n\n        for(k = 0; k < kaisu; k++) {\n                for(i = 0; i < 2; i++) {\n                        for(j = 0; j < 2; j++) {\n                                scanf(\"%lf\",&sen[i][j][0]);\n                                scanf(\"%lf\",&sen[i][j][1]);\n                        }\n                }\n\n                katamuki[0] = (sen[0][1][1] - sen[0][0][1])  / (sen[0][1][0] - sen[0][0][0]);\n                katamuki[1] = (sen[1][0][1] - sen[0][0][1])  / (sen[1][0][0] - sen[0][0][0]);\n                katamuki[2] = (sen[1][1][1] - sen[0][0][1])  / (sen[1][1][0] - sen[0][0][0]);\n                if(katamuki[1] > katamuki[2]) {\n                        temp = katamuki[1];\n                        katamuki[1] = katamuki[2];\n                        katamuki[2] = temp;\n                }\n\n                if(katamuki[1] < 0 && katamuki[2] > 0) {\n                        if(katamuki[0] <= katamuki[1] && katamuki[0] >= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 0;\n                        }\n                }else {\n                        if(katamuki[0] >= katamuki[1] && katamuki[0] <= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 0;\n                        }\n                }\n                printf(\"%d\\n\",ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double *x, double *y ) {\n\tdouble numer = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\tdouble denom = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 );\n\n\tif ( fabs( denom ) < EPS )\n\t\tif ( fabs( numer ) < EPS ) {\n\t\t\tdouble h1 = x1 == x2 ? ( y3 - y1 ) / ( y2 - y1 ) : ( x3 - x1 ) / ( x2 - x1 );\n\t\t\tdouble h2 = x1 == x2 ? ( y4 - y1 ) / ( y2 - y1 ) : ( x4 - x1 ) / ( x2 - x1 );\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS ) {\n\t\t\t\t*x = x1;\n\t\t\t\t*y = y1;\n\t\t\t\treturn 4;\n\t\t\t} else if ( fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) ) {\n\t\t\t\t*x = x2;\n\t\t\t\t*y = y2;\n\t\t\t\treturn 4;\n\t\t\t} else if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse {\n\t\tdouble t = numer / denom;\n\t\tdouble s = ( ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) ) / denom;\n\n\t\tif ( fabs( t - 0.5 ) < 0.5 + EPS && fabs( s - 0.5 ) < 0.5 + EPS ) {\n\t\t\t*x = x1 + t * ( x2 - x1 );\n\t\t\t*y = y1 + t * ( y2 - y1 );\n\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 6;\n\t}\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 ) {\n\tdouble dn = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 );\n\tdouble nm = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\n\tif ( fabs( dn ) < EPS )\n\t\tif ( fabs( nm ) < EPS ) {\n\t\t\tdouble norm = hypot( x2 - x1, y2 - y1 );\n\t\t\t// double h1 = x1 == x2 ? ( y3 - y1 ) / ( y2 - y1 ) : ( x3 - x1 ) / ( x2 - x1 );\n\t\t\tdouble h1 = hypot( x3 - x1, y3 - y1 ) / norm;\n\t\t\t// double h2 = x1 == x2 ? ( y4 - y1 ) / ( y2 - y1 ) : ( x4 - x1 ) / ( x2 - x1 );\n\t\t\tdouble h2 = hypot( x4 - x1, y4 - y1 ) / norm;\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS ) {\n\t\t\t\treturn 4;\n\t\t\t} else if ( fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) ) {\n\t\t\t\treturn 4;\n\t\t\t} else if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse\n\t\tif ( fabs( nm / dn - 0.5 ) < 0.5 + EPS && fabs( ( ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) ) / dn - 0.5 ) < 0.5 + EPS ) {\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 6;\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3 );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define max(a,b) a>b?a:b\n#define min(a,b) a<b?a:b\nint main(){\n    int n,ax,ay,bx,by,cx,cy,dx,dy;\n    double x,y,t;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n        t=(double)((cx-ax)*(dy-cy)-(cy-ay)*(dx-cx))/(double)((bx-ax)*(dy-cy)-(by-ay)*(dx-cx));\n        x=ax+t*(bx-ax);\n        y=ay+t*(by-ay);\n        if((double)(min(ax,bx))<=x&&x<=(double)(max(ax,bx))&&(double)(min(ay,by))<=y&&y<=(double)(max(ay,by))){\n            if((double)(min(cx,dx))<=x&&x<=(double)(max(cx,dx))&&(double)(min(cy,dy))<=y&&y<=(double)(max(cy,dy)))printf(\"%d\\n\",1);\n        }else printf(\"%d\\n\",0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\n\t\tif(ta*tb<0 && tc*td<=0) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define max(a,b) a>b?a:b\n#define min(a,b) a<b?a:b\nint main(){\n    int n,ax,ay,bx,by,cx,cy,dx,dy;\n    double x,y,t;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n        t=(double)((cx-ax)*(dy-cy)-(cy-ay)*(dx-cx))/(double)((bx-ax)*(dy-cy)-(by-ay)*(dx-cx));\n        x=ax+t*(bx-ax);\n        y=ay+t*(by-ay);\n        if((double)(min(ax,bx))<=x&&x<=(double)(max(ax,bx))&&(double)(min(ay,by))<=y&&y<=(double)(max(ay,by))){\n            if((double)(min(cx,dx))<=x&&x<=(double)(max(cx,dx))&&(double)(min(cy,dy))<=y&&y<=(double)(max(cy,dy)))puts(\"1\");\n        }else puts(\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    l0 = (x1 - x2)*(x3 - x1) + (y1 - y2)*(y1 - y3);\n    l1 = (x1 - x2)*(x4 - x1) + (y1 - y2)*(y1 - y4);\n    l2 = (x3 - x4)*(x1 - x3) + (y3 - y4)*(y3 - y1);\n    l3 = (x3 - x4)*(x2 - x3) + (y3 - y4)*(y3 - y2);\n    if(l0 * l1 < 0 && l2 * l3 < 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        long long int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n        if ((v[0].x * v[1].x + v[0].y * v[1].y) < 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) < 0) {\n            return 1;\n        } else if ((v[0].x * v[1].x + v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) > 0){\n            return 0;\n        } else {\n            return -1;\n        }\n    }else if (ans < 0){\n        return -1;\n    } else {\n        return 1;\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        long int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n                if ((v[0].x * v[1].x + v[0].y * v[1].y) < 0\n                        && (v[0].x * v[2].x + v[0].y * v[2].y) < 0) {\n                        return 1;\n                } else if ((v[0].x * v[1].x + v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) > 0){\n                        return 0;\n                } else {\n                        return -1;\n                }\n        }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double *x, double *y ) {\n\tdouble numer = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\tdouble denom = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 );\n\n\tif ( fabs( denom ) < EPS )\n\t\tif ( fabs( numer ) < EPS ) {\n\t\t\tdouble h1 = ( x3 - x1 + y3 - y1 ) / ( x2 - x1 + y2 - y1 );\n\t\t\tdouble h2 = ( x4 - x1 + y4 - y1 ) / ( x2 - x1 + y2 - y1 );\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS ) {\n\t\t\t\t*x = x1;\n\t\t\t\t*y = y1;\n\t\t\t\treturn 4;\n\t\t\t} else if ( fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) ) {\n\t\t\t\t*x = x2;\n\t\t\t\t*y = y2;\n\t\t\t\treturn 4;\n\t\t\t} else if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse {\n\t\tdouble t = numer / denom;\n\t\tdouble s = ( ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) ) / denom;\n\n\t\tif ( fabs( t - 0.5 ) < 0.5 + EPS && fabs( s - 0.5 ) < 0.5 + EPS ) {\n\t\t\t*x = x1 + t * ( x2 - x1 );\n\t\t\t*y = y1 + t * ( y2 - y1 );\n\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 6;\n\t}\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x0, y0, x1, y1, x2, y2, x3, y3, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n    l0 = (x1 - x2)*(x3 - x1) + (y1 - y2)*(y1 - y3);\n    l1 = (x1 - x2)*(x4 - x1) + (y1 - y2)*(y1 - y4);\n    l2 = (x3 - x4)*(x1 - x3) + (y3 - y4)*(y3 - y1);\n    l3 = (x3 - x4)*(x2 - x3) + (y3 - y4)*(y3 - y2);\n    if(l0 * l1 < 0 && l2 * l3 < 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?b:a\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\ntypedef struct LINE{\n\tPOINT s;//start point\n\tPOINT e;//end point\n}LINE;\ntypedef struct COMPLEX{\n\tdouble r;//?????¢\n\tdouble q;//????§???????theta\n}COMPLEX;\n\n//POINT????????????\nvoid print_p(POINT a){\n\tprintf(\"(%lf,%lf)\\n\",a.x,a.y);\n}\n\n//LINE????????????\nvoid print_l(LINE a){\n\tprintf(\"(%lf,%lf) -> (%lf,%lf)\\n\",(a.s).x,(a.s).y,(a.e).x,(a.e).y);\n}\n\n//COMPLEX????????????\nvoid print_c(COMPLEX a){\n\tprintf(\"(%lf,%lf)\\n\",a.r,a.q);\n}\n\n//????????????????????¢?????????\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\n//2???a,b???????????¢\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n//??´??§????????????\nPOINT sum_vec(POINT a,POINT b){\n\ta.x += b.x;\n\ta.y += b.y;\n\treturn a;\n}\n\n//??´??§????????????\n//mkae_vec??¨?????£??????????????¨???????????????\n//??????????????????\nPOINT dif_vec(POINT a,POINT b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\treturn a;\n}\n\n//??´??§????????????????????????\nPOINT scalar_vec(POINT a,double k){\n\ta.x *= k;\n\ta.y *= k;\n\treturn a;\n}\n\n//???????????????\nPOINT minus_vec(POINT a){\n\treturn scalar_vec(a,-1.0);\n}\n\n//??????\ndouble dot(POINT a,POINT b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//??????\ndouble cross(POINT a,POINT b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\n//AP:PB=t:s??¨?????????????±???????\n//k, 0:??????, 1:??????\n//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???\nPOINT division(POINT a,POINT b,double t,double s,int k){\n\tdouble tmp = t + s * (1 - k*2);\n\ta.x += (make_vec(a,b)).x / tmp * t;\n\ta.y += (make_vec(a,b)).y / tmp * t;\n\treturn a;\n}\n\n//???p????????´???a?????????????????????????¶??????????\nPOINT perpendicular(LINE a,POINT p){\n\tPOINT ps = make_vec(p,a.s);\n\tPOINT pe = make_vec(p,a.e);\n\tdouble t = norm2(ps) - dot(ps,pe);\n\tdouble s = norm2(pe) - dot(ps,pe);\n\treturn division(a.s,a.e,t,s,0);\n}\n\n//??´???a???????????????p??¨????§°???????????????\nPOINT reflection(LINE a,POINT p){\n\tPOINT h = perpendicular(a,p);\n\treturn sum_vec(h,make_vec(p,h));\n}\n\n//* ????§???¢?????????\nint inclusion(POINT a[],int n,POINT p){\n\tint ans = 0;\n\tint i;\n\tPOINT g[n+1];\n\tdouble w,rad = 0.0;\n\n\tfor(i = 0;i < n;i++){\n\t\tg[i] = a[i];\n\t}\n\tg[n] = g[0];\n\n\tfor(i = 0;i < n;i++){\n\t\tif(g[i].x == p.x && g[i].y == p.y){\n\t\t\treturn ans = 1;\n\t\t}\n\t}\n\tfor(i = 0;i < n;i++){\n\t\tw = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),\n\t\t\t\tdot(make_vec(p,g[i]),make_vec(p,g[i+1])));\n\t\trad += w;\n\t\tif(fabs(w - M_PI) <= 0.000001 ||\n\t\t\t fabs(w + M_PI) <= 0.000001)\n\t\t\treturn ans = 1;\n\t}\n\tif(fabs(rad - M_PI*2)<=0.000001){//2??\n\t\treturn ans = 2;//in!\n\t}\n\treturn ans;\n}\n\n// a.s, a.e, p?????????????????????\n// ???????¨???????????????????????????????  1\n// ????¨?????????????????????????????????? -1\n// p, a.s, a.e????????????????????? 2\n// a.s, a.e, p?????????????????????-2\n// ???p?????´???a???????????????????????? 0\nint ccw(LINE a,POINT p){\n\tint cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));\n\tif(cls > 0){\n\t\treturn  1;\n\t}else if(cls < 0){\n\t\treturn -1;\n\t}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0){\n\t\treturn  2;\n\t}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0){\n\t\treturn -2;\n\t}else{\n\t\treturn  0;\n\t}\n}\n\n// ??????????????????\nint parallel(LINE a,LINE b){\n\tif(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ?????´????????????\nint orthogonal(LINE a,LINE b){\n\tif(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n// ??????a,b???????????????????????????\nint intersection(LINE a,LINE b){\n\tif(ccw(a,b.s)*ccw(a,b.e) <= 0 &&\n\t   ccw(b,a.s)*ccw(b,a.e) <= 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nint main(){\n\tLINE a,b;\n\tint k;\n\tscanf(\"%d\",&k);\n\twhile(k--){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.s.x,&a.s.y,&a.e.x,&a.e.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&b.s.x,&b.s.y,&b.e.x,&b.e.y);\n\t\tprintf(\"%d\\n\",intersection(a,b));\n\t}\n/*\n\tPOINT a,b,q;\n\tdouble t,s;\n\n\tscanf(\"%lf%lf%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y,&t,&s);\n\n\tq = division(a,b,t,s,0);\n\tprintf(\"%lf %lf\\n\",q.x,q.y);\n*/\n/*\n\tLINE a;\n\tPOINT b;\n\tint k;\n\tchar s[5][100]={{\"ONLINE_FRONT\"},{\"CLOCKWISE\"},{\"ON_SEGMENT\"},{\"COUNTER_CLOCKWISE\"},{\"ONLINE_BACK\"}};\n\t\n\tscanf(\"%lf%lf%lf%lf%d\",&a.s.x,&a.s.y,&a.e.x,&a.e.y,&k);\n\twhile(k--){\n\t\tscanf(\"%lf%lf\",&b.x,&b.y);\n\t\tprintf(\"%s\\n\",s[ccw(a,b)+2]);\n\t}\n*/\n/*\n\tPOINT a,b;\n\tint k;\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf%d\",&a.x,&a.y,&b.x,&b.y,&k);\n\t\tprint_p(sum_vec(a,b));\n\t\tprint_p(dif_vec(a,b));\n\t\tprint_p(scalar_vec(a,k));\n\t\tprint_p(minus_vec(a));\n\t}\n*/\n/*\n\tPOINT a,b;\n\twhile(1){\n\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tprintf(\"%lf\\n\",distance(a,b));\n\t}\n*/\n/*\n\tint i,m,n;\n\tPOINT g[100];//n\n\tPOINT q;//m\n\tint ans = 0;\n\n\tscanf(\"%d\",&n);\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%lf%lf\",&g[i].x,&g[i].y);\n\t}\n\tscanf(\"%d\",&m);\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%lf%lf\",&q.x,&q.y);\n\t\tans = inclusion(g,n,q);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n*/\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double *x, double *y ) {\n\tdouble numer = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\tdouble denom = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 );\n\n\tif ( fabs( denom ) < EPS )\n\t\tif ( fabs( numer ) < EPS ) {\n\t\t\tdouble h1, h2;\n\n\t\t\tif ( x1 == x2 ) {\n\t\t\t\th1 = ( y3 - y1 ) / ( y2 - y1 );\n\t\t\t\th2 = ( y4 - y1 ) / ( y2 - y1 );\n\t\t\t} else {\n\t\t\t\th1 = ( x3 - x1 ) / ( x2 - x1 );\n\t\t\t\th2 = ( x4 - x1 ) / ( x2 - x1 );\n\t\t\t}\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS ) {\n\t\t\t\t*x = x1;\n\t\t\t\t*y = y1;\n\t\t\t\treturn 4;\n\t\t\t} else if ( fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) ) {\n\t\t\t\t*x = x2;\n\t\t\t\t*y = y2;\n\t\t\t\treturn 4;\n\t\t\t} else if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse {\n\t\tdouble t = numer / denom;\n\t\tdouble s = ( ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) ) / denom;\n\n\t\tif ( fabs( t - 0.5 ) < 0.5 + EPS && fabs( s - 0.5 ) < 0.5 + EPS ) {\n\t\t\t*x = x1 + t * ( x2 - x1 );\n\t\t\t*y = y1 + t * ( y2 - y1 );\n\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 6;\n\t}\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n\ntypedef struct Point{ll x,y;}P;\ntypedef struct line{P p1,p2;}L;\nint sgn(ll x){return x<0?-1:x>0;}\n\nint iscross(L s,L t){\n\t//点(p,q)が直線f(x,y)=ax+by+c=0のどっち側にあるかはf(p,q)を見ればよい\n\t//点(x1,y1),(x2,y2)を結ぶ直線の式は(y2-y1)*(x-x1)+(x2-x1)*(y1-y)=0\n\tll t1=(s.p2.y-s.p1.y)*(t.p1.x-s.p1.x)+(s.p2.x-s.p1.x)*(s.p1.y-t.p1.y);\n\tll t2=(s.p2.y-s.p1.y)*(t.p2.x-s.p1.x)+(s.p2.x-s.p1.x)*(s.p1.y-t.p2.y);\n\tll t3=(t.p2.y-t.p1.y)*(s.p1.x-t.p1.x)+(t.p2.x-t.p1.x)*(t.p1.y-s.p1.y);\n\tll t4=(t.p2.y-t.p1.y)*(s.p2.x-t.p1.x)+(t.p2.x-t.p1.x)*(t.p1.y-s.p2.y);\n\t//同一直線上にない\n\tif(t1 || t2)return sgn(t1)!=sgn(t2) && sgn(t3)!=sgn(t4);\n\t//同一直線上にある\n\tll c1=(s.p2.x-s.p1.x)*(s.p2.x-s.p1.x)+(s.p2.y-s.p1.y)*(s.p2.y-s.p1.y);\n\tll c2=(t.p1.x-s.p1.x)*(s.p2.x-s.p1.x)+(t.p1.y-s.p1.y)*(s.p2.y-s.p1.y);\n\tll c3=(t.p2.x-s.p1.x)*(s.p2.x-s.p1.x)+(t.p2.y-s.p1.y)*(s.p2.y-s.p1.y);\n\tif(0<=c2&&c2<=c1 || 0<=c3&&c3<=c1 || c2<=0&&c1<=c3 || c3<=0&&c1<=c2)return 1;\n\treturn 0;\n}\n\nint main(){\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tL s,t;\n\t\tfor(int i=0;i<2;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",&s.p1.x,&s.p1.y,&s.p2.x,&s.p2.y);\n\t\t\tif(!i)t=s;\n\t\t}\n\t\tprintf(\"%d\\n\",iscross(s,t));\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define swap( x, y ) do { double tmp; tmp = x; x = y; y = tmp; } while ( 0 )\n\nint rel_l_l( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\tswap( x0, x1 );\n\t\tswap( y0, y1 );\n\t}\n\tif ( x3 < x2 ) {\n\t\tswap( x2, x3 );\n\t\tswap( y2, y3 );\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\tif ( x0 == x2 ) {\n\t\t\t\tif ( y1 < y0 )\n\t\t\t\t\tswap( y0, y1 );\n\t\t\t\tif ( y3 < y2 )\n\t\t\t\t\tswap( y2, y3 );\n\n\t\t\t\tif ( y3 < y0 || y1 < y2 )\n\t\t\t\t\trel = 3;\n\t\t\t\telse if ( y3 == y0 || y1 == y2 ) {\n\t\t\t\t\t*y = y3 == y0 ? y0 : y1;\n\t\t\t\t\trel = 4;\n\t\t\t\t} else\n\t\t\t\t\trel = 5;\n\t\t\t} else\n\t\t\t\trel = 2;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\t*y = a * *x + b;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else {\n\t\t\tif ( a == c ) {\n\t\t\t\tif ( b == d )\n\t\t\t\t\tif ( x3 < x0 || x1 < x2 )\n\t\t\t\t\t\trel = 3;\n\t\t\t\t\telse if ( x3 == x0 || x1 == x2 ) {\n\t\t\t\t\t\t*x = x3 == x0 ? x0 : x1;\n\t\t\t\t\t\trel = 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\trel = 5;\n\t\t\t\telse\n\t\t\t\t\trel = 2;\n\t\t\t} else {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t\t\t*y = a * *x + b;\n\t\t}\n\t}\n\n\treturn rel;\n}\n\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_l_l( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\n\t\tprintf( \"%d\\n\", rel == 1 || rel == 4 ? 1 : 0 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\n\t\tif((fabs(x1-x3)<0.0001) && fabs(y1-y3)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x1-x4)<0.0001) && fabs(y1-y4)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x2-x3)<0.0001) && fabs(y2-y3)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x2-x4)<0.0001) && fabs(y2-y4)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if(ta*tb<=0 && tc*td<=0) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\n\t\tif((fabs(x1-x3)<0.0001) && fabs(y1-y3)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x1-x4)<0.0001) && fabs(y1-y4)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x2-x3)<0.0001) && fabs(y2-y3)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if((fabs(x2-x4)<0.0001) && fabs(y2-y4)<0.0001) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else if(ta*tb<0 && tc*td<=0) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define max(a,b) a>b?a:b\n#define min(a,b) a<b?a:b\nint main(){\n    int n,ax,ay,bx,by,cx,cy,dx,dy;\n    double x,y,t;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n        t=(double)((cx-ax)*(dy-cy)-(cy-ay)*(dx-cx))/(double)((bx-ax)*(dy-cy)-(by-ay)*(dx-cx));\n        x=ax+t*(bx-ax);\n        y=ay+t*(by-ay);\n        if((double)(min(ax,bx))<=x&&x<=(double)(max(ax,bx))&&(double)(min(ay,by))<=y&&y<=(double)(max(ay,by))){\n            if((double)(min(cx,dx))<=x&&x<=(double)(max(cx,dx))&&(double)(min(cy,dy))<=y&&y<=(double)(max(cy,dy)))printf(\"%d\\n\",1);\n        }else printf(\"%d\\n\",0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PREC 1e-12\n\nint main() {\n    int x, y, x0, y0, x1, y1, x2, y2, x3, y3;\n    int q;\n    double s, t, denom;\n    int judge;\n\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d %d %d %d %d %d %d %d\",\n              &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        denom = (x1-x0)*(y3-y2) - (y1-y0)*(x3-x2);\n        if (fabs(denom) < PREC) {\n            judge = 0;\n        }\n        else {\n            s = ((y3-y2)*(x2-x0)-(x3-x2)*(y2-y0)) / denom;\n            t = ((y1-y0)*(x2-x0)-(x1-x0)*(y2-y0)) / denom;\n            if (s < 0 || s > 1 || t < 0 || t > 1) {\n                judge = 0;\n            }\n            else {\n                judge = 1;\n            }\n        }\n        printf(\"%d\\n\", judge);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  if((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)return 1;\n  else return 0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint tf(int n) {\n        if(n < 0) return 0;\n        return 1;\n}\n\nint main(void) {\n        int i,j,k;\n        int kaisu;\n        int pm = 0;\n        int ans;\n        double sen[2][2][2];\n        double katamuki[3];\n        double temp;\n\n\n\n        scanf(\"%d\",&kaisu);\n\n        for(k = 0; k < kaisu; k++) {\n                for(i = 0; i < 2; i++) {\n                        for(j = 0; j < 2; j++) {\n                                scanf(\"%lf\",&sen[i][j][0]);\n                                scanf(\"%lf\",&sen[i][j][1]);\n                        }\n                }\n\n                katamuki[0] = (sen[0][1][1] - sen[0][0][1])  / (sen[0][1][0] - sen[0][0][0]);\n                katamuki[1] = (sen[1][0][1] - sen[0][0][1])  / (sen[1][0][0] - sen[0][0][0]);\n                katamuki[2] = (sen[1][1][1] - sen[0][0][1])  / (sen[1][1][0] - sen[0][0][0]);\n                if(katamuki[1] > katamuki[2]) {\n                        temp = katamuki[1];\n                        katamuki[1] = katamuki[2];\n                        katamuki[2] = temp;\n                }\n\n                if(katamuki[1] < 0 && katamuki[2] > 0) {\n                        if(katamuki[0] <= katamuki[1] && katamuki[0] >= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }else {\n                        if(katamuki[0] >= katamuki[1] && katamuki[0] <= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }\n                printf(\"%d\\n\",ans);\n        }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 < 0 && l2 * l3 < 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double *x, double *y ) {\n\tdouble numer = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\tdouble denom = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ); \n\n\tif ( fabs( denom ) < EPS )\n\t\tif ( fabs( numer ) < EPS ) {\n\t\t\tdouble h1 = ( x3 - x1 + y3 - y1 ) / ( x2 - x1 + y2 - y1 );\n\t\t\tdouble h2 = ( x4 - x1 + y4 - y1 ) / ( x2 - x1 + y2 - y1 );\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS ) {\n\t\t\t\t*x = x1;\n\t\t\t\t*y = y1;\n\t\t\t\treturn 4;\n\t\t\t} else if ( fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) ) {\n\t\t\t\t*x = x2;\n\t\t\t\t*y = y2;\n\t\t\t\treturn 4;\n\t\t\t} else if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse {\n\t\tdouble t = numer / denom;\n\t\tdouble s = ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) / denom;\n\n\t\tif ( fabs( t - 0.5 ) < 0.5 + EPS && fabs( s - 0.5 ) < 0.5 + EPS ) {\n\t\t\t*x = x1 + t * ( x2 - x1 );\n\t\t\t*y = y1 + t * ( y2 - y1 );\n\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 6;\n\t}\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n                if ((v[0].x * v[1].x - v[0].y * v[1].y) < 0\n                        && (v[0].x * v[2].x - v[0].y * v[2].y) < 0) {\n                        return 1;\n                } else if ((v[0].x * v[1].x - v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x - v[0].y * v[2].y) > 0){\n                        return 0;\n                } else {\n                        return -1;\n                }\n        }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x=p0[0],x0=p1[0]-x,x1=p2[0]-x,x2=p3[0]-x,x3=x2-x1,x4=x1-x0,x5=x2-x0;\n  long long y=p0[1],y0=p1[1]-y,y1=p2[1]-y,y2=p3[1]-y,y3=y2-y1,y4=y1-y0,y5=y2-y0;\n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y1-y3*x1);\n  long long d1=x1*x4+y1*y4,d2=x4*x5+y4*y5,d3=x2*x5+y2*y5,d4=x1*x2+y1*y2;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4>0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  return ((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x6+y1*y6,d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=x6*x7+y6*y7;\n  if(c1==0&&c2==0){\n    if(d1>0&&d2>0&&d3>0&&d4)return 0;\n    else          return 1;\n  }\n  if(c1<=0&&c2<=0)return 1;\n  else return 0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x=p0[0],x0=p1[0]-x,x1=p2[0]-x,x2=p3[0]-x,x3=x2-x1,x4=x1-x0,x5=x2-x0;\n  long long y=p0[1],y0=p1[1]-y,y1=p2[1]-y,y2=p3[1]-y,y3=y2-y1,y4=y1-y0,y5=y2-y0;\n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y1-y3*x1);\n  long long d1=x1*x4+y1*y4,d2=x4*x5+y4*y5,d3=x2*x5+y2*y5,d4=x1*x2+y1*y2;\n  return c1||c2?c1<=0&&c2<=0?1:0:d1>0&&d2>0&&d3>0&&d4>0?0:1;\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n\ntypedef struct point2d{\n  int64 x,y;\n} point;\n\ntypedef struct line2d{\n  point s,t;\n} line;\n\nvoid swap(int64 *a,int64 *b){\n  int64 tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint func(const line *a,const point *b){\n  int64 p=a->s.x;\n  int64 q=a->s.y;\n  int64 r=a->t.x;\n  int64 s=a->t.y;\n  int64 t=(s-q)*(b->x-p)-(r-p)*(b->y-q);\n  return t==0?0:(t>0?1:-1);\n}\n\nint isIntersect(const line *a,const line *b){\n  int p=func(a,&(b->s));\n  int q=func(a,&(b->t));\n  int r=func(b,&(a->s));\n  int s=func(b,&(a->t));\n  if(p==0 && q==0 && r==0 && s==0){//同一直線上に2つの線分有り\n    if(a->s.x!=a->t.x){\n      int64 p=a->s.x;\n      int64 q=a->t.x;\n      int64 r=b->s.x;\n      int64 s=b->t.x;\n      if(p>q) swap(&p,&q);\n      if(r>s) swap(&r,&s);\n      return !(p>s || r>q);\n    } else {\n      int64 p=a->s.y;\n      int64 q=a->t.y;\n      int64 r=b->s.y;\n      int64 s=b->t.y;\n      if(p>q) swap(&p,&q);\n      if(r>s) swap(&r,&s);\n      return !(p>s || r>q);\n    }\n  }\n  return p*q<=0 && r*s<=0;\n}\n\nvoid scanfLine(line *a){\n  scanf(\"%lld%lld%lld%lld\",&(a->s.x),&(a->s.y),&(a->t.x),&(a->t.y));\n  return;\n}\n\nvoid run(void){\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    line a,b;\n    scanfLine(&a);\n    scanfLine(&b);\n    int ans=isIntersect(&a,&b);\n    printf(\"%d\\n\",ans);\n  }\n  return;\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  return ((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x6+y1*y6,d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=x6*x7+y6*y7;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4>0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define EPS 0.0000000002\n#define MAX 1010001000\n\ntypedef struct point{\n    double x, y;\n}point;\n\ntypedef struct line{\n    point st, en;\n}line;\n\ndouble norm(point a);\ndouble norm2(point a);\ndouble distans(point a, point b);\npoint sum_vector(point a, point b);\npoint diff_vector(point a, point b);\npoint minus_vector(point a);\ndouble dot(point a, point b);\ndouble cross(point a, point b);\n\npoint reflection(line a, point p);\npoint projection(line a, point p);\nint ccw(line a, point p);\nint parallel(line a, line b);\nint orthogonal(line a, line b);\nint intersection(line a, line b);\n\npoint reflection(line a, point p)\n{\n    //直線aについて点pと線対称な点を返す\n    return sum_vector(projection(a, p), diff_vector(projection(a, p), p));\n}\n\npoint projection(line a, point p)\n{\n    //直線ab上に点pから垂線を下ろしたときの点h//\n    point h;\n    double k = dot(diff_vector(a.st, p), diff_vector(a.st, a.en))\n                / dot(diff_vector(a.en, a.st), diff_vector(a.en, a.st));\n    h.x = k * (a.en.x - a.st.x) + a.st.x;\n    h.y = k * (a.en.y - a.st.y) + a.st.y;\n    return h;\n}\n\ndouble norm(point a)\n{\n    //原点からの距離\n    return sqrt((a.x * a.x) + (a.y * a.y));\n}\n\ndouble norm2(point a)\n{\n    //原点からの距離の二乗\n    return (a.x * a.x) + (a.y * a.y);\n}\n\ndouble distans(point a, point b)\n{\n    //二点間の距離\n    point tmp = sum_vector(b, minus_vector(a));\n    return norm(tmp);\n}\n\npoint sum_vector(point a, point b)\n{\n    //ベクトルの和\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\npoint diff_vector(point a, point b)\n{\n    //ベクトルの差\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\npoint minus_vector(point a)\n{\n    //逆ベクトル\n    a.x *= -1;\n    a.y *= -1;\n    return a;\n}\n\ndouble dot(point a, point b)\n{\n    //内積\n    return (a.x * b.x) + (a.y * b.y);\n}\n\ndouble cross(point a, point b)\n{\n    //外積\n    return (a.x * b.y) - (b.x * a.y);\n}\n\nint ccw(line a, point p)\n{\n    //counter clockwise == 1\n    //clockwise == -1\n    //online back == 2\n    //online front == -2\n    //on segment == 0\n    int cls = cross(diff_vector(a.en, a.st), diff_vector(p, a.st));\n    if (cls > 0) {\n        return 1;\n    } else if (cls < 0) {\n        return -1;\n    } else if (dot(diff_vector(a.en, a.st), diff_vector(p, a.st)) < 0) {\n        return 2;\n    } else if (norm(diff_vector(a.st, a.en)) < norm(diff_vector(a.st, p))) {\n        return -2;\n    } else {\n        return 0;\n    }\n}\n\nint parallel(line a, line b)\n{\n    //並行で1,そうでなくて0\n    if (!cross(diff_vector(a.en, a.st), diff_vector(b.en, b.st))) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint orthogonal(line a, line b)\n{\n    //直行で1,そうでなくて0\n    if (!dot(diff_vector(a.en, a.st), diff_vector(b.en, b.st))) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint intersection(line a, line b)\n{\n    //線分a, bが交差するとき1,そうでなくて0\n    if (ccw(a,b.st) * ccw(a,b.en) <= 0 &&\n            ccw(b,a.st) * ccw(b,a.en) <= 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n///////////////////////////////////////\n\nint main(void)\n{\n    line a, b;\n    int n, i;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\"\n                , &a.st.x, &a.st.y, &a.en.x, &a.en.y\n                , &b.st.x, &b.st.y, &b.en.x, &b.en.y);\n        printf(\"%d\\n\",intersection(a, b));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PREC 1e-12\n\n#define max(a, b) ((a)>(b)?(a):(b))\n#define min(a, b) ((a)<(b)?(a):(b))\n\nint main() {\n    int x, y, x0, y0, x1, y1, x2, y2, x3, y3;\n    int q;\n    double s, t, num1, num2, denom;\n    int judge;\n\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d %d %d %d %d %d %d %d\",\n              &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        num1 = (y3-y2)*(x2-x0)-(x3-x2)*(y2-y0);\n        num2 = (y1-y0)*(x2-x0)-(x1-x0)*(y2-y0);\n        denom = (x1-x0)*(y3-y2) - (y1-y0)*(x3-x2);\n        if (fabs(denom) < PREC) {\n            if (fabs(num1) < PREC && fabs(num2) < PREC ) {\n                if ((max(x0, x1) >= min(x2, x3) && min(x0, x1) <= max(x2, x3)) &&\n                    (max(y0, y1) >= min(y2, y3) && min(y0, y1) <= max(y2, y3)))\n                    judge = 1;\n                else\n                    judge = 0;\n            }\n            else\n                judge = 0;\n        }\n        else {\n            s = num1 / denom;\n            t = num2 / denom;\n            if (s < 0 || s > 1 || t < 0 || t > 1) {\n                judge = 0;\n            }\n            else {\n                judge = 1;\n            }\n        }\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define swap( x, y ) do { double tmp; tmp = x; x = y; y = tmp; } while ( 0 )\n\nint rel_s_s( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\tswap( x0, x1 );\n\t\tswap( y0, y1 );\n\t}\n\tif ( x3 < x2 ) {\n\t\tswap( x2, x3 );\n\t\tswap( y2, y3 );\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\tif ( x0 == x2 ) {\n\t\t\t\tif ( y1 < y0 )\n\t\t\t\t\tswap( y0, y1 );\n\t\t\t\tif ( y3 < y2 )\n\t\t\t\t\tswap( y2, y3 );\n\n\t\t\t\tif ( y3 < y0 || y1 < y2 )\n\t\t\t\t\trel = 3;\n\t\t\t\telse if ( y3 == y0 || y1 == y2 ) {\n\t\t\t\t\t*y = y3 == y0 ? y0 : y1;\n\t\t\t\t\trel = 4;\n\t\t\t\t} else\n\t\t\t\t\trel = 5;\n\t\t\t} else\n\t\t\t\trel = 2;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else\n\t\t\tif ( a == c )\n\t\t\t\tif ( b == d )\n\t\t\t\t\tif ( x3 < x0 || x1 < x2 )\n\t\t\t\t\t\trel = 3;\n\t\t\t\t\telse if ( x3 == x0 || x1 == x2 ) {\n\t\t\t\t\t\t*x = x3 == x0 ? x0 : x1;\n\t\t\t\t\t\trel = 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\trel = 5;\n\t\t\t\telse\n\t\t\t\t\trel = 2;\n\t\t\telse {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t\t*y = a * *x + b;\n\t}\n\n\treturn rel;\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\n\t\tprintf( \"%d\\n\", rel == 1 || rel == 4 || rel == 5 ? 1 : 0 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n\n#define EPS 1e-10\n\nint rel_s_s( double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 ) {\n\tdouble dn = ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 );\n\tdouble nm = ( x3 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y3 - y1 );\n\n\tif ( fabs( dn ) < EPS )\n\t\tif ( fabs( nm ) < EPS ) {\n\t\t\tdouble h1 = x1 == x2 ? ( y3 - y1 ) / ( y2 - y1 ) : ( x3 - x1 ) / ( x2 - x1 );\n\t\t\tdouble h2 = x1 == x2 ? ( y4 - y1 ) / ( y2 - y1 ) : ( x4 - x1 ) / ( x2 - x1 );\n\n\t\t\tif ( ( h1 < h2 ? h1 : h2 ) < 0.0 && fabs( h1 < h2 ? h2 : h1 ) < EPS || fabs( ( h1 < h2 ? h1 : h2 ) - 1.0 ) < EPS && 1.0 < ( h1 < h2 ? h2 : h1 ) )\n\t\t\t\treturn 4;\n\t\t\telse if ( h1 < 0.0 && h2 < 0.0 || 1.0 < h1 && 1.0 < h2 )\n\t\t\t\treturn 3;\n\t\t\telse\n\t\t\t\treturn 5;\n\t\t} else\n\t\t\treturn 2;\n\telse\n\t\tif ( fabs( nm / dn - 0.5 ) < 0.5 + EPS && fabs( ( ( x3 - x1 ) * ( y2 - y1 ) - ( x2 - x1 ) * ( y3 - y1 ) ) / dn - 0.5 ) < 0.5 + EPS )\n\t\t\tif ( fabs( ( x2 - x1 ) * ( x4 - x3 ) + ( y2 - y1 ) * ( y4 - y3 ) ) < EPS )\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\telse\n\t\t\treturn 6;\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3 );\n\t\tprintf( \"%d\\n\", rel == 2 || rel == 3 || rel == 6 ? 0 : 1 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define max(a,b) a>b?a:b\n#define min(a,b) a<b?a:b\nint main(){\n    int n,ax,ay,bx,by,cx,cy,dx,dy;\n    double x,y,t;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n        t=(double)((cx-ax)*(dy-cy)-(cy-ay)*(dx-cx))/(double)((bx-ax)*(dy-cy)-(by-ay)*(dx-cx));\n        x=ax+t*(bx-ax);\n        y=ay+t*(by-ay);\n        if((double)(min(ax,bx))<=x&&x<=(double)(max(ax,bx))&&(double)(min(ay,by))<=y&&y<=(double)(max(ay,by))){\n            if((double)(min(cx,dx))<=x&&x<=(double)(max(cx,dx))&&(double)(min(cy,dy))<=y&&y<=(double)(max(cy,dy)))printf(\"1\\n\");\n        }else printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble get_radian(double x1, double y1, double x2, double y2) {\n\tif(fabs(x1-x2) < 0.00000001f) {\n\t\tif(fabs(y1-y2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(y1 > y2) {\n\t\t\treturn 3 * M_PI / 2;\n\t\t} else {\n\t\t\treturn M_PI / 2;\n\t\t}\n\t} else if(fabs(y1-y2) < 0.00000001f) {\n\t\tif(fabs(x1-x2) < 0.00000001f) {\n\t\t\treturn 0.0f;\n\t\t} else if(x1 > x2) {\n\t\t\treturn M_PI;\n\t\t}\n\t\treturn 0.0;\n\t}\n\t\n\tif(x2 >= x1) {\n\t\tif(y2 >= y1) {\n\t\t\treturn atan((y2-y1)/(x2-x1));\n\t\t}\n\t\treturn 2 * M_PI + atan((y2-y1)/(x2-x1));\n\t} else {\n\t\tif(y2 >= y1) {\n\t\t\treturn M_PI - atan((y2-y1)/(x1-x2));\n\t\t}\n\t\treturn M_PI + atan((y2-y1)/(x2-x1));\n\t}\n}\n\nint main(void) {\n\tdouble x1,x2,x3,x4,y1,y2,y3,y4;\n\tdouble ta, tb, tc, td;\n\tint i, n;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\\n\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n\t\tta=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\ttb=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\ttc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\ttd=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\n\t\tif(ta*tb<=0 && tc*td<=0) {\n\t\t\tprintf(\"1\\n\");\n\t\t} else {\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  long long x7=x2-x0,y7=y2-y0/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x4+y1*y4,d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=x4*x7+y4*y7;\n  if(c1==0&&c2==0)return (d1<0&&d2>0&&d3>0&&d4<0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    if(x1 == x2 && x2 == x3 && x3 == x4){\n        l0 = (y1 - y3) * (y2 - y4);\n        l1 = (y1 - y4) * (y2 - y3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if(y1 == y2 && y2 == y3 && y3 == y4){\n        l0 = (x1 - x3) * (x2 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else{\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 <= 0 && l2 * l3 <= 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PREC 1e-12\n\nint main() {\n    int x, y, x0, y0, x1, y1, x2, y2, x3, y3;\n    int q;\n    double s, t, num1, num2, denom;\n    int judge;\n\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        scanf(\"%d %d %d %d %d %d %d %d\",\n              &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3);\n        num1 = (y3-y2)*(x2-x0)-(x3-x2)*(y2-y0);\n        num2 = (y1-y0)*(x2-x0)-(x1-x0)*(y2-y0);\n        denom = (x1-x0)*(y3-y2) - (y1-y0)*(x3-x2);\n        if (fabs(denom) < PREC) {\n            if (fabs(num1) < PREC && fabs(num2) < PREC ) {\n                if (((x1-x2)*(x2-x0) >= 0 && (y1-y2)*(y2-y0) >= 0) ||\n                    ((x1-x3)*(x3-x0) >= 0 && (y1-y3)*(y3-y0) >= 0))\n                    judge = 1;\n                else\n                    judge = 0;\n            }\n            else\n                judge = 0;\n        }\n        else {\n            s = num1 / denom;\n            t = num2 / denom;\n            if (s < 0 || s > 1 || t < 0 || t > 1) {\n                judge = 0;\n            }\n            else {\n                judge = 1;\n            }\n        }\n        printf(\"%d\\n\", judge);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    l0 = (x1 - x2)*(x3 - x1) + (y1 - y2)*(y1 - y3);\n    l1 = (x1 - x2)*(x4 - x1) + (y1 - y2)*(y1 - y4);\n    l2 = (x3 - x4)*(x1 - x3) + (y3 - y4)*(y3 - y1);\n    l3 = (x3 - x4)*(x2 - x3) + (y3 - y4)*(y3 - y2);\n    if(l0 * l1 < 0 && l2 * l3 < 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  long long x7=p3[0]-p1[0],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*(x4)+y1*(y4),d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=(x4)*x7+(y4)*y7;\n  if(c1==0&&c2==0)return (d1<0&&d2>0&&d3>0&&d4<0)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint intsec_line( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble tmp;\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\ttmp = x0;\n\t\tx0 = x1;\n\t\tx1 = tmp;\n\n\t\ttmp = y0;\n\t\ty0 = y1;\n\t\ty1 = tmp;\n\t}\n\tif ( x3 < x2 ) {\n\t\ttmp = x2;\n\t\tx2 = x3;\n\t\tx3 = tmp;\n\n\t\ttmp = y2;\n\t\ty2 = y3;\n\t\ty3 = tmp;\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\trel = 2;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\t*y = a * *x + b;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else\n\t\t\tif ( a == c )\n\t\t\t\trel = 2;\n\t\t\telse {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\t*y = a * *x + b;\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t}\n\n\treturn rel;\n}\n\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\t\tprintf( \"%d\\n\", intsec_line( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint cross(double x0,double y0,double x1,double y1,double x2,double y2,double x3,double y3){\n  double a0=0,a1=0,b0=0,b1=0;\n  double tx=0,ty=0,p0p1=0,p2p3=0,len1=0,len2=0;\n  \n  a0=(y1-y0)/(x1-x0);\n  a1=(y3-y2)/(x3-x2);\n  b0=y0-a0*x0;\n  b1=y2-a1*x2;\n  //???????±???????\n  tx=(b0-b1)/(a1-a0);\n  ty=a0*tx+b0;\n  p0p1=sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));\n  p2p3=sqrt((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2));\n  len1=sqrt((tx-x0)*(tx-x0)+(ty-y0)*(ty-y0));\n  len2=sqrt((tx-x2)*(tx-x2)+(ty-y2)*(ty-y2));\n  if(p0p1<len1 || p2p3<len2 || (y2-y0)==(y3-y1)) return 0;\n  else return 1;\n  \n}\n\n\n\n\nint main(){\n   int number,i,m;\n  double x0,y0,x1,y1,x2,y2,x3,y3;\n  scanf(\"%d\",&number);\n  for(i=0;i<number;i++){\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x0,&y0,&x1,&y1,&x2,&y2,&x3,&y3);\n    m=cross(x0,y0,x1,y1,x2,y2,x3,y3);\n    \n    printf(\"%d\\n\",m);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint intsec_line( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble tmp;\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\ttmp = x0;\n\t\tx0 = x1;\n\t\tx1 = tmp;\n\n\t\ttmp = y0;\n\t\ty0 = y1;\n\t\ty1 = tmp;\n\t}\n\tif ( x3 < x2 ) {\n\t\ttmp = x2;\n\t\tx2 = x3;\n\t\tx3 = tmp;\n\n\t\ttmp = y2;\n\t\ty2 = y3;\n\t\ty3 = tmp;\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\trel = 0;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\t*y = a * *x + b;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else\n\t\t\tif ( a == c )\n\t\t\t\trel = 0;\n\t\t\telse {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\t*y = a * *x + b;\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t}\n\n\treturn rel;\n}\n\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\t\tprintf( \"%d\\n\", intsec_line( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint tf(int n) {\n        if(n < 0) return 0;\n        return 1;\n}\n\nint main(void) {\n        int i,j,k;\n        int kaisu;\n        int pm = 0;\n        int ans;\n        double sen[2][2][2];\n        double katamuki[3];\n        double temp;\n\n\n\n        scanf(\"%d\",&kaisu);\n\n        for(k = 0; k < kaisu; k++) {\n                for(i = 0; i < 2; i++) {\n                        for(j = 0; j < 2; j++) {\n                                scanf(\"%lf\",&sen[i][j][0]);\n                                scanf(\"%lf\",&sen[i][j][1]);\n                        }\n                }\n\n                katamuki[0] = (sen[0][1][1] - sen[0][0][1])  / (sen[0][1][0] - sen[0][0][0]);\n                katamuki[1] = (sen[1][0][1] - sen[0][0][1])  / (sen[1][0][0] - sen[0][0][0]);\n                katamuki[2] = (sen[1][1][1] - sen[0][0][1])  / (sen[1][1][0] - sen[0][0][0]);\n                if(katamuki[1] > katamuki[2]) {\n                        temp = katamuki[1];\n                        katamuki[1] = katamuki[2];\n                        katamuki[2] = temp;\n                }\n\n                if(katamuki[1] < 0 && katamuki[2] > 0) {\n                        if(katamuki[0] <= katamuki[1] && katamuki[0] >= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }else {\n                        if(katamuki[0] >= katamuki[1] && katamuki[0] <= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }\n                printf(\"%d\\n\",ans);\n        }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        long int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n                if ((v[0].x * v[1].x + v[0].y * v[1].y) < 0\n                        && (v[0].x * v[2].x + v[0].y * v[2].y) < 0) {\n                        return 1;\n                } else if ((v[0].x * v[1].x + v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) > 0){\n                        return 0;\n                } else {\n                        return -1;\n                }\n        }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  //long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  //long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x6+y1*y6,d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=x6*x7+y6*y7;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x=p0[0],x0=p1[0]-x,x1=p2[0]-x,x2=p3[0]-x,x3=x2-x1,x4=x1-x0,x5=x2-x0;\n  long long y=p0[1],y0=p1[1]-y,y1=p2[1]-y,y2=p3[1]-y,y3=y2-y1,y4=y1-y0,y5=y2-y0;\n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y1-y3*x1);\n  long long d1=x1*x4+y1*y4,d2=x4*x5+y4*y5,d3=x2*x5+y2*y5,d4=x1*x2+y1*y2;\n  return c1||c2?(c1<=0&&c2<=0?1:0):(d1>0&&d2>0&&d3>0&&d4>0?0:1);\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  int x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  int y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  return (x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0?1:0;\n}\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define DOT(v1, v2) (v1.x * v2.x + v1.y * v2.y)\n#define CROSS(v1, v2) (v1.x * v2.y - v1.y * v2.x)\n#define NORM(v) (v.x * v.x + v.y * v.y)\n\ntypedef struct { double x, y; } point_t;\ntypedef point_t vector_t;\ntypedef struct { point_t p0, p1; } segment_t;\ntypedef segment_t line_t;\n\nstatic vector_t minus(vector_t v1, vector_t v2) {\n  vector_t ret = { v1.x - v2.x, v1.y - v2.y };\n  return ret;\n}\n\nstatic int clockwise(segment_t s, point_t p) {\n  vector_t a = minus(s.p1, s.p0);\n  vector_t b = minus(p, s.p0);\n  double c = CROSS(a, b);\n  double d = DOT(a, b);\n  double na = NORM(a);\n  double nb = NORM(b);\n  if (c > 0.0) return 1;\n  if (c < 0.0) return -1;\n  if (d < 0.0) return 1;\n  if (nb > na) return -1;\n  return 0;\n}\n\nint main(int argc, char **argv) {\n  int q, i, k, l;\n  segment_t s1, s2;\n\n  scanf(\"%d\", &q);\n  for (i = 0; i < q; ++i) {\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",\n        &s1.p0.x, &s1.p0.y, &s1.p1.x, &s1.p1.y,\n        &s2.p0.x, &s2.p0.y, &s2.p1.x, &s2.p1.y);\n    k = clockwise(s1, s2.p0) * clockwise(s1, s2.p1);\n    l = clockwise(s2, s1.p0) * clockwise(s2, s1.p1);\n    printf(\"%d\\n\", k <= 0 && l <= 0);\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_2_B Intersection\n// 2018.5.2 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define INF\t\t\t1e8\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn hypot(p1.x-p2.x, p1.y-p2.y); };\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta = vsub(p1, p0), b = vsub(p2, p0), t = cross(a, b);\n\tif (t >  EPS) return 1;\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\n\nint is_intersectSS(SEG s1, SEG s2)\n{\n\treturn ccw(s1.s, s1.e, s2.s) * ccw(s1.s, s1.e, s2.e) <= 0 &&\n\t\t   ccw(s2.s, s2.e, s1.s) * ccw(s2.s, s2.e, s1.e) <= 0;\n}\n\nint main()\n{\n\tint q, x, y;\n\tPP p0, p1, p2, p3;\n\tSEG s1, s2;\n\n\tq = in();\n\twhile (q--) {\n\t\tx = in(), y = in(), p0 = vset(x, y);\n\t\tx = in(), y = in(), p1 = vset(x, y);\n\t\tx = in(), y = in(), p2 = vset(x, y);\n\t\tx = in(), y = in(), p3 = vset(x, y);\n\t\ts1.s = p0, s1.e = p1;\n\t\ts2.s = p2, s2.e = p3;\n\t\tputchar('0' + is_intersectSS(s1, s2)), putchar('\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct point {\n        double x;\n        double y;\n};\nint ccw(struct point, struct point, struct point, struct point);\nmain()\n{\n        int i, n;\n        struct point p[4];\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\", &p[0].x, &p[0].y\n                                  , &p[1].x, &p[1].y, &p[2].x, &p[2].y, &p[3].x, &p[3].y);\n                if (ccw(p[0], p[1], p[2], p[3])<=0 && ccw(p[2], p[3], p[0], p[1])<=0) {\n                        printf(\"1\\n\");\n                } else {\n                        printf(\"0\\n\");\n                }\n        }\n}\nint ccw(struct point p0, struct point p1, struct point p2, struct point p3)\n{\n        long long int ans;\n        struct point v[3];\n        v[0].x = p1.x - p0.x; v[0].y = p1.y - p0.y;\n        v[1].x = p2.x - p0.x; v[1].y = p2.y - p0.y;\n        v[2].x = p3.x - p0.x; v[2].y = p3.y - p0.y;\n        ans = (v[0].x * v[1].y - v[0].y * v[1].x)\n                * (v[0].x * v[2].y - v[0].y * v[2].x);\n        if (!ans) {\n                if ((v[0].x * v[1].x + v[0].y * v[1].y) < 0\n                        && (v[0].x * v[2].x + v[0].y * v[2].y) < 0) {\n                        return 1;\n                } else if ((v[0].x * v[1].x + v[0].y * v[1].y) > 0\n            && (v[0].x * v[2].x + v[0].y * v[2].y) > 0){\n                        return 0;\n                } else {\n                        return -1;\n                }\n        }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    if(x1 == x2 && x2 == x3 && x3 == x4){\n        l0 = (y1 - y2) * (y3 - y4);\n        l1 = (y1 - y4) * (y2 - y3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if(y1 == y2 && y2 == y3 && y3 == y4){\n        l0 = (x1 - x2) * (x3 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else{\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 <= 0 && l2 * l3 <= 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x6+y1*y6,d2=x2*x7+y2*y7;\n  if(c1==0&&c2==0){\n    if(d1>0&&d2>0)return 0;\n    else          return 1;\n  }\n  if(c1<=0&&c2<=0)return 1;\n  else return 0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x2+y1*y2,d2=x6*x7+y6*y7;\n  if(c1==0&&c2==0){\n    if(d1>0&&d2>0)return 0;\n    else          return 1;\n  }\n  if(c1<=0&&c2<=0)return 1;\n  else return 0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 <= 0 && l2 * l3 <= 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  if((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)return 1;\n  else return 0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define eps 0.000000001\ndouble abal[4];\nvoid sort(double list[])\n{\n    int n=4;\n int c, d;\n  double t;\n\n  for (c = 0 ; c < n - 1; c++)\n  {\n    for (d = 0 ; d < n - c - 1; d++)\n    {\n      if (list[d] < list[d+1])\n      {\n        /* Swapping */\n\n        t         = list[d];\n        list[d]   = list[d+1];\n        list[d+1] = t;\n      }\n    }\n  }\n}\n\n\nint main()\n    {\n        double x1,x2,x3,y1,y2,y3,x4,y4,q,m1,c1,c2,X,Y,m2,i,one,two,whole,one_again,two_again,whole_again,bal,a;\n\n        scanf(\"%lf\",&q);\n        for(i=0;i<q;i++)\n        {\n            scanf(\"%lf %lf %lf %lf\",&x1,&y1,&x2,&y2);\n            scanf(\"%lf %lf %lf %lf\",&x3,&y3,&x4,&y4);\n            if(x1==x2 && x3!=x4)\n            {\n                X=x2;\n                m2=(y3-y4)/(x3-x4);\n                c2=y3-m2*x3;\n                Y=m2*X+c2;\n            }\n            else if (x1!=x2 && x3==x4)\n            {\n                X=x3;\n                m1=(y1-y2)/(x1-x2);\n                c1=y1-m1*x1;\n                Y=m1*X+c1;\n            }\n            else if(x1==x2 && x3==x4)\n            {\n                if(x1==x3)\n                {\n                    bal=sqrt((y1-y2)*(y1-y2));\n                        a=sqrt((y3-y4)*(y3-y4));\n                        abal[0]=sqrt((y1-y4)*(y1-y4));\n                        abal[1]=sqrt((y2-y4)*(y2-y4));\n                        abal[2]=sqrt((y2-y3)*(y2-y3));\n                        abal[3]=sqrt((y1-y3)*(y1-y3));\n                        sort(abal);\n                       // printf(\"%lf %lf %lf\\n\",abal[0],bal,a);\n                       double max_abal = abal[0];\n                        if((a+bal)>=(max_abal) || (a+bal+eps)>=(max_abal))\n                {printf(\"1\\n\");\n                continue;\n                }\n\n                else {\n                    printf(\"0\\n\");//printf(\"OK\\n\");\n                continue;\n                    }\n                }\n                else {\n                    printf(\"0\\n\");//printf(\"OK\\n\");\n                continue;\n                }\n\n\n            }\n\n            /*else\n            }*/\n            else\n            {\n                m1=(y1-y2)/(x1-x2);\n                c1=y1-m1*x1;\n                m2=(y3-y4)/(x3-x4);\n                c2=y3-m2*x3;\n                if(fabs(m1-m2)<=eps)\n                {\n                    if(fabs(m1*x3-y3+c1)<=eps)\n                    {\n                        bal=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n                        a=sqrt((x3-x4)*(x3-x4)+(y3-y4)*(y3-y4));\n                        abal[0]=sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4));\n                        abal[1]=sqrt((x2-x4)*(x2-x4)+(y2-y4)*(y2-y4));\n                        abal[2]=sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));\n                        abal[3]=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));\n                        sort(abal);\n                       // printf(\"%lf %lf %lf\\n\",abal[0],bal,a);\n                       double max_abal = abal[0];\n                        if((a+bal)>=(max_abal) || (a+bal+eps)>=(max_abal))\n                {printf(\"1\\n\");\n                continue;\n                }\n                else\n                {\n                    printf(\"0\\n\"); continue;\n                }\n                    }\n                    else\n                    {printf(\"0\\n\");continue;\n                    }\n                }\n\n                X=(c2-c1)/(m1-m2);\n                Y=m1*X+c1;\n\n            }\n            one=sqrt((X-x1)*(X-x1) + (Y-y1)*(Y-y1));\n            two =sqrt((X-x2)*(X-x2) + (Y-y2)*(Y-y2));\n            whole =sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n            one_again=sqrt((X-x3)*(X-x3) + (Y-y3)*(Y-y3));\n            two_again=sqrt((X-x4)*(X-x4) + (Y-y4)*(Y-y4));\n            whole_again=sqrt((x4-x3)*(x4-x3) + (y4-y3)*(y4-y3));\n            if(((fabs((one+two)-whole))<=eps) && ((fabs((one_again+two_again)-whole_again))<=eps))\n                printf(\"1\\n\");\n            else printf(\"0\\n\");\n             //printf(\"%lf %lf\\n\",(one+two)-whole,(one_again+two_again)-whole_again);\n\n\n        }\n        return 0;\n    }\n\n  // ALHAMDULLIAH\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\nbool\nintersect(double xs0, double ys0, double xs1, double ys1, double xt0, double yt0, double xt1, double yt1)\n{\n\tdouble rx1 = xs1 - xs0;\n\tdouble ry1 = ys1 - ys0;\n\tdouble rx2 = xt1 - xt0;\n\tdouble ry2 = yt1 - yt0;\n\n\tdouble ra = (rx1 * (ys0 - yt0) - ry1 * (xs0 - xt0)) / (rx1 * ry2 - rx2 * ry1);\n\tdouble rb = (rx2 * (xs0 - yt0) - ry2 * (xs0 - xt0)) / (rx1 * ry2 - rx2 * ry1);\n\treturn (0 <= ra && ra <= 1 && 0 <= rb && rb <= 1);\n}\n\nint\nmain(int argc, char** argv)\n{\n\tdouble xs0, ys0, xs1, ys1, xt0, yt0, xt1, yt1;\n\tint xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\tint q;\n\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d %d %d\", &xp0, &yp0, &xp1, &yp1, &xp2, &yp2, &xp3, &yp3);\n\t\txs0 = xp0, ys0 = yp0;\n\t\txs1 = xp1, ys1 = yp1;\n\t\txt0 = xp2, yt0 = yp2;\n\t\txt1 = xp3, yt1 = yp3;\n\n\t\tif (intersect(xs0, ys0, xs1, ys1, xt0, yt0, xt1, yt1))\n\t\t\tprintf(\"1\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  int x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0],x3=x2-x1,x4=x0-x1,x5=-x1;\n  int y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1],y3=y2-y1,y4=y0-y1,y5=-y1;\n  return ((x0*y1-y0*x1)*(x0*y2-y0*x2)<=0&&(x3*y4-y3*x4)*(x3*y5-y3*x5)<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\"%d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nint max(int a, int b);\nint min(int a, int b);\n\nint main(void){\n  int q;\n  scanf(\"%d\",&q);\n\n  double x1,y1,x2,y2,x3,y3,x4,y4;\n  double x,y;//直線の交点\n  double det;//行列式\n  double k1,k2;\n  int a,b,c,d;\n  for(int i=0;i<q;i++){\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4);\n    det=(x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(det==0){//平行\n      if(x1*y2-x2*y1!=x3*y4-x4*y3){\n        printf(\"0\\n\");\n        continue;\n      }\n\n\n      if(x2==x1){\n        a=min(y1,y2);\n        b=max(y1,y2);\n        c=min(y3,y4);\n        d=max(y3,y4);\n      }\n      else{\n        a=min(x1,x2);\n        b=max(x1,x2);\n        c=min(x3,x4);\n        d=max(x3,x4);\n      }\n\n      if(b<c || d<a){\n        printf(\"0\\n\");\n      }\n      else{\n        printf(\"1\\n\");\n      }\n      continue;\n    }\n    x=((x3-x4)*(x1*y2-x2*y1)+(x2-x1)*(x3*y4-x4*y3))/det;\n    y=((y3-y4)*(x1*y2-x2*y1)+(y2-y1)*(x3*y4-x4*y3))/det;\n    if(x1==x2){\n      k1=(y-y1)*1.0/(y2-y1);\n    }\n    else{\n      k1=(x-x1)*1.0/(x2-x1);\n    }\n    if(k1<0 || 1<k1){\n      printf(\"0\\n\");\n      continue;\n    }\n\n    if(x3==x4){\n      k2=(y-y3)*1.0/(y4-y3);\n    }\n    else{\n      k2=(x-x3)*1.0/(x4-x3);\n    }\n    if(k2<0 || 1<k2){\n      printf(\"0\\n\");\n      continue;\n    }\n    printf(\"1\\n\");\n  }\n  return 0;\n}\n\nint max(int a, int b) {\n    if (a > b)\n        return a;\n    else\n        return b;\n}\n\nint min(int a, int b) {\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//#include<math.h>\nint ifcl(int p0[2],int p1[2],int p2[2],int p3[2]){\n  long long x0=p1[0]-p0[0],x1=p2[0]-p0[0],x2=p3[0]-p0[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y0=p1[1]-p0[1],y1=p2[1]-p0[1],y2=p3[1]-p0[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  long long x3=p3[0]-p2[0],x4=p1[0]-p2[0],x5=p0[0]-p2[0];\n  long long y3=p3[1]-p2[1],y4=p1[1]-p2[1],y5=p0[1]-p2[1];\n  long long x6=p2[0]-p1[0],x7=p3[0]-p1[0]/*,x3=x2-x1,x4=x0-x1,x5=-x1*/;\n  long long y6=p2[1]-p1[1],y7=p3[1]-p1[1]/*,y3=y2-y1,y4=y0-y1,y5=-y1*/;\n  \n  long long c1=(x0*y1-y0*x1)*(x0*y2-y0*x2),c2=(x3*y4-y3*x4)*(x3*y5-y3*x5);\n  long long d1=x1*x6+y1*y6,d2=x2*x7+y2*y7,d3=x1*x2+y1*y2,d4=x6*x7+y6*y7;\n  if(c1==0&&c2==0)return (d1>0&&d2>0&&d3>0&&d4)?0:1;\n  return (c1<=0&&c2<=0)?1:0;\n}\n/*double dMIN(double a,double b){return a<b?a:b;}\ndouble drpl(int p0[2],int p1[2],int p2[2]){\n  int a=p0[1]-p1[1],b=p0[0]-p1[0],c=p0[0]*p1[1]-p1[0]*p0[1];\n  int d=p2[1]-p1[1],e=p2[0]-p1[0];\n  int f=p2[1]-p0[1],g=p2[0]-p0[0];\n  if(a*d+b*e<0||a*f+b*g>0)return dMIN(hypot(d,e),hypot(f,g));\n  return abs(p2[0]*a-p2[1]*b+c)/hypot(a,b);\n}\ndouble drll(int *p0,int *p1,int *p2,int *p3){\n  double l=drpl(p2,p3,p0);\n  l=dMIN(l,drpl(p2,p3,p1));\n  l=dMIN(l,drpl(p0,p1,p2));\n  l=dMIN(l,drpl(p0,p1,p3));\n  if(ifcl(p0,p1,p2,p3))l=0;\n  return l;\n  }*/\nint main(){\n  int p[4][2],n,i;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<8;i++)scanf(\" %d\",&p[i/2][i%2]);\n    printf(\"%d\\n\",ifcl(p[0],p[1],p[2],p[3]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n   int i, n, x1, y1, x2, y2, x3, y3, x4, y4, l0, l1, l2, l3;\n   scanf(\"%d\", &n);\nfor (i = 0; i < n; i++){\n    scanf(\"%d %d %d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3, &x4, &y4);\n    if(x1 == x2 && x2 == x3 && x3 == x4){\n        l0 = (y1 - y3) * (y2 - y4);\n        l1 = (y1 - y4) * (y2 - y3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if(y1 == y2 && y2 == y3 && y3 == y4){\n        l0 = (x1 - x3) * (x2 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n         if(l0 > 0 && l1 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else if((y2-y1)*(x4-x3) == (y4-y3)*(x2-x1)){\n        l0 = (x1 - x3) * (x2 - x4);\n        l1 = (x1 - x4) * (x2 - x3);\n        l2 = (y1 - y3) * (y2 - y4);\n        l3 = (y1 - y4) * (y2 - y3);\n         if(l0 > 0 && l1 > 0 && l2 > 0 && l3 > 0){\n            printf(\"0\\n\");\n         }else{\n            printf(\"1\\n\");\n         }\n    }else{\n    l0 = (x1 - x2)*(y3 - y1) + (y1 - y2)*(x1 - x3);\n    l1 = (x1 - x2)*(y4 - y1) + (y1 - y2)*(x1 - x4);\n    l2 = (x3 - x4)*(y1 - y3) + (y3 - y4)*(x3 - x1);\n    l3 = (x3 - x4)*(y2 - y3) + (y3 - y4)*(x3 - x2);\n    if(l0 * l1 <= 0 && l2 * l3 <= 0){\n        printf(\"1\\n\");\n    }else{\n        printf(\"0\\n\");\n    }\n    }\n}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define swap( x, y ) do { double tmp; tmp = x; x = y; y = tmp; } while ( 0 )\n\nint rel_s_s( double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double *x, double *y ) {\n\tdouble a, b, c, d;\n\tint rel;\n\n\tif ( x1 < x0 ) {\n\t\tswap( x0, x1 );\n\t\tswap( y0, y1 );\n\t}\n\tif ( x3 < x2 ) {\n\t\tswap( x2, x3 );\n\t\tswap( y2, y3 );\n\t}\n\n\tif ( x0 != x1 ) {\n\t\ta = ( y0 - y1 ) / ( x0 - x1 );\n\t\tb = ( x0 * y1 - x1 * y0 ) / ( x0 - x1 );\n\t}\n\tif ( x2 != x3 ) {\n\t\tc = ( y2 - y3 ) / ( x2 - x3 );\n\t\td = ( x2 * y3 - x3 * y2 ) / ( x2 - x3 );\n\t}\n\n\trel = 1;\n\tif ( x0 == x1 ) {\n\t\t*x = x0;\n\t\tif ( x2 == x3 )\n\t\t\tif ( x0 == x2 ) {\n\t\t\t\tif ( y1 < y0 )\n\t\t\t\t\tswap( y0, y1 );\n\t\t\t\tif ( y3 < y2 )\n\t\t\t\t\tswap( y2, y3 );\n\n\t\t\t\tif ( y3 < y0 || y1 < y2 )\n\t\t\t\t\trel = 3;\n\t\t\t\telse if ( y3 == y0 || y1 == y2 ) {\n\t\t\t\t\t*y = y3 == y0 ? y0 : y1;\n\t\t\t\t\trel = 4;\n\t\t\t\t} else\n\t\t\t\t\trel = 5;\n\t\t\t} else\n\t\t\t\trel = 2;\n\t\telse {\n\t\t\t*y = c * *x + d;\n\t\t\tif ( *x < x2 || x3 < *x || *y < ( y0 < y1 ? y0 : y1 ) || ( y0 < y1 ? y1 : y0 ) < *y )\n\t\t\t\trel = 0;\n\t\t}\n\t} else {\n\t\tif ( x2 == x3 ) {\n\t\t\t*x = x2;\n\t\t\t*y = a * *x + b;\n\t\t\tif ( *x < x0 || x1 < *x || *y < ( y2 < y3 ? y2 : y3 ) || ( y2 < y3 ? y3 : y2 ) < *y )\n\t\t\t\trel = 0;\n\t\t} else {\n\t\t\tif ( a == c )\n\t\t\t\tif ( b == d )\n\t\t\t\t\tif ( x3 < x0 || x1 < x2 )\n\t\t\t\t\t\trel = 3;\n\t\t\t\t\telse if ( x3 == x0 || x1 == x2 ) {\n\t\t\t\t\t\t*x = x3 == x0 ? x0 : x1;\n\t\t\t\t\t\trel = 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\trel = 5;\n\t\t\t\telse\n\t\t\t\t\trel = 2;\n\t\t\telse {\n\t\t\t\t*x = ( -b + d ) / ( a - c );\n\t\t\t\tif ( *x < x0 || x1 < *x || *x < x2 || x3 < *x )\n\t\t\t\t\trel = 0;\n\t\t\t}\n\t\t\t*y = a * *x + b;\n\t\t}\n\t}\n\n\treturn rel;\n}\n\nint main( void ) {\n\tint q;\n\n\tscanf( \"%d\", &q );\n\twhile ( q-- ) {\n\t\tint rel;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3, x, y;\n\n\t\tscanf( \"%lf %lf %lf %lf %lf %lf %lf %lf\", &x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3 );\n\n\t\trel = rel_s_s( x0, y0, x1, y1, x2, y2, x3, y3, &x, &y );\n\n\t\tprintf( \"%d\\n\", rel == 1 || rel == 4 || rel == 5 ? 1 : 0 );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint tf(int n) {\n        if(n < 0) return 0;\n        return 1;\n}\n\nint main(void) {\n        int i,j,k;\n        int kaisu;\n        int pm = 0;\n        int ans;\n        double sen[2][2][2];\n        double katamuki[3];\n        double temp;\n\n\n\n        scanf(\"%d\",&kaisu);\n\n        for(k = 0; k < kaisu; k++) {\n                for(i = 0; i < 2; i++) {\n                        for(j = 0; j < 2; j++) {\n                                scanf(\"%lf\",&sen[i][j][0]);\n                                scanf(\"%lf\",&sen[i][j][1]);\n                        }\n                }\n\n                katamuki[0] = (sen[0][1][1] - sen[0][0][1])  / (sen[0][1][0] - sen[0][0][0]);\n                katamuki[1] = (sen[1][0][1] - sen[0][0][1])  / (sen[1][0][0] - sen[0][0][0]);\n                katamuki[2] = (sen[1][1][1] - sen[0][0][1])  / (sen[1][1][0] - sen[0][0][0]);\n                if(katamuki[1] > katamuki[2]) {\n                        temp = katamuki[1];\n                        katamuki[1] = katamuki[2];\n                        katamuki[2] = temp;\n                }\n\n                if(katamuki[1] < 0 && katamuki[2] > 0) {\n                        if(katamuki[0] <= katamuki[1] && katamuki[0] >= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }else {\n                        if(katamuki[0] >= katamuki[1] && katamuki[0] <= katamuki[2])\n                                if(tf(sen[0][0][0] - sen[1][0][0]) != tf(sen[0][1][0] - sen[1][0][0]) || tf(sen[0][0][1] - sen[1][0][1]) != tf(sen[0][1][1] - sen[1][0][1])) {\n                                        ans = 0;\n                                }else {\n                                        ans = 1;\n                                }\n                        else {\n                                ans = 1;\n                        }\n                }\n                printf(\"%d\\n\",ans);\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\tif ((cross(abx, aby, acx, acy) * cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& (cross(cdx, cdy, cax, cay) * cross(cdx, cdy, cbx, cby) <= 0)) {\n\t\t\t\tif (cross(abx, aby, cdx, cdy) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) > 0 && dot(abx, aby, acx, acy) < sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, adx, ady) > 0 && dot(abx, aby, adx, ady) < sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Segments/Lines - Intersection\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString line;\n\t\tString[] words;\n\n\t\tint q = sc.nextInt();\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tdouble xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\t\t\txp0 = sc.nextDouble();\n\t\t\typ0 = sc.nextDouble();\n\t\t\txp1 = sc.nextDouble();\n\t\t\typ1 = sc.nextDouble();\n\t\t\txp2 = sc.nextDouble();\n\t\t\typ2 = sc.nextDouble();\n\t\t\txp3 = sc.nextDouble();\n\t\t\typ3 = sc.nextDouble();\n\n\t\t\tPoint p0, p1, p2, p3;\n\t\t\tp0 = new Point(xp0, yp0);\n\t\t\tp1 = new Point(xp1, yp1);\n\t\t\tp2 = new Point(xp2, yp2);\n\t\t\tp3 = new Point(xp3, yp3);\n\n\t\t\tif (Geometries.isIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t} //end main\n}\n\nclass Geometries {\n\n\tstatic double EPS = 1e-10;\n\n\t//????????????\n\tstatic boolean equals(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\t//\n\tstatic enum Order {\n\t\tCOUNTER_CLOCKWISE(1),   //???????¨???????\n\t\tCLOCKWISE(-1),          //????¨???????\n\t\tONLINE_BACK(2),         //???????????????????????´??????\n\t\tONLINE_FRONT(-2),       //????????????????????´??????\n\t\tON_SEGMENT(0);          //???????????????\n\n\t\tprivate int value;\n\n\t\tOrder(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\t//?????????\n\tstatic Order order(Point p0, Point p1, Point p2) {\n\t\tPoint v1 = p1.subtract(p0);\n\t\tPoint v2 = p2.subtract(p0);\n\t\tif (v1.outer(v2) > EPS) {return Order.COUNTER_CLOCKWISE;}\n\t\tif (v1.outer(v2) < -EPS) {return Order.CLOCKWISE;}\n\t\tif (v1.inner(v2) < -EPS) {return Order.ONLINE_BACK;}\n\t\tif (v1.norm() < v2.norm()) {return Order.ONLINE_FRONT;}\n\t\treturn Order.ON_SEGMENT;\n\t}\n\n\tstatic Order order(Segment s, Point p) {\n\t\tPoint p0 = s.p1;\n\t\tPoint p1 = s.p2;\n\t\treturn order(p0, p1, p);\n\t}\n\n\t//??´?????????\n\tstatic boolean isOrthogonal(Point a, Point b) {\n\t\treturn equals(a.inner(b), 0.0);\n\t}\n\n\tstatic boolean isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isOrthogonal(Segment s1, Segment s2) {\n\t\treturn isOrthogonal(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isParallel(Point a, Point b) {\n\t\treturn equals(a.outer(b), 0.0);\n\t}\n\n\tstatic boolean isParallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isParallel(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isParallel(Segment s1, Segment s2) {\n\t\treturn isParallel(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isIntersect(Point a1, Point a2, Point b1, Point b2) {\n\t\tOrder o1, o2, o3, o4;\n\t\to1 = order(a1, a2, b1);\n\t\to2 = order(a1, a2, b2);\n\t\to3 = order(b1, b2, a1);\n\t\to4 = order(b1, b2, a2);\n\n\t\tif (o1.value * o2.value <= 0 && o3.value * o4.value <= 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isIntersect(Segment s1, Segment s2) {\n\t\tPoint a1 = s1.p1;\n\t\tPoint a2 = s1.p2;\n\t\tPoint b1 = s2.p1;\n\t\tPoint b2 = s2.p2;\n\t\treturn isIntersect(a1, a2, b1, b2);\n\t}\n}\n\nclass Point implements Comparable<Point> {\n\n\tstatic double EPS = 1e-10;\n\n\tdouble x, y;\n\n\tPoint() {\n\t\tthis(0.0, 0.0);\n\t}\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic int compareTo(Point p) {\n\t\tif (equals(p)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (x != p.x) {\n\t\t\t\treturn Double.compare(y, p.y);\n\t\t\t} else {\n\t\t\t\treturn Double.compare(x, p.x);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tPoint p = (Point) obj;\n\t\treturn x - p.x < EPS && y - p.y < EPS;\n\t}\n\n\tPoint add(Point p) {\n\t\treturn new Point(x + p.x, y + p.y);\n\t}\n\n\tPoint subtract(Point p) {\n\t\treturn new Point(x - p.x, y - p.y);\n\t}\n\n\tPoint multiply(double k) {\n\t\treturn new Point(x * k, y * k);\n\t}\n\n\tPoint devide(double k) {\n\t\treturn new Point(x / k, y / k);\n\t}\n\n\tdouble inner(Point p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\n\tdouble outer(Point p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tdouble abs() {\n\t\treturn Math.sqrt(norm());\n\t}\n}\n\nclass Segment {\n\tPoint p1, p2;\n\n\tpublic Segment() {\n\t\tthis(new Point(), new Point());\n\t}\n\n\tpublic Segment(Point p1, Point p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n}\n\nclass Circle {\n\tPoint c;\n\tdouble r;\n\n\tpublic Circle() {\n\t\tthis(new Point(), 0.0);\n\t}\n\n\tpublic Circle(Point c, double r) {\n\t\tthis.c = c;\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        boolean b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1.subtract(s1.p1)) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2.subtract(s1.p1))  < EPS ;\n        boolean b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1.subtract(s2.p1)) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2.subtract(s2.p1))  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextDouble();\n\t\t\ty0 = sc.nextDouble();\n\t\t\tx1 = sc.nextDouble();\n\t\t\ty1 = sc.nextDouble();\n\t\t\tx2 = sc.nextDouble();\n\t\t\ty2 = sc.nextDouble();\n\t\t\tx3 = sc.nextDouble();\n\t\t\ty3 = sc.nextDouble();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 * prd2 < 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??´???AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0\n\t\t\t *     ABxAC*ABxAD<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tif (xab != 0 || yab != 0) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\treturn (long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0;\n\t\t\t} else {\n\t\t\t\tint xcd = xd - xc;\n\t\t\t\tint ycd = yd - yc;\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??????AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0 && |CD|==0\n\t\t\t *     CAxCB==0 && CA.CB<0\n\t\t\t * |AB|!=0 && |CD|!=0\n\t\t\t *     ABxCD==0\n\t\t\t *         ACxAD==0 && (AB.AC>=0 || AB.AD>=0) && (BA.BC>=0 || BA.BD>=0)\n\t\t\t *     ABxCD!=0\n\t\t\t *         ABxAC*ABxAD<=0 && CDxCA*CDxCB<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tint xcd = xd - xc;\n\t\t\tint ycd = yd - yc;\n\t\t\tif ((xab != 0 || yab != 0) && (xcd != 0 || ycd != 0)) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\tif (cross(xab, yab, xcd, ycd) != 0) {\n\t\t\t\t\tint xca = -xac;\n\t\t\t\t\tint yca = -yac;\n\t\t\t\t\tint xcb = xb - xc;\n\t\t\t\t\tint ycb = yb - yc;\n\t\t\t\t\treturn ((long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0)\n\t\t\t\t\t\t\t&& ((long)cross(xcd, ycd, xca, yca) * cross(xcd, ycd, xcb, ycb) <= 0);\n\t\t\t\t} else {\n\t\t\t\t\tint xba = -xab;\n\t\t\t\t\tint yba = -yab;\n\t\t\t\t\tint xbc = xc - xb;\n\t\t\t\t\tint ybc = yc - yb;\n\t\t\t\t\tint xbd = xd - xb;\n\t\t\t\t\tint ybd = yd - yb;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0\n\t\t\t\t\t\t\t&& (dot(xab, yab, xac, yac) >= 0 || dot(xab, yab, xad, yad) >= 0)\n\t\t\t\t\t\t\t&& (dot(xba, yba, xbc, ybc) >= 0 || dot(xba, yba, xbd, ybd) >= 0);\n\t\t\t\t}\n\t\t\t} else if (xab != 0 || yab != 0) {\n\t\t\t\tint xca = xa - xc;\n\t\t\t\tint yca = ya - yc;\n\t\t\t\tint xcb = xb - xc;\n\t\t\t\tint ycb = yb - yc;\n\t\t\t\treturn cross(xca, yca, xcb, ycb) == 0 && dot(xca, yca, xcb, ycb) < 0;\n\t\t\t} else {\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n/*\n1\n0 0 0 3 0 1 0 2\n*/\n\npublic class Main{\n\tstatic double EPS = 0.0000000001;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint q = s.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tif (intersect(new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()) )) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ccw(Point lp0, Point lp1, Point p) {\n\t\tVector lv = lp1.diff(lp0);\n\t\tVector pv = p.diff(lp0);\n\t\tdouble cp=0.0;\n\t\tif ((cp=lv.crossProduct(pv))>EPS) {return -1;} // counter-clockwise\n\t\tif (cp<-EPS) {return 1;} // clockwise\n//\t\tif (lv.dotProduct(pv)<-EPS) return 2; // online-back\n//\t\tif (lv.norm() < pv.norm()) return 3; // online-front\n\t\treturn 0; // on-segment\n\t}\n\tstatic boolean intersect(Point p0, Point p1, Point p2, Point p3) {\n\t\treturn ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0 && ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0;}\n\tstatic boolean intersect(Segment s1, Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n\n}\nclass Point {\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tstatic double EPS = 0.0000000001;\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tclass P {\n\t\tdouble x, y;\n\n\t\tP(double x_, double y_) {\n\t\t\tx = x_;\n\t\t\ty = y_;\n\t\t}\n\n\t\tP add(P p) {\n\t\t\treturn new P(x + p.x, y + p.y);\n\t\t}\n\n\t\tP sub(P p) {\n\t\t\treturn new P(x - p.x, y - p.y);\n\t\t}\n\n\t\tP mul(double v) {\n\t\t\treturn new P(x * v, y * v);\n\t\t}\n\n\t\tP div(double v) {\n\t\t\treturn new P(x / v, y / v);\n\t\t}\n\n\t\tdouble dot(P p) {\n\t\t\treturn x * p.x + y * p.y;\n\t\t}\n\n\t\tdouble det(P p) {\n\t\t\treturn x * p.y - y * p.x;\n\t\t}\n\n\t\tdouble abs2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(abs2());\n\t\t}\n\n\t\tP norm() {\n\t\t\treturn div(abs());\n\t\t}\n\n\t\tP rot90() {\n\t\t\treturn new P(-y, x);\n\t\t}\n\n\t\tP proj(P src, P dst) {\n\t\t\tP p_sd = dst.sub(src).norm();\n\t\t\treturn src.add(p_sd.mul(sub(src).dot(p_sd)));\n\t\t}\n\n\t\tP reflect(P src, P dst) {\n\t\t\tP middle = proj(src, dst);\n\t\t\treturn add(middle.sub(this).mul(2));\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%f %f\", x, y);\n\t\t}\n\t}\n\n\tP isLL(P p1, P p2, P q1, P q2) {\n\t\tdouble d = p2.sub(p1).det(q1.sub(q2));\n\t\tif (Math.abs(d) < 1e-10)\n\t\t\treturn null;\n\t\treturn p1.add(p2.sub(p1).mul(q1.sub(q2).det(p1.sub(q2)) / d));\n\t}\n\n\tboolean intersect(P p1, P p2, P q1, P q2) {\n\t\treturn Line2D.linesIntersect(p1.x, p1.y, p2.x, p2.y, q1.x, q1.y, q2.x, q2.y);\n\t}\n\n\tvoid run() {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tP p1 = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tP p2 = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tP q1 = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tP q2 = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tSystem.out.println(intersect(p1, p2, q1, q2) ? 1 : 0);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tGeometry geom = new Geometry();\n\n\t\tint q = scan.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint x0 = scan.nextInt();\n\t\t\tint y0 = scan.nextInt();\n\t\t\tint x1 = scan.nextInt();\n\t\t\tint y1 = scan.nextInt();\n\t\t\tint x2 = scan.nextInt();\n\t\t\tint y2 = scan.nextInt();\n\t\t\tint x3 = scan.nextInt();\n\t\t\tint y3 = scan.nextInt();\n\t\t\tgeom.setBaseLine(new Point(x1 - x0, y1 - y0));\n\t\t\tPoint s1 = geom.rotateBaseX(new Point(x1 - x0, y1 - y0), true);\n\t\t\tPoint p2 = geom.rotateBaseX(new Point(x2 - x0, y2 - y0), true);\n\t\t\tPoint p3 = geom.rotateBaseX(new Point(x3 - x0, y3 - y0), true);\n\t\t\tif (p2.y == p3.y)\n\t\t\t\tif (p2.y == 0)\n\t\t\t\t\tif (Math.min(p2.x, p3.x) <= Math.max(0, s1.x) && Math.max(p2.x, p3.x) >= Math.min(0, s1.x))\n\t\t\t\t\t\tpwriter.println(\"1\");\n\t\t\t\t\telse\n\t\t\t\t\t\tpwriter.println(\"0\");\n\t\t\t\telse\n\t\t\t\t\tpwriter.println(\"0\");\n\t\t\telse {\n\t\t\t\tif (p2.y * p3.y <= 0) {\n\t\t\t\t\tPoint s2 = geom.crossX(p2, p3);\n\t\t\t\t\tif (s2.x <= Math.max(0, s1.x) && s2.x >= Math.min(0, s1.x))\n\t\t\t\t\t\tpwriter.println(\"1\");\n\t\t\t\t\telse\n\t\t\t\t\t\tpwriter.println(\"0\");\n\t\t\t\t} else\n\t\t\t\t\tpwriter.println(\"0\");\n\t\t\t}\n\t\t}\n\t\tpwriter.flush();\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Point {\n\tpublic double x, y;\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n}\n\nclass Geometry {\n\tdouble sin, cos;\n\n\tpublic void setBaseLine(Point v) {\n\t\tdouble t2 = v.x * v.x + v.y * v.y;\n\t\tsin = v.y / Math.sqrt(t2);\n\t\tcos = v.x / Math.sqrt(t2);\n\t}\n\n\tpublic Point crossX(Point p0, Point p1) {\n\t\tif (p0.y == p1.y)\n\t\t\treturn null;\n\t\t// y=(y1-y0)/(x1-x0)*(x-x0)+y0 : y=0\n\t\t// (y1-y0)*(x-x0)=-y0*(x1-x0)\n\t\t// x=x0-y0*(x1-x0)/(y1-y0)\n\t\t// x=(x0y1-x1y0)/(y1-y0)\n\t\treturn new Point(round((p0.x * p1.y - p1.x * p0.y) / (p1.y - p0.y)), 0);\n\t}\n\n\tpublic boolean isSameLine(Point p0, Point p1, Point p2) {\n\t\tif ((p1.x - p0.x) * (p2.y - p0.y) == (p2.x - p0.x) * (p1.y - p0.y))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic Point rotateBaseX(Point p, boolean direction) {\n\t\tif (direction)\n\t\t\treturn new Point(round(p.x * cos + p.y * sin), round(-p.x * sin + p.y * cos));\n\t\telse\n\t\t\treturn new Point(round(p.x * cos - p.y * sin), round(p.x * sin + p.y * cos));\n\t}\n\n\tprivate double round(double d) {\n\t\treturn (double) Math.round(d * 1000000000) / 1000000000;\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Segments/Lines - Intersection\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString line;\n\t\tString[] words;\n\n\t\tint q = sc.nextInt();\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tdouble xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\t\t\txp0 = sc.nextDouble();\n\t\t\typ0 = sc.nextDouble();\n\t\t\txp1 = sc.nextDouble();\n\t\t\typ1 = sc.nextDouble();\n\t\t\txp2 = sc.nextDouble();\n\t\t\typ2 = sc.nextDouble();\n\t\t\txp3 = sc.nextDouble();\n\t\t\typ3 = sc.nextDouble();\n\n\t\t\tPoint p0, p1, p2, p3;\n\t\t\tp0 = new Point(xp0, yp0);\n\t\t\tp1 = new Point(xp1, yp1);\n\t\t\tp2 = new Point(xp2, yp2);\n\t\t\tp3 = new Point(xp3, yp3);\n\n\t\t\tif (Geometries.isIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t} //end main\n}\n\nclass Geometries {\n\n\tstatic double EPS = 1e-10;\n\n\t//????????????\n\tstatic boolean equals(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\t//\n\tstatic enum Order {\n\t\tCOUNTER_CLOCKWISE(1),   //???????¨???????\n\t\tCLOCKWISE(-1),          //????¨???????\n\t\tONLINE_BACK(2),         //???????????????????????´??????\n\t\tONLINE_FRONT(-2),       //????????????????????´??????\n\t\tON_SEGMENT(0);          //???????????????\n\n\t\tprivate int value;\n\n\t\tOrder(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\t//?????????\n\tstatic Order order(Point p0, Point p1, Point p2) {\n\t\tPoint v1 = p1.subtract(p0);\n\t\tPoint v2 = p2.subtract(p0);\n\t\tif (v1.outer(v2) > EPS) {return Order.COUNTER_CLOCKWISE;}\n\t\tif (v1.outer(v2) < -EPS) {return Order.CLOCKWISE;}\n\t\tif (v1.inner(v2) < -EPS) {return Order.ONLINE_BACK;}\n\t\tif (v1.norm() < v2.norm()) {return Order.ONLINE_FRONT;}\n\t\treturn Order.ON_SEGMENT;\n\t}\n\n\tstatic Order order(Segment s, Point p) {\n\t\tPoint p0 = s.p1;\n\t\tPoint p1 = s.p2;\n\t\treturn order(p0, p1, p);\n\t}\n\n\t//??´?????????\n\tstatic boolean isOrthogonal(Point a, Point b) {\n\t\treturn equals(a.inner(b), 0.0);\n\t}\n\n\tstatic boolean isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isOrthogonal(Segment s1, Segment s2) {\n\t\treturn isOrthogonal(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isParallel(Point a, Point b) {\n\t\treturn equals(a.outer(b), 0.0);\n\t}\n\n\tstatic boolean isParallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isParallel(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isParallel(Segment s1, Segment s2) {\n\t\treturn isParallel(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isIntersect(Point a1, Point a2, Point b1, Point b2) {\n\t\tOrder o1, o2, o3, o4;\n\t\to1 = order(a1, a2, b1);\n\t\to2 = order(a1, a2, b2);\n\t\to3 = order(b1, b2, a1);\n\t\to4 = order(b1, b2, a2);\n\n\t\tif (o1 == Order.ON_SEGMENT\n\t\t\t\t|| o2 == Order.ON_SEGMENT\n\t\t\t\t|| o3 == Order.ON_SEGMENT\n\t\t\t\t|| o4 == Order.ON_SEGMENT\n\t\t\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (((o1 == Order.COUNTER_CLOCKWISE && o2 == Order.CLOCKWISE)\n\t\t\t\t|| (o1 == Order.CLOCKWISE && o2 == Order.COUNTER_CLOCKWISE))\n\t\t\t\t&& ((o3 == Order.COUNTER_CLOCKWISE && o4 == Order.CLOCKWISE)\n\t\t\t\t|| (o3 == Order.CLOCKWISE && o4 == Order.COUNTER_CLOCKWISE))) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tstatic boolean isIntersect(Segment s1, Segment s2) {\n\t\tPoint a1 = s1.p1;\n\t\tPoint a2 = s1.p2;\n\t\tPoint b1 = s2.p1;\n\t\tPoint b2 = s2.p2;\n\t\treturn isIntersect(a1, a2, b1, b2);\n\t}\n}\n\nclass Point implements Comparable<Point> {\n\n\tstatic double EPS = 1e-10;\n\n\tdouble x, y;\n\n\tPoint() {\n\t\tthis(0.0, 0.0);\n\t}\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic int compareTo(Point p) {\n\t\tif (equals(p)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (x != p.x) {\n\t\t\t\treturn Double.compare(y, p.y);\n\t\t\t} else {\n\t\t\t\treturn Double.compare(x, p.x);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tPoint p = (Point) obj;\n\t\treturn x - p.x < EPS && y - p.y < EPS;\n\t}\n\n\tPoint add(Point p) {\n\t\treturn new Point(x + p.x, y + p.y);\n\t}\n\n\tPoint subtract(Point p) {\n\t\treturn new Point(x - p.x, y - p.y);\n\t}\n\n\tPoint multiply(double k) {\n\t\treturn new Point(x * k, y * k);\n\t}\n\n\tPoint devide(double k) {\n\t\treturn new Point(x / k, y / k);\n\t}\n\n\tdouble inner(Point p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\n\tdouble outer(Point p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tdouble abs() {\n\t\treturn Math.sqrt(norm());\n\t}\n}\n\nclass Segment {\n\tPoint p1, p2;\n\n\tpublic Segment() {\n\t\tthis(new Point(), new Point());\n\t}\n\n\tpublic Segment(Point p1, Point p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n}\n\nclass Circle {\n\tPoint c;\n\tdouble r;\n\n\tpublic Circle() {\n\t\tthis(new Point(), 0.0);\n\t}\n\n\tpublic Circle(Point c, double r) {\n\t\tthis.c = c;\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.math.BigDecimal;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint q = stdIn.nextInt();\n\t\tfor(int i=0;i<q;i++){\n\t\t\tdouble x0 = stdIn.nextDouble();\n\t\t\tdouble y0 = stdIn.nextDouble();\n\t\t\tdouble x1 = stdIn.nextDouble();\n\t\t\tdouble y1 = stdIn.nextDouble();\n\t\t\tdouble x2 = stdIn.nextDouble();\n\t\t\tdouble y2 = stdIn.nextDouble();\n\t\t\tdouble x3 = stdIn.nextDouble();\n\t\t\tdouble y3 = stdIn.nextDouble();\n\t\t\tPoint p0 = new Point(x0,y0);\n\t\t\tPoint p1 = new Point(x1,y1);\n\t\t\tPoint p2 = new Point(x2,y2);\n\t\t\tPoint p3 = new Point(x3,y3);\n\t\t\tif(p0.intersect(p1,p2,p3)){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\t\n}\nclass Point{\n\n\tpublic double x,y;\n\tfinal double EPS = Math.pow(10,-8);\n\tfinal int cutoff = 9;\n\n\tPoint(double x,double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tdouble abs(){\n\t\tPoint a = new Point(0,0);\t\n\t\treturn Math.sqrt(norm(a));\t\n\t}\n\tdouble abs( Point a ){\n\t\treturn Math.sqrt(norm(a));\n\t}\n\tdouble norm( Point a ){\t\n\t\treturn rounding((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));\n\t}\n\n\tvoid add( Point a ){\n\t\tthis.x = rounding(this.x + a.x);\n\t\tthis.y = rounding(this.y + a.y);\n\t}\n\tvoid sub( Point a ){\n\t\tthis.x = rounding(this.x - a.x);\n\t\tthis.y = rounding(this.y - a.y);\n\t}\n\tvoid mul( double z){\n\t\tthis.x = rounding(this.x * z);\n\t\tthis.y = rounding(this.x * z);\n\t}\n\tvoid div( double z){\n\t\tthis.x = rounding(this.x / z);\n\t\tthis.y = rounding(this.x / z);\n\t}\n\n\tPoint getCrossPoint( Point a , Point b , Point c ){\n\t\tPoint d = new Point(this.x,this.y);\n\t\tVector s1 = new Vector(d.x,d.y,a.x,a.y);\n\t\tVector s2 = new Vector(b.x,b.y,c.x,c.y);\n\t\tdouble t1 = getDistanceSP(b,c);\n\t\tdouble t2 = a.getDistanceSP(b,c);\n\t\ts1.mul(t1/(t1+t2));\n\t\tVector s3 = new Vector(b.x,b.y,d.x,d.y);\n\t\ts3.add(s1);\n\t\treturn new Point(b.x+s3.x,b.y+s3.y);\n\t}\n\n\tdouble getDistance( Point a , Point b , Point c ){\n\t\tif(intersect(a,b,c)){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn Math.min(getDistanceSP(b,c),a.getDistanceSP(b,c));\n\t}\n\tdouble getDistanceSP( Point a , Point b ){\n\t\tVector s = new Vector( a.x , a.y , b.x , b.y);\n\t\tVector sa = new Vector( a.x , a.y , this.x , this.y );\n\t\tVector sb = new Vector( b.x , b.y , this.x , this.y );\n\t\tif(s.dot(sa)<0.00){\n\t\t\treturn abs(a);\n\t\t}\n\t\ts.mul(-1);\n\t\tif(s.dot(sb)<0.00){\n\t\t\treturn abs(b);\n\t\t}\n\t\treturn Math.abs(s.cross(sb)/s.abs());\n\t}\n\n\tint CCW( Point a , Point b ){\n\t\tVector sa = new Vector( this.x , this.y , a.x , a.y );\n\t\tVector sb = new Vector( this.x , this.y , b.x , b.y );\n\t\tif(sa.cross(sb) > EPS){\n\t\t\treturn -1;\n\t\t}\n\t\telse if(sa.cross(sb) < -EPS){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(sa.dot(sb) < -EPS){\n\t\t\treturn -2;\n\t\t}\n\t\telse if(sa.norm() < sb.norm()){\n\t\t\treturn 2;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tboolean intersect( Point a , Point b , Point c ){\n\t\tPoint d = new Point(this.x,this.y);\n\t\tif(CCW(a,b)*CCW(a,c) <= 0 && b.CCW(c,a)*b.CCW(c,d) <= 0){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tint contains( Point[] query ){\n\t\tboolean flag1 = false;\n\t\tboolean flag2 = false;\n\t\tPoint p1 = new Point(this.x+1,this.y);\n\t\tfor(int i=0;i<query.length;i++){\n\t\t\tif(CCW(query[i],p1) == 2 || CCW(query[i],p1) == 0){\n\t\t\t\tflag1 = true;\n\t\t\t}\n\t\t}\n\t\tPoint p2 = new Point(Integer.MAX_VALUE/2,this.y);\n\t\tfinal int l = query.length;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(intersect(p2,query[i%l],query[(i+1)%l])){\n\t\t\t\tflag2 = true;\n\t\t\t}\n\t\t}\n\n\t\tif(flag1){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(flag2){\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid temp( Point a ){\n\t\tPoint temp = new Point(0,0);\n\t\ttemp.x = this.x;\n\t\ttemp.y = this.y;\n\t\tthis.x = a.x;\n\t\tthis.y = a.y;\n\t\ta.x = temp.x;\n\t\ta.y = temp.y;\n\t}\n\tvoid sort( Point[] query ){\n\t\tfor(int i=0;i<query.length;i++){\n\t\t\tfor(int j=0;j<query.length-1-i;j++){\n\t\t\t\tif(query[j].x > query[j+1].x){\n\t\t\t\t\tquery[j].temp(query[j+1]);\n\t\t\t\t}\n\t\t\t\telse if(query[j].x == query[j+1].x && query[j].y > query[j+1].y){\n\t\t\t\t\tquery[j].temp(query[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tArrayList<Point> andrewScan( Point[] query ){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tif(query.length<4){\n\t\t\tfor(int i=0;i<query.length;i++){\n\t\t\t\tlist.add(query[i]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsort(query);\n\t\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\t\tlist1.add(query[0]);\n\t\t\tlist1.add(query[1]);\n\t\t\tint next = 2;\n\t\t\twhile(next<query.length-1){\n\t\t\t\tif(list1.size()<2){\n\t\t\t\t\tlist1.add(query[next]);\n\t\t\t\t\tnext++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint p1 = list1.get(list1.size()-2);\n\t\t\t\t\tPoint p2 = list1.get(list1.size()-1);\n\t\t\t\t\tif(p1.CCW(p2,query[next])!=-1){\n\t\t\t\t\t\tlist1.add(query[next]);\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlist1.remove(list1.size()-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPoint p1 = list1.get(list1.size()-2);\n\t\t\tPoint p2 = list1.get(list1.size()-1);\n\t\t\tif(p1.CCW(p2,query[query.length-1])!=-1){\n\t\t\t\tlist1.add(query[query.length-1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist1.remove(list1.size()-1);\n\t\t\t\tlist1.add(query[query.length-1]);\n\t\t\t}\n\t\t\tlist2.add(query[query.length-1]);\n\t\t\tlist2.add(query[query.length-2]);\n\t\t\tnext = query.length-3;\n\t\t\twhile(next>0){\n\t\t\t\tif(list2.size()<2){\n\t\t\t\t\tlist2.add(query[next]);\n\t\t\t\t\tnext--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint a = list2.get(list2.size()-2);\n\t\t\t\t\tPoint b = list2.get(list2.size()-1);\n\t\t\t\t\tif(a.CCW(b,query[next])!=-1){\n\t\t\t\t\t\tlist2.add(query[next]);\n\t\t\t\t\t\tnext--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlist2.remove(list2.size()-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1 = list2.get(list2.size()-2);\n\t\t\tp2 = list2.get(list2.size()-1);\n\t\t\tif(p1.CCW(p2,query[0])>=0){\n\t\t\t\tlist2.add(query[0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist2.remove(list2.size()-1);\n\t\t\t\tlist2.add(query[0]);\n\t\t\t}\n\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\tlist.add(list1.get(i));\n\t\t\t}\n\t\t\tfor(int i=1;i<list2.size()-1;i++){\n\t\t\t\tlist.add(list2.get(i));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tPoint polarCos(double cos_a){\n\t\tdouble sin_a = Math.sqrt(1-Math.pow(cos_a,2));\n\t\tdouble x = cos_a*this.x - sin_a*this.y;\n\t\tdouble y = sin_a*this.x + cos_a*this.y;\n\t\treturn new Point(x,y); \n\t}\n\tPoint polarSin(double sin_a){\n\t\tdouble cos_a = Math.sqrt(1-Math.pow(sin_a,2));\n\t\tdouble x = cos_a*this.x - sin_a*this.y;\n\t\tdouble y = sin_a*this.x + cos_a*this.y;\n\t\treturn new Point(x,y); \n\t}\n\n\tboolean judge( Point a ){\t\n\t\tif( Math.abs( this.x - a.x ) < EPS && Math.abs( this.y - a.y ) < EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tdouble rounding(double a){\n\t\tBigDecimal bi = new BigDecimal(String.valueOf(a));\n\t\treturn bi.setScale(cutoff,BigDecimal.ROUND_HALF_UP).doubleValue();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n\n    public Segment() {\n        this(new Point(), new Point());\n    }\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static bool cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos3 = ccw(s2, s1.p2);\n        return pos1.id * pos2.id <= 0 && pos3.id * pos4.id <= 0\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n/*\n1\n0 0 5 0 1 0 1 2\n*/\n\npublic class Main{\n\tstatic double EPS = 0.0000000001;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint q = s.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tif (intersect(new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()) )) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ccw(Point lp0, Point lp1, Point p) {\n\t\tVector lv = lp1.diff(lp0);\n\t\tVector pv = p.diff(lp0);\n\t\tdouble cp=0.0;\n\t\tif ((cp=lv.crossProduct(pv))>EPS) {return -1;} // counter-clockwise\n\t\tif (cp<-EPS) {return 1;} // clockwise\n\t\tif (lv.dotProduct(pv)<-EPS) return 2; // online-back\n\t\tif (lv.norm() < pv.norm()) return 3; // online-front\n\t\treturn 0; // on-segment\n\t}\n\tstatic boolean intersect(Point p0, Point p1, Point p2, Point p3) {return ccw(p0,p1,p2)*ccw(p0,p1,p3)<=0 && ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0;}\n\tstatic boolean intersect(Segment s1, Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n\n}\nclass Point {\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tstatic double EPS = 0.0000000001;\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tint q = in.nextInt();\n\t\tfor(int i=0;i<q;i++)new CGL_2B().doIt();\n\t}\n\t\n\tclass CGL_2B{\n\t\tvoid doIt(){\n\t\t\tLine2D l1 = new Line2D.Double(in.nextDouble(),in.nextDouble(),in.nextDouble(),in.nextDouble());;\n\t\t\tLine2D l2 = new Line2D.Double(in.nextDouble(),in.nextDouble(),in.nextDouble(),in.nextDouble());;\n\t\t\tif(l1.intersectsLine(l2))System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tif(x0 >= x1) {\n\t\t\t\tif((x0<x2 && x0<x3) || (x1>x2 && x1>x3)) {\n\t\t\t\t\tans.append(0);\n\t\t\t\t\tans.append(\"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif((x1<x2 && x1<x3) || (x0>x2 && x0>x3)) {\n\t\t\t\t\tans.append(0);\n\t\t\t\t\tans.append(\"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(y0 >= y1) {\n\t\t\t\tif((y0<y2 && y0<y3) || (y1>y2 && y1>y3)) {\n\t\t\t\t\tans.append(0);\n\t\t\t\t\tans.append(\"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif((y1<y2 && y1<y3) || (y0>y2 && y0>y3)) {\n\t\t\t\t\tans.append(0);\n\t\t\t\t\tans.append(\"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(((x0-x1)*(y2-y0)+(y0-y1)*(x0-x2))*((x0-x1)*(y3-y0)+(y0-y1)*(x0-x3))>0) {\n\t\t\t\tans.append(0);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(((x2-x3)*(y0-y2)+(y2-y3)*(x2-x0))*((x2-x3)*(y1-y2)+(y2-y3)*(x2-x1))>0) {\n\t\t\t\tans.append(0);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tans.append(1);\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n\n        public Segment() {\n            this(new Point(), new Point());\n        }\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static bool cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS \n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS \n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1 && x2 == x3 || Math.abs(a2 - a1) < ALLOWABLE_ERROR) {\n\t\t\t\tif((Math.min(y0, y1) <= y2 && y2 <= Math.max(y0, y1)) || (Math.min(y0, y1) <= y3 && y3 <= Math.max(y0, y1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(y0 == y1 && y2 == y3) {\n\t\t\t\tif((Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1)) || (Math.min(x0, x1) <= x3 && x3 <= Math.max(x0, x1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(x2, x3) <= x0 && x0 <= Math.max(x2, x3) && Math.min(y0, y1) <= y && y <= Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1) && Math.min(y2, y3) <= y && y <= Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) <= x && x <= Math.max(x0, x1) && Math.min(x2, x3) <= x && x <= Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Segments/Lines - Intersection\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString line;\n\t\tString[] words;\n\n\t\tint q = sc.nextInt();\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tdouble xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\t\t\txp0 = sc.nextDouble();\n\t\t\typ0 = sc.nextDouble();\n\t\t\txp1 = sc.nextDouble();\n\t\t\typ1 = sc.nextDouble();\n\t\t\txp2 = sc.nextDouble();\n\t\t\typ2 = sc.nextDouble();\n\t\t\txp3 = sc.nextDouble();\n\t\t\typ3 = sc.nextDouble();\n\n\t\t\tPoint p0, p1, p2, p3;\n\t\t\tp0 = new Point(xp0, yp0);\n\t\t\tp1 = new Point(xp1, yp1);\n\t\t\tp2 = new Point(xp2, yp2);\n\t\t\tp3 = new Point(xp3, yp3);\n\n\t\t\tif (Geometries.isIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t} //end main\n}\n\nclass Geometries {\n\n\tstatic double EPS = 1e-10;\n\n\t//????????????\n\tstatic boolean equals(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\t//\n\tstatic enum Order {\n\t\tCOUNTER_CLOCKWISE(1),   //???????¨???????\n\t\tCLOCKWISE(-1),          //????¨???????\n\t\tONLINE_BACK(2),         //???????????????????????´??????\n\t\tONLINE_FRONT(-2),       //????????????????????´??????\n\t\tON_SEGMENT(0);          //???????????????\n\n\t\tprivate int value;\n\n\t\tOrder(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\t//?????????\n\tstatic Order order(Point p0, Point p1, Point p2) {\n\t\tPoint v1 = p1.subtract(p0);\n\t\tPoint v2 = p2.subtract(p0);\n\t\tif (v1.outer(v2) > EPS) {return Order.COUNTER_CLOCKWISE;}\n\t\tif (v1.outer(v2) < -EPS) {return Order.CLOCKWISE;}\n\t\tif (v1.inner(v2) < -EPS) {return Order.ONLINE_BACK;}\n\t\tif (v1.norm() < v2.norm()) {return Order.ONLINE_FRONT;}\n\t\treturn Order.ON_SEGMENT;\n\t}\n\n\tstatic Order order(Segment s, Point p) {\n\t\tPoint p0 = s.p1;\n\t\tPoint p1 = s.p2;\n\t\treturn order(p0, p1, p);\n\t}\n\n\t//??´?????????\n\tstatic boolean isOrthogonal(Point a, Point b) {\n\t\treturn equals(a.inner(b), 0.0);\n\t}\n\n\tstatic boolean isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isOrthogonal(Segment s1, Segment s2) {\n\t\treturn isOrthogonal(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isParallel(Point a, Point b) {\n\t\treturn equals(a.outer(b), 0.0);\n\t}\n\n\tstatic boolean isParallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isParallel(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isParallel(Segment s1, Segment s2) {\n\t\treturn isParallel(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isIntersect(Point a1, Point a2, Point b1, Point b2) {\n\t\tOrder o1, o2;\n\t\to1 = order(a1, a2, b1);\n\t\to2 = order(a1, a2, b2);\n\t\tif (o1 == Order.COUNTER_CLOCKWISE && o2 == Order.CLOCKWISE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1 == Order.CLOCKWISE && o2 == Order.COUNTER_CLOCKWISE) {\n\t\t\treturn true;\n\t\t}\n\t\to1 = order(b1, b2, a1);\n\t\to2 = order(b1, b2, a2);\n\t\tif (o1 == Order.COUNTER_CLOCKWISE && o2 == Order.CLOCKWISE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1 == Order.CLOCKWISE && o2 == Order.COUNTER_CLOCKWISE) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isIntersect(Segment s1, Segment s2) {\n\t\tPoint a1 = s1.p1;\n\t\tPoint a2 = s1.p2;\n\t\tPoint b1 = s2.p1;\n\t\tPoint b2 = s2.p2;\n\t\treturn isIntersect(a1, a2, b1, b2);\n\t}\n}\n\nclass Point implements Comparable<Point> {\n\n\tstatic double EPS = 1e-10;\n\n\tdouble x, y;\n\n\tPoint() {\n\t\tthis(0.0, 0.0);\n\t}\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic int compareTo(Point p) {\n\t\tif (equals(p)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (x != p.x) {\n\t\t\t\treturn Double.compare(y, p.y);\n\t\t\t} else {\n\t\t\t\treturn Double.compare(x, p.x);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tPoint p = (Point) obj;\n\t\treturn x - p.x < EPS && y - p.y < EPS;\n\t}\n\n\tPoint add(Point p) {\n\t\treturn new Point(x + p.x, y + p.y);\n\t}\n\n\tPoint subtract(Point p) {\n\t\treturn new Point(x - p.x, y - p.y);\n\t}\n\n\tPoint multiply(double k) {\n\t\treturn new Point(x * k, y * k);\n\t}\n\n\tPoint devide(double k) {\n\t\treturn new Point(x / k, y / k);\n\t}\n\n\tdouble inner(Point p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\n\tdouble outer(Point p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tdouble abs() {\n\t\treturn Math.sqrt(norm());\n\t}\n}\n\nclass Segment {\n\tPoint p1, p2;\n\n\tpublic Segment() {\n\t\tthis(new Point(), new Point());\n\t}\n\n\tpublic Segment(Point p1, Point p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n}\n\nclass Circle {\n\tPoint c;\n\tdouble r;\n\n\tpublic Circle() {\n\t\tthis(new Point(), 0.0);\n\t}\n\n\tpublic Circle(Point c, double r) {\n\t\tthis.c = c;\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\tstatic double EPS = 0.0000000001;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint q = s.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tif (intersect(new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()) )) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ccw(Point lp0, Point lp1, Point p) {\n\t\tVector lv = lp1.diff(lp0);\n\t\tVector pv = p.diff(lp0);\n\t\tdouble cp=0.0;\n\t\tif ((cp=lv.crossProduct(pv))>EPS) {return 1;} // counter-clockwise\n\t\tif (cp<-EPS) {return 2;} // clockwise\n\t\tif (lv.dotProduct(pv)<-EPS) return 3; // online-back\n\t\tif (lv.norm() < pv.norm()) return 4; // online-front\n\t\treturn 5; // on-segment\n\t}\n\tstatic boolean intersect(Point p0, Point p1, Point p2, Point p3) {return ccw(p0,p1,p2)*ccw(p0,p1,p3)==2 && ccw(p2,p3,p0)*ccw(p2,p3,p1)==2;}\n\tstatic boolean intersect(Segment s1, Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n\n}\nclass Point {\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tstatic double EPS = 0.0000000001;\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    double xp0, xp1, yp0, yp1, xp2, yp2, xp3, yp3;\n    int q;\n    int i;\n    double s1x, s1y, s2x, s2y, s3x, s3y, s1, s2;\n\n    q = sc.nextInt();\n    for(i = 0;i < q;i++){\n      xp0 = sc.nextDouble();\n      yp0 = sc.nextDouble();\n      xp1 = sc.nextDouble();\n      yp1 = sc.nextDouble();\n      xp2 = sc.nextDouble();\n      yp2 = sc.nextDouble();\n      xp3 = sc.nextDouble();\n      yp3 = sc.nextDouble();\n\n      s1x = xp1 - xp0;\n      s1y = yp1 - yp0;\n      s2x = xp2 - xp0;\n      s2y = yp2 - yp0;\n      s3x = xp3 - xp0;\n      s3y = yp3 - yp0;\n\n      s1 = s1x * s2y - s1y * s2x;\n      s2 = s1x * s3y - s1y * s3x;\n\n      if(s1 * s2 > 0){\n        System.out.println(\"0\");  //no\n      }else{\n        s1x = xp3 - xp2;\n        s1y = yp3 - yp2;\n        s2x = xp0 - xp2;\n        s2y = yp0 - yp2;\n        s3x = xp1 - xp2;\n        s3y = yp1 - yp2;\n\n        s1 = s1x * s2y - s1y * s2x;\n        s2 = s1x * s3y - s1y * s3x;\n        if(s1 * s2 > 0){\n          System.out.println(\"0\");  //no\n        }else{\n          System.out.println(\"1\");  //yes\n        }\n      }\n    }\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(x2, x3) <= x0 && x0 <= Math.max(x2, x3) && Math.min(y0, y1) <= y && y <= Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1) && Math.min(y2, y3) <= y && y <= Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) <= x && x <= Math.max(x0, x1) && Math.min(x2, x3) <= x && x <= Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic final double EPS = 0.00000000001;\n\tstatic final int COUNTER_CLOCKWISE = 1;\n\tstatic final int CLOCKWISE = -1;\n\tstatic final int ONLINE_BACK = 2;\n\tstatic final int ONLINE_FRONT = -2;\n\tstatic final int ON_SEGMENT = 0;\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint q = scan.nextInt();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint[]p0 = new int[2];\n\t\t\tint[]p1 = new int[2];\n\t\t\tint[]p2 = new int[2];\n\t\t\tint[]p3 = new int[2];\n\t\t\tp0[0] = scan.nextInt();\n\t\t\tp0[1] = scan.nextInt();\n\t\t\tp1[0] = scan.nextInt();\n\t\t\tp1[1] = scan.nextInt();\n\t\t\tp2[0] = scan.nextInt();\n\t\t\tp2[1] = scan.nextInt();\n\t\t\tp3[0] = scan.nextInt();\n\t\t\tp3[1] = scan.nextInt();\n\t\t\tif(intersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\n\t}\n\tstatic boolean intersect(int[]p1, int[]p2, int[]p3, int[]p4) {\n\t\tif(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0) {\n\t\t\treturn true;\n\t\t}else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatic int ccw(int[]p0, int[]p1, int[]p2) {\n\t\tint[]a = {p1[0] - p0[0], p1[1] - p0[1]};\n\t\tint[]b = {p2[0] - p0[0], p2[1] - p0[1]};\n\t\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif(norm(a) < norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\tstatic int norm(int[]p) {\n\t\treturn p[0] * p[0] + p[1] * p[1];\n\t}\n\tstatic int[] vec(int[]p1, int[]p2) {\n\t\tint[]u = {p2[0] - p1[0], p2[1] - p1[1]};\n\t\treturn u;\n\t}\n\tstatic int dot(int[]u, int[]v) {\n\t\treturn u[0] * v[0] + u[1] * v[1];\n\t}\n\tstatic int cross(int[]u, int[]v) {\n\t\treturn u[0] * v[1] - u[1] * v[0];\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextDouble();\n\t\t\ty0 = sc.nextDouble();\n\t\t\tx1 = sc.nextDouble();\n\t\t\ty1 = sc.nextDouble();\n\t\t\tx2 = sc.nextDouble();\n\t\t\ty2 = sc.nextDouble();\n\t\t\tx3 = sc.nextDouble();\n\t\t\ty3 = sc.nextDouble();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\n\nimport javax.sound.midi.MidiMessage;\n \npublic class Main {\n\t\tstatic long MOD=(long) (Math.pow(10, 9)+7);\n\t\tstatic boolean[] visited;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\t int n = sc.nextInt();\n\t     Geometric geometric=new Geometric();\n\t     for (int i = 0; i < n; i++) {\n\t    \t int x0 = sc.nextInt();\n\t    \t int y0 = sc.nextInt();\n\t    \t int x1 = sc.nextInt();\n\t    \t int y1 = sc.nextInt();\n\t    \t int x2 = sc.nextInt();\n\t    \t int y2 = sc.nextInt();\n\t    \t int x3 = sc.nextInt();\n\t    \t int y3 = sc.nextInt();\n\t    \t boolean flag=geometric.crosssegmentline((double)x0, (double)y0, (double)x1, (double)y1, (double)x2, (double)y2, (double)x3, (double)y3);\n\t    \t if (flag) {\n\t\t\t\tout.println(1);\n\t\t\t}\n\t    \t else {\n\t\t\t\tout.println(0);\n\t\t\t}\n\t     }\n\t     out.flush();\n\t}\n\tstatic class Geometric{\n\t\tstatic final double eps = 0.0000000001;\n\t\tdouble[] project(double x1, double y1, double x2, double y2, double px, double py){\n\t\t\t//(x1,y1)と(x2,y2)を直線lとして、(px,py)からlに下した垂線の足をもとめる。\n\t        if(y1 == y2) {\n\t        \tdouble[] ans= {px,y1};\n\t        \treturn ans;\n\t        \t}\n\t        else if(x1 == x2) {\n\t        \tdouble[] ans= {x1,py};\n\t        \treturn ans;\n\t        }\n\t        else{\n\t            double katamuki1 = (y2 - y1)/(x2 - x1);\n\t            double seppen1 = -katamuki1 * x1 + y1;\n\t            double katamuki2 = -1.0 / katamuki1;\n\t            double seppen2 = -katamuki2 * px + py;\n\t            double ansx = (seppen2 - seppen1)/(katamuki1 - katamuki2);\n\t            double ansy = ansx * katamuki1 + seppen1;\n\t            double[] ans= {ansx,ansy};\n\t            return ans;\n\t        }\n\t    }\n\t    double[] project2(double x1, double y1, double x2, double y2, double px, double py){\n\t    \t//(x1,y1)と(x2,y2)を直線lとして、lに対して(px,py)の対称な点をもとめる。\n\t        if(y1 == y2) {\n\t        \tdouble[] ans= {px,(py - 2*(py - y1))};\n\t        \treturn ans;\n\t        }\n\t        else if(x1 == x2) {\n\t        \tdouble[] ans= {(px - 2*(px - x1)),py};\n\t        \treturn ans;\n\t        }\n\t        else{\n\t            double katamuki1 = (y2 - y1)/(x2 - x1);\n\t            double seppen1 = -1.0 * katamuki1 * x1 + y1;\n\t            double katamuki2 = -1.0 / katamuki1;\n\t            double seppen2 = -1.0 * katamuki2 * px + py;\n\t            double ansx = (seppen2 - seppen1)/(katamuki1 - katamuki2);\n\t            double ansy = ansx * katamuki1 + seppen1;\n\t            double[] ans= {(px - 2*(px - ansx)),(py- 2 * (py - ansy))};\n\t            return ans;\n\t        }\n\t    }\n\t    public double d2(double x0,double y0,double x1,double y1){\n\t\t\treturn (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1);\n\t\t}\n\t\tpublic double d1(double x0,double y0,double x1,double y1){\n\t\t\treturn Math.sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));\n\t\t}\n\t\tboolean crosssegmentline(double x0,double y0,double x1,double y1,double x2,double y2,double x3,double y3) {\n\t\t\tdouble s=0;\n\t\t\tdouble t=0;\n\t\t\tdouble s_=0;\n\t\t\tdouble t_=0;\n\t\t    s = (x0 - x1) * (y2 - y0) - (y0 - y1) * (x2 - x0);\n\t\t    t = (x0 - x1) * (y3 - y0) - (y0 - y1) * (x3 - x0);\n\t\t    if (s * t > 0) return false;\n\t\t    s_ = (x2 - x3) * (y0 - y2) - (y2 - y3) * (x0 - x2);\n\t\t    t_ = (x2 - x3) * (y1 - y2) - (y2 - y3) * (x1 - x2);\n\t\t    if (s_ * t_ > 0) return false;\n\t\t    if (s*t==0&&s_*t_==0) {\n\t\t\t\tif (this.direction(x0, y0, x1, y1, x2, y2)==5||this.direction(x0, y0, x1, y1, x3, y3)==5) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (this.direction(x2, y2, x3, y3, x0, y0)==5||this.direction(x2, y2, x3, y3, x1, y1)==5) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t    return true;\n\t\t}\n\t    int direction(double x0,double y0,double x1,double y1,double x2,double y2){\n\t\t\t//x0 y0を起点としてp1ベクトル（x1-x0,y1-y0）から見てp2ベクトルが、反時計回りなら１、時計回りなら２、反対方向なら３、\n\t    \t//同じ方向かつp2のほうが大きい場合４、以下の場合５．\n\t\t\tif(x1 == x0 && y1 == y0){\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t\telse if(x2 == x0 && y2 == y0){\n\t\t\t\treturn 5;\n\t\t\t}\n\t\t\t\n\t\t\t//外積の第三成分 = |→p1||→p2|sinθ\n\t\t\tdouble det = (x1 -x0)*(y2-y0) - (x2 -x0)*(y1 - y0);\n\t\t\t\n\t\t\tif(det>eps){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(det<-eps){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse{\t//同一直線状\n\t\t\t\tif((x1-x0 >0 == x2-x0 <0) && x1-x0 != 0){\t//反対側\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\telse if((y1-y0 >0 == y2-y0 <0) && y1-y0 != 0){\t//反対側\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble d10 = d2(x0,y0,x1,y1);\t//p1とp0の距離^2\n\t\t\t\t\tdouble d20 = d2(x0,y0,x2,y2);\t//p2とp0の距離^2\n\t\t\t\t\tif(d10 < d20){\t//p2のほうが遠い\n\t\t\t\t\t\treturn 4;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\treturn 5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t    int paralell_or_vertical(double x0,double y0,double x1,double y1,double x2,double y2,double x3,double y3) {\n\t    \t//平行なら2　垂直なら1　それ以外は０を返す。\n\t    \tdouble naiseki=(x1-x0)*(x3-x2)+(y1-y0)*(y3-y2);\n\t    \tdouble d1=Math.sqrt(d2(x0, y0, x1, y1));\n\t    \tdouble d2=Math.sqrt(d2(x2, y2, x3, y3));\n\t    \tdouble cos=naiseki/(d1*d2);\n\t    \t\n\t    \tif (cos+eps>=1||cos-eps<=-1) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t    \telse if(cos<eps&&cos>-eps){\n\t\t\t\treturn 1;\n\t\t\t}\n\t    \telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t    }\n\t}\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    static final int INF = (1 << 31) - 1;             \n    static final int MAXN = 11111;     \n    static int a1, b1, c1;\n    static int a2, b2, c2;\n    \n    public static void main(String[] args) throws Exception {                \n        Scanner input = new Scanner(System.in);\n        int q = input.nextInt();\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        for (int i = 0; i < q; ++i) {\n            x0 = input.nextInt();\n            y0 = input.nextInt();\n            x1 = input.nextInt();\n            y1 = input.nextInt();\n            x2 = input.nextInt();\n            y2 = input.nextInt();\n            x3 = input.nextInt();\n            y3 = input.nextInt();            \n            a1 = y0 - y1;\n            b1 = x1 - x0;\n            c1 = - a1 * x0 - b1 * y0;\n            a2 = y2 - y3;\n            b2 = x3 - x2;\n            c2 = - a2 * x2 - b2 * y2;\n            if (check1(x2, y2, x3, y3) && check2(x0, y0, x1, y1)) System.out.println(\"1\");\n            else System.out.println(\"0\");\n            \n        }\n    }             \n    \n    static boolean check1(int x1, int y1, int x2, int y2) {\n        int d1 = a1 * x1 + b1 * y1 + c1;\n        int d2 = a1 * x2 + b1 * y2 + c1;\n        return d1 * d2 <= 0 && d1 * d1 + d2 * d2 != 0;\n    }\n    \n    static boolean check2(int x1, int y1, int x2, int y2) {\n        int d1 = a2 * x1 + b2 * y1 + c2;\n        int d2 = a2 * x2 + b2 * y2 + c2;\n        return d1 * d2 <= 0 && d1 * d1 + d2 * d2 != 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tlong norm2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = ccw(s1, d1, d2) * ccw(s1, d1, s2);\n\t\tlong prd2 = ccw(s2, d2, s1) * crossProduct(s2, d2, s2, d1);\n\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long ccw(Point s, Point d, Point p) {\n\t\tlong cp = crossProduct(s, d, s, p);\n\t\tif (cp != 0)\n\t\t\treturn Long.compare(cp, 0);\n\t\telse {\n\t\t\tif (dotProduct(s, d, s, p) < 0)\n\t\t\t\treturn -2;\n\t\t\telse if (dotProduct(d, s, d, p) < 0)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic long dotProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.x - s2.x) + (d1.y - s1.y) * (d2.y - s2.y);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\tif (((long)cross(abx, aby, acx, acy) * cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& ((long)cross(cdx, cdy, cax, cay) * cross(cdx, cdy, cbx, cby) <= 0)) {\n\t\t\t\tif (cross(abx, aby, cdx, cdy) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif ((dot(abx, aby, acx, acy) >= 0 || dot(abx, aby, adx, ady) >= 0)\n\t\t\t\t\t\t&& (dot(-abx, -aby, -cbx, -cby) >= 0 || dot(-abx, -aby, xd - xb, yd - yb) >= 0)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif (sumofsquare(acx, acy) == 0 || sumofsquare(adx, ady) == 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) * dot(abx, aby, adx, ady) < 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) > 0 && dot(abx, aby, acx, acy) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, adx, ady) > 0 && dot(abx, aby, adx, ady) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\t\t\t\t\n\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif ((s1.x <= s2.x && s2.x <= d1.x) && (s1.x <= d2.x && d2.x <= d1.x)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t&& ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Segments/Lines - Intersection\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString line;\n\t\tString[] words;\n\n\t\tint q = sc.nextInt();\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tdouble xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n\t\t\txp0 = sc.nextDouble();\n\t\t\typ0 = sc.nextDouble();\n\t\t\txp1 = sc.nextDouble();\n\t\t\typ1 = sc.nextDouble();\n\t\t\txp2 = sc.nextDouble();\n\t\t\typ2 = sc.nextDouble();\n\t\t\txp3 = sc.nextDouble();\n\t\t\typ3 = sc.nextDouble();\n\n\t\t\tPoint p0, p1, p2, p3;\n\t\t\tp0 = new Point(xp0, yp0);\n\t\t\tp1 = new Point(xp1, yp1);\n\t\t\tp2 = new Point(xp2, yp2);\n\t\t\tp3 = new Point(xp3, yp3);\n\n\t\t\tif (Geometries.isIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t} //end main\n}\n\nclass Geometries {\n\n\tstatic double EPS = 1e-10;\n\n\t//????????????\n\tstatic boolean equals(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\t//\n\tstatic enum Order {\n\t\tCOUNTER_CLOCKWISE(1),   //???????¨???????\n\t\tCLOCKWISE(-1),          //????¨???????\n\t\tONLINE_BACK(2),         //???????????????????????´??????\n\t\tONLINE_FRONT(-2),       //????????????????????´??????\n\t\tON_SEGMENT(0);          //???????????????\n\n\t\tprivate int value;\n\n\t\tOrder(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\t//?????????\n\tstatic Order order(Point p0, Point p1, Point p2) {\n\t\tPoint v1 = p1.subtract(p0);\n\t\tPoint v2 = p2.subtract(p0);\n\t\tif (v1.outer(v2) > EPS) {return Order.COUNTER_CLOCKWISE;}\n\t\tif (v1.outer(v2) < -EPS) {return Order.CLOCKWISE;}\n\t\tif (v1.inner(v2) < -EPS) {return Order.ONLINE_BACK;}\n\t\tif (v1.norm() < v2.norm()) {return Order.ONLINE_FRONT;}\n\t\treturn Order.ON_SEGMENT;\n\t}\n\n\tstatic Order order(Segment s, Point p) {\n\t\tPoint p0 = s.p1;\n\t\tPoint p1 = s.p2;\n\t\treturn order(p0, p1, p);\n\t}\n\n\t//??´?????????\n\tstatic boolean isOrthogonal(Point a, Point b) {\n\t\treturn equals(a.inner(b), 0.0);\n\t}\n\n\tstatic boolean isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isOrthogonal(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isOrthogonal(Segment s1, Segment s2) {\n\t\treturn isOrthogonal(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isParallel(Point a, Point b) {\n\t\treturn equals(a.outer(b), 0.0);\n\t}\n\n\tstatic boolean isParallel(Point a1, Point a2, Point b1, Point b2) {\n\t\treturn isParallel(\n\t\t\t\ta1.subtract(a2),\n\t\t\t\tb1.subtract(b2)\n\t\t);\n\t}\n\n\tstatic boolean isParallel(Segment s1, Segment s2) {\n\t\treturn isParallel(\n\t\t\t\ts1.p2.subtract(s1.p1),\n\t\t\t\ts2.p2.subtract(s2.p1)\n\t\t);\n\t}\n\n\t//????????????\n\tstatic boolean isIntersect(Point a1, Point a2, Point b1, Point b2) {\n\t\tOrder o1, o2, o3, o4;\n\t\to1 = order(a1, a2, b1);\n\t\to2 = order(a1, a2, b2);\n\t\to3 = order(b1, b2, a1);\n\t\to4 = order(b1, b2, a2);\n\n\t\tif (((o1 == Order.COUNTER_CLOCKWISE && o2 == Order.CLOCKWISE)\n\t\t\t\t|| (o1 == Order.CLOCKWISE && o2 == Order.COUNTER_CLOCKWISE))\n\t\t\t\t&& ((o3 == Order.COUNTER_CLOCKWISE && o4 == Order.CLOCKWISE)\n\t\t\t\t|| (o3 == Order.CLOCKWISE && o4 == Order.COUNTER_CLOCKWISE))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isIntersect(Segment s1, Segment s2) {\n\t\tPoint a1 = s1.p1;\n\t\tPoint a2 = s1.p2;\n\t\tPoint b1 = s2.p1;\n\t\tPoint b2 = s2.p2;\n\t\treturn isIntersect(a1, a2, b1, b2);\n\t}\n}\n\nclass Point implements Comparable<Point> {\n\n\tstatic double EPS = 1e-10;\n\n\tdouble x, y;\n\n\tPoint() {\n\t\tthis(0.0, 0.0);\n\t}\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic int compareTo(Point p) {\n\t\tif (equals(p)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (x != p.x) {\n\t\t\t\treturn Double.compare(y, p.y);\n\t\t\t} else {\n\t\t\t\treturn Double.compare(x, p.x);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tPoint p = (Point) obj;\n\t\treturn x - p.x < EPS && y - p.y < EPS;\n\t}\n\n\tPoint add(Point p) {\n\t\treturn new Point(x + p.x, y + p.y);\n\t}\n\n\tPoint subtract(Point p) {\n\t\treturn new Point(x - p.x, y - p.y);\n\t}\n\n\tPoint multiply(double k) {\n\t\treturn new Point(x * k, y * k);\n\t}\n\n\tPoint devide(double k) {\n\t\treturn new Point(x / k, y / k);\n\t}\n\n\tdouble inner(Point p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\n\tdouble outer(Point p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\n\tdouble abs() {\n\t\treturn Math.sqrt(norm());\n\t}\n}\n\nclass Segment {\n\tPoint p1, p2;\n\n\tpublic Segment() {\n\t\tthis(new Point(), new Point());\n\t}\n\n\tpublic Segment(Point p1, Point p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n}\n\nclass Circle {\n\tPoint c;\n\tdouble r;\n\n\tpublic Circle() {\n\t\tthis(new Point(), 0.0);\n\t}\n\n\tpublic Circle(Point c, double r) {\n\t\tthis.c = c;\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    static final int INF = (1 << 31) - 1;             \n    static final int MAXN = 11111;     \n    static int a1, b1, c1;\n    static int a2, b2, c2;\n    \n    public static void main(String[] args) throws Exception {                \n        Scanner input = new Scanner(System.in);\n        int q = input.nextInt();\n        int x0, y0, x1, y1, x2, y2, x3, y3;\n        for (int i = 0; i < q; ++i) {\n            x0 = input.nextInt();\n            y0 = input.nextInt();\n            x1 = input.nextInt();\n            y1 = input.nextInt();\n            x2 = input.nextInt();\n            y2 = input.nextInt();\n            x3 = input.nextInt();\n            y3 = input.nextInt();            \n            a1 = y0 - y1;\n            b1 = x1 - x0;\n            c1 = - a1 * x0 - b1 * y0;\n            a2 = y2 - y3;\n            b2 = x3 - x2;\n            c2 = - a2 * x2 - b2 * y2;\n            if (check1(x2, y2, x3, y3) && check2(x0, y0, x1, y1)) System.out.println(\"1\");\n            else System.out.println(\"0\");\n            \n        }\n    }             \n    \n    static boolean check1(int x1, int y1, int x2, int y2) {\n        return (a1 * x1 + b1 * y1 + c1) * (a1 * x2 + b1 * y2 + c1) <= 0;\n    }\n    \n    static boolean check2(int x1, int y1, int x2, int y2) {\n        return (a2 * x1 + b2 * y1 + c2) * (a2 * x2 + b2 * y2 + c2) <= 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    double xp0, xp1, yp0, yp1, xp2, yp2, xp3, yp3;\n    int q;\n    int i;\n    double s1x0, s1y0, s2x0, s2y0, s3x0, s3y0, s10, s20;\n    double s1x1, s1y1, s2x1, s2y1, s3x1, s3y1, s11, s21;\n\n    q = sc.nextInt();\n    for(i = 0;i < q;i++){\n      xp0 = sc.nextDouble();\n      yp0 = sc.nextDouble();\n      xp1 = sc.nextDouble();\n      yp1 = sc.nextDouble();\n      xp2 = sc.nextDouble();\n      yp2 = sc.nextDouble();\n      xp3 = sc.nextDouble();\n      yp3 = sc.nextDouble();\n\n      s1x0 = xp1 - xp0;\n      s1y0 = yp1 - yp0;\n      s2x0 = xp2 - xp0;\n      s2y0 = yp2 - yp0;\n      s3x0 = xp3 - xp0;\n      s3y0 = yp3 - yp0;\n\n      s10 = s1x0 * s2y0 - s1y0 * s2x0;\n      s20 = s1x0 * s3y0 - s1y0 * s3x0;\n\n      s1x1 = xp3 - xp2;\n      s1y1 = yp3 - yp2;\n      s2x1 = xp0 - xp2;\n      s2y1 = yp0 - yp2;\n      s3x1 = xp1 - xp2;\n      s3y1 = yp1 - yp2;\n\n      s11 = s1x1 * s2y1 - s1y1 * s2x1;\n      s21 = s1x1 * s3y1 - s1y1 * s3x1;\n\n      if(s10 * s20 > 0 || s11 * s21 > 0){\n        System.out.println(\"0\");  //no\n      }else if(s10 == 0 && s20 == 0 &&\n               (s1x0 * s2x0 < 0 || s1y0 * s2y0 < 0) &&\n               (s1x0 * s3x0 < 0 || s1y0 * s3y0 < 0)\n              ){\n        System.out.println(\"0\");  //no\n      }else if(s20 == 0 && s21 == 0 &&\n               (s1x1 * s2x1 < 0 || s1y1 * s2y1 < 0) &&\n               (s1x1 * s3x1 < 0 || s1y1 * s3y1 < 0)\n              ){\n        System.out.println(\"0\");  //no\n      }else{\n        System.out.println(\"1\");  //yes\n      }\n    }\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    double xp0, xp1, yp0, yp1, xp2, yp2, xp3, yp3;\n    int q;\n    int i;\n    double s1x0, s1y0, s2x0, s2y0, s3x0, s3y0, s10, s20;\n    double s1x1, s1y1, s2x1, s2y1, s3x1, s3y1, s11, s21;\n\n    q = sc.nextInt();\n    for(i = 0;i < q;i++){\n      xp0 = sc.nextDouble();\n      yp0 = sc.nextDouble();\n      xp1 = sc.nextDouble();\n      yp1 = sc.nextDouble();\n      xp2 = sc.nextDouble();\n      yp2 = sc.nextDouble();\n      xp3 = sc.nextDouble();\n      yp3 = sc.nextDouble();\n\n      s1x0 = xp1 - xp0;\n      s1y0 = yp1 - yp0;\n      s2x0 = xp2 - xp0;\n      s2y0 = yp2 - yp0;\n      s3x0 = xp3 - xp0;\n      s3y0 = yp3 - yp0;\n\n      s10 = s1x0 * s2y0 - s1y0 * s2x0;\n      s20 = s1x0 * s3y0 - s1y0 * s3x0;\n\n      s1x1 = xp3 - xp2;\n      s1y1 = yp3 - yp2;\n      s2x1 = xp0 - xp2;\n      s2y1 = yp0 - yp2;\n      s3x1 = xp1 - xp2;\n      s3y1 = yp1 - yp2;\n\n      s11 = s1x1 * s2y1 - s1y1 * s2x1;\n      s21 = s1x1 * s3y1 - s1y1 * s3x1;\n\n      if(s10 * s20 > 0 || s11 * s21 > 0){\n        System.out.println(\"0\");  //no\n      }else if((s1x0 * s2x0 < 0 || s1y0 * s2y0 < 0) &&\n               (s1x0 * s3x0 < 0 || s1y0 * s3y0 < 0)\n              ){\n        System.out.println(\"0\");  //no\n      }else if((s1x1 * s2x1 < 0 || s1y1 * s2y1 < 0) &&\n               (s1x1 * s3x1 < 0 || s1y1 * s3y1 < 0)\n              ){\n        System.out.println(\"0\");  //no\n      }else{\n        System.out.println(\"1\");  //yes\n      }\n    }\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\nclass Geometries {\n    static double EPS = 1e-9;\n    \n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        boolean b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        boolean b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos3 = ccw(s2, s1.p2);\n        if ( (pos1.id * pos2.id) <= 0 && (pos3.id * pos4.id) <= 0 ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        boolean b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        boolean b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\n\t\t\tPoint2D[] points = new Point2D[4];\n\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tint x = Integer.parseInt(tmpArray[j*2]);\n\t\t\t\tint y = Integer.parseInt(tmpArray[j*2 + 1]);\n\n\t\t\t\tpoints[j] = new Point2D.Double(x, y);\n\t\t\t}\n\n\t\t\tLine2D[] lines = new Line2D[2];\n\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\tlines[j] = new Line2D.Double(points[j*2], points[j*2 + 1]);\n\t\t\t}\n\n\t\t\tif(lines[0].intersectsLine(lines[1])){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n       \tPrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n        int q = sc.nextInt();\n        \n        for(int i=0;i<q;i++){\n        \tPoint p0 = new Point(sc.nextDouble(),sc.nextDouble());\n        \tPoint p1 = new Point(sc.nextDouble(),sc.nextDouble());\n        \tPoint p2 = new Point(sc.nextDouble(),sc.nextDouble());\n        \tPoint p3 = new Point(sc.nextDouble(),sc.nextDouble());\n        \tLineSegment ls1 = new LineSegment(p0,p1);\n        \tLineSegment ls2 = new LineSegment(p2,p3);\n        \tif(ls1.isIntersect(ls2)){\n        \t\tout.println(1);\n        \t}\n        \telse{\n        \t\tout.println(0);\n        \t}\n        }\n        \n        out.flush();\n    }\n\n    \n}\n\nclass Point implements Comparable<Point>{\n\tdouble x,y;\n\tstatic final double eps = 0.00000001;\n\t\n\tpublic Point(double a, double b){\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t}\n\t\n\t//距離の2乗\n\tpublic double d2(Point b){\n\t\treturn (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y);\n\t}\n\t\n\t//通常のユークリッド距離\n\tpublic double dist(Point b){\n\t\treturn Math.sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y));\n\t}\n\t\n\t//p1へのベクトルからみてp2へのベクトルが反時計回りなら1、時計回りなら2\n\t//↑が同一直線状にあるとき、→p2が→p1と反対側なら3、→p2が→p1の延長線上なら4、→p2が→p1上にあれば5を返す\n\tint direction(Point p1, Point p2){\n\t\t\n\t\tif(p2.x == x && p2.y == y){\n\t\t\treturn 5;\n\t\t}\n\t\t\n\t\t//外積の第三成分 = |→p1||→p2|sinθ\n\t\tdouble det = (p1.x -x)*(p2.y-y) - (p2.x -x)*(p1.y - y);\n\t\t\n\t\tif(det>eps){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(det<-eps){\n\t\t\treturn 2;\n\t\t}\n\t\telse{\t//同一直線状\n\t\t\tif((p1.x-x >0 == p2.x-x <0) && p1.x-x != 0){\t//反対側\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\telse if((p1.y-y >0 == p2.y-y <0) && p1.y-y != 0){\t//反対側\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble d10 = d2(p1);\t//p1とp0の距離^2\n\t\t\t\tdouble d20 = d2(p2);\t//p2とp0の距離^2\n\t\t\t\tif(d10 < d20){\t//p2のほうが遠い\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(x);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(y);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPoint other = (Point) obj;\n\t\tif (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Point o){\n\t\tif(x!=o.x){\n\t\t\treturn Double.compare(x,o.x);\n\t\t}\n\t\treturn Double.compare(y, o.y);\n\t}\n\t\t\n}\n\nclass Line {\n\tdouble a;\n\tdouble b;\n\tdouble c;\n\tstatic final double eps = 0.00000001;\n\t\n\t//2点p,qを通る直線\n\tpublic Line(Point p, Point q){\n\t\tif(p.y == q.y){\n\t\t\tthis.a = 0;\n\t\t\tthis.b = 1;\n\t\t\tthis.c = -(p.y);\n\t\t}\n\t\telse if(p.x == q.x){\n\t\t\tthis.a = 1;\n\t\t\tthis.b = 0;\n\t\t\tthis.c = -(p.x);\n\t\t}\n\t\telse{\n\t\t\tthis.a = p.y - q.y;\n\t\t\tthis.b = q.x - p.x;\n\t\t\tthis.c = - a*p.x - b*p.y;\n\t\t}\n\t}\n\tpublic Line(LineSegment ls){\n\t\tPoint p = ls.p1;\n\t\tPoint q = ls.p2;\n\t\tif(p.y == q.y){\n\t\t\tthis.a = 0;\n\t\t\tthis.b = 1;\n\t\t\tthis.c = -(p.y);\n\t\t}\n\t\telse if(p.x == q.x){\n\t\t\tthis.a = 1;\n\t\t\tthis.b = 0;\n\t\t\tthis.c = -(p.x);\n\t\t}\n\t\telse{\n\t\t\tthis.a = p.y - q.y;\n\t\t\tthis.b = q.x - p.x;\n\t\t\tthis.c = - a*p.x - b*p.y;\n\t\t}\n\t}\n\t\n\t//ax+by+c=0\n\tpublic Line(double a, double b, double c){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n\t//y=ax+c\n\tpublic Line(double a, double c){\n\t\tthis.a = a;\n\t\tthis.b = -1;\n\t\tthis.c = c;\n\t}\n\t\n\t//点pからの垂線の足\n\tpublic Point projection(Point p){\n\t\t//-bx+ay+d=0がこの直線と垂直でpを通る直線とし、dを求める\n\t\tdouble d = b*p.x - a*p.y;\n\t\treturn crossPoint(new Line(-b,a,d));\n\t}\n\t\n\t//点pと線対称な点\n\tpublic Point reflection(Point p){\n\t\tPoint proj = projection(p);\n\t\tdouble x = proj.x + (proj.x - p.x);\n\t\tdouble y = proj.y + (proj.y - p.y);\n\t\treturn new Point(x,y);\n\t}\n\t\n\t//直線lとの交点\n\tpublic Point crossPoint(Line l){\n\t\tif(a==0){ //b=1前提\n\t\t\tdouble x = (l.b*c - l.c)/l.a;\n\t\t\treturn new Point(x,-c);\n\t\t}\n\t\tif(l.a==0){ //l.b=1前提\n\t\t\tdouble x = (b*l.c - c)/a;\n\t\t\treturn new Point(x, -l.c);\n\t\t}\n\t\t\n\t\t//xの係数をlと等しくする\n\t\t//気持ちは double A = l.a;\n\t\tdouble mlt = l.a/a;\n\t\tdouble B = b * mlt;\n\t\tdouble C = c * mlt;\n\t\tdouble y = (l.c-C)/(B-l.b);\n\t\tdouble x = (-b*y-c)/a;\n\t\treturn new Point(x,y);\n\t}\n\t\n\t//直線lと同一かどうか\n\tpublic boolean isSame(Line l){\n\t\tif(a == 0){\n\t\t\tif(l.a != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(Math.abs(c - l.c)<eps){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(b == 0){\n\t\t\tif(l.b != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(Math.abs(c - l.c)<eps){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(Math.abs(a*l.b - b*l.a)<eps && Math.abs(b*l.c - c*l.b)<eps){\t//a1:b1:c1 = a2:b2:c2\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//直線lと平行かどうか\n\tboolean isParallel(Line l){\n\t\tif(Math.abs(a*l.b - l.a*b) < eps){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//直線lと垂直かどうか\n\tboolean isOrthogonal(Line l){\n\t\tif(Math.abs(a*l.a + b*l.b) < eps){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\n\tpublic void print(){\n\t\tSystem.out.println(a + \"x + \" + b + \"y + \" + c + \"= 0\" );\n\t}\n\t\n\tpublic void display(){\n\t\tSystem.out.println(a + \"x + \" + b + \"y + \" + c + \" = 0\");\n\t}\n\t\n}\n\nclass LineSegment {\n\tPoint p1;\n\tPoint p2;\n\tstatic final double eps = 0.00000001;\n\t\n\tpublic LineSegment(Point p1, Point p2){\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\t\n\tboolean isIntersect(LineSegment ls){\n\t\tLine a = new Line(this);\n\t\tLine b = new Line(ls);\n\t\t\n\t\tif(a.isSame(b)){\t//重なる\n\t\t\tif(p1.x == p2.x){\t//x軸に垂直\n\t\t\t\tdouble big = Math.max(p1.y, p2.y);\n\t\t\t\tdouble small = Math.min(p1.y, p2.y);\n\t\t\t\tdouble lbig = Math.max(ls.p1.y, ls.p2.y);\n\t\t\t\tdouble lsmall = Math.min(ls.p1.y, ls.p2.y);\n\t\t\t\t\n\t\t\t\tif(lsmall <= big && small <= lbig){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble big = Math.max(p1.x, p2.x);\n\t\t\t\tdouble small = Math.min(p1.x, p2.x);\n\t\t\t\tdouble lbig = Math.max(ls.p1.x, ls.p2.x);\n\t\t\t\tdouble lsmall = Math.min(ls.p1.x, ls.p2.x);\n\t\t\t\t\n\t\t\t\tif(lsmall <= big && small <= lbig){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(a.isParallel(b)){\t//平行\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\tPoint cross = a.crossPoint(b);\n\n\t\t\tif(isOn(cross) && ls.isOn(cross)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//pが線分上にあるか\n\tboolean isOn(Point p){\n\t\tif(p1.x == p2.x){\t//x軸に垂直\n\t\t\tdouble big = Math.max(p1.y, p2.y);\n\t\t\tdouble small = Math.min(p1.y, p2.y);\n\t\t\t\n\t\t\tif(small <= p.y && p.y <= big){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdouble big = Math.max(p1.x, p2.x);\n\t\t\tdouble small = Math.min(p1.x, p2.x);\n\t\t\t\n\t\t\tif(small <= p.x && p.x <= big){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic int[][] nextintMatrix(int h, int w){\n\t\tint[][] mat = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tmat[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(x2, x3) < x0 && x0 < Math.max(x2, x3) && Math.min(y0, y1) < y && y < Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(x0, x1) < x2 && x2 < Math.max(x0, x1) && Math.min(y2, y3) < y && y < Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) < x && x < Math.max(x0, x1) && Math.min(x2, x3) < x && x < Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static double innerProduct()\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos3 = ccw(s2, s1.p2);\n        return pos1.id * pos2.id <= 0 && pos3.id * pos4.id <= 0\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??´???AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0\n\t\t\t *     ABxAC*ABxAD<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tif (xab != 0 || yab != 0) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\treturn (long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0;\n\t\t\t} else {\n\t\t\t\tint xcd = xd - xc;\n\t\t\t\tint ycd = yd - yc;\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??????AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0 && |CD|==0\n\t\t\t *     CAxCB==0 && CA.CB<0\n\t\t\t * |AB|!=0 && |CD|!=0\n\t\t\t *     ABxCD==0\n\t\t\t *         ACxAD==0 && (AB.AC>=0 || AB.AD>=0) && (BA.BC>=0 || BA.BD>=0)\n\t\t\t *     ABxCD!=0\n\t\t\t *         ABxAC*ABxAD<=0 && CDxCA*CDxCB<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tint xcd = xd - xc;\n\t\t\tint ycd = yd - yc;\n\t\t\tif ((xab != 0 || yab != 0) && (xcd != 0 || ycd != 0)) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\tif (cross(xab, yab, xcd, ycd) != 0) {\n\t\t\t\t\tint xca = -xac;\n\t\t\t\t\tint yca = -yac;\n\t\t\t\t\tint xcb = xb - xc;\n\t\t\t\t\tint ycb = yb - yc;\n\t\t\t\t\treturn ((long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0)\n\t\t\t\t\t\t\t&& ((long)cross(xcd, ycd, xca, yca) * cross(xcd, ycd, xcb, ycb) <= 0);\n\t\t\t\t} else {\n\t\t\t\t\tint xba = -xab;\n\t\t\t\t\tint yba = -yab;\n\t\t\t\t\tint xbc = xc - xb;\n\t\t\t\t\tint ybc = yc - yb;\n\t\t\t\t\tint xbd = xd - xb;\n\t\t\t\t\tint ybd = yd - yb;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0\n\t\t\t\t\t\t\t&& (dot(xab, yab, xac, yac) >= 0 || dot(xab, yab, xad, yad) >= 0)\n\t\t\t\t\t\t\t&& (dot(xba, yba, xbc, ybc) >= 0 || dot(xba, yba, xbd, ybd) >= 0);\n\t\t\t\t}\n\t\t\t} else if (xab != 0 || yab != 0) {\n\t\t\t\tint xca = xc - xa;\n\t\t\t\tint yca = yc - ya;\n\t\t\t\tint xcb = xb - xc;\n\t\t\t\tint ycb = yb - yc;\n\t\t\t\treturn cross(xca, yca, xcb, ycb) == 0 && dot(xca, yca, xcb, ycb) < 0;\n\t\t\t} else {\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextDouble();\n\t\t\ty0 = sc.nextDouble();\n\t\t\tx1 = sc.nextDouble();\n\t\t\ty1 = sc.nextDouble();\n\t\t\tx2 = sc.nextDouble();\n\t\t\ty2 = sc.nextDouble();\n\t\t\tx3 = sc.nextDouble();\n\t\t\ty3 = sc.nextDouble();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) < 0)\n\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) < 0));\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic Point[][] seg;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tPoint s1 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint d1 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint s2 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint d2 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif (linesIntersect(s1, d1, s2, d2)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// seg = new Point[n][2];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// Point p1 = new Point(x1[i], y1[i]);\n\t\t// Point p2 = new Point(x2[i], y2[i]);\n\t\t// ps.add(p1);\n\t\t// ps.add(p2);\n\t\t// seg[i] = new Point[] { p1, p2 };\n\t\t// }\n\t\t// sx = sc.nextDouble();\n\t\t// sy = sc.nextDouble();\n\t\t// gx = sc.nextDouble();\n\t\t// gy = sc.nextDouble();\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t//\n\t\t// }\n\t}\n\n\tstatic int gen = 0;\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x1, double y1) {\n\t\t\tthis.x = x1;\n\t\t\tthis.y = y1;\n\t\t\tid = gen++;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = ccw(s1, d1, d2) * ccw(s1, d1, s2);\n\t\tlong prd2 = ccw(s2, d2, s1) * ccw(s2, d2, d1);\n\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long ccw(Point s, Point d, Point p) {\n\t\tdouble cp = crossProduct(s, d, s, p);\n\t\tif (cp != 0)\n\t\t\treturn Double.compare(cp, 0);\n\t\telse {\n\t\t\tif (dotProduct(s, d, s, p) < 0)\n\t\t\t\treturn -2;\n\t\t\telse if (dotProduct(d, s, d, p) < 0)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic double dotProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.x - s2.x) + (d1.y - s1.y) * (d2.y - s2.y);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n//import java.io.*;\nimport java.util.stream.IntStream;\n\npublic class Main{\n    static int sum=0;\n    public static void main (String args[]){\n        //初期処理\n        Scanner sc=new Scanner(System.in);\n        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // try{\n            // int n = Integer.parseInt(br.readLine());\n        int n = sc.nextInt();\n        for(int i=0; i<n; i++){\n            Vector p0 = new Vector(sc.nextInt(), sc.nextInt());\n            Vector p1 = new Vector(sc.nextInt(), sc.nextInt());\n            Vector p2 = new Vector(sc.nextInt(), sc.nextInt());\n            Vector p3 = new Vector(sc.nextInt(), sc.nextInt());\n\n            if(Vector.intersect(p0, p1, p2, p3)){\n                System.out.println(1);\n            }else{\n                System.out.println(0);\n            }\n        }\n\n    }\n}\n\nclass Vector{\n    public static final double EPS = 1e-10;\n    public static final int COUNTER_CLOCKWISE=1;\n    public static final int CLOCKWISE=-1;\n    public static final int ONLINE_BACK=2;\n    public static final int ONLINE_FRONT=-2;\n    public static final int ON_SEGMENT=0;\n\n    public double x,y;\n\n    public Vector(){}\n    public Vector(double x, double y){this.x=x;this.y=y;}\n\n    public Vector plus(Vector p){return new Vector(this.x+p.x, this.y+p.y);}\n    public Vector minus(Vector p){return new Vector(this.x-p.x, this.y-p.y);}\n    public Vector multiple(double a){return new Vector(this.x*a, this.y*a);}\n    public Vector divide(double a){return new Vector(this.x/a, this.y/a);}\n\n    public double abs(){return Math.sqrt(this.norm());}\n    public double norm(){return x*x+y*y;}\n\n    \n    public static double dot(Vector a, Vector b){\n        return a.x*b.x+a.y*b.y;\n    }\n\n    public static double cross(Vector a, Vector b){\n        return a.x*b.y-a.y*b.x;\n    }\n\n    //point.projectで垂線の足の座標\n    public Vector project(Vector seg1, Vector seg2){\n        Vector seg = seg2.minus(seg1);\n        Vector relPoint = this.minus(seg1);\n        double t = dot(seg, relPoint)/seg.norm();\n        return seg1.plus(seg.multiple(t));\n    }\n    \n    //point.reflectionで対称点\n    public Vector reflection(Vector seg1, Vector seg2){\n        Vector projected = this.project(seg1, seg2);\n        Vector ashi = projected.minus(this);\n        return this.plus(ashi.multiple(2));\n    }\n\n    //p0が始点\n    public static int ccw(Vector p0, Vector p1, Vector p2){\n        Vector s1 = p1.minus(p0);\n        Vector s2 = p2.minus(p0);\n\n        double cross = Vector.cross(s1, s2);\n        double dot = Vector.dot(s1, s2);\n\n        if(cross>0){return COUNTER_CLOCKWISE;}\n        if(cross<0){return CLOCKWISE;}\n        if(dot<0){return ONLINE_BACK;}\n        if(s1.abs()<s2.abs()){return ONLINE_FRONT;}\n        return ON_SEGMENT;\n    }\n\n    public static Boolean intersect(Vector p0, Vector p1, Vector p2, Vector p3){\n        if(ccw(p0, p1, p2)*ccw(p0, p1, p3)<=0 && ccw(p2, p3, p0)*ccw(p2, p3, p1)<=0){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n\n        public Segment() {\n            this(new Point(), new Point());\n        }\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static bool cross(Segment s1, Segment s2) {\n        bool b1 = (exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2) < EPS \n        bool b2 = (exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2) < EPS \n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos3 = ccw(s2, s1.p2);\n        return pos1.id * pos2.id <= 0 && pos3.id * pos4.id <= 0;\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\tif ((cross(abx, aby, acx, acy) * cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& (cross(cdx, cdy, cax, cay) * cross(cdx, cdy, cbx, cby) <= 0)) {\n\t\t\t\tif (cross(abx, aby, cdx, cdy) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) > 0 && dot(abx, aby, acx, acy) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, adx, ady) > 0 && dot(abx, aby, adx, ady) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (sumofsquare(acx, acy) == 0 || sumofsquare(adx, ady) == 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint q;\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tboolean flag;\n\t\t\n\t\tq = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tflag = false;\n\t\t\t\n\t\t\tx0 = scan.nextDouble();\n\t\t\ty0 = scan.nextDouble();\n\t\t\tx1 = scan.nextDouble();\n\t\t\ty1 = scan.nextDouble();\n\t\t\tx2 = scan.nextDouble();\n\t\t\ty2 = scan.nextDouble();\n\t\t\tx3 = scan.nextDouble();\n\t\t\ty3 = scan.nextDouble();\n\t\t\t\n\t\t\tif( ((y0 - y1) * (x2 - x0) - (x0 - x1) * (y2 - y0)) * \n\t\t\t\t((y0 - y1) * (x3 - x0) - (x0 - x1) * (y3 - y0)) == 0\n\t\t\t\t&&\n\t\t\t\t((y2 - y3) * (x0 - x2) - (x2 - x3) * (y0 - y2)) *\n\t\t\t\t((y2 - y3) * (x1 - x2) - (x2 - x3) * (y1 - y2)) == 0) {\n\t\t\t\t\n\t\t\t\tif(x0 > x1) {\n\t\t\t\t\tdouble tmp = x0;\n\t\t\t\t\tx0 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t\tif(y0 > y1) {\n\t\t\t\t\tdouble tmp = y0;\n\t\t\t\t\ty0 = x1;\n\t\t\t\t\ty1 = tmp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif((x0 > x2 && x0 > x3) || (x1 < x2 && x1 < x3)) {\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t\n\t\t\t\t} else if((y0 > y2 && y0 > y3) || (y1 < y2 && y1 < y3)) {\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t} else if( ((y0 - y1) * (x2 - x0) - (x0 - x1) * (y2 - y0)) * \n\t\t\t\t((y0 - y1) * (x3 - x0) - (x0 - x1) * (y3 - y0)) <= 0\n\t\t\t\t&&\n\t\t\t\t((y2 - y3) * (x0 - x2) - (x2 - x3) * (y0 - y2)) *\n\t\t\t\t((y2 - y3) * (x1 - x2) - (x2 - x3) * (y1 - y2)) <= 0) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tscan.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1 && x2 == x3) {\n\t\t\t\tif((Math.min(y0, y1) <= y2 && y2 <= Math.max(y0, y1)) || (Math.min(y0, y1) <= y3 && y3 <= Math.max(y0, y1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(y0 == y1 && y2 == y3) {\n\t\t\t\tif((Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1)) || (Math.min(x0, x1) <= x3 && x3 <= Math.max(x0, x1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(x2, x3) <= x0 && x0 <= Math.max(x2, x3) && Math.min(y0, y1) <= y && y <= Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1) && Math.min(y2, y3) <= y && y <= Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) <= x && x <= Math.max(x0, x1) && Math.min(x2, x3) <= x && x <= Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\tif ((cross(abx, aby, acx, acy) * cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& (cross(cdx, cdy, cax, cay) * cross(cdx, cdy, cbx, cby) <= 0)) {\n\t\t\t\tif (cross(abx, aby, cdx, cdy) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (sumofsquare(acx, acy) == 0 || sumofsquare(adx, ady) == 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) * dot(abx, aby, adx, ady) < 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) > 0 && dot(abx, aby, acx, acy) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, adx, ady) > 0 && dot(abx, aby, adx, ady) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\tif ((cross(abx, aby, acx, acy) * cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& (cross(cdx, cdy, cax, cay) * cross(cdx, cdy, cbx, cby) <= 0)) {\n\t\t\t\tif (cross(abx, aby, cdx, cdy) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, acx, acy) > 0 && dot(abx, aby, acx, acy) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (dot(abx, aby, adx, ady) > 0 && dot(abx, aby, adx, ady) <= sumofsquare(abx, aby)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tGeometry geom = new Geometry();\n\n\t\tint q = scan.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint x0 = scan.nextInt();\n\t\t\tint y0 = scan.nextInt();\n\t\t\tint x1 = scan.nextInt();\n\t\t\tint y1 = scan.nextInt();\n\t\t\tint x2 = scan.nextInt();\n\t\t\tint y2 = scan.nextInt();\n\t\t\tint x3 = scan.nextInt();\n\t\t\tint y3 = scan.nextInt();\n\t\t\tgeom.setBaseLine(new Point(x1 - x0, y1 - y0));\n\t\t\tPoint s1 = geom.rotateBaseX(new Point(x1 - x0, y1 - y0), true);\n\t\t\tPoint p2 = geom.rotateBaseX(new Point(x2 - x0, y2 - y0), true);\n\t\t\tPoint p3 = geom.rotateBaseX(new Point(x3 - x0, y3 - y0), true);\n\t\t\tif (p2.y == p3.y)\n\t\t\t\tif (p2.y == 0)\n\t\t\t\t\tif (Math.min(p2.x, p3.x) <= Math.max(0, s1.x) && Math.max(p2.x, p3.x) >= Math.min(0, s1.x))\n\t\t\t\t\t\tpwriter.println(\"1\");\n\t\t\t\t\telse\n\t\t\t\t\t\tpwriter.println(\"0\");\n\t\t\t\telse\n\t\t\t\t\tpwriter.println(\"0\");\n\t\t\telse {\n\t\t\t\tPoint s2 = geom.crossX(p2, p3);\n\t\t\t\tif (s2.x <= Math.max(0, s1.x) && s2.x >= Math.min(0, s1.x))\n\t\t\t\t\tpwriter.println(\"1\");\n\t\t\t\telse\n\t\t\t\t\tpwriter.println(\"0\");\n\t\t\t}\n\t\t}\n\t\tpwriter.flush();\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Point {\n\tpublic double x, y;\n\n\tpublic Point(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n}\n\nclass Geometry {\n\tdouble sin, cos;\n\n\tpublic void setBaseLine(Point v) {\n\t\tdouble t2 = v.x * v.x + v.y * v.y;\n\t\tsin = v.y / Math.sqrt(t2);\n\t\tcos = v.x / Math.sqrt(t2);\n\t}\n\n\tpublic Point crossX(Point p0, Point p1) {\n\t\tif (p0.y == p1.y)\n\t\t\treturn null;\n\t\t// y=(y1-y0)/(x1-x0)*(x-x0)+y0 : y=0\n\t\t// (y1-y0)*(x-x0)=-y0*(x1-x0)\n\t\t// x=x0-y0*(x1-x0)/(y1-y0)\n\t\t// x=(x0y1-x1y0)/(y1-y0)\n\t\treturn new Point(round((p0.x * p1.y - p1.x * p0.y) / (p1.y - p0.y)), 0);\n\t}\n\n\tpublic boolean isSameLine(Point p0, Point p1, Point p2) {\n\t\tif ((p1.x - p0.x) * (p2.y - p0.y) == (p2.x - p0.x) * (p1.y - p0.y))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic Point rotateBaseX(Point p, boolean direction) {\n\t\tif (direction)\n\t\t\treturn new Point(round(p.x * cos + p.y * sin), round(-p.x * sin + p.y * cos));\n\t\telse\n\t\t\treturn new Point(round(p.x * cos - p.y * sin), round(p.x * sin + p.y * cos));\n\t}\n\n\tprivate double round(double d) {\n\t\treturn (double) Math.round(d * 1000000000) / 1000000000;\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n\n        public Segment() {\n            this(new Point(), new Point());\n        }\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n\n        public Segment() {\n            this(new Point(), new Point());\n        }\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static bool cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos3 = ccw(s2, s1.p2);\n        return ( (pos1.id * pos2.id) <= 0 && (pos3.id * pos4.id) <= 0 );\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1 && x2 == x3) {\n\t\t\t\tif((Math.min(y0, y1) <= y2 && y2 <= Math.max(y0, y1)) || (Math.min(y0, y1) <= y3 && y3 <= Math.max(y0, y1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(y0 == y1 && y2 == y3 || Math.abs(a2 - a1) < ALLOWABLE_ERROR) {\n\t\t\t\tif((Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1)) || (Math.min(x0, x1) <= x3 && x3 <= Math.max(x0, x1))){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(x2, x3) <= x0 && x0 <= Math.max(x2, x3) && Math.min(y0, y1) <= y && y <= Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(x0, x1) <= x2 && x2 <= Math.max(x0, x1) && Math.min(y2, y3) <= y && y <= Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) <= x && x <= Math.max(x0, x1) && Math.min(x2, x3) <= x && x <= Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException, NumberFormatException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int n = Integer.parseInt(br.readLine());\n        \n        for(int i = 0; i < n; i++) {\n            String[] tmpArray = br.readLine().split(\" \");\n            \n            Point2D[] points = new Point2D[4];\n            \n            for(int j = 0; j < 4; j++) {\n                int x = Integer.parseInt(tmpArray[j * 2]);\n                int y = Integer.parseInt(tmpArray[j * 2 + 1]);\n                \n                points[j] = new Point2D.Double(x, y);\n            }\n            \n            Line2D[] lines = new Line2D[2];\n            for(int j = 0; j < 2; j++) {\n                lines[j] = new Line2D.Double(points[j * 2], points[j * 2 + 1]);\n            }\n            \n            if(lines[0].intersectsLine(lines[1])) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextDouble();\n\t\t\ty0 = sc.nextDouble();\n\t\t\tx1 = sc.nextDouble();\n\t\t\ty1 = sc.nextDouble();\n\t\t\tx2 = sc.nextDouble();\n\t\t\ty2 = sc.nextDouble();\n\t\t\tx3 = sc.nextDouble();\n\t\t\ty3 = sc.nextDouble();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) <= 0)\n\t\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) <= 0));\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        boolean b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        boolean b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        boolean b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1.subtract(s1.p1)) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2.subtract(s1.p1))  < EPS ;\n        boolean b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1.subtract(s2.p1)) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2subtract(s2.p1))  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextDouble();\n\t\t\ty0 = sc.nextDouble();\n\t\t\tx1 = sc.nextDouble();\n\t\t\ty1 = sc.nextDouble();\n\t\t\tx2 = sc.nextDouble();\n\t\t\ty2 = sc.nextDouble();\n\t\t\tx3 = sc.nextDouble();\n\t\t\ty3 = sc.nextDouble();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t// ArrayList<Point> ps = new ArrayList<>();\n\t\t// n = sc.nextInt();\n\t\t// x1 = new double[n];\n\t\t// y1 = new double[n];\n\t\t// x2 = new double[n];\n\t\t// y2 = new double[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// x1[i] = sc.nextDouble();\n\t\t// y1[i] = sc.nextDouble();\n\t\t// x2[i] = sc.nextDouble();\n\t\t// y2[i] = sc.nextDouble();\n\t\t// ps.add(new Point(x1[i], y1[i]));\n\t\t// ps.add(new Point(x2[i], y2[i]));\n\t\t// }\n\t\t//\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// for (int j = i + 1; j < n; ++j) {\n\t\t//\n\t\t// }\n\t\t// }\n\n\t}\n\n\tstatic class Point {\n\t\tdouble x, y;\n\t\tint id;\n\n\t\tpublic Point(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn ((crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2)) < 0)\n\t\t\t\t&& ((crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1) < 0));\n\t}\n\n\tstatic double crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Geometries {\n    static double EPS = 1e-9;\n    class Point implements Comparable<Point> {\n        double x;\n        double y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Point o) {\n            if (Math.abs(x - o.x) > EPS)\n                return (int) Math.signum(x - o.x);\n            else\n                return (int) Math.signum(y - o.y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n     \n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n     \n        Point multiply(double k) {\n            return new Point(x * k, y * k);\n        }\n     \n        Point devide(double k) {\n            return new Point(x / k, y / k);\n        }\n    }\n\n    class Segment {\n        Point p1;\n        Point p2;\n     \n        public Segment(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    static double exteriorProduct(Point p1, Point p2) {\n        return p1.x * p2.y - p1.y * p2.x;\n    }\n\n    static boolean cross(Segment s1, Segment s2) {\n        bool b1 = exteriorProduct(s1.p2.subtract(s1.p1), s2.p1) * exteriorProduct(s1.p2.subtract(s1.p1), s2.p2)  < EPS ;\n        bool b2 = exteriorProduct(s2.p2.subtract(s2.p1), s1.p1) * exteriorProduct(s2.p2.subtract(s2.p1), s1.p2)  < EPS ;\n        return b1 && b2;\n    }\n}\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.cross(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic int n;\n\tstatic double[] x1, y1, x2, y2;\n\tstatic double sx, sy, gx, gy;\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tlong x0, y0, x1, y1, x2, y2, x3, y3;\n\t\t\tx0 = sc.nextLong();\n\t\t\ty0 = sc.nextLong();\n\t\t\tx1 = sc.nextLong();\n\t\t\ty1 = sc.nextLong();\n\t\t\tx2 = sc.nextLong();\n\t\t\ty2 = sc.nextLong();\n\t\t\tx3 = sc.nextLong();\n\t\t\ty3 = sc.nextLong();\n\t\t\tPoint p0 = new Point(x0, y0);\n\t\t\tPoint p1 = new Point(x1, y1);\n\t\t\tPoint p2 = new Point(x2, y2);\n\t\t\tPoint p3 = new Point(x3, y3);\n\t\t\tif (linesIntersect(p0, p1, p2, p3)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tlong x, y;\n\t\tint id;\n\n\t\tpublic Point(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {\n\t\tlong prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);\n\t\tlong prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);\n\t\tif (prd1 == 0 && prd2 == 0) {\n\t\t\tif (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)\n\t\t\t\t\t|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)\n\t\t\t\t\t|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t} else\n\t\t\treturn prd1 <= 0 && prd2 <= 0;\n\t}\n\n\tstatic long crossProduct(Point s1, Point d1, Point s2, Point d2) {\n\t\treturn (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//CGL_2_B\npublic class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    double xp0, xp1, yp0, yp1, xp2, yp2, xp3, yp3;\n    int q;\n    int i;\n    double s1x0, s1y0, s2x0, s2y0, s3x0, s3y0, s10, s20;\n    double s1x1, s1y1, s2x1, s2y1, s3x1, s3y1, s11, s21;\n\n    q = sc.nextInt();\n    for(i = 0;i < q;i++){\n      xp0 = sc.nextDouble();\n      yp0 = sc.nextDouble();\n      xp1 = sc.nextDouble();\n      yp1 = sc.nextDouble();\n      xp2 = sc.nextDouble();\n      yp2 = sc.nextDouble();\n      xp3 = sc.nextDouble();\n      yp3 = sc.nextDouble();\n\n      s1x0 = xp1 - xp0;\n      s1y0 = yp1 - yp0;\n      s2x0 = xp2 - xp0;\n      s2y0 = yp2 - yp0;\n      s3x0 = xp3 - xp0;\n      s3y0 = yp3 - yp0;\n\n      s10 = s1x0 * s2y0 - s1y0 * s2x0;\n      s20 = s1x0 * s3y0 - s1y0 * s3x0;\n\n      s1x1 = xp3 - xp2;\n      s1y1 = yp3 - yp2;\n      s2x1 = xp0 - xp2;\n      s2y1 = yp0 - yp2;\n      s3x1 = xp1 - xp2;\n      s3y1 = yp1 - yp2;\n\n      s11 = s1x1 * s2y1 - s1y1 * s2x1;\n      s21 = s1x1 * s3y1 - s1y1 * s3x1;\n\n      if(s10 * s20 > 0 || s11 * s21 > 0){\n        System.out.println(\"0\");  //no\n      }else if(s10 == 0 && s20 == 0 &&\n               (s1x0 * s2x0 < 0 || s1y0 * s2y0 < 0) &&\n               (s1x0 * s3x0 < 0 || s1y0 * s3y0 < 0)\n              ){\n        System.out.println(\"0\");  //no\n      }else if(s10 == 0 && s20 == 0 &&\n        ((s1x0 * s1x0) + (s1y0 * s1y0) < (s2x0 * s2x0) + (s2y0 * s2y0)) &&\n        ((s1x0 * s1x0) + (s1y0 * s1y0) < (s3x0 * s3x0) + (s3y0 * s3y0))\n              ){\n        System.out.println(\"0\");  //no\n      }else{\n        System.out.println(\"1\");  //yes\n      }\n    }\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "// package codecheck;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\nclass Point implements Comparable<Point> {\n    static double EPS = 1e-9;\n    double x;\n    double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point o) {\n        if (Math.abs(x - o.x) > EPS)\n            return (int) Math.signum(x - o.x);\n        else\n            return (int) Math.signum(y - o.y);\n    }\n\n    Point add(Point p) {\n        return new Point(x + p.x, y + p.y);\n    }\n \n    Point subtract(Point p) {\n        return new Point(x - p.x, y - p.y);\n    }\n \n    Point multiply(double k) {\n        return new Point(x * k, y * k);\n    }\n \n    Point devide(double k) {\n        return new Point(x / k, y / k);\n    }\n\n    double inner(Point p) {\n        return x * p.x + y * p.y;\n    }\n \n    double exterior(Point p) {\n        return x * p.y - y * p.x;\n    }\n\n    double norm() {\n        return x * x + y * y;\n    }\n}\n\nclass Segment {\n    Point p1;\n    Point p2;\n \n    public Segment(Point p1, Point p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n}\n\nclass Geometries {\n    static double EPS = 1e-9;\n\n    static enum Position {\n        COUNTER_CLOCKWISE(1),\n        CLOCKWISE(-1),\n        ONLINE_BACK(2),\n        ONLINE_FRONT(-2),\n        ON_SEGMENT(0);\n\n        private int id;\n        private Position(int id) {\n            this.id = id;\n        }\n    }\n\n    //return the position of p2 against the vector from p0 to p1\n    static Position ccw(Point p0, Point p1, Point p2) {\n        Point v1 = p1.subtract(p0);\n        Point v2 = p2.subtract(p0);\n        if( v1.exterior(v2) > EPS)  return Position.COUNTER_CLOCKWISE;\n        if( v1.exterior(v2) < -EPS) return Position.CLOCKWISE;\n        if( v1.inner(v2) < - EPS)   return Position.ONLINE_BACK;\n        if( v1.norm() < v2.norm() ) return Position.ONLINE_FRONT;\n        return Position.ON_SEGMENT;\n    }\n    static Position ccw(Segment s, Point p) {\n        return ccw(s.p1, s.p2, p);\n    }\n\n    static boolean intersect(Segment s1, Segment s2) {\n        Position pos1, pos2, pos3, pos4;\n        pos1 = ccw(s1, s2.p1);\n        pos2 = ccw(s1, s2.p2);\n        pos3 = ccw(s2, s1.p1);\n        pos4 = ccw(s2, s1.p2);\n        return pos1.id * pos2.id <= 0 && pos3.id * pos4.id <= 0;\n    }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n        String line;\n        String[] words;\n \n        int q = sc.nextInt();\n \n        for (int i = 0; i < q; i++) {\n            double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n            xp0 = sc.nextDouble();\n            yp0 = sc.nextDouble();\n            xp1 = sc.nextDouble();\n            yp1 = sc.nextDouble();\n            xp2 = sc.nextDouble();\n            yp2 = sc.nextDouble();\n            xp3 = sc.nextDouble();\n            yp3 = sc.nextDouble();\n \n            Point p0, p1, p2, p3;\n            p0 = new Point(xp0, yp0);\n            p1 = new Point(xp1, yp1);\n            p2 = new Point(xp2, yp2);\n            p3 = new Point(xp3, yp3);\n\n            Segment s1, s2;\n            s1 = new Segment(p0, p1);\n            s2 = new Segment(p2, p3);\n \n            if (Geometries.intersect(s1, s2)) {\n                System.out.println(1);\n            } else {\n                System.out.println(0);\n            }\n        }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n/*\n1\n0 0 0 3 0 1 0 2\n*/\n\npublic class Main {\n\tstatic double EPS = 0.0000000001;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint q = s.nextInt();\n\t\tfor (int i=0;i<q;i++) {\n\t\t\tif (intersect(new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()), new Point(s.nextInt(),s.nextInt()) )) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ccw(Point lp0, Point lp1, Point p) {\n\t\tVector lv = lp1.diff(lp0);\n\t\tVector pv = p.diff(lp0);\n\t\tdouble cp=0.0;\n\t\tif ((cp=lv.crossProduct(pv))>EPS) {return -1;} // counter-clockwise\n\t\tif (cp<-EPS) {return 1;} // clockwise\n\t\tif (lv.dotProduct(pv)<-EPS) return 2; // online-back\n\t\tif (lv.norm() < pv.norm()) return 3; // online-front\n\t\treturn 0; // on-segment\n\t}\n\tstatic boolean intersect(Point p0, Point p1, Point p2, Point p3) {\n\t\tint ccw0=ccw(p0,p1,p2)*ccw(p0,p1,p3);\n\t\tint ccw1=ccw(p2,p3,p0)*ccw(p2,p3,p1);\n\t\treturn ccw0<=0&&ccw1<=0||ccw0==0&&ccw1==6||ccw0==6&&ccw1==0;}\n\tstatic boolean intersect(Segment s1, Segment s2){return intersect(s1.p1,s1.p2,s2.p1,s2.p2);}\n\n}\nclass Point {\n\tdouble x; double y;\n\tpublic Point(double ax, double ay){x=ax;y=ay;}\n\tpublic Vector sum(Point p) { return new Vector(x+p.x,y+p.y); }\n\tpublic Vector diff(Point p) { return new Vector(x-p.x,y-p.y); }\n\tpublic Vector mult(double k) { return new Vector(x*k,y*k); }\n\tpublic Vector div(double k) { return new Vector(x*(1.0/k),y*(1.0/k)); }\n\tstatic double EPS = 0.0000000001;\n\tpublic boolean equals(Point p){return Math.abs(x-p.x)<EPS && Math.abs(y-p.y)<EPS;}\n\tpublic String toString(){return \"(\"+x+\",\"+y+\")\";}\n}\nclass Vector extends Point {\n\tpublic Vector(double ax, double ay) {super(ax,ay);}\n\tpublic Vector(Point p1, Point p2) {super(p1.x-p2.x,p2.x-p2.y);}\n\tpublic double norm() {return x*x+y*y;}\n\tpublic double abs() {return Math.sqrt(norm());}\n\t// TODO:\n\tpublic boolean isSmallerThan(Vector v) {return x!=v.x?x<v.x:y<v.y;}\n\tpublic double dotProduct(Vector v) {return x*v.x+y*v.y;}\n\tpublic double crossProduct(Vector v) {return x*v.y - y*v.x;}\n}\n\nclass Segment {\n\tPoint p1; Point p2;\n\tpublic Segment(Point ap1, Point ap2){p1=ap1;p2=ap2;}\n\tpublic double dotProduct(Segment s) {return (p1.x-p2.x)*(s.p1.x-s.p2.x)+(p1.y-p2.y)*(s.p1.y-s.p2.y);}\n\tpublic double crossProduct(Segment s) {return (p1.x-p2.x)*(s.p1.y-s.p2.y) - (p1.y-p2.y)*(s.p1.x-s.p2.x);}\n\tpublic String toString(){return p1.toString()+\"->\"+p2.toString();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??´???AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0\n\t\t\t *     ABxAC*ABxAD<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tif (xab != 0 || yab != 0) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\treturn (long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0;\n\t\t\t} else {\n\t\t\t\tint xcd = xd - xc;\n\t\t\t\tint ycd = yd - yc;\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\t/*\n\t\t\t * ??????AB??¨??????CD??¨??????????????????????????????\n\t\t\t * \n\t\t\t * |AB|==0 && |CD|==0\n\t\t\t *     ???A==???C\n\t\t\t * |AB|==0 && |CD|!=0\n\t\t\t *     ACxAD==0 && AC.AD<0\n\t\t\t * |AB|!=0 && |CD|==0\n\t\t\t *     CAxCB==0 && CA.CB<0\n\t\t\t * |AB|!=0 && |CD|!=0\n\t\t\t *     ABxCD==0\n\t\t\t *         (AB.AC>=0 || AB.AD>=0) && (BA.BC>=0 || BA.BD>=0)\n\t\t\t *     ABxCD!=0\n\t\t\t *         ABxAC*ABxAD<=0 && CDxCA*CDxCB<=0\n\t\t\t */\n\t\t\tint xab = xb - xa;\n\t\t\tint yab = yb - ya;\n\t\t\tint xcd = xd - xc;\n\t\t\tint ycd = yd - yc;\n\t\t\tif ((xab != 0 || yab != 0) && (xcd != 0 || ycd != 0)) {\n\t\t\t\tint xac = xc - xa;\n\t\t\t\tint yac = yc - ya;\n\t\t\t\tint xad = xd - xa;\n\t\t\t\tint yad = yd - ya;\n\t\t\t\tif (cross(xab, yab, xcd, ycd) != 0) {\n\t\t\t\t\tint xca = -xac;\n\t\t\t\t\tint yca = -yac;\n\t\t\t\t\tint xcb = xb - xc;\n\t\t\t\t\tint ycb = yb - yc;\n\t\t\t\t\treturn ((long)cross(xab, yab, xac, yac) * cross(xab, yab, xad, yad) <= 0)\n\t\t\t\t\t\t\t&& ((long)cross(xcd, ycd, xca, yca) * cross(xcd, ycd, xcb, ycb) <= 0);\n\t\t\t\t} else {\n\t\t\t\t\tint xba = -xab;\n\t\t\t\t\tint yba = -yab;\n\t\t\t\t\tint xbc = xc - xb;\n\t\t\t\t\tint ybc = yc - yb;\n\t\t\t\t\tint xbd = xd - xb;\n\t\t\t\t\tint ybd = yd - yb;\n\t\t\t\t\treturn (dot(xab, yab, xac, yac) >= 0 || dot(xab, yab, xad, yad) >= 0)\n\t\t\t\t\t\t\t&& (dot(xba, yba, xbc, ybc) >= 0 || dot(xba, yba, xbd, ybd) >= 0);\n\t\t\t\t}\n\t\t\t} else if (xab != 0 || yab != 0) {\n\t\t\t\tint xca = xc - xa;\n\t\t\t\tint yca = yc - ya;\n\t\t\t\tint xcb = xb - xc;\n\t\t\t\tint ycb = yb - yc;\n\t\t\t\treturn cross(xca, yca, xcb, ycb) == 0 && dot(xca, yca, xcb, ycb) < 0;\n\t\t\t} else {\n\t\t\t\tif (xcd != 0 || ycd != 0) {\n\t\t\t\t\tint xac = xc - xa;\n\t\t\t\t\tint yac = yc - ya;\n\t\t\t\t\tint xad = xd - xa;\n\t\t\t\t\tint yad = yd - ya;\n\t\t\t\t\treturn cross(xac, yac, xad, yad) == 0 && dot(xac, yac, xad, yad) < 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn xa == xc && ya == yc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic final double ALLOWABLE_ERROR = 0.00000001;\n\n\tpublic static void main(String[] args) {\n\t\tint q = sc.nextInt();\n\t\t\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tdouble x0 = sc.nextDouble();\n\t\t\tdouble y0 = sc.nextDouble();\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tdouble x3 = sc.nextDouble();\n\t\t\tdouble y3 = sc.nextDouble();\n\t\t\t\n\t\t\tdouble a1 = (y1 - y0) / (x1 - x0);\n\t\t\tdouble a2 = (y3 - y2) / (x3 - x2);\n\t\t\tdouble b1 = y0 - a1 * x0;\n\t\t\tdouble b2 = y2 - a2 * x2;\n\t\t\t\n\t\t\tdouble x;\n\t\t\tdouble y;\n\t\t\tif(x0 == x1) {\n\t\t\t\ty = a2 * x0 + b2;\n\t\t\t\tif(Math.min(y0, y1) <= y && y <= Math.max(y0, y1)){\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else if(x2 == x3) {\n\t\t\t\ty = a1 * x2 + b1;\n\t\t\t\tif(Math.min(y2, y3) <= y && y <= Math.max(y2, y3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tx = (b1 - b2) / (a2 - a1);\n\t\t\t\tif(Math.min(x0, x1) <= x && x <= Math.max(x0, x1) && Math.min(x2, x3) <= x && x <= Math.max(x2, x3)) {\n\t\t\t\t\tans.append(1);\n\t\t\t\t} else {\n\t\t\t\t\tans.append(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.math.BigDecimal;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint q = stdIn.nextInt();\n\t\tfor(int i=0;i<q;i++){\n\t\t\tdouble x0 = stdIn.nextDouble();\n\t\t\tdouble y0 = stdIn.nextDouble();\n\t\t\tdouble x1 = stdIn.nextDouble();\n\t\t\tdouble y1 = stdIn.nextDouble();\n\t\t\tdouble x2 = stdIn.nextDouble();\n\t\t\tdouble y2 = stdIn.nextDouble();\n\t\t\tdouble x3 = stdIn.nextDouble();\n\t\t\tdouble y3 = stdIn.nextDouble();\n\t\t\tPoint p0 = new Point(x0,y0);\n\t\t\tPoint p1 = new Point(x1,y1);\n\t\t\tPoint p2 = new Point(x2,y2);\n\t\t\tPoint p3 = new Point(x3,y3);\n\t\t\tif(p0.intersect(p1,p2,p3)){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\n\t}\t\n}\n\nclass Vector{\n\tpublic final double EPS = Math.pow(10,-8);\n\tpublic double x,y;\n\tfinal int cutoff = 9;\n\n\tVector( double x1 , double y1 , double x2 , double y2 ){\n\t\tthis.x = x2 - x1;\n\t\tthis.y = y2 - y1;\n\t}\n\n\tdouble dot( Vector a ){\t\n\t\treturn rounding(this.x * a.x + this.y * a.y);\n\t}\n\tdouble cross( Vector a ){\t\n\t\treturn rounding(this.x * a.y - this.y * a.x);\n\t}\n\n\tvoid add( Vector a ){\n\t\tthis.x = rounding(this.x + a.x);\n\t\tthis.y = rounding(this.y + a.y);\n\t}\n\tvoid sub( Vector a ){\n\t\tthis.x = rounding(this.x - a.x);\n\t\tthis.y = rounding(this.y - a.y);\n\t}\n\tvoid mul( double z ){\n\t\tthis.x = rounding(this.x * z);\n\t\tthis.y = rounding(this.y * z);\n\t}\n\tvoid div( double z ){\n\t\tthis.x = rounding(this.x / z);\n\t\tthis.y = rounding(this.y / z);\n\t}\n\n\tdouble abs(){\n\t\treturn Math.sqrt(norm());\n\t}\n\tdouble norm(){\n\t\treturn rounding(this.x * this.x + this.y * this.y);\n\t}\n\n\tvoid projection( Vector a ){\n\t\tif(judge(a.norm())){\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t}\n\t\telse{\n\t\t\tdouble cos = dot(a)/(abs() * a.abs());\n\t\t\tdouble frac = a.abs() * cos/abs();\n\t\t\tmul(frac);\n\t\t}\n\t}\n\tVector reflection( Vector a ){\n\t\tprojection(a);\n\t\treturn new Vector(a.x,a.y,this.x,this.y);\n\t}\n\n\tboolean judgeisOrthogonal( Vector a ){\t\n\t\treturn judge(dot(a)) ? true : false;\n\t}  \n\tboolean judgeisParallel( Vector a ){\t\n\t\treturn judge(cross(a)) ? true : false;\n\t}\n\n\tboolean judge( double a ){\t\t\n\t\treturn Math.abs(a)<EPS ? true : false;\n\t}\n\tdouble rounding(double a){\n\t\tBigDecimal bi = new BigDecimal(String.valueOf(a));\n\t\treturn bi.setScale(cutoff,BigDecimal.ROUND_HALF_UP).doubleValue();\n\t}\n} \n\n\nclass Point{\n\n\tpublic double x,y;\n\tfinal double EPS = Math.pow(10,-8);\n\tfinal int cutoff = 9;\n\n\tPoint(double x,double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tdouble abs(){\n\t\tPoint a = new Point(0,0);\t\n\t\treturn Math.sqrt(norm(a));\t\n\t}\n\tdouble abs( Point a ){\n\t\treturn Math.sqrt(norm(a));\n\t}\n\tdouble norm( Point a ){\t\n\t\treturn rounding((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));\n\t}\n\n\tvoid add( Point a ){\n\t\tthis.x = rounding(this.x + a.x);\n\t\tthis.y = rounding(this.y + a.y);\n\t}\n\tvoid sub( Point a ){\n\t\tthis.x = rounding(this.x - a.x);\n\t\tthis.y = rounding(this.y - a.y);\n\t}\n\tvoid mul( double z){\n\t\tthis.x = rounding(this.x * z);\n\t\tthis.y = rounding(this.x * z);\n\t}\n\tvoid div( double z){\n\t\tthis.x = rounding(this.x / z);\n\t\tthis.y = rounding(this.x / z);\n\t}\n\n\tPoint getCrossPoint( Point a , Point b , Point c ){\n\t\tPoint d = new Point(this.x,this.y);\n\t\tVector s1 = new Vector(d.x,d.y,a.x,a.y);\n\t\tVector s2 = new Vector(b.x,b.y,c.x,c.y);\n\t\tdouble t1 = getDistanceSP(b,c);\n\t\tdouble t2 = a.getDistanceSP(b,c);\n\t\ts1.mul(t1/(t1+t2));\n\t\tVector s3 = new Vector(b.x,b.y,d.x,d.y);\n\t\ts3.add(s1);\n\t\treturn new Point(b.x+s3.x,b.y+s3.y);\n\t}\n\n\tdouble getDistance( Point a , Point b , Point c ){\n\t\tif(intersect(a,b,c)){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn Math.min(getDistanceSP(b,c),a.getDistanceSP(b,c));\n\t}\n\tdouble getDistanceSP( Point a , Point b ){\n\t\tVector s = new Vector( a.x , a.y , b.x , b.y);\n\t\tVector sa = new Vector( a.x , a.y , this.x , this.y );\n\t\tVector sb = new Vector( b.x , b.y , this.x , this.y );\n\t\tif(s.dot(sa)<0.00){\n\t\t\treturn abs(a);\n\t\t}\n\t\ts.mul(-1);\n\t\tif(s.dot(sb)<0.00){\n\t\t\treturn abs(b);\n\t\t}\n\t\treturn Math.abs(s.cross(sb)/s.abs());\n\t}\n\n\tint CCW( Point a , Point b ){\n\t\tVector sa = new Vector( this.x , this.y , a.x , a.y );\n\t\tVector sb = new Vector( this.x , this.y , b.x , b.y );\n\t\tif(sa.cross(sb) > EPS){\n\t\t\treturn -1;\n\t\t}\n\t\telse if(sa.cross(sb) < -EPS){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(sa.dot(sb) < -EPS){\n\t\t\treturn -2;\n\t\t}\n\t\telse if(sa.norm() < sb.norm()){\n\t\t\treturn 2;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tboolean intersect( Point a , Point b , Point c ){\n\t\tPoint d = new Point(this.x,this.y);\n\t\tif(CCW(a,b)*CCW(a,c) <= 0 && b.CCW(c,a)*b.CCW(c,d) <= 0){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tint contains( Point[] query ){\n\t\tboolean flag1 = false;\n\t\tboolean flag2 = false;\n\t\tPoint p1 = new Point(this.x+1,this.y);\n\t\tfor(int i=0;i<query.length;i++){\n\t\t\tif(CCW(query[i],p1) == 2 || CCW(query[i],p1) == 0){\n\t\t\t\tflag1 = true;\n\t\t\t}\n\t\t}\n\t\tPoint p2 = new Point(Integer.MAX_VALUE/2,this.y);\n\t\tfinal int l = query.length;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(intersect(p2,query[i%l],query[(i+1)%l])){\n\t\t\t\tflag2 = true;\n\t\t\t}\n\t\t}\n\n\t\tif(flag1){\n\t\t\treturn 2;\n\t\t}\n\t\telse if(flag2){\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid temp( Point a ){\n\t\tPoint temp = new Point(0,0);\n\t\ttemp.x = this.x;\n\t\ttemp.y = this.y;\n\t\tthis.x = a.x;\n\t\tthis.y = a.y;\n\t\ta.x = temp.x;\n\t\ta.y = temp.y;\n\t}\n\tvoid sort( Point[] query ){\n\t\tfor(int i=0;i<query.length;i++){\n\t\t\tfor(int j=0;j<query.length-1-i;j++){\n\t\t\t\tif(query[j].x > query[j+1].x){\n\t\t\t\t\tquery[j].temp(query[j+1]);\n\t\t\t\t}\n\t\t\t\telse if(query[j].x == query[j+1].x && query[j].y > query[j+1].y){\n\t\t\t\t\tquery[j].temp(query[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tArrayList<Point> andrewScan( Point[] query ){\n\t\tArrayList<Point> list = new ArrayList<Point>();\n\t\tif(query.length<4){\n\t\t\tfor(int i=0;i<query.length;i++){\n\t\t\t\tlist.add(query[i]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsort(query);\n\t\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\t\tlist1.add(query[0]);\n\t\t\tlist1.add(query[1]);\n\t\t\tint next = 2;\n\t\t\twhile(next<query.length-1){\n\t\t\t\tif(list1.size()<2){\n\t\t\t\t\tlist1.add(query[next]);\n\t\t\t\t\tnext++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint p1 = list1.get(list1.size()-2);\n\t\t\t\t\tPoint p2 = list1.get(list1.size()-1);\n\t\t\t\t\tif(p1.CCW(p2,query[next])!=-1){\n\t\t\t\t\t\tlist1.add(query[next]);\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlist1.remove(list1.size()-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPoint p1 = list1.get(list1.size()-2);\n\t\t\tPoint p2 = list1.get(list1.size()-1);\n\t\t\tif(p1.CCW(p2,query[query.length-1])!=-1){\n\t\t\t\tlist1.add(query[query.length-1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist1.remove(list1.size()-1);\n\t\t\t\tlist1.add(query[query.length-1]);\n\t\t\t}\n\t\t\tlist2.add(query[query.length-1]);\n\t\t\tlist2.add(query[query.length-2]);\n\t\t\tnext = query.length-3;\n\t\t\twhile(next>0){\n\t\t\t\tif(list2.size()<2){\n\t\t\t\t\tlist2.add(query[next]);\n\t\t\t\t\tnext--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint a = list2.get(list2.size()-2);\n\t\t\t\t\tPoint b = list2.get(list2.size()-1);\n\t\t\t\t\tif(a.CCW(b,query[next])!=-1){\n\t\t\t\t\t\tlist2.add(query[next]);\n\t\t\t\t\t\tnext--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlist2.remove(list2.size()-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp1 = list2.get(list2.size()-2);\n\t\t\tp2 = list2.get(list2.size()-1);\n\t\t\tif(p1.CCW(p2,query[0])>=0){\n\t\t\t\tlist2.add(query[0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist2.remove(list2.size()-1);\n\t\t\t\tlist2.add(query[0]);\n\t\t\t}\n\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\tlist.add(list1.get(i));\n\t\t\t}\n\t\t\tfor(int i=1;i<list2.size()-1;i++){\n\t\t\t\tlist.add(list2.get(i));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tPoint polarCos(double cos_a){\n\t\tdouble sin_a = Math.sqrt(1-Math.pow(cos_a,2));\n\t\tdouble x = cos_a*this.x - sin_a*this.y;\n\t\tdouble y = sin_a*this.x + cos_a*this.y;\n\t\treturn new Point(x,y); \n\t}\n\tPoint polarSin(double sin_a){\n\t\tdouble cos_a = Math.sqrt(1-Math.pow(sin_a,2));\n\t\tdouble x = cos_a*this.x - sin_a*this.y;\n\t\tdouble y = sin_a*this.x + cos_a*this.y;\n\t\treturn new Point(x,y); \n\t}\n\n\tboolean judge( Point a ){\t\n\t\tif( Math.abs( this.x - a.x ) < EPS && Math.abs( this.y - a.y ) < EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tdouble rounding(double a){\n\t\tBigDecimal bi = new BigDecimal(String.valueOf(a));\n\t\treturn bi.setScale(cutoff,BigDecimal.ROUND_HALF_UP).doubleValue();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint xp0 = sc.nextInt();\n\t\t\tint yp0 = sc.nextInt();\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\n\t\t\tif (Geom.lineSegsIntersect(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Geom {\n\t\tstatic int dot(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * xb + ya * yb;\n\t\t}\n\n\t\tstatic int cross(int xa, int ya, int xb, int yb) {\n\t\t\treturn xa * yb - xb * ya;\n\t\t}\n\t\t\n\t\tstatic int sumofsquare(int xa, int ya) {\n\t\t\treturn xa * xa + ya * ya;\n\t\t}\n\n\t\tstatic boolean lineSegsIntersect(int xa, int ya, int xb, int yb, int xc, int yc, int xd, int yd) {\n\t\t\tint abx = xb - xa;\n\t\t\tint aby = yb - ya;\n\t\t\tint acx = xc - xa;\n\t\t\tint acy = yc - ya;\n\t\t\tint adx = xd - xa;\n\t\t\tint ady = yd - ya;\n\t\t\tint cdx = xd - xc;\n\t\t\tint cdy = yd - yc;\n\t\t\tint cax = xa - xc;\n\t\t\tint cay = ya - yc;\n\t\t\tint cbx = xb - xc;\n\t\t\tint cby = yb - yc;\n\n\t\t\treturn (cross(abx, aby, acx, acy) * Geom.cross(abx, aby, adx, ady) <= 0)\n\t\t\t\t\t&& (Geom.cross(cdx, cdy, cax, cay) * Geom.cross(cdx, cdy, cbx, cby) <= 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Console;\nusing static System.Math;\nusing static MyIO;\nusing static MyUtil;\n\nusing static Geometory;\nusing Vector = Geometory.Point;\nusing Line = Geometory.Segment;\n\npublic class B\n{\n\tpublic static void Main() => (new Solver()).Solve();\n}\n\npublic class Solver\n{\n\tpublic void Solve()\n\t{\n\t\tint Q = GetInt();\n\t\tvar ans = new int[Q];\n\t\tfor(int i = 0; i < Q; i++)\n\t\t{\n\t\t\tvar p0 = new Point(GetDouble(), GetDouble());\n\t\t\tvar p1 = new Point(GetDouble(), GetDouble());\n\t\t\tvar p2 = new Point(GetDouble(), GetDouble());\n\t\t\tvar p3 = new Point(GetDouble(), GetDouble());\n\t\t\tvar s1 = new Segment(p0, p1);\n\t\t\tvar s2 = new Segment(p2, p3);\n\t\t\tans[i] = Intersect(s1, s2) ? 1 : 0;\n\t\t}\n\t\tWriteLine(string.Join(\"\\n\", ans));\n\t}\n}\n\npublic static class Geometory\n{\n\tprivate const double EPS = 1e-10;\n\tpublic static bool Equals(double a, double b) => Math.Abs(a - b) < EPS;\n\n\tpublic class Point\n\t{\n\t\tpublic double X;\n\t\tpublic double Y;\t\t\n\t\tpublic Point(double x, double y)\n\t\t{\n\t\t\tX = x;\n\t\t\tY = y;\n\t\t}\n\t\n\t\tpublic static Point operator+(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\t\tpublic static Point operator-(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n\t\tpublic static Point operator*(Point p, double a) => new Point(a * p.X, a * p.Y);\n\t\tpublic static Point operator*(double a, Point p) => new Point(a * p.X, a * p.Y);\n\t\tpublic static Point operator/(Point p, double a) => new Point(p.X / a, p.Y / a);\n\t}\n\n\tpublic class Segment\n\t{\n\t\tpublic Point P1;\n\t\tpublic Point P2;\n\t\tpublic Segment(Point p1, Point p2)\n\t\t{\n\t\t\tP1 = p1;\n\t\t\tP2 = p2;\n\t\t}\n\t}\n\n\tpublic static double Abs(Vector a) => Math.Sqrt(Norm(a));\n\tpublic static double Norm(Vector a) => a.X * a.X + a.Y * a.Y;\n\tpublic static double Dot(Vector a, Vector b) => a.X * b.X + a.Y * b.Y;\n\tpublic static double Cross(Vector a, Vector b) => a.X * b.Y - a.Y * b.X;\n\n\tpublic static bool IsOrthogonal(Vector a, Vector b) => Equals(Dot(a, b), 0.0);\n\tpublic static bool IsOrthogonal(Point a1, Point a2, Point b1, Point b2) => IsOrthogonal(a1 - a2, b1 - b2);\n\tpublic static bool IsOrthogonal(Segment s1, Segment s2) => Equals(Dot(s1.P2 - s1.P1, s2.P2 - s2.P1), 0.0);\n\tpublic static bool IsParallel(Vector a, Vector b) => Equals(Cross(a, b), 0.0);\n\tpublic static bool IsParallel(Point a1, Point a2, Point b1, Point b2) => IsParallel(a1 - a2, b1 - b2);\n\tpublic static bool IsParallel(Segment s1, Segment s2) => Equals(Cross(s1.P2 - s1.P1, s2.P2 - s2.P1), 0.0);\n\n\tpublic static Point Project(Segment s, Point p)\n\t{\n\t\tVector b = s.P2 - s.P1;\n\t\tdouble r = Dot(p - s.P1, b) / Norm(b);\n\t\treturn s.P1 + b * r;\n\t}\n\tpublic static Point Reflect(Segment s, Point p) => p + (Project(s, p) - p) * 2.0;\n\n\tpublic static double GetDistance(Point a, Point b) => Abs(a - b);\n\tpublic static double GetDistanceLP(Line l, Point p) => Math.Abs(Cross(l.P2 - l.P1, p - l.P1) / Abs(l.P2 - l.P1));\n\tpublic static double GetDistanceSP(Segment s, Point p)\n\t{\n\t\tif(Dot(s.P2 - s.P1, p - s.P1) < 0.0) return Abs(p - s.P1);\n\t\tif(Dot(s.P1 - s.P2, p - s.P2) < 0.0) return Abs(p - s.P2);\n\t\treturn GetDistanceLP(s, p);\n\t}\n\tpublic static double GetDistance(Segment s1, Segment s2)\n\t{\n\t\tif(Intersect(s1, s2)) return 0.0;\n\t\treturn Math.Min(Math.Min(GetDistanceSP(s1, s2.P1), GetDistanceSP(s1, s2.P2)),\n\t\t                Math.Min(GetDistanceSP(s2, s1.P1), GetDistanceSP(s2, s1.P2)));\n\t}\n\n\tpublic const int COUNTER_CLOCKWISE = 1;\n\tpublic const int CLOCKWISE = -1;\n\tpublic const int ONLINE_BACK = 2;\n\tpublic const int ONLINE_FRONT = -2;\n\tpublic const int ON_SEGMENT = 0;\n\tpublic static int Ccw(Point p0, Point p1, Point p2)\n\t{\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif(Cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif(Cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif(Dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif(Norm(a) < Norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\tpublic static bool Intersect(Point p1, Point p2, Point p3, Point p4)\n\t{\n\t\treturn (Ccw(p1, p2, p3) * Ccw(p1, p2, p4) <= 0 && \n\t\t        Ccw(p3, p4, p1) * Ccw(p3, p4, p2) <= 0);\n\t}\n\tpublic static bool Intersect(Segment s1, Segment s2) => Intersect(s1.P1, s1.P2, s2.P1, s2.P2);\n}\n\npublic static class MyIO\n{\n\tprivate static string[] args = null;\n\tprivate static int num = -1;\n\tprivate static int used = -1;\n\n\tprivate static string getArg()\n\t{\n\t\tif(used == num)\n\t\t{\n\t\t\targs = Console.ReadLine().Split(' ');\n\t\t\tnum = args.Length;\n\t\t\tused = 0;\n\t\t}\n\t\treturn args[used++];\n\t}\n\n\tpublic static int GetInt() => int.Parse(getArg());\n\tpublic static long GetLong() => long.Parse(getArg());\n\tpublic static double GetDouble() => double.Parse(getArg());\n\tpublic static decimal GetDecimal() => decimal.Parse(getArg());\n\tpublic static string GetString() => getArg();\n\tpublic static char GetChar() => getArg()[0];\n\tpublic static int[] GetInts(long N) => Enumerable.Range(0, (int)N).Select(_ => GetInt()).ToArray();\n\tpublic static long[] GetLongs(long N) => Enumerable.Range(0, (int)N).Select(_ => GetLong()).ToArray();\n\tpublic static double[] GetDoubles(long N) => Enumerable.Range(0, (int)N).Select(_ => GetDouble()).ToArray();\n\tpublic static decimal[] GetDecimals(long N) => Enumerable.Range(0, (int)N).Select(_ => GetDecimal()).ToArray();\n\tpublic static string[] GetStrings(long N) => Enumerable.Range(0, (int)N).Select(_ => GetString()).ToArray();\n}\n\npublic static class MyUtil\n{\n\tpublic static void chmax<T>(ref T x, T y) where T : IComparable<T>\n\t{\n\t\tif(x.CompareTo(y) < 0)\n\t\t\tx = y;\n\t}\n\n\tpublic static void chmin<T>(ref T x, T y) where T : IComparable<T>\n\t{\n\t\tif(x.CompareTo(y) > 0)\n\t\t\tx = y;\n\t}\n\n\tpublic static void swap<T>(ref T x, ref T y)\n\t{\n\t\tT tmp = x;\n\t\tx = y;\n\t\ty = tmp;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\ninline bool equals(double a, double b) { return fabs(a - b) < eps ;}\n\nclass Point {\npublic:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {};\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n    }\n};\n\nstruct Segment {Point p1, p2;};\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    double ta, tb, tc, td;\n    ta = (p3.x - p4.x) * (p1.y - p3.y) + (p3.y - p4.y) * (p3.x - p1.x);\n    tb = (p3.x - p4.x) * (p2.y - p3.y) + (p3.y - p4.y) * (p3.x - p2.x);\n    tc = (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p1.x - p3.x);\n    td = (p1.x - p2.x) * (p4.y - p1.y) + (p1.y - p2.y) * (p1.x - p4.x);\n    return ta * tb <= 0 && tc * td <= 0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(void) {\n    int q;\n    cin >> q;\n    while (q--) {\n        double x0, y0, x1, y1, x2, y2, x3, y3;\n        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        Segment s1 = {Point(x0, y0), Point(x1, y1)};\n        Segment s2 = {Point(x2, y2), Point(x3, y3)};\n        cout << (intersect(s1, s2) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Diagnostics;\nusing Aoj.CGL.Lib;\n\nnamespace Aoj.CGL.Chapter2B\n{\n    class Program\n    {\n        public static void Solve()\n        {\n            int q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < q; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                var seg1 = new Segment(input[0],input[1],input[2],input[3]);\n                var seg2 = new Segment(input[4],input[5],input[6],input[7]);\n\n                var isIntersect = MathUtil.Intersect(seg1, seg2);\n\n                Console.WriteLine(isIntersect ? \"1\" : \"0\");\n            }\n        }\n\n        public static void Main()\n        {\n            // Console.SetIn(new System.IO.StreamReader(\"ComputationalGeometry/Input/02_Segment_Line_B_01.txt\"));\n            // var sw = new Stopwatch();\n            // sw.Start();\n\n            Solve();\n\n            // Console.WriteLine(\"{0}ms\", sw.ElapsedMilliseconds);\n        }\n    }\n}\n\nnamespace Aoj.CGL.Lib\n{\n    using Line = Segment;\n\n    using Point = Vector;\n\n    using Polygon = List<Vector>;\n\n    public struct Segment\n    {\n        private Point _p1;\n        private Point _p2;\n\n        public Point P1 { get{ return _p1; } }\n        public Point P2 { get{ return _p2; } }\n\n        public Segment(Point p1, Point p2)\n        {\n            _p1 = p1;\n            _p2 = p2;\n        }\n\n        public Segment(double x1, double y1, double x2, double y2)\n        {\n            _p1 = new Point(x1, y1);\n            _p2 = new Point(x2, y2);\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"P1x:{0},P1y:{1}, P2x:{2},P2y:{3}\", P1.X, P1.Y, P2.X, P2.Y);\n        }\n    }\n\n    public struct Circle\n    {\n        private Point _p;\n        private double _r;\n\n        public Point P { get { return _p; } }\n        public double R { get { return _r; } }\n\n        public Circle(Point p, double r)\n        {\n            _p = p;\n            _r = r;\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"px:{0},py:{1},r:{2}\", P.X, P.Y, R);\n        }\n    }\n\n    public struct Vector\n    {\n        private double _x;\n        private double _y;\n\n        public double X { get { return _x;} }\n        public double Y { get { return _y;} }\n\n        public Vector(double x, double y)\n        {\n            _x = x;\n            _y = y;\n        }\n\n        public double Norm()\n        {\n            return X * X + Y * Y;\n        }\n\n        public double Abs()\n        {\n            return Math.Sqrt(Norm());\n        }\n\n        public Vector Normalize()\n        {\n            double mag = Abs();\n            return new Vector(X * mag, Y * mag);\n        }\n\n        public static Vector operator +(Vector v1, Vector v2)\n        {\n            return new Vector(v1.X + v2.X, v1.Y + v2.Y);\n        }\n\n        public static Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.X - v2.X, v1.Y - v2.Y);\n        }\n\n        public static Vector operator *(Vector v, double k)\n        {\n            return new Vector(v.X * k, v.Y * k);\n        }\n\n        public static Vector operator *(double k, Vector v)\n        {\n            return v * k;\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"x:{0},y:{1}\", X, Y);\n        }\n    }\n\n    public static class MathUtil\n    {\n        public static double Dot(Vector v1, Vector v2)\n        {\n            return v1.X * v2.X + v1.Y * v2.Y;\n        }\n\n        public static double Cross(Vector v1, Vector v2)\n        {\n            return v1.X * v2.Y - v1.Y * v2.X;\n        }\n\n        public static bool IsOrthogonal(Vector v1, Vector v2)\n        {\n            return Dot(v1, v2) == 0.0;\n        }\n\n        public static bool IsOrthogonal(Point a1, Point a2, Point b1, Point b2)\n        {\n            return IsOrthogonal(a1 - a2, b1 - b2);\n        }\n\n        public static bool IsOrthogonal(Segment s1, Segment s2)\n        {\n            return IsOrthogonal((Vector)(s1.P1 - s1.P2), (Vector)(s2.P1 - s2.P2));\n        }\n\n        public static bool IsParallel(Vector v1, Vector v2)\n        {\n            return Cross(v1, v2) == 0.0;\n        }\n\n        public static bool IsParallel(Point a1, Point a2, Point b1, Point b2)\n        {\n            return IsParallel(a1 - a2, b1 - b2);\n        }\n        public static bool IsParallel(Segment s1, Segment s2)\n        {\n            return IsParallel((Vector)(s1.P1 - s1.P2), (Vector)(s2.P1 - s2.P2));\n        }\n\n        public static Vector Project(Vector v, Vector onNormal)\n        {\n            // mag = |b|cos?? / |a|\n            //     = |a||b|cos?? / |a|^2\n            double mag = Dot(v, onNormal) / onNormal.Norm();\n            return new Vector(onNormal.X * mag, onNormal.Y * mag);\n        }\n\n        public static Point Project(Point p, Segment s)\n        {\n            Vector v  = p - s.P1;\n            Vector baseV = s.P2 - s.P1;\n            Vector project = Project(v, baseV);\n            return s.P1 + project;\n        }\n\n        public static Point Reflect(Point p, Segment s)\n        {\n            Point project = Project(p, s);\n            return p + (project - p) * 2.0;\n        }\n\n        // ??????????????????????¨??????? ~ ????¨????????????¢???????????°???\n        public const int OnLineBack = 2;\n        public const int CounterClockwise = 1;\n        public const int OnSegment = 0;\n        public const int Clockwise = -1;\n        public const int OnLineFront = -2;\n\n        /// <summary>\n        /// ??????p0p1??????????????????p0p2??????????¨??????? ~ ????¨?????????????????????????????????????int??§?????????\n        /// </summary>\n        /// <param name=\"p0\"></param>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <returns></returns>\n        public static int Ccw(Point p0, Point p1, Point p2)\n        {\n            var baseV = p1 - p0;\n            var v = p2 - p0;\n            if (Cross(baseV, v) > 0)\n                return CounterClockwise;\n            else if (Cross(baseV, v) < 0)\n                return Clockwise;\n            else if (Dot(baseV, v) < 0)\n                return OnLineBack;\n            else if (baseV.Norm() < v.Norm())\n                return OnLineFront;\n            return OnSegment;\n        }\n\n        /// <summary>\n        /// ????????????????????´??????????????????????¢?????????????\n        /// http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool Intersect(Segment s1, Segment s2)\n        {\n            return Intersect(s1.P1, s1.P2, s2.P1, s2.P2);\n        }\n\n        public static bool Intersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            return (\n                Ccw(p1, p2, p3) * Ccw(p1, p2, p4) <= 0 &&\n                Ccw(p3, p4, p1) * Ccw(p3, p4, p2) <= 0\n            );\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            if (p1.x >= p2.x)\n                if ((p1.x < p3.x && p1.x < p4.x) || (p2.x > p3.x && p2.x > p4.x))\n                    return false;\n                else if ((p2.x < p3.x && p2.x < p4.x) || (p1.x > p3.x && p1.x > p4.x))\n                        return false;\n            if (p1.y >= p2.y)\n                if ((p1.y < p3.y && p1.y < p4.y) || (p2.y > p3.y && p2.y > p4.y))\n                    return false;\n                else if ((p2.y < p3.y && p2.y < p4.y) || (p1.y > p3.y && p1.y > p4.y))\n                        return false;\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td < 0 && ta * tb < 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            int q = int.Parse(Console.ReadLine());\n\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < q; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Pt a = new Pt(input[0], input[1]);\n                Pt b = new Pt(input[2], input[3]);\n                Pt c = new Pt(input[4], input[5]);\n                Pt d = new Pt(input[6], input[7]);\n\n                sb.AppendLine(IsIntersect(a, b, c, d) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsIntersect(Pt p1, Pt p2, Pt p3, Pt p4)\n        {\n            return CCW(p1, p2, p3) * CCW(p1, p2, p4) <= 0 &&\n                   CCW(p3, p4, p1) * CCW(p3, p4, p2) <= 0;\n        }\n\n        static int CCW(Pt p0, Pt p1, Pt p2)\n        {\n            Pt a = p1 - p0, b = p2 - p0;\n\n            if (a.Cross(b) > EPS) return 1;\n            if (a.Cross(b) < -EPS) return -1;\n            if (a.Dot(b) < -EPS) return 2;\n            if (a.Norm < b.Norm) return -2;\n            return 0;\n        }\n    }\n\n    class Pt : IComparable<Pt>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Pt(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Pt p) { return x * p.x + y * p.y; }\n        public double Cross(Pt p) { return x * p.y - y * p.x; }\n\n        public static Pt operator +(Pt a, Pt b) { return new Pt(a.x + b.x, a.y + b.y); }\n        public static Pt operator -(Pt a, Pt b) { return new Pt(a.x - b.x, a.y - b.y); }\n        public static Pt operator *(Pt p, double d) { return new Pt(p.x * d, p.y * d); }\n        public static Pt operator /(Pt p, double d) { return new Pt(p.x / d, p.y / d); }\n        public static bool operator <(Pt a, Pt b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Pt a, Pt b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Pt a, Pt b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Pt a, Pt b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Pt other)\n        {\n            return x != other.x ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Pt other = (Pt)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class Seg\n    {\n        internal Pt p1, p2;\n\n        public Seg(Pt a, Pt b)\n        {\n            p1 = a;\n            p2 = b;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint n=sc.I;\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\tsb.Append(Gp1(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7])+\"\\n\");\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n\tstatic int Gp1(double p1x,double p1y,double p2x,double p2y,double p3x,double p3y,double p4x,double p4y){\n\t\tdouble t1=(p4y-p3y)*(p4x-p1x)-(p4x-p3x)*(p4y-p1y);\n\t\tdouble t2=(p2x-p1x)*(p4y-p1y)-(p2y-p1y)*(p4x-p1x);\n\t\tdouble t3=(p2x-p1x)*(p4y-p3y)-(p2y-p1y)*(p4x-p3x);\n\t\tif(t3==0){\n\t\t\tif(Abs(Atan2(p2y-p1y,p2x-p1x))!=Abs(Atan2(p3y-p1y,p3x-p1x))){return p1x==p3x&&p1y==p3y?1:0;}\n\t\t\tvar a=new double[][]{new double[]{p1x,p1y,1},new double[]{p2x,p2y,2},new double[]{p3x,p3y,3},new double[]{p4x,p4y,4}};\n\t\t\tArray.Sort(a,(x,y)=>{var c=x[0].CompareTo(y[0]);return c==0?y[1].CompareTo(x[1]):c;});\n\t\t\treturn (Abs(a[0][2]-a[1][2])!=1||Abs(a[2][2]-a[3][2])!=1)||(a[1][0]==a[2][0]&&a[1][1]==a[2][1])?1:0;\n\t\t}\n\t\tdouble t4=t1/t3,t5=t2/t3;\n\t\treturn (t4<0||t4>1||t5<0||t5>1||t3==0)?0:1;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using Vector = CGL.Point;\n//using Line = CGL.Segment;\n//using Polygon = System.Collections.Generic.List<CGL.Point>;\n\nnamespace CGL\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var q = scan[0];\n            for (int i = 0; i < q; i++)\n            {\n                var t = scan;\n                var P = new Point[4];\n                for (int j = 0; j < 4; j++)\n                {\n                    P[j] = new Point(t[j * 2], t[j * 2 + 1]);\n                }\n                var s1 = new Segment(P[0], P[1]);\n                var s2 = new Segment(P[2], P[3]);\n                Console.WriteLine(s1.Intersect(s2) ? 1 : 0);\n            }\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n    \n    struct Point\n    {\n        static readonly double EPS = 1E-10;\n        public double x, y;\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(double k, Point a) { return new Point(k * a.x, k * a.y); }\n        public static Point operator /(double k, Point a) { return new Point(a.x / k, a.y / k); }\n        \n        public double Abs { get { return Math.Sqrt(Norm); } }  \n        public double Norm { get { return x * x + y * y; } }\n\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public override bool Equals(object p){  return Math.Abs(x - ((Point)p).x) < EPS && Math.Abs(y - ((Point)p).y) < EPS; }\n        public override int GetHashCode(){ return x.GetHashCode() ^ y.GetHashCode(); }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double GetDistance(Point p) { return (this - p).Abs; }\n\n        public int CCW(Point b)\n        {\n            if (Cross(b) > EPS) return 1;\n            if (Cross(b) < -EPS) return -1;\n            if (Dot(b) < -EPS) return 2;\n            if (Norm < b.Norm) return -2;\n            return 0;\n        }\n    }\n    struct Segment\n    {\n        public Point p1, p2;\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        public Point Projection(Point p)\n        {\n            Point b = p2 - p1;\n            double r = b.Dot(p - p1) / b.Norm;\n            return p1 + r * b;\n        }\n        public Point Reflection(Point p)\n        {\n            return p + 2 * (Projection(p) - p);\n        }\n        public double GetD_LP(Point p)\n        {\n            return Math.Abs((p - p1).Cross(p2 - p1) / (p2 - p1).Abs);\n        }\n        public double GetD_SP(Point p)\n        {\n            if ((p - p1).Dot(p2 - p1) < 0) return (p - p1).Abs;\n            if ((p - p2).Dot(p1 - p2) < 0) return (p - p2).Abs;\n            return GetD_LP(p);\n        }\n        public bool Intersect(Segment s)\n        {\n            return (p2 - p1).CCW(s.p1 - p1) * (p2 - p1).CCW(s.p2 - p1) <= 0 &&\n                (s.p2 - s.p1).CCW(p1 - s.p1) * (s.p2 - s.p1).CCW(p2 - s.p1) <= 0;\n        }\n        public double GetDistance(Segment s)\n        {\n            if (this.Intersect(s)) return 0;\n            return Math.Min(Math.Min(GetD_SP(s.p1), GetD_SP(s.p2)), Math.Min(s.GetD_SP(p1), s.GetD_SP(p2)));\n        }\n    }\n    /*struct Circle\n    {\n        public Point c; double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n\n    }*/\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            if (p1.x >= p2.x)\n                if ((p1.x < p3.x && p1.x < p4.x) || (p2.x > p3.x && p2.x > p4.x))\n                    return false;\n                else if ((p2.x < p3.x && p2.x < p4.x) || (p1.x > p3.x && p1.x > p4.x))\n                        return false;\n            if (p1.y >= p2.y)\n                if ((p1.y < p3.y && p1.y < p4.y) || (p2.y > p3.y && p2.y > p4.y))\n                    return false;\n                else if ((p2.y < p3.y && p2.y < p4.y) || (p1.y > p3.y && p1.y > p4.y))\n                        return false;\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td < 0 && ta * tb < 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program\n{\n\n\tstatic readonly int COUNTER_CLOCKWISE = 1;\n\tstatic readonly int CLOCKWISE = -1;\n\tstatic readonly int ONLINE_BACK = 2;\n\tstatic readonly int ONLINE_FRONT = -2;\n\tstatic readonly int ON_SEGMENT = 0;\n\n\tpublic class Vector\n\t{\n\t\tpublic double x, y;\n\n\t\tpublic Vector (double x, double y)\n\t\t{\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic static Vector operator- (Vector v1, Vector v2)\n\t\t{\n\t\t\treturn new Vector (v1.x - v2.x, v1.y - v2.y);\n\t\t}\n\t}\n\n\tpublic class Segment\n\t{\n\t\tpublic Vector p1, p2;\n\n\t\tpublic Segment (Vector v1, Vector v2)\n\t\t{\n\t\t\tp1 = v1;\n\t\t\tp2 = v2;\n\t\t}\n\t}\n\n\tpublic static double dot (Vector v1, Vector v2)\n\t{\n\t\treturn v1.x * v2.x + v1.y * v2.y;\n\t}\n\n\tpublic static double cross (Vector v1, Vector v2)\n\t{\n\t\treturn v1.x * v2.y - v1.y * v2.x;\n\t}\n\n\tstatic double norm (Vector v)\n\t{\n\t\treturn v.x * v.x + v.y * v.y;\n\t}\n\n\tstatic bool intersect (Vector p1, Vector p2, Vector p3, Vector p4)\n\t{\n\t\treturn (ccw (p1, p2, p3) * ccw (p1, p2, p4) <= 0 &&\n\t\tccw (p3, p4, p1) * ccw (p3, p4, p2) <= 0);\n\t}\n\n\tstatic bool intersect (Segment s1, Segment s2)\n\t{\n\t\treturn intersect (s1.p1, s1.p2, s2.p1, s2.p2);\n\t}\n\n\tstatic int ccw (Vector p1, Vector p2, Vector p3)\n\t{\n\t\tVector a = p2 - p1;\n\t\tVector b = p3 - p1;\n\t\tif (cross (a, b) > Double.Epsilon) {\n\t\t\treturn COUNTER_CLOCKWISE;\n\t\t}\n\t\tif (cross (a, b) < -Double.Epsilon) {\n\t\t\treturn CLOCKWISE;\n\t\t}\n\t\tif (dot (a, b) < -Double.Epsilon) {\n\t\t\treturn ONLINE_BACK;\n\t\t}\n\t\tif (norm (a) < norm (b)) {\n\t\t\treturn ONLINE_FRONT;\n\t\t}\n\t\treturn ON_SEGMENT;\n\t}\n\n\tpublic static void Main ()\n\t{\n\t\tint n = int.Parse (Console.ReadLine ());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring[] s = Console.ReadLine ().Split (' ');\n\t\t\tSegment seg1, seg2;\n\t\t\tVector p1, p2, p3, p4;\n\t\t\tp1 = new Vector (int.Parse (s [0]), int.Parse (s [1]));\n\t\t\tp2 = new Vector (int.Parse (s [2]), int.Parse (s [3]));\n\t\t\tp3 = new Vector (int.Parse (s [4]), int.Parse (s [5]));\n\t\t\tp4 = new Vector (int.Parse (s [6]), int.Parse (s [7]));\n\n\t\t\tseg1 = new Segment (p1, p2);\n\t\t\tseg2 = new Segment (p3, p4);\n\n\t\t\tif(intersect(seg1, seg2))\n\t\t\t  {\n\t\t\tConsole.WriteLine (\"1\");\n\t\t\t  } else {\n\t\t\tConsole.WriteLine (\"0\");\n\t\t\t  }\n\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            if (p1.x >= p2.x)\n                if ((p1.x < p3.x && p1.x < p4.x) || (p2.x > p3.x && p2.x > p4.x))\n                    return false;\n                else\n                    if ((p2.x < p3.x && p2.x < p4.x) || (p1.x > p3.x && p1.x > p4.x))\n                        return false;\n            if (p1.y >= p2.y)\n                if ((p1.y < p3.y && p1.y < p4.y) || (p2.y > p3.y && p2.y > p4.y))\n                    return false;\n                else\n                    if ((p2.y < p3.y && p2.y < p4.y) || (p1.y > p3.y && p1.y > p4.y))\n                        return false;\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td > 0 || ta * tb > 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1 ;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * (b.y) + a.y * (-b.x);\n            long td = a.x * (c.y) + a.y * (-c.x);\n            if (tc * td < 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main()\n\t{\n    long q = long.Parse(Console.ReadLine());\n    for(long i = 0; i < q; i++)\n    {\n      bool answer = false;\n\t\t  string[] input = Console.ReadLine().Split(' ');\n      Vector2 vecA = new Vector2(decimal.Parse(input[0]), decimal.Parse(input[1]));//受け取った入力をdecimalに変換\n      Vector2 vecB = new Vector2(decimal.Parse(input[2]), decimal.Parse(input[3]));\n      Vector2 vecAsub = new Vector2(decimal.Parse(input[4]), decimal.Parse(input[5]));\n      Vector2 vecBsub = new Vector2(decimal.Parse(input[6]), decimal.Parse(input[7]));\n\n      if(Vector2.WhereVector(vecA, vecB, vecAsub) + Vector2.WhereVector(vecA, vecB, vecBsub) == 3\n        && Vector2.WhereVector(vecAsub, vecBsub, vecA) + Vector2.WhereVector(vecAsub, vecBsub, vecB) == 3)\n          answer = true;\n      if(Vector2.WhereVector(vecA, vecB, vecAsub) == 5 || Vector2.WhereVector(vecA, vecB, vecBsub) == 5\n        || Vector2.WhereVector(vecAsub, vecBsub, vecA) == 5 || Vector2.WhereVector(vecAsub, vecBsub, vecB) == 5)\n          answer = true;\n      Console.WriteLine((answer) ? \"1\" : \"0\");\n    }\n\n\t}\n}\n\nclass Vector2//2次元ベクトル\n{\nstatic decimal EPS = 1e-10m;//小数誤差比較\n\n  public Vector2 (decimal X, decimal Y)\n  {\n    this.x = X;\n    this.y = Y;\n  }\n\n  public decimal x {private set; get;}\n  public decimal y {private set; get;}\n\n  public static Vector2 operator + (Vector2 ob1, Vector2 ob2)//ベクトルの基本演算\n  {\n    return new Vector2 (ob1.x + ob2.x, ob1.y + ob2.y);\n  }\n  public static Vector2 operator - (Vector2 ob1, Vector2 ob2)\n  {\n    return new Vector2 (ob1.x - ob2.x, ob1.y - ob2.y);\n  }\n  public static Vector2 operator * (Vector2 ob, decimal scalar)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n  public static Vector2 operator * (decimal scalar, Vector2 ob)\n  {\n    return new Vector2 (ob.x * scalar, ob.y * scalar);\n  }\n\n  public decimal Length()//ベクトルの長さ\n  {\n    return x * x + y * y;\n  }\n  public static decimal DotProduct(Vector2 ob1, Vector2 ob2)//内積\n  {\n    return ob1.x * ob2.x + ob1.y * ob2.y;\n  }\n  public static decimal CrossProduct(Vector2 ob1, Vector2 ob2)//外積。第2引数が反時計回り側で正。\n  {\n    return ob1.x * ob2.y - ob1.y * ob2.x;\n  }\n\n  public static Vector2 Projection(Vector2 beginPoint, Vector2 endPoint, Vector2 point)//点の射影\n  {\n    Vector2 segment = endPoint - beginPoint;\n    decimal ratio = Vector2.DotProduct(point - beginPoint, segment) / segment.Length();\n    return beginPoint + segment * ratio;//始点にたす\n  }\n\npublic static long WhereVector(Vector2 beginPoint, Vector2 endPoint, Vector2 point)\n  {//ベクトルに対する点の位置\n    Vector2 segment = endPoint - beginPoint;\n    Vector2 aimVec = point - beginPoint;\n    if(Vector2.CrossProduct(segment, aimVec) > EPS)\n      return 1;//反時計回り側\n    else if(Vector2.CrossProduct(segment, aimVec) < -EPS)\n      return 2;//時計回り側\n    else if(Vector2.DotProduct(segment, aimVec) < -1+EPS)\n      return 3;//ベクトル反対向きの側\n    else if(segment.Length() < aimVec.Length())\n      return 4;//ベクトル向きの側\n    else\n      return 5;//ベクトル上\n  }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\n\nnamespace AOJ\n{\n    using Vector = Point;\n    using Line = Segment;\n    using Polygon = List<Point>;\n\n    class Consts\n    {\n        public static readonly double EPS = 1e-10;\n    }\n    class Point\n    {\n        double x, y;\n        public double X { get { return this.x; } set { this.x = value; } }\n        public double Y { get { return this.y; } set { this.y = value; } }\n        public Point(double x = 0, double y = 0)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        static public Point operator +(Point p1, Point p2) => new Point(p1.x + p2.x, p1.y + p2.y);\n        static public Point operator -(Point p1, Point p2) => new Point(p1.x - p2.x, p1.y - p2.y);\n        static public Point operator *(Point p, double a) => new Point(a * p.x, a * p.y);\n        static public Point operator *(double a, Point p) => p * a;\n        static public Point operator /(Point p, double a) => new Point(p.x / a, p.y / a);\n        static public bool operator <(Point p1, Point p2) => p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y;\n        static public bool operator >(Point p1, Point p2) => p2 < p1;\n\n        static public bool operator ==(Point p1, Point p2) => (p1.x - p2.x) < Consts.EPS && (p1.y - p2.y) < Consts.EPS;\n        static public bool operator !=(Point p1, Point p2) => !(p1 == p2);\n\n        public double abs() => Math.Abs(norm());\n        public double norm() => this.x * this.x + this.y * this.y;\n        public double euclideannorm() => Math.Sqrt(norm());//ユークリッド距離\n\n        public override bool Equals(object obj)\n        {\n            if ((object)obj == null || this.GetType() != obj.GetType())\n            {\n                return false;\n            }\n            var c = (Point)obj;\n            return this == c;\n        }\n        public override int GetHashCode()\n        {\n            return this.x.GetHashCode() ^ this.y.GetHashCode();\n        }\n    }\n    struct Segment\n    {\n        public Point p1, p2;\n    }\n    class Circle\n    {\n        public Point c;\n        public double r;\n        public Circle(Point c, double r)\n        {\n            this.c = c;\n            this.r = r;\n        }\n    }\n\n    class VecCalc\n    {\n        static bool equals(double a, double b) => Math.Abs(a - b) < Consts.EPS;\n        //内積\n        static public double dot(Vector a, Vector b)\n        {\n            return a.X * b.X + a.Y * b.Y;\n        }\n        //外積\n        static public double cross(Vector a, Vector b)\n        {\n            return a.X * b.Y - a.Y * b.X;\n        }\n        //16.2 直行判定\n        static public bool isOrthogonal(Vector a, Vector b)\n        {\n            return equals(dot(a, b), 0.0);\n        }\n        static public bool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isOrthogonal(a1 - a2, b1 - b2);\n        }\n        static public bool isOrthogonal(Segment s1, Segment s2)\n        {\n            return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.2 平行判定\n        static public bool isParallel(Vector a, Vector b)\n        {\n            return equals(cross(a, b), 0.0);\n        }\n        static public bool isParallel(Point a1, Point a2, Point b1, Point b2)\n        {\n            return isParallel(a1 - a2, b1 - b2);\n        }\n        static public bool isParallel(Segment s1, Segment s2)\n        {\n            return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n        }\n        //16.3 射影\n        static public Point project(Segment s, Point p)\n        {\n            Vector b = s.p2 - s.p1;\n            double r = dot(p - s.p1, b) / b.norm();\n            return s.p1 + b * r;\n        }\n        //16.4 反射\n        static public Point reflection(Segment s, Point p)\n        {\n            return 2 * project(s, p) - p;\n            //mid = project(s, p) - p;\n            //return mid + mid - p;\n        }\n        //16.5 距離\n        //2点間の距離\n        static public double getDistance(Point a, Point b)\n        {\n            return (a - b).abs();\n        }\n        //直線lと点pの距離\n        static public double getDistanceLP(Line l,Point p)\n        {\n            return Math.Abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n        }\n        //線分sと点pの距離\n        static public double getDistanceSP(Segment s, Point p)\n        {\n            if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n            if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n            return getDistanceLP(s, p);\n        }\n        static public double getDistance(Segment s1, Segment s2)\n        {\n            if (false) return 0.0;\n            return Math.Min(\n                    Math.Min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n                    Math.Min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n                );\n        }\n        //16.6 反時計回り\n        static public readonly int COUNTER_CLOCKWISE=1;\n        static public readonly int CLOCKWISE = -1;\n        static public readonly int ONLINE_BACK = 2;\n        static public readonly int ONLINE_FRONT = -2;\n        static public readonly int ON_SEGMENT = 0;\n        static public int ccw(Point p0, Point p1, Point p2)\n        {\n            Vector a = p1 - p0;\n            Vector b = p2 - p0;\n            var dot_ = dot(a, b);\n            var cross_ = cross(a, b);\n            if (Consts.EPS < cross_) return COUNTER_CLOCKWISE;\n            if (cross_ < -Consts.EPS) return CLOCKWISE;\n            if (dot_ < -Consts.EPS) return ONLINE_BACK;\n            if (a.norm() < b.norm()) return ONLINE_FRONT;\n            return ON_SEGMENT;\n        }\n        static public int ccw(Segment s, Point p)\n        {\n            return ccw(s.p1, s.p2, p);\n\n        }\n        //16.7 線分の交差判定\n        static public bool intersect(Point p1, Point p2,Point p3,Point p4)\n        {\n            return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n                ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n                );\n        }\n        static public bool intersect(Segment s1, Segment s2)\n        {\n            return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n        }\n    }\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n\n        static void Main(string[] args)\n        {\n            var Q = Sarray()[0];\n            for (var i = 0; i < Q; ++i)\n            {\n                var p0123 = Sarray();\n                var p0 = new Point(p0123[0], p0123[1]);\n                var p1 = new Point(p0123[2], p0123[3]);\n                var p2 = new Point(p0123[4], p0123[5]);\n                var p3 = new Point(p0123[6], p0123[7]);\n\n                if (VecCalc.intersect(p0, p1, p2, p3))\n                    WriteLine(1);\n                else\n                    WriteLine(0);\n                //WriteLine($\"{ans.X} {ans.Y}\");\n\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1 ;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x); \n            if (tc * td <= 0 && ta * tb <= 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nclass B\n{\n\tstatic int[] Read() => Console.ReadLine().Split().Select(int.Parse).ToArray();\n\tstatic void Main() => Console.WriteLine(string.Join(\"\\n\", new int[int.Parse(Console.ReadLine())].Select(_ => Solve())));\n\n\tstatic long Solve()\n\t{\n\t\tvar h = Read();\n\t\tV p0 = new V(h[0], h[1]), p1 = new V(h[2], h[3]), p2 = new V(h[4], h[5]), p3 = new V(h[6], h[7]);\n\t\tV s1 = p1 - p0, s2 = p3 - p2;\n\n\t\tFunc<V, V, V, int> sign = (q0, q1, p) => Math.Sign((p.X - q0.X) * (q1.Y - q0.Y) - (q1.X - q0.X) * (p.Y - q0.Y));\n\t\tvar d1 = sign(p0, p1, p2) * sign(p0, p1, p3);\n\t\tvar d2 = sign(p2, p3, p0) * sign(p2, p3, p1);\n\n\t\tif (V.IsParallel(s1, s2))\n\t\t{\n\t\t\t// 同一直線上にない\n\t\t\tif (d1 != 0) return 0;\n\n\t\t\tif (p0.X == p1.X && p0.X == p2.X)\n\t\t\t{\n\t\t\t\t// y 軸に平行\n\t\t\t\tint m1 = Math.Min(p0.Y, p1.Y), M1 = Math.Max(p0.Y, p1.Y);\n\t\t\t\tint m2 = Math.Min(p2.Y, p3.Y), M2 = Math.Max(p2.Y, p3.Y);\n\t\t\t\treturn (m1 < m2 ? m2 <= M1 : m1 <= M2) ? 1 : 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint m1 = Math.Min(p0.X, p1.X), M1 = Math.Max(p0.X, p1.X);\n\t\t\t\tint m2 = Math.Min(p2.X, p3.X), M2 = Math.Max(p2.X, p3.X);\n\t\t\t\treturn (m1 < m2 ? m2 <= M1 : m1 <= M2) ? 1 : 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn d1 <= 0 && d2 <= 0 ? 1 : 0;\n\t\t}\n\t}\n}\n\nstruct V\n{\n\tpublic int X, Y;\n\tpublic V(int x, int y) { X = x; Y = y; }\n\n\tpublic static V operator -(V v) => new V(-v.X, -v.Y);\n\tpublic static V operator +(V v1, V v2) => new V(v1.X + v2.X, v1.Y + v2.Y);\n\tpublic static V operator -(V v1, V v2) => new V(v1.X - v2.X, v1.Y - v2.Y);\n\n\tpublic static bool IsParallel(V v1, V v2) => v1.X * v2.Y == v2.X * v1.Y;\n\tpublic static bool IsOrthogonal(V v1, V v2) => v1.X * v2.X == -v1.Y * v2.Y;\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int NQ = Reader.Int();\n\n        for (int q = 0; q < NQ; q++)\n        {\n            var a = new Point(Reader.Int(), Reader.Int());\n            var b = new Point(Reader.Int(), Reader.Int());\n            var c = new Point(Reader.Int(), Reader.Int());\n            var d = new Point(Reader.Int(), Reader.Int());\n            var seg1 = new Segment(a, b);\n            var seg2 = new Segment(c, d);\n            Console.WriteLine(SegmentIntersect(seg1, seg2) ? 1 : 0);\n        }\n        Console.ReadLine();\n    }\n\n    bool SegmentIntersect(Segment seg1, Segment seg2)\n    {\n        var c1 = (seg1.B - seg1.A).Det(seg2.A - seg1.A);\n        if (c1 == 0 && (seg1.A - seg2.A).Dot(seg1.B - seg2.A) <= 0) return true;\n        var c2 = (seg1.B - seg1.A).Det(seg2.B - seg1.A);\n        if (c2 == 0 && (seg1.A - seg2.B).Dot(seg1.B - seg2.B) <= 0) return true;\n        var c3 = (seg2.B - seg2.A).Det(seg1.A - seg2.A);\n        if (c3 == 0 && (seg2.A - seg1.A).Dot(seg2.B - seg1.A) <= 0) return true;\n        var c4 = (seg2.B - seg2.A).Det(seg1.B - seg2.A);\n        if (c4 == 0 && (seg2.A - seg1.B).Dot(seg2.B - seg1.B) <= 0) return true;\n        return c1 * c2 < 0 && c3 * c4 < 0;\n    }\n\n    public class Segment\n    {\n        public Point A, B;\n        public Segment(Point a, Point b) { A = a; B = b; }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(Point p, double d)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \", \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\nnamespace CGL_2_B_Intersection\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\tint inputCount = int.Parse (Console.ReadLine ());\n\t\t\tStringBuilder output = new StringBuilder (inputCount * 2);\n\n\t\t\tfor (int lp = 0; lp < inputCount; lp++)\n\t\t\t{\n\t\t\t\tint[] inputNum = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\n\t\t\t\tVector2 point1 = new Vector2 (inputNum[0], inputNum[1]);\n\t\t\t\tVector2 point2 = new Vector2 (inputNum[2], inputNum[3]);\n\t\t\t\tVector2 point3 = new Vector2 (inputNum[4], inputNum[5]);\n\t\t\t\tVector2 point4 = new Vector2 (inputNum[6], inputNum[7]);\n\n\t\t\t\tif (Vector2.Intersection (point1, point2, point3, point4))\n\t\t\t\t{\n\t\t\t\t\toutput.AppendLine (\"1\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toutput.AppendLine (\"0\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tConsole.Write (output);\n\t\t}\n\t}\n\n\tclass Vector2\n\t{\n\t\tpublic Vector2 ( decimal x, decimal y )\n\t\t{\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t}\n\n\t\tpublic decimal X { private set; get; }\n\t\tpublic decimal Y { private set; get; }\n\n\t\tpublic static Vector2 operator + ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X + ob2.X, ob1.Y + ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator - ( Vector2 ob1, Vector2 ob2 )\n\t\t{\n\t\t\treturn new Vector2 (ob1.X - ob2.X, ob1.Y - ob2.Y);\n\t\t}\n\t\tpublic static Vector2 operator * ( Vector2 ob, decimal scalar )\n\t\t{\n\t\t\treturn new Vector2 (ob.X * scalar, ob.Y * scalar);\n\t\t}\n\n\t\tpublic decimal Length ()\n\t\t{\n\t\t\treturn X * X + Y * Y;\n\t\t}\n\n\t\tpublic static decimal DotProduct ( Vector2 line1, Vector2 line2 )\n\t\t{\n\t\t\treturn line1.X * line2.X + line1.Y * line2.Y;\n\t\t}\n\t\tpublic static decimal CrossProduct ( Vector2 line1, Vector2 line2 )\n\t\t{\n\t\t\treturn line1.X * line2.Y - line1.Y * line2.X;\n\t\t}\n\n\t\tpublic const int Counter_Clockwise = 1;\n\t\tpublic const int Clockwise = -1;\n\t\tpublic const int OnlineBack = 2;\n\t\tpublic const int OnlineFront = -2;\n\t\tpublic const int OnSegment = 0;\n\n\t\tpublic static int PointState ( Vector2 point1, Vector2 point2, Vector2 point3 )\n\t\t{\n\t\t\tVector2 line1 = point2 - point1;\n\t\t\tVector2 line2 = point3 - point1;\n\n\t\t\tdecimal crossProduct = CrossProduct (line1, line2);\n\n\t\t\tif (crossProduct > 0m)\n\t\t\t{\n\t\t\t\treturn Counter_Clockwise;\n\t\t\t}\n\t\t\telse if (crossProduct < 0m)\n\t\t\t{\n\t\t\t\treturn Clockwise;\n\t\t\t}\n\t\t\telse if (DotProduct (line1, line2) < 0m)\n\t\t\t{\n\t\t\t\treturn OnlineBack;\n\t\t\t}\n\t\t\telse if (line1.Length () < line2.Length ())\n\t\t\t{\n\t\t\t\treturn OnlineFront;\n\t\t\t}\n\n\t\t\treturn OnSegment;\n\t\t}\n\n\t\tpublic static bool Intersection ( Vector2 line1Point1, Vector2 line1Point2, Vector2 line2Point1, Vector2 line2Point2 )\n\t\t{\n\t\t\tVector2 p1 = line1Point1;\n\t\t\tVector2 p2 = line1Point2;\n\t\t\tVector2 p3 = line2Point1;\n\t\t\tVector2 p4 = line2Point2;\n\n\t\t\treturn (PointState (p1, p2, p3) * PointState (p1, p2, p4) <= 0 &&\n\t\t\t\tPointState (p3, p4, p1) * PointState (p3, p4, p2) <= 0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace geometry\n{\n\tpublic class Point{\n\t\tpublic double x, y;\n\t\tpublic Point(){\n\t\t\tthis.x = this.y = 0;\n\t\t}\n\n\t\tpublic Point(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic static Point operator+(Point p1, Point p2){\n\t\t\treturn new Point (p1.x + p2.x, p1.y + p2.y);\n\t\t}\n\n\t\tpublic static Point operator-(Point p1, Point p2){\n\t\t\treturn new Point (p1.x - p2.x, p1.y - p2.y);\n\t\t}\n\n\t\tpublic static Point operator*(Point p1, double a){\n\t\t\treturn new Point (p1.x * a, p1.y * a);\n\t\t}\n\n\t\tpublic static Point operator/(Point p1, double a){\n\t\t\treturn new Point (p1.x / a, p1.y / a);\n\t\t}\n\n\t\tpublic double norm(){\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\t}\n\n\t\tpublic double abs(){\n\t\t\treturn Math.Sqrt(norm()); \n\t\t}\n\n\t\tpublic Point Clone(){\n\t\t\tPoint clone = new Point (this.x, this.y);\n\t\t\treturn clone;\n\t\t}\n\t}\n\n\tpublic class Line{\n\t\tpublic Point p1, p2;\n\t\tpublic Line(){\n\t\t\tthis.p1 = new Point ();\n\t\t\tthis.p2 = new Point ();\n\t\t}\n\n\t\tpublic Line(double p1x, double p1y, double p2x, double p2y){\n\t\t\tthis.p1 = new Point(p1x, p1y);\n\t\t\tthis.p2 = new Point(p2x, p2y);\n\t\t}\n\n\t\tpublic Line(Point p1, Point p2){\n\t\t\tthis.p1 = p1.Clone();\n\t\t\tthis.p2 = p2.Clone();\n\t\t}\n\n\t\tpublic Line Clone(){\n\t\t\tLine clone = new Line (this.p1, this.p2);\n\t\t\treturn clone;\n\t\t}\n\t}\n\n\tpublic class Circle{\n\t\tpublic Point c;\n\t\tpublic double r;\n\t\tpublic Circle(){\n\t\t\tthis.c = new Point ();\n\t\t\tthis.r = 0.0;\n\t\t}\n\n\t\tpublic Circle(double cx, double cy, double r){\n\t\t\tthis.c.x = cx;\n\t\t\tthis.c.y = cy;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic Circle(Point c, double r){\n\t\t\tthis.c = c.Clone();\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic Circle Clone(){\n\t\t\tCircle clone = new Circle (this.c, this.r);\n\t\t\treturn clone;\n\t\t}\n\t}\n\n\tclass MainClass{\n\t\tstatic bool is_equal(double a, double b){\n\t\t\tif (Math.Abs (a - b) < 0.000001) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tstatic double dot(Point v1, Point v2){\n\t\t\treturn v1.x * v2.x + v1.y * v2.y;\n\t\t}\n\n\t\tstatic double cross(Point v1, Point v2){\n\t\t\treturn v1.x * v2.y - v1.y * v2.x;\n\t\t}\n\n\t\t// ??´?????????\n\t\tstatic bool is_orthogonal(Line s1, Line s2){\n\t\t\treturn is_equal(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n\t\t}\n\n\t\t// ????????????\n\t\tstatic bool is_parallel(Line s1, Line s2){\n\t\t\treturn is_equal(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n\t\t}\n\n\t\t// ????????????\n\t\tstatic bool is_intersect(Line s1, Line s2){\n\t\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 && ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t\t}\n\n\t\t// ?°???±??¢??°\n\t\tstatic Point project(Line s, Point p){\n\t\t\tPoint base_v = s.p2 - s.p1;\n\t\t\tdouble r = dot (p - s.p1, base_v) / base_v.norm ();\n\t\t\treturn s.p1 + base_v * r;\n\t\t}\n\n\t\t// ????°???¢??°\n\t\tstatic Point reflect(Line s, Point p){\n\t\t\treturn p + (project(s, p) - p) * 2;\n\t\t}\n\n\t\t// ???????¨???????\n\t\tstatic int ccw(Point p0, Point p1, Point p2){\n\t\t\tPoint v1 = p1 - p0;\n\t\t\tPoint v2 = p2 - p0;\n\t\t\tif (cross (v1, v2) > 0.000001) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (cross (v1, v2) < -0.000001) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (dot (v1, v2) < -0.000001) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tif (v1.norm() < v2.norm()) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tstatic double get_distance_p2p(Point p1, Point p2){\n\t\t\treturn (p2 - p1).abs();\n\t\t}\n\n\t\tstatic double get_distance_l2p(Line l, Point p){\n\t\t\treturn Math.Abs (cross (l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs ();\n\t\t}\n\n\t\tstatic double get_distance_s2p(Line s, Point p){\n\t\t\tif (dot (s.p2 - s.p1, p - s.p1) < 0.0) {\n\t\t\t\treturn (p - s.p1).abs ();\n\t\t\t} else if (dot (s.p1 - s.p2, p - s.p2) < 0.0) {\n\t\t\t\treturn (p - s.p2).abs ();\n\t\t\t}\n\t\t\treturn get_distance_l2p (s, p);\n\t\t}\n\n\t\tstatic double[] input_line(){\n\t\t\tstring[] s = Console.ReadLine().Split(' ');\n\t\t\tdouble[] d = s.Select(i => double.Parse(i)).ToArray();\n\t\t\treturn d;\n\t\t}\n\n\t\t// ?°???±\n\t\tstatic void CGL_1_A(){\n\t\t\tdouble[] d = input_line ();\n\t\t\tLine l = new Line(d[0], d[1], d[2], d[3]);\n\n\t\t\tint q = int.Parse(Console.ReadLine());\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tdouble[] p_pos = input_line ();\n\t\t\t\tPoint p1 = new Point (p_pos[0], p_pos[1]);\n\t\t\t\tPoint p2 = project (l, p1);\n\t\t\t\tConsole.WriteLine (\"{0} {1}\", p2.x, p2.y);\n\t\t\t}\n\t\t}\n\n\t\t// ????°?\n\t\tstatic void CGL_1_B(){\n\t\t\tdouble[] d = input_line ();\n\t\t\tLine l = new Line(d[0], d[1], d[2], d[3]);\n\n\t\t\tint q = int.Parse(Console.ReadLine());\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tdouble[] p_pos = input_line ();\n\t\t\t\tPoint p1 = new Point (p_pos [0], p_pos [1]);\n\t\t\t\tPoint p2 = reflect (l, p1);\n\t\t\t\tConsole.WriteLine (\"{0} {1}\", p2.x, p2.y);\n\t\t\t}\n\t\t}\n\n\t\t// ??´????????´???/????????????\n\t\tstatic void CGL_2_A(){\n\t\t\tint q = int.Parse(Console.ReadLine());\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tdouble[] s_pos = input_line ();\n\t\t\t\tLine s1 = new Line(s_pos[0], s_pos[1], s_pos[2], s_pos[3]);\n\t\t\t\tLine s2 = new Line(s_pos[4], s_pos[5], s_pos[6], s_pos[7]);\n\t\t\t\tif (is_parallel (s1, s2)) {\n\t\t\t\t\tConsole.Write (\"2\\n\");\n\t\t\t\t} else if (is_orthogonal (s1, s2)) {\n\t\t\t\t\tConsole.Write (\"1\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tConsole.Write (\"0\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ?????????????????????\n\t\tstatic void CGL_2_B(){\n\t\t\tint q = int.Parse(Console.ReadLine());\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tdouble[] s_pos = input_line ();\n\t\t\t\tLine s1 = new Line(s_pos[0], s_pos[1], s_pos[2], s_pos[3]);\n\t\t\t\tLine s2 = new Line(s_pos[4], s_pos[5], s_pos[6], s_pos[7]);\n\n\t\t\t\tif (is_intersect (s1, s2)) {\n\t\t\t\t\tConsole.Write (\"1\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tConsole.Write (\"0\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static void Main (string[] args){\n\t\t\t// ?°???±\n\t\t\t//CGL_1_A ();\n\t\t\t// ????°?\n\t\t\t//CGL_1_B ();\n\t\t\t// ??´????????´???/????????????\n\t\t\t//CGL_2_A ();\n\t\t\t// ?????????????????????\n\t\t\tCGL_2_B ();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td <= 0 && ta * tb <= 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1 ;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x); \n            if (tc * td < 0 && ta * tb < 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            if (p1.x >= p2.x)\n                if ((p1.x < p3.x && p1.x < p4.x) || (p2.x > p3.x && p2.x > p4.x))\n                    return false;\n                else\n                    if ((p2.x < p3.x && p2.x < p4.x) || (p1.x > p3.x && p1.x > p4.x))\n                        return false;\n            if (p1.y >= p2.y)\n                if ((p1.y < p3.y && p1.y < p4.y) || (p2.y > p3.y && p2.y > p4.y))\n                    return false;\n                else\n                    if ((p2.y < p3.y && p2.y < p4.y) || (p1.y > p3.y && p1.y > p4.y))\n                        return false;\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td > 0 || ta * tb > 0) return false;\n            return true;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush=\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ' '));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\tvar Q = cin.ReadInt;\n\t\t\tfor(int j = 0; j<Q; j++) {\n\t\t\t\tvar d = cin.ReadIntArray(8);\n\t\t\t\tvar ps = new P2[4];\n\t\t\t\tfor(int k = 0; k<4; k++) {\n\t\t\t\t\tps[k]=new P2(d[2*k], d[2*k+1]);\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(isIntersect(ps[0], ps[1], ps[2], ps[3]) ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tpublic struct P2 {\n\t\t\tpublic decimal x { get; set; }\n\t\t\tpublic decimal y { get; set; }\n\t\t\tpublic P2(decimal xx, decimal yy) { x=xx; y=yy; }\n\t\t\tpublic static P2 operator +(P2 a, V2 b) => new P2(a.x+b.x, a.y+b.y);\n\t\t\tpublic static V2 operator -(P2 a, P2 b) => new V2(a.x-b.x, a.y-b.y);\n\t\t\tpublic decimal Abs2() => x*x+y*y;\n\t\t\tpublic override string ToString() => $\"({x}, {y})\";\n\t\t}\n\t\tpublic struct V2 {\n\t\t\tpublic decimal x { get; set; }\n\t\t\tpublic decimal y { get; set; }\n\t\t\tpublic V2(decimal xx, decimal yy) { x=xx; y=yy; }\n\t\t\tpublic static V2 operator -(V2 a, V2 b) => new V2(a.x-b.x, a.y-b.y);\n\t\t\tpublic static V2 operator +(V2 a, V2 b) => new V2(a.x+b.x, a.y+b.y);\n\t\t\tpublic static V2 operator *(V2 a, decimal k) => new V2(a.x*k, a.y*k);\n\t\t\tpublic static decimal outer(V2 a, V2 b) => a.x*b.y-b.x*a.y;\n\t\t\tpublic static decimal inner(V2 a, V2 b) => a.x*b.x+a.y*b.y;\n\t\t\tpublic decimal Abs2() => x*x+y*y;\n\t\t\tpublic override string ToString() => $\"({x}, {y})\";\n\t\t}\n\t\tstatic public bool isIntersect(P2 a1, P2 a2, P2 b1, P2 b2) {\n\t\t\tvar parallel = V2.outer(a2-a1, b2-b1)==0m;\n\t\t\tif(parallel) {\n\t\t\t\tvar willIntersect = V2.outer(a2-a1, b1-a1)==0m;\n\t\t\t\tif(!willIntersect) return false;\n\t\t\t\tvar k1 = V2.inner(b1-a1, b1-a2);\n\t\t\t\tvar k2 = V2.inner(b2-a1, b2-a2);\n\t\t\t\tif(k1<=0||k2<=0) return true;\n\t\t\t\tvar l1 = V2.inner(a1-b1, a1-b2);\n\t\t\t\tvar l2 = V2.inner(a2-b1, a2-b2);\n\t\t\t\treturn l1<=0||l2<=0;\n\t\t\t} else\n\t\t\t\treturn V2.outer(b1-a1, a2-a1)*V2.outer(b2-a2, a1-a2)>=0\n\t\t\t\t&&V2.outer(a1-b1, b2-b1)*V2.outer(a2-b2, b1-b2)>=0;\n\t\t}\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static void Swap<T>(this T[] A, int x, int y) {\n\t\t\tvar tmp = A[x];\n\t\t\tA[x]=A[y];\n\t\t\tA[y]=tmp;\n\t\t}\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[] X) => Enumerable.Range(0, X.Length);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[,] X, int dim)\n\t\t\t=> Enumerable.Range(0, X.GetLength(dim));\n\t\tpublic static string Join<T>(this T[,] X, string separatorD2 = \",\", string separatorD1 = \"\\n\")\n\t\t\t=> X.Indices(0).Select(\n\t\t\t\ti => X.Indices(1).Select(j => X[i, j]).Join(separatorD2)\n\t\t\t).Join(separatorD1);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator=separator;\n\t\t\tthis._stream=stream;\n\t\t\tinputStream=new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count!=0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i<tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i<N; ++i)\n\t\t\t\tret[i]=Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i<N; ++i) ret[i]=ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i<N; ++i) ret[i]=ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i<N; ++i) ret[i]=ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek()==-1; }\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td < 0 && ta * tb < 0) return true;\n            if (ta == 0 && Math.Min(p3.x, p4.x) <= p1.x && p1.x <= Math.Max(p3.x, p4.y))\n                return true;\n            if (tb == 0 && Math.Min(p3.x, p4.x) <= p2.x && p2.x <= Math.Max(p3.x, p4.y))\n                return true;\n            if (tc == 0 && Math.Min(p1.x, p2.x) <= p3.x && p3.x <= Math.Max(p1.x, p2.y))\n                return true;\n            if (tb == 0 && Math.Min(p1.x, p2.x) <= p4.x && p4.x <= Math.Max(p1.x, p2.y))\n                return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            int q = int.Parse(Console.ReadLine());\n\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < q; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Pt a = new Pt(input[0], input[1]);\n                Pt b = new Pt(input[2], input[3]);\n                Pt c = new Pt(input[4], input[5]);\n                Pt d = new Pt(input[6], input[7]);\n\n                sb.AppendLine(IsIntersect(a, b, c, d) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsIntersect(Pt p1,Pt p2,Pt p3,Pt p4)\n        {\n            return CCW(p1, p2, p3) * CCW(p1, p2, p4) <= 0 &&\n                   CCW(p3, p4, p1) * CCW(p3, p4, p2) <= 0;\n        }\n\n        static int CCW(Pt p0, Pt p1, Pt p2)\n        {\n            Pt a = p1 - p0, b = p2 - p0;\n\n            if (a.Cross(b) > EPS) return 1;\n            if (a.Cross(b) < -EPS) return -1;\n            return 0;\n        }\n    }\n\n    class Pt : IComparable<Pt>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Pt(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Pt p) { return x * p.x + y * p.y; }\n        public double Cross(Pt p) { return x * p.y - y * p.x; }\n\n        public static Pt operator +(Pt a, Pt b) { return new Pt(a.x + b.x, a.y + b.y); }\n        public static Pt operator -(Pt a, Pt b) { return new Pt(a.x - b.x, a.y - b.y); }\n        public static Pt operator *(Pt p, double d) { return new Pt(p.x * d, p.y * d); }\n        public static Pt operator /(Pt p, double d) { return new Pt(p.x / d, p.y / d); }\n        public static bool operator <(Pt a, Pt b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Pt a, Pt b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Pt a, Pt b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Pt a, Pt b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Pt other)\n        {\n            return x != other.x ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Pt other = (Pt)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class Seg\n    {\n        internal Pt p1, p2;\n\n        public Seg(Pt a, Pt b)\n        {\n            p1 = a;\n            p2 = b;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2????????????????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        ///  ?????´?????????3????????¨????????´??????????????????????????????????????¨????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * b.y + a.y * (-b.x);\n            long td = a.x * c.y + a.y * (-c.x);\n            Point d = p3 - p4;\n            Point e = p1 - p3;\n            Point f = p2 - p3;\n            long ta = d.x * e.y + d.y * (-e.x);\n            long tb = d.x * f.y + d.y * (-f.x);\n            if (tc * td < 0 && ta * tb < 0) return true;\n            if (ta == 0 //???p1???p3p4?????´??????????????£?????????????????£?????????p2?????´???\n                && Math.Min(p3.x, p4.x) <= p1.x && p1.x <= Math.Max(p3.x, p4.x)\n                && Math.Min(p3.y, p4.y) <= p1.y && p1.y <= Math.Max(p3.y, p4.y)\n                )\n                return true;\n            if (tb == 0 \n                && Math.Min(p3.x, p4.x) <= p2.x && p2.x <= Math.Max(p3.x, p4.x)\n                && Math.Min(p3.y, p4.y) <= p2.y && p2.y <= Math.Max(p3.y, p4.y)\n                )\n                return true;\n            if (tc == 0  //???p3???p1p2?????´??????????????£?????????????????£?????????p4?????´???\n                && Math.Min(p1.x, p2.x) <= p3.x && p3.x <= Math.Max(p1.x, p2.x)\n                && Math.Min(p1.y, p2.y) <= p3.y && p3.y <= Math.Max(p1.y, p2.y)\n                )\n                return true;\n            if (tb == 0\n                && Math.Min(p1.x, p2.x) <= p4.x && p4.x <= Math.Max(p1.x, p2.x)\n                && Math.Min(p1.y, p2.y) <= p4.y && p4.y <= Math.Max(p1.y, p2.y))\n                return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#region ZIPPER\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Linq;\nusing System.Text;\nusing sc = Scanner;\nusing Geometry;\nusing gl = Geometry.GeometryLibrary;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solver solver = new Solver();\n        solver.Solve();\n#if DEBUG\n        System.Console.WriteLine(\"?¶?????????????????????????????????????????????????????????????\");\n        System.Console.ReadKey();\n#endif\n\n    }\n}\n/// <summary>\n/// ?¨??????\\????????????????????´???????????????????????????????????????\n/// </summary>\npublic static class Scanner\n{\n    public static string NextString()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return tmp;\n    }\n    public static int NextInt()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return int.Parse(tmp);\n    }\n    public static long NextLong()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return long.Parse(tmp);\n    }\n    public static double NextDouble()\n    {\n        string tmp = \"\";\n        while (true)\n        {\n            int readData;\n            string data;\n            readData = Console.Read();\n            if (readData == -1) //EOF\n            {\n                break;\n            }\n            data = char.ConvertFromUtf32(readData);\n            if (data == \" \" || data == \"\\n\")\n            {\n                break;\n            }\n            tmp += data;\n        }\n        return double.Parse(tmp);\n    }\n\n    public static string[] NextStrArray()\n    {\n        return Console.ReadLine().Split(' ');\n    }\n    public static int[] NextIntArray()\n    {\n\n        string[] s = NextStrArray();\n        int[] a = new int[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = int.Parse(s[i]);\n        }\n        return a;\n    }\n    public static long[] NextLongArray()\n    {\n        string[] s = NextStrArray();\n        long[] a = new long[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = long.Parse(s[i]);\n        }\n        return a;\n    }\n    public static double[] NextDoubleArray()\n    {\n        string[] s = NextStrArray();\n        double[] a = new double[s.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            a[i] = double.Parse(s[i]);\n        }\n        return a;\n    }\n}\n#endregion ZIPPER\n\npublic class Solver\n{\n#region IGNORE_ME\n    public Solver()\n    {\n        //???????????¨?????????????????????????????????????????????\n    }\n#endregion IGNORE_ME\n\n    public void Solve()\n    {\n        int q = sc.NextInt();\n        Point[] p = new Point[4*q];\n        for (int i = 0; i < 4*q; i++)\n        {\n            p[i] = new Point(sc.NextInt(), sc.NextInt());\n        }\n        for (int i = 0; i < q; i++)\n        {\n            int s = 4*i;\n            if (gl.DoesIntersect(p[s], p[s + 1], p[s + 2], p[s + 3]))\n            {\n                Console.WriteLine(\"1\");\n            }\n            else\n                Console.WriteLine(\"0\");\n        }\n#if DEBUG\n        Console.WriteLine(\"\");//local check\n#endif\n    }\n}\nnamespace Geometry\n{\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(double???)\n    /// </summary>\n    public struct dPoint\n    {\n        public double x;\n        public double y;\n        public dPoint(int x, int y)\n        {\n            this.x = (double)x; this.y = (double)y;\n        }\n        public dPoint(double x, double y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static dPoint operator +(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static dPoint operator -(dPoint p1, dPoint p2)\n        {\n            return new dPoint(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static dPoint operator *(double s, dPoint p)\n        {\n            return new dPoint(s * p.x, s * p.y);\n        }\n    }\n    /// <summary>\n    /// ??????x,y??§?¨??????¨???(int???)\n    /// </summary>\n    public struct Point\n    {\n        public int x;\n        public int y;\n        public Point(int x, int y)\n        {\n            this.x = x; this.y = y;\n        }\n        public static Point operator +(Point p1, Point p2)\n        {\n            return new Point(p1.x + p2.x, p1.y + p2.y);\n        }\n        public static Point operator -(Point p1, Point p2)\n        {\n            return new Point(p1.x - p2.x, p1.y - p2.y);\n        }\n        public static Point operator *(int s, Point p)\n        {\n            return new Point(s * p.x, s * p.y);\n        }\n    }\n\n    public static class GeometryLibrary\n    {\n\n\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static double Naiseki(dPoint p1, dPoint p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??????\n        /// </summary>\n        /// <returns></returns>\n        public static int Naiseki(Point p1, Point p2)\n        {\n            return p1.x * p2.x + p1.y * p2.y;\n        }\n        /// <summary>\n        /// ??´???p1,p2???????????????p????°???±\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Projection(dPoint p1, dPoint p2, dPoint p)\n        {\n            dPoint a = p2 - p1;\n            dPoint b = p - p1;\n            double t = Naiseki(a, b) / Naiseki(a, a);\n            return t * a + p1 ;\n        }\n        /// <summary>\n        /// ??´???p1p2???????????????p???????°????p1,p2???????????´?????????????§°??????p????§????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        public static dPoint Refrection(dPoint p1, dPoint p2, dPoint p)\n        {\n            return 2 * Projection(p1, p2, p) - p;\n        }\n\n        /// <summary>\n        /// p1p2??¨p3p4???2??´????????????\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsParallel(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) * Naiseki(a, b) == Naiseki(a, a) * Naiseki(b, b)) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????´\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool IsVertical(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p2 - p1;\n            Point b = p4 - p3;\n            if (Naiseki(a, b) == 0) return true;\n            return false;\n        }\n        /// <summary>\n        ///  p1p2??¨p3p4???2??´???????????? ?????????http://www5d.biglobe.ne.jp/~tomoya03/shtml/algorithm/Intersection.htm\n        /// </summary>\n        /// <param name=\"p1\"></param>\n        /// <param name=\"p2\"></param>\n        /// <param name=\"p3\"></param>\n        /// <param name=\"p4\"></param>\n        /// <returns></returns>\n        public static bool DoesIntersect(Point p1, Point p2, Point p3, Point p4)\n        {\n            Point a = p1 - p2;\n            Point b = p3 - p1;\n            Point c = p4 - p1;\n            long tc = a.x * (b.x) + a.y * (-b.y);\n            long td = a.x * (c.y) + a.y * (-c.x);\n            if (tc * td < 0) return true;\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int NQ = Reader.Int();\n\n        for (int q = 0; q < NQ; q++)\n        {\n            var a = new Point(Reader.Int(), Reader.Int());\n            var b = new Point(Reader.Int(), Reader.Int());\n            var c = new Point(Reader.Int(), Reader.Int());\n            var d = new Point(Reader.Int(), Reader.Int());\n            Console.WriteLine(SegmentIntersect(a, b, c, d) ? 1 : 0);\n        }\n        Console.ReadLine();\n    }\n\n    bool SegmentIntersect(Point a1, Point a2, Point b1, Point b2)\n    {\n        var c1 = (a2 - a1).Det(b1 - a1);\n        if (c1 == 0 && (a1 - b1).Dot(a2 - b1) <= 0) return true;\n        var c2 = (a2 - a1).Det(b2 - a1);\n        if (c2 == 0 && (a1 - b2).Dot(a2 - b2) <= 0) return true;\n        var c3 = (b2 - b1).Det(a1 - b1);\n        if (c3 == 0 && (b1 - a1).Dot(b2 - a1) <= 0) return true;\n        var c4 = (b2 - b1).Det(a2 - b1);\n        if (c4 == 0 && (b1 - a2).Dot(b2 - a2) <= 0) return true;\n        return c1 * c2 < 0 && c3 * c4 < 0;\n    }\n\n    public class Segment\n    {\n        public Point A, B;\n        public Segment(Point a, Point b) { A = a; B = b; }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(Point p, double d)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \", \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var Point = function(x,y) {\n\tthis.x = x;\n\tthis.y = y;\n};\n\nPoint.prototype = {\n\tvec:function(p) {\n\t\treturn new Point(this.x-p.x,this.y-p.y);\n\t},\n\tnorm:function(){\n\t\treturn this.x*this.x+this.y*this.y;\n\t},\n\tlen:function() {\n\t\treturn Math.sqrt(this.norm());\n\t},\n};\n\nvar Line = function(a,b) {\n\tthis.a = a;\n\tthis.b = b;\n};\n\nLine.prototype = {\n\tvec:function() {return this.b.vec(this.a);}\n};\n\nvar Geo = {\n\tP:function(x,y) {\n\t\treturn new Point(x,y);\n\t},\n\tL:function(a,b) {\n\t\treturn new Line(a,b);\n\t},\n\tFRONT:1,\n\tRIGHT:2,\n\tBACK:4,\n\tLEFT:8,\n\tON:16,\n\teps:1e-9,\n\tcross:function(a,b) {\n\t\treturn a.x*b.y-a.y*b.x;\n\t},\n\tdot:function(a,b) {\n\t\treturn a.x*b.x+a.y*b.y;\n\t},\n\teq:function(a,b) {\n\t\treturn Math.abs(a-b)<Geo.eps;\n\t},\n\tsig:function(a) {\n\t\treturn a<-Geo.eps ? -1 : (a>Geo.eps) ? 1 : 0;\n\t},\n\tccw:function(s,p) {\n\t\tvar a = s.vec();\n\t\t//console.log(a);\n\t\tp = p.vec(s.a);\n\t\tvar cr = Geo.cross(a,p);\n\t\tif( Geo.eq(cr,0) ) {\n\t\t\tif(Geo.sig(Geo.dot(a,p)) < 0) return Geo.BACK;\n\t\t\tif(Geo.sig(a.norm()-p.norm()) < 0) return Geo.FRONT;\n\t\t\treturn Geo.ON;\n\t\t}\n\t\treturn (cr > 0) ? Geo.LEFT : Geo.RIGHT;\n\t},\n\tiI2_1:function(a,b) {\n\t\treturn ((Geo.ccw(a,b.a)|Geo.ccw(a,b.b))&(ccw(b,a.a)|ccw(b,a.b))) == (Geo.LFET|Geo.RIGHT);\n\t},\n\tiI2_2:function(a,b) {\n\t\tvar cwa = Geo.ccw(a,b.a) | Geo.ccw(a,b.b);\n\t\tvar cwb = Geo.ccw(b,a.a) | Geo.ccw(b,a.b);\n\t\treturn ((cwa | cwb) & Geo.ON) || ((cwa & cwb) == (Geo.LEFT | Geo.RIGHT));\n\t},\n\tiPoL2:function(a,b) {\n\t\treturn a.a.vec(b).len()+b.vec(a.b).len() < a.a.vec(a.b).len() + Geo.eps;\n\t},\n};\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function (chunk)\n{\n\tvar sc = chunk.trim().split(\"\\n\");\n\t//console.log(sc);\n\tvar q = parseInt(sc.shift());\n\t//console.log(q);\n\twhile( q-- > 0 ) {\n\t\tvar d = sc.shift().trim().split(\" \");\n\t\tfor( var i in d ) d[i] = parseInt(d[i]);\n\t\tvar l1 = Geo.L(Geo.P(d[0],d[1]),Geo.P(d[2],d[3]));\n\t\tvar l2 = Geo.L(Geo.P(d[4],d[5]),Geo.P(d[6],d[7]));\n\t\tconsole.log(Geo.iI2_2(l1,l2)?1:0);\n\t}\n});"
  },
  {
    "language": "JavaScript",
    "code": "// Vector2d\nvar Vector2D = class Vector2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nVector2D.prototype.Init = function(x,y){\n\tthis.x = x;\n\tthis.y = y;\n}\n\n/*\n * v: Vector2D\n */\nfunction rotateVector90(v){\n\tvar r = new Vector2D();\n\tr.x = -v.y;\n\tr.y = v.x;\n\treturn r;\n}\n\n/*\n * get degree to radian return radian\n */\nfunction getDegreeToRadian(degree){\n\tvar pi = 3.14159265358979323846;\n\treturn degree * pi / 180;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVector(vec,degree){\n\tvar radian = getDegreeToRadian(degree);\n\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\nfunction isEqualVectors(a,b){\n\treturn equalFloats(a.x - b.x,0) && equalFloats(a.y - b.y,0);\n}\n\n/**\n * vec:Vector2D\n * \n * return unitVector\n */\nfunction getUnitVector(vec){\n\tvar length = getVectorLength2D(vec);\n\tif(length > 0){\n\t\treturn getDivideVector(vec,length);\n\t}\n\treturn vec;\n}\n\n/**\n * return vector length\n * \n * vec:Vector2D\n */\nfunction getVectorLength2D(vec){\n\treturn Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n}\n\nfunction getDivideVector(vec2D,length){\n\tvec2D.x = vec2D.x / length;\n\tvec2D.y = vec2D.y / length;\n\treturn vec2D;\n}\n\nfunction equalFloats(a,b){\n\tvar threshold = 1 / 8192;\n\treturn Math.abs(a - b) < threshold;\n}\n\nfunction isParallelVector(vectorA,vectorB){\n\tvar na = rotateVector90(vectorA);\n\treturn equalFloats(0,dotProduct2D(na,vectorB));\n}\n\nfunction isVerticalVector(vectorA,vectorB){\n\treturn equalFloats(0,dotProduct2D(vectorA,vectorB));\n}\n\nfunction subtractVector(vecA,vecB){\n\tvar vec = new Vector2D();\n\tvec.x = vecA.x - vecB.x;\n\tvec.y = vecA.y - vecB.y;\n\treturn vec;\n}\n\nfunction dotProduct2D(vecA,vecB){\n\treturn vecA.x * vecB.x + vecA.y * vecB.y;\n}\n\n/**\n * 外積\n * \n * @param vecA\n * @param vecB\n * @returns\n */\nfunction getCloss(vecA,vecB){\n\treturn vecA.x * vecB.y - vecA.y * vecB.x;;\n}\n\n/**\n * line segment\n * \n * point1:Vector2D point2:Vector2D\n */\nvar LineSegment2D = class LineSegment2D {\n\tconstructor(point1,point2){\n\t\tthis.point1 = point1;\n\t\tthis.point2 = point2;\n\t}\n}\n\nLineSegment2D.prototype.Init = function(point1,point2){\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n}\n\nfunction onOneSide(axis,segment){\n\tvar d1 = new Vector2D();\n\td1 = subtractVector(segment.point1,axis.base);\n\n\tvar d2 = new Vector2D();\n\td2 = subtractVector(segment.point2,axis.base);\n\n\tvar n = new Vector2D();\n\tn = rotateVector90(axis.direction);\n\n\t// 同じ方向だということを返す\n\treturn dotProduct2D(n,d1) * dotProduct2D(n,d2) > 0;\n}\n\nfunction overLapping(minA,maxA,minB,maxB){\n\treturn minB <= maxA && minA <= maxB;\n}\n\nfunction isSegmentsCollide(segment1,segment2){\n\t// 線分の方向をチェックするためのベクトル\n\tvar axisA = new Line();\n\tvar axisB = new Line();\n\n\t// 線分1のベクトルに対して、線分2が片側にあるかチェック\n\taxisA.base = segment1.point1;\n\taxisA.direction = subtractVector(segment1.point2,segment1.point1);\n\n\tif(onOneSide(axisA,segment2)){\n\t\treturn false;\n\t}\n\n\t// 同じく\n\taxisB.base = segment2.point1;\n\taxisB.direction = subtractVector(segment2.point2,segment2.point1);\n\n\tif(onOneSide(axisB,segment1)){\n\t\treturn false;\n\t}\n\n\t// 同じベクトルをもつケース\n\tif(isParallelVector(axisA.direction,axisB.direction)){\n\t\tvar rangeA = getProjectSegment(segment1,axisA.direction);\n\t\tvar rangeB = getProjectSegment(segment2,axisA.direction);\n\n\t\t// 重なっているか\n\t\treturn isOverLappingRanges(rangeA,rangeB);\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\n/*\n * Line Object\n */\nfunction Line(){\n\t// vector2D\n\tthis.base;\n\t// vector2D\n\tthis.direction\n}\n\nLine.prototype.Init = function(base,direction,color){\n\tthis.base = base;\n\tthis.direction = direction;\n}\n\n/**\n * Range\n */\nvar Range = class Range {\n\tconstructor(min,max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n}\n\nfunction getMaxMinRange(range1,range2){\n\tvar range = new Range();\n\trange.min = range1.min < range2.min ? range1.min : range2.min;\n\trange.max = range1.max < range2.max ? range2.max : range1.max;\n\treturn range;\n}\n\nfunction getSortRange(range){\n\tvar sorted = new Range(range.min,range.max);\n\tif(range.min > range.max){\n\t\tsorted.min = range.max;\n\t\tsorted.max = range.min;\n\t}\n\treturn sorted;\n}\n\nfunction getNegateVector(vector){\n\tvector.x = -vector.x;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfunction getAddVector(vecA,vecB){\n\treturn new Vector2D(vecA.x + vecB.x,vecA.y + vecB.y);\n}\n\n/**\n * segment:segment onto:Vector2D\n * \n * return Range\n */\nfunction getProjectSegment(segment,onto){\n\tvar ontoUnitVec = getUnitVector(onto);\n\n\tvar range = new Range();\n\trange.min = dotProduct2D(ontoUnitVec,segment.point1);\n\trange.max = dotProduct2D(ontoUnitVec,segment.point2);\n\n\trange = getSortRange(range);\n\treturn range;\n}\n\nfunction isOverLappingRanges(range1,range2){\n\treturn overLapping(range1.min,range1.max,range2.min,range2.max);\n}\n\nfunction projectVector(project,onto){\n\tvar d = dotProduct2D(onto,onto);\n\tconsole.log(\"d = \" + d);\n\n\tif(0 < d){\n\t    var dp = dotProduct2D(project,onto);\n\t    console.log(\"dp = \" + dp);\n\t    return multiplyVector(onto,dp / d);\n\t}\n\treturn onto;\n}\n\nfunction getNorm(vec){\n\treturn vec.x * vec.x + vec.y * vec.y;\n}\n\n/**\n * point class\n */\nvar Point2D = class Point2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n}\n\nfunction addPoint(point1,point2){\n\treturn new Point2D(point1.x + point2.x,point1.y + point2.y);\n}\n\nfunction subtractPoint(point1,point2){\n\treturn new Point2D(point1.x - point2.x,point1.y - point2.y);\n}\n\nfunction multiplyPoint(point,scalar){\n\treturn new Point2D(point.x * scalar,point.y * scalar);\n}\n\n/**\n * segment : LineSegment2D\n * point : Point\n */\nfunction getProjectPoint(segment,point){\n\tvar vec1 = new Vector2D(segment.point2.x - segment.point1.x,segment.point2.y - segment.point1.y);\n\tvar vec2 = new Vector2D(point.x - segment.point1.x,point.y - segment.point1.y);\n\tvar rate = dotProduct2D(vec2,vec1) / getNorm(vec1);\n\tvar vec3 = multiplyVector(vec1,rate);\n\tvar project = new Point2D(segment.point1.x + vec3.x,segment.point1.y + vec3.y);\n\treturn project; \n}\n\nfunction getReflectionPoint(segment,point){\n\tvar projection = getProjectPoint(segment,point);\n\t// pから射影点までのベクトル\n\tvar vec = subtractPoint(projection,point);\n\t// 2倍したものが射影点になる\n\tvar refrectionPoint = multiplyPoint(vec,2);\n\t// 始点を足す\n\treturn addPoint(refrectionPoint,point);\n}\n\nfunction multiplyVector(vec,scalar){\n\tvar temp = new Vector2D();\n\ttemp.x = vec.x * scalar;\n\ttemp.y = vec.y * scalar;\n\treturn temp;\n}\n\nfunction clampOnRange(x,min,max){\n\tif(x < min){\n\t\treturn min;\n\t}else if(x > max){\n\t\treturn max;\n\t}else{\n\t\treturn x;\n\t}\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n//var input = require('fs').readFileSync('input.txt', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\t\n// 消す\nArr.shift();\n\nArr.forEach(function(v){\n   var nums = v.split(\" \").map(Number);\n   var segment1 = new LineSegment2D(new Vector2D(nums[0],nums[1]),new Vector2D(nums[2],nums[3]));\n   var segment2 = new LineSegment2D(new Vector2D(nums[4],nums[5]),new Vector2D(nums[6],nums[7])); \n   var ans = \"0\";\n   if(isSegmentsCollide(segment1,segment2)){\n\t   ans = \"1\";\n   }\n   console.log(ans);\n});\n"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\nclass Line\n  attr_reader :p1, :p2, :maxx, :minx, :maxy, :miny, :x, :y\n  def initialize(x1, y1, x2, y2)\n    @p1 = Point.new(x1, y1)\n    @p2 = Point.new(x2, y2)\n    @maxx = (x1 > x2)? x1 : x2\n    @minx = (x1 > x2)? x2 : x1\n    @maxy = (y1 > y2)? y1 : y2\n    @miny = (y1 > y2)? y2 : y1\n    @x = x1 - x2\n    @y = y1 - y2\n  end\n  def parallel?(other)\n    return (x * other.y) == (y * other.x)\n  end\n  def over_x?(other)\n    return (x ** 2 + other.x ** 2 >= (maxx - other.maxx) ** 2 + (minx - other.minx) ** 2)\n  end\n  def over_y?(other)\n    return (y ** 2 + other.y ** 2 >= (maxy - other.maxy) ** 2 + (miny - other.miny) ** 2)\n  end\n  def get_xy(other)\n    return (y * other + (x * p2.y - y * p2.x))\n  end\n  def get_yx(other)\n    return (x * other + (y * p2.x - x * p2.y))\n  end\n  def cross_x?(other)\n    return (other.x * p1.y - other.get_xy(p1.x)) * (other.x * p2.y - other.get_xy(p2.x)) <= 0\n  end\n  def cross_y?(other)\n    return (other.y * p1.x - other.get_yx(p1.y)) * (other.y * p2.x - other.get_yx(p2.y)) <= 0\n  end\n  def intersection?(other)\n    if (parallel?(other))\n      if (x * y == 0)\n        if (x == 0)\n          return ((p1.x == other.p1.x) and (over_y?(other)))\n        else\n          return ((p1.y == other.p1.y) and (over_x?(other)))\n        end\n      else\n        return (cross_x?(other) and over_x?(other))\n      end\n    else\n      if (y == 0 or other.y == 0)\n        return (cross_x?(other) and other.cross_x?(self))\n      else\n        return (cross_y?(other) and other.cross_y?(self))\n      end\n    end\n  end\nend\n\ndef main(input = STDIN, output = nil)\n  q = input.gets.to_i\n  q.times do |i|\n    arg = input.gets.split(\" \").map(&:to_i)\n    l1 = Line.new(*arg[0...4])\n    l2 = Line.new(*arg[4..-1])\n    if (l1.intersection?(l2))\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\nclass Line\n  attr_reader :p1, :p2, :maxx, :minx, :maxy, :miny, :x, :y\n  def initialize(x1, y1, x2, y2)\n    @p1 = Point.new(x1, y1)\n    @p2 = Point.new(x2, y2)\n    @maxx = (x1 > x2)? x1 : x2\n    @minx = (x1 > x2)? x2 : x1\n    @maxy = (y1 > y2)? y1 : y2\n    @miny = (y1 > y2)? y2 : y1\n    @x = x1 - x2\n    @y = y1 - y2\n  end\n  def parallel?(other)\n    return (x * other.y) == (x * other.x)\n  end\n  def over_x?(other)\n    return (x ** 2 + other.x ** 2 >= (maxx - other.maxx) ** 2 + (minx - other.mixx) ** 2)\n  end\n  def over_y?(other)\n    return (y ** 2 + other.y ** 2 >= (maxy - other.maxy) ** 2 + (miny - other.miny) ** 2)\n  end\n  def get_xy(other)\n    return (y * other + (x * p2.y - y * p2.x))\n  end\n  def get_yx(other)\n    return (x * other + (y * p2.x - x * p2.y))\n  end\n  def cross_x?(other)\n    return (other.x * p1.y - other.get_xy(p1.x)) * (other.x * p2.y - other.get_xy(p2.x)) <= 0\n  end\n  def cross_y?(other)\n    return (other.y * p1.x - other.get_yx(p1.y)) * (other.y * p2.x - other.get_yx(p2.y)) <= 0\n  end\n  def intersection?(other)\n    if (parallel?(other))\n      if (x * y == 0)\n        if (x == 0)\n          return ((p1.x == other.p1.x) and (over_y?(other)))\n        else\n          return ((p1.y == other.p1.y) and (over_y?(other)))\n        end\n      else\n        return (cross_x?(other) and over_x?(other))\n      end\n    else\n      if (y == 0 or other.y == 0)\n        return (cross_x?(other) and other.cross_x?(self))\n      else\n        return (cross_y?(other) and other.cross_y?(self))\n      end\n    end\n  end\nend\n\ndef main(input = STDIN, output = nil)\n  q = input.gets.to_i\n  q.times do |i|\n    arg = input.gets.split(\" \").map(&:to_i)\n    l1 = Line.new(*arg[0...4])\n    l2 = Line.new(*arg[4..-1])\n    if (l1.intersection?(l2))\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "#encoding : utf-8\n\nrequire 'complex'\n\n# Complex * Complex -> Double\n\ndef dot(c1, c2)\n  (c1.conj * c2).real\nend\n\n# Complex * Complex -> Double\ndef cross(c1, c2)\n  (c1.conj * c2).imag\nend\n\n# Complex * Complex * Complex -> Complex\n# return the proj of vector p0p to vector p0p1\ndef proj(p0, p1, p)\n  (p1 - p0) * dot(p1 - p0, p - p0) / ((p1 - p0).abs ** 2) + p0\nend\n\n\ndef sign d\n  eps = 1e-8\n  d < -eps ? -1 : (d > eps ? 1 : 0)\nend\n\n# Complex * Complex * Complex -> Bool\n# Return true if Point q is on segment p1p2\n# otherwise return false\ndef on_seg(p1, p2, q)\n  sign(cross(p1 - q, p2 - q)) == 0 &&\n    sign(dot(p1 - q, p2 - q)) <= 0\nend\n\ndef direct(p0, p1, p2)\n  d = cross(p1 - p0, p2 - p0)\n  if sign(d) == 1\n    :COUNTER_CLOCKWISE\n  elsif sign(d) == -1\n    :CLOCKWISE\n  else\n    if on_seg(p2, p1, p0)\n      :ONLINE_BACK\n    elsif on_seg(p0, p2, p1)\n      :ONLINE_FRONT\n    else\n      :ON_SEGMENT\n    end\n  end\nend\n\n# Complex * Complex * Complex * Complex -> :PARALL | :OVERLAP | Complex\n# Compute the intersect point of two line p0p1 p2p3\n# Return:\n#       :PARALLEL if two line parallel\n#       :OVERLAP if two line overlap\n#       Point of the intersection\ndef intersect_line(p0, p1, p2, p3)\n  v1 = Complex(p1 - p0)\n  v2 = Complex(p3 - p2)\n  if sign(cross(v1, v2)) == 0 and sign(cross(p2 - p0, p2 - p1)) == 0\n    :OVERLAP\n  elsif sign(cross(v1, v2)) == 0 and sign(cross(p2 - p0, p2 - p1)) != 0\n    :PARALLEL\n  else\n    p2 + (p3 - p2) * ((cross(p1 - p0, p2 - p0)) /\n      (cross(p3 - p0, p1 - p0) + cross(p1 - p0, p2 - p0)))\n  end\nend\n\ndef main\n  t = gets.chomp.to_i\n  (1..t).each do |ca|\n    x1, y1, x2, y2, x3, y3, x4, y4 = gets.chomp.split(/\\s/).collect {|x| x.to_f}\n    p0, p1 = Complex(x1, y1), Complex(x2, y2)\n    p2, p3 = Complex(x3, y3), Complex(x4, y4)\n    int = intersect_line(p0, p1, p2, p3)\n    if int == :OVERLAP or int == :PARALLEL\n      puts \"0\"\n    elsif on_seg(p0, p1, int) and on_seg(p2, p3, int)\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  p0, p1, p2, p3 = gets.split.map(&:to_i).each_slice(2).map {|a, b| a + b * 1i }\n  u, v, w, z = p1 - p0, p3 - p2, p2 - p0, p3 - p0\n  d, c = (u.conj * v).rect\n  if c.zero?\n    if (u.conj * w).imag.zero?\n      ud, wd, zd = [u, w, z].map {|x| (u.conj * x).real }\n      a, b = 0, ud\n      a, b = b, a if b < a\n      p wd < a && zd < a || wd > b && zd > b ? 0 : 1\n    else\n      p 0\n    end\n  else\n    # t, s are such that p0 + t * u = p2 + s * v\n    t = (Complex(*v.rect.reverse!) * w).real.to_f / c\n    s = (Complex(*u.rect.reverse!) * w).real.to_f / c\n    p 0 <= t && t <= 1 && 0 <= s && s <= 1 ? 1 : 0\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nq = gets.to_i\n\ndef cross(p1, p2)\n  return p1[0] * p2[1] - p1[1] * p2[0]\nend\n\nq.times do\n  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y = gets.split.map &:to_i\n  p0 = Vector[ p0x, p0y ]\n  p1 = Vector[ p1x, p1y ]\n  p2 = Vector[ p2x, p2y ]\n  p3 = Vector[ p3x, p3y ]\n\n  if cross(p1-p0, p2-p0) * cross(p1-p0, p3-p0) < 0 &&\n    cross(p3-p2, p0-p2) * cross(p3-p2, p1-p2) < 0\n    puts 1\n  elsif  ( cross(p1-p0, p2-p0) == 0 && (p1-p0).inner_product(p2-p0) > 0 && (p2-p0).norm <= (p1-p0).norm ) ||\n    ( cross(p1-p0, p3-p0) == 0 && (p1-p0).inner_product(p3-p0) > 0 && (p3-p0).norm <= (p1-p0).norm )\n    puts 1\n  elsif  ( cross(p3-p2, p0-p2) == 0 && (p3-p2).inner_product(p0-p2) > 0 && (p0-p2).norm <= (p3-p2).norm ) ||\n    ( cross(p3-p2, p1-p2) == 0 && (p3-p2).inner_product(p1-p2) > 0 && (p1-p2).norm <= (p3-p2).norm )\n    puts 1\n  else\n    puts 0\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "q = gets.to_i\nq.times{\n  x0, y0, x1, y1, x2, y2, x3, y3 = gets.split.map(&:to_i)\n  if x0 < x1 && ((x2 < x0 && x3 < x0) || (x1 < x2 && x1 < x3))\n    puts 0\n  elsif x1 <= x0 && ((x2 < x1 && x3 < x1) || (x0 < x2 && x0 < x3))\n    puts 0\n  elsif y0 < y1 && ((y2 < y0 && y3 < y0) || (y1 < y2 && y1 < y3))\n    puts 0\n  elsif y1 <= y0 && ((y2 < y1 && y3 < y1) || (y0 < y2 && y0 < y3))\n    puts 0\n  else\n    t0 = (x0-x1) * (y2-y0) + (y0-y1) * (x0-x2)\n    t1 = (x0-x1) * (y3-y0) + (y0-y1) * (x0-x3)\n    t2 = (x2-x3) * (y0-y2) + (y2-y3) * (x2-x0)\n    t3 = (x2-x3) * (y1-y2) + (y2-y3) * (x2-x1)\n    if t0 * t1 <= 0 && t2 * t3 <= 0\n      puts 1\n    else\n      puts 0\n    end\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\nclass Line\n  attr_reader :p1, :p2, :maxx, :minx, :maxy, :miny, :x, :y\n  def initialize(x1, y1, x2, y2)\n    @p1 = Point.new(x1, y1)\n    @p2 = Point.new(x2, y2)\n    @maxx = (x1 > x2)? x1 : x2\n    @minx = (x1 > x2)? x2 : x1\n    @maxy = (y1 > y2)? y1 : y2\n    @miny = (y1 > y2)? y2 : y1\n    @x = x1 - x2\n    @y = y1 - y2\n  end\n  def parallel?(other)\n    return (x * other.y) == (y * other.x)\n  end\n  def over_x?(other)\n    return (x ** 2 + other.x ** 2 >= (maxx - other.maxx) ** 2 + (minx - other.mixx) ** 2)\n  end\n  def over_y?(other)\n    return (y ** 2 + other.y ** 2 >= (maxy - other.maxy) ** 2 + (miny - other.miny) ** 2)\n  end\n  def get_xy(other)\n    return (y * other + (x * p2.y - y * p2.x))\n  end\n  def get_yx(other)\n    return (x * other + (y * p2.x - x * p2.y))\n  end\n  def cross_x?(other)\n    return (other.x * p1.y - other.get_xy(p1.x)) * (other.x * p2.y - other.get_xy(p2.x)) <= 0\n  end\n  def cross_y?(other)\n    return (other.y * p1.x - other.get_yx(p1.y)) * (other.y * p2.x - other.get_yx(p2.y)) <= 0\n  end\n  def intersection?(other)\n    if (parallel?(other))\n      if (x * y == 0)\n        if (x == 0)\n          return ((p1.x == other.p1.x) and (over_y?(other)))\n        else\n          return ((p1.y == other.p1.y) and (over_x?(other)))\n        end\n      else\n        return (cross_x?(other) and over_x?(other))\n      end\n    else\n      if (y == 0 or other.y == 0)\n        return (cross_x?(other) and other.cross_x?(self))\n      else\n        return (cross_y?(other) and other.cross_y?(self))\n      end\n    end\n  end\nend\n\ndef main(input = STDIN, output = nil)\n  q = input.gets.to_i\n  q.times do |i|\n    arg = input.gets.split(\" \").map(&:to_i)\n    l1 = Line.new(*arg[0...4])\n    l2 = Line.new(*arg[4..-1])\n    if (l1.intersection?(l2))\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "def projecter(x, y, xp, yp)\n  return (xp * x + yp * y) / (x ** 2 + y ** 2), (yp * x - xp * y) / (x ** 2 + y ** 2)\nend\ndef main(input = STDIN)\n  input.gets.to_i.times do\n    points = input.gets.split(\" \").map(&:to_r)\n    a1, b1, a2, b2 = *projecter(points[2] - points[0], points[3] - points[1], points[4], points[5]), *projecter(points[2] - points[0], points[3] - points[1], points[6], points[7])\n    if ((b1 - b2) + (a1 * b2 - b1 * a2)) * (a1 * b2 - b1 * a2) <= 0\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  p0, p1, p2, p3 = gets.split.map(&:to_i).each_slice(2).map {|a, b| a + b * 1i }\n  u, v, w = p1 - p0, p3 - p2, p2 - p0\n  d, c = (u.conj * v).rect\n  # t, s are such that p0 + t * u = p2 + s * v\n  t = (Complex(*v.rect.reverse!) * w).real.to_f / c\n  s = (Complex(*u.rect.reverse!) * w).real.to_f / c\n  p c != 0 && 0 <= t && t <= 1 && 0 <= s && s <= 1 ? 1 : 0\nend"
  },
  {
    "language": "Ruby",
    "code": "def projecter(x, y, xp, yp)\n  return (xp * x + yp * y) / (x ** 2 + y ** 2), (yp * x - xp * y) / (x ** 2 + y ** 2)\nend\ndef check(a1, b1, a2, b2)\n  return ((((b2 - b1) * (1 - a1) + b1 * (a2 - a1)) * (b1 * (a2 - a1) - (b2 - b1) * a1) <= 0) and (b1 * b2 <= 0) and subcheck(a1, b1, a2, b2))\nend\ndef subcheck(a1, b1, a2, b2)\n  return (b1 != b2 or a1.between?(0,1) or a2.between?(0, 1))\nend\n          \n\ndef main(input = STDIN)\n  input.gets.to_i.times do\n    points = input.gets.split(\" \").map(&:to_r)\n    a1, b1, a2, b2 = *projecter(points[2] - points[0], points[3] - points[1], points[4] - points[0], points[5] - points[1]), *projecter(points[2] - points[0], points[3] - points[1], points[6] - points[0], points[7] - points[1])\n    if  check(a1, b1, a2, b2)\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\nclass Line\n  attr_reader :p1, :p2, :maxx, :minx, :maxy, :miny, :x, :y\n  def initialize(x1, y1, x2, y2)\n    @p1 = Point.new(x1, y1)\n    @p2 = Point.new(x2, y2)\n    @maxx = (x1 > x2)? x1 : x2\n    @minx = (x1 > x2)? x2 : x1\n    @maxy = (y1 > y2)? y1 : y2\n    @miny = (y1 > y2)? y2 : y1\n    @x = x1 - x2\n    @y = y1 - y2\n  end\n  def parallel?(other)\n    return (x * other.y) == (x * other.x)\n  end\n  def over_x?(other)\n    return (x ** 2 + other.x ** 2 >= (maxx - other.maxx) ** 2 + (minx - other.mixx) ** 2)\n  end\n  def over_y?(other)\n    return (y ** 2 + other.y ** 2 >= (maxy - other.maxy) ** 2 + (miny - other.miny) ** 2)\n  end\n  def get_xy(other)\n    return (y * other + (x * p2.y - y * p2.x))\n  end\n  def get_yx(other)\n    return (x * other + (y * p2.x - x * p2.y))\n  end\n  def cross_x?(other)\n    return (other.x * p1.y - other.get_xy(p1.x)) * (other.x * p2.y - other.get_xy(p2.x)) <= 0\n  end\n  def cross_y?(other)\n    return (other.y * p1.x - other.get_yx(p1.y)) * (other.y * p2.x - other.get_yx(p2.y)) <= 0\n  end\n  def intersection?(other)\n    if (parallel?(other))\n      if (x * y == 0)\n        if (x == 0)\n          return ((p1.x == other.p1.x) and (over_y?(other)))\n        else\n          return ((p1.y == other.p1.y) and (over_x?(other)))\n        end\n      else\n        return (cross_x?(other) and over_x?(other))\n      end\n    else\n      if (y == 0 or other.y == 0)\n        return (cross_x?(other) and other.cross_x?(self))\n      else\n        return (cross_y?(other) and other.cross_y?(self))\n      end\n    end\n  end\nend\n\ndef main(input = STDIN, output = nil)\n  q = input.gets.to_i\n  q.times do |i|\n    arg = input.gets.split(\" \").map(&:to_i)\n    l1 = Line.new(*arg[0...4])\n    l2 = Line.new(*arg[4..-1])\n    if (l1.intersection?(l2))\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nq = gets.to_i\n\ndef cross(p1, p2)\n  return p1[0] * p2[1] - p1[1] * p2[0]\nend\n\nq.times do\n  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y = gets.split.map &:to_i\n  p0 = Vector[ p0x, p0y ]\n  p1 = Vector[ p1x, p1y ]\n  p2 = Vector[ p2x, p2y ]\n  p3 = Vector[ p3x, p3y ]\n\n  if cross(p1-p0, p2-p0) * cross(p1-p0, p3-p0) < 0 &&\n    cross(p3-p2, p0-p2) * cross(p3-p2, p1-p2) < 0\n    puts 1\n  elsif  ( cross(p1-p0, p2-p0) == 0 && (p1-p0).inner_product(p2-p0) >= 0 && (p2-p0).norm <= (p1-p0).norm ) ||\n    ( cross(p1-p0, p3-p0) == 0 && (p1-p0).inner_product(p3-p0) >= 0 && (p3-p0).norm <= (p1-p0).norm )\n    puts 1\n  elsif  ( cross(p3-p2, p0-p2) == 0 && (p3-p2).inner_product(p0-p2) >= 0 && (p0-p2).norm <= (p3-p2).norm ) ||\n    ( cross(p3-p2, p1-p2) == 0 && (p3-p2).inner_product(p1-p2) >= 0 && (p1-p2).norm <= (p3-p2).norm )\n    puts 1\n  else\n    puts 0\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\ndef projector(a, b, c, d, x, y)\n  if a * d == b * c\n    #p [\"a=#{a}\",\"b=#{b}\", \"c=#{c}\", \"d=#{d}\", x, y]\n    if a * y == b * x\n      temp = [[x, x - c].sort, [y, y - d].sort]\n      if (temp[0][0] < a and 0 < temp[0][1]) or (temp[1][0] < b and 0 < temp[1][1])\n        return 0.5, 0.5\n      else\n        return 2, 2\n      end\n    else\n      return nil, nil\n    end\n  else\n    return ((d * x - b * y) / (a * d - b * c)), ((a * y - x * c) / (a * d - b * c))\n  end\nend\ndef main(input = STDIN)\n  input.gets.to_i.times do\n    points = input.gets.split(\" \").map(&:to_r)\n    #a1, b1, a2, b2 = *projecter(points[2] - points[0], points[3] - points[1], points[4] - points[0], points[5] - points[1]), *projecter(points[2] - points[0], points[3] - points[1], points[6] - points[0], points[7] - points[1])\n\n    if (a, b = projector(points[2] - points[0], points[3] - points[1], points[6] - points[4], points[7] - points[5], points[6] - points[0], points[7] - points[1])).all?\n      #p \"not pallarel #{[a, b]}, #{points.map(&:to_f)}\"\n      if (0 < a and a < 1) and (0 < b and b < 1)\n        puts \"1\"\n      else\n        puts \"0\"\n      end\n    else\n      puts \"0\"\n    end\n  end\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "#encoding : utf-8\n\nrequire 'complex'\n\n# Complex * Complex -> Double\n\ndef dot(c1, c2)\n  (c1.conj * c2).real\nend\n\n# Complex * Complex -> Double\ndef cross(c1, c2)\n  (c1.conj * c2).imag\nend\n\n# Complex * Complex * Complex -> Complex\n# return the proj of vector p0p to vector p0p1\ndef proj(p0, p1, p)\n  (p1 - p0) * dot(p1 - p0, p - p0) / ((p1 - p0).abs ** 2) + p0\nend\n\n\ndef sign d\n  eps = 1e-8\n  d < -eps ? -1 : (d > eps ? 1 : 0)\nend\n\n# Complex * Complex * Complex -> Bool\n# Return true if Point q is on segment p1p2\n# otherwise return false\ndef on_seg(p1, p2, q)\n  sign(cross(p1 - q, p2 - q)) == 0 &&\n    sign(dot(p1 - q, p2 - q)) <= 0\nend\n\ndef direct(p0, p1, p2)\n  d = cross(p1 - p0, p2 - p0)\n  if sign(d) == 1\n    :COUNTER_CLOCKWISE\n  elsif sign(d) == -1\n    :CLOCKWISE\n  else\n    if on_seg(p2, p1, p0)\n      :ONLINE_BACK\n    elsif on_seg(p0, p2, p1)\n      :ONLINE_FRONT\n    else\n      :ON_SEGMENT\n    end\n  end\nend\n\n# Complex * Complex * Complex * Complex -> :PARALL | :OVERLAP | Complex\n# Compute the intersect point of two line p0p1 p2p3\n# Return:\n#       :PARALLEL if two line parallel\n#       :OVERLAP if two line overlap\n#       Point of the intersection\ndef intersect_line(p0, p1, p2, p3)\n  v1 = Complex(p1 - p0)\n  v2 = Complex(p3 - p2)\n  if sign(cross(v1, v2)) == 0 and sign(cross(p2 - p0, p2 - p1)) == 0\n    :OVERLAP\n  elsif sign(cross(v1, v2)) == 0 and sign(cross(p2 - p0, p2 - p1)) != 0\n    :PARALLEL\n  else\n    p2 + (p3 - p2) * ((cross(p1 - p0, p2 - p0)) /\n      (cross(p3 - p0, p1 - p0) + cross(p1 - p0, p2 - p0)))\n  end\nend\n\ndef main\n  t = gets.chomp.to_i\n  (1..t).each do |ca|\n    x1, y1, x2, y2, x3, y3, x4, y4 = gets.chomp.split(/\\s/).collect {|x| x.to_f}\n    p0, p1 = Complex(x1, y1), Complex(x2, y2)\n    p2, p3 = Complex(x3, y3), Complex(x4, y4)\n    int = intersect_line(p0, p1, p2, p3)\n    if int == :OVERLAP or int == :PARALLEL\n      puts \"2\"\n    elsif on_seg(p0, p1, int) and on_seg(p2, p3, int)\n      puts \"1\"\n    else\n      puts \"0\"\n    end\n  end\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  p0, p1, p2, p3 = gets.split.map(&:to_i).each_slice(2).map {|a, b| a + b * 1i }\n  u, v, w, z = p1 - p0, p3 - p2, p2 - p0, p3 - p0\n  d, c = (u.conj * v).rect\n  if c.zero?\n    if (u.conj * w).imag.zero?\n      ud, wd, zd = [u, w, z].map {|x| (u.conj * x).real }\n      p wd.zero? || zd.zero? || wd <= ud && ud <= zd || zd <= ud && ud <= wd ? 1 : 0\n    else\n      p 0\n    end\n  else\n    # t, s are such that p0 + t * u = p2 + s * v\n    t = (Complex(*v.rect.reverse!) * w).real.to_f / c\n    s = (Complex(*u.rect.reverse!) * w).real.to_f / c\n    p 0 <= t && t <= 1 && 0 <= s && s <= 1 ? 1 : 0\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "q = gets.to_i\nq.times{\n  x0, y0, x1, y1, x2, y2, x3, y3 = gets.split.map(&:to_i)\n  t0 = (x0-x1) * (y2-y0) + (y0-y1) * (x0-x2)\n  t1 = (x0-x1) * (y3-y0) + (y0-y1) * (x0-x3)\n  t2 = (x2-x3) * (y0-y2) + (y2-y3) * (x2-x0)\n  t3 = (x2-x3) * (y1-y2) + (y2-y3) * (x2-x1)\n  if t0 * t1 <= 0 && t2 * t3 <= 0\n    puts 1\n  else\n    puts 0\n  end\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"strings\"\n\t\"fmt\"\n\t\"bufio\"\n\t\"strconv\"\n\t\"math\"\n\t\"os\"\n)\n\n// test\nfunc Test_solve() {\n\tinput := `\n3\n0 0 3 0 1 1 2 -1\n0 0 3 0 3 1 3 -1\n0 0 3 0 3 -2 5 0\n`\n\tinput = strings.Trim(input, \"\\n\")\n\n\tsolve(bufio.NewScanner(strings.NewReader(input)))\n}\n\n//\nfunc subVector(p1, p2 []float64) []float64 {\n\treturn []float64{\n\t\tp1[0] - p2[0],\n\t\tp1[1] - p2[1],\n\t}\n}\n\n//\nfunc dotVector(p1, p2 []float64) float64 {\n\treturn p1[0]*p2[0] + p1[1]*p2[1]\n}\n\n//\nfunc crossVector(p1, p2 []float64) float64 {\n\treturn p1[0]*p2[1] - p1[1]*p2[0]\n}\n\n//\nfunc absVector(p []float64) float64 {\n\treturn math.Sqrt(p[0]*p[0] + p[1]*p[1])\n}\n\n//\nfunc norrmalize(p []float64) float64 {\n\treturn p[0]*p[0] + p[1]*p[1]\n}\n\n//\n// 1: p1-p2より反時計周り側にp3\n// 2: p1-p2より時計周り側にp3\n// 3: p1-p2直線上、p2の先にp3\n// 4: p1-p2直線上、p1の前にp3\n// 5: p1-p2線分上にp3\nfunc checkClockWise(p1, p2, p3 []float64) int {\n\tp1p2 := subVector(p2, p1)\n\tp1p3 := subVector(p3, p1)\n\tif crossVector(p1p2, p1p3) > 0.0 {\n\t\treturn 1\n\t} else if crossVector(p1p2, p1p3) < 0.0 {\n\t\treturn 2\n\t} else if dotVector(p1p2, p1p3) < 0.0 {\n\t\treturn 4\n\t} else if norrmalize(p1p2) < norrmalize(p1p3) {\n\t\treturn 3\n\t}\n\treturn 5\n}\n\nfunc strSliceToFloat64(strSlice []string) []float64 {\n\tn := len(strSlice)\n\tsliceFloat := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tv, _ := strconv.Atoi(strSlice[i])\n\t\tsliceFloat[i] = float64(v)\n\t}\n\treturn sliceFloat\n}\n\n// solve\nfunc solve(sc *bufio.Scanner) {\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tslice := strSliceToFloat64(strings.Split(sc.Text(), \" \"))\n\n\t\t//fmt.Println(slice)\n\n\t\tp1 := []float64{slice[0], slice[1]}\n\t\tp2 := []float64{slice[2], slice[3]}\n\t\tp3 := []float64{slice[4], slice[5]}\n\t\tp4 := []float64{slice[6], slice[7]}\n\n\t\tc1 := checkClockWise(p1, p2, p3)\n\t\tc2 := checkClockWise(p1, p2, p4)\n\n\t\tc3 := checkClockWise(p3, p4, p1)\n\t\tc4 := checkClockWise(p3, p4, p2)\n\n\t\tconv := func(v int) int {\n\t\t\tif v == 2 {\n\t\t\t\treturn -1\n\t\t\t} else if v == 5 {\n\t\t\t\treturn 0\n\t\t\t} else if v == 4 {\n\t\t\t    return -1\n\t\t\t}\n\t\t\treturn v\n\t\t}\n\n\t\tc1 = conv(c1)\n\t\tc2 = conv(c2)\n\t\tc3 = conv(c3)\n\t\tc4 = conv(c4)\n\n\t\tisInterSect := c1*c2 <= 0 && c3*c4 <= 0\n\n\t\tif isInterSect {\n\t\t\tfmt.Printf(\"%d\\n\", 1)\n\t\t} else {\n\t\t\tfmt.Printf(\"%d\\n\", 0)\n\t\t}\n\t}\n}\n\n// main\nfunc main() {\n    solve(bufio.NewScanner(os.Stdin))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n\treturn scanner\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\tcnt := 0\n\tif os.Getenv(\"MASPY\") == \"ますピ\" {\n\t\tfp, _ = os.Open(os.Getenv(\"BEET_THE_HARMONY_OF_PERFECT\"))\n\t\tcnt = 3\n\t}\n\tif os.Getenv(\"MASPYPY\") == \"ますピッピ\" {\n\t\twfp, _ = os.Create(os.Getenv(\"NGTKANA_IS_GENIUS10\"))\n\t}\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\tsolve(scanner, writer)\n\tfor i := 0; i < cnt; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n\twriter.Flush()\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tq := getNextInt(scanner)\n\tfor i := 0; i < q; i++ {\n\t\txx := make([]float64, 4)\n\t\tyy := make([]float64, 4)\n\t\tfor i := 0; i < 4; i++ {\n\t\t\txx[i] = getNextFloat64(scanner)\n\t\t\tyy[i] = getNextFloat64(scanner)\n\t\t}\n\t\tss := makeGrid(4, 4)\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\tss[j][i] = complex(xx[i]-xx[j], yy[i]-yy[j])\n\t\t\t}\n\t\t}\n\n\t\tb1 := between(ss[0][1], ss[0][2], ss[0][3])\n\t\tb2 := between(ss[2][3], ss[2][0], ss[2][1])\n\t\tif b1 == 1 || b2 == 1 {\n\t\t\tfmt.Fprintln(writer, 0)\n\t\t\tcontinue\n\t\t}\n\t\tif b1 == -1 && b2 == -1 {\n\t\t\tfmt.Fprintln(writer, 1)\n\t\t\tcontinue\n\t\t}\n\t\tif overlap(ss[0][1], ss[0][2], ss[0][3]) {\n\t\t\tfmt.Fprintln(writer, 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Fprintln(writer, 0)\n\t}\n}\nfunc sign(a float64) int {\n\teps := 1e-10\n\tif math.Abs(a) < eps {\n\t\treturn 0\n\t}\n\tif a > eps {\n\t\treturn 1\n\t}\n\treturn -1\n}\nfunc between(s, a, b complex128) int {\n\tia := imag(a / s)\n\tib := imag(b / s)\n\treturn sign(ia * ib)\n}\nfunc overlap(s, a, b complex128) bool {\n\tra := real(a / s)\n\trb := real(b / s)\n\tif sign(ra-1) == 1 && sign(rb-1) == 1 {\n\t\treturn false\n\t}\n\tif sign(ra) == -1 && sign(rb) == -1 {\n\t\treturn false\n\t}\n\treturn true\n}\nfunc makeGrid(h, w int) [][]complex128 {\n\tindex := make([][]complex128, h, h)\n\tdata := make([]complex128, h*w, h*w)\n\tfor i := 0; i < h; i++ {\n\t\tindex[i] = data[i*w : (i+1)*w]\n\t}\n\treturn index\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc nextFloat64() (float64, error) {\n\treturn strconv.ParseFloat(nextString(), 64)\n}\n\nfunc min(x, y float64) float64 {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc max(x, y float64) float64 {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\ntype Point struct {\n\tx float64\n\ty float64\n}\n\nfunc sub(l, r *Point) *Point {\n\ts := Point{\n\t\tx: l.x - r.x,\n\t\ty: l.y - r.y,\n\t}\n\treturn &s\n}\n\nfunc crossProd(l, r *Point) float64 {\n\treturn l.x*r.y - r.x*l.y\n}\n\nfunc direction(pi, pj, pk *Point) float64 {\n\treturn crossProd(sub(pk, pi), sub(pj, pi))\n}\n\nfunc readPoint() *Point {\n\tx, _ := nextFloat64()\n\ty, _ := nextFloat64()\n\tpoint := Point{\n\t\tx: x,\n\t\ty: y,\n\t}\n\treturn &point\n}\n\nfunc onSegment(pi, pj, pk *Point) bool {\n\treturn min(pi.x, pj.x) <= pk.x && pk.x <= max(pi.x, pj.x) && min(pi.y, pj.y) <= pk.y && pk.y <= max(pi.y, pj.y)\n}\n\nfunc segmentsIntersect(p1, p2, p3, p4 *Point) bool {\n\td1 := direction(p3, p4, p1)\n\td2 := direction(p3, p4, p2)\n\td3 := direction(p1, p2, p3)\n\td4 := direction(p1, p2, p4)\n\n\t// fmt.Println(d1, d2, d3, d4)\n\tif ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || d3 < 0 && d4 > 0) {\n\t\treturn true\n\t} else if d1 == 0 && onSegment(p3, p4, p1) {\n\t\treturn true\n\t} else if d2 == 0 && onSegment(p3, p4, p2) {\n\t\treturn true\n\t} else if d3 == 0 && onSegment(p1, p2, p3) {\n\t\treturn true\n\t} else if d4 == 0 && onSegment(p1, p2, p4) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnQueries := nextInt()\n\n\tfor iQuery := 0; iQuery < nQueries; iQuery++ {\n\t\tp0 := readPoint()\n\t\tp1 := readPoint()\n\t\tp2 := readPoint()\n\t\tp3 := readPoint()\n\n\t\tif segmentsIntersect(p0, p1, p2, p3) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "module Point = struct\n\n  type t = { x : float; y : float }\n\n  let make x y = { x; y }\n\n  let equal_p a b = abs_float (a.x -. b.x) < 1e-10 && abs_float (a.y -. b.y) < 1e-10\n\n  let sum a b = { x = a.x +. b.x; y = a.y +. b.y }\n\n  let diff a b = { x = a.x -. b.x; y = a.y -. b.y }\n\n  let multi p k = { x = p.x *. k; y = p.y *. k }\n\n  let div p k = { x = p.x /. k; y = p.y /. k }\n\n  let norm p = p.x *. p.x +. p.y *. p.y\n\n  let abs p = norm p |> sqrt\n\n  let dot a b = a.x *. b.x +. a.y *. b.y\n\n  let cross a b = a.x *. b.y -. a.y *. b.x\n\n  let project p1 p2 p =\n    let base = diff p2 p1 in\n    dot (diff p p1) base /. norm base\n    |> multi base\n    |> sum p1\n\n  let reflect p1 p2 p =\n    multi (diff (project p1 p2 p) p) 2.\n    |> sum p\n\n  let parallel_p (p0, p1) (p2, p3) =\n    let a = diff p0 p1 in\n    let b = diff p2 p3 in\n    cross a b = 0.\n\n  let orthogonal_p (p0, p1) (p2, p3) =\n    let a = diff p0 p1 in\n    let b = diff p2 p3 in\n    dot a b = 0.\n\nend\n\nmodule IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_fs () = read_line () |> split_on_char ' ' |> List.map float_of_string\n\nend\n\nopen Point\n\nlet eps = 1e-10\n\nlet ccw p0 p1 p2 =\n  let a = diff p1 p0 in\n  let b = diff p2 p0 in\n  let c = cross a b in\n  if c > eps then 1\n  else if c < (-. eps) then (-1)\n  else if dot a b < (-. eps) then 2\n  else if norm a < norm b then (-2)\n  else 0\n\nlet intersect_p (p0, p1) (p2, p3) =\n  ccw p0 p1 p2 * ccw p0 p1 p3 <= 0 && ccw p2 p3 p0 * ccw p2 p3 p1 <= 0\n\nlet () =\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    match IO.read_fs () with\n    | x0 :: y0 :: x1 :: y1 :: x2 :: y2 :: x3 :: y3 :: _ ->\n      let s = (make x0 y0, make x1 y1) in\n      let t = (make x2 y2, make x3 y3) in\n      print_endline (if intersect_p s t then \"1\" else \"0\")\n    | _ -> assert false\n  done"
  },
  {
    "language": "OCaml",
    "code": "let () =\n  let cross (x0,y0) (x1,y1) = x0*.y1-.x1*.y0 and\n      inner (x0,y0) (x1,y1) = x0*.x1+.y0*.y1 and\n      norm (x,y) = x*.x+.y*.y in\n  let check_lines v0 v1 =\n       if cross v0 v1 > (1e-10) then -1\n       else if cross v0 v1 < -.(1e-10) then 1\n       else if inner v0 v1 < -.(1e-10) then 1\n       else if norm v0 < norm v1 then 1\n       else 0\n  in\n  let intersect p0x p0y p1x p1y p2x p2y p3x p3y =\n    (check_lines (p2x-.p0x, p2y-.p0y) (p1x-.p0x, p1y-.p0y)) * (check_lines (p3x-.p0x, p3y-.p0y) (p1x-.p0x, p1y-.p0y)) <= 0 &&\n      (check_lines (p1x-.p2x, p1y-.p2y) (p3x-.p2x, p3y-.p2y)) * (check_lines (p0x-.p2x, p0y-.p2y) (p3x-.p2x, p3y-.p2y)) <= 0\n  in\n  let n = Scanf.scanf \"%d\\n\" (fun x -> x) in\n  let rec read = function\n      0 -> ()\n    | i ->\n       let (p0x,p0y,p1x,p1y,p2x,p2y,p3x,p3y) =\n         Scanf.scanf \" %f %f %f %f %f %f %f %f\\n\" (fun s t u v w x y z -> (s,t,u,v,w,x,y,z))\n       in\n       if intersect p0x p0y p1x p1y p2x p2y p3x p3y then print_endline \"1\"\n       else print_endline \"0\"\n       ;read (i-1)\n  in read n\n;;"
  },
  {
    "language": "OCaml",
    "code": "let () =\n  let cross (x0,y0) (x1,y1) = x0*.y1-.x1*.y0 and\n      inner (x0,y0) (x1,y1) = x0*.x1+.y0*.y1 and\n      norm (x,y) = x*.x+.y*.y in\n  let check_lines v0 v1 =\n       if cross v0 v1 > (1e-10) then -1\n       else if cross v0 v1 < -.(1e-10) then 1\n       else if inner v0 v1 < -.(1e-10) then 1\n       else if norm v0 < norm v1 then 0\n       else 0\n  in\n  let intersect p0x p0y p1x p1y p2x p2y p3x p3y =\n    ((check_lines (p2x-.p0x, p2y-.p0y) (p1x-.p0x, p1y-.p0y)) * (check_lines (p3x-.p0x, p3y-.p0y) (p1x-.p0x, p1y-.p0y)) <= 0) &&\n      ((check_lines (p1x-.p2x, p1y-.p2y) (p3x-.p2x, p3y-.p2y)) * (check_lines (p0x-.p2x, p0y-.p2y) (p3x-.p2x, p3y-.p2y)) <= 0)\n  in\n  let n = Scanf.scanf \"%d\\n\" (fun x -> x) in\n  let rec read = function\n      0 -> ()\n    | i ->\n       let (p0x,p0y,p1x,p1y,p2x,p2y,p3x,p3y) =\n         Scanf.scanf \" %f %f %f %f %f %f %f %f\\n\" (fun s t u v w x y z -> (s,t,u,v,w,x,y,z))\n       in\n       if intersect p0x p0y p1x p1y p2x p2y p3x p3y then print_endline \"1\"\n       else print_endline \"0\"\n       ;read (i-1)\n  in read n\n;;"
  },
  {
    "language": "OCaml",
    "code": "module Point = struct\n\n  type t = { x : float; y : float }\n\n  let make x y = { x; y }\n\n  let equal_p a b = abs_float (a.x -. b.x) < 1e-10 && abs_float (a.y -. b.y) < 1e-10\n\n  let sum a b = { x = a.x +. b.x; y = a.y +. b.y }\n\n  let diff a b = { x = a.x -. b.x; y = a.y -. b.y }\n\n  let multi p k = { x = p.x *. k; y = p.y *. k }\n\n  let div p k = { x = p.x /. k; y = p.y /. k }\n\n  let norm p = p.x *. p.x +. p.y *. p.y\n\n  let abs p = norm p |> sqrt\n\n  let dot a b = a.x *. b.x +. a.y *. b.y\n\n  let cross a b = a.x *. b.y -. a.y *. b.x\n\n  let project p1 p2 p =\n    let base = diff p2 p1 in\n    dot (diff p p1) base /. norm base\n    |> multi base\n    |> sum p1\n\n  let reflect p1 p2 p =\n    multi (diff (project p1 p2 p) p) 2.\n    |> sum p\n\n  let parallel_p (p0, p1) (p2, p3) =\n    let a = diff p0 p1 in\n    let b = diff p2 p3 in\n    cross a b = 0.\n\n  let orthogonal_p (p0, p1) (p2, p3) =\n    let a = diff p0 p1 in\n    let b = diff p2 p3 in\n    dot a b = 0.\n\nend\n\nmodule IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_fs () = read_line () |> split_on_char ' ' |> List.map float_of_string\n\nend\n\nopen Point\n\ntype clock =\n  | Counter_clockwise\n  | Clockwise\n  | On_segment\n\nlet eps = 1e-10\n\nlet ccw p0 p1 p2 =\n  let a = diff p1 p0 in\n  let b = diff p2 p0 in\n  let c = cross a b in\n  if c > eps then Counter_clockwise\n  else if c < (-. eps) then Clockwise\n  else On_segment\n\nlet intersect_p (p0, p1) (p2, p3) =\n  let a = ccw p0 p1 p2 in\n  let b = ccw p0 p1 p3 in\n  let c = ccw p2 p3 p0 in\n  let d = ccw p2 p3 p1 in\n  if a = Counter_clockwise && b = Counter_clockwise\n    || c = Counter_clockwise && d = Counter_clockwise\n  then false\n  else true\n\nlet () =\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    match IO.read_fs () with\n    | x0 :: y0 :: x1 :: y1 :: x2 :: y2 :: x3 :: y3 :: _ ->\n      let s = (make x0 y0, make x1 y1) in\n      let t = (make x2 y2, make x3 y3) in\n      print_endline (if intersect_p s t then \"1\" else \"0\")\n    | _ -> assert false\n  done"
  },
  {
    "language": "OCaml",
    "code": "let () =\n  let cross (x0,y0) (x1,y1) = x0*.y1-.x1*.y0 and\n      inner (x0,y0) (x1,y1) = x0*.x1+.y0*.y1 and\n      norm (x,y) = x*.x+.y*.y in\n  let check_lines v1 v0 =\n       if cross v0 v1 > (1e-10) then -1\n       else if cross v0 v1 < -.(1e-10) then 1\n       else if inner v0 v1 < -.(1e-10) then 1\n       else if norm v0 < norm v1 then 1\n       else 0\n  in\n  let intersect p0x p0y p1x p1y p2x p2y p3x p3y =\n    (check_lines (p2x-.p0x, p2y-.p0y) (p1x-.p0x, p1y-.p0y)) * (check_lines (p3x-.p0x, p3y-.p0y) (p1x-.p0x, p1y-.p0y)) <= 0 &&\n      (check_lines (p1x-.p2x, p1y-.p2y) (p3x-.p2x, p3y-.p2y)) * (check_lines (p0x-.p2x, p0y-.p2y) (p3x-.p2x, p3y-.p2y)) <= 0\n  in\n  let n = Scanf.scanf \"%d\\n\" (fun x -> x) in\n  let rec read = function\n      0 -> ()\n    | i ->\n       let (p0x,p0y,p1x,p1y,p2x,p2y,p3x,p3y) =\n         Scanf.scanf \" %f %f %f %f %f %f %f %f\\n\" (fun s t u v w x y z -> (s,t,u,v,w,x,y,z))\n       in\n       if intersect p0x p0y p1x p1y p2x p2y p3x p3y then print_endline \"1\"\n       else print_endline \"0\"\n       ;read (i-1)\n  in read n\n;;"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nbool isIntersectLineSegments(Vec2 a, Vec2 b, Vec2 c, Vec2 d) {\n    auto s = (b - a).cross(c - a) * (b - a).cross(d - a);\n    auto t = (d - c).cross(a - c) * (d - c).cross(b - c);\n    return s <= 0 && t <= 0;\n}\n\nvoid main() {\n    int q = readint();\n    for (int i = 0; i < q; i++) {\n        auto xs = readints();\n        auto a = Vec2(xs[0], xs[1]);\n        auto b = Vec2(xs[2], xs[3]);\n        auto c = Vec2(xs[4], xs[5]);\n        auto d = Vec2(xs[6], xs[7]);\n\n        if (isIntersectLineSegments(a, b, c, d))\n            writeln(1);\n        else\n            writeln(0);\n    }\n}\n\nstruct Vec2 {\n    immutable double x;\n    immutable double y;\n\n    this(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 opAdd(Vec2 other) {\n        return Vec2(this.x + other.x, this.y + other.y);\n    }\n\n    Vec2 opSub(Vec2 other) {\n        return Vec2(this.x - other.x, this.y - other.y);\n    }\n\n    Vec2 opMul(double d) {\n        return Vec2(this.x * d, this.y * d);\n    }\n\n    double dot(Vec2 other) {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    double cross(Vec2 other) {\n        return this.x * other.y - other.x * this.y;\n    }\n\n    double mag() {\n        return sqrt(magSq());\n    }\n\n    double magSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    Vec2 normalize() {\n        auto m = mag();\n        if (m != 0 && m != 1)\n            return Vec2(this.x / m, this.y / m);\n        return this;\n    }\n\n    static double distance(Vec2 a, Vec2 b) {\n        return (a - b).mag();\n    }\n}"
  },
  {
    "language": "D",
    "code": "#include<complex>\n#include<iostream>\n\nusing namespace std;\n\n\ntypedef complex<double> P;\n\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn (cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nint main() {\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tdouble x0, y0, x1, y1, x2, y2, x3, y3;\n\t\tcin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP p0(x0, y0), p1(x1, y1), p2(x2, y2), p3(x3, y3);\n\t\tcout << is_intersected_ls(p0, p1, p2, p3) << endl;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nbool isIntersectLineSegments(Vec2 a, Vec2 b, Vec2 c, Vec2 d) {\n    auto s = (b - a).cross(c - a) * (b - a).cross(d - a);\n    auto t = (d - c).cross(a - c) * (d - c).cross(b - c);\n\n    return s < 0 && t < 0;\n}\n\nvoid main() {\n    int q = readint();\n    for (int i = 0; i < q; i++) {\n        auto xs = readints();\n        auto a = Vec2(xs[0], xs[1]);\n        auto b = Vec2(xs[2], xs[3]);\n        auto c = Vec2(xs[4], xs[5]);\n        auto d = Vec2(xs[6], xs[7]);\n\n        if (isIntersectLineSegments(a, b, c, d))\n            writeln(1);\n        else\n            writeln(0);\n    }\n}\n\nstruct Vec2 {\n    immutable double x;\n    immutable double y;\n\n    this(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 opAdd(Vec2 other) {\n        return Vec2(this.x + other.x, this.y + other.y);\n    }\n\n    Vec2 opSub(Vec2 other) {\n        return Vec2(this.x - other.x, this.y - other.y);\n    }\n\n    Vec2 opMul(double d) {\n        return Vec2(this.x * d, this.y * d);\n    }\n\n    double dot(Vec2 other) {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    double cross(Vec2 other) {\n        return this.x * other.y - other.x * this.y;\n    }\n\n    double mag() {\n        return sqrt(magSq());\n    }\n\n    double magSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    Vec2 normalize() {\n        auto m = mag();\n        if (m != 0 && m != 1)\n            return Vec2(this.x / m, this.y / m);\n        return this;\n    }\n\n    static double distance(Vec2 a, Vec2 b) {\n        return (a - b).mag();\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nbool isOnSegment(Vec2 p, Vec2 a, Vec2 b) {\n    auto ab = b - a;\n    auto ap = p - a;\n\n    if (ab.cross(ap) != 0)\n        return false;\n\n    // ab ??¨ ap ????????????\n    if (ab.dot(ap) < 0)\n        return false;\n\n    // p ??? ab ?????????????????????\n    if (ab.magSq() >= ap.magSq())\n        return true;\n\n    return false;\n}\n\nbool isIntersectLineSegments(Vec2 a, Vec2 b, Vec2 c, Vec2 d) {\n    auto s = (b - a).cross(c - a) * (b - a).cross(d - a);\n    auto t = (d - c).cross(a - c) * (d - c).cross(b - c);\n\n    if (s < 0 && t < 0)\n        return true;\n\n    // ???????????????????????????\n    if (isOnSegment(c, a, b) || isOnSegment(d, a, b) || isOnSegment(a, c, d) || isOnSegment(b, c, d)) {\n        return true;\n    }\n    return false;\n}\n\nvoid main() {\n    int q = readint();\n    for (int i = 0; i < q; i++) {\n        auto xs = readints();\n        auto a = Vec2(xs[0], xs[1]);\n        auto b = Vec2(xs[2], xs[3]);\n        auto c = Vec2(xs[4], xs[5]);\n        auto d = Vec2(xs[6], xs[7]);\n\n        if (isIntersectLineSegments(a, b, c, d))\n            writeln(1);\n        else\n            writeln(0);\n    }\n}\n\nstruct Vec2 {\n    immutable double x;\n    immutable double y;\n\n    this(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 opAdd(Vec2 other) {\n        return Vec2(this.x + other.x, this.y + other.y);\n    }\n\n    Vec2 opSub(Vec2 other) {\n        return Vec2(this.x - other.x, this.y - other.y);\n    }\n\n    Vec2 opMul(double d) {\n        return Vec2(this.x * d, this.y * d);\n    }\n\n    double dot(Vec2 other) {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    double cross(Vec2 other) {\n        return this.x * other.y - other.x * this.y;\n    }\n\n    double mag() {\n        return sqrt(magSq());\n    }\n\n    double magSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    Vec2 normalize() {\n        auto m = mag();\n        if (m != 0 && m != 1)\n            return Vec2(this.x / m, this.y / m);\n        return this;\n    }\n\n    static double distance(Vec2 a, Vec2 b) {\n        return (a - b).mag();\n    }\n}"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef isOn(l,m):\n    a = dif(l.e,l.s);b = dif(m.s,l.s);c = dif(m.e,l.s)\n    d = dif(l.e,m.s);e = dif(l.s,m.s);f = dif(l.e,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    \ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    if isOn(l,m):return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:\n        return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import starmap\nreadline = sys.stdin.readline\nEPS = 1e-9\nONLINE_FRONT = -2\nCLOCKWISE = -1\nON_SEGMENT = 0\nCOUNTER_CLOCKWISE = 1\nONLINE_BACK = 2\nclass Segment(object):\n    __slots__ = ('fi', 'se')\n    def __init__(self, fi, se):\n        self.fi = fi\n        self.se = se\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\ndef norm(base):\n    return abs(base) ** 2\ndef project(s, p2):\n    base = s.fi - s.se\n    r = dot(p2 - s.fi, base) / norm(base)\n    return s.fi + base * r\ndef reflect(s, p):\n    return p + (project(s, p) - p) * 2.0\ndef ccw(p1, p2, p3):\n    a = p2 - p1\n    b = p3 - p1\n    if cross(a, b) > EPS: return 1\n    if cross(a, b) < -EPS: return -1\n    if dot(a, b) < -EPS: return 2\n    if norm(a) < norm(b): return -2\n    return 0\ndef intersect4(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0)\ndef intersect2(s1, s2):\n    return intersect4(s1.fi, s1.se, s2.fi, s2.se)\ndef getDistance(a, b):  return abs(a - b)\ndef getDistanceLP(l, p):\n    return abs(cross(l.se - l.fi, p - l.fi) / abs(l.se - l.fi))\ndef getDistanceSP(s, p):\n    if dot(s.se - s.fi, p - s.fi) < 0.0: return abs(p - s.fi)\n    if dot(s.fi - s.se, p - s.se) < 0.0: return abs(p - s.se)\n    return getDistanceLP(s, p)\ndef getDistances(s1, s2):\n    if intersect2(s1, s2): return 0.0\n    return min(getDistanceSP(s1, s2.fi), getDistanceSP(s1, s2.se),\n               getDistanceSP(s2, s1.fi), getDistanceSP(s2, s1.se))\nn = int(readline())\nfor _ in [0] * n:\n    p0, p1, p2, p3 = starmap(complex, zip(*[map(int, input().split())] * 2))\n    print(1 if intersect4(p0, p1, p2, p3) else 0)"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Vector:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n        \n    def __add__(self,other):\n        return Vector(self.x+other.x,self.y+other.y)\n    \n    def __sub__(self,other):\n        return Vector(self.x-other.x,self.y-other.y)\n    \n    def __mul__(self,scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n    def __rmul__(self, scalar):\n        return Vector(self.x*scalar,self.y*scalar)\n   \n    def __repr__(self):\n        return str([self.x,self.y])\n        \n    def norm_2(self):\n        return dot(self,self)\n    \n    def norm(self):\n        return math.sqrt(self.norm_2())\n    \ndef v_sum(v1,v2):\n    return Vector(v1.x+v2.x,v1.y+v2.y) \ndef scalar_multi(k,v):\n    return Vector(k*v.x,k*v.y)\ndef v_diff(v1,v2):\n    return v_sum(v1,scalar_multi(-1,v2))\n    \ndef dot(vector1,vector2):\n    return vector1.x*vector2.x+vector1.y*vector2.y\n\ndef cross(vector1,vector2):\n    return vector1.x*vector2.y-vector1.y*vector2.x\n\ndef is_crossed(p,q,s,t):\n    a = q-p\n    b = t-s\n    v = s-p\n    w = t-p\n    x = p-s\n    y = q-s\n    if cross(a,v)*cross(a,w)<=0 and cross(b,x)*cross(b,y)<=0:\n        if cross(a,v) == cross(a,w) == cross(b,x) == cross(b,y) == 0:\n            if 0<=dot(a,v)<=a.norm_2() or 0<=dot(a,w)<=a.norm_2()  or 0<=dot(b,x)<=b.norm_2() or 0<=dot(b,y)<=b.norm_2():\n                return True\n            else:\n                return False\n        else:    \n            return True\n    else:\n        return False\n        \nq = int(input())\nfor i in range(q):\n    x1,y1,x2,y2,x3,y3,x4,y4 = map(int,input().split())\n    p1 = Vector(x1,y1)\n    p2 = Vector(x2,y2)\n    p3 = Vector(x3,y3)\n    p4 = Vector(x4,y4)\n    \n    if is_crossed(p1,p2,p3,p4):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c):\n        print(1)\n    elif cross(a,b) == 0 and cross(a,c) == 0:\n        if ( not isOn(c,a) and isOn(b,a)) or (isOn(c,a) and not isOn(b,a)) :\n            print(1)\n        else:\n            print(0)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1)"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    elif l.s == m.e or l.s == m.s or l.e == m.e or l.e == m.s:return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(b,a) ; l2 = Line(d,c)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# CGL_2_B: Segments/Lines - Intersection\n\nfrom math import sqrt\n\n\nclass Segment:\n    def __init__(self, p0, p1):\n        self.end_points = (p0, p1)\n\n    def intersect(self, other):\n        p0, p1 = self.end_points\n        p2, p3 = other.end_points\n\n        if convex(p0, p2, p1, p3):\n            return True\n        else:\n            if (p0 in other or p1 in other\n                    or p2 in self or p3 in self):\n                return True\n\n        return False\n\n    def __contains__(self, p):\n        p0, p1 = self.end_points\n        x0, y0 = p0\n        x1, y1 = p1\n        x, y = p\n        v = (x1-x0, y1-y0)\n        v0 = (x-x0, y-y0)\n        v1 = (x-x1, y-y1)\n        if dot(orthogonal(v0), v1) == 0:\n            if abs(length(v0) + length(v1) - length(v)) < 1e-10:\n                return True\n        return False\n\n\ndef dot(v1, v2):\n    x1, y1 = v1\n    x2, y2 = v2\n    return x1 * x2 + y1 * y2\n\n\ndef orthogonal(v):\n    x, y = v\n    return -y, x\n\n\ndef length(v):\n    x, y = v\n    return sqrt(x**2 + y**2)\n\n\ndef convex(p0, p1, p2, p3):\n    ret = []\n    for pa, pb, pc in zip([p0, p1, p2, p3],\n                          [p1, p2, p3, p0],\n                          [p2, p3, p0, p1]):\n        xa, ya = pa\n        xb, yb = pb\n        xc, yc = pc\n        v1 = (xb - xa, yb - ya)\n        v2 = (xc - xb, yc - yb)\n        ret.append(dot(orthogonal(v1), v2))\n\n    return all([d > 0 for d in ret]) or all([d < 0 for d in ret])\n\n\ndef run():\n    q = int(input())\n\n    for _ in range(q):\n        x0, y0, x1, y1, x2, y2, x3, y3 = [int(i) for i in input().split()]\n        s1 = Segment((x0, y0), (x1, y1))\n        s2 = Segment((x2, y2), (x3, y3))\n        if s1.intersect(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nq = int(input())\n\ndef norm(a):\n    return sqrt(a[0] ** 2 + a[1] ** 2)\n\ndef dot(a, b):\n    return sum([i * j for i,j in zip(a, b)])\n\ndef sub(a, b):\n    return [a[0] - b[0],a[1] - b[1]]\n\ndef cross(a, b):\n    return  a[0] * b[1] - a[1] * b[0]\n\ndef ccw(a, b, c):\n    x = sub(b, a)\n    y = sub(c, a)\n    if cross(x, y) > 0: return 1\n    if cross(x, y) < 0: return -1\n    if dot(x, y) < 0: return 2\n    if norm(a) < norm(b): return -2\n    return 0\n\ndef intersect(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and \\\n           ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\nfor i in range(q):\n    xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int, input().split())\n    print(1 if intersect([xp0, yp0], [xp1, yp1], [xp2, yp2], [xp3, yp3]) else 0)"
  },
  {
    "language": "Python",
    "code": "EPS = 10**(-9)\ndef is_equal(a,b):\n    return abs(a-b) < EPS\n\ndef norm(v,i=2):\n    import math\n    ret = 0\n    n = len(v)\n    for j in range(n):\n        ret += abs(v[j])**i\n    return math.pow(ret,1/i)\n\nclass Vector(list):\n    \"\"\"\n    ベクトルクラス\n    対応演算子\n    +  : ベクトル和 \n    -  : ベクトル差\n    *  : スカラー倍、または内積\n    /  : スカラー除法\n    ** : 外積\n    += : ベクトル和\n    -= : ベクトル差\n    *= : スカラー倍\n    /= : スカラー除法\n\n    メソッド\n    self.norm(i) : L{i}ノルムを計算\n    \"\"\"\n    def __add__(self,other):\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i) + other.__getitem__(i)\n        return self.__class__(ret)\n    \n    def __radd__(self,other):\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = other.__getitem__(i) + super().__getitem__(i)\n        return self.__class__(ret)\n    \n    def __iadd__(self, other):\n        n = len(self)\n        for i in range(n):\n            self[i] += other.__getitem__(i)\n        return self\n\n    def __sub__(self,others):\n        n = len(self) \n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i) - others.__getitem__(i)\n        return self.__class__(ret)\n\n    def __iadd__(self, other):\n        n = len(self)\n        for i in range(n):\n            self[i] -= other.__getitem__(i)\n        return self\n\n    def __rsub__(self,others):\n        n = len(self) \n        ret = [0]*n\n        for i in range(n):\n            ret[i] = others.__getitem__(i) - super().__getitem__(i)\n        return self.__class__(ret)\n    \n    def __mul__(self,other):\n        n = len(self)\n        if isinstance(other,list):\n            ret = 0\n            for i in range(n):\n                ret += super().__getitem__(i)*other.__getitem__(i)\n            return ret\n        else:\n            ret = [0]*n\n            for i in range(n):\n                ret[i] = super().__getitem__(i)*other\n            return self.__class__(ret)\n\n    def __rmul__(self,other):\n        n = len(self)\n        if isinstance(other,list):\n            ret = 0\n            for i in range(n):\n                ret += super().__getitem__(i)*other.__getitem__(i)\n            return ret\n        else:\n            ret = [0]*n\n            for i in range(n):\n                ret[i] = super().__getitem__(i)*other\n            return self.__class__(ret)\n    \n    \n    def __truediv__(self,other):\n        \"\"\"\n        ベクトルのスカラー除法\n        Vector/scalar\n        \"\"\"\n        n = len(self)\n        ret = [0]*n\n        for i in range(n):\n            ret[i] = super().__getitem__(i)/other\n        return self.__class__(ret)\n    \n    def norm(self,i):\n        \"\"\"\n        L{i}ノルム\n        self.norm(i)\n        \"\"\"\n        return norm(self,i)\n    \n    def __pow__(self,other):\n        \"\"\"\n        外積\n        self**other\n        \"\"\"\n        n = len(self)\n        ret = [0]*3\n        x = self[:]\n        y = other[:]\n        if n == 2:\n            x.append(0)\n            y.append(0)\n        if n == 2 or n == 3:\n            for i in range(3):\n                ret[0],ret[1],ret[2] = x[1]*y[2]-x[2]*y[1],x[2]*y[0]-x[0]*y[2],x[0]*y[1]-x[1]*y[0]\n            ret = Vector(ret)\n            if n == 2:\n                return ret\n            else:\n                return ret\n\nclass Segment:\n    \"\"\"\n    線分クラス\n    \"\"\"\n    def __init__(self,v1,v2):\n        self.v1 = v1\n        self.v2 = v2\n    \n    def length(self):\n        return norm(self.v1-self.v2)\n\n    def get_unit_vec(self):\n        #方向単位ベクトル\n        dist = norm(self.v2-self.v1)\n        if dist != 0:\n            return (self.v2-self.v1)/dist\n        else:\n            return False\n    \n    def projection(self,vector):\n        #射影点(線分を直線と見たときの)\n        unit_vec = self.get_unit_vec()\n        t = unit_vec*(vector-self.v1)\n        return self.v1 + t*unit_vec\n    \n    def is_vertical(self,other):\n        #線分の直交判定\n        return is_equal(0,self.get_unit_vec()*other.get_unit_vec())\n    \n    def is_horizontal(self,other):\n        #線分の平行判定\n        return is_equal(0,self.get_unit_vec()**other.get_unit_vec())\n    \n    def reflection(self,vector):\n        #反射点(線分を直線と見たときの)\n        projection = self.projection(vector)\n        v = projection - vector\n        return projection + vector\n    \n    def include(self,vector):\n        #線分が点を含むか否か\n        proj = self.projection(vector)\n        if not is_equal(norm(proj-vector),0):\n            return False\n        else:\n            n = len(self.v1)\n            f = True\n            for i in range(n):\n                f &= ((self.v1[i] <= vector[i] <= self.v2[i]) or (self.v2[i] <= vector[i] <=self.v1[i]))\n            return f\n    \n    def distance(self,other):\n        #点と線分の距離\n        if isinstance(other,Vector):\n            proj = self.projection(other)\n            if self.include(proj):\n                return norm(proj-other)\n                ret = []\n                ret.append(norm(self.v1-other))\n                ret.append(norm(self.v2-other))\n                return min(ret)\n\n    def ccw(self,vector):\n        \"\"\"\n        線分に対して点が反時計回りの位置にある(1)か時計回りの位置にある(-1)か線分上にある(0)か\n        \"\"\"\n        direction = self.v2 - self.v1\n        v = vector - self.v1\n        if self.include(vector):\n            return 0\n        else:\n            cross = direction**v\n            if cross[2] <= 0:\n                return 1\n            else:\n                return -1\n    \n    def intersect(self,segment):\n        ccw12 = self.ccw(segment.v1)\n        ccw13 = self.ccw(segment.v2)\n        ccw20 = segment.ccw(self.v1)\n        ccw21 = segment.ccw(self.v2)\n\n        if ccw12*ccw13*ccw20*ccw21 == 0:\n            return True\n        else:\n            if ccw12*ccw13 < 0 and ccw20*ccw21 < 0:\n                return True\n            else:\n                return False\n\n\n\n\n\n\n\nclass Line(Segment):\n    \"\"\"\n    直線クラス\n    \"\"\"\n    #直線上に点が存在するか否か\n    def include(self,vector):\n        proj = self.projection(vector)\n        return is_equal(norm(proj-vector),0)\n\n\nq = int(input())\nP0s,P1s,P2s,P3s = [0]*q,[0]*q,[0]*q,[0]*q\nfor i in range(q):\n    tmp = list(map(int, input().split()))\n    P0s[i],P1s[i],P2s[i],P3s[i] = Vector(tmp[0:2]),Vector(tmp[2:4]),Vector(tmp[4:6]),Vector(tmp[6:8])\n\nfor i in range(q):\n    p0,p1,p2,p3 = P0s[i],P1s[i],P2s[i],P3s[i]\n    S1 = Segment(p0,p1)\n    S2 = Segment(p2,p3)\n\n    if S1.intersect(S2):\n        print(1)\n    else:\n        print(0)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(other / self.x, other / self.y)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        from math import sqrt\n        return sqrt(self.norm())\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(other / self.x, other / self.y)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return Vector.dot(a, b) == 0.0\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return Vector.cross(a, b) == 0.0\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, c=Point(), r=0.0):\n        self.c = c\n        self.r = r\n\n\ndef ccw(p0, p1, p2):\n    a = Vector(p1 - p0)\n    b = Vector(p2 - p0)\n    epsilon = 1e-10\n    if Vector.cross(a, b) > epsilon:\n        return 1 # 'COUNTER_CLOCKWISE'\n    elif Vector.cross(a, b) < -epsilon:\n        return -1 # 'CLOCKWISE'\n    elif Vector.dot(a, b) < -epsilon:\n        return 2 # 'ONLINE_BACK'\n    elif a.norm() < b.norm():\n        return -2 # 'ONLINE_FRONT'\n    else:\n        return 0 # 'ON_SEGMENT'\n\n\ndef intersect(p0, p1, p2, p3):\n    ans1 = ccw(p0, p1, p2) * ccw(p0, p1, p3)\n    ans2 = ccw(p2, p3, p0) * ccw(p2, p3, p1)\n    return ans1 <= 0 and ans2 <= 0\n\n\ndef main(args):\n    q = int(input())\n    for _ in range(q):\n        x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, input().split())\n        p0 = Point(x_p0, y_p0)\n        p1 = Point(x_p1, y_p1)\n        p2 = Point(x_p2, y_p2)\n        p3 = Point(x_p3, y_p3)\n        result = intersect(p0, p1, p2, p3)\n        print(int(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import math\n\nEPS = 1e-10\n\ndef equals(a, b):\n    return abs(a - b) < EPS\n\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __add__(self, p):\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, a):\n        return Point(self.x * a, self.y * a)\n\n    def __rmul__(self, a):\n        return self * a\n\n    def __truediv__(self, a):\n        return Point(self.x / a, self.y / a)\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\n    def __lt__(self, p):\n        if self.x != p.x:\n            return self. x < p.x\n        else:\n            return self.y < p.y\n\n    def __eq__(self, p):\n        return equals(self.x, p.x) and equals(self.y, p.y)\n\n\nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n\ndef dot(a, b):\n    return a.x * b.x + a.y * b.y\n\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\n\ndef ccw(p0, p1, p2):\n    COUNTER_CLOCKWISE = 1\n    CLOCKWISE = -1\n    ONLINE_BACK = 2\n    ONLINE_FRONT = -2\n    ON_SEGMENT = 0\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > EPS:\n        return COUNTER_CLOCKWISE\n    if cross(a, b) < -EPS:\n        return CLOCKWISE\n    if dot(a, b) < -EPS:\n        return ONLINE_BACK\n    if a.norm() < b.norm():\n        return ONLINE_FRONT\n    return ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    p1 = s1.p1\n    p2 = s1.p2\n    p3 = s2.p1\n    p4 = s2.p2\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0)\n\n\nif __name__ == '__main__':\n    q = int(input())\n    ans = []\n    for i in range(q):\n        x0, y0, x1, y1, x2, y2, x3, y3 = [int(v) for v in input().split()]\n        s1 = Segment(Point(x0, y0), Point(x1, y1))\n        s2 = Segment(Point(x2, y2), Point(x3, y3))\n        ans.append(intersect(s1, s2))\n\n    for v in ans:\n        print(int(v))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        self.intersept = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n            self.intersept = self.p1.y - self.slope*self.p1.x\n\n    def is_in_range(self, x, y):\n        return ((x - self.p1.x)*(x - self.p2.x) <= 0 and (y - self.p1.y)*(y - self.p2.y) <= 0)\n\n    def is_intersect(self, seg):\n        if self.slope == seg.slope: return False\n        slope_diff = seg.slope - self.slope\n        if self.slope == float('inf'):\n            x = self.p1.x\n        elif seg.slope == float('inf'):\n            x = seg.p1.x\n        else:\n            x = -(seg.intersept - self.intersept)/slope_diff\n        y = self.slope * x + self.intersept\n        if seg.is_in_range(x, y) and self.is_in_range(x, y): return True\n        return False\n\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "def dot3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef dist2(A, B):\n    ax, ay = A; bx, by = B\n    return (ax - bx) ** 2 + (ay - by) ** 2\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        E0 = dot3(P0, P1, Q0)\n        E1 = dot3(P0, P1, Q1)\n        if not E0 < E1:\n            E0, E1 = E1, E0\n        return E0 <= dist2(P0, P1) and 0 <= E1\n    return C0 * C1 <= 0 and D0 * D1 <= 0\nfor q in range(int(input())):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, input().split())\n    print(+is_intersection((x0, y0), (x1, y1), (x2, y2), (x3, y3)))"
  },
  {
    "language": "Python",
    "code": "class Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n\n    def is_intersect(self, seg):\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        e = (self.p1.x - seg.p1.x)*(self.p2.x - seg.p2.x)\n        f = (self.p1.x - seg.p2.x)*(self.p2.x - seg.p1.x)\n        g = (self.p1.y - seg.p1.y)*(self.p2.y - seg.p2.y)\n        h = (self.p1.y - seg.p2.y)*(self.p2.y - seg.p1.y)\n        return a*b <= 0 and c*d <= 0 and (e <= 0 or f <= 0) and (g <= 0 or h <= 0)\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : return False\n    \ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    if cross(a,d) == 0 and (isOn(b,a) or isOn(c,a) or isOn(e,d) or isOn(f,d)):\n        print(isOn(b,a),isOn(c,a),isOn(e,d),isOn(f,d))\n        print(\"here1\")\n        return True\n    elif cross(a,b) * cross(a,c) > 0 or cross(d,e) * cross(d,f) > 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    q = int(readline())\n    for i in range(q):\n        xy = map(int, readline().split())\n        p0, p1, p2, p3 = [x + y * 1j for x, y in zip(*[xy] * 2)]\n        print(1 if is_intersected_ls(p0, p1, p2, p3) else 0)\n\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < 1e-10) and (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < 1e-10)\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\nmain()"
  },
  {
    "language": "Python",
    "code": "EPS = 1e-4\n\n\n#外積\ndef OuterProduct(one, two):\n\ttmp = one.conjugate() * two\n\treturn tmp.imag\n\n#内積\ndef InnerProduct(one, two):\n\ttmp = one.conjugate() * two\n\treturn tmp.real\n\n#点が直線上にあるか\ndef IsOnLine(point, begin, end):\n\treturn abs(OuterProduct(begin-point, end-point)) <= EPS\n\n#点が線分上にあるか\ndef IsOnSegment(point, begin, end):\n\tif abs(OuterProduct(begin-point, end-point)) <= EPS and InnerProduct(begin-point, end-point) <= EPS:\n\t\treturn True\n\telse:\n\t\treturn False\n\n#3点が反時計回りか\n#一直線上のときの例外処理できていない→とりあえずF\ndef CCW(p, q, r):\n\tone, two = q-p, r-q\n\tif OuterProduct(one, two) > -EPS:\n\t\treturn True\n\telse:\n\t\treturn False\n\n#線分どうし交叉\ndef Intersect_SS(b1, e1, b2, e2):\n\tif (CCW(b1, e1, b2) != CCW(b1, e1, e2)) and (CCW(b2, e2, b1) != CCW(b2, e2, e1)):\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef solve(a, b, c, d):\n\tif IsOnSegment(a, c, d) or IsOnSegment(b, c, d) or IsOnSegment(c, a, b) or IsOnSegment(d, a, b):\n\t\treturn 1\n\telif abs(OuterProduct(b-a, d-c)) <= EPS:\n\t\treturn 0\n\telif Intersect_SS(a, b, c, d):\n\t\treturn 1\n\telse:\n\t\treturn 0\n\nn = int(input())\nfor _ in range(n):\n\tpp = list(map(int, input().split()))\n\tp = [complex(pp[i], pp[i+1]) for i in range(0, 8, 2)]\n\tprint(solve(p[0], p[1], p[2], p[3]))\n"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem CGL_2_B: Intersection\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef on_segment(p, q, r):\n    # Given three colinear points p, q, r, the function checks if\n    # point q lies on line segment 'pr'\n    return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and \\\n           q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])\n\ndef orientation(p, q, r):\n    # To find orientation of ordered triplet (p, q, r).\n    # The function returns following values\n    #   0 --> p, q and r are colinear\n    #   1 --> Clockwise\n    #   2 --> Counterclockwise\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef do_intersect(p1, q1, p2, q2):\n    # The main function that returns true if line segment 'p1q1'\n    # and 'p2q2' intersect.\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    #\n    # General case:\n    if o1 != o2 and o3 != o4:\n        return True\n    #\n    # Special Cases:\n    # \n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    # p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    #  p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    # Doesn't fall in any of the above cases:\n    return False\n\n\nn = int(input())\nfor k in range(n):\n    x1, y1, x2, y2, x3, y3, x4, y4 = [int(_) for _ in input().split()]\n    print(1 if do_intersect([x1, y1], [x2, y2], [x3, y3], [x4, y4]) else 0)"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    t = (y2-y0)*dx0 - (x2-x0)*dy0\n    tm = dx1*dy0 - dy1*dx0\n    if t < 0:\n        t = -t\n        tm = -tm\n    ov = dx0*dy1 - dy0*dx1\n    if ov == 0:\n        print 0\n    elif 0 <= s <= sm and 0 <= t <= tm:\n        print 1\n    else:\n        print 0"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c) or isOn(c,a) or isOn(b,a):\n        print(1)\n    elif cross(a,b) == 0 and cross(a,c) == 0:\n        print(0)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport math\nimport os\nimport sys\n\n\ndef main():\n    Q = read_int()\n    for _ in range(Q):\n        x0, y0, x1, y1, x2, y2, x3, y3 = read_ints()\n        print(solve(Vec(x0, y0), Vec(x1, y1), Vec(x2, y2), Vec(x3, y3)))\n\n\nCROSS = 1\nNOT_CROSS = 0\n\n\ndef solve(a, b, c, d):\n    p = b - a\n    q = c - a\n    r = d - a\n    cq = p.cross(q)\n    cr = p.cross(r)\n    if cq == 0 and cr == 0:\n        dq = p.dot(q)\n        dr = p.dot(r)\n        ap = p.abs2()\n        aq = q.abs2()\n        ar = r.abs2()\n        if (dq < 0 and dr < 0) or (ap < aq and ap < ar):\n            return NOT_CROSS\n        return CROSS\n\n    if cq * cr > 0:\n        return NOT_CROSS\n\n    p = d - c\n    q = a - c\n    r = b - c\n    cq = p.cross(q)\n    cr = p.cross(r)\n    if cq * cr > 0:\n        return NOT_CROSS\n\n    return CROSS\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nclass Vec(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        super().__init__()\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __rmul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vec(self.x / scalar, self.y / scalar)\n\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n\n    def __isub__(self, other):\n        self.x -= other.x\n        self.y -= other.y\n        return self\n\n    def __imul__(self, scalar):\n        self.x *= scalar\n        self.y *= scalar\n        return self\n\n    def __idiv__(self, scalar):\n        self.x /= scalar\n        self.y /= scalar\n        return self\n\n    def __neg__(self):\n        return Vec(-self.x, -self.y)\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def abs2(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return math.sqrt(float(self.abs2()))\n\n    def __str__(self):\n        return '({}, {})'.format(self.x, self.y)\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from typing import Tuple\n\n\ndef cross(a: Tuple[int, int], b: Tuple[int, int]) -> float:\n    return float(a[0] * b[1] - a[1] * b[0])\n\n\nif __name__ == \"__main__\":\n    q = int(input())\n    for _ in range(q):\n        x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(lambda x: int(x),\n                                                             input().split())\n        if x_p1 < x_p0:\n            x_p0, x_p1 = x_p1, x_p0\n            y_p0, y_p1 = y_p1, y_p0\n        if x_p3 < x_p2:\n            x_p2, x_p3 = x_p3, x_p2\n            y_p2, y_p3 = y_p3, y_p2\n\n        min_x1, max_x1 = x_p0, x_p1\n        min_y1, max_y1 = (y_p0, y_p1) if y_p0 < y_p1 else (y_p1, y_p0)\n        min_x2, max_x2 = x_p2, x_p3\n        min_y2, max_y2 = (y_p2, y_p3) if y_p2 < y_p3 else (y_p3, y_p2)\n\n        if any((max_x1 < min_x2, max_x2 < min_x1, max_y1 < min_y2, max_y2 < min_y1)):\n            print(0)\n            continue\n\n        s01 = (x_p1 - x_p0, y_p1 - y_p0)\n        s02 = (x_p2 - x_p0, y_p2 - y_p0)\n        s03 = (x_p3 - x_p0, y_p3 - y_p0)\n        s21 = (x_p1 - x_p2, y_p1 - y_p2)\n        s20 = (x_p0 - x_p2, y_p0 - y_p2)\n        s23 = (x_p3 - x_p2, y_p3 - y_p2)\n\n        print(int(cross(s01, s02) * cross(s01, s03) < 1e-6\n              and cross(s23, s20) * cross(s23, s21) < 1e-6))\n\n"
  },
  {
    "language": "Python",
    "code": "class Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n\n    def is_intersect(self, seg):\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        e = (self.p1.x - seg.p1.x)*(self.p2.x - seg.p2.x)\n        f = (self.p1.x - seg.p2.x)*(self.p2.x - seg.p1.x)\n        g = (self.p1.y - seg.p1.y)*(self.p2.y - seg.p2.y)\n        h = (self.p1.y - seg.p2.y)*(self.p2.y - seg.p1.y)\n        return a*b <= 0 and c*d <= 0 and e*f <= 0 and g*h <= 0\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c):\n        print(1)\n    elif cross(a,b) == 0 and cross(a,c) == 0:\n        print(0)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nEPS = 1e-10\n\nclass Vector:\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k):\n        return Vector(self.x * k, self.y * k)\n\n    def __gt__(self, other):\n        return self.x > other.x and self.y > other.yb\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.yb\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    # usually cross operation return Vector but it returns scalor\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\nclass Point(Vector):\n    def __init__(self, *args, **kargs):\n        return super().__init__(*args, **kargs)\n\nclass Segment:\n    def __init__(self, p1=Point(0, 0), p2=Point(1, 1)):\n        self.p1 = p1\n        self.p2 = p2\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > EPS:\n        return 1\n    elif a.cross(b) < -EPS:\n        return -1\n    elif a.dot(b) < -EPS:\n        return 2\n    elif a.norm() < b.norm():\n        return -2\n    else:\n        return 0\n\ndef intersect(p0, p1, p2, p3):\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0 and\n                ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0)\n\ndef read_and_print_results(n):\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        p0 = Vector(int(line[0]), int(line[1]))\n        p1 = Vector(int(line[2]), int(line[3]))\n        p2 = Vector(int(line[4]), int(line[5]))\n        p3 = Vector(int(line[6]), int(line[7]))\n        if intersect(p0, p1, p2, p3):\n            print(1)\n        else:\n            print(0)\n\nn = int(input())\nread_and_print_results(n)\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        self.intersept = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n            self.intersept = self.p1.y - self.slope*self.p1.x\n\n    def is_in_range(self, x, y):\n        return ((x - self.p1.x)*(x - self.p2.x) <= 0 and (y - self.p1.y)*(y - self.p2.y) <= 0)\n\n    def is_intersect(self, seg):\n        if self.slope == seg.slope: return False\n        slope_diff = seg.slope - self.slope\n        if self.slope == float('inf'):\n            x = self.p1.x\n            y = seg.slope * x + seg.intersept\n        elif seg.slope == float('inf'):\n            x = seg.p1.x\n            y = self.slope * x + self.intersept\n        else:\n            x = -(seg.intersept - self.intersept)/slope_diff\n            y = self.slope * x + self.intersept\n        if seg.is_in_range(x, y) and self.is_in_range(x, y): return True\n        return False\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_2_B\n# この問題は後の点の内包に繋がります\nfrom math import sqrt\n\n\nclass Vector:\n    def __init__(self, ls):\n        '''\n        ls ... list\n        '''\n        self.vec = ls\n\n    def __len__(self):\n        return len(self.vec)\n\n    def __getitem__(self, idx):\n        return self.vec[idx]\n\n    def __repr__(self):\n        return f'Vector({self.vec})'\n\n    def add(self, vec):\n        '''\n        vec ... vector class\n        '''\n        assert len(self) == len(vec)\n        ret = [a + b for a, b in zip(self.vec, vec.vec)]\n        return Vector(ret)\n\n    def sub(self, vec):\n        '''\n        vec ... vector class\n        '''\n        assert len(self) == len(vec)\n        ret = [a - b for a, b in zip(self.vec, vec.vec)]\n        return Vector(ret)\n\n    def mul(self, vec):\n        '''\n        vec ... vector class\n        '''\n        assert len(self) == len(vec)\n        ret = [a * b for a, b in zip(self.vec, vec.vec)]\n        return Vector(ret)\n\n    def norm(self):\n        tmp = sum([x * x for x in self.vec])\n        return sqrt(tmp)\n\n\ndef norm(vec):\n    '''\n    vec ... Vector class\n    '''\n    return vec.norm()\n\n\ndef cross(a, b):\n    '''\n    Outer product for 2d\n    a,b ... Vector class\n    '''\n    assert len(a) == 2 and len(b) == 2\n    first = a[0] * b[1]\n    second = a[1] * b[0]\n    return first - second\n\n\ndef dot(a, b):\n    return sum(a.mul(b))\n\n\nEPS = 1e-10\n\n\ndef ccw(p0, p1, p2):\n    '''\n    問題を解くための関数\n    引数はすべてVector\n    '''\n    a = p1.sub(p0)\n    b = p2.sub(p0)\n    if cross(a, b) > EPS:\n        # 'COUNTER_CLOCKWISE'\n        return 1\n    elif cross(a, b) < -EPS:\n        # 'CLOCKWISE'\n        return -1\n    elif dot(a, b) < 0:  # 同一直線状でa,bが逆を向いている\n        # 'ONLINE_BACK'\n        return 2\n    elif a.norm() < b.norm():  # a,bが同じ方向を向いて かつ bがaよりも長い\n        # 'ONLINE_FRONT'\n        return -2\n    else:\n        # 'ON_SEGMENT'\n        return 0\n\n\ndef is_intersect(args: list):\n    x0, y0, x1, y1, x2, y2, x3, y3 = args\n    p0 = Vector([x0, y0])\n    p1 = Vector([x1, y1])\n    p2 = Vector([x2, y2])\n    p3 = Vector([x3, y3])\n    return (ccw(p0, p1, p2) * ccw(p0, p1, p3) <= 0) and (ccw(p2, p3, p0) * ccw(p2, p3, p1) <= 0)\n\n\n# load data\nN = int(input())\nfor _ in range(N):\n    if is_intersect(list(map(int, input().split()))):\n        print(1)\n    else:\n        print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "class Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n\n    def is_intersect(self, seg):\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        return a*b <= 0 and c*d <= 0\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0 0 3 0 1 1 2 -1\n0 0 3 0 3 1 3 -1\n0 0 3 0 3 -2 5 0\n\noutput:\n1\n1\n0\n\"\"\"\n\nimport sys\n\nEPS = 1e-9\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef check_ccw(p0, p1, p2):\n    # flag = float('inf')\n    a, b = p1 - p0, p2 - p0\n    if cross(a, b) > EPS:\n        # print('COUNTER_CLOCKWISE')\n        flag = 1\n    elif cross(a, b) < -1 * EPS:\n        # print('CLOCKWISE')\n        flag = -1\n    elif dot(a, b) < -1 * EPS:\n        # print('ONLINE_BACK')\n        flag = 2\n    elif abs(a) < abs(b):\n        # print('ONLINE_FRONT')\n        flag = -2\n    else:\n        # print('ON_SEGMENT')\n        flag = 0\n    return flag\n\n\ndef check_intersection(_lines):\n    for line in _lines:\n        line = tuple(map(int, line))\n        p0, p1, p2, p3 = (x + y * 1j for x, y in zip(line[::2], line[1::2]))\n        flag = (check_ccw(p0, p1, p2) * check_ccw(p0, p1, p3) <= 0) and \\\n               (check_ccw(p2, p3, p0) * check_ccw(p2, p3, p1) <= 0)\n\n        if flag:\n            print('1')\n        else:\n            print('0')\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    l_num = int(_input[0])\n    lines = map(lambda x: x.split(), _input[1:])\n\n    check_intersection(lines)"
  },
  {
    "language": "Python",
    "code": "q = int(input())\n\ndef sub(a, b):\n    return [a[0] - b[0],a[1] - b[1]]\n\ndef cross(a, b):\n    return  a[0] * b[1] - a[1] * b[0]\n\ndef ccw(a, b, c):\n    x = sub(b, a)\n    y = sub(c, a)\n    if cross(x, y) > 0: return 1\n    if cross(x, y) < 0: return -1\n    return 0\n\ndef intersect(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and \\\n           ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\nfor i in range(q):\n    xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int, input().split())\n    print(1 if intersect([xp0, yp0], [xp1, yp1], [xp2, yp2], [xp3, yp3]) else 0)"
  },
  {
    "language": "Python",
    "code": "from math import pi, cos, sin, atan2\nEPS = 10**(-9)\n\ndef eq(value1, value2):\n    return abs(value1-value2) <= EPS\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.arg = atan2(y, x) # -PI ~ PI\n    \n    def __str__(self):\n        return \"{0:.8f} {1:.8f}\".format(self.x, self.y)\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, scal):\n        return Point(self.x*scal, self.y*scal)\n    \n    def __truediv__(self, scal):\n        return Point(self.x/scal, self.y/scal)\n    \n    def __eq__(self, other):\n        return eq(self.x, other.x) and eq(self.y, other.y)\n\n    # 原点からの距離\n    def __abs__(self):\n        return (self.x**2+self.y**2)**0.5\n    \n# 原点を中心にrad角だけ回転した点\ndef Rotation(vec: Point, rad):\n    return Point(vec.x*cos(rad)-vec.y*sin(rad), vec.x*sin(rad)+vec.y*cos(rad))\n\n\nclass Circle():\n    def __init__(self, p, r):\n        self.p = p\n        self.r = r\n\n\nclass Line():\n    # 点a, bを通る\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n        self.arg = (a-b).arg % pi\n    \n    def __str__(self):\n        return \"[({0}, {1}) - ({2}, {3})]\".format(self.a.x, self.a.y, self.b.x, self.b.y)\n\n    # pointを通って平行\n    def par(self, point):\n        return Line(point, point+(self.a-self.b))\n\n    # pointを通って垂直\n    def tan(self, point):\n        return Line(point, point + Rotation(self.a-self.b, pi/2))\n\n\nclass Segment(Line):\n    def __init__(self, a, b):\n        super().__init__(a, b)\n\n\n# 符号付き面積\ndef cross(vec1: Point, vec2: Point):\n    return vec1.x*vec2.y - vec1.y*vec2.x\n\n# 内積\ndef dot(vec1: Point, vec2: Point):\n    return vec1.x*vec2.x + vec1.y*vec2.y\n\n# 点a->b->cの回転方向\ndef ccw(a, b, c):\n    if cross(b-a, c-a) > EPS: return +1 # COUNTER_CLOCKWISE\n    if cross(b-a, c-a) < -EPS: return -1 # CLOCKWISE\n    if dot(c-a, b-a) < -EPS: return +2 # c -> a -> b\n    if abs(b-a) < abs(c-a): return -2 # a -> b -> c\n    return 0 # a -> c -> b\n\n\n# pのlへの射影\ndef projection(l, p):\n    t = dot(l.b-l.a, p-l.a) / abs(l.a-l.b)**2\n    return l.a + (l.b-l.a)*t\n\n# pのlによる反射\ndef reflection(l, p):\n    return p + (projection(l, p) - p)*2\n\ndef isPararell(l1, l2):\n    return eq(cross(l1.a-l1.b, l2.a-l2.b), 0)\n\ndef isVertical(l1, l2):\n    return eq(dot(l1.a-l1.b, l2.a-l2.b), 0)\n\n\ndef isIntersect_lp(l, p):\n    return abs(ccw(l.a, l.b, p)) != 1\n\ndef isIntersect_ll(l1, l2):\n    return not isPararell(l1, l2) or isIntersect_lp(l1, l2.a)\n\ndef isIntersect_sp(s, p):\n    return ccw(s.a, s.b, p) == 0\n\ndef isIntersect_ss(s1, s2):\n    return ccw(s1.a, s1.b, s2.a)*ccw(s1.a, s1.b, s2.b) <= 0 and ccw(s2.a, s2.b, s1.a)*ccw(s2.a, s2.b, s1.b) <= 0\n\ndef isIntersect_ls(l, s):\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS\n\ndef isIntersect_cp(c, p):\n    return abs(abs(c.p - p) - c.r) < EPS\n\ndef isIntersect_cl(c, l):\n    return distance_lp(l, c.p) <= c.r + EPS\n\ndef isIntersect_cs(c, s):\n    pass\n\ndef isIntersect_cc(c1, c2):\n    pass\n\n\ndef distance_pp(p1, p2):\n    return abs(p1-p2)\n\ndef distance_lp(l, p):\n    return abs(projection(l,p)-p)\n\ndef distance_ll(l1, l2):\n    return 0 if isIntersect_ll(l1, l2) else distance_lp(l1, l2.a)\n\ndef distance_sp(s, p):\n    r = projection(s, p)\n    if isIntersect_sp(s, r): return abs(r-p)\n    return min(abs(s.a-p), abs(s.b-p))\n\ndef distance_ss(s1, s2):\n    if isIntersect_ss(s1, s2): return 0\n    return min([distance_sp(s1, s2.a), distance_sp(s1, s2.b), distance_sp(s2, s1.a), distance_sp(s2, s1.b)])\n\ndef distance_ls(l, s):\n    if isIntersect_ls(l, s): return 0\n    return min(distance_lp(l, s.a), distance_lp(l, s.b))\n\n\ndef crosspoint_ll(l1, l2):\n    A = cross(l1.b - l1.a, l2.b - l2.a)\n    B = cross(l1.b - l1.a, l1.b - l2.a)\n    if eq(abs(A), 0) and eq(abs(B), 0): return l2.a\n    return l2.a + (l2.b - l2.a) * B / A\n\ndef crosspoint_ss(s1, s2):\n    return crosspoint_ll(s1, s2)\n\ndef crosspoint_lc(l, c):\n    if eq(distance_lp(l, c.p), c.r): return [c.p]\n    p = projection(l, c.p)\n    e = (l.b - l.a) / abs(l.b-l.a)\n    dis = (c.r**2-abs(p-c.p)**2)**0.5\n    return [p + e*dis, p - e*dis]\n\ndef crosspoint_sc(s, c):\n    pass\n\ndef crosspoint_cc(c1, c2):\n    d = abs(c1.p-c2.p)\n    if not abs(c1.r-c2.r) <= d <= c1.r+c2.r:\n        return []\n    mid_p = (c2.p * (c1.r**2-c2.r**2+d**2) + c1.p * (c2.r**2-c1.r**2+d**2)) / (2*d**2)\n    tanvec = Rotation(c1.p-c2.p, pi/2)\n    return crosspoint_lc(Line(mid_p, mid_p+tanvec), c1)\n\n\n# pからのcの接点\ndef tangent_cp(c, p):\n    return crosspoint_cc(c, Circle(p, (abs(p-c.p)**2 - c.r**2)**0.5))\n\n\n\n\n\nimport sys\ninput = sys.stdin.readline\n\ndef verify_1A():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    l = Line(Point(p1x, p1y), Point(p2x, p2y))\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        print(projection(l, p))\n\ndef verify_1B():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    l = Line(Point(p1x, p1y), Point(p2x, p2y))\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        print(reflection(l, p))\n\ndef verify_1C():\n    p1x, p1y, p2x, p2y = map(int, input().split())\n    p1 = Point(p1x, p1y); p2 = Point(p2x, p2y)\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for px, py in Query:\n        p = Point(px, py)\n        result = ccw(p1, p2, p)\n        if result == 1:\n            print(\"COUNTER_CLOCKWISE\")\n        elif result == -1:\n            print(\"CLOCKWISE\")\n        elif result == 2:\n            print(\"ONLINE_BACK\")\n        elif result == -2:\n            print(\"ONLINE_FRONT\")\n        else:\n            print(\"ON_SEGMENT\")\n\ndef verify_2A():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        l1 = Line(Point(p0x, p0y), Point(p1x, p1y))\n        l2 = Line(Point(p2x, p2y), Point(p3x, p3y))\n        if isPararell(l1, l2):\n            print(2)\n        elif isVertical(l1, l2):\n            print(1)\n        else:\n            print(0)\n\ndef verify_2B():\n    Q = int(input())\n    Query = [list(map(int, input().split())) for _ in range(Q)]\n    for p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y in Query:\n        s1 = Segment(Point(p0x, p0y), Point(p1x, p1y))\n        s2 = Segment(Point(p2x, p2y), Point(p3x, p3y))\n        if isIntersect_ss(s1, s2):\n            print(1)\n        else:\n            print(0)\nverify_2B()\n"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    elif l.s == m.e or l.s == m.s or l.e == m.e or l.e == m.s:return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    t = (y2-y0)*dx0 - (x2-x0)*dy0\n    tm = dx1*dy0 - dy1*dx0\n    if t < 0:\n        t = -t\n        tm = -tm\n    if 0 <= s <= sm and 0 <= t <= tm:\n        print 1\n    else:\n        print 0"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(other / self.x, other / self.y)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        from math import sqrt\n        return sqrt(self.norm())\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(other / self.x, other / self.y)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return Vector.dot(a, b) == 0.0\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return Vector.cross(a, b) == 0.0\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, c=Point(), r=0.0):\n        self.c = c\n        self.r = r\n\n\ndef ccw(p0, p1, p2):\n    a = Vector(p1 - p0)\n    b = Vector(p2 - p0)\n    epsilon = 1e-10\n    if Vector.cross(a, b) > epsilon:\n        return 1 # 'COUNTER_CLOCKWISE'\n    elif Vector.cross(a, b) < -epsilon:\n        return -1 # 'CLOCKWISE'\n    elif Vector.dot(a, b) < -epsilon:\n        return 1 # 'ONLINE_BACK'\n    elif a.norm() < b.norm():\n        return 1 # 'ONLINE_FRONT'\n    else:\n        return 0 # 'ON_SEGMENT'\n\n\ndef intersect(p0, p1, p2, p3):\n    ans1 = ccw(p0, p1, p2) * ccw(p0, p1, p3)\n    ans2 = ccw(p2, p3, p0) * ccw(p2, p3, p1)\n    return ans1 <= 0 and ans2 <= 0\n\n\ndef main(args):\n    q = int(input())\n    for _ in range(q):\n        x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, input().split())\n        p0 = Point(x_p0, y_p0)\n        p1 = Point(x_p1, y_p1)\n        p2 = Point(x_p2, y_p2)\n        p3 = Point(x_p3, y_p3)\n        result = intersect(p0, p1, p2, p3)\n        print(int(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nq = input()\n\nfor loop in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    # ax + by = c\n    a1, b1, c1 = [y1 - y0, x0 - x1, x0 * (y1 - y0) - y0 * (x1 - x0)]\n    a2, b2, c2 = [y3 - y2, x2 - x3, x2 * (y3 - y2) - y2 * (x3 - x2)]\n    det = a1 * b2 - b1 * a2\n    # parallel\n    if det == 0:\n        if x0 * a1 + y0 * b1 != x2 * a1 + y2 * b1: # not collinear\n            print 0\n        elif max(x0, x1) < min(x2, x3) or max(x2, x3) < min(x0, x1) \\\n            or max(y0, y1) < min(y2, y3) or max(y2, y3) < min(y0, y1): # not overlap\n            print 0\n        else: # overlap\n            print 1\n        continue\n\n    if (a1 * x2 + b1 * y2 - c1) * (a1 * x3 + b1 * y3 - c1) <= 0 and \\\n        (a2 * x0 + b2 * y0 - c2) * (a2 * x1 + b2 * y1 - c2) <= 0:\n        print 1\n    else:\n        print 0\n\n"
  },
  {
    "language": "Python",
    "code": "def dot3(O, A, B):\n  ox, oy = O\n  ax, ay = A\n  bx, by = B\n  return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\n\ndef cross3(O, A, B):\n  ox, oy = O\n  ax, ay = A\n  bx, by = B\n  return (ax - ox) * (by- oy) - (bx - ox) * (ay - oy)\n\ndef dist2(A, B):\n  ax, ay = A\n  bx, by = B\n  return (ax - bx)**2 + (ay - by)**2\n\ndef is_intersection(p0, p1, q0, q1):\n  c0 = cross3(p0, p1, q0)\n  c1 = cross3(p0, p1, q1)\n  d0 = cross3(q0, q1, p0)\n  d1 = cross3(q0, q1, p1)\n  if c0 == c1 == 0:\n    e0 = dot3(p0, p1, q0)\n    e1 = dot3(p0, p1, q1)\n    if not e0 < e1:\n      e0, e1 = e1, e0\n    return e0 <= dist2(p0, p1) and 0 <= e1\n  return c0 * c1 <= 0 and d0 * d1 <= 0\n\nfor q in range(int(input())):\n  x0, y0, x1, y1, x2, y2, x3, y3 = map(int, input().split())\n  print(+is_intersection((x0, y0), (x1, y1), (x2, y2), (x3, y3)))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\n\ndef cross_product(vect1, vect2):\n    return vect1[0]*vect2[1] - vect1[1]*vect2[0]\n\n\ndef vector_minus(vect1, vect2):\n    return [el1 - el2 for el1, el2 in zip(vect1, vect2)]\n\n\ndef is_cross(l_from1, l_to1, l_from2, l_to2):\n    line1 = vector_minus(l_to1, l_from1)\n    line2 = vector_minus(l_to2, l_from2)\n\n    from1_to2_1 = vector_minus(l_from2, l_from1)\n    from1_to2_2 = vector_minus(l_to2, l_from1)\n\n    from2_to1_1 = vector_minus(l_from1, l_from2)\n    from2_to1_2 = vector_minus(l_to1, l_from2)\n\n    if cross_product(line1, from1_to2_1)*cross_product(line1, from1_to2_2) > 0:\n        return 0\n    if cross_product(line2, from2_to1_1)*cross_product(line2, from2_to1_2) > 0:\n        return 0\n    return 1\n\n\nif __name__ == '__main__':\n    Q = int(input())\n\n    for i in range(Q):\n        all_list = list(map(int, input().split()))\n        p0_list = all_list[:2]\n        p1_list = all_list[2:4]\n        p2_list = all_list[4:6]\n        p3_list = all_list[6:]\n\n        if is_cross(p0_list, p1_list, p2_list, p3_list):\n            print(\"1\")\n        else:\n            print(\"0\")\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import starmap\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\nq = int(input())\nwhile q:\n    q -= 1\n    p0, p1, p2, p3 = starmap(complex, zip(*[map(int, input().split())] * 2))\n    max_x1, min_x1 = (p0.real, p1.real) if p0.real > p1.real else (p1.real, p0.real)\n    max_y1, min_y1 = (p0.imag, p1.imag) if p0.imag > p1.imag else (p1.imag, p0.imag)\n    max_x2, min_x2 = (p2.real, p3.real) if p2.real > p3.real else (p2.real, p3.real)\n    max_y2, min_y2 = (p2.imag, p3.imag) if p2.imag > p3.imag else (p2.imag, p3.imag)\n    if any((max_x1 < min_x2, max_x2 < min_x1, max_y1 < min_y2, max_y2 < min_y1)):\n        print(0)\n        continue\n    print(int(cross(p1 - p0, p2 - p0) * cross(p1 - p0, p3 - p0) < 1e-6 and\n              cross(p3 - p2, p0 - p2) * cross(p3 - p2, p1 - p2) < 1e-6))"
  },
  {
    "language": "Python",
    "code": "import cmath\nimport math\nimport os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nPI = cmath.pi\nTAU = cmath.pi * 2\nEPS = 1e-10\n\n\nclass Point:\n    \"\"\"\n    2次元空間上の点\n    \"\"\"\n\n    # 反時計回り側にある\n    CCW_COUNTER_CLOCKWISE = 1\n    # 時計回り側にある\n    CCW_CLOCKWISE = -1\n    # 線分の後ろにある\n    CCW_ONLINE_BACK = 2\n    # 線分の前にある\n    CCW_ONLINE_FRONT = -2\n    # 線分上にある\n    CCW_ON_SEGMENT = 0\n\n    def __init__(self, c: complex):\n        self.c = c\n\n    @property\n    def x(self):\n        return self.c.real\n\n    @property\n    def y(self):\n        return self.c.imag\n\n    @staticmethod\n    def from_rect(x: float, y: float):\n        return Point(complex(x, y))\n\n    @staticmethod\n    def from_polar(r: float, phi: float):\n        return Point(cmath.rect(r, phi))\n\n    def __add__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c + p.c)\n\n    def __iadd__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c += p.c\n        return self\n\n    def __sub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c - p.c)\n\n    def __isub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c -= p.c\n        return self\n\n    def __mul__(self, f: float):\n        return Point(self.c * f)\n\n    def __imul__(self, f: float):\n        self.c *= f\n        return self\n\n    def __truediv__(self, f: float):\n        return Point(self.c / f)\n\n    def __itruediv__(self, f: float):\n        self.c /= f\n        return self\n\n    def __repr__(self):\n        return \"({}, {})\".format(round(self.x, 10), round(self.y, 10))\n\n    def __neg__(self):\n        return Point(-self.c)\n\n    def __eq__(self, p):\n        return abs(self.c - p.c) < EPS\n\n    def __abs__(self):\n        return abs(self.c)\n\n    @staticmethod\n    def ccw(a, b, c):\n        \"\"\"\n        線分 ab に対する c の位置\n        線分上にあるか判定するだけなら on_segment とかのが速い\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point a:\n        :param Point b:\n        :param Point c:\n        \"\"\"\n        b = b - a\n        c = c - a\n        det = b.det(c)\n        if det > EPS:\n            return Point.CCW_COUNTER_CLOCKWISE\n        if det < -EPS:\n            return Point.CCW_CLOCKWISE\n        if b.dot(c) < -EPS:\n            return Point.CCW_ONLINE_BACK\n        if c.norm() - b.norm() > EPS:\n            return Point.CCW_ONLINE_FRONT\n        return Point.CCW_ON_SEGMENT\n\n    def dot(self, p):\n        \"\"\"\n        内積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.x + self.y * p.y\n\n    def det(self, p):\n        \"\"\"\n        外積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.y - self.y * p.x\n\n    def dist(self, p):\n        \"\"\"\n        距離\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return abs(self.c - p.c)\n\n    def norm(self):\n        \"\"\"\n        原点からの距離\n        :rtype: float\n        \"\"\"\n        return abs(self.c)\n\n    def phase(self):\n        \"\"\"\n        原点からの角度\n        :rtype: float\n        \"\"\"\n        return cmath.phase(self.c)\n\n    def angle(self, p, q):\n        \"\"\"\n        p に向いてる状態から q まで反時計回りに回転するときの角度\n        -pi <= ret <= pi\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return (cmath.phase(q.c - self.c) - cmath.phase(p.c - self.c) + PI) % TAU - PI\n\n    def area(self, p, q):\n        \"\"\"\n        p, q となす三角形の面積\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return abs((p - self).det(q - self) / 2)\n\n    def projection_point(self, p, q, allow_outer=False):\n        \"\"\"\n        線分 pq を通る直線上に垂線をおろしたときの足の座標\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_outer: 答えが線分の間になくても OK\n        :rtype: Point|None\n        \"\"\"\n        diff_q = q - p\n        # 答えの p からの距離\n        r = (self - p).dot(diff_q) / abs(diff_q)\n        # 線分の角度\n        phase = diff_q.phase()\n\n        ret = Point.from_polar(r, phase) + p\n        if allow_outer or (p - ret).dot(q - ret) < EPS:\n            return ret\n        return None\n\n    def reflection_point(self, p, q):\n        \"\"\"\n        直線 pq を挟んで反対にある点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n        :param Point p:\n        :param Point q:\n        :rtype: Point\n        \"\"\"\n        # 距離\n        r = abs(self - p)\n        # pq と p-self の角度\n        angle = p.angle(q, self)\n        # 直線を挟んで角度を反対にする\n        angle = (q - p).phase() - angle\n        return Point.from_polar(r, angle) + p\n\n    def on_segment(self, p, q, allow_side=True):\n        \"\"\"\n        点が線分 pq の上に乗っているか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        :rtype: bool\n        \"\"\"\n        if not allow_side and (self == p or self == q):\n            return False\n        # 外積がゼロ: 面積がゼロ == 一直線\n        # 内積がマイナス: p - self - q の順に並んでる\n        return abs((p - self).det(q - self)) < EPS and (p - self).dot(q - self) < EPS\n\n\nclass Line:\n    \"\"\"\n    2次元空間上の直線\n    \"\"\"\n\n    def __init__(self, a: float, b: float, c: float):\n        \"\"\"\n        直線 ax + by + c = 0\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @staticmethod\n    def from_gradient(grad: float, intercept: float):\n        \"\"\"\n        直線 y = ax + b\n        :param grad: 傾き\n        :param intercept: 切片\n        :return:\n        \"\"\"\n        return Line(grad, -1, intercept)\n\n    @staticmethod\n    def from_segment(p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        a = p2.y - p1.y\n        b = p1.x - p2.x\n        c = p2.y * (p2.x - p1.x) - p2.x * (p2.y - p1.y)\n        return Line(a, b, c)\n\n    @property\n    def gradient(self):\n        \"\"\"\n        傾き\n        \"\"\"\n        return INF if self.b == 0 else -self.a / self.b\n\n    @property\n    def intercept(self):\n        \"\"\"\n        切片\n        \"\"\"\n        return INF if self.b == 0 else -self.c / self.b\n\n    def is_parallel_to(self, l):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の外積がゼロ\n        return abs(Point.from_rect(self.a, self.b).det(Point.from_rect(l.a, l.b))) < EPS\n\n    def is_orthogonal_to(self, l):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の内積がゼロ\n        return abs(Point.from_rect(self.a, self.b).dot(Point.from_rect(l.a, l.b))) < EPS\n\n    def intersection_point(self, l):\n        \"\"\"\n        交差する点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n        FIXME: 誤差が気になる。EPS <= 1e-9 だと CGL_2_B ダメだった。\n        :param Line l:\n        :rtype: Point|None\n        \"\"\"\n        a1, b1, c1 = self.a, self.b, self.c\n        a2, b2, c2 = l.a, l.b, l.c\n        det = a1 * b2 - a2 * b1\n        if abs(det) < EPS:\n            # 並行\n            return None\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return Point.from_rect(x, y)\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        raise NotImplementedError()\n\n    def has_point(self, p):\n        \"\"\"\n        p が直線上に乗っているかどうか\n        :param Point p:\n        \"\"\"\n        return abs(self.a * p.x + self.b * p.y + self.c) < EPS\n\n\nclass Segment:\n    \"\"\"\n    2次元空間上の線分\n    \"\"\"\n\n    def __init__(self, p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n\n    def norm(self):\n        \"\"\"\n        線分の長さ\n        \"\"\"\n        return abs(self.p1 - self.p2)\n\n    def phase(self):\n        \"\"\"\n        p1 を原点としたときの p2 の角度\n        \"\"\"\n        return cmath.phase(self.p2 - self.p1)\n\n    def is_parallel_to(self, s):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 外積がゼロ\n        return abs((self.p1 - self.p2).det(s.p1 - s.p2)) < EPS\n\n    def is_orthogonal_to(self, s):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 内積がゼロ\n        return abs((self.p1 - self.p2).dot(s.p1 - s.p2)) < EPS\n\n    def intersects_with(self, s, allow_side=True):\n        \"\"\"\n        交差するかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        :param Segment s:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        if self.is_parallel_to(s):\n            # 並行なら線分の端点がもう片方の線分の上にあるかどうか\n            return (s.p1.on_segment(self.p1, self.p2, allow_side) or\n                    s.p2.on_segment(self.p1, self.p2, allow_side) or\n                    self.p1.on_segment(s.p1, s.p2, allow_side) or\n                    self.p2.on_segment(s.p1, s.p2, allow_side))\n        else:\n            # allow_side ならゼロを許容する\n            det_lower = EPS if allow_side else -EPS\n            ok = True\n            # self の両側に s.p1 と s.p2 があるか\n            ok &= (self.p2 - self.p1).det(s.p1 - self.p1) * (self.p2 - self.p1).det(s.p2 - self.p1) < det_lower\n            # s の両側に self.p1 と self.p2 があるか\n            ok &= (s.p2 - s.p1).det(self.p1 - s.p1) * (s.p2 - s.p1).det(self.p2 - s.p1) < det_lower\n            return ok\n\n    def closest_point(self, p):\n        \"\"\"\n        線分上の、p に最も近い点\n        :param Point p:\n        \"\"\"\n        # p からおろした垂線までの距離\n        d = (p - self.p1).dot(self.p2 - self.p1) / self.norm()\n        # p1 より前\n        if d < EPS:\n            return self.p1\n        # p2 より後\n        if -EPS < d - self.norm():\n            return self.p2\n        # 線分上\n        return Point.from_polar(d, (self.p2 - self.p1).phase()) + self.p1\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        return abs(p - self.closest_point(p))\n\n    def dist_segment(self, s):\n        \"\"\"\n        他の線分との最短距離\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n        :param Segment s:\n        \"\"\"\n        if self.intersects_with(s):\n            return 0.0\n        return min(\n            self.dist(s.p1),\n            self.dist(s.p2),\n            s.dist(self.p1),\n            s.dist(self.p2),\n        )\n\n    def has_point(self, p, allow_side=True):\n        \"\"\"\n        p が線分上に乗っているかどうか\n        :param Point p:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        return p.on_segment(self.p1, self.p2, allow_side=allow_side)\n\n\nclass Polygon:\n    \"\"\"\n    2次元空間上の多角形\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"\n        :param list of Point points:\n        \"\"\"\n        self.points = points\n\n    def iter2(self):\n        \"\"\"\n        隣り合う2点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point)]\n        \"\"\"\n        return zip(self.points, self.points[1:] + self.points[:1])\n\n    def iter3(self):\n        \"\"\"\n        隣り合う3点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point, Point)]\n        \"\"\"\n        return zip(self.points,\n                   self.points[1:] + self.points[:1],\n                   self.points[2:] + self.points[:2])\n\n    def area(self):\n        \"\"\"\n        面積\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n        \"\"\"\n        # 外積の和 / 2\n        dets = []\n        for p, q in self.iter2():\n            dets.append(p.det(q))\n        return abs(math.fsum(dets)) / 2\n\n    def is_convex(self, allow_straight=False, allow_collapsed=False):\n        \"\"\"\n        凸多角形かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :param allow_collapsed: 面積がゼロの場合を許容するか\n        \"\"\"\n        ccw = []\n        for a, b, c in self.iter3():\n            ccw.append(Point.ccw(a, b, c))\n        ccw = set(ccw)\n        if len(ccw) == 1:\n            if ccw == {Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_straight and len(ccw) == 2:\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_collapsed and len(ccw) == 3:\n            return ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_ONLINE_BACK, Point.CCW_ON_SEGMENT}\n        return False\n\n    def has_point_on_edge(self, p):\n        \"\"\"\n        指定した点が辺上にあるか\n        :param Point p:\n        :rtype: bool\n        \"\"\"\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return True\n        return False\n\n    def contains(self, p, allow_on_edge=True):\n        \"\"\"\n        指定した点を含むか\n        Winding Number Algorithm\n        https://www.nttpc.co.jp/technology/number_algorithm.html\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n        :param Point p:\n        :param bool allow_on_edge: 辺上の点を許容するか\n        \"\"\"\n        angles = []\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return allow_on_edge\n            angles.append(p.angle(a, b))\n        # 一周以上するなら含む\n        return abs(math.fsum(angles)) > EPS\n\n    @staticmethod\n    def convex_hull(points, allow_straight=False):\n        \"\"\"\n        凸包。x が最も小さい点のうち y が最も小さい点から反時計回り。\n        Graham Scan O(N log N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n        :param list of Point points:\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :rtype: list of Point\n        \"\"\"\n        points = points[:]\n        points.sort(key=lambda p: (p.x, p.y))\n\n        # allow_straight なら 0 を許容する\n        det_lower = -EPS if allow_straight else EPS\n\n        sz = 0\n        #: :type: list of (Point|None)\n        ret = [None] * (N * 2)\n        for p in points:\n            while sz > 1 and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        floor = sz\n        for p in reversed(points[:-1]):\n            while sz > floor and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        ret = ret[:sz - 1]\n\n        if allow_straight and len(ret) > len(points):\n            # allow_straight かつ全部一直線のときに二重にカウントしちゃう\n            ret = points\n        return ret\n\n    @staticmethod\n    def diameter(points):\n        \"\"\"\n        直径\n        凸包構築 O(N log N) + カリパー法 O(N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\n        :param list of Point points:\n        \"\"\"\n        # 反時計回り\n        points = Polygon.convex_hull(points, allow_straight=False)\n        if len(points) == 1:\n            return 0.0\n        if len(points) == 2:\n            return abs(points[0] - points[1])\n\n        # x軸方向に最も遠い点対\n        si = points.index(min(points, key=lambda p: (p.x, p.y)))\n        sj = points.index(max(points, key=lambda p: (p.x, p.y)))\n        n = len(points)\n\n        ret = 0.0\n        # 半周回転\n        i, j = si, sj\n        while i != sj or j != si:\n            ret = max(ret, abs(points[i] - points[j]))\n            ni = (i + 1) % n\n            nj = (j + 1) % n\n            # 2つの辺が並行になる方向にずらす\n            if (points[ni] - points[i]).det(points[nj] - points[j]) > 0:\n                j = nj\n            else:\n                i = ni\n        return ret\n\n    def convex_cut_by_line(self, line_p1, line_p2):\n        \"\"\"\n        凸多角形を直線 line_p1-line_p2 でカットする。\n        凸じゃないといけません\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=ja\n        :param line_p1:\n        :param line_p2:\n        :return: (line_p1-line_p2 の左側の多角形, line_p1-line_p2 の右側の多角形)\n        :rtype: (Polygon|None, Polygon|None)\n        \"\"\"\n        n = len(self.points)\n        line = Line.from_segment(line_p1, line_p2)\n        # 直線と重なる点\n        on_line_points = []\n        for i, p in enumerate(self.points):\n            if line.has_point(p):\n                on_line_points.append(i)\n\n        # 辺が直線上にある\n        has_on_line_edge = False\n        if len(on_line_points) >= 3:\n            has_on_line_edge = True\n        elif len(on_line_points) == 2:\n            # 直線上にある点が隣り合ってる\n            has_on_line_edge = abs(on_line_points[0] - on_line_points[1]) in [1, n - 1]\n        # 辺が直線上にある場合、どっちか片方に全部ある\n        if has_on_line_edge:\n            for p in self.points:\n                ccw = Point.ccw(line_p1, line_p2, p)\n                if ccw == Point.CCW_COUNTER_CLOCKWISE:\n                    return Polygon(self.points[:]), None\n                if ccw == Point.CCW_CLOCKWISE:\n                    return None, Polygon(self.points[:])\n\n        ret_lefts = []\n        ret_rights = []\n        d = line_p2 - line_p1\n        for p, q in self.iter2():\n            det_p = d.det(p - line_p1)\n            det_q = d.det(q - line_p1)\n            if det_p > -EPS:\n                ret_lefts.append(p)\n            if det_p < EPS:\n                ret_rights.append(p)\n            # 外積の符号が違う == 直線の反対側にある場合は交点を追加\n            if det_p * det_q < -EPS:\n                intersection = line.intersection_point(Line.from_segment(p, q))\n                ret_lefts.append(intersection)\n                ret_rights.append(intersection)\n\n        # 点のみの場合を除いて返す\n        l = Polygon(ret_lefts) if len(ret_lefts) > 1 else None\n        r = Polygon(ret_rights) if len(ret_rights) > 1 else None\n        return l, r\n\n\nQ = int(sys.stdin.buffer.readline())\nROWS = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(Q)]\n\nfor x0, y0, x1, y1, x2, y2, x3, y3 in ROWS:\n    s1 = Segment(Point.from_rect(x0, y0), Point.from_rect(x1, y1))\n    s2 = Segment(Point.from_rect(x2, y2), Point.from_rect(x3, y3))\n    print(int(s1.intersects_with(s2, allow_side=True)))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\n###########################\n#          幾何\n###########################\ndef sgn(a):\n    if a < -eps: return -1\n    if a >  eps: return  1\n    return 0\n\nclass Point:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n        pass\n\n    def tolist(self):\n        return [self.x,self.y]\n\n    def __add__(self,p):\n        return Point(self.x+p.x, self.y+p.y)\n    def __iadd__(self,p):\n        return self + p\n\n    def __sub__(self,p):\n        return Point(self.x - p.x, self.y - p.y)\n    def __isub__(self,p):\n        return self - p\n\n    def __truediv__(self,n):\n        return Point(self.x/n, self.y/n)\n    def __itruediv__(self,n):\n        return self / n\n\n    def __mul__(self,n):\n        return Point(self.x*n, self.y*n)\n    def __imul__(self,n):\n        return self * n\n\n    def __lt__(self,other):\n        tmp = sgn(self.x - other.x)\n        if tmp != 0:\n            return tmp < 0\n        else:\n            return sgn(self.y - other.y) < 0\n\n    def __eq__(self,other):\n        return sgn(self.x - other.x) == 0 and sgn(self.y - other.y) == 0\n\n    def abs(self):\n        return math.sqrt(self.x**2+self.y**2)\n\n    def dot(self,p):\n        return self.x * p.x + self.y*p.y\n\n    def det(self,p):\n        return self.x * p.y - self.y*p.x\n\n    def arg(self,p):\n        return math.atan2(y,x)\n\n# 点の進行方向 a -> b -> c\ndef iSP(a,b,c):\n    tmp = sgn((b-a).det(c-a))\n    if tmp > 0:   return 1   # 左に曲がる場合\n    elif tmp < 0: return -1  # 右に曲がる場合\n    else: # まっすぐ\n        if sgn((b-a).dot(c-a)) < 0: return -2 # c-a-b の順\n        if sgn((a-b).dot(c-b)) < 0: return  2 # a-b-c の順\n        return 0 # a-c-bの順\n\n# ab,cd の直線交差\ndef isToleranceLine(a,b,c,d):\n    if sgn((b-a).det(c-d)) != 0: return 1 # 交差する\n    else:\n        if sgn((b-a).det(c-a)) != 0: return 0 # 平行\n        else: return -1 # 同一直線\n\n# ab,cd の線分交差 重複，端点での交差もTrue\ndef isToleranceSegline(a,b,c,d):\n    return sgn(iSP(a,b,c)*iSP(a,b,d))<=0 and sgn(iSP(c,d,a)*iSP(c,d,b)) <= 0\n\n# 直線ab と 直線cd の交点 (存在する前提)\ndef Intersection(a,b,c,d):\n    tmp1 = (b-a)*((c-a).det(d-c))\n    tmp2 = (b-a).det(d-c)\n    return a+(tmp1/tmp2)\n\n# 直線ab と 点c の距離\ndef DistanceLineToPoint(a,b,c):\n    return abs(((c-a).det(b-a))/((b-a).abs()))\n\n# 線分ab と 点c の距離\ndef DistanceSeglineToPoint(a,b,c):\n    if sgn((b-a).dot(c-a)) < 0: # <cab が鈍角\n        return (c-a).abs()\n    if sgn((a-b).dot(c-b)) < 0: # <cba が鈍角\n        return (c-b).abs()\n    return DistanceLineToPoint(a,b,c)\n\n# 直線ab への 点c からの垂線の足\ndef Vfoot(a,b,c):\n    d = c + Point((b-a).y,-(b-a).x)\n    return Intersection(a,b,c,d)\n\n# 多角形の面積\ndef PolygonArea(Plist):\n    Plist = ConvexHull(Plist)\n    L = len(Plist)\n    S = 0\n    for i in range(L):\n        tmpS = (Plist[i-1].det(Plist[i]))/2\n        S += tmpS\n    return S\n\n# 多角形の重心\ndef PolygonG(Plist):\n    Plist = ConvexHull(Plist)\n    L = len(Plist)\n    S = 0\n    G = Point(0,0)\n    for i in range(L):\n        tmpS = (Plist[i-1].det(Plist[i]))/2\n        S += tmpS\n        G += (Plist[i-1]+Plist[i])/3*tmpS\n    return G/S\n\n# 凸法\ndef ConvexHull(Plist):\n    Plist.sort()\n    L = len(Plist)\n    qu = deque([])\n    quL = 0\n    for p in Plist:\n        while quL >= 2 and iSP(qu[quL-2],qu[quL-1],p) == 1:\n            qu.pop()\n            quL -= 1\n        qu.append(p)\n        quL += 1\n\n    qd = deque([])\n    qdL = 0\n    for p in Plist:\n        while qdL >= 2 and iSP(qd[qdL-2],qd[qdL-1],p) == -1:\n            qd.pop()\n            qdL -= 1\n        qd.append(p)\n        qdL += 1\n\n    qd.pop()\n    qu.popleft()\n    hidari = list(qd) + list(reversed(qu)) # 左端開始，左回りPlist\n    return hidari\n\nN = int(input())\nfor _ in range(N):\n    x0,y0,x1,y1,x2,y2,x3,y3 = inpl()\n    p0 = Point(x0,y0)\n    p1 = Point(x1,y1)\n    p2 = Point(x2,y2)\n    p3 = Point(x3,y3)\n    if isToleranceSegline(p0,p1,p2,p3):\n        print(1)\n    else:\n        print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nclass Geometry:\n\n    EPS = 10 ** -9\n\n    def add(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return (x1+x2, y1+y2)\n\n    def sub(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return (x1-x2, y1-y2)\n\n    def mul(self, a, b):\n        x1, y1 = a\n        if not isinstance(b, tuple):\n            return (x1*b, y1*b)\n        x2, y2 = b \n        return (x1*x2, y1*y2)\n\n    def norm(self, a):\n        x, y = a\n        return x**2 + y**2\n\n    def dot(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return x1*x2 + y1*y2\n\n    def cross(self, a, b):\n        x1, y1 = a\n        x2, y2 = b\n        return x1*y2 - y1*x2\n\n    def project(self, seg, p):\n        \"\"\" 線分segに対する点pの射影 \"\"\"\n        p1, p2 = seg\n        base = self.sub(p2, p1)\n        r = self.dot(self.sub(p, p1), base) / self.norm(base)\n        return self.add(p1, self.mul(base, r))\n\n    def reflect(self, seg, p):\n        \"\"\" 線分segを対称軸とした点pの線対称の点 \"\"\"\n        return self.add(p, self.mul(self.sub(self.project(seg, p), p), 2))\n\n    def ccw(self, p0, p1, p2):\n        \"\"\" 線分p0,p1から線分p0,p2への回転方向 \"\"\"\n        a = self.sub(p1, p0)\n        b = self.sub(p2, p0)\n        # 反時計回り\n        if self.cross(a, b) > self.EPS: return 1\n        # 時計回り\n        if self.cross(a, b) < -self.EPS: return -1\n        # 直線上(p2 => p0 => p1)\n        if self.dot(a, b) < -self.EPS: return 2\n        # 直線上(p0 => p1 => p2)\n        if self.norm(a) < self.norm(b): return -2\n        # 直線上(p0 => p2 => p1)\n        return 0\n\n    def intersect(self, seg1, seg2):\n        \"\"\" 線分seg1と線分seg2の交差判定 \"\"\"\n        p1, p2 = seg1\n        p3, p4 = seg2\n        return (\n            self.ccw(p1, p2, p3) * self.ccw(p1, p2, p4) <= 0\n            and self.ccw(p3, p4, p1) * self.ccw(p3, p4, p2) <= 0\n        )\n\ngm = Geometry()\nQ = INT()\nfor i in range(Q):\n    x1, y1, x2, y2, x3, y3, x4, y4 = MAP()\n    seg1 = ((x1, y1), (x2, y2))\n    seg2 = ((x3, y3), (x4, y4))\n    print(int(gm.intersect(seg1, seg2)))\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n\n    def is_intersect(self, seg):\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        return a*b < 0 and c*d < 0\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n\n    def is_intersect(self, seg):\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        return a*b <= 0 and c*d <= 0\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\ndef z(x,  y,  x1,  y1,  x2,  y2):\n    if (x1 > x2):x1,x2=x2,x1;y1,y2=y2,y1\n    return x1 <= x and x <= x2 and ((y1 <= y2 and y1 <= y and y <= y2) | (y1 > y2 and y2 <= y and y <= y1)) and (y-y1)*(x2-x1) == (y2-y1)*(x-x1);\n\nfor i in range(n):\n    a,b,c,d,e,f,g,h = map(int, input().split())\n    \n    p = d-b\n    q = c-a\n    r = h-f\n    s = g-e\n    \n    t = (f-b)*q - (e-a)*p\n    u = (h-b)*q - (g-a)*p\n    \n    v = (b-f)*s - (a-e)*r\n    w = (d-f)*s - (c-e)*r\n\n    if (t*u<0 and v*w<0) | z(a,b,e,f,g,h) | z(c,d,e,f,g,h) | z(e,f,a,b,c,d) | z(g,h,a,b,c,d):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef is_Crossed(OA, OC, OB, OD):\n    \"\"\"\n    AOJ: CGL_2B \n    segment AC and segment BD\n    ref. http://www.fumiononaka.com/Business/html5/FN1312004.html\n    \"\"\"\n    AC = Point(OC.x - OA.x, OC.y - OA.y)\n    BD = Point(OD.x - OB.x, OD.y - OB.y)\n    AB = Point(OB.x - OA.x, OB.y - OA.y)\n    BC = Point(OC.x - OB.x, OC.y - OB.y)\n    AD = Point(OD.x - OA.x, OD.y - OA.y)\n    BA = Point(-AB.x, -AB.y)\n\t\n    if crossProduct2D(AC, BD) == 0:\n        if (OA.x, OA.y) == (OD.x, OD.y) or (OB.x, OB.y) == (OC.x, OC.y):\n            return 1\n        else:\n            return 0\n    if crossProduct2D(BD, BA) * crossProduct2D(BD, BC) > 0: \n        return 0\n    else:\n\t    if crossProduct2D(AC, AB) * crossProduct2D(AC, AD) > 0: \n\t        return 0\n\t    else: \n\t        return 1\n\t        \ndef crossProduct2D(Point0, Point1):\n    return Point0.x * Point1.y - Point0.y * Point1.x\n\nif __name__ == \"__main__\":\n    n = int(raw_input())\n    for i in range(n):\n        xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int,raw_input().split())\n        P0 = Point(xp0, yp0)\n        P1 = Point(xp1, yp1)\n        P2 = Point(xp2, yp2)\n        P3 = Point(xp3, yp3)\n        print is_Crossed(P0, P1, P2, P3)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    q = int(readline())\n    for i in range(q):\n        xy = map(int, readline().split())\n        p0, p1, p2, p3 = [x + y * 1j for x, y in zip(*[xy] * 2)]\n        print(1 if is_intersected_ls(p0, p1, p2, p3) else 0)\n\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    eps = 0\n    print(cross(a2-a1, b1-a1))\n    print(cross(a2-a1, b2-a1))\n    print(cross(b2-b1, a1-b1))\n    print(cross(b2-b1, a2-b1))\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < eps) and (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < eps)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\nmain()"
  },
  {
    "language": "Python",
    "code": "q = int(raw_input())\nfor _ in xrange(q):\n  x0,y0,x1,y1,x2,y2,x3,y3 = map(float, raw_input().split())\n  ta = (x2 - x3) * (y0 - y2) + (y2 - y3) * (x2 - x0)\n  tb = (x2 - x3) * (y1 - y2) + (y2 - y3) * (x2 - x1)\n  tc = (x0 - x1) * (y2 - y0) + (y0 - y1) * (x0 - x2)\n  td = (x0 - x1) * (y3 - y0) + (y0 - y1) * (x0 - x3)\n\n  if tc * td <= 0 and ta * tb <= 0:\n    print 1\n  else:\n    print 0"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\n\nCOUNTER_CLOCKWISE = 1\nCLOCKWISE = -1\nONLINE_BACK = 2\nONLINE_FRONT = -2\nON_SEGMENT = 0\n\nEPS = 0.0000000001\n\nclass Point:\n    \n    global EPS\n    \n    def __init__(self, x = 0, y = 0):\n        self.x = x\n        self.y = y\n        \n        \n    def __add__(a, b):\n        s = a.x + b.x\n        t = a.y + b.y\n        return Point(s, t)\n        \n    def __sub__(a, b):\n        s = a.x - b.x\n        t = a.y - b.y\n        return Point(s, t)\n            \n    def __mul__(self, a):\n        s = a * self.x\n        t = a * self.y\n        return Point(s, t)\n        \n    def __truediv__(self, a):\n        s = self.x / a\n        t = self.y / a\n        return Point(s, t)\n            \n            \n            \n            \n    def norm(self):\n        return self.x * self.x + self.y * self.y\n        \n    def abs(self):\n        return self.norm() ** 0.5\n            \n    \n            \n            \n    def __eq__(self, other):\n        return abs(self.x - other.y) < self.EPS and abs(self.y - other.y) < self.EPS\n            \n            \n            \n    def dot(self, b):\n        return self.x * b.x + self.y * b.y\n        \n    def cross(self, b):\n        return self.x * b.y - self.y * b.x\n    \n    \nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n\ndef ccw(p0, p1, p2):\n    a = p1-p0\n    b = p2-p0\n    \n    if a.cross(b) > 0:\n        return COUNTER_CLOCKWISE\n    elif a.cross(b) <0:\n        return CLOCKWISE\n    elif a.dot(b) < 0:\n        return ONLINE_BACK\n    elif a.abs() < b.abs():\n        return ONLINE_FRONT\n    else:\n        return ON_SEGMENT\n\ndef intersect(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) *ccw(p1, p2, p4) <=0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\ndef intersectS(s1, s2):\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n\n\n\n        \nn = int(input())\nfor i in range(n):\n    nums=list(map(int,input().split()))\n    p1 = Point(nums[0], nums[1])\n    p2 = Point(nums[2], nums[3])\n    p3 = Point(nums[4], nums[5])\n    p4 = Point(nums[6], nums[7])\n    s1 = Segment(p1, p2)\n    s2 = Segment(p3, p4)\n    if intersectS(s1, s2):\n        print(1)\n    else:\n        print(0)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(other / self.x, other / self.y)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        from math import sqrt\n        return sqrt(self.norm())\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(other / self.x, other / self.y)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return Vector.dot(a, b) == 0.0\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return Vector.cross(a, b) == 0.0\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, c=Point(), r=0.0):\n        self.c = c\n        self.r = r\n\n\ndef ccw(p0, p1, p2):\n    a = Vector(p1 - p0)\n    b = Vector(p2 - p0)\n    epsilon = 1e-10\n    if Vector.cross(a, b) > epsilon:\n        return 1 # 'COUNTER_CLOCKWISE'\n    elif Vector.cross(a, b) < -epsilon:\n        return -1 # 'CLOCKWISE'\n    elif Vector.dot(a, b) < -epsilon:\n        return 2 # 'ONLINE_BACK'\n    elif a.norm() < b.norm():\n        return -2 # 'ONLINE_FRONT'\n    else:\n        return 0 # 'ON_SEGMENT'\n\n\ndef intersect(p0, p1, p2=Point(), p3=Point()):\n    if isinstance(p0, Point):\n        ans1 = ccw(p0, p1, p2) * ccw(p0, p1, p3)\n        ans2 = ccw(p2, p3, p0) * ccw(p2, p3, p1)\n        return ans1 <= 0 and ans2 <= 0\n    elif isinstance(p0, Segment):\n        ans1 = ccw(p0.p1, p0.p2, p1.p1) * ccw(p0.p1, p0.p2, p1.p2)\n        ans2 = ccw(p1.p1, p1.p2, p0.p1) * ccw(p1.p1, p1.p2, p0.p2)\n        return ans1 <= 0 and ans2 <= 0\n\n\ndef main(args):\n    q = int(input())\n    for _ in range(q):\n        x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, input().split())\n        p0 = Point(x_p0, y_p0)\n        p1 = Point(x_p1, y_p1)\n        p2 = Point(x_p2, y_p2)\n        p3 = Point(x_p3, y_p3)\n        #result = intersect(p0, p1, p2, p3)\n\n        s1 = Segment(p0, p1)\n        s2 = Segment(p2, p3)\n        result = intersect(s1, s2)\n        print(int(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import math\nfrom typing import Union\n\n\nclass Point(object):\n    __slots__ = ['x', 'y']\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other: Union[int, float]):\n        return Point(self.x * other, self.y * other)\n\n    def __repr__(self):\n        return f\"({self.x},{self.y})\"\n\n\nclass Vector(Point):\n    __slots__ = ['x', 'y', 'pt1', 'pt2']\n\n    def __init__(self, pt1: Point, pt2: Point):\n        from_pt1_to_pt2 = pt2 - pt1\n        super().__init__(from_pt1_to_pt2.x, from_pt1_to_pt2.y)\n        self.pt1 = pt1\n        self.pt2 = pt2\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def norm(self):\n        return pow(self.x, 2) + pow(self.y, 2)\n\n    def abs(self):\n        return math.sqrt(self.norm())\n\n    def __repr__(self):\n        return f\"{self.pt1},{self.pt2}\"\n\n\nclass Segment(Vector):\n    __slots__ = ['x', 'y', 'pt1', 'pt2']\n\n    def __init__(self, pt1: Point, pt2: Point):\n        super().__init__(pt1, pt2)\n\n    def projection(self, pt: Point)-> Point:\n        t = self.dot(Vector(self.pt1, pt)) / pow(self.abs(), 2)\n        return Point(self.pt1.x + t * self.x, self.pt1.y + t * self.y)\n\n    def reflection(self, pt: Point) -> Point:\n        return self.projection(pt) * 2 - pt\n\n    def is_intersected_with(self, other) -> bool:\n        if (self.point_geometry(other.pt1) * self.point_geometry(other.pt2)) <= 0\\\n                and other.point_geometry(self.pt1) * other.point_geometry(self.pt2) <= 0:\n            return True\n        else:\n            return False\n\n    def point_geometry(self, pt: Point) -> int:\n        \"\"\"\n        [-2:\"Online Back\", -1:\"Counter Clockwise\", 0:\"On Segment\", 1:\"Clockwise\",  2:\"Online Front\"]\n        \"\"\"\n        vec_pt1_to_pt = Vector(self.pt1, pt)\n        cross = self.cross(vec_pt1_to_pt)\n        if cross > 0:\n            return -1   # counter clockwise\n        elif cross < 0:\n            return 1    # clockwise\n        else:           # cross == 0\n            dot = self.dot(vec_pt1_to_pt)\n            if dot < 0:\n                return -2    # online back\n            else:       # dot > 0\n                if self.abs() < vec_pt1_to_pt.abs():\n                    return 2    # online front\n                else:\n                    return 0    # on segment\n\n    def __repr__(self):\n        return f\"{self.pt1},{self.pt2}\"\n\n\ndef main():\n    num_query = int(input())\n    for i in range(num_query):\n        p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y = map(int, input().split())\n        seg_1 = Segment(Point(p0_x, p0_y), Point(p1_x, p1_y))\n        seg_2 = Segment(Point(p2_x, p2_y), Point(p3_x, p3_y))\n\n        print(int(seg_1.is_intersected_with(seg_2)))\n    return\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0 0 3 0 1 1 2 -1\n0 0 3 0 3 1 3 -1\n0 0 3 0 3 -2 5 0\n\noutput:\n1\n1\n0\n\"\"\"\n\nimport sys\n\nEPS = 1e-9\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef check_ccw(p0, p1, p2):\n    a, b = p1 - p0, p2 - p0\n    if cross(a, b) > EPS:\n        flag = 1\n    elif cross(a, b) < -1 * EPS:\n        flag = -1\n    elif dot(a, b) < -1 * EPS:\n        flag = 2\n    elif abs(a) < abs(b):\n        flag = -2\n    else:\n        flag = 0\n    return flag\n\n\ndef check_intersection(p0, p1, p2, p3):\n    intersected = (check_ccw(p0, p1, p2) * check_ccw(p0, p1, p3) <= 0) and \\\n                  (check_ccw(p2, p3, p0) * check_ccw(p2, p3, p1) <= 0)\n\n    return intersected\n\n\ndef solve(_lines):\n    for line in _lines:\n        line = tuple(map(int, line))\n        p0, p1, p2, p3 = (x + y * 1j for x, y in zip(line[::2], line[1::2]))\n        intersected = check_intersection(p0, p1, p2, p3)\n\n        if intersected:\n            print('1')\n        else:\n            print('0')\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    l_num = int(_input[0])\n    lines = map(lambda x: x.split(), _input[1:])\n\n    solve(lines)"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    t = (y2-y0)*dx0 - (x2-x0)*dy0\n    tm = dx1*dy0 - dy1*dx0\n    if t < 0:\n        t = -t\n        tm = -tm\n    ov = dx0*dy1 - dy0*dx1\n    if 0 <= s <= sm and 0 <= t <= tm:\n        if ov == 0:\n            r0 = dx0**2 + dy0**2\n            r1 = (x2-x0)*dx0 + (y2-y0)*dy0\n            r2 = (x3-x0)*dx0 + (y3-y0)*dy0\n            if r2 < 0 or r0 < r1:\n                print 0\n            else:\n                print 1\n        else:\n            print 1\n    else:\n        print 0"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    q = int(readline())\n    for i in range(q):\n        xy = map(int, readline().split())\n        p0, p1, p2, p3 = [x + y * 1j for x, y in zip(*[xy] * 2)]\n        print(1 if is_intersected_ls(p0, p1, p2, p3) else 0)\n\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    eps = 0\n    if max(a1.real, a2.real) < min(b1.real, b2.real)\\\n      or max(b1.real, b2.real) < min(a1.real, a2.real)\\\n      or max(a1.imag, a2.imag) < min(b1.imag, b2.imag)\\\n      or max(b1.imag, b2.imag) < min(a1.imag, a2.imag):\n        return False\n\n    #print(cross(a2-a1, b1-a1))\n    #print(cross(a2-a1, b2-a1))\n    #print(cross(b2-b1, a1-b1))\n    #print(cross(b2-b1, a2-b1))\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) <= eps)\\\n        and (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) <= eps)\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport collections\nimport math\n\n\nclass Vector2(collections.namedtuple(\"Vector2\", [\"x\",  \"y\"])):\n\n    def __add__(self, other):\n        return Vector2(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector2(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vector2(self.x * scalar, self.y * scalar)\n\n    def __neg__(self):\n        return Vector2(-self.x, -self.y)\n\n    def __pos__(self):\n        return Vector2(+self.x, +self.y)\n\n    def __abs__(self):  # norm\n        return math.sqrt(float(self.x * self.x + self.y * self.y))\n\n    def dot(self, other):  # dot product\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):  # cross product\n        return self.x * other.y - self.y * other.x\n\n\ndef getDistanceSP(segment, point):\n    p = point\n    p1, p2 = segment\n    if (p2 - p1).dot(p - p1) < 0:\n        return abs(p - p1)\n    if (p1 - p2).dot(p - p2) < 0:\n        return abs(p - p2)\n    return abs((p2 - p1).cross(p - p1)) / abs(p2 - p1)\n\n\ndef getDistance(s1, s2):\n    a, b = s1\n    c, d = s2\n    if intersect(s1, s2):  # intersect\n        return 0\n    return min(getDistanceSP(s1, c), getDistanceSP(s1, d), getDistanceSP(s2, a), getDistanceSP(s2, b))\n\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if a.cross(b) > 0:\n        return 1  # COUNTER_CLOCKWISE\n    elif a.cross(b) < 0:\n        return -1  # CLOCKWISE\n    elif a.dot(b) < 0:\n        return 2  # ONLINE_BACK\n    elif abs(a) < abs(b):\n        return -2  # ONLINE_FRONT\n    else:\n        return 0  # ON_SEGMENT\n\n\ndef intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0\n\n\nif __name__ == '__main__':\n\n    n = int(input())\n\n    for _ in range(n):\n        l = list(map(int, input().split()))\n        s1 = [Vector2(l[0], l[1]), Vector2(l[2], l[3])]\n        s2 = [Vector2(l[4], l[5]), Vector2(l[6], l[7])]\n\n        print(int(intersect(s1, s2)))\n\n"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c):\n        print(1)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1)"
  },
  {
    "language": "Python",
    "code": "q = int(raw_input())\nfor _ in xrange(q):\n  x0,y0,x1,y1,x2,y2,x3,y3 = map(float, raw_input().split())\n  ta = (x2 - x3) * (y0 - y2) + (y2 - y3) * (x2 - x0)\n  tb = (x2 - x3) * (y1 - y2) + (y2 - y3) * (x2 - x1)\n  tc = (x0 - x1) * (y2 - y0) + (y0 - y1) * (x0 - x2)\n  td = (x0 - x1) * (y3 - y0) + (y0 - y1) * (x0 - x3)\n\n  if tc * td <= 0 and ta * tb <= 0:\n    if tc * td == 0 and ta * tb == 0:\n      outer1 = (x2 - x0) * (x2 - x1) + (y2 - y0) * (y2 - y1)\n      outer2 = (x3 - x0) * (x3 - x1) + (y3 - y0) * (y3 - y1)\n      if outer1 <= 0 or outer2 <= 0:\n        print 1\n      else:\n        print 0\n    else:\n      print 1\n  else:\n    print 0"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    q = int(readline())\n    for i in range(q):\n        xy = map(int, readline().split())\n        p0, p1, p2, p3 = [x + y * 1j for x, y in zip(*[xy] * 2)]\n        print(1 if is_intersected_ls(p0, p1, p2, p3) else 0)\n\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    eps = 0\n    return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < eps) and (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < eps)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\nmain()"
  },
  {
    "language": "Python",
    "code": "class Point:\n    def __init__(self, x , y):\n        self.x = x\n        self.y = y\n    def __sub__(self, p):\n        x_sub = self.x - p.x\n        y_sub = self.y - p.y\n        return Point(x_sub, y_sub)\n\nclass Vector:\n    def __init__(self, p):\n        self.x = p.x\n        self.y = p.y\n    def norm(self):\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n\ndef cross(v1, v2):\n    return v1.x * v2.y - v1.y * v2.x\n\ndef dot(v1, v2):\n    return v1.x * v2.x + v1.y * v2.y\n\ndef ccw(p0, p1, p2):\n    a = Vector(p1 - p0)\n    b = Vector(p2 - p0)\n    cross_ab = cross(a, b)\n    if cross_ab > 0:\n        return 1\n    elif cross_ab < 0:\n        return -1\n    elif dot(a, b) < 0:\n        return 1\n    elif a.norm() < b.norm():\n        return -1\n    else:\n        return 0\n\ndef intersect(p1, p2, p3, p4):\n    if (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) and \\\n       (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0):\n        print('1')\n    else:\n        print('0')\n\nimport sys\n\nfile_input = sys.stdin\n\nsq = file_input.readline()\n\nfor line in file_input:\n    x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, line.split())\n    p0 = Point(x_p0, y_p0)\n    p1 = Point(x_p1, y_p1)\n    p2 = Point(x_p2, y_p2)\n    p3 = Point(x_p3, y_p3)\n    intersect(p0, p1, p2, p3)"
  },
  {
    "language": "Python",
    "code": "def cross(a,b):return a[0]*b[1] - a[1]*b[0]\n\nq = range(int(input()))\nfor i in q:\n    a,b,c,d,e,f,g,h = [int(x) for x in input().split()]\n    A = [c-a,d-b]; B = [e-a,f-b]; C = [g-a,h-a];\n    D = [g-e,h-f]; E = [a-e,b-f]; F = [c-e,d-f];\n    T = max(a,c) < min(e,g)\n    if max(a,c) < min(e,g) or max(e,g) < min(a,c) or max(b,d) < min(f,h) or max(f,h) < min(b,d):\n        print(\"0\")\n    elif cross(A,B) * cross(A,C) <= 1e-12 and cross(D,E) * cross(D,F) <= 1e-12:\n        print(\"1\")\n    else:\n        print(\"0\")"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n    def __mul__(self, other):\n        return Point(self.x * other, self.y * other)\n    def __floordiv__(self, other):\n        return Point(self.x / other, self.y / other)\n    def __repr__(self):\n        return str(self.x) + ' ' + str(self.y)\n\nclass Vector(Point):\n    pass\n\nclass Line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Segment(Line):\n    pass\n\ndef points_to_vector(p1, p2):\n    x = p1.x - p2.x\n    y = p1.y - p2.y\n    return Vector(x, y)\n\ndef vector(p):\n    return Vector(p.x, p.y)\n\ndef dot(v1, v2):\n    return v1.x * v2.x + v1.y * v2.y\n\ndef cross(v1, v2):\n    return v1.x * v2.y - v1.y * v2.x\n\ndef norm(v):\n    return v.x**2 + v.y**2\n\ndef distance(v):\n    return math.sqrt(norm(v))\n\ndef project(s, p):\n    base = points_to_vector(s.p1, s.p2)\n    hypo = points_to_vector(p, s.p1)\n    r = dot(hypo, base) / norm(base)\n    return s.p1 + base * r\n\ndef reflect(s, p):\n    return p + (project(s, p) -p) * 2\n\n# def get_distance(s1, s2):\n#     #TODO: Define intersect()\n#     if insersect(s1, s2):\n#         return 0\n#     d1 = get_distance_sp(s1, s2.p1)\n#     d2 = get_distance_sp(s1, s2.p2)\n#     d3 = get_distance_sp(s2, s1.p1)\n#     d4 = get_distance_sp(s2, s1.p2)\n#     return min(d1, min(d2, min(d3, d4)))\n\ndef get_distance_pp(p1, p2):\n    return distance(p1 - p2)\n\ndef get_distance_lp(l, p):\n    return distance(cross(l.p2 - l.p1, p - l.p1)) / distance(l.p2 - l.p1)\n\ndef get_distance_sp(s, p):\n    if dot(s.p2 - s.p1, p - s.p1) < 0:\n        return distance(p - s.p1)\n    elif dot(s.p1 - s.p2, p - s.p2) < 0:\n        return distance(p - s.p2)\n    else:\n        return get_distance_lp(s, p)\n\ndef ccw(p0, p1, p2):\n    EPS = 1e-10\n    COUNTER_CLOCKWISE = 1\n    CLOCKWISE = -1\n    ONLINE_BACK = 2\n    ONLINE_FRONT = -2\n    ON_SEGMENT = 0\n    v1 = p1 - p0\n    v2 = p2 - p0\n    if cross(v1, v2) > EPS:\n        return COUNTER_CLOCKWISE\n    elif cross(v1, v2) < -EPS:\n        return CLOCKWISE\n    elif dot(v1, v2) < -EPS:\n        return ONLINE_BACK\n    elif norm(v1) < norm(v2):\n        return ONLINE_FRONT\n    else:\n        return ON_SEGMENT\n\ndef intersect_p(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\ndef intersect_s(s1, s2):\n    return intersect_p(s1.p1, s1.p2, s2.p1, s2.p2)\n\n\nimport sys\n# sys.stdin = open('input.txt')\n\nq = int(input())\nfor i in range(q):\n    temp = list(map(int, input().split()))\n    points = []\n    for j in range(0, 8, 2):\n        points.append(Point(temp[j], temp[j+1]))\n    s1 = Segment(points[0], points[1])\n    s2 = Segment(points[2], points[3])\n    if intersect_s(s1, s2):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import starmap\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\nq = int(input())\nwhile q:\n    q -= 1\n    p0, p1, p2, p3 = starmap(complex, zip(*[map(int, input().split())] * 2))\n    max_x1, min_x1 = (p0.real, p1.real) if p0.real > p1.real else (p1.real, p0.real)\n    max_y1, min_y1 = (p0.imag, p1.imag) if p0.imag > p1.imag else (p1.imag, p0.imag)\n    max_x2, min_x2 = (p2.real, p3.real) if p2.real > p3.real else (p3.real, p2.real)\n    max_y2, min_y2 = (p2.imag, p3.imag) if p2.imag > p3.imag else (p3.imag, p2.imag)\n    if any((max_x1 < min_x2, max_x2 < min_x1, max_y1 < min_y2, max_y2 < min_y1)):\n        print(0)\n        continue\n\n    print(int(cross(p1 - p0, p2 - p0) * cross(p1 - p0, p3 - p0) < 1e-6 and\n              cross(p3 - p2, p0 - p2) * cross(p3 - p2, p1 - p2) < 1e-6))"
  },
  {
    "language": "Python",
    "code": "class Point:\n    def __init__(self, x , y):\n        self.x = x\n        self.y = y\n    def __sub__(self, p):\n        x_sub = self.x - p.x\n        y_sub = self.y - p.y\n        return Point(x_sub, y_sub)\n\nclass Vector:\n    def __init__(self, p):\n        self.x = p.x\n        self.y = p.y\n\ndef cross(v1, v2):\n    return v1.x * v2.y - v1.y * v2.x\n\ndef ccw(p0, p1, p2):\n    a = Vector(p1 - p0)\n    b = Vector(p2 - p0)\n    cross_ab = cross(a, b)\n    if cross_ab > 0:\n        return 1\n    elif cross_ab < 0:\n        return -1\n    else:\n        return 0\n\ndef intersect(p1, p2, p3, p4):\n    if (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) and \\\n       (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0):\n        print('1')\n    else:\n        print('0')\n\nimport sys\n\nfile_input = sys.stdin\n\nsq = file_input.readline()\n\nfor line in file_input:\n    x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, line.split())\n    p0 = Point(x_p0, y_p0)\n    p1 = Point(x_p1, y_p1)\n    p2 = Point(x_p2, y_p2)\n    p3 = Point(x_p3, y_p3)\n    intersect(p0, p1, p2, p3)"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    elif l.s == m.e or l.s == m.s or l.e == m.e or l.e == m.s:return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(b,1) ; l2 = Line(b,1)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef isOn(l,m):\n    a = dif(l.e,l.s);b = dif(m.s,l.s);c = dif(m.e,l.s)\n    d = dif(m.e,m.s);e = dif(l.s,m.s);f = dif(l.e,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    else:return False\n        \n    \ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    if isOn(l,m):return True\n    elif l.s == m.e or l.s == m.s or l.e == m.e or l.e == m.s:return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "def cross(a,b):return a[0]*b[1] - a[1]*b[0]\n\nq = range(int(input()))\nfor i in q:\n    a,b,c,d,e,f,g,h = [int(x) for x in input().split()]\n    A = [c-a,d-b]; B = [e-a,f-b]; C = [g-a,h-b];\n    D = [g-e,h-f]; E = [a-e,b-f]; F = [c-e,d-f];\n    if max(a,c) < min(e,g) or max(e,g) < min(a,c) or max(b,d) < min(f,h) or max(f,h) < min(b,d):\n        print(\"0\")\n    elif cross(A,B) * cross(A,C) <= 0 and cross(D,E) * cross(D,F) <= 0:\n        print(\"1\")\n    else:\n        print(\"0\")"
  },
  {
    "language": "Python",
    "code": "def dot(vx1, vy1, vx2, vy2):\n    return vx1*vx2 + vy1*vy2\n\n\ndef cross(vx1, vy1, vx2, vy2):\n    return vx1*vy2 - vy1*vx2\n\n\nq = int(input())\n\nfor _ in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, input().split())\n\n    c1 = cross(x1 - x0, y1 - y0, x2 - x0, y2 - y0)\n    c2 = cross(x1 - x0, y1 - y0, x3 - x0, y3 - y0)\n    c3 = cross(x3 - x2, y3 - y2, x0 - x2, y0 - y2)\n    c4 = cross(x3 - x2, y3 - y2, x1 - x2, y1 - y2)\n    d1 = dot(x1 - x0, y1 - y0, x2 - x0, y2 - y0)\n    d2 = dot(x1 - x0, y1 - y0, x3 - x0, y3 - y0)\n    d3 = dot(x0 - x1, y0 - y1, x2 - x1, y2 - y1)\n    d4 = dot(x0 - x1, y0 - y1, x3 - x1, y3 - y1)\n\n    if c1*c2 <= 0 and c3*c4 <= 0:\n        if (d1 < 0 and d2 < 0) or (d3 < 0 and d4 < 0):\n            print(0)\n        else:\n            print(1)\n    else:\n        print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "def on_segment(u0,v0,u1,v1,u2,v2):\n     return u1<=max(u0,u2) and u1>=min(u0,u2) and v1<=max(v0,v2) and v1>=min(v0,v2)\n\ndef signed_area(x0,y0,x1,y1):\n    return (x0*y1-x1*y0)\n\nq=int(input())\n\nfor _ in [0]*q:\n    x0,y0,x1,y1,x2,y2,x3,y3=map(int,input().split())\n    ta=signed_area(x1-x0,y1-y0,x2-x0,y2-y0)\n    tb=signed_area(x1-x0,y1-y0,x3-x0,y3-y0)\n    tc=signed_area(x3-x2,y3-y2,x0-x2,y0-y2)\n    td=signed_area(x3-x2,y3-y2,x1-x2,y1-y2)\n\n    \"\"\"\n    print(ta/2)\n    print(tb/2)\n    print(tc/2)\n    print(td/2)\n    \n    print(on_segment(x0,y0,x2,y2,x1,y1))\n    print(on_segment(x0,y0,x3,y3,x1,y1))\n    print(on_segment(x2,y2,x0,y0,x3,y3))\n    print(on_segment(x2,y2,x1,y1,x3,y3))\n    \"\"\"\n\n    if ta*tb<0 and tc*td<0:\n        print(\"1\")\n    elif ta==0 and on_segment(x0,y0,x2,y2,x1,y1):\n        print(\"1\")\n    elif tb==0 and on_segment(x0,y0,x3,y3,x1,y1):\n        print(\"1\")\n    elif tc==0 and on_segment(x2,y2,x0,y0,x3,y3):\n        print(\"1\")\n    elif td==0 and on_segment(x2,y2,x1,y1,x3,y3):\n        print(\"1\")\n    else:\n        print(\"0\")\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nq = int(input())\n\ndef norm(a):\n    return sqrt(a[0] ** 2 + a[1] ** 2)\n\ndef dot(a, b):\n    return sum([i * j for i,j in zip(a, b)])\n\ndef sub(a, b):\n    return [a[0] - b[0],a[1] - b[1]]\n\ndef cross(a, b):\n    return  a[0] * b[1] - a[1] * b[0]\n\ndef ccw(a, b, c):\n    x = sub(b, a)\n    y = sub(c, a)\n    if cross(x, y) > 0: return 1\n    if cross(x, y) < 0: return -1\n    if dot(x, y) < 0: return 2\n    if norm(x) < norm(y): return -2\n    return 0\n\ndef intersect(p1, p2, p3, p4):\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and \\\n           ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\nfor i in range(q):\n    xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int, input().split())\n    print(1 if intersect([xp0, yp0], [xp1, yp1], [xp2, yp2], [xp3, yp3]) else 0)"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : return False\n    \ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    if cross(a,d) == 0 and (isOn(b,a) or isOn(c,a) or isOn(e,d) or isOn(f,d)):\n        print(isOn(b,a),isOn(c,a),isOn(e,d),isOn(f,d))\n        print(\"here1\")\n        return True\n    elif cross(a,b) * cross(a,c) > 0 or cross(d,e) * cross(d,f) > 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "import math\nEPS=1e-10\n\n#点类\nclass Point():\n\n    def __init__(self,x,y):\n        self.x=x\n        self.y=y\n    \n    def __sub__(self,p):\n        return Point(self.x - p.x, self.y - p.y);\n    def __add__(self,p):\n        return Point(self.x + p.x, self.y + p.y)\n           \n    def __mul__(self,a): #a: scalar\n        return Point(self.x * a, self.y * a)\n    def __truediv__(self,a): #a: scalar\n        return Point(self.x / a, self.y / a)\n   \n    def __str__(self):\n       return  str(self.x)+','+str(self.y)\n    def __repr__(self):\n        return  'Point('+str(self.x)+','+str(self.y)+')'\n    \n    def __lt__(self, other):    \n        if self.y-other.y==0:\n            return self.x<other.x\n        else:\n            return self.y<other.y\n            \n    def __eq__(self, other):    \n        return abs(self.x-other.x)<EPS and  abs(self.y-other.y)<EPS\n\n\n# 线段类\nclass Segment():\n    def __init__(self,p1, p2):\n        self.p1=p1\n        self.p2=p2\n    def __str__(self):\n        return  'segment:('+str(self.p1)+';'+str(self.p2)+')'\n    def __repr__(self):\n        return  'segment:('+str(self.p1)+';'+str(self.p2)+')'\n\n\nclass Circle():\n    def __init__(self,c, r):\n        self.c=c\n        self.r=r\n\n    def __str__(self):\n       return  'Circle:(center point: '+str(self.c)+'; radius: '+str(self.r)+')'\n    def __repr__(self):\n       return  'Circle:(center point: '+str(self.c)+'; radius: '+str(self.r)+')'\n   \n    \n#定义多边形\nclass Polygon():\n    def __init__(self,ps=[]):\n        self.ps=ps\n        self.size=len(ps)\n  \n    def __getitem__(self, i):#iter override \n        return self.ps[i]  \n    def __setitem__(self,i,p): \n        self.ps[i]=p               \n    def __iter__(self):     \n        return self.ps  \n    \n    def addpoint(self,i,p):\n        self.ps.insert(i,p)\n        self.size+=1\n    def delpoint(self,i):\n        self.size-=1\n        return self.ps.pop(i)\n    def sortYX(self):\n        self.ps.sort()\n        #self.ps.sort(key=attrgetter('y','x'))\n    def __str__(self):\n       return  'Polygon:'+str(tuple(self.ps))\n    def __repr__(self):\n       return  'Polygon:'+str(tuple(self.ps))\n        \n    def __len__(self):\n        return len(self.ps)\n    def __eq__(self, other):  \n         return self.ps==other.ps\n    \n    def draw(self):\n      \n       turtle.screensize(800,800,\"black\")\n       #turtle.setup(width=0.9,height=0.9)\n       turtle.title(\"Polygon convex hull\")\n       turtle.setworldcoordinates(-400,-400,400,400) \n\n       #print(turtle.screensize())\n       #mywin = turtle.Screen()    \n       #mywin.   \n       t=turtle.Turtle() \n       #mywin=turtle.Screen()\n       \n       t.pencolor(\"red\")\n       for pt in self.ps:\n           t.goto(pt.x,pt.y)\n           t.dot(10,'white')\n       \n \n\n#***************************点、向量****************************\n\n#向量的模的平方\ndef norm(p):  \n    return p.x * p.x + p.y * p.y\n\n\n#向量P的长度\ndef length(p):\n    return math.sqrt(p.x * p.x + p.y * p.y)\n\n\n# 向量的(点)内积, dot(a,b)=|a|*|b|*cos(a,b) (从a,到b的角)\n# =============================================================================\n# r=dot(a,b),得到矢量a和b的点积，如果两个矢量都非零矢量  \n# r<0：两矢量夹角为钝角； \n# r=0：两矢量夹角为直角； \n# r>0：两矢量夹角为锐角  \n# =============================================================================\ndef dot(a, b) :\n    return a.x * b.x + a.y * b.y\n\n\n\n# =============================================================================\n# # 向量的（叉）外积 cross(a,b)=|a||b|*sin(a,b) (从a,到b的角)由a,b构成的平行四边的面积\n# r=cross(a,b),得到向量a和向量b的叉积  \n# r>0：b在矢量a的逆时针方向；  \n# r=0：a,b 平行共线；  \n# r<0：b在向量a的顺时针方向 \n# =============================================================================\ndef cross( a, b) :\n    return a.x * b.y - a.y * b.x\n\n# 点p在线段s上的投影\ndef project(s, p):\n    base = s.p2 - s.p1\n    r = dot(p - s.p1, base) / norm(base)\n    return s.p1 + base * r \n\n\n# 点a到点b的距离\ndef getDistance(a, b) :\n    return length(a - b)\n\n# 线段l和点p的距离\ndef getDistanceLP(l, p) :\n    return abs( cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1) )\n\n#getDistanceLP(s3, p7)\n    \n#线段s与点p的距离\ndef getDistanceSP(s, p) :\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0):\n        return length(p - s.p1)\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0):\n        return length(p - s.p2)\n    return getDistanceLP(s, p)\n\n#print(getDistanceLP(s3, Point(5,5)))\n#print(getDistanceSP(s3, Point(5,5)))\n\n\n#*************************线段********************************/\n# 线段s1，s2是否正交 <==> 内积为0\ndef isOrthogonalSG(s1, s2) :\n    return abs(dot(s1.p2 - s1.p1, s2.p2 - s2.p1))<EPS\n\n\n# 线段s1，s2是否平行 <==> 叉积为0\ndef isParallelLN(s1,s2) :\n    return abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1))<0\n\n\n\n\n# 逆时针方向ccw（Counter-Clockwise）\nCOUNTER_CLOCKWISE = 1;\nCLOCKWISE = -1;\nONLINE_BACK = -2;\nONLINE_FRONT = 2;\nON_SEGMENT = 0;\n\ndef ccw(p0, p1, p2) :\n    a = p1 - p0\n    b = p2 - p0\n    if (cross(a, b) > EPS):\n        return COUNTER_CLOCKWISE\n    if (cross(a, b) < -EPS):\n        return CLOCKWISE\n    if (dot(a, b) < -EPS):\n        return ONLINE_BACK\n    if (norm(a) < norm(b)):\n        return ONLINE_FRONT\n    \n    return ON_SEGMENT;\n\n\ndef toleft(p0,p1,p2):\n    a = p1 - p0\n    b = p2 - p0  \n    tmp=cross(a,b)\n    if tmp > EPS:\n        return 1\n    elif abs(tmp)<EPS and norm(a)<=norm(b):\n        return 2  #共线，p2在p0p1的右延长线上\n    elif abs(tmp)<EPS and norm(a)>norm(b):\n        return -2  #共线，p2在p0p1的left延长线上    \n    else:\n        return -1\n\n\n#以线段s为对称轴与点p成线对称的点\ndef reflect(s, p) :\n    return p + (project(s, p) - p) * 2.0\n\n\n\n#判断线段s1和s2是否相交\ndef intersectSG(s1, s2) :\n    return intersectP4(s1.p1, s1.p2, s2.p1, s2.p2)\n\n\n# 线段s1和线段s2的距离\ndef getDistanceSG(s1, s2) :\n    # 相交\n    if (intersectSG(s1, s2)):\n        return 0.0\n    return min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\\\n        getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\n# 判断线段p1p2和线段p3p4是否相交\ndef intersectP4(p1, p2, p3, p4) :\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and \\\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\n\n\n\n\nq=int(input())\nfor i in range(0,q):\n    s= [int(x) for x in input().split()]\n    p0=Point(s[0],s[1])\n    p1=Point(s[2],s[3])\n    p2=Point(s[4],s[5])\n    p3=Point(s[6],s[7])\n    \n    \n    if p0==p2 or p0==p3 or p1==p2 or p1==p3:\n        print(1)\n\n    elif cross(p1-p0,p2-p0)*cross(p1-p0,p3-p0)<0 and \\\n           cross(p3-p2,p0-p2)*cross(p3-p2,p1-p2)<0:\n       print(1)\n    \n    elif cross(p1-p0,p2-p0)==0 and dot (p1-p0,p2-p0)>0 and \\\n            length(p2-p0)<length(p1-p0):\n        print(1)\n                \n    elif cross(p1-p0,p3-p0)==0 and dot (p1-p0,p3-p0)>0 and \\\n            length(p3-p0)<length(p3-p0):\n        print(1)\n\n\n    elif cross(p3-p2,p0-p2)==0 and dot (p3-p2,p0-p2)>0 and \\\n            length(p0-p2)<length(p3-p2):\n        print(1)\n                \n    elif cross(p3-p2,p1-p2)==0 and dot (p3-p2,p1-p2)>0 and \\\n            length(p1-p2)<length(p3-p2):\n        print(1)\n\n    else:\n       print(0)\n       \n"
  },
  {
    "language": "Python",
    "code": "def cross(v1,v2):\n\treturn v1.real*v2.imag-v1.imag*v2.real\n\ndef isOnSegment(p1,p2,p):\n\treturn abs(p1-p)+abs(p2-p)-abs(p1-p2)<=1e-8\n\ndef isIntersection(p1,p2,p3,p4):\n\tif cross(p2-p1,p4-p3)==0:\n\t\treturn any(isOnSegment(q1,q2,q3)for q1,q2,q3 in ((p1,p2,p3),(p1,p2,p4),(p3,p4,p1),(p3,p4,p2)))\n\treturn cross(p2-p1,p3-p1)*cross(p2-p1,p4-p1)<=1e-8>=cross(p4-p3,p1-p3)*cross(p4-p3,p2-p3)\n\nimport sys\ninput = sys.stdin.buffer.readline\nans=[]\nfor _ in range(int(input())):\n\tm=map(int,input().split())\n\tans.append(int(isIntersection(*[complex(x,y)for x,y in zip(*[iter(m)]*2)])))\nprint(\"\\n\".join(map(str,ans)))\n"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c) or isOn(c,a) or isOn(b,a):\n        print(1)\n    elif cross(a,b) == 0 and cross(a,c) == 0:\n        print(0)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1)"
  },
  {
    "language": "Python",
    "code": "from itertools import starmap\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\nq = int(input())\nwhile q:\n    q -= 1\n    p0, p1, p2, p3 = starmap(complex, zip(*[map(int, input().split())] * 2))\n    print(int(cross(p1 - p0, p2 - p0) * cross(p1 - p0, p3 - p0) < 1e-6 and\n              cross(p3 - p2, p0 - p2) * cross(p3 - p2, p1 - p2) < 1e-6))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef is_Crossed(OA, OC, OB, OD):\n    \"\"\"\n    AOJ: CGL_2B \n    ref. http://www.fumiononaka.com/Business/html5/FN1312004.html\n    \"\"\"\n    AC = Point(OC.x - OA.x, OC.y - OA.y)\n    BD = Point(OD.x - OB.x, OD.y - OB.y)\n    AB = Point(OB.x - OA.x, OB.y - OA.y)\n    BC = Point(OC.x - OB.x, OC.y - OB.y)\n    AD = Point(OD.x - OA.x, OD.y - OA.y)\n    BA = Point(-AB.x, -AB.y)\n\t\n    if crossProduct2D(AC, BD) == 0: return 0\n    if crossProduct2D(BD, BA) * crossProduct2D(BD, BC) > 0: return 0\n    else:\n\t    if crossProduct2D(AC, AB) * crossProduct2D(AC, AD) > 0: return 0\n\t    else: return 1\n\t        \ndef crossProduct2D(Point0, Point1):\n    return Point0.x * Point1.y - Point0.y * Point1.x\n\nif __name__ == \"__main__\":\n    n = int(raw_input())\n    for i in range(n):\n        xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int,raw_input().split())\n        P0 = Point(xp0, yp0)\n        P1 = Point(xp1, yp1)\n        P2 = Point(xp2, yp2)\n        P3 = Point(xp3, yp3)\n        print is_Crossed(P0, P1, P2, P3)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\nfrom typing import List, Tuple\nfrom math import sqrt\nfrom enum import IntEnum\n\nEPS = 1e-10\n\n\ndef float_equal(x: float, y: float) -> bool:\n    return abs(x - y) < EPS\n\n\nclass PointLocation(IntEnum):\n    COUNTER_CLOCKWISE = 1\n    CCW = 1\n    CLOCKWISE = -1\n    CW = -1\n    ONLINE_BACK = 2\n    O_B = 2\n    ONLINE_FRONT = -2\n    O_F = -2\n    ON_SEGMENT = 0\n    O_S = 0\n\n\nPL = PointLocation\n\n\nclass Point:\n\n    def __init__(self, x: float=0.0, y: float=0.0) -> None:\n        self.x = x\n        self.y = y\n\n    def __repr__(self) -> str:\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Point):\n            # print(\"NotImplemented in Point\")\n            return NotImplemented\n        return float_equal(self.x, other.x) and \\\n            float_equal(self.y, other.y)\n\n    def __add__(self, other: 'Point') -> 'Point':\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other: 'Point') -> 'Point':\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, k: float) -> 'Point':\n        return Point(self.x * k, self.y * k)\n\n    def __rmul__(self, k: float) -> 'Point':\n        return self * k\n\n    def __truediv__(self, k: float) -> 'Point':\n        return Point(self.x / k, self.y / k)\n\n    def __lt__(self, other: 'Point') -> bool:\n        return self.y < other.y \\\n            if abs(self.x - other.x) < EPS \\\n            else self.x < other.x\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        return sqrt(self.norm())\n\n    def dot(self, other: 'Point') -> float:\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other: 'Point') -> float:\n        return self.x * other.y - self.y * other.x\n\n    def is_orthogonal(self, other: 'Point') -> bool:\n        return float_equal(self.dot(other), 0.0)\n\n    def is_parallel(self, other: 'Point') -> bool:\n        return float_equal(self.cross(other), 0.0)\n\n    def distance(self, other: 'Point') -> float:\n        return (self - other).abs()\n\n    def in_side_of(self, seg: 'Segment') -> bool:\n        return seg.vector().dot(\n            Segment(seg.p1, self).vector()) >= 0\n\n    def in_width_of(self, seg: 'Segment') -> bool:\n        return \\\n            self.in_side_of(seg) and \\\n            self.in_side_of(seg.reverse())\n\n    def distance_to_line(self, seg: 'Segment') -> float:\n        return \\\n            abs((self - seg.p1).cross(seg.vector())) / \\\n            seg.length()\n\n    def distance_to_segment(self, seg: 'Segment') -> float:\n        if not self.in_side_of(seg):\n            return self.distance(seg.p1)\n        if not self.in_side_of(seg.reverse()):\n            return self.distance(seg.p2)\n        else:\n            return self.distance_to_line(seg)\n\n    def location(self, seg: 'Segment') -> PointLocation:\n        p = self - seg.p1\n        d = seg.vector().cross(p)\n        if d > EPS:\n            return PointLocation.COUNTER_CLOCKWISE\n        if d < -EPS:\n            return PointLocation.CLOCKWISE\n        if seg.vector().dot(p) < 0.0:\n            return PointLocation.ONLINE_BACK\n        if seg.vector().norm() < p.norm():\n            return PointLocation.ONLINE_FRONT\n        return PointLocation.ON_SEGMENT\n\n\nVector = Point\n\n\nclass Segment:\n\n    def __init__(self, p1: Point = None, p2: Point = None) -> None:\n        self.p1: Point = Point() if p1 is None else p1\n        self.p2: Point = Point() if p2 is None else p2\n\n    def __repr__(self) -> str:\n        return \"Segment({}, {})\".format(self.p1, self.p2)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Segment):\n            # print(\"NotImplemented in Segment\")\n            return NotImplemented\n        return self.p1 == other.p1 and self.p2 == other.p2\n\n    def vector(self) -> Vector:\n        return self.p2 - self.p1\n\n    def reverse(self) -> 'Segment':\n        return Segment(self.p2, self.p1)\n\n    def length(self) -> float:\n        return self.p1.distance(self.p2)\n\n    def is_orthogonal(self, other: 'Segment') -> bool:\n        return self.vector().is_orthogonal(other.vector())\n\n    def is_parallel(self, other: 'Segment') -> bool:\n        return self.vector().is_parallel(other.vector())\n\n    def projection(self, p: Point) -> Point:\n        v = self.vector()\n        vp = p - self.p1\n        return v.dot(vp) / v.norm() * v + self.p1\n\n    def reflection(self, p: Point) -> Point:\n        x = self.projection(p)\n        return p + 2 * (x - p)\n\n    def intersect_ratio(self, other: 'Segment') -> Tuple[float, float]:\n        a = self.vector()\n        b = other.vector()\n        c = self.p1 - other.p1\n        s = b.cross(c) / a.cross(b)\n        t = a.cross(c) / a.cross(b)\n        return s, t\n\n    def intersects(self, other: 'Segment') -> bool:\n        d0 = self.p1.location(other)\n        d1 = self.p2.location(other)\n        d2 = other.p1.location(self)\n        d3 = other.p2.location(self)\n        return d0 * d1 * d2 * d3 == 0 or \\\n            (d0 * d1 == -1 and d2 * d3 == -1)\n\n    def intersection(self, other: 'Segment') -> Point:\n        s, _ = self.intersect_ratio(other)\n        return self.p1 + s * self.vector()\n\n    def distance_with_segment(self, other: 'Segment') -> float:\n        if not self.is_parallel(other) and \\\n                self.intersects(other):\n            return 0\n        else:\n            return min(\n                self.p1.distance_to_segment(other),\n                self.p2.distance_to_segment(other),\n                other.p1.distance_to_segment(self),\n                other.p2.distance_to_segment(self))\n\n\nLine = Segment\n\n\nclass Circle:\n\n    def __init__(self, c: Point=None, r: float=0.0) -> None:\n        self.c: Point = Point() if c is None else c\n        self.r: float = r\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Circle):\n            return NotImplemented\n        return self.c == other.c and self.r == other.r\n\n    def __repr__(self) -> str:\n        return \"Circle({}, {})\".format(self.c, self.r)\n\ndef main() -> None:\n    q = int(input())\n\n    for _ in range(q):\n        x0, y0, x1, y1, x2, y2, x3, y3 = \\\n            [int(x) for x in input().split()]\n        s1 = Segment(Point(x0, y0), Point(x1, y1))\n        s2 = Segment(Point(x2, y2), Point(x3, y3))\n        print(1 if s1.intersects(s2) else 0)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\n\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(other / self.x, other / self.y)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def abs(self):\n        from math import sqrt\n        return sqrt(self.norm())\n\n    def ccw(self, p0, p1):\n        # ??????2???(p0, p1)?????????????????????????????????????????¢????????????\n        a = Vector(p1 - p0)\n        b = Vector(self - p0)\n        if Vector.cross(a, b) > Point.epsilon:\n            return 1 # 'COUNTER_CLOCKWISE'\n        elif Vector.cross(a, b) < -Point.epsilon:\n            return -1 # 'CLOCKWISE'\n        elif Vector.dot(a, b) < -Point.epsilon:\n            return 2 # 'ONLINE_BACK'\n        elif a.norm() < b.norm():\n            return -2 # 'ONLINE_FRONT'\n        else:\n            return 0 # 'ON_SEGMENT'\n\n    def project(self, s):\n        # ??????(Point)????????????s??????????????????????????????????????§?¨?(?°???±)????±???????\n        base = Vector(s.p2 - s.p1)\n        a = Vector(self - s.p1)\n        r = Vector.dot(a, base)\n        r /= base.norm()\n        return s.p1 + base * r\n\n    def reflect(self, s):\n        # ??????s???????§°?????¨?????????????????¨???????§°??????????????§?¨?(????°?)????±???????\n        proj = self.project(s)\n        return self + (proj - self)*2\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(other / self.x, other / self.y)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return Vector.dot(a, b) == 0.0\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return Vector.cross(a, b) == 0.0\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    def intersect(self, s):\n        # ????????¨??????????????????????????????????????????????????????\n        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)\n        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)\n        return ans1 <= 0 and ans2 <= 0\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, c=Point(), r=0.0):\n        self.c = c\n        self.r = r\n\n\n\ndef cross_point(s1, s2):\n    base = s2.p2 - s2.p1\n    d1 = abs(Vector.cross(base, s1.p1-s2.p1))\n    d2 = abs(Vector.cross(base, s1.p2-s2.p1))\n    t = d1 / (d1 + d2)\n    return s1.p1 + (s1.p2 - s1.p1) * t\n\n\ndef main(args):\n    q = int(input())\n    for _ in range(q):\n        x_p0, y_p0, x_p1, y_p1, x_p2, y_p2, x_p3, y_p3 = map(int, input().split())\n        p0 = Point(x_p0, y_p0)\n        p1 = Point(x_p1, y_p1)\n        p2 = Point(x_p2, y_p2)\n        p3 = Point(x_p3, y_p3)\n        s1 = Segment(p0, p1)\n        s2 = Segment(p2, p3)\n        result = s1.intersect(s2)\n        print(int(result))\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass Vector2():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, v):\n        return Vector2(self.x+v.x, self.y+v.y)\n\n    def __sub__(self, v):\n        return Vector2(self.x-v.x, self.y-v.y)\n\n    def __mul__(self, v):\n        return Vector2(self.x*v, self.y*v)\n\n    def __truediv__(self, v):\n        return Vector2(self.x/v, self.y/v)\n\n    def __abs__(self):\n        return math.sqrt(float(self.x*self.x+self.y*self.y))\n\n    def dot(self, v):\n        return self.x*v.x+self.y*v.y\n\n    def cross(self, v):\n        return self.x*v.y-self.y*v.x\n\n    def norm(self):\n        d = abs(self)\n        return Vector2(self.x/d, self.y/d)\n\n\ndef distanceLP(v1, v2, p):\n    '''\n    v1 -> v2の直線とpとの距離\n    '''\n    return abs((v2-v1).cross(p-v1))/abs(v2-v1)\n\n\ndef distanceSP(v1, v2, p):\n    '''\n    v1 -> v2の線分とpとの距離\n    '''\n    if (v2-v1).dot(p-v1) < 0.0:\n        return abs(p-v1)\n    if (v1-v2).dot(p-v2) < 0.0:\n        return abs(p-v2)\n    return distanceLP(v1, v2, p)\n\n\ndef intersect(p1, p2, p3, p4):\n    '''\n    p1p2とp3p4の交差判定\n    '''\n    #t1 = (p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x)\n    #t2 = (p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x)\n    #t3 = (p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x)\n    #t4 = (p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x)\n    # return (t1*t2) <= 0.0 and (t3*t4) <= 0.0\n    c1 = ccw(p1, p2, p3)*ccw(p1, p2, p4)\n    c2 = ccw(p3, p4, p1)*ccw(p3, p4, p2)\n    return c1 <= 0.0 and c2 <= 0.0\n\n\ndef distance(a1, a2, b1, b2):\n    '''\n    線分a1a2とb1b2の距離\n    '''\n    if intersect(a1, a2, b1, b2):\n        return 0.0\n    return min([\n        min([distanceSP(a1, a2, b1), distanceSP(a1, a2, b2)]),\n        min([distanceSP(b1, b2, a1), distanceSP(b1, b2, a2)])\n    ])\n\n\ndef ccw(p0, p1, p2):\n    c = (p1-p0).cross(p2-p0)\n    if math.isclose(c, 0.0, abs_tol=1e-10):\n        d = (p1-p0).dot(p2-p0)\n        if d < 0.0:\n            return 1\n        else:\n            d1 = abs(p1-p0)\n            d2 = abs(p2-p0)\n            if d1 < d2:\n                return -1\n            else:\n                return 0\n    elif c < 0.0:\n        return -1\n    else:\n        return 1\n\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, input().split())\n    p0 = Vector2(x0, y0)\n    p1 = Vector2(x1, y1)\n    p2 = Vector2(x2, y2)\n    p3 = Vector2(x3, y3)\n    print(\"1\" if intersect(p0, p1, p2, p3) else \"0\")\n\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\n\ndef cross_product(vect1, vect2):\n    return vect1[0]*vect2[1] - vect1[1]*vect2[0]\n\n\ndef vector_minus(vect1, vect2):\n    return [el1 - el2 for el1, el2 in zip(vect1, vect2)]\n\n\ndef is_cross(l_from1, l_to1, l_from2, l_to2):\n    line1 = vector_minus(l_to1, l_from1)\n    line2 = vector_minus(l_to2, l_from2)\n\n    from1_to2_1 = vector_minus(l_from2, l_from1)\n    from1_to2_2 = vector_minus(l_to2, l_from1)\n\n    from2_to1_1 = vector_minus(l_from1, l_from2)\n    from2_to1_2 = vector_minus(l_to1, l_from2)\n\n    if cross_product(line1, from1_to2_1)*cross_product(line1, from1_to2_2) >= 0:\n        return 0\n    if cross_product(line2, from2_to1_1)*cross_product(line2, from2_to1_2) >= 0:\n        return 0\n    return 1\n\n\nif __name__ == '__main__':\n    Q = int(input())\n\n    for i in range(Q):\n        all_list = list(map(int, input().split()))\n        p0_list = all_list[:2]\n        p1_list = all_list[2:4]\n        p2_list = all_list[4:6]\n        p3_list = all_list[6:]\n\n        if is_cross(p0_list, p1_list, p2_list, p3_list):\n            print(\"1\")\n        else:\n            print(\"0\")\n\n"
  },
  {
    "language": "Python",
    "code": "q = int(raw_input())\nfor _ in xrange(q):\n  x0,y0,x1,y1,x2,y2,x3,y3 = map(float, raw_input().split())\n  ta = (x2 - x3) * (y0 - y2) + (y2 - y3) * (x2 - x0)\n  tb = (x2 - x3) * (y1 - y2) + (y2 - y3) * (x2 - x1)\n  tc = (x0 - x1) * (y2 - y0) + (y0 - y1) * (x0 - x2)\n  td = (x0 - x1) * (y3 - y0) + (y0 - y1) * (x0 - x3)\n\n  if tc * td <= 0 and ta * tb <= 0:\n    if tc * td == 0 and ta * tb == 0:\n      outer1 = (x2 - x0) * (x2 - x1) + (y2 - y0) * (y2 - y1)\n      outer2 = (x3 - x0) * (x3 - x1) + (y3 - y0) * (y3 - y1)\n      outer3 = (x0 - x2) * (x0 - x3) + (y0 - y2) * (y0 - y3)\n      outer4 = (x1 - x2) * (x1 - x3) + (y1 - y2) * (y1 - y3)\n      if outer1 <= 0 or outer2 <= 0 or outer3 <= 0 or outer4 <= 0:\n        print 1\n      else:\n        print 0\n    else:\n      print 1\n  else:\n    print 0"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    t = (y2-y0)*dx0 - (x2-x0)*dy0\n    tm = dx1*dy0 - dy1*dx0\n    if t < 0:\n        t = -t\n        tm = -tm\n    if 0 <= s <= max(sm, 0) and 0 <= t <= max(tm, 0):\n        ov = dx0*dy1 - dy0*dx1\n        if ov == 0:\n            r0 = dx0**2 + dy0**2\n            r1 = (x2-x0)*dx0 + (y2-y0)*dy0\n            r2 = (x3-x0)*dx0 + (y3-y0)*dy0\n            if r1 > r2: r1, r2 = r2, r1\n            if r2 < 0 or r0 < r1:\n                print 0\n            else:\n                print 1\n        else:\n            print 1\n    else:\n        print 0"
  },
  {
    "language": "Python",
    "code": "class Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment():\n    def __init__(self, x1, y1, x2, y2):\n        self.p1 = Point(x1, y1)\n        self.p2 = Point(x2, y2)\n        self.slope = None\n        if self.p1.x == self.p2.x:\n            self.slope = float('inf')\n        else:\n            self.slope = (self.p2.y - self.p1.y)/(self.p2.x - self.p1.x)\n\n    def is_intersect(self, seg):\n        if self.slope == seg.slope: return False\n        a = (seg.p1.x - seg.p2.x) * (self.p1.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p1.x)\n        b = (seg.p1.x - seg.p2.x) * (self.p2.y - seg.p1.y) + (seg.p1.y - seg.p2.y) * (seg.p1.x - self.p2.x)\n        c = (self.p1.x - self.p2.x) * (seg.p1.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p1.x)\n        d = (self.p1.x - self.p2.x) * (seg.p2.y - self.p1.y) + (self.p1.y - self.p2.y) * (self.p1.x - seg.p2.x)\n        return a*b <= 0 and c*d <= 0\n\nq = int(input())\nfor i in range(q):\n    x0, y0, x1, y1, x2, y2, x3, y3 = list(map(int, input().split(' ')))\n    line1, line2 = Segment(x0, y0, x1, y1), Segment(x2, y2, x3, y3)\n    if line1.is_intersect(line2):\n        print(1)\n    else:\n        print(0)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Line:\n    def __init__(self,p1,p2):\n        if p1[1] < p2[1]:self.s=p2;self.e=p1\n        elif p1[1] > p2[1]:self.s=p1;self.e=p2\n        else:\n            if p1[0] < p2[0]:self.s=p1;self.e=p2\n            else:self.s=p2;self.e=p1\ndef dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef dif(a,b):return [x-y for x,y in zip(a,b)]\ndef isOn(l,m):\n    a = dif(l.e,l.s);b = dif(m.s,l.s);c = dif(m.e,l.s)\n    d = dif(m.e,m.s);e = dif(l.s,m.s);f = dif(l.e,m.s)\n    g = lambda a, b : cross(a,b)==0 and dot(a,b)>0 and dot(b,b)<dot(a,a)\n    print(a,b,c,d,e,f)\n    if g(a,b) or g(a,c) or g(d,e) or g(d,f):return True\n    else:return False\n        \n    \ndef InterSection(l,m):\n    a = dif(l.e,l.s);b = dif(m.e,l.s);c = dif(m.s,l.s)\n    d = dif(m.e,m.s);e = dif(l.e,m.s);f = dif(l.s,m.s)\n    print(a,b,c,d,e,f)\n    if isOn(l,m):return True\n    elif l.s == m.e or l.s == m.s or l.e == m.e or l.e == m.s:return True\n    elif cross(a,b) * cross(a,c) >= 0 or cross(d,e) * cross(d,f) >= 0:return False\n    else:return True\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x0,y0] ; b = [x1,y1] ; c = [x2,y2] ; d = [x3,y3]\n    l1 = Line(a,b) ; l2 = Line(c,d)\n    if InterSection(l1,l2):print(1)\n    else:print(0)"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    x0, y0, x1, y1, x2, y2, x3, y3 = map(int, raw_input().split())\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    t = (y2-y0)*dx0 - (x2-x0)*dy0\n    tm = dx1*dy0 - dy1*dx0\n    if t < 0:\n        t = -t\n        tm = -tm\n    ov = dx0*dy1 - dy0*dx1\n    if 0 <= s <= max(sm, 0) and 0 <= t <= max(tm, 0):\n        if ov == 0:\n            r0 = dx0**2 + dy0**2\n            r1 = (x2-x0)*dx0 + (y2-y0)*dy0\n            r2 = (x3-x0)*dx0 + (y3-y0)*dy0\n            if r2 < 0 or r0 < r1:\n                print 0\n            else:\n                print 1\n        else:\n            print 1\n    else:\n        print 0"
  },
  {
    "language": "Python",
    "code": "def dot(a,b):return a[0]*b[0] + a[1]*b[1]\ndef cross(a,b):return a[0]*b[1] - a[1]*b[0]\ndef isOn(a,b):\n    if cross(a,b) == 0:\n        if dot(a,b) < 0 or dot(a,a) < dot(b,b) : return False\n        else : return True\n    else : \n        return False\n\nq = int(input())\nfor i in range(q):\n    x0,y0,x1,y1,x2,y2,x3,y3 = [int(i) for i in input().split()]\n    a = [x1-x0,y1-y0]\n    b = [x2-x0,y2-y0]\n    c = [x3-x0,y3-y0]\n    d = [x3-x2,y3-y2]\n    e = [x0-x2,y0-y2]\n    f = [x1-x2,y1-y2]\n    if isOn(a,b) or isOn(a,c):\n        print(1)\n    elif cross(a,b) == 0 and cross(a,c) == 0:\n        print(0)\n    elif cross(a,b) * cross(a,c) > 0 :\n        print(0)\n    elif cross(d,e) * cross(d,f) > 0 :\n        print(0)\n    else :\n        print(1,isOn(a,b),isOn(a,c))"
  },
  {
    "language": "Python",
    "code": "def cross(a,b):return a[0]*b[1] - a[1]*b[0]\n\nq = range(int(input()))\nfor i in q:\n    a,b,c,d,e,f,g,h = [int(x) for x in input().split()]\n    A = [c-a,d-b]; B = [e-a,f-b]; C = [g-a,h-a];\n    D = [g-e,h-f]; E = [a-e,b-f]; F = [c-e,d-f];\n    T = max(a,c) < min(e,g)\n    if max(a,c) < min(e,g) or max(e,g) < min(a,c) or max(b,d) < min(f,h) or max(f,h) < min(b,d):\n        print(\"0\")\n    elif cross(A,B) * cross(A,C) <= 0 and cross(D,E) * cross(D,F) <= 0:\n        print(\"1\")\n    else:\n        print(\"0\")"
  },
  {
    "language": "Python",
    "code": "import math\n\nEPS = 1e-10\n\nCOUNTER_CLOCKWISE = 1\nCLOCKWISE = -1\nONLINE_BACK = 2\nONLINE_FRONT = -2\nON_SEGMENT = 0\n\nclass Segment():\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, point):\n        # + 演算子での挙動を指定\n        return Point(self.x+point.x, self.y+point.y)\n\n    def __sub__(self, point):\n        # - 演算子での挙動を指定\n        return Point(self.x-point.x, self.y-point.y)\n\n    def __mul__(self, a):\n        # * 演算子での挙動を指定\n        return Point(a*self.x, a*self.y)\n\n    def __truediv__(self, a):\n        # / 演算子での挙動を指定\n        return Point(self.x/a, self.y/a)\n\n    def __abs__(self):\n        # abs関数での挙動を指定\n        return math.sqrt(self.norm())\n\n    def norm(self):\n        return self.x**2+self.y**2\n\n    def __eq__(self, point):\n        # == 演算子での挙動を指定\n        return abs(self.x-point.x) < EPS and abs(self.y-point.y) <EPS\n\ndef dot(a, b):\n    return a.x*b.x+a.y*b.y\n\ndef cross(a, b):\n    return a.x*b.y - a.y*b.x\n\ndef isOrthogonal(a, b):\n    return dot(a, b) == 0\n\ndef isParallel(a, b):\n    return cross(a, b) == 0\n\ndef project(s, p):\n    #s: Segment(), p: Point()\n    base = s.p2 - s.p1\n    r = dot(p-s.p1, base)/base.norm()\n    return s.p1+base*r\n\ndef reflect(s, p):\n    return p+(project(s, p)-p)*2\n\ndef get_distance(a, b):\n    return abs(a-b)\n\ndef get_distance_lp(l, p):\n    return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1))\n\ndef get_distance_sp(s, p):\n    if dot(s.p2-s.p1, p-s.p1) < 0:\n        return abs(p-s.p1)\n    if dot(s.p1-s.p2, p-s.p2) < 0:\n        return abs(p-s.p2)\n    return get_distance_lp(s, p)\n\ndef intersect(s1, s2):\n    return True\n    \ndef get_distance(s1, s2):\n    if intersect(s1, s2):\n        return 0\n    return min([get_distance_sp(s1, s2.p1), get_distance_sp(s1, s2.p2),\n                get_distance_sp(s2, s1.p1), get_distance_sp(s2, s1.p2)])\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > EPS:\n        return COUNTER_CLOCKWISE\n    if cross(a, b) < -EPS:\n        return CLOCKWISE\n    if dot(a, b) < -EPS:\n        return ONLINE_BACK\n    if a.norm() < b.norm():\n        return ONLINE_FRONT\n    return ON_SEGMENT\n\nfrom functools import singledispatch\n@singledispatch\ndef intersect(p1, p2, p3, p4):\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0\n            and ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0)\n\n@intersect.register(Segment)\ndef _(s1, s2):\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2)\n\n\nif __name__ == '__main__':\n    from sys import stdin\n    input = stdin.readline\n\n    \n\n    q = int(input())\n    for _ in range(q):\n        x0, y0, x1, y1, x2, y2, x3, y3 = map(int, input().split())\n        p0 = Point(x0, y0)\n        p1 = Point(x1, y1)\n        p2 = Point(x2, y2)\n        p3 = Point(x3, y3)\n        s1 = Segment(p0, p1)\n        s2 = Segment(p2, p3)\n        if intersect(s1, s2):\n            print(1)\n        else:\n            print(0)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \nimport itertools\ndef is_the_same_points_included(OA, OC, OB, OD):\n    args = [OA, OC, OB, OD]\n    for first,second in itertools.combinations(args,2):\n        if (first.x, first.y) == (second.x, second.y):\n            return True\n    else:\n        return False\n\ndef is_Crossed(OA, OC, OB, OD):\n    \"\"\"\n    AOJ: CGL_2B \n    segment AC and segment BD\n    ref. http://www.fumiononaka.com/Business/html5/FN1312004.html\n    \"\"\"\n    AC = Point(OC.x - OA.x, OC.y - OA.y)\n    BD = Point(OD.x - OB.x, OD.y - OB.y)\n    AB = Point(OB.x - OA.x, OB.y - OA.y)\n    BC = Point(OC.x - OB.x, OC.y - OB.y)\n    AD = Point(OD.x - OA.x, OD.y - OA.y)\n    BA = Point(-AB.x, -AB.y)\n\t\n    if crossProduct2D(AC, BD) == 0:\n        if is_the_same_points_included(OA, OC, OB, OD):\n            return 1\n        else:\n            return 0\n    if crossProduct2D(BD, BA) * crossProduct2D(BD, BC) > 0: \n        return 0\n    else:\n\t    if crossProduct2D(AC, AB) * crossProduct2D(AC, AD) > 0: \n\t        return 0\n\t    else: \n\t        return 1\n\t        \ndef crossProduct2D(Point0, Point1):\n    return Point0.x * Point1.y - Point0.y * Point1.x\n\nif __name__ == \"__main__\":\n    n = int(raw_input())\n    for i in range(n):\n        xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3 = map(int,raw_input().split())\n        P0 = Point(xp0, yp0)\n        P1 = Point(xp1, yp1)\n        P2 = Point(xp2, yp2)\n        P3 = Point(xp3, yp3)\n        print is_Crossed(P0, P1, P2, P3)"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]\npub struct Complex<T> {\n    pub re: T,\n    pub im: T,\n}\nimpl<T> Complex<T> {\n    #[inline]\n    pub fn new(re: T, im: T) -> Complex<T> {\n        Complex { re: re, im: im }\n    }\n}\nimpl<T: Neg<Output = T>> Complex<T> {\n    #[inline]\n    pub fn conjugate(self) -> Complex<T> {\n        Self::new(self.re, -self.im)\n    }\n}\nimpl<T: Add<Output = T> + Mul<Output = T>> Complex<T> {\n    #[inline]\n    pub fn dot(self, other: Self) -> T {\n        self.re * other.re + self.im * other.im\n    }\n}\nimpl<T: Sub<Output = T> + Mul<Output = T>> Complex<T> {\n    #[inline]\n    pub fn cross(self, other: Self) -> T {\n        self.re * other.im - self.im * other.re\n    }\n}\nimpl Complex<f64> {\n    #[inline]\n    pub fn from_polar(r: f64, theta: f64) -> Self {\n        Complex::new(r * theta.cos(), r * theta.sin())\n    }\n    #[inline]\n    pub fn abs(self) -> f64 {\n        self.re.hypot(self.im)\n    }\n    #[inline]\n    pub fn unit(self) -> Self {\n        self / self.abs()\n    }\n    #[inline]\n    pub fn angle(self) -> f64 {\n        self.im.atan2(self.re)\n    }\n}\nimpl<T: Add<Output = T>> Add for Complex<T> {\n    type Output = Self;\n    fn add(self, other: Self) -> Self::Output {\n        Self::new(self.re + other.re, self.im + other.im)\n    }\n}\nimpl<T: Copy + Add<Output = T>> Add<T> for Complex<T> {\n    type Output = Self;\n    fn add(self, other: T) -> Self::Output {\n        Self::new(self.re + other, self.im + other)\n    }\n}\nimpl<T: Sub<Output = T>> Sub for Complex<T> {\n    type Output = Self;\n    fn sub(self, other: Self) -> Self::Output {\n        Self::new(self.re - other.re, self.im - other.im)\n    }\n}\nimpl<T: Copy + Sub<Output = T>> Sub<T> for Complex<T> {\n    type Output = Self;\n    fn sub(self, other: T) -> Self::Output {\n        Self::new(self.re - other, self.im - other)\n    }\n}\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>> Mul for Complex<T> {\n    type Output = Self;\n    fn mul(self, other: Self) -> Self::Output {\n        Self::new(\n            self.re * other.re - self.im * other.im,\n            self.re * other.im + self.im * other.re,\n        )\n    }\n}\nimpl<T: Copy + Mul<Output = T>> Mul<T> for Complex<T> {\n    type Output = Self;\n    fn mul(self, other: T) -> Self::Output {\n        Self::new(self.re * other, self.im * other)\n    }\n}\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>> Div\n    for Complex<T>\n{\n    type Output = Self;\n    fn div(self, other: Self) -> Self::Output {\n        let d = other.re * other.re + other.im * other.im;\n        Self::new(\n            (self.re * other.re + self.im * other.im) / d,\n            (self.im * other.re - self.re * other.im) / d,\n        )\n    }\n}\nimpl<T: Copy + Div<Output = T>> Div<T> for Complex<T> {\n    type Output = Self;\n    fn div(self, other: T) -> Self::Output {\n        Self::new(self.re / other, self.im / other)\n    }\n}\nimpl<T: Neg<Output = T>> Neg for Complex<T> {\n    type Output = Self;\n    fn neg(self) -> Self::Output {\n        Self::new(-self.re, -self.im)\n    }\n}\npub type Point = Complex<f64>;\n#[derive(Clone, Debug, PartialEq)]\npub struct LineSegment {\n    p1: Point,\n    p2: Point,\n}\nimpl LineSegment {\n    pub fn new(p1: Point, p2: Point) -> Self {\n        LineSegment { p1: p1, p2: p2 }\n    }\n    pub fn dir(&self) -> Point {\n        self.p2 - self.p1\n    }\n    pub fn intersect(&self, other: &Self) -> bool {\n        ccw(self.p1, self.p2, other.p1) as i8 * ccw(self.p1, self.p2, other.p2) as i8 <= 0\n            && ccw(other.p1, other.p2, self.p1) as i8 * ccw(other.p1, other.p2, self.p2) as i8 <= 0\n    }\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub enum CCW {\n    #[doc = \" a--b--c\"]\n    OnlineFront = -2,\n    #[doc = \" a--b-vc\"]\n    Clockwise = -1,\n    #[doc = \" a--c--b\"]\n    OnSegment = 0,\n    #[doc = \" a--b-^c\"]\n    CounterClockwise = 1,\n    #[doc = \" c--a--b\"]\n    OnlineBack = 2,\n}\npub fn ccw(a: Point, b: Point, c: Point) -> CCW {\n    let x = b - a;\n    let y = c - a;\n    if x.cross(y) > 0. {\n        CCW::CounterClockwise\n    } else if x.cross(y) < 0. {\n        CCW::Clockwise\n    } else if x.dot(y) < 0. {\n        CCW::OnlineBack\n    } else if x.abs() < y.abs() {\n        CCW::OnlineFront\n    } else {\n        CCW::OnSegment\n    }\n}\nfn main() {\n    input! { q, qs: [[(f64, f64); 4]; q] };\n    for ps in &qs {\n        let l1 = LineSegment::new(Point::new(ps[0].0, ps[0].1), Point::new(ps[1].0, ps[1].1));\n        let l2 = LineSegment::new(Point::new(ps[2].0, ps[2].1), Point::new(ps[3].0, ps[3].1));\n        let x = if l1.intersect(&l2) { 1 } else { 0 };\n        println!(\"{}\", x);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::f64::consts::PI;\n\nconst EPS: f64 = 1e-8;\n\nfn main() {\n    let mut sc = Scanner::new();\n\n    let q = sc.next::<usize>();\n    for _ in 0..q {\n        let p0 = sc.next::<Pt>();\n        let p1 = sc.next::<Pt>();\n        let p2 = sc.next::<Pt>();\n        let p3 = sc.next::<Pt>();\n\n        let ans = if intersect_line_segment(&LineSegment(p0, p1), &LineSegment(p2, p3)) {\n            1\n        } else {\n            0\n        };\n\n        println!(\"{}\", ans);\n    }\n}\n\npub fn cross(a: Pt, b: Pt) -> f64 {\n    (a.conj() * b).im\n}\n\npub fn dot(a: Pt, b: Pt) -> f64 {\n    (a.conj() * b).re\n}\n\npub enum CCW {\n    /// a->b->c is counter clockwise\n    CounterClockwise = 1,\n    /// a->b->c is counter clockwise\n    Clockwise = -1,\n    /// c--a--b\n    OnLineBack = 2,\n    /// a--b--c\n    OnLineFront = -2,\n    /// a--c--b\n    OnSegment = 0,\n}\n\npub fn ccw(a: Pt, b: Pt, c: Pt) -> CCW {\n    let b = b - a;\n    let c = c - a;\n    if cross(b, c) > 0.0 {\n        CCW::CounterClockwise\n    } else if cross(b, c) < 0.0 {\n        CCW::Clockwise\n    } else if dot(b, c) < 0.0 {\n        CCW::OnLineBack\n    } else if b.norm() < c.norm() {\n        CCW::OnLineFront\n    } else {\n        CCW::OnSegment\n    }\n}\n\n/// Signed area of triangle\npub fn triangle_signed_area(a: Pt, b: Pt, c: Pt) -> f64 {\n    cross(b - a, c - a) / 2.0\n}\n\nstruct Line(Pt, Pt);\nstruct LineSegment(Pt, Pt);\n\nenum CrossLine {\n    Parallel,\n    Cross(Pt),\n}\n\nenum CrossLineSegment {\n    None,\n    Many,\n    One(Pt),\n}\n\nfn intersect_line(a: &Line, b: &Line) -> bool {\n    cross(a.1 - a.0, b.1 - b.0) > EPS || cross(a.1 - a.0, b.0 - b.1) < EPS\n}\n\nfn intersect_line_segment(a: &LineSegment, b: &LineSegment) -> bool {\n    ccw(a.0, a.1, b.0) as i32 * ccw(a.0, a.1, b.1) as i32 <= 0\n        && ccw(b.0, b.1, a.0) as i32 * ccw(b.0, b.1, a.1) as i32 <= 0\n}\n\n// fn cross_line_segment(a: &LineSegment, b: &LineSegment) -> CrossLineSegment {\n//     use CrossLineSegment::*;\n\n//     // normalize a to [(0, 0), (0, 1)]\n//     let b0 = b.0 - a.0;\n//     let b1 = b.1 - a.0;\n//     let va = a.1 - a.0;\n\n//     let b0 = b0 / va;\n//     let b1 = b1 / va;\n\n//     if b0.im * b1.im > 0.0 {\n//         return None;\n//     }\n//     if b0.re < 0.0 && b1.re < 0.0 || b0.re > 1.0 && b0.re > 1.0 {\n//         return None;\n//     }\n\n//     if b0.re * none\n\n//     todo!()\n// }\n\n//==========\n\nuse std::fmt::Debug;\nuse std::ops::{Add, Div, Mul, Sub};\n\n#[derive(PartialEq, Eq, Copy, Clone, Hash, Debug, Default)]\n#[repr(C)]\npub struct Complex<T> {\n    /// Real portion of the complex number\n    pub re: T,\n    /// Imaginary portion of the complex number\n    pub im: T,\n}\n\nimpl<T> Complex<T> {\n    #[inline]\n    pub fn new(re: T, im: T) -> Self {\n        Complex { re, im }\n    }\n}\n\nimpl Complex<f64> {\n    #[inline]\n    pub fn conj(&self) -> Self {\n        Self::new(self.re.clone(), -self.im.clone())\n    }\n\n    #[inline]\n    pub fn norm(&self) -> f64 {\n        self.re.hypot(self.im)\n    }\n\n    #[inline]\n    pub fn arg(&self) -> f64 {\n        self.im.atan2(self.re)\n    }\n\n    #[inline]\n    pub fn abs(&self) -> f64 {\n        self.im.atan2(self.re)\n    }\n}\n\nimpl<T: Add<Output = T>> Add for Complex<T> {\n    type Output = Self;\n    fn add(self, rhs: Self) -> Self::Output {\n        Self::new(self.re + rhs.re, self.im + rhs.im)\n    }\n}\n\nimpl<T: Sub<Output = T>> Sub for Complex<T> {\n    type Output = Self;\n    fn sub(self, rhs: Self) -> Self::Output {\n        Self::new(self.re - rhs.re, self.im - rhs.im)\n    }\n}\n\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>> Mul for Complex<T> {\n    type Output = Self;\n    fn mul(self, rhs: Self) -> Self::Output {\n        Self::new(\n            self.re * rhs.re - self.im * rhs.im,\n            self.re * rhs.im + self.im * rhs.re,\n        )\n    }\n}\n\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>> Div\n    for Complex<T>\n{\n    type Output = Self;\n    fn div(self, rhs: Self) -> Self::Output {\n        let d = rhs.re * rhs.re + rhs.im * rhs.im;\n        Self::new(\n            (self.re * rhs.re + self.im * rhs.im) / d,\n            (self.im * rhs.re - self.re * rhs.im) / d,\n        )\n    }\n}\n\ntype Pt = Complex<f64>;\n\n//==========\n\npub struct Scanner {\n    buf: Vec<char>,\n    cur: usize,\n}\n\nimpl Scanner {\n    pub fn new() -> Scanner {\n        Scanner {\n            buf: vec![],\n            cur: 0,\n        }\n    }\n\n    fn fill(&mut self) {\n        let mut s = String::new();\n        let len = std::io::stdin().read_line(&mut s).unwrap();\n        if len == 0 {\n            panic!(\"unexpected EOF\");\n        }\n        for c in s.chars() {\n            self.buf.push(c);\n        }\n    }\n\n    pub fn next_char(&mut self) -> char {\n        'outer: loop {\n            if self.cur >= self.buf.len() {\n                self.fill();\n            }\n            while self.cur < self.buf.len() {\n                if !self.buf[self.cur].is_whitespace() {\n                    break 'outer;\n                }\n                self.cur += 1;\n            }\n        }\n        let ret = self.buf[self.cur];\n        self.cur += 1;\n        ret\n    }\n\n    pub fn next_word(&mut self) -> String {\n        'outer: loop {\n            if self.cur >= self.buf.len() {\n                self.fill();\n            }\n            while self.cur < self.buf.len() {\n                if !self.buf[self.cur].is_whitespace() {\n                    break 'outer;\n                }\n                self.cur += 1;\n            }\n        }\n\n        let mut s = String::new();\n        while self.cur < self.buf.len() && !self.buf[self.cur].is_whitespace() {\n            s.push(self.buf[self.cur]);\n            self.cur += 1;\n        }\n        s\n    }\n\n    pub fn next<T: Reader>(&mut self) -> T {\n        T::read(self)\n    }\n\n    pub fn next_vec_len<T: Reader>(&mut self) -> Vec<T> {\n        let n: usize = self.next();\n        self.next_vec(n)\n    }\n\n    pub fn next_vec<T: Reader>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.next()).collect()\n    }\n}\n\npub trait Reader {\n    fn read(sc: &mut Scanner) -> Self;\n}\n\nimpl<T: Reader> Reader for Complex<T> {\n    fn read(sc: &mut Scanner) -> Self {\n        Self::new(sc.next(), sc.next())\n    }\n}\n\nimpl Reader for char {\n    fn read(sc: &mut Scanner) -> Self {\n        sc.next_char()\n    }\n}\n\nmacro_rules! impl_for_from_str {\n    ($typ:ty) => {\n        impl Reader for $typ {\n            fn read(sc: &mut Scanner) -> Self {\n                sc.next_word().parse().unwrap()\n            }\n        }\n    };\n}\n\nimpl_for_from_str!(i8);\nimpl_for_from_str!(u8);\nimpl_for_from_str!(i16);\nimpl_for_from_str!(u16);\nimpl_for_from_str!(i32);\nimpl_for_from_str!(u32);\nimpl_for_from_str!(i64);\nimpl_for_from_str!(u64);\n// impl_for_from_str!(i128);\n// impl_for_from_str!(u128);\nimpl_for_from_str!(isize);\nimpl_for_from_str!(usize);\nimpl_for_from_str!(f32);\nimpl_for_from_str!(f64);\nimpl_for_from_str!(String);\n\n"
  }
]