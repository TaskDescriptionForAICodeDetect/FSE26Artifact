[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint W,H;\nint tiles[31][61] = {};\nint tleft[31][61] = {};\nint tright[31][61] = {};\nstruct Position {\n    int x,y;\n    bool foot; // true:left false:right\n};\nstruct CompareByFirst {\n    bool operator()(pair<int, Position> const & a,\n                              pair<int, Position> const & b) const\n    { return a.first > b.first; }\n};\n\nint main() {\nSTART:\n    while (cin>>W>>H && W != 0 && H != 0) {\n        priority_queue<pair<int, Position>, vector<pair<int, Position> >, CompareByFirst> pqueue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                tleft[w][h] = -1;\n                tright[w][h] = -1;\n                char tile = 0;\n                cin>>tile;\n                switch(tile) {\n                    case 'S':\n                    {\n                        tiles[w][h] = 0;\n                        Position pos = {w,h,true};\n                        pqueue.push(make_pair(0, pos));\n                        pos.foot = false;\n                        pqueue.push(make_pair(0, pos));\n                        break;\n                    }\n\n                    case 'T':\n                    {\n                        tiles[w][h] = -2;\n                        break;\n                    }\n\n                    case 'X':\n                        tiles[w][h] = -1;\n                        break;\n\n                    default:\n                        tiles[w][h] = atoi(&tile);\n                }\n            }\n        }\n\n        while (!pqueue.empty()) {\n            pair<int, Position> p = pqueue.top();\n            pqueue.pop();\n            if (p.second.foot == true) {\n                if (tleft[p.second.x][p.second.y] == -1) tleft[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = 1; w <= 3 - abs(h); w++) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                cout<<p.first<<endl;\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, false};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (tright[p.second.x][p.second.y] == -1) tright[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = -1; w >= abs(h) - 3; w--) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                cout<<p.first<<endl;\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, true};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        cout<<-1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\n#define INF 500000\n#define P  pair <int , pair < int, pair <int , int > > >\n#define dis first\n#define x second.first\n#define y second.second.first\n#define sta second.second.second\nusing namespace std;\nstring str[60];\nint w,h,cnt;\npriority_queue < P > Q;\nint d[61][31][2];\n\nvoid dijkstra(int sx,int sy,int rl) {\n  bool visited[61][31][2] = {};\n  while(!Q.empty()) Q.pop();\n  P ttt;\n  ttt.dis=0,   ttt.x = sx,   ttt.y=sy, ttt.sta = rl;\n  d[sy][sx][rl] = 0;\n  Q.push(ttt);\n\n  while(!Q.empty()) {\n    cnt++;\n    P t = Q.top();\n    Q.pop();\n\n    if(visited[t.y][t.x][t.sta] == 1) continue;\n    visited[t.y][t.x][t.sta] = 1;\n\n    for(int i=1;i<=3;i++) { //i = x\n      for(int j=-3+i;j<=3-i;j++) { // j = y\n\tint nx,ny = t.y + j;\n\tif(t.sta == 0) nx = t.x - i;\n\tif(t.sta == 1) nx = t.x + i;\n\tif(nx<0 || ny<0 || w<=nx || h<=ny) continue;\n\tif(str[ny][nx]=='X') continue;\n\tint cost = str[ny][nx] - '0';\n\tif(str[ny][nx] == 'T' || str[ny][nx] == 'S') cost = 0;\n\t\tif(d[ny][nx][(t.sta+1)%2] < d[t.y][t.x][t.sta]-cost){\n\t  d[ny][nx][(t.sta+1)%2] =  d[t.y][t.x][t.sta]-cost;\n\t  P tt;\n\t  tt.dis =  d[ny][nx][(t.sta+1)%2];\n\t  tt.x = nx , tt.y = ny , tt.sta = (t.sta+1)%2;\n\t  Q.push(tt);\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {  \n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    \n    for(int i=0;i<h;i++) {\n      str[h-i-1] = \"\";\n      for(int j=0;j<w;j++) {\n\tstring a;\n\tcin >>a;\n\tstr[h-i-1] += a;\n      }\n    }\n\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<2;k++) d[i][j][k] = -INF;\n\n    for(int i=0;i<w;i++) \n      if(str[0][i] == 'S') {\n\tdijkstra(i,0,0);\n\tdijkstra(i,0,1);\n      }\n    \n    int ans = -INF;    \n    for(int i=0;i<w;i++) {\n      if(str[h-1][i] == 'T') ans = max(ans,d[h-1][i][0]),ans = max(ans,d[h-1][i][1]);\n    }\n\n\n    if(ans == -INF) cout << -1 <<endl;\n    else cout << -ans <<endl;\n    // cout << cnt <<endl;\n  }\n    \n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nstruct state{\n    int x, y, dir, dist;\n    state(int x, int y, int dir, int dist): x(x), y(y), dir(dir), dist(dist){}\n};\n\nint w, h;\n\nvoid solve(){\n    int a[h][w];\n    rep(i, h)rep(j, w){\n        char c;\n        scanf(\" %c\", &c);\n        if(isdigit(c)) a[i][j] = c-'0';\n        else a[i][j] = (c == 'X' ? mod : 0);\n    }\n\n    auto cmp = [](const state &s1, const state &s2){\n        return s1.dist > s2.dist;\n    };\n    priority_queue<state, vector<state>, decltype(cmp)> que(cmp);\n    int d[h][w][2];\n    rep(i, h)rep(j, w)rep(k, 2) d[i][j][k] = mod;\n    rep(j, w)if(a[h-1][j] == 0){\n        rep(k, 2){\n            d[h-1][j][k] = 0;\n            que.emplace(h-1, j, k, 0);\n        }\n    }\n    while(!que.empty()){\n        auto s = que.top();\n        que.pop();\n        if(s.dist > d[s.x][s.y][s.dir]) continue;\n        for(int dx=-2; dx<=2; ++dx)for(int dy=1; dy+abs(dx)<=3; ++dy){\n            int nx = s.x + dx, ny = s.y + dy * (2*s.dir - 1), nd = s.dir^1;\n            if(0<=nx && nx<h && 0<=ny && ny<w && chmin(d[nx][ny][nd], s.dist + a[nx][ny])){\n                que.emplace(nx, ny, nd, d[nx][ny][nd]);\n            }\n        }\n    }\n    int ans = mod;\n    rep(j, w)if(a[0][j] == 0)rep(k, 2) chmin(ans, d[0][j][k]);\n    printf(\"%d\\n\", ans == mod ? -1 : ans);\n}\n\nint main(){\n    while(scanf(\"%d%d\", &w, &h) && w){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[61][31];\nint used[2][61][31][61][31]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c; // ???????????§???????????????????¨???¶\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false; // ??????????¨???????\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c; // ?????£????????¨?????????\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true; // ?£????\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true; // ?£????\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; //????£???????\n\t  if(board[s.r.sc][s.r.fs] < 0) return true; //??????????£?\n\t  if(board[s.l.sc][s.l.fs] < 0) return true; //??????????£?\n\t  return false; // ??§??????\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true; // ????¶??????´??????\n\t  if(g.find(s.r) != g.end()) return true; // ????¶??????´??????\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n//\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n//\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost = 0 ;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  if(is_used(ns)) continue;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tsort(s.begin(),s.end());\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  for(int j=i+1; j<s.size(); j++){\n\t\t\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\t\t\t  state st = state(s[i], s[j], (f+1)%2, 0);\n\t\t\t\t\t\t\t  if( valid(st) ) continue;\n\t\t\t\t\t\t\t  int tmp = dijk(st);\n\t\t\t\t\t\t\t  if(tmp != -1)\n\t\t\t\t\t\t\t\t\tans = min(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n#define F          first\n#define S          second\n#define PB         push_back\n#define INF        ( 1 << 20 )\n\nusing namespace std;\n\nstruct state\n{\n\tint x[2], y[2]; // left, right\n\tint lr; // どっちの足を着いているか\n\tint cost;\n\n\tbool operator< (const state &s) const { return cost > s.cost; }\n};\n\n// 右足を動かせる範囲（左足の場合はx符号反転）\nint ad[9][2] =\n{\n\t{ 1, 2 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 1, -2 },\n\t{ 2, 1 }, { 2, 0 }, { 2, -1 },\n\t{ 3, 0 },\n};\n\nint sign[2] = { -1, 1 };\n\nint W,H;\nvector< pair<int, int> > ss;\nvector< pair<int, int> > ts;\nint costs[61][31];\nbool det[2][61][31];\n\nbool ok(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint main()\n{\n\twhile(cin>>W>>H,W|H)\n\t{\n\t\tss.clear();\n\t\tts.clear();\n\n\t\trep(y,H)rep(x,W)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'S':\n\t\t\t\tcosts[y][x] = 0;\n\t\t\t\tss.PB(make_pair(x, y));\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tcosts[y][x] = 0;\n\t\t\t\tts.PB(make_pair(x, y));\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tcosts[y][x] = INF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcosts[y][x] = c - '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdet[0][y][x] = det[1][y][x] = false;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\trep(i,ss.size())\n\t\t{\n\t\t\tpair<int, int> pt = ss[i];\n\t\t\tstate init;\n\t\t\tinit.cost = 0;\n\t\t\trep(d,2)\n\t\t\t{\n\t\t\t\tinit.x[d] = pt.F;\n\t\t\t\tinit.y[d] = pt.S;\n\t\t\t\tinit.lr = d;\n\t\t\t\tQ.push(init);\n\t\t\t}\n\t\t}\n\n\t\tint mincost = INF;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tstate s = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tint x0 = s.x[s.lr], y0 = s.y[s.lr];\n\t\t\tif (det[s.lr][y0][x0]) continue;\n\t\t\tdet[s.lr][y0][x0] = true;\n\n\t\t\trep(i,ts.size())\n\t\t\t{\n\t\t\t\tpair<int, int> p = ts[i];\n\t\t\t\tif (x0 == p.F && y0 == p.S)\n\t\t\t\t{\n\t\t\t\t\tmincost = min(mincost, s.cost);\n\t\t\t\t\t//break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(i,9)\n\t\t\t{\n\t\t\t\tint lr = 1 - s.lr; // 動かす足\n\t\t\t\tint x1 = x0 + sign[lr] * ad[i][0], y1 = y0 + ad[i][1];\n\t\t\t\tif (ok(x1, y1) && !det[lr][y1][x1])\n\t\t\t\t{\n\t\t\t\t\tstate s1;\n\t\t\t\t\ts1.cost = s.cost + costs[y1][x1];\n\t\t\t\t\ts1.x[lr] = x1;\n\t\t\t\t\ts1.y[lr] = y1;\n\t\t\t\t\ts1.lr = lr;\n\t\t\t\t\tQ.push(s1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (mincost == INF ? -1 : mincost) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <numeric>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <tuple>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long  ll;\n\nconst int INF = 1e9;\n\nstruct Node {\n    int x, y, d, foot;\n    Node() {}\n    Node(int x, int y, int d, int foot) : x(x), y(y), d(d), foot(foot) {}\n};\nbool operator<(const Node &a, const Node &b) {\n    return a.d > b.d;\n}\n\nconst int dx[][9] = {{1, 2, 3, 1, 2, 1, 1, 2, 1},\n                     {-1, -2, -3, -1, -2, -1, -1, -2, -1}};\nconst int dy[][9] = {{0, 0, 0, -1, -1, -2, 1, 1, 2},\n                     {0, 0, 0, -1, -1, -2, 1, 1, 2}};\n\nint main()\n{\n    int w, h;\n\n    while (cin >> w >> h, w || h) {\n        vector<vector<char>> block(h, vector<char>(w));\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                cin >> block[i][j];\n\n        // d[i][j][k] := (i, j)にk(0: 左, 1: 右)足を置いた時の最短距離\n        vector<vector<vector<int>>> d(h, vector<vector<int>>(w, vector<int>(2, INF)));\n        priority_queue<Node> que;\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                if (block[i][j] == 'S') {\n                    d[i][j][0] = d[i][j][1] = 0;\n                    que.push(Node(j, i, 0, 0));\n                    que.push(Node(j, i, 0, 1));\n                }\n\n        while (!que.empty()) {\n            Node now = que.top();  que.pop();\n\n            for (int j = 0; j < 9; ++j) {\n                int nx = now.x + dx[now.foot][j];\n                int ny = now.y + dy[now.foot][j];\n\n                if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n                    continue;\n                if (block[ny][nx] == 'X')\n                    continue;\n\n                int cost = 0;\n                if (block[ny][nx] == 'S' || block[ny][nx] == 'T')\n                    cost = 0;\n                else if (isdigit(block[ny][nx]))\n                    cost = (int)(block[ny][nx] - '0');\n\n                if (d[ny][nx][(now.foot + 1) % 2] > d[now.y][now.x][now.foot] + cost) {\n                    d[ny][nx][(now.foot + 1) % 2] = d[now.y][now.x][now.foot] + cost;\n                    que.push(Node(nx, ny, d[ny][nx][(now.foot + 1) % 2], (now.foot + 1) % 2));\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                if (block[i][j] == 'T')\n                    res = min(res, min(d[i][j][0], d[i][j][1]));\n\n        if (res == INF)\n            res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint w, h;\ninline void update(st p, priority_queue<st>&que) {\n\tfor (int k = -2; k <= 2; k++) {\n\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\tif (p.b) {\n\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tupdate({ i,j,0,0,0,1 }, que); update({ 0,0,i,j,0,0 }, que);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tupdate(p, que);\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\n#define Y real()\n#define X imag()\n#define INF (1000000)\n#define SLIP (-1)\n\nenum foot {\n\tLEFT,\n\tRIGHT\n};\n\nclass Node {\n\tpublic:\n\t\tP position;\n\t\tfoot current_foot;\n\n\t\tNode(P p, foot cf): position(p), current_foot(cf) {\n\t\t}\n\n\t\t// for std::map\n\t\tbool operator < (const Node& other) const {\n\t\t\tif (current_foot != other.current_foot) {\n\t\t\t\treturn current_foot < other.current_foot;\n\t\t\t} else {\n\t\t\t\tif (position.Y != other.position.Y) {\n\t\t\t\t\treturn position.Y < other.position.Y;\n\t\t\t\t} else {\n\t\t\t\t\treturn position.X < other.position.X;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nbool in_field(P p, int height, int width)\n{\n\treturn (0 <= p.Y && p.Y < height) && (0 <= p.X && p.X < width);\n}\n\ntypedef pair<int, Node> QTYPE;\n// for priority_queue\nclass Comp {\n\tpublic:\n\t\tbool operator() (const QTYPE& l, const QTYPE& r) const {\n\t\t\treturn (l.F > r.F);\n\t\t}\n};\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tVVI cliff(h, VI(w, 0));\n\t\tvector<P> starts, goals;\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcliff[i][j] = 0;\n\t\t\t\t\t\tstarts.PB(P(i, j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tcliff[i][j] = 0;\n\t\t\t\t\t\tgoals.PB(P(i, j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\tcliff[i][j] = SLIP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcliff[i][j] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<Node, int> costs;\n\n\t\tint ans = -1;\n\t\tPQ< QTYPE, vector<QTYPE>, Comp > q;\n\t\tEACH (starts, itr) {\n\t\t\tq.push(MP(0, Node(*itr, LEFT)));\n\t\t\tq.push(MP(0, Node(*itr, RIGHT)));\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tQTYPE t = q.top(); q.pop();\n\t\t\tint cost = t.F;\n\t\t\tNode n = t.S;\n\t\t\tif (EXIST(costs, n)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcosts[n] = cost;\n#define FOUND(vec, item) (find(ALL(vec), (item)) != (vec).end())\n\t\t\tif (FOUND(goals, n.position)) {\n\t\t\t\tans = cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP next_foot_base;\n\t\t\tif (n.current_foot == LEFT) {\n\t\t\t\tnext_foot_base = n.position + P(-2, 1);\n\t\t\t} else {\n\t\t\t\tnext_foot_base = n.position + P(-2, -3);\n\t\t\t}\n\t\t\tREP (i, 5) {\n\t\t\t\tREP (j, 3) {\n\t\t\t\t\tP nf = next_foot_base + P(i, j);\n\t\t\t\t\tIFC(!in_field(nf, h, w));\n\t\t\t\t\tIFC(abs(nf.Y - n.position.Y) + abs(nf.X - n.position.X) > 3);\n\t\t\t\t\tIFC(cliff[nf.Y][nf.X] == SLIP);\n\t\t\t\t\tq.push(MP(cost + cliff[nf.Y][nf.X], Node(nf, (foot)!n.current_foot)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<(int)N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\nint dp[61][31][2];\nint ccdx[9]={1,1,1,1,1,2,2,2,3};\nint ccdy[9]={2,1,0,-1,-2,1,0,-1,0};\nstruct st{\n\tint cost,nx,ny,nlr;\n\tst(int _cost,int _nlr,int _nx,int _ny){\n\t\tcost = _cost;\n\t\tnlr = _nlr;\n\t\tnx = _nx;\n\t\tny = _ny;\n\t}\n};\nbool operator<(st a, st b) {\n    return a.cost > b.cost;\n}\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tREP(i,0,61) REP(j,0,31) REP(k,0,2) dp[i][j][k]=inf;\n\t\tchar field[61][31];\n\t\tpriority_queue<st> pq;//L or R ,(x,y)\n\t\tREP(i,0,h) REP(j,0,w) {\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S') {\n\t\t\t\tpq.push(st(0,0,j,i));\n\t\t\t\tpq.push(st(0,1,j,i));\n\t\t\t\tdp[i][j][0]=dp[i][j][1]=0;\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\twhile(!pq.empty()){\n\t\t\tst now=pq.top();pq.pop();\n\t\t\tREP(i,0,9){\n\t\t\t\tst next=st(0,0,0,0);\n\t\t\t\tif(now.nlr%2)\tnext=st(now.cost,1-now.nlr,now.nx+ccdx[i],now.ny+ccdy[i]);\n\t\t\t\telse\tnext=st(now.cost,1-now.nlr,now.nx-ccdx[i],now.ny+ccdy[i]);\n\t\t\t\tif(!ck(next.nx,0,w)||!ck(next.ny,0,h)) continue;\n\t\t\t\tif(isdigit(field[next.ny][next.nx])){\n\t\t\t\t\tif(dp[next.ny][next.nx][next.nlr]>now.cost+(field[next.ny][next.nx]-'0')){\n\t\t\t\t\t\tdp[next.ny][next.nx][next.nlr]=now.cost+(field[next.ny][next.nx]-'0');\n\t\t\t\t\t\tpq.push(st(dp[next.ny][next.nx][next.nlr],next.nlr,next.nx,next.ny));\n\t\t\t\t\t}\n\t\t\t\t}else if(field[next.ny][next.nx]=='T'){\n\t\t\t\t\tans=min(ans,now.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(ans==inf?-1:ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint tesu[31][61][2];\nchar cliff[31][61];\nint w, h;\n\nint dy[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nint dx[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nvoid solve(int isnowleft, int x, int y, int nowtesu)\n{\n    if(nowtesu >= tesu[x][y][isnowleft]) return;\n    tesu[x][y][isnowleft] = nowtesu;\n    for(int i = 0; i < 9; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[isnowleft][i];\n        if(nx < 0 || ny < 0 || nx >= h || ny >= w || cliff[nx][ny] == 'X') continue;\n        if(cliff[nx][ny] == 'T') tesu[nx][ny][!isnowleft] = min(tesu[nx][ny][!isnowleft], nowtesu);\n        else if(cliff[nx][ny] == 'S') solve(!isnowleft, nx, ny, nowtesu);\n        else solve(!isnowleft, nx, ny, nowtesu + cliff[nx][ny] - '0');\n    }\n    return;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        vector<int> sx, sy, tx, ty;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> cliff[i][j];\n                if(cliff[i][j] == 'S'){\n                    sx.push_back(i);\n                    sy.push_back(j);\n                } else if(cliff[i][j] == 'T'){\n                    tx.push_back(i);\n                    ty.push_back(j);\n                }\n            }\n        }\n        memset(tesu, 1000000, sizeof(tesu));\n        int ans = 1000000;\n        for(int i = 0; i < 2; i++){\n            for(int j = 0; j < sx.size(); j++){\n                solve(i, sx[j], sy[j], 0);\n            }\n        }\n        // for(int k = 0; k < 2; k++){\n        //     for(int i = 0; i < h; i++){\n        //             for(int j = 0; j < w; j++){\n        //                 cout << tesu[i][j][k] << \" \";\n        //             }\n        //             cout << endl;\n        //         }\n        //         cout << endl;\n        //     }\n        for(int i = 0; i < tx.size(); i++){\n            for(int j = 0; j < 2; j++){\n                ans = min(ans, tesu[tx[i]][ty[i]][j]);\n            }\n        }\n        if(ans == 1000000) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 100000000\n#include<algorithm>\n#include<queue>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct pla{\n\tint lx,ly,rx,ry,nowc;\n\tpla(){}\n\tpla(int lx,int ly,int rx,int ry,int nowc):\n\tlx(lx),ly(ly),rx(rx),ry(ry),nowc(nowc){}\n\tbool operator<(const pla &x)const{\n\t\treturn nowc>x.nowc;\n\t}\n};\nint main(){\n\tint w,h,dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\n\twhile(cin>>w>>h,w||h){\n\t\tchar s[70][40];\n\t\trep(i,h)\n\t\trep(j,w){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\tpriority_queue<pla> que;\n\t\tint d[20][20][20][20];\n\t\trep(i,h)\n\t\trep(j,w)\n\t\trep(k,h)\n\t\trep(l,w)\n\t\td[i][j][k][l]=INF;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\tfor(int j=i+1;j<w;j++){\n\t\t\t\t\tif(s[h-1][j]=='S'){\n\t\t\t\t\t\tque.push(pla(i,h-1,j,h-1,0));\n\t\t\t\t\t\td[h-1][i][h-1][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint llx,lly,rrx,rry,nrrc,nllc;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\trep(j,9){\n\t\t\t\t\trrx=i+dx[j];\n\t\t\t\t\trry=h-1+dy[j];\n\t\t\t\t\tif(rrx<0||rrx>w-1||rry>h-1||rry<0||s[rry][rrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnrrc=isdigit(s[rry][rrx])?s[rry][rrx]-'0':0;\n\t\t\t\t\tque.push(pla(i,h-1,rrx,rry,nrrc));\n\t\t\t\t\td[h-1][i][rry][rrx]=nrrc;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\trep(j,9){\n\t\t\t\t\tllx=i-dx[j];\n\t\t\t\t\tlly=h-1+dy[j];\n\t\t\t\t\tif(llx<0||llx>w-1||lly>h-1||lly<0||s[lly][llx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnllc=isdigit(s[lly][llx])?s[lly][llx]-'0':0;\n\t\t\t\t\tque.push(pla(llx,lly,i,h-1,nllc));\n\t\t\t\t\td[lly][llx][h-1][i]=nllc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\twhile(!que.empty()){\n\t\t\tpla now=que.top();\n\t\t\tque.pop();\n\t\t\t//cout<<now.nowc<<' '<<now.lx<<' '<<now.ly<<endl;\n\t\t\tif(d[now.ly][now.lx][now.ry][now.rx]<now.nowc){\n\t\t\t//\tcout<<\"77777\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[now.ly][now.lx]=='T'||s[now.ry][now.rx]=='T'){\n\t\t\t\tflag=false;\n\t\t\t\tcout<<now.nowc<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nrx,nry,nrc;\n\t\t\t\tnrx=now.lx+dx[i];\n\t\t\t\tnry=now.ly+dy[i];\n\t\t\t\tif((nrx==now.rx&&nry==now.ry)||nry<0||nry>h-1||nrx<0||nrx>w-1||s[nry][nrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\tnrc=isdigit(s[nry][nrx])?s[nry][nrx]-'0':0;\n\t\t\t//\tcout<<nrc<<endl;\n\t\t\t\tif(d[now.ly][now.lx][nry][nrx]>now.nowc+nrc){\n\t\t\t\t\tque.push(pla(now.lx,now.ly,nrx,nry,now.nowc+nrc));\n\t\t\t\t\td[now.ly][now.lx][nry][nrx]=now.nowc+nrc;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nlx,nly,nlc;\n\t\t\t\tnlx=now.rx-dx[i];\n\t\t\t\tnly=now.ry+dy[i];\n\t\t\t\tif((nlx==now.lx&&nly==now.ly)||nly<0||nly>h-1||nlx<0||nlx>w-1||s[nly][nlx]=='X')\n\t\t\t\tcontinue;\n\t\t\t\tnlc=isdigit(s[nly][nlx])?s[nly][nlx]-'0':0;\n\t\t\t\tif(d[nly][nlx][now.ry][now.rx]>now.nowc+nlc){\n\t\t\t\t\tque.push(pla(nlx,nly,now.rx,now.ry,now.nowc+nlc));\n\t\t\t\t\td[nly][nlx][now.ry][now.rx]=now.nowc+nlc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tif(flag)\n\t\tcout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\n#include <cstdlib>\n#define H 60\n#define W 30\n#define SC signed char\n#define INF INT_MAX\n#define GOAL 10\n#define LABEL_X -1\n#define DEBUG false\nusing namespace std;\n\nint cost[H][W];\nSC s[H][W];\n\nint mv[9][2] = { // E«ÌÚ®ÍÍ( isL=falseÌ )\n  {1,-2},{1,-1},{1,0},{1,1},{1,2},\n  {2,-1},{2,0},{2,1},\n  {3,0}\n};\n\nint w,h;\nstruct P{\n  SC lx,ly, rx,ry;\n  bool isL; // ¶«ð®©·µ½ Ætrue\n  int cost; // oßÔ\n};\n\nvoid pr(P p ){\n  cout << \"(\"<<(int)p.lx<<\",\"<<(int)p.ly<<\") (\"\n       <<(int)p.rx<<\",\"<<(int)p.ry<<\") \"\n       << \"cost=\" << p.cost;\n  if( p.isL ) cout << \" left\" << endl;\n  else        cout << \" right\"<< endl;\n}\nvoid prCost(){\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ){\n      cout.width(11);\n      cout << cost[i][j];\n    }\n    cout << endl;\n  }\n}\n\n\nint main(){\n  queue<P> qu;\n  P p, q;\n\n  while( cin>>w >> h && (h||w) ){\n    p.lx=SCHAR_MAX; p.ly=SCHAR_MAX;\n    p.isL=true; p.cost=0;\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tchar c;\n\tcin >> c;\n\tswitch( c ){\n\tcase 'S' : s[i][j] = 0;\n\t  if( p.lx>j ){\n\t    p.rx=p.lx; p.ry=p.ly;\n\t    p.lx=j;    p.ly=i;\n\t  }else{\n\t    p.rx=j;    p.ry=i;\n\t  }\n\t  break;\n\tcase 'T' : \n\t  s[i][j] = GOAL;\n\t  break;\n\tcase 'X' : s[i][j]=LABEL_X; break;\n\tdefault :  s[i][j] = c-'0'; break;\n\t}\n      }\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcost[i][j] = INT_MAX;\n    while( !qu.empty() ) qu.pop();\n\n    qu.push( p ); p.isL=!p.isL;\n    qu.push( p );\n\n    int ans=INT_MAX, x,y;\n    while( !qu.empty() ){\n      p=qu.front(); qu.pop();\n      //      pr( p );\n\n      if( p.lx==p.rx && p.ly==p.ry ) continue;\n\n      if( p.isL ){ x=p.lx; y=p.ly; }\n      else {       x=p.rx; y=p.ry; }\n\n      if( x<0 || x>=w ) continue;\n      if( y<0 || y>=h ) continue;\n\n      if( s[y][x]==LABEL_X ) continue; // 'X'\n      \n      // goal\n      if( s[p.ly][p.lx]==GOAL || s[p.ry][p.rx]==GOAL ){\n\tif( ans > p.cost ) ans = p.cost; continue;\n      }\n\n      p.cost += s[y][x];\n      if( p.isL ){ // ¶«ðs[y][x] Éu¢½Æ«ÌÅ¬RXg\n\tif( p.cost >= cost[y][x] ) continue;\n\tcost[y][x] = p.cost;\n      }\n\n      if( DEBUG ){\n\tpr( p );\n\tprCost();\n      }\n      q=p;\n      if( p.isL ){\n\tq.isL=false;\n\tfor( int i=0;i<9;i++ ){\n\t  q.rx = p.lx + mv[i][0];\n\t  q.ry = p.ly + mv[i][1];\n\t  qu.push( q );\n\t}\n      }else{\n\tq.isL=true;\n\tfor( int i=0;i<9;i++ ){\n\t  q.lx = p.rx - mv[i][0];\n\t  q.ly = p.ry + mv[i][1];\n\t  qu.push( q );\n\t}\n      }\n    }\n    if( ans==INT_MAX ) ans=-1;\n    cout << ans << endl;\n\n    //    break;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> W >> H;\n\tvector<int>ans;\n\twhile (H) {\n\t\tvector<vector<char>>field(H, vector<char>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint ret = MOD;\n\t\tvector<vector<vector<vector<vector<int>>>>>dp(H, vector<vector<vector<vector<int>>>>(W, vector<vector<vector<int>>>(H, vector<vector<int>>(W, vector<int>(2, MOD)))));\n\t\tqueue<pair<pair<pair<int, int>, pair<int, int>>, int>>Q;\n\t\tfor (int i = 0; i < W; i++) {\n\t\t\tfor (int j = i + 1; j < W; j++) {\n\t\t\t\tif (field[H - 1][i] == 'S'&&field[H - 1][j] == 'S'&&j-i<=3) {\n\t\t\t\t\tdp[H - 1][i][H - 1][j][0] = 0;\n\t\t\t\t\tdp[H - 1][i][H - 1][j][1] = 0;\n\t\t\t\t\tQ.push({ { { H - 1,i },{ H - 1,j } },0 });\n\t\t\t\t\tQ.push({ { { H - 1,i },{ H - 1,j } },1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint ly = Q.front().first.first.first;\n\t\t\tint lx = Q.front().first.first.second;\n\t\t\tint ry = Q.front().first.second.first;\n\t\t\tint rx = Q.front().first.second.second;\n\t\t\tint bf = Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif (!bf) {\n\t\t\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\t\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\t\t\t\tif (abs(i) + j > 3)continue;\n\t\t\t\t\t\tint nry = ly + i;\n\t\t\t\t\t\tint nrx = lx + j;\n\t\t\t\t\t\tif (nry < 0 || nrx < 0 || nry >= H || nrx >= W)continue;\n\t\t\t\t\t\tif (field[nry][nrx] == 'X')continue;\n\t\t\t\t\t\tif (field[nry][nrx] == 'T') {\n\t\t\t\t\t\t\tret = min(ret, dp[ly][lx][ry][rx][bf]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[nry][nrx] == 'S') {\n\t\t\t\t\t\t\tif (dp[ly][lx][nry][nrx][!bf] > dp[ly][lx][ry][rx][bf]) {\n\t\t\t\t\t\t\t\tdp[ly][lx][nry][nrx][!bf] = dp[ly][lx][ry][rx][bf];\n\t\t\t\t\t\t\t\tQ.push({ { { ly,lx },{ nry,nrx } },!bf });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[ly][lx][nry][nrx][!bf] > dp[ly][lx][ry][rx][bf] + field[nry][nrx] - '0') {\n\t\t\t\t\t\t\tdp[ly][lx][nry][nrx][!bf] = dp[ly][lx][ry][rx][bf] + field[nry][nrx] - '0';\n\t\t\t\t\t\t\tQ.push({ {{ly,lx},{nry,nrx}},!bf });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\t\t\tfor (int j = -1; j >= -3; j--) {\n\t\t\t\t\t\tif (abs(i) - j > 3)continue;\n\t\t\t\t\t\tint nly = ry + i;\n\t\t\t\t\t\tint nlx = rx + j;\n\t\t\t\t\t\tif (nly < 0 || nlx < 0 || nly >= H || nlx >= W)continue;\n\t\t\t\t\t\tif (field[nly][nlx] == 'X')continue;\n\t\t\t\t\t\tif (field[nly][nlx] == 'T') {\n\t\t\t\t\t\t\tret = min(ret, dp[ly][lx][ry][rx][bf]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[nly][nlx] == 'S') {\n\t\t\t\t\t\t\tif (dp[nly][nlx][ry][rx][!bf] > dp[ly][lx][ry][rx][bf]) {\n\t\t\t\t\t\t\t\tdp[nly][nlx][ry][rx][!bf] = dp[ly][lx][ry][rx][bf];\n\t\t\t\t\t\t\t\tQ.push({ { { nly,nlx },{ ry,rx } },!bf });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[nly][nlx][ry][rx][!bf] > dp[ly][lx][ry][rx][bf] + field[nly][nlx] - '0') {\n\t\t\t\t\t\t\tdp[nly][nlx][ry][rx][!bf] = dp[ly][lx][ry][rx][bf] + field[nly][nlx] - '0';\n\t\t\t\t\t\t\tQ.push({ { { nly,nlx },{ ry,rx } },!bf });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(ret);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\tif (abs(i - k) + abs(j - l) > 3||j>=l)continue;\n\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t\t\t\t\t\t//cout << dp[i][j][k][l][0] << \" \" << dp[i][j][k][l][1] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H;\n\t}\n\tfor (auto i : ans) {\n\t\tif (i == MOD)cout << -1 << endl;\n\t\telse cout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  vector<P2> G[2][100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,-1,-2,-1,0,-1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> grid[i][j];\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tG[0][i][j].clear();\n\tG[1][i][j].clear();\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      if(grid[y][x] == 'T'){\n\tcout << t << endl;\n\tq.push(p);\n\tbreak;\n      }\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    if(q.empty())cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int dy[] = { 1,  1,  1,  1,  1,  2,  2,  2,  3};\nconst int dx[] = {-2, -1,  0,  1,  2, -1,  0,  1,  0};\nconst int INF = 1001001001;\nconst int K = 3;\ntypedef pair<int, int> P;\nstruct STATE\n{\n\tint x, y, a, d;\n\tbool operator <(const STATE &t) const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[256][256];\nint d[256][256][2];\nvoid init();\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tinit();\n\t\tw += K; h += K;\n\t\t\n\t\tvector<P> start;\n\t\tfor (int i = K; i < h; i++){\n\t\t\tfor (int j = K; j < w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'S'){\n\t\t\t\t\tstart.PB(P(i, j));\n\t\t\t\t\tgrid[i][j] = 127;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'T'){\n\t\t\t\t\tgrid[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] >= '1' && grid[i][j] <= '9'){\n\t\t\t\t\tgrid[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < start.size(); i++){\n\t\t\tpriority_queue<STATE> que;\n\t\t\tque.push({start[i].first, start[i].second, 1, 0});\n\t\t\tque.push({start[i].first, start[i].second, -1, 0});\n\t\t\tfor (; que.size(); que.pop()){\n\t\t\t\tSTATE st = que.top();\n\t\t\t\tif (d[st.x][st.y][st.a == 1] <= st.d) continue;\n\t\t\t\td[st.x][st.y][st.a == 1] = st.d;\n\t\t\t\tif (st.d >= res) continue;\n\t\t\t\tif (grid[st.x][st.y] == 0){\n\t\t\t\t\tres = st.d;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//cout << st.x << \" \" << st.y << endl;\n\t\t\t\t\n\t\t\t\tfor (int dir = 0; dir < 9; dir++){\n\t\t\t\t\tint tx = st.x + dx[dir] * st.a;\n\t\t\t\t\tint ty = st.y + dy[dir] * st.a;\n\t\t\t\t\tint ta = -st.a;\n\t\t\t\t\tint td = st.d + grid[tx][ty];\n\t\t\t\t\tif (grid[tx][ty] == 'X') continue;\n\t\t\t\t\tque.push({tx, ty, -st.a, td});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (res != INF) cout << res << endl;\n\t\telse cout << \"-1\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\nvoid init()\n{\n\tmemset(grid, 'X', sizeof(grid));\n\tfor (int i = 0; i < 256; i++){\n\t\tfor (int j = 0; j < 256; j++){\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\tint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\tint y[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\t\tset<int> t;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = input - '0';\n\t\t\t\telse if(input == 'X') \n\t\t\t\t\tfield[i][j] = INF;\n\t\t\t\telse if(input == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tpq.push(feet(j, i, 0, 0));\n\t\t\t\t\tpq.push(feet(j, i, 1, 0));\n\t\t\t\t}\n\t\t\t\telse if(input == 'T') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tt.insert(j*100+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n    cout <<ans <<endl;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(t.count(f.x*100+f.y)) { // 'T'\n\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<9; i++) {\n\t\t\t\tfeet temp(f.x+x[i], f.y+y[i], !f.p, f.cnt+field[f.y+y[i]][f.x+x[i]]);\n\t\t\t\tif(f.p) {\n\t\t\t\t\ttemp.x = f.x-x[i];\n\t\t\t\t\ttemp.cnt = f.cnt+field[f.y+y[i]][f.x-x[i]];\n\t\t\t\t}\n\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\tif(field[temp.y][temp.x] != INF) { // 'x'\n\t\t\t\t\t\tif(temp.x < 0 || w-1 < temp.x || temp.y < 0 || h-1 < temp.y) { //out of range\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans==INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}\n\n//passed all test cases\n//but couldnt pass"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n//#define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nint w, h;\nint cliff[70][40];\nint dist[70][40][2];\npii start[2800];\npii goal[2800];\n\nint steplx[9] = {3, 2, 2, 2, 1, 1, 1, 1, 1};\nint steply[9] = {0, -1, 0, 1, -2, -1, 0, 1, 2};\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if (w==0 && h==0) break;\n\n        REP(i, 70) {\n            REP(j, 40) {\n                cliff[i][j] = 0;\n                REP(k, 2) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n\n        REP(i, 2){\n            start[i] = pii(-1, -1);\n        }\n        \n        int start_num = 0;\n        int goal_num = 0;\n        REP(i, h) {\n            REP(j, w) {\n                char num;\n                cin >> num;\n                if (num == 'X') {\n                    cliff[i][j] = -1;\n                } else if (num == 'S') {\n                    cliff[i][j] = 0;\n                    REP(k, 2) dist[i][j][k] = 0;\n                    start[start_num] = pii(i, j);\n                    start_num++;\n                } else if (num == 'T') {\n                    cliff[i][j] = -2;\n                    goal[goal_num] = pii(i, j);\n                    goal_num++;\n                } else {\n                    cliff[i][j] = num - '0';\n                }\n            }\n        }\n\n        queue<pair<pii, pii>> que;\n        int sign[2] = {-1, 1};\n        REP(i, start_num) {\n            REP(j, 2) {\n                que.push(pair<pii, pii>(pii(0, sign[j]), start[i]));\n            }\n        }\n\n        while(!que.empty()) {\n            pair<pii, pii> p = que.front(); que.pop();\n            int d = p.first.first;\n            int x = p.second.second;\n            int y = p.second.first;\n            int lr = p.first.second;\n            if (d > dist[y][x][(1+lr)/2]) continue;\n\n#ifdef DEBUG\n            cout << y << \" \" << x << \" \" << d << \" \" << lr << endl;\n#endif\n\n            REP(i, 9) {\n                int nx = x + lr * steplx[i];\n                int ny = y + steply[i];\n                if (nx>=0 && ny>=0 && nx<w && ny<h) {\n                    if (cliff[ny][nx] == -1) continue;\n                    int next_dist = dist[y][x][(1+lr)/2] + max(0, cliff[ny][nx]);\n                    if (dist[ny][nx][(1-lr)/2] > next_dist) {\n                        dist[ny][nx][(1-lr)/2] = next_dist;\n                        if (cliff[ny][nx] == -2) continue;\n                        que.push(pair<pii, pii>(pii(next_dist, -lr), pii(ny, nx)));\n                    }\n                }\n            }\n        }\n\n        int output = INF;\n        REP(i, goal_num) {\n            REP(k, 2) {\n                output = min(dist[goal[i].first][goal[i].second][k], output);\n            }\n        }\n\n        if (output == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << output << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\nll dp[65][35][3];\nint main() {\n\tint w, h;\n\tint dx[9] = { 1,1,2,1,2,3,1,2,1 }, dy[9] = { -2,-1,-1,0,0,0,1,1,2 };\n\tchar s[65][35];\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tdp[i][j][0] = dp[i][j][1] = 0LL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto isOutOfRange = [] (int x, int y, int h, int w){\n\t\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t\t};\n\t\tauto cost = [&](int x, int y) {\n\t\t\tif (s[y][x] == 'X') return INF;\n\t\t\tif (s[y][x] == 'S') return INF;\n\t\t\tif (s[y][x] == 'T') return 0LL;\n\t\t\treturn (ll)s[y][x] - '0';\n\t\t};\n\t\tfor (int _ = 0; _ < 1800; _++) {\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int now = 0; now < 2; now++) {\n\t\t\t\t\t\tif (dp[y][x][now] == INF) continue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + (now==0?dx[i]:-dx[i]), ny = y + dy[i], nxt = (now + 1) % 2;\n\t\t\t\t\t\t\tif (isOutOfRange(nx, ny, h, w) || s[ny][nx] == 'X') continue;\n\t\t\t\t\t\t\tdp[ny][nx][nxt] = min(dp[ny][nx][nxt], dp[y][x][now] + cost(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcout << \"(\" << (dp[i][j][0]==INF?-1:dp[i][j][0]) << \", \" << (dp[i][j][1]==INF?-1:dp[i][j][1])<< \")\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tll ans = INF;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] != 'T') continue;\n\t\t\t\tans = min({ ans, dp[i][j][0], dp[i][j][1] });\n\t\t\t}\n\t\t}\n\t\tif (ans == INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\nstruct State {\n    int x, y, foot, cost;\n    State(int x, int y, int foot, int cost) : x(x), y(y), foot(foot), cost(cost){}\n};\n\nbool operator<(const State &lhs, const State &rhs) {\n    return lhs.cost > rhs.cost;\n}\n\nconst int MAX = (1 << 21);\nconst int dx[2][9] = {\n    {-3, -2, -2, -2, -1, -1, -1, -1, -1},\n    {3, 2, 2, 2, 1, 1, 1, 1, 1}\n};\nconst int dy[2][9] = {\n    {0, -1, 0, 1, -2, -1, 0, 1, 2},\n    {0, -1, 0, 1, -2, -1, 0, 1, 2}\n};\n\nchar field[80][80];\nbool visited[80][80][2];\n\nint main()\n{\n    int w, h;\n    while(cin >> w >> h && w && h) {\n        \n        priority_queue<State, vector<State>, less<State> > que;\n        for(int i = 0; i < 80; i++) {\n            for(int j = 0; j < 80; j++) {\n                field[i][j] = 'X';\n                visited[i][j][0] = visited[i][j][1] = false;\n            }\n        }\n        \n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                cin >> field[i + 5][j + 5];\n                if(field[i + 5][j + 5] == 'S') {\n                    que.push(State(j + 5, i + 5, 0, 0));\n                    que.push(State(j + 5, i + 5, 1, 0));\n                    field[i + 5][j + 5] = '0';\n                }\n            }\n        }\n\n        int ret = MAX;\n        while(!que.empty()) {\n            State cur = que.top(); que.pop();\n            if(field[cur.y][cur.x] == 'T') {\n                ret =  cur.cost;\n                break;\n            }\n            visited[cur.y][cur.x][cur.foot] = true;\n\n            //cout << cur.x << \" \" << cur.y << \" \" << cur.foot << \" \" << cur.cost << endl;\n            for(int i = 0; i < 9; i++) {\n                int nx, ny, nfoot, ncost;\n                nfoot = (cur.foot + 1) %2;\n                nx = cur.x + dx[nfoot][i]; ny = cur.y + dy[nfoot][i];\n                if(field[ny][nx] == 'X' || visited[ny][nx][nfoot]) {\n                    continue;\n                }\n                ncost = cur.cost + ((field[ny][nx] == 'T') ? 0 : (field[ny][nx] - '0'));\n                que.push(State(nx, ny, nfoot, ncost));\n            }\n        }\n        cout << ((ret == MAX) ? -1 : ret) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <queue>\nusing namespace std;\n\nint W, H;\nchar board[100][100];\nint dist[100][100][2];\nconst int INF = 1 << 28;\n\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int dx[][9] = {{0, 0, 0, 1, 1, 2, -1, -1, -2}, {0, 0, 0, 1, 1, 2, -1, -1, -2}};\nconst int dy[][9] = {{1, 2, 3, 1, 2, 1, 1, 2, 1}, {-1, -2, -3, -1, -2, -1, -1, -2, -1}};\n\nstruct Elem {\n    int x, y, foot, dist;\n    bool operator<(const Elem &e) const {\n        return dist > e.dist;\n    }\n};\n\nvoid solve() {\n    priority_queue<Elem> que;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 'S') {\n                que.push(Elem{i, j, 0, 0});\n                que.push(Elem{i, j, 1, 0});\n                dist[i][j][0] = dist[i][j][1] = 0;\n            }\n            else {\n                dist[i][j][0] = dist[i][j][1] = INF;\n            }\n        }\n    }\n\n    int ans = INF;\n    while(que.size()) {\n        Elem cur = que.top(); que.pop();\n        int f = cur.foot;\n        for(int k=0; k<9; k++) {\n            int nx = cur.x + dx[f][k];\n            int ny = cur.y + dy[f][k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if(board[nx][ny] == 'X') continue;\n\n            bool t_or_s = !isdigit(board[nx][ny]);\n            int cost = (t_or_s ? 0 : board[nx][ny] - '0');\n            if(dist[nx][ny][f^1] > dist[cur.x][cur.y][f] + cost) {\n                dist[nx][ny][f^1] = dist[cur.x][cur.y][f] + cost;\n                que.push(Elem{nx, ny, f^1, dist[nx][ny][f^1]});\n                if(board[nx][ny] == 'T') {\n                    if(ans > dist[nx][ny][f^1]) {\n                        ans = dist[nx][ny][f^1];\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", (ans == INF ? -1 : ans));\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d%d\", &W, &H);\n        if(W == 0 && H == 0) break;\n\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                scanf(\" %c\", &board[i][j]);\n            }\n        }\n\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-12;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint dp[60][30][60][30][2];\n\nstruct Node {\n\tint ly, lx, ry, rx, nx, cost;\n\tNode(const int lly, const int llx, const int rry, const int rrx, const int nnx, const int ccost) {\n\t\tly = lly, lx = llx, ry = rry, rx = rrx, nx = nnx, cost = ccost;\n\t}\n\tvoid debug() {\n\t\tcout << ly << \" \" << lx << \" \" << ry << \" \" << rx << \" \" << nx << \" \" << cost << endl;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn cost > n.cost;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> W >> H, H) {\n\t\tvector<vector<char>>field(H, vector<char>(W));\n\t\tfor (auto &i : field)for (auto &j : i)cin >> j;\n\t\treverse(field.begin(), field.end());\n\t\tint ans = MOD;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\tfor (int m = 0; m < 2; m++)dp[i][j][k][l][m] = MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<Node>PQ;\n\t\tfor (int k = 0; k < W; k++) {\n\t\t\tif (field[0][k] != 'S')continue;\n\t\t\tfor (int j = -3; j < 0; j++) {\n\t\t\t\tfor (int i = -3 - j; i <= j + 3; i++) {\n\t\t\t\t\tif (0 + i < 0 || 0 + i >= H || k + j < 0 || k + j >= W)continue;\n\t\t\t\t\tif (field[0 + i][k + j] == 'X')continue;\n\t\t\t\t\tint add = 0;\n\t\t\t\t\tif (field[0 + i][k + j] >= '0'&&field[0 + i][k + j] <= '9') {\n\t\t\t\t\t\tadd = field[0 + i][k + j] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[0 + i][k + j][0][k][1] > 0 + add) {\n\t\t\t\t\t\tdp[0 + i][k + j][0][k][1] = 0 + add;\n\t\t\t\t\t\tPQ.push(Node(0 + i, k + j, 0, k, 1, 0 + add));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\t\t\tfor (int i = j - 3; i <= 3 - j; i++) {\n\t\t\t\t\t\tif (0 + i < 0 || 0 + i >= H || k + j < 0 || k + j >= W)continue;\n\t\t\t\t\t\tif (field[0 + i][k + j] == 'X')continue;\n\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\tif (field[0 + i][k + j] >= '0'&&field[0 + i][k + j] <= '9') {\n\t\t\t\t\t\t\tadd = field[0 + i][k + j] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[0][k][0 + i][k + j][0] > 0 + add) {\n\t\t\t\t\t\t\tdp[0][k][0 + i][k + j][0] = 0 + add;\n\t\t\t\t\t\t\tPQ.push(Node(0, k, 0 + i, k + j, 0, 0 + add));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!PQ.empty()) {\n\t\t\tauto c = PQ.top();\n\t\t\t//c.debug();\n\t\t\tPQ.pop();\n\t\t\tif (c.nx == 0) {\n\t\t\t\tfor (int j = -3; j < 0; j++) {\n\t\t\t\t\tfor (int i = -3 - j; i <= j + 3; i++) {\n\t\t\t\t\t\tif (c.ry + i < 0 || c.ry + i >= H || c.rx + j < 0 || c.rx + j >= W)continue;\n\t\t\t\t\t\tif (field[c.ry + i][c.rx + j] == 'X')continue;\n\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\tif (field[c.ry + i][c.rx + j] >= '0'&&field[c.ry + i][c.rx + j] <= '9') {\n\t\t\t\t\t\t\tadd = field[c.ry + i][c.rx + j] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[c.ry + i][c.rx + j][c.ry][c.rx][1] > c.cost + add) {\n\t\t\t\t\t\t\tdp[c.ry + i][c.rx + j][c.ry][c.rx][1] = c.cost + add;\n\t\t\t\t\t\t\tPQ.push(Node(c.ry + i, c.rx + j, c.ry, c.rx, 1, c.cost + add));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\t\t\tfor (int i = j - 3; i <= 3 - j; i++) {\n\t\t\t\t\t\tif (c.ly + i < 0 || c.ly + i >= H || c.lx + j < 0 || c.lx + j >= W)continue;\n\t\t\t\t\t\tif (field[c.ly + i][c.lx + j] == 'X')continue;\n\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\tif (field[c.ly + i][c.lx + j] >= '0'&&field[c.ly + i][c.lx + j] <= '9') {\n\t\t\t\t\t\t\tadd = field[c.ly + i][c.lx + j] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[c.ly][c.lx][c.ly + i][c.lx + j][0] > c.cost + add) {\n\t\t\t\t\t\t\tdp[c.ly][c.lx][c.ly + i][c.lx + j][0] = c.cost + add;\n\t\t\t\t\t\t\tPQ.push(Node(c.ly, c.lx, c.ly + i, c.lx + j, 0, c.cost + add));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < W; i++) {\n\t\t\tif (field[H - 1][i] == 'T') {\n\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\tans = min(ans, dp[H - 1][i][j][k][l]);\n\t\t\t\t\t\t\tans = min(ans, dp[j][k][H - 1][i][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cctype>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int> >, greater<tuple<int, int, int, int> > > que;\n\n\tque.push(make_tuple(0, 0, sx, H - 1)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(0, 0, sx, H - 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint s = get<1>(que.top());\n\t\tint x = get<2>(que.top());\n\t\tint y = get<3>(que.top());\n\n\t\tque.pop();\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][1], x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][0], x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint w,h;\nchar s[99][99];\nint cost[60][30][60][30][2];\n\nstruct Node{\n  int lx,ly,rx,ry;\n  int foot,cost;\n  bool operator<(const Node &r)const{\n    return cost>=r.cost;\n  }\n};\nbool ok(Node &node){\n  int lx=node.lx,rx=node.rx,ly=node.ly,ry=node.ry;\n  if(lx<0||rx<0||ly<0||ry<0||lx>=w||rx>=w||ly>=h||ry>=h)return 0;\n     if(s[ly][lx]=='X'||s[ry][rx]=='X')return 0;\n     return lx<rx&&abs(lx-rx)+abs(ly-ry)<=3;\n}\n\nint main()\n{\n  while(cin>>w>>h,w){\n  \n    rep(i,h)rep(j,w)rep(ii,h)rep(jj,w)rep(k,2)cost[i][j][ii][jj][k]=inf;\n\n    priority_queue<Node>Q;\n    rep(i,h)rep(j,w){\n      cin>>s[i][j];\n      if(s[i][j]=='S'){\n\tNode node;\n\tnode.ry=-inf,node.rx=-inf;\n\tnode.ly=i,node.lx=j; node.foot=node.cost=0;\n\tQ.push(node);\n\tswap(node.ry,node.ly); swap(node.rx,node.lx);\n\tnode.foot=1;\n\tQ.push(node);\n      }\n    }\n    int ans=inf;\n    while(!Q.empty()){\n      Node cur=Q.top();\n      //dbg(cur.ly);dbg(cur.lx);dbg(cur.ry);dbg(cur.rx);\n      //dbg(cur.cost);dbg(cur.foot);\n      Q.pop();\n    \n      if(ok(cur)&&(s[cur.ly][cur.lx]=='T'||s[cur.ry][cur.rx]=='T')){\n\tans=cur.cost; break;\n      }\n\n      for(int dy=-3;dy<=3;dy++)for(int dx=-3;dx<=3;dx++){\n\tNode node=cur;\n\tint y,x;\n\tif(node.foot==0)y=node.ry=node.ly+dy,x=node.rx=node.lx+dx;\n\telse y=node.ly=node.ry+dy,x=node.lx=node.rx+dx;\n\tnode.foot^=1;\n\tif(!ok(node))continue;\n\n\tnode.cost+=isdigit(s[y][x])?s[y][x]-'0':0;\n\tint &c=cost[node.ly][node.lx][node.ry][node.rx][node.foot];\n\tif(node.cost>=c)continue;\n\t\n\tc=node.cost;\n\tQ.push(node);\n      }\n    }\n    cout<<(ans==inf?-1:ans)<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct leg{int x,y,rl,cost;\n  bool operator<(const leg& r)const{\n    return cost>r.cost;\n  }\n};\nint dp[60][30][2];\n\nint main(){\n  int h,w;\n  while(cin>>w>>h,w){\n    char ma[60][30];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>ma[i][j];\n\n    priority_queue<leg> que;\n    for(int i=0;i<w;i++){\n      if(ma[h-1][i]!='S')continue;\n      que.push((leg){h-1,i,0,0});\n      que.push((leg){h-1,i,1,0});\n    }\n    fill_n(**dp,60*30*2,-1);\n\n    int f=1;\n    while(!que.empty()){\n    \n      leg tmp=que.top();\n      que.pop();\n      int x=tmp.x;\n      int y=tmp.y;\n      int cost=tmp.cost;\n      int rl=tmp.rl;\n    \n      //cout<<x<<\" \"<<y<<\" \"<<rl<<\" \"<<cost<<endl;\n    \n      if(ma[x][y]=='X')continue;\n      if(ma[x][y]=='T'){\n\tcout<<cost<<endl;\n\tf=0;\n\tbreak;\n      }\n      if(dp[x][y][rl]!=-1)continue;\n    \n      dp[x][y][rl]=cost;\n    \n      if(ma[x][y]!='S')cost+=ma[x][y]-'0';\n      if(rl){\n      \n\tfor(int i=-2;i<=2;i++){\n\t  for(int j=1;j<=3;j++){\n\t    int nx=x+i;\n\t    int ny=y+j;\n\t    if(abs(y+1-ny)+abs(x-nx)>=3)continue;\n\t    if(nx<0||h<=nx||ny<0||w<=ny)continue;\n\t    if(ma[nx][ny]=='X')continue;\n\t    que.push((leg){nx,ny,!rl,cost});\n\t  }\n\t}\n      \n      }else{\n      \n\tfor(int i=-2;i<=2;i++){\n\t  for(int j=-3;j<=-1;j++){\n\t    int nx=x+i;\n\t    int ny=y+j;\n\t    if(abs(y-1-ny)+abs(x-nx)>=3)continue;\n\t    if(nx<0||h<=nx||ny<0||w<=ny)continue;\n\t    if(ma[nx][ny]=='X')continue;\n\t    que.push((leg){nx,ny,!rl,cost});\n\t  }\n\t}\n      \n      }\n    \n    }\n    if(f)cout<<-1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef pair<int, TIII> QIIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n#define MQ(a,b,c,d) MP(a, MT(b,c,d))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n#define Q1 first\n#define Q2 second.T1\n#define Q3 second.T2\n#define Q4 second.T3\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nchar board[60][60];\nint dist[60][60][2];\n\nint dx[9]={1,1,1,1,1,2,2,2,3};\nint dy[9]={-2,-1,0,1,2,-1,0,1,0};\n\nint main(){\n\tint w,h;\n\tchar buf[2];\n\twhile(cin>>w>>h,w){\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tscanf(\"%s\",buf);\n\t\t\t\tboard[h-1-i][j]=buf[0];\n\t\t\t}\n\t\t}\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tpriority_queue<QIIII, vector<QIIII>, greater<QIIII> > q;\n\t\tREP(i,w)if(board[0][i]=='S')REP(j,2)q.push(MQ(0,0,i,j));\n\t\tint ans = -1;\n\t\twhile(!q.empty()){\n\t\t\tQIIII tmp = q.top();\n\t\t\tq.pop();\n\t\t\tint cd = tmp.Q1;\n\t\t\tint cy = tmp.Q2;\n\t\t\tint cx = tmp.Q3;\n\t\t\tint lr = tmp.Q4;\n\t\t\tif(dist[cy][cx][lr]!=-1)continue;\n\t\t\tdist[cy][cx][lr]=cd;\n\t\t\tif(board[cy][cx]=='T'){\n\t\t\t\tans = cd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i,9){\n\t\t\t\tint nx=cx+(2*lr-1)*dx[i];\n\t\t\t\tint ny=cy+(2*lr-1)*dy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tif(board[ny][nx]=='X'||board[ny][nx]=='S')continue;\n\t\t\t\tif(board[ny][nx]=='T')q.push(MQ(cd, ny, nx, 1-lr));\n\t\t\t\telse q.push(MQ(cd+board[ny][nx]-'0', ny, nx, 1-lr));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int rdx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nconst int rdy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nconst int ldx[] = {-1, -1, -2, -1, -2, -3, -1, -2, -1};\nconst int ldy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nconst int INF = 1 << 30;\n\nint W, H;\n\nusing tup = tuple<int, int, bool>;\n\nvector<vector<vector<int>>> dijkstra(int sx, int sy, bool left, const vector<vector<char>> &grid)\n{\n    priority_queue<pair<int, tup>, vector<pair<int, tup>>, greater<pair<int, tup>>> que;\n    vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(2, INF)));\n    que.push(make_pair(0, make_tuple(sx, sy, left)));\n    dist[sy][sx][left] = 0;\n    while (!que.empty())\n    {\n        auto p = que.top();\n        que.pop();\n        int d = p.first;\n        int x = get<0>(p.second);\n        int y = get<1>(p.second);\n        int left = get<2>(p.second);\n        if (dist[y][x][left] < d)\n            continue;\n        for (int i = 0; i < 9; i++)\n        {\n            int nx = x + (left ? ldx[i] : rdx[i]);\n            int ny = y + (left ? ldy[i] : rdy[i]);\n            if (nx < 0 || nx >= W || ny < 0 || ny >= H || grid[ny][nx] == 'X')\n                continue;\n            int cost = grid[ny][nx] - '0';\n            if (grid[ny][nx] == 'T' || grid[ny][nx] == 'S')\n                cost = 0;\n            if (dist[y][x][left] + cost < dist[ny][nx][!left])\n            {\n                // cout << nx << ' ' << ny << endl;\n                que.push(make_pair(dist[y][x][left] + cost, make_tuple(nx, ny, !left)));\n                dist[ny][nx][!left] = dist[y][x][left] + cost;\n                // cout << dist[ny][nx][!left] << endl;\n            }\n        }\n    }\n    return dist;\n}\n\nint main()\n{\n    while (cin >> W >> H, W | H)\n    {\n        vector<vector<char>> grid(H, vector<char>(W));\n        vector<pair<int, int>> sp, tp;\n        for (int i = 0; i < H; i++)\n            for (int j = 0; j < W; j++)\n            {\n                cin >> grid[i][j];\n                if (grid[i][j] == 'T')\n                {\n                    tp.push_back(make_pair(j, i));\n                }\n                else if (grid[i][j] == 'S')\n                {\n                    sp.push_back(make_pair(j, i));\n                }\n            }\n        int res = INF;\n        for (auto s : sp)\n        {\n            for (int l = 0; l < 2; l++)\n            {\n                auto dist = dijkstra(s.first, s.second, l, grid);\n                // for (int i = 0; i < H; i++)\n                // {\n                //     for (int j = 0; j < W; j++)\n                //     {\n                //         cout << dist[i][j][0] << ' ';\n                //     }\n                //     cout << endl;\n                // }\n                for (auto t : tp)\n                {\n                    res = min(res, min(dist[t.second][t.first][0], dist[t.second][t.first][1]));\n                }\n            }\n        }\n        cout << (res == INF ? -1 : res) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint dp[100][50][2];\n\nint solve(int w, int h){\n  vector<vector<char>> vec(h,vector<char>(w));\n  rep(i,h) rep(j,w) scanf(\" %c\", &vec[i][j]);\n\n  fill(dp[0][0], dp[100][0], INF);\n  // dp[h][w][r?l]\n\n  queue<int> sx,sy,sz;\n\n  rep(i,h) rep(j,w){\n    if(vec[i][j]=='S'){\n      sx.push(i); sy.push(j); sz.push(0);\n      dp[i][j][0] = 0;\n      sx.push(i); sy.push(j); sz.push(1);\n      dp[i][j][1] = 0;\n    }\n    if(vec[i][j]=='T') vec[i][j]='0';\n  }\n\n  while(!sx.empty()){\n    int x = sx.front(); sx.pop();\n    int y = sy.front(); sy.pop();\n    int z = sz.front(); sz.pop();\n    const int dx[]={-2,-1,-1,0,0,0,1,1,2};\n    const int dy[][9]={{1,1,2,1,2,3,1,2,1}, {-1,-1,-2,-1,-2,-3,-1,-2,-1}};\n    rep(i,9){\n      int nx = x+dx[i];\n      int ny = y+dy[z][i];\n      int nz = !z;\n      if(nx<0 || nx>=h || ny<0 || ny>=w || vec[nx][ny]=='X') continue;\n      int nd = dp[x][y][z] + vec[nx][ny] - '0';\n      if(dp[nx][ny][nz]>nd){\n        dp[nx][ny][nz] = nd;\n        sx.push(nx); sy.push(ny); sz.push(nz);\n      }\n    }\n  }\n\n  int ret=INF;\n  rep(i,h) rep(j,w) if(vec[i][j]=='0') rep(k,2) ret = min(ret, dp[i][j][k]);\n  if(ret==INF) return -1;\n  else return ret;\n}\n\nint main(){\n  int w,h;\n  while(cin>>w>>h, w|h){\n    cout<<solve(w,h)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nchar s[100][100];\nint d[100][100][2];\n\nint dx[2][9] = { { 1, 1, 1, 1, 1, 2, 2, 2, 3 },\n\t\t\t\t{ -1, -1, -1, -1, -1, -2, -2, -2, -3 } };\nint dy[9] = { 2,1,0,-1,-2,1,0,-1,0 };\n\nconst int INF = 1e9;\n\ntypedef tuple<int, int, int> T;\n\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx && y < my;\n}\n\nint main(){\n\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\n\t\tmemset(s, 0, sizeof s);\n\n\t\trep(i, 100)rep(j, 100)rep(k, 2)d[i][j][k] = INF;\n\n\t\tqueue<T> q;\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> s[y][x];\n\t\t\tif (s[y][x] == 'S'){\n\t\t\t\tq.push(T(y, x, 0));\n\t\t\t\tq.push(T(y, x, 1));\n\t\t\t\td[y][x][0] = 0;\n\t\t\t\td[y][x][1] = 0;\n\t\t\t}\n\t\t}\n\n\t\twhile (q.size()){\n\t\t\tint y = get<0>(q.front());\n\t\t\tint x = get<1>(q.front());\n\t\t\tint r = get<2>(q.front());\n\t\t\tq.pop();\n\n\t\t\trep(i, 9){\n\t\t\t\tint tx = x + dx[r][i];\n\t\t\t\tint ty = y + dy[i];\n\n\t\t\t\tint tmp = 0;\n\t\t\t\tif (s[ty][tx] >= '0' && s[ty][tx] <= '9')tmp = s[ty][tx] - '0';\n\n\t\t\t\tif (cheak(x, y, w, h) && (d[ty][tx][1-r] > d[y][x][r] + tmp)\n\t\t\t\t\t&& (s[ty][tx] != 'X')){\n\n\t\t\t\t\td[ty][tx][1-r] = d[y][x][r] + tmp;\n\t\t\t\t\tq.push(T(ty, tx, 1 - r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(y, h)rep(x, w){\n\t\t\tif (s[y][x] == 'T'){\n\t\t\t\tans = min(ans, d[y][x][0]);\n\t\t\t\tans = min(ans, d[y][x][1]);\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef pair<int, TIII> QIIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n#define MQ(a,b,c,d) MP(a, MT(b,c,d))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n#define Q1 first\n#define Q2 second.T1\n#define Q3 second.T2\n#define Q4 second.T3\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nchar board[60][60];\nint dist[60][60][2];\n\nint dx[9]={1,1,1,1,1,2,2,2,3};\nint dy[9]={-2,-1,0,1,2,-1,0,1,0};\n\nint main(){\n\tint w,h;\n\tchar buf[2];\n\twhile(cin>>w>>h,w){\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tscanf(\"%s\",buf);\n\t\t\t\tboard[h-1-i][j]=buf[0];\n\t\t\t}\n\t\t}\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tpriority_queue<QIIII, vector<QIIII>, greater<QIIII> > q;\n\t\tREP(i,w)if(board[0][i]=='S')REP(j,2)q.push(MQ(0,0,i,j));\n\t\tint ans = -1;\n\t\twhile(!q.empty()){\n\t\t\tQIIII tmp = q.top();\n\t\t\tq.pop();\n\t\t\tint cd = tmp.Q1;\n\t\t\tint cy = tmp.Q2;\n\t\t\tint cx = tmp.Q3;\n\t\t\tint lr = tmp.Q4;\n\t\t\tif(dist[cy][cx][lr]!=-1)continue;\n\t\t\tdist[cy][cx][lr]=cd;\n\t\t\tif(board[cy][cx]=='T'){\n\t\t\t\tans = cd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i,9){\n\t\t\t\tint nx=cx+(2*lr-1)*dx[i];\n\t\t\t\tint ny=cy+(2*lr-1)*dy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tif(board[ny][nx]=='X'||board[ny][nx]=='S')continue;\n\t\t\t\tif(board[ny][nx]=='T')q.push(MQ(cd, ny, nx, 1-lr));\n\t\t\t\telse q.push(MQ(cd+board[ny][nx]-'0', ny, nx, 1-lr));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint w,h;\nchar s[99][99];\nint cost[60][30][60][30][2];\n\nstruct Node{\n  int lx,ly,rx,ry;\n  int foot,cost;\n  bool operator<(const Node &r)const{\n    return cost>=r.cost;\n  }\n};\nbool ok(Node &node){\n  int lx=node.lx,rx=node.rx,ly=node.ly,ry=node.ry;\n  if(lx<0||rx<0||ly<0||ry<0||lx>=w||rx>=w||ly>=h||ry>=h)return 0;\n     if(s[ly][lx]=='X'||s[ry][rx]=='X')return 0;\n     return lx<rx&&abs(lx-rx)+abs(ly-ry)<=3;\n}\n\nint main()\n{\n  while(cin>>w>>h,w){\n  \n    rep(i,h)rep(j,w)rep(ii,h)rep(jj,w)rep(k,2)cost[i][j][ii][jj][k]=inf;\n\n    priority_queue<Node>Q;\n    rep(i,h)rep(j,w){\n      cin>>s[i][j];\n      if(s[i][j]=='S'){\n\tNode node;\n\tnode.ry=-inf,node.rx=-inf;\n\tnode.ly=i,node.lx=j; node.foot=node.cost=0;\n\tQ.push(node);\n\tswap(node.ry,node.ly); swap(node.rx,node.lx);\n\tnode.foot=1;\n\tQ.push(node);\n      }\n    }\n    int ans=inf;\n    while(!Q.empty()){\n      Node cur=Q.top();\n      //dbg(cur.ly);dbg(cur.lx);dbg(cur.ry);dbg(cur.rx);\n      //dbg(cur.cost);dbg(cur.foot);\n      Q.pop();\n    \n      if(ok(cur)&&(s[cur.ly][cur.lx]=='T'||s[cur.ry][cur.rx]=='T')){\n\tans=cur.cost; break;\n      }\n\n      rep(y,h)rep(x,w){\n\tNode node=cur;\n\tif(node.foot==0)node.ry=y,node.rx=x;\n\telse node.ly=y,node.lx=x;\n\tnode.foot^=1;\n\tif(!ok(node))continue;\n\n\tnode.cost+=isdigit(s[y][x])?s[y][x]-'0':0;\n\tint &c=cost[node.ly][node.lx][node.ry][node.rx][node.foot];\n\tif(node.cost>=c)continue;\n\t\n\tc=node.cost;\n\tQ.push(node);\n      }\n    }\n    cout<<(ans==inf?-1:ans)<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct edge {int from, to, dist;};\nint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint y[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nconst int INF = 99999;\n\nint Dijkstra(const vector<edge>& es, int n, int s, int t){\n\tint* cal_graph = new int[n*n];\n\tint* d = new int[n];\n\tbool* used= new bool[n];\n\tint dist;\n\tfor(int j=0; j<n*n; j++){cal_graph[j]=INF;}\n\tfor(int j=0; j<n; j++){cal_graph[j*n+j]=0;}\n\tfor(int j=0; j<es.size(); j++){ cal_graph[ ((&es[j])->from)*n + (&es[j])->to ] = (&es[j])->dist;}\n\n\tfill(d,d+n, INF); fill(used,used+n,false); d[s]=0;\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0; u<n; u++){ if(!used[u] && (v==-1 || d[u]<d[v])){v=u;}}\n\t\tif(v==-1){ break;}\n\t\tused[v]=true;\n\t\tfor(int u=0; u<n; u++){ d[u] = min(d[u],d[v]+cal_graph[v*n+u]);}\n\t}\n\tdist = d[t];\n\n\tdelete[] cal_graph;\n\tdelete[] d;\n\n\treturn dist;\n}\n\nint main()\n{\n\tint w, h, ans;\n\tstring str;\n\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0){return 0;}\n\t\tint* graph = new int[w*2*h];\n\t\tvector<edge> es;\n\t\tedge e;\n\t\tvector<int> s;\n\t\tvector<int> t;\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> str;\n\t\t\t\tif(str == \"X\"){graph[i*w+j] = INF; graph[(i*w+j)+(h*w)] = INF;}\n\t\t\t\telse if(str == \"S\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; s.push_back(i*w+j); s.push_back((i*w+j)+(h*w));}\n\t\t\t\telse if(str == \"T\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; t.push_back(i*w+j); t.push_back((i*w+j)+(h*w));}\n\t\t\t\telse{ graph[i*w+j] = atoi(str.c_str()); graph[(i*w+j)+(h*w)] = graph[i*w+j];}\n\t\t\t}\n\t\t}\n\t\t/* \t二部グラフの作成 */\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(graph[i*w+j]!=INF){\n\t\t\t\t\tfor(int k=0; k<9; k++){\n\t\t\t\t\t\tif((j+x[k]<w)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j+x[k])]!=INF){ \n\t\t\t\t\t\t\t\t(e.from)=i*w+j; (e.to)=(i-y[k])*w+(j+x[k])+h*w; (e.dist)=graph[(i-y[k])*w+(j+x[k])+h*w]; es.push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((j-x[k]>=0)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j-x[k])]!=INF){ \n\t\t\t\t\t\t\t\t(e.from)=i*w+j+h*w; (e.to)=(i-y[k])*w+(j-x[k]); (e.dist)=graph[(i-y[k])*w+(j-x[k])+h*w]; es.push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdelete[] graph;\n\n\t\t/* SどうしとTどうしを接続 */\n\t\tfor(int i=0; i< s.size(); i++){\n\t\t\tfor(int j=0; j< s.size(); j++){\n\t\t\t\t(e.from)=s[i]; (e.to)=s[j]; (e.dist)=0; es.push_back(e);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\tfor(int j=0; j< t.size(); j++){\n\t\t\t\t(e.from)=t[i]; (e.to)=t[j]; (e.dist)=0; es.push_back(e);\n\t\t\t}\n\t\t}\n\n\t\tans = INF; ans = min(ans,Dijkstra(es, w*h*2, s[0], t[0]));\n\t\tif(ans!=INF){cout << ans << endl;}\n\t\telse{cout << -1 << endl;}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\nint dw[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dh[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\nchar mp[61][31];\nint dis[2][60][30];\nbool used[2][60][30];\nint w,h,ans;\nvoid dijkstra(int si,int sj, int sk){\n\trep(i,2) rep(j,h) rep(k,w) dis[i][j][k]=1e+8,used[i][j][k]=false;\n\tdis[si][sj][sk]=0;\n\twhile(true){\n\t\tint vi=-1,vj=-1,vk=-1;\n\t\trep(i,2) rep(j,h) rep(k,w){\n\t\t\tif(!used[i][j][k] && mp[j][k]!='X' &&(vi==-1 || dis[i][j][k]<dis[vi][vj][vk])) vi=i,vj=j,vk=k;\n\t\t}\n\t\tif(vi==-1) break;\n\t\tused[vi][vj][vk]=true;\n\t\trep(i,9){\n\t\t\tint nj=vj+dh[vi][i],nk=vk+dw[vi][i],ni=1-vi;\n\t\t\tif(0<=nj && nj<h && 0<=nk && nk<w && mp[nj][nk]!='X' && mp[nj][nk]!='S'){\n\t\t\t\tif(mp[nj][nk]=='T') dis[ni][nj][nk]=min(dis[ni][nj][nk],dis[vi][vj][vk]);\n\t\t\t\tdis[ni][nj][nk]=min(dis[ni][nj][nk],dis[vi][vj][vk]+(mp[nj][nk]-'0'));\n\t\t\t}\n\t\t}\n\t}\n\trep(j,w) if(mp[0][j]=='T') rep(i,2) ans=min(ans,dis[i][0][j]);\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0) break;\n\t\tans=1e+8;\n\t\trep(i,h) rep(j,w) cin >> mp[i][j];\n\t\trep(j,w) if(mp[h-1][j]=='S') rep(i,2) dijkstra(i,h-1,j);\n\t\tif(ans==1e8) ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][31][61][31];\nint dl[61][61];\nint dr[61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tfill(&dl[0][0], &dl[60][60] + 1, INF);\n\t\tfill(&dr[0][0], &dr[60][60] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tdl[j][i] = dr[j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr] || (dis > dl[xl][yl] && dis > dr[xr][yr])) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > dis + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = dis + cost;\n\t\t\t\t\t\tdr[xr2][yr2] = min(dr[xr2][yr2], memo[xl][yl][xr2][yr2]);\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > dis + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = dis + cost;\n\t\t\t\t\t\tdl[xl2][yl2] = min(dl[xl2][yl2], memo[xl2][yl2][xr][yr]);\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nconst int INF = INT_MAX/2-1;\n\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nint dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\n\ntypedef vector<char> vc;\n\nstruct state {\n\tint x, y, c;\n\tbool l;\n\tstate(int x, int y, int c, bool l) : x(x), y(y), c(c), l(l) {};\n\tbool operator<(const state &o)const {\n\t\treturn c>o.c;\n\t}\n};\n\nint get(char c) {\n\tswitch(c) {\n\tcase 'S':\n\tcase 'T':\n\t\treturn 0;\n\tdefault:\n\t\treturn c - '0';\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvector<vc> field(h, vc(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tvector<vvi> cost(2, vvi(h, vi(w, INF)));\t\t\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tQ.push(state(j, i, 0, true));\n\t\t\t\t\tQ.push(state(j, i, 0, false));\n\t\t\t\t\tcost[0][i][j] = 0;\n\t\t\t\t\tcost[1][i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tint k = (st.l ? 1 : -1);\n\t\t\tint l = (st.l ? 1 : 0);\n\n\t\t\tif(field[st.y][st.x] == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, 9) {\n\t\t\t\tint nx = st.x + dx[i]*k;\n\t\t\t\tint ny = st.y + dy[i];\n\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'X') {\n\t\t\t\t\tint nc = st.c + get(field[ny][nx]);\n\t\t\t\t\tif(nc < cost[l][ny][nx]) {\n\t\t\t\t\t\tcost[l][ny][nx] = nc;\n\t\t\t\t\t\tQ.push(state(nx, ny, nc, !st.l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'T') {\n\t\t\t\t\tans = min(ans, cost[0][i][j]);\n\t\t\t\t\tans = min(ans, cost[1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e5;\nint d[61][31][2];\n\nint main() {\n    int w, h;\n    while (cin >> w >> h && w){\n        VVI a(h, VI(w));\n        VI sx, sy, gx, gy;\n        REP(i,h) REP(j,w) {\n            char x;\n            cin >> x;\n            if (x == 'X') a[i][j] = -1;\n            else if (x == 'S'){\n                sx.push_back(i);\n                sy.push_back(j);\n            }else if (x == 'T'){\n                gx.push_back(i);\n                gy.push_back(j);\n            }else{\n                a[i][j] = x - '0';\n            }\n        }\n        REP(i,h) REP(j,w) REP(k,2) d[i][j][k] = INF;\n        priority_queue<pair<P,P>, vector<pair<P,P> >, greater<pair<P,P> > > q;\n        REP(i,sx.size()) REP(k,2) {\n            d[sx[i]][sy[i]][k] = 0;\n            q.push(make_pair(P(0,k), P(sx[i],sy[i])));\n        }\n        while (!q.empty()){\n            pair<P,P> pp = q.top();\n            q.pop();\n            int i = pp.second.first, j = pp.second.second;\n            int f = pp.first.second;\n            if(d[i][j][f] < pp.first.first) continue;\n            FOR(dj,1,3) FOR(di,-3+dj,3-dj){\n                int ii = i + di, jj = j;\n                if (f == 0) jj += dj;\n                else jj -= dj;\n                if (ii < 0 || jj < 0 || ii >= h || jj >= w || a[ii][jj] == -1) continue;\n                if (d[ii][jj][f^1] > d[i][j][f] + a[ii][jj]){\n                    d[ii][jj][f^1] = d[i][j][f] + a[ii][jj];\n                    q.push(make_pair(P(d[ii][jj][f^1],f^1), P(ii,jj)));\n                }\n            }\n        }\n        int ans = INF;\n        REP(i,gx.size()) REP(k,2){\n            ans = min(ans, d[gx[i]][gy[i]][k]);\n        }\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n#define INF 999999999\n\nclass P{\npublic:\n\tint x,y,cost,flg;\n\n\tP(int _x,int _y,int _cost,int _flg){\n\t\tx = _x;\n\t\ty = _y;\n\t\tcost = _cost;\n\t\tflg = _flg;\n\t}\n\n\tbool operator<(const P &p)const{\n\t\treturn cost > p.cost;\n\t}\n};\n\nint w,h;\nint t[62][62];\nint dx1[] = {1,1,1,1,1,2,2,2,3};\nint dy1[] = {-2,-1,0,1,2,-1,0,1,0};\nint dx2[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint dy2[] = {-2,-1,0,1,2,-1,0,1,0};\nbool closed[62][62][2];\n\nint solve(priority_queue<P> open){\n\tmemset(closed,0,sizeof(closed));\n\n\twhile(!open.empty()){\n\t\tP p = open.top(); open.pop();\n\t\tif(closed[p.x][p.y][p.flg]) continue;\n\t\tclosed[p.x][p.y][p.flg] = true;\n\n\t\tif(t[p.y][p.x] == -1){\n\t\t\treturn p.cost+1;\n\t\t}\n\n\t\tif(p.flg){\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint nx = p.x + dx1[i];\n\t\t\t\tint ny = p.y + dy1[i];\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && t[ny][nx]!=INF){\n\t\t\t\t\topen.push(P(nx,ny,p.cost+t[ny][nx],0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint nx = p.x + dx2[i];\n\t\t\t\tint ny = p.y + dy2[i];\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && t[ny][nx]!=INF){\n\t\t\t\t\topen.push(P(nx,ny,p.cost+t[ny][nx],1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(cin>>w>>h, w||h){\n\t\tpriority_queue<P> open;\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar ch;\n\t\t\t\tcin>>ch;\n\t\t\t\tif(ch == 'S'){\n\t\t\t\t\topen.push(P(j,i,0,0));\n\t\t\t\t\topen.push(P(j,i,0,1));\n\t\t\t\t\tt[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(ch == 'T') t[i][j] = -1;\n\t\t\t\telse if(ch == 'X') t[i][j] = INF;\n\t\t\t\telse t[i][j] = ch - '0';\n\t\t\t}\n\t\t}\n\n\t\tint res = solve(open);\n\t\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <ctime>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1);\n#endif\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int((a).size()))\n#define F first\n#define S second\nint dx[]={0,1,0,-1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\n\nint w,h;\nchar in[100][100];\nbool vis[2][100][100];\nint solve(){\n  priority_queue<pair<PI,PI> > q;\n  memset(vis,0,sizeof(vis));\n  rep(i,h)rep(j,w){\n    cin>>in[i][j];\n    if(in[i][j]=='S'){\n      q.push(mp(mp(0,0),mp(i,j)));\n      q.push(mp(mp(0,1),mp(i,j)));\n    }\n  }\n\n  while(!q.empty()){\n    pair<PI,PI> cv=q.top();q.pop();\n    int fo=cv.F.S;\n    int cc=-cv.F.F;\n    int cx=cv.S.F;\n    int cy=cv.S.S;\n    if(vis[fo][cx][cy])continue;\n    vis[fo][cx][cy]=true;\n    if(in[cx][cy]=='T')return cc;\n    for(int i=-2;i<=2;++i)\n      for(int j=1;j<=3-abs(i);++j){\n        int nx=cx+i;\n        int ny=cy+(fo*2-1)*j;\n        if(min(nx,ny)<0 || nx>=h || ny>=w ||\n           vis[!fo][nx][ny] || in[nx][ny]=='X')continue;\n        int nc=cc;\n        if(isdigit(in[nx][ny]))nc+=in[nx][ny]-'0';\n        q.push(mp(mp(-nc,!fo),\n                  mp(nx,ny)));\n      }\n  }\n  return -1;  \n}\n\n\nmain(){\n  while(cin>>w>>h,h)\n    cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,pair<int,int> > > pi;\n\n#define COST(p) ((p).first)\n#define LR(p) ((p).second.first)\n#define X(p) ((p).second.second.first)\n#define Y(p) ((p).second.second.second)\n#define PI(c,l,x,y) (make_pair(c,make_pair(l,make_pair(x,y))))\n#define L (0)\n#define R (1)\n\nint main(){\n  int w,h;\n  while(cin>>w>>h, w+h){\n    int s[h][w];\n    priority_queue<pi,vector<pi>,greater<pi> > q;\n    int memo[2][h][w];\n    memset(memo,-1,sizeof(memo));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        char c; cin>>c;\n        switch(c){\n        case 'T':\n          s[i][j]=0;\n          break;\n        case 'S':\n          q.push(PI(0,L,j,i)); memo[L][i][j]=0;\n          q.push(PI(0,R,j,i)); memo[R][i][j]=0;\n        case 'X':\n          s[i][j]='X';\n          break;\n        default:\n          s[i][j]=c-'0';\n          break;\n        }\n      }\n    }\n    const int dx[] = { 3, 2, 2, 2, 1, 1, 1, 1, 1};\n    const int dy[] = { 0, 1, 0,-1, 2, 1, 0,-1,-2};\n#define OK(x,y,w,h) (x>=0&&y>=0&&x<w&&y<h)\n    while(q.size()){\n      pi p = q.top(); q.pop();\n      int c =COST(p), x = X(p), y = Y(p);\n      int lr = LR(p), nlr = (lr==0?1:0);\n      /*\n      cout << x << \",\" << y <<  \" \" << (lr==0?'L':'R') <<endl;\n      for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n          printf(\"%3d \",memo[0][i][j]);\n        }\n        printf(\" || \");\n        for(int j=0; j<w; j++){\n          printf(\"%3d \",memo[1][i][j]);\n        }\n        printf(\" || \");\n        for(int j=0; j<w; j++){\n          printf(\"%3d \",s[i][j]);\n        }\n        puts(\"\");\n      }\n      puts(\"\");\n      */\n      if(s[y][x]==0){\n        cout << c << endl;\n        break;\n      }\n      for(int i=0; i<9; i++){\n        int xx,yy=y+dy[i];\n        if(lr==L)\n          xx = x+dx[i];\n        else\n          xx = x-dx[i];\n        //cout << \" \" <<  xx << \",\" << yy << endl;\n        if(OK(xx,yy,w,h)&&(s[yy][xx]!='X')&&(memo[nlr][yy][xx]==-1)){\n          memo[nlr][yy][xx]= c + s[yy][xx];\n          q.push(PI(c+s[yy][xx],nlr,xx,yy));\n        }\n      }\n      if(q.empty()){\n        cout << \"-1\" << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<vector<char>> s(h, vector<char>(w));\n        vector<vector<vector<int>>> d(h, vector<vector<int>>(w, vector<int>(2, inf)));\n        using state = tuple<int, int, int, int>;\n        priority_queue<state, vector<state>, greater<state>> que;\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                cin >> s[i][j];\n                if(s[i][j] == 'S') {\n                    d[h - i - 1][j][0] = d[h - i - 1][j][1] = 0;\n                    que.emplace(0, h - i - 1, j, 0);\n                    que.emplace(0, h - i - 1, j, 1);\n                }\n            }\n        }\n        reverse(begin(s), end(s));\n        while(!que.empty()) {\n            int cur_d, y, x, step;\n            tie(cur_d, y, x, step) = que.top();\n            que.pop();\n            if(cur_d > d[y][x][step]) continue;\n            int inc = step == 0 ? 1 : -1;\n            for(int i = 1; i <= 3; ++i) {\n                for(int dy = -3 + i; dy <= 3 - i; ++dy) {\n                    int ny = y + dy, nx = x + inc * i;\n                    if(ny < 0 || h <= ny || nx < 0 || w <= nx || s[ny][nx] == 'X') continue;\n                    int nxt_d = cur_d + (isalpha(s[ny][nx]) ? 0 : s[ny][nx] - '0');\n                    if(d[ny][nx][!step] > nxt_d) {\n                        que.emplace(nxt_d, ny, nx, !step);\n                        d[ny][nx][!step] = nxt_d;\n                    }\n                }\n            }\n        }\n\n        int ans = inf;\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                if(s[i][j] == 'T') {\n                    ans = min({ans, d[i][j][0], d[i][j][1]});\n                }\n            }\n        }\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n//#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define INF 10000;\n\n\nbool check[100][100][2] = { false };\nint cost[100][100][2];\nint move[] = { 1, -1 };\n\nclass Node{\npublic:\n\tint x;\n\tint y;\n\tint lr;//0 -> left, 1 -> right\n\tint num;\n\n\tNode(){ x = 0; y = 0; lr = 0; num = 0; }\n\tNode(int x, int y, int lr, int num) : x(x), y(y), lr(lr), num(num){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.num < n2.num;\n}\n\nbool operator> (const Node &n1, const Node &n2){\n\treturn n1.num > n2.num;\n}\n\nint main(void){\n\n\tint w, h;\n\twhile (cin >> w >> h, w, h){\n\t\tchar map[100][100];\n\t\tint result = -1;\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcost[j][i][1] = cost[j][i][0] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcheck[j][i][1] = check[j][i][0] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif (map[j][i] == 'X') check[j][i][1] = check[j][i][0] = true;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que;\n\n\t\tfor (int i = 0; i < w; i++){\n\t\t\tif (map[0][i] == 'S'){\n\t\t\t\tque.push(Node(i, 0, 0, 0));\n\t\t\t\tque.push(Node(i, 0, 1, 0));\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\twhile (!que.empty()){\n\t\t\tNode buff = que.top();\n\t\t\tque.pop();\n\n\t\t\tif (check[buff.y][buff.x][buff.lr]) continue;\n\t\t\tcheck[buff.y][buff.x][buff.lr] = true;\n\t\t\tcost[buff.y][buff.x][buff.lr] = min(cost[buff.y][buff.x][buff.lr], buff.num);\n\n\t\t\tfor (int i = 1; i <= 3; i++){\n\t\t\t\tfor (int j = 3 - i; abs(j) + i <= 3; j--){\n\t\t\t\t\tif (flag) break;\n\t\t\t\t\tint nextx = buff.x + move[buff.lr] * i;\n\t\t\t\t\tint nexty = buff.y + j;\n\t\t\t\t\tif (nextx < 0 || w <= nextx || nexty < 0 || h <= nexty || map[nexty][nextx] == 'S' || map[nexty][nextx] == 'X') continue;\n\t\t\t\t\tif (map[nexty][nextx] == 'T'){\n\t\t\t\t\t\tresult = buff.num;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(Node(nextx, nexty, (buff.lr + 1) % 2, buff.num + (map[nexty][nextx] - '0')));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\t/*\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << map[j][i] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << min(cost[j][i][0], cost[j][i][1]) << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif (!flag) cout << -1 << endl;\n\t\telse cout << result << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 1000000000\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\nstruct state { int y, x, s, c; };\n\nint H, W;\nchar S[60][30];\nint dp[60][30][2];\nbool g[60][30];\n\nconst int dd[2][9][2] = {\n  {\n    { 2, -1 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -2, -1 },\n    { 1, -2 }, { 0, -2 }, { -1, -2 }, { 0, -3 }\n  }, {\n    { 2, 1 }, { 1, 1 }, { 0, 1 }, { -1, 1 }, { -2, 1 },\n    { 1, 2 }, { 0, 2 }, { -1, 2 }, { 0, 3 }\n  }\n};\n\nclass Compare {\npublic:\n  bool operator()(struct state a, struct state b) {\n    return a.c > b.c;\n  }\n};\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W && S[y][x] != 'X';\n}\n\nint main(void) {\n  while(cin >> W >> H, H && W) {\n    priority_queue<struct state, vector<struct state>, Compare> q;\n\n    REP(i, 0, H) {\n      REP(j, 0, W) {\n        cin >> S[i][j];\n        if(S[i][j] == 'S') {\n          struct state sl = { i, j, 0, 0 };\n          struct state sr = { i, j, 1, 0 };\n          q.push(sl);\n          q.push(sr);\n          S[i][j] = '0';\n        }\n        if(S[i][j] == 'T') {\n          g[i][j] = true;\n          S[i][j] = '0';\n        } else {\n          g[i][j] = false;\n        }\n      }\n    }\n\n    REP(i, 0, H) REP(j, 0, W) REP(k, 0, 2) dp[i][j][k] = INF;\n\n    int ans = -1;\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.y << \" \" << c.x << \" \" << c.s << \" \" << c.c << endl;\n\n      if(dp[c.y][c.x][c.s] <= c.c) continue;\n      dp[c.y][c.x][c.s] = c.c;\n\n      if(g[c.y][c.x]) {\n        ans = dp[c.y][c.x][c.s];\n        break;\n      }\n\n      int ns = 1 - c.s;\n      REP(i, 0, 9) {\n        int ny = c.y + dd[ns][i][0];\n        int nx = c.x + dd[ns][i][1];\n        if(isin(ny, nx)) {\n          struct state n = { ny, nx, ns, c.c + (S[ny][nx] - '0') };\n          if(dp[n.y][n.x][n.s] >= n.c) q.push(n);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n//typedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint x;\n\tint y;\n\tint cost;\n};\n\nclass Sit{\npublic:\n\tint x;\n\tint y;\n\tint foot;\n\n\tSit();\n\n\tSit(int _x,int _y,int _foot){\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n\n\tbool operator<(const Sit &a) const{\n\t\treturn a.foot < this->foot;\n\t}\n};\n\ntypedef pair<int,Sit> P;\nint V;\n\nconst int MAX_X = 30;\nconst int MAX_Y = 60;\n\n// x,yÀWAÇÌ«ð©¯é©\nvector<edge> G[MAX_Y][MAX_X][2];\n\n// RXg\nint d[MAX_Y][MAX_X][2];\nconst int INF = 100000000;\n\nvoid dijkstra(int sx,int sy,int sfoot){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i = 0; i < MAX_Y; i++)\n\t\tfor(int j = 0; j < MAX_X; j++)\n\t\t\tfill(d[i][j],d[i][j]+2,INF);\n\n\td[sy][sx][sfoot] = 0;\n\tque.push(P(0,Sit(sx,sy,sfoot)));\n\twhile(!que.empty()){\n\t\t//if(sy == 9 && que.top().second.y == 4){\n\t\t//\tcout << endl;\n\t\t//}\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tSit v = p.second;\n\t\tif(d[v.y][v.x][v.foot] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v.y][v.x][v.foot].size(); i++){\n\t\t\tedge e = G[v.y][v.x][v.foot][i];\n\t\t\tint nextStep = v.foot ? 0 : 1;\n\t\t\tif(d[e.y][e.x][nextStep] > d[v.y][v.x][v.foot] + e.cost){\n\t\t\t\td[e.y][e.x][nextStep] = d[v.y][v.x][v.foot] + e.cost;\n\t\t\t\tque.push(P(d[e.y][e.x][nextStep],Sit(e.x,e.y,nextStep)));\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\n\tint w,h;\n\tchar field[60][30];\n\tvector<pair<int,int> > startPoints;\n\tvector<pair<int,int> > terminates;\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tstartPoints.clear();\n\t\tterminates.clear();\n\t\tfor(int i = 0; i < MAX_Y; i++)\n\t\t\tfor(int j = 0; j < MAX_X; j++)\n\t\t\t\tfor(int k = 0; k <= 1; k++)\n\t\t\t\t\tG[i][j][k].clear();\n\n\t\t// make filed\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == 'S'){\n\t\t\t\t\tstartPoints.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'T'){\n\t\t\t\t\tterminates.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// GbWðÔ\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t//if(i == 5 && j == 0 && w == 2){\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\tif(field[i][j] == 'X' || field[i][j] == 'T')\n\t\t\t\t\tcontinue;\n\t\t\t\t// »m[hÅÂ¢Ä¢é«Ìûü(0ð¶,1ðE«Æ·é)\n\t\t\t\t//if(w == 2){\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t// yoko\n\t\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\t\t// tate\n\t\t\t\t\t\t\tfor(int m = -3+l; m <= -l+3; m++){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.y = i + m;\n\t\t\t\t\t\t\t\te.x = j + l;\n\t\t\t\t\t\t\t\tif(!(e.x < 0 || e.x >= w || e.y < 0 || e.y >= h || field[e.y][e.x] == 'X' || field[e.y][e.x] == 'S')){\n\t\t\t\t\t\t\t\t\tif(field[e.y][e.x] == 'T')\n\t\t\t\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\te.cost = field[e.y][e.x] - '0';\n\t\t\t\t\t\t\t\t\tG[i][j][k].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int l = -1; l >= -3; l--){\n\t\t\t\t\t\t\t// tate\n\t\t\t\t\t\t\tfor(int m = -l-3; m <= l+3; m++){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.y = i + m;\n\t\t\t\t\t\t\t\te.x = j + l;\n\t\t\t\t\t\t\t\tif(!(e.x < 0 || e.x >= w || e.y < 0 || e.y >= h || field[e.y][e.x] == 'X' || field[e.y][e.x] == 'S')){\n\t\t\t\t\t\t\t\t\tif(field[e.y][e.x] == 'T')\n\t\t\t\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\te.cost = field[e.y][e.x] - '0';\n\t\t\t\t\t\t\t\t\tG[i][j][k].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// en_©çD«È«ÅX^[g\n\t\tint minCost = INF;\n\t\tfor(int i = 0; i < startPoints.size(); i++){\n\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\tpair<int,int> pr = startPoints[i];\n\t\t\t\t//if(w == 2){\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\tdijkstra(pr.second,pr.first,k);\n\t\t\t\t// min cost\n\t\t\t\tfor(int l = 0; l < terminates.size(); l++){\n\t\t\t\t\tfor(int m = 0; m < 2; m++){\n\t\t\t\t\t\tminCost = min(minCost,d[terminates[l].first][terminates[l].second][m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << minCost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint dist[1800][1800][2],s[100][100],w,h;\n\nint encode(int x,int y){\n    return x+w*y;\n}\n\npii decode(int pos){\n    return make_pair(pos%w,pos/w);\n}\n\nbool verify(int lp,int rp){\n    int lx=decode(lp).first,ly=decode(lp).second;\n    int rx=decode(rp).first,ry=decode(rp).second;\n    return lx<rx and abs(lx-rx)+abs(ly-ry)<=3 and s[lx][ly]!=inf and s[rx][ry]!=inf;\n}\n\nvoid solve(){\n    typedef tuple<int,int,int> state;\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n        vector<int> start_points,end_points;\n        rep(y,0,h) rep(x,0,w) s[x][y]=0;\n        rep(y,0,h) rep(x,0,w){\n            char tmp;\n            cin >> tmp;\n            if(tmp=='S') start_points.push_back(encode(x,y));\n            else if(tmp=='T') end_points.push_back(encode(x,y));\n            else if(tmp=='X') s[x][y]=inf;\n            else s[x][y]=tmp-'0';\n        }\n\n        rep(i,0,w*h) rep(j,0,w*h) rep(k,0,2) dist[i][j][k]=inf;\n        priority_queue<pair<int,state>,vector<pair<int,state>>,greater<pair<int,state>>> que;\n        rep(i,0,2) rep(j,0,w*h){\n            auto f=[&](int lp,int rp,int c){\n                if(!verify(lp,rp)) return;\n                dist[lp][rp][c]=s[decode(j).first][decode(j).second];\n                que.push(make_pair(dist[lp][rp][c],make_tuple(lp,rp,c)));\n            };\n            f(start_points[i],j,0);\n            f(j,start_points[i],1);\n        }\n\n        while(!que.empty()){\n            int d=que.top().first;\n            state st=que.top().second;\n            que.pop();\n            int lp=get<0>(st),rp=get<1>(st),c=get<2>(st);\n            if(d>dist[lp][rp][c]) continue;\n\n            int lx=decode(lp).first,ly=decode(lp).second;\n            int rx=decode(rp).first,ry=decode(rp).second;\n            rep(dx,-5,5) rep(dy,-5,5){\n                auto add=[&](int nlp,int nrp,int nc,int cost){\n                    if(verify(nlp,nrp) and d+cost<dist[nlp][nrp][nc]){\n                        dist[nlp][nrp][nc]=d+cost;\n                        que.push(make_pair(dist[nlp][nrp][nc],make_tuple(nlp,nrp,nc)));\n                    }\n                };\n                if(c==0){\n                    if(0<=lx+dx and lx+dx<w and 0<=ly+dy and ly+dy<h) add(encode(lx+dx,ly+dy),rp,1-c,s[lx+dx][ly+dy]);\n                }else{\n                    if(0<=rx+dx and rx+dx<w and 0<=ry+dy and ry+dy<h) add(lp,encode(rx+dx,ry+dy),1-c,s[rx+dx][ry+dy]);\n                }\n            }\n        }\n\n        int ans=inf;\n        rep(i,0,w*h) rep(j,0,2){\n            ans=min(ans,dist[end_points[0]][i][j]);\n            ans=min(ans,dist[i][end_points[0]][j]);\n            ans=min(ans,dist[end_points[1]][i][j]);\n            ans=min(ans,dist[i][end_points[1]][j]);\n        }\n        if(ans==inf) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint W, H;\nchar board[100][100];\nint dist[100][100][2];\nconst int INF = 1 << 28;\n\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int dx[][9] = {{0, 0, 0, 1, 1, 2, -1, -1, -2}, {0, 0, 0, 1, 1, 2, -1, -1, -2}};\nconst int dy[][9] = {{1, 2, 3, 1, 2, 1, 1, 2, 1}, {-1, -2, -3, -1, -2, -1, -1, -2, -1}};\n\nstruct Elem {\n    int x, y, foot, dist;\n    bool operator<(const Elem &e) const {\n        return dist > e.dist;\n    }\n};\n\nvoid solve() {\n    priority_queue<Elem> que;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 'S') {\n                que.push(Elem{i, j, 0, 0});\n                que.push(Elem{i, j, 1, 0});\n                dist[i][j][0] = dist[i][j][1] = 0;\n            }\n            else {\n                dist[i][j][0] = dist[i][j][1] = INF;\n            }\n        }\n    }\n\n    int ans = INF;\n    while(que.size()) {\n        Elem cur = que.top(); que.pop();\n        int f = cur.foot;\n        for(int k=0; k<9; k++) {\n            int nx = cur.x + dx[f][k];\n            int ny = cur.y + dy[f][k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if(board[nx][ny] == 'X') continue;\n\n            bool t_or_s = !isdigit(board[nx][ny]);\n            int cost = (t_or_s ? 0 : board[nx][ny] - '0');\n            if(dist[nx][ny][f^1] > dist[cur.x][cur.y][f] + cost) {\n                dist[nx][ny][f^1] = dist[cur.x][cur.y][f] + cost;\n                que.push(Elem{nx, ny, f^1, dist[nx][ny][f^1]});\n                if(board[nx][ny] == 'T') {\n                    if(ans > dist[nx][ny][f^1]) {\n                        ans = dist[nx][ny][f^1];\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", (ans == INF ? -1 : ans));\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d%d\", &W, &H);\n        if(W == 0 && H == 0) break;\n\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                scanf(\" %c\", &board[i][j]);\n            }\n        }\n\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\nint dw[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dh[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\nchar mp[61][31];\nint dis[2][60][30];\nbool used[2][60][30];\nint w,h,ans;\nvoid dijkstra(int si,int sj, int sk){\n\trep(i,2) rep(j,h) rep(k,w) dis[i][j][k]=1e+8,used[i][j][k]=false;\n\tdis[si][sj][sk]=0;\n\twhile(true){\n\t\tint vi=-1,vj=-1,vk=-1;\n\t\trep(i,2) rep(j,h) rep(k,w){\n\t\t\tif(!used[i][j][k] && mp[j][k]!='X' &&(vi==-1 || dis[i][j][k]<dis[vi][vj][vk])) vi=i,vj=j,vk=k;\n\t\t}\n\t\tif(vi==-1) break;\n\t\tused[vi][vj][vk]=true;\n\t\trep(i,9){\n\t\t\tint nj=vj+dh[vi][i],nk=vk+dw[vi][i],ni=1-vi;\n\t\t\tif(0<=nj && nj<h && 0<=nk && nk<w && mp[nj][nk]!='X' && mp[nj][nk]!='S'){\n\t\t\t\tif(mp[nj][nk]=='T') dis[ni][nj][nk]=min(dis[ni][nj][nk],dis[vi][vj][vk]);\n\t\t\t\tdis[ni][nj][nk]=min(dis[ni][nj][nk],dis[vi][vj][vk]+(mp[nj][nk]-'0'));\n\t\t\t}\n\t\t}\n\t}\n\trep(j,w) if(mp[0][j]=='T') rep(i,2) ans=min(ans,dis[i][0][j]);\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0) break;\n\t\tans=1e+8;\n\t\trep(i,h) rep(j,w) scanf(\" %c\",&mp[i][j]);\n\t\trep(j,w) if(mp[h-1][j]=='S') rep(i,2) dijkstra(i,h-1,j);\n\t\tif(ans==1e8) ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define exist(c, x) find(all(c), x) != (c).end()\n#define mp(a, b) make_pair(a, b)\nconst int inf = 1 << 28;\nconst int dx[][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1,  0,  0,  0,  1,  1,  2}},\n          dy[][9] = {{ 1,  1,  2, 1, 2, 3, 1, 2, 1}, {-1, -1, -2, -1, -2, -3, -1, -2, -1}};\n\nint w, h;\nvector<vector<int> > cliff;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(){\n    vector<vector<int> > mem;\n    mem.assign(h * 100 + w, vector<int>(h * 100 + w, inf));\n    vector<int> T;\n    rep(j, w)if(cliff[0][j] == 0)T.push_back(j);\n    auto comp = [&](const pair<int, int> &a, const pair<int, int> &b){\n        return mem[a.first][a.second] > mem[b.first][b.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int> >, decltype(comp)> q(comp);\n    rep(k, w)if(cliff[h-1][k] == -1){\n        int st = (h-1) * 100 + k;\n        rep(i, 2)rep(j, 9){\n            int nx = h-1 + dx[i][j], ny = k + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int nxt = nx * 100 + ny;\n                mem[i? nxt: st][i? st: nxt] = cliff[nx][ny];\n                q.push(mp(i? nxt: st, i? st: nxt));\n            }\n        }\n    }\n    while(!q.empty()){\n        pair<int, int> p = q.top(); q.pop();\n        if(exist(T, p.first) || exist(T, p.second))continue;\n        int lx = p.first / 100, ly = p.first % 100, rx = p.second / 100, ry = p.second % 100;\n        rep(i, 2)rep(j, 9){\n            int nx = (i? rx: lx) + dx[i][j], ny = (i? ry: ly) + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int cost = mem[p.first][p.second] + cliff[nx][ny], nxt = nx * 100 + ny;\n                if(mem[i? nxt: p.first][i? p.second: nxt] <= cost)continue;\n                mem[i? nxt: p.first][i? p.second: nxt] = cost;\n                q.push(mp(i? nxt: p.first, i? p.second: nxt));\n            }\n        }\n    }\n    int res = inf;\n    for(auto v: T){\n        rep(k, h * 100 + w)res = min(res, mem[v][k]);\n        rep(k, h * 100 + w)res = min(res, mem[k][v]);\n    }\n    return res == inf? -1: res;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        cin.ignore();\n        cliff.assign(h, vector<int>(w, 0));\n        rep(i, h){\n            string in;\n            getline(cin, in);\n            in.erase(remove_if(all(in), [](char c){return c == ' ';}), in.end());\n            rep(j, w)cliff[i][j] = in[j] == 'X'? -2: in[j] == 'S'? -1: in[j] == 'T'? 0: in[j] - '0';\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1e9\nchar v[31][61][2];\nchar map[32][62];\nint dp[31][36][2];\nint w,h;\nstruct {int x,y;} d[9]={\n{1,-2},\n{1,-1},\n{1,0},\n{1,1},\n{1,2},\n{2,-1},\n{2,0},\n{2,1},\n{3,0}\n};\n\n\nclass State{\npublic:\n\tint cost;\n\tint x,y,d;\n\t\n\tState(){}\n\tState(int c, int a, int b, int e)\n\t:cost(c),x(a),y(b),d(e)\n\t{}\n\tbool operator < (const State &opp) const{\n\t\treturn cost > opp.cost;\n\t}\n};\n\nmain(){\n\tint i,j,k;\n\twhile(cin>>w>>h,w){\n\t\tpriority_queue<State> S;\n\t\tfor(i=1;i<=h;i++) \n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin>>map[j][i];\n\t\t\t\tfor(k=0;k<2;k++){\n\t\t\t\t\tif(map[j][i]=='S'){\n\t\t\t\t\t\tS.push(State(0,j,i,k));\n\t\t\t\t\t\tdp[j][i][k] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[j][i][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t\tv[j][i][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tState t;\n\t\twhile(!S.empty()){\n\t\t\tt = S.top();S.pop();\n\t\t\tif(map[t.x][t.y]=='T') break;\n\t\t\tif(v[t.x][t.y][t.d]) continue;\n\t\t\tv[t.x][t.y][t.d] = 1;\n\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tint tx=t.x+d[i].x*(!t.d?1:-1);\n\t\t\t\tint ty=t.y+d[i].y;\n\t\t\t\tint td=(t.d+1)%2;\n\t\t\t\tif(tx<1 || ty<1 || w<tx || h<ty || map[tx][ty]=='X') continue;\n\t\t\t\tint tc=('0'<=map[tx][ty] && map[tx][ty]<='9')?map[tx][ty]-'0':0;\n\t\t\t\tif(t.cost+tc < dp[tx][ty][td]){\n\t\t\t\t\tdp[tx][ty][td] = t.cost+tc;\n\t\t\t\t\tS.push(State(dp[tx][ty][td], tx, ty, td));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (map[t.x][t.y]=='T'?dp[t.x][t.y][t.d]:-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// (foot,(x,y)) : foot = 0 なら左足, foot = 1 なら右足\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<int,Node> State;\n\nconst int MAX_H = 61;\nconst int MAX_W = 31;\nconst int INF = 1e+8;\n\n// 入力\nint w, h;\nchar s[MAX_H][MAX_W];\n\n// スタートとゴールの位置\nvector<P> vs, vg;\n\nint dx[2][9] = {\n\t{ 1, 1, 1, 1, 1, 2, 2, 2, 3},\n\t{-1,-1,-1,-1,-1,-2,-2,-2,-3}\n};\nint dy[2][9] = {\n\t{-2,-1,0,1,2,-1,0,1,0},\n\t{-2,-1,0,1,2,-1,0,1,0}\n};\n\n// 初期化\nvoid init(){\n\tvs.clear();\n\tvg.clear();\n}\n\n// d[foot][y][x] := 最小コスト\nint d[2][MAX_H][MAX_W];\n\n// 足がゴールについたかどうか (最小コストの更新も行う)\nbool goal(int& ans, int cost, int x, int y){\n\tfor(int i=0 ; i < vg.size() ; i++ ){\n\t\tint gx = vg[i].first;\n\t\tint gy = vg[i].second;\n\t\tif( x == gx && y == gy ){\n\t\t\tans = min( ans , cost );\n\t\t\treturn true;\n\t\t}\t\n\t}\n}\n\n// sp : 始点, foot : 足, (foot = 0 なら左足, foot = 1 なら右足)\nint solve(P sp,int foot_){\n\t// 初期化\n\tfor(int y=0 ; y < MAX_H ; y++ ){\n\t\tfor(int x=0 ; x < MAX_W ; x++ ){\n\t\t\td[0][y][x] = INF;\n\t\t\td[1][y][x] = INF;\n\t\t}\n\t}\n\tint sx = sp.first;\n\tint sy = sp.second;\n\tNode start( foot_ , sp );\n\td[foot_][sy][sx] = 0;\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tq.push( State(0,start) );\n\t\n\tint ans = INF;\n\twhile( !q.empty() ){\n\t\t// 値を取り出す\n\t\tint now_cost = q.top().first;\n\t\tint foot = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\t// 片足がゴールについていたら\n\t\t//if( goal( ans , now_cost , x , y ) ){\n\t\t//\tcontinue;\n\t\t//}\n\t\t\n\t\t// もう片方の足の移動\n\t\tfor(int i=0 ; i < 9 ; i++ ){\n\t\t\tint mx = x + dx[foot][i];\n\t\t\tint my = y + dy[foot][i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\t\n\t\t\t// 足がゴールについたとき\n\t\t\tif( s[my][mx] == 'T' ){\n\t\t\t\tans = min( ans , now_cost );\n\t\t\t\tbreak;\n\t\t\t}else if( s[my][mx] >= '0' && s[my][mx] <= '9' ){ // ブロックのとき\n\t\t\t\tint cost = s[my][mx] - '0';\n\t\t\t\t// より小さいコストだったら\n\t\t\t\tif( now_cost + cost < d[foot][my][mx] ){\n\t\t\t\t\td[foot][my][mx] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tint foot_next;\n\t\t\t\t\tfoot_next = (foot == 0)? 1 : 0 ;\n\t\t\t\t\tNode next( foot_next , P(mx,my) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\t// 入力\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'S' ){\n\t\t\t\t\tvs.push_back( P(x,y) );\n\t\t\t\t}else if( s[y][x] == 'T' ){\n\t\t\t\t\tvg.push_back( P(x,y) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// スタート地点から探索\n\t\tint ans = INF;\n\t\tfor(int i=0 ; i < vs.size() ; i++ ){\n\t\t\tint result = solve( vs[i] , 0 );\n\t\t\tans = min( ans , result );\n\t\t\tresult = solve( vs[i] , 1 );\n\t\t\tans = min( ans , result );\n\t\t}\n\t\t\n\t\t// 辿りつけないとき\n\t\tif( ans == INF )\n\t\t\tans = -1;\n\t\t\n\t\t// 出力\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint main() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\tvector<pair<int, int>> ending;\n\t\tlong long cost[60][30] = {};\n\t\tlong long dp[2][60][30] = {};\n\t\tint visited[2][60][30] = {};\n\t\tREP(i, 2) {\n\t\t\tREP(q, 60) {\n\t\t\t\tREP(j, 30) {\n\t\t\t\t\tdp[i][q][j] = LONG_INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<tuple<int, int, int, int>> next;\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tstring s;\n\t\t\t\tcin >> s;\n\t\t\t\tif (s == \"S\") {\n\t\t\t\t\tREP(j, 2) {\n\t\t\t\t\t\tdp[j][i][q] = 0;\n\t\t\t\t\t\tnext.push(make_tuple(-0, j, i, q));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s == \"T\") {\n\t\t\t\t\tending.push_back(make_pair(i, q));\n\t\t\t\t}\n\t\t\t\telse if (s == \"X\") {\n\t\t\t\t\tcost[i][q] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcost[i][q] = s[0] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint xe[9] = { 2,1,0,-1,-2,1,0,-1,0 };\n\t\tint ye[9] = { 1,1,1,1,1,2,2,2,3 };\n\t\twhile (next.empty() == false) {\n\t\t\ttuple<int, int, int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tint now_here_x = get<2>(now);\n\t\t\tint now_here_y = get<3>(now);\n\t\t\tint asi = get<1>(now)+1;\n\t\t\tasi %= 2;\n\t\t\tif (visited[(asi+1)%2][now_here_x][now_here_y] == 0) {\n\t\t\t\tvisited[(asi+1)%2][now_here_x][now_here_y] = 1;\n\t\t\t\tREP(q, 9) {\n\t\t\t\t\tint now_x = now_here_x + xe[q];\n\t\t\t\t\tint now_y = now_here_y;\n\t\t\t\t\tif (asi == 0) {\n\t\t\t\t\t\tnow_y -= ye[q];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnow_y += ye[q];\n\t\t\t\t\t}\n\t\t\t\t\tif (now_x >= 0 && now_x < h && now_y >= 0 && now_y < w) {\n\t\t\t\t\t\tif (cost[now_x][now_y] != -1) {\n\t\t\t\t\t\t\tint next_cost = dp[(asi + 1) % 2][now_here_x][now_here_y] + cost[now_x][now_y];\n\t\t\t\t\t\t\tif (dp[asi][now_x][now_y] > next_cost) {\n\t\t\t\t\t\t\t\tdp[asi][now_x][now_y] = next_cost;\n\t\t\t\t\t\t\t\tnext.push(make_tuple(-next_cost, asi, now_x, now_y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans = LONG_INF;\n\t\tREP(i, ending.size()) {\n\t\t\tans = min(ans, dp[0][ending[i].first][ending[i].second]);\n\t\t\tans = min(ans, dp[1][ending[i].first][ending[i].second]);\n\t\t}\n\t\tif (ans == LONG_INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9 + 10;\nint w, h;\n\nstruct pos {\n  int x;\n  int y;\n  bool is_out() { return x < 1 || w < x || y < 1 || h < y; }\n};\nstruct node {\n  pos loc;\n  int time;\n  int step;\n  void print() {\n    cout << loc.x << ' ' << loc.y << ' ' << time << ' ' << step << endl;\n  }\n};\n\nbool operator<(const pair<int, pos> &p1, const pair<int, pos> &p2) {\n  if (p1.first != p2.first) {\n    return p1.first < p2.first;\n  } else {\n    if (p1.second.x == p2.second.x) {\n      return p1.second.y < p2.second.y;\n    } else {\n      return p1.second.x < p2.second.x;\n    }\n  }\n}\nbool operator<(const pos &pos1, const pos &pos2) {\n  if (pos1.x == pos2.x) {\n    return pos1.y < pos2.y;\n  } else {\n    return pos1.x < pos2.x;\n  }\n}\n\nbool operator>(const node &node1, const node &node2) {\n  return node1.time > node2.time;\n};\n\nint main() {\n  while (cin >> w >> h) {\n    if (!w && !h) {\n      break;\n    }\n    vector<int> starts;\n    vector<int> goals;\n    map<pos, int> W;\n    //壁の情報を得る\n    for (int y = h; y > 0; y--) {\n      for (int x = 1; x <= w; x++) {\n        char s;\n        cin >> s;\n        if (s == 'S') {\n          starts.push_back(x);\n          W[{x, y}] = 0;\n        } else if (s == 'T') {\n          goals.push_back(x);\n          W[{x, y}] = 0;\n        } else if (s == 'X') {\n          W[{x, y}] = INF;\n        } else {\n          W[{x, y}] = s - '0';\n        }\n      }\n    }\n\n    //それぞれの地点から行ける場所をdestsに入れる\n    // step->left:1, right:-1\n    // <step, from> : <to, time>\n    map<pair<int, pos>, vector<pair<pos, int>>> dests;\n    for (int y = 1; y <= h; y++) {\n      for (int x = 1; x <= w; x++) {\n        if (W[{x, y}] != INF) {\n          for (int step : {1, -1}) {\n            for (int offset_x = 1; offset_x <= 3; offset_x++) {\n              for (int offset_y = offset_x - 3; offset_y <= 3 - offset_x;\n                   offset_y++) {\n                pos next_pos = {x + step * offset_x, y + offset_y};\n                if (!next_pos.is_out() && W[next_pos] != INF) {\n                  dests[{step, {x, y}}].push_back({next_pos, W[next_pos]});\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    priority_queue<node, vector<node>, greater<node>> pQ;\n    // <pos, step> : time\n    map<pair<pos, int>, int> tmp;\n    map<pair<pos, int>, int> T;\n    for (int s : starts) {\n      for (int step : {1, -1}) {\n        for (int i = 1; i <= w; i++) {\n          for (int j = 1; j <= h; j++) {\n            tmp[{{i, j}, step}] = INF;\n            T[{{i, j}, step}] = INF;\n          }\n        }\n        pQ.push({{s, 1}, 0, step});\n        tmp[{{s, 1}, step}] = 0;\n      }\n    }\n    // ダイクストラ法\n    while (!pQ.empty()) {\n      node smallest = pQ.top();\n      pQ.pop();\n      if (T[{smallest.loc, smallest.step}] == INF) {\n        T[{smallest.loc, smallest.step}] = smallest.time;\n        for (pair<pos, int> dest : dests[{smallest.step, smallest.loc}]) {\n          if (tmp[{dest.first, smallest.step}] > smallest.time + dest.second) {\n            tmp[{dest.first, smallest.step}] = smallest.time + dest.second;\n            pQ.push({dest.first, tmp[{dest.first, smallest.step}],\n                     smallest.step * -1});\n          }\n        }\n      }\n    }\n    for (int g : goals) {\n      ans = min(ans, T[{{g, h}, 1}]);\n      ans = min(ans, T[{{g, h}, -1}]);\n    }\n\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n}\n\n/*\n問題:Cliff\nClimbing(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150)\n所要時間：120m\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][60], buf[2];\nint d[60][60][60][60][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define MAX 3600\n\n\n#define TEST 0\n\nint edges[MAX][MAX];\nint edges_ind[MAX*20][2];\n//vector<pair<int,int> > edges_ind;\nchar dat[MAX];\nint w,h;\nint cnt;//|E|\n\nint shortest(int start)\n{\n    int d[MAX];\n    fill_n(d,2*w*h,-1);\n    d[start]=0;\n    for(int time=0;time<2*w*h-1;++time)\n    {\n        for(int i=0;i<cnt;i++)\n        {\n            int v0=edges_ind[i][0];\n            int v1=edges_ind[i][1];\n            if(d[v0]>=0)\n            {\n                if(d[v1]==-1)\n                {\n                    d[v1]=d[v0]+edges[v0][v1];\n                }\n                else{\n                    d[v1]=min(d[v1],d[v0]+edges[v0][v1]);\n                }\n            }\n        }\n    }\n    int minv=0x3fffffff;\n    for(int i=0;i<2*w*h;i++)\n    {\n        if(dat[i]=='T' && d[i]>=0)\n            minv=min(minv,d[i]);\n    }\n    return minv;\n}\n\nint main(void)\n{\n    while(scanf(\"%d%d\",&w,&h)==2 &&(w||h))\n    {\n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {   \n                int ch;\n                while((ch=getchar())<=' '){}\n                dat[i*w+j]=ch;\n            }\n        }\n        if(TEST&&0)\n        {\n            for(int i=0;i<w*h;i++)\n            {\n                printf(\"%c \",dat[i]);\n            }\n        }\n        for(int i=0;i<2*w*h;i++)\n        {\n            fill(edges[i],edges[i]+2*w*h,-1);\n        }\n        cnt=0;\n        //left->right\n        for(int x=0;x<w;x++)\n        {\n            for(int y=0;y<h;y++)\n            {\n                for(int p=0;p<3&&x+p+1<w;p++)\n                {\n                    for(int t=max(y-2+p,0);t<=y+2-p&&t<h;t++)\n                    {\n                        int dest=w*h+t*w+x+p+1;\n                        char ch=dat[dest-w*h];\n                        if(ch>='0'&&ch<='9')\n                        {\n                            edges[y*w+x][dest]=ch-'0';\n                            edges_ind[cnt][0]=y*w+x;\n                            edges_ind[cnt][1]=dest;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n        //right->left\n        for(int x=0;x<w;x++)\n        {\n            for(int y=0;y<h;y++)\n            {\n                for(int p=0;p<3&&x-p-1>=0;p++)\n                {\n                    for(int t=max(y-2+p,0);t<=y+2-p&&t<h;t++)\n                    {\n                        int dest=t*w+x-p-1;\n                        char ch=dat[dest];\n                        if(ch>='0'&&ch<='9')\n                        {\n                            edges[w*h+y*w+x][dest]=ch-'0';\n                            edges_ind[cnt][0]=w*h+y*w+x;\n                            edges_ind[cnt][1]=dest;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n        if(TEST)\n        {\n            for(int i=0;i<cnt;i++)\n            {\n                printf(\"%d-%d\\n\",edges_ind[i][0],edges_ind[i][1]);\n            }\n        }\n        int minv=0x3fffffff;\n        for(int i=0;i<w*h;i++)\n        {\n            if(dat[i]=='S')\n            {\n                minv=min(minv,shortest(i));\n                minv=min(minv,shortest(w*h+i));\n            }\n        }\n        printf(\"%d\\n\",minv==0x3fffffff?-1:minv);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f;\n\t\t\t\t\tf.ly = f.ry = i;\n\t\t\t\t\tf.lx = f.rx = j;\n\t\t\t\t\tf.p = 0;\n\t\t\t\t\tf.cnt = 0;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\tif(field[temp.ry][temp.rx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\tif(field[temp.ly][temp.lx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_W 30\n#define MAX_H 60\n\n#define INF INT_MAX\n\nint w, h;\nchar field[MAX_H][MAX_W];\n\nint d[MAX_H][MAX_W][2];\n\nconst int dx[] = {1,   1, 1, 1, 1,  2, 2, 2, 3};\nconst int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nstruct P {\n    int x, y;\n    int foot;\n    int cost;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_W * MAX_H, 0);\n        vector<pii> start, goal;\n        REP(y, h) REP(x, w) {\n            cin >> field[y][x];\n            if (field[y][x] == 'S') {\n                start.push_back(make_pair(x, y));\n            }\n            if (field[y][x] == 'T') {\n                goal.push_back(make_pair(x, y));\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P> > que;\n\n        fill_n((int *)d, MAX_W * MAX_H * 2, INF);\n        REP(i, start.size()) {\n            int x = start[i].first;\n            int y = start[i].second;\n            d[y][x][0] = 0;\n            d[y][x][1] = 0;\n            que.push((P){x, y, -1, 0});\n            que.push((P){x, y, 1, 0});\n        }\n\n        bool ok = false;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            REP(i, goal.size()) {\n                int gx = goal[i].first;\n                int gy = goal[i].second;\n                if (p.x == gx && p.y == gy) {\n                    cout << p.cost << endl;\n                    ok = true;\n                    break;\n                }\n            }\n            if (ok) break;\n\n\n            int footi = (p.foot + 1) / 2;\n            if (d[p.y][p.x][footi] < p.cost) continue;\n            REP(i, 9) {\n                int sx = p.x + dx[i] * p.foot;\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    if (field[sy][sx] == 'T') {\n                        que.push((P){sx, sy, 0, p.cost});\n                    } else if ('0' <= field[sy][sx] && field[sy][sx] <= '9') {\n                        int time = field[sy][sx] - '0';\n                        if (d[sy][sx][1-footi] > p.cost + time) {\n                            d[sy][sx][1-footi] = p.cost + time;\n                            que.push((P){sx, sy, p.foot * -1, p.cost + time});\n                        }\n                    }\n                }\n            }\n        }\n        if (!ok) {\n            cout << \"-1\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, step;\n    int feet;\n\n    bool operator >(const P& p) const {\n        return step > p.step;\n    }\n};\n\nconst int dx[] = {1,1,1,1,1,2,2,2,3}; const int dy[] = {2,1,0,-1,-2,1,0,-1,0};\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1e8\n\nconst char START = 'S';\nconst char GOAL = 'T';\nconst char WALL = 'X';\n\nchar field[MAX_H][MAX_W];\nint G[MAX_H][MAX_W][2];\n\nint w, h;\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_H*MAX_W, WALL);\n        fill_n((int *)G, MAX_H*MAX_W*2, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> field[y][x];\n                if ('0' <= field[y][x] && field[y][x] <= '9') {\n                    field[y][x] -= '0';\n                }\n                if (field[y][x] == START) {\n                    field[y][x] = 0;\n                    que.push({x, y, 0, 1});\n                    que.push({x, y, 0, -1});\n                }\n            }\n        }\n\n        int step = -1;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            if (field[p.y][p.x] == GOAL) {\n                step = p.step;\n                break;\n            }\n\n            REP(i, 9) {\n                int sx = p.x + dx[i] * p.feet, sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    switch (field[sy][sx]) {\n                    case WALL:\n                        break;\n                    case GOAL:\n                        que.push({sx, sy, p.step, -p.feet});\n                        break;\n                    default:\n                        int f = p.feet > 0 ? 0 : 1;\n                        int s = p.step + field[sy][sx];\n                        if (G[sx][sy][f] > s) {\n                            G[sx][sy][f] = s;\n                            que.push({sx, sy, s, -p.feet});\n                        }\n                    }\n                }\n            }\n        }\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\n//const int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h; // 2<=w<=30,5<=h<=60\nusing P = pair<pair<int,int>,pair<int,int>>;        // time,turn,x,y\npii dy[2];\n\n\ninline P make(int i,int j,int k,int l){\n    return make_pair(make_pair(i,j),make_pair(k,l));\n}\n\nbool ok(int x,int y){\n    if(x<0 or x>=h or y<0 or y>=w) return false;\n    else return true;\n}\n\nint dist(int x1,int y1,int x2,int y2){\n    return abs(x1-x2)+abs(y1-y2);\n}\n\n\nvoid solve(){\n    vector<vector<char>> table(h,vector<char>(w));\n    rep(i,h) rep(j,w) cin>>table[i][j];\n    vector<pii> s,g;\n    rep(i,h) rep(j,w){\n        if(table[i][j]=='S'){\n            s.push_back(pii(i,j));\n        }\n        if(table[i][j]=='T'){\n            g.push_back(pii(i,j));\n        }\n    }\n    vector<vector<vector<bool>>> use(2,vector<vector<bool>>(h,vector<bool>(w,true)));\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    for(pii p : s){\n        que.push(make(0,0,p.first,p.second));\n        que.push(make(0,1,p.first,p.second));\n    }\n\n\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        int time = p.first.first;\n        int turn = p.first.second;\n        pii point = p.second;\n        int x = point.first;\n        int y = point.second;\n\n        if(table[x][y]=='T'){\n            cout << time << endl;\n            return;\n        }\n\n        if(!use[turn][x][y]) continue;\n        use[turn][x][y]=false;\n\n //       cout << \"pop : \" << time << \" \" << turn << \" \" << x << \" \" << y << endl;\n\n\n        for(int i=-3;i<=3;i++){\n            for(int j=dy[turn].first;j<dy[turn].second;j++){\n                int nx=x+i;\n                int ny=y+j;\n                if(!ok(nx,ny)) continue;\n                if(dist(x,y,nx,ny)>3 or !use[(turn+1)%2][nx][ny]) continue;\n                if(table[nx][ny]=='X') continue;\n                int ntime = time + table[nx][ny] - (table[nx][ny]=='T' ? 'T' : '0');\n//                cout << \"\\tpush : \" << ntime << \" \" << (turn+1)%2 << \" \" << nx << \" \" << ny << endl;\n                que.push(make(ntime,(turn+1)%2,nx,ny));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n}\n\nint main(){\n    dy[0] = make_pair(1,4);\n    dy[1] = make_pair(-3,0);\n    while(cin>>w>>h){\n        if(w==0&&h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nvector<pi> F;\n\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      F.clear();\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\" %c\",&S[i][j]);\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  F.pb(pi(i,j));\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t}\n\t      //printf(\"%c\", S[i][j]);\n\t    }\n\t  //printf(\"\\n\");\n\t}\n      queue<pi> Q;\n      queue<bool> R;\n      rep(i,F.size())\n\t{\n\t  Q.push(F[i]);\n\t  Q.push(F[i]);\n\t  R.push(0);\n\t  R.push(1);\n\t}\n\n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<map>\n#define INF 1000000000\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<bool,P> iP;\ntypedef pair<int,iP> iPi;\nint w,h;\nint dx[]={1,1,1,1,1,2,2,2,3,-1,-1,-1,-1,-1,-2,-2,-2,-3},dy[]={-2,-1,0,1,2,-1,0,1,0,-2,-1,0,1,2,-1,0,1,0};\nint d[62][32][2];\nmap<P,bool> mp;\n//(i,(b,((i,i),(i,i))))\nbool inf(P a){\n\tif(a.second>=0&&a.second<w&&a.first>=0&&a.first<h)\n\t\treturn true;\n\treturn false;\n}\n\nint dij(vector<vector<int> > f,vector<P> v){\n\tpriority_queue<iPi,vector<iPi> , greater<iPi> > que;\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\tfor(int z=0;z<2;z++)\n\t\td[i][j][z]=INF;\n\tfor(int i=0;i<v.size();i++){\n\t\tque.push(iPi(0,iP(false,v[i])));\n\t\tque.push(iPi(0,iP(true,v[i])));\n\t\td[v[i].first][v[i].second][0]=0;\n\t\td[v[i].first][v[i].second][1]=0;\n\t}\n\t\n\twhile(!que.empty()){\n\t\tiPi p=que.top();\n\t\tP pos=p.second.second;\n\t\tbool which=p.second.first;\n\t\tint nc=p.first;\n\t\tque.pop();\n\t\tif(d[pos.first][pos.second][which]<nc){\n\t\t\tcontinue;\n\t\t}\n\t\tif(mp[pos]){\n\t\t\treturn nc;\n\t\t}\n\t\td[pos.first][pos.second][which]=nc;\n\t\tif(which)\n\t\tfor(int i=0;i<9;i++){\n\t\t\tint ny=pos.first+dy[i],nx=pos.second+dx[i];\n\t\t\tif(inf(P(ny,nx))&&d[ny][nx][which^1]>nc+f[ny][nx]){\n\t\t\t\tque.push(iPi(nc+f[ny][nx],iP(which^1,P(ny,nx))));\n\t\t\t}\n\t\t}\n\t\telse\n\t\tfor(int i=9;i<18;i++){\n\t\t\tint ny=pos.first+dy[i],nx=pos.second+dx[i];\n\t\t\tif(inf(P(ny,nx))&&d[ny][nx][which^1]>nc+f[ny][nx]){\n\t\t\t\tque.push(iPi(nc+f[ny][nx],iP(which^1,P(ny,nx))));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tvector<vector<int> > f(h,vector<int>(w));\n\t\tvector<P> v(2);\n\t\tmp.clear();\n\t\tv.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;//f[i][j];\n\t\t\t\tif(c=='S'){\n\t\t\t\t\tv.pb(P(i,j));\n\t\t\t\t\tf[i][j]=0;\n\t\t\t\t}else if(c=='T'){\n\t\t\t\t\tmp[P(i,j)]=true;\n\t\t\t\t\tf[i][j]=0;\n\t\t\t\t}else if(c=='X'){\n\t\t\t\t\tf[i][j]=INF;\n\t\t\t\t}else{\n\t\t\t\t\tf[i][j]=c-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(all(v));\n\t\tcout<<dij(f,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  vector<P2> G[2][100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,1,2,-1,0,1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tG[0][i][j].clear();\n\tG[1][i][j].clear();\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(grid[i][j] == 'T')\n\t  ans = min(ans,min(d[0][i][j],d[1][i][j]));\n    if(ans ==INF)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vc = std::vector<char>;\n\tusing vvc = std::vector<vc>;\n\n\tusing i3 = std::array<int, 3>;\n\tusing i4 = std::array<int, 4>;\n\n\tint W, H;\n\tint calcNum(const i3 &arr)\n\t{\n\t\treturn (arr[0] * W + arr[1]) * 2 + arr[2];\n\t}\n\tbool isIn(const i4 &arr)\n\t{\n\t\treturn 0 <= arr[1] && arr[1] < H && 0 <= arr[2] && arr[2] < W;\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (W == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\n\t\tvvc cliff(H, vc(W));\n\t\tfor (int i{}; i < H; i++)\n\t\t\tfor (int j{}; j < W; j++)\n\t\t\t\tscanf(\" %c\", &cliff[i][j]);\n\t\t\n\t\tstd::vector<int> distance(H * W * 2, 1 << 30);\n\t\tstd::priority_queue<i4, std::vector<i4>, std::greater<i4>> dij;\n\t\tfor (int i{}; i < W; i++)\n\t\t\tif (cliff[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tdistance[calcNum({H - 1, i, 0})] = distance[calcNum({H - 1, i, 1})] = 0;\n\t\t\t\tdij.push({0, H - 1, i, 0});\n\t\t\t\tdij.push({0, H - 1, i, 1});\n\t\t\t}\n\t\t\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\ti4 now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now[0] > distance[calcNum({now[1], now[2], now[3]})])\n\t\t\t\tcontinue;\n\t\t\tif (cliff[now[1]][now[2]] == 'T') break;\n\t\t\tfor (int h_i{-2}; h_i <= 2; h_i++)\n\t\t\t\tfor (int w_i{1}; w_i + std::abs(h_i) <= 3; w_i++)\n\t\t\t\t{\n\t\t\t\t\ti4 next{now};\n\t\t\t\t\tnext[1] += h_i;\n\t\t\t\t\tif (next[3])\n\t\t\t\t\t\tnext[2] += w_i;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext[2] -= w_i;\n\t\t\t\t\tif (!isIn(next)) continue;\n\t\t\t\t\tif (cliff[next[1]][next[2]] == 'X' || cliff[next[1]][next[2]] == 'S') continue;\n\t\t\t\t\tif (cliff[next[1]][next[2]] != 'T')\n\t\t\t\t\t\tnext[0] += cliff[next[1]][next[2]] - '0';\n\t\t\t\t\tnext[3] ^= 1;\n\t\t\t\t\tint id{calcNum({next[1], next[2], next[3]})};\n\t\t\t\t\tif (next[0] >= distance[id]) continue;\n\t\t\t\t\tdistance[id] = next[0];\n\t\t\t\t\tdij.push(next);\n\t\t\t\t}\n\t\t}\n\t\tint min{1 << 30};\n\t\tfor (int i{}; i < W; i++)\n\t\t\tif (cliff[0][i] == 'T')\n\t\t\t\tmin = std::min({min, distance[calcNum({0, i, 0})], distance[calcNum({0, i, 1})]});\n\t\tif (min == (1 << 30)) puts(\"-1\");\n\t\telse printf(\"%d\\n\", min);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int dy[16] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\nconst int dx[16] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\n\nmap<char, vvi> cost;\n\nchar m[31][61];\nint w, h;\n\nstruct Data{\n    char ft;\n    int y, x;\n};\n\nvoid dfs(Data s){\n\n    queue<Data> q;\n    q.push(s);\n\n    while(not q.empty()){\n        // cout << endl;\n        // rep(i,h){ rep(j,w){ cout << cost['R'][i][j] << ' ' ; } cout << endl; }\n        // cout << endl;\n        // rep(i,h){ rep(j,w){ cout << cost['L'][i][j] << ' ' ; } cout << endl; }\n        // cout << endl;\n        struct Data u = q.front(); q.pop();\n        char nft = (u.ft == 'L' ? 'R' : 'L');\n        rep(i,9){\n            int ny = u.y + dy[i];\n            int nx = u.x + dx[i] * (nft == 'R' ? 1 : -1);\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n            if(m[ny][nx] == 'X' || m[ny][nx] == 'S') continue;\n            if(m[ny][nx] == 'T'){\n                //show(cost[u.ft][u.y][u.x])\n                cost[nft][ny][nx] = min(cost[nft][ny][nx], cost[u.ft][u.y][u.x]);\n                continue;\n            }\n            if(cost[u.ft][u.y][u.x] + (m[ny][nx] - '0') < cost[nft][ny][nx]){\n                cost[nft][ny][nx] = cost[u.ft][u.y][u.x] + (m[ny][nx] - '0');\n                q.push(Data{nft,ny,nx});\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        cost['R'] = vvi(31, vi(61,INF));\n        cost['L'] = vvi(31, vi(61,INF));\n\n        rep(i,h) rep(j,w) cin >> m[i][j];\n\n        rep(i,w) if(m[h - 1][i] == 'S'){\n            cost['R'][h - 1][i] = 0;\n            dfs(Data{'R', h - 1, i});\n            cost['L'][h - 1][i] = 0;\n            dfs(Data{'L', h - 1, i});\n        }\n\n        int mini = INF;\n        rep(i,w){\n            int tmp = INF;\n            if(m[0][i] == 'T') tmp = min(cost['R'][0][i], cost['L'][0][i]);\n            mini = min(mini, tmp);\n        }\n        cout << (mini == INF ? -1 : mini) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  while (1){\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0){\n      break;\n    }\n    vector<vector<char>> s(h, vector<char>(w));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> s[i][j];\n      }\n    }\n    map<int, vector<pair<int, int>>> E;\n    int M = h * w * h * w * 2;\n    for (int ly = 0; ly < h; ly++){\n      for (int lx = 0; lx < w; lx++){\n        for (int ry = 0; ry < h; ry++){\n          for (int rx = 0; rx < w; rx++){\n            if (lx < rx && abs(lx - rx) + abs(ly - ry) <= 3){\n              if (s[ly][lx] != 'X' && s[ry][rx] != 'X'){\n                int ul = ((ly * w + lx) * h * w + (ry * w + rx)) * 2;\n                for (int rx2 = lx + 1; rx2 <= lx + 3; rx2++){\n                  for (int ry2 = ly - (3 - (rx2 - lx)); ry2 <= ly + (3 - (rx2 - lx)); ry2++){\n                    if (0 <= rx2 && rx2 < w && 0 <= ry2 && ry2 < h){\n                      if (s[ry2][rx2] != 'X'){\n                        int v = ((ly * w + lx) * h * w + (ry2 * w + rx2)) * 2 + 1;\n                        int c;\n                        if (s[ry2][rx2] == 'S' || s[ry2][rx2] == 'T'){\n                          c = 0;\n                        } else {\n                          c = s[ry2][rx2] - '0';\n                        }\n                        E[ul].push_back(make_pair(c, v));\n                      }\n                    }\n                  }\n                }\n                int ur = ((ly * w + lx) * h * w + (ry * w + rx)) * 2 + 1;\n                for (int lx2 = rx - 3; lx2 <= rx - 1; lx2++){\n                  for (int ly2 = ry - (3 - (rx - lx2)); ly2 <= ry + (3 - (rx - lx2)); ly2++){\n                    if (0 <= lx2 && lx2 < w && 0 <= ly2 && ly2 < h){\n                      if (s[ly2][lx2] != 'X'){\n                        int v = ((ly2 * w + lx2) * h * w + (ry * w + rx)) * 2;\n                        int c;\n                        if (s[ly2][lx2] == 'S' || s[ly2][lx2] == 'T'){\n                          c = 0;\n                        } else {\n                          c = s[ly2][lx2] - '0';\n                        }\n                        E[ur].push_back(make_pair(c, v));\n                      }\n                    }\n                  }\n                }\n                if (s[ly][lx] == 'S'){\n                  int c;\n                  if (s[ry][rx] == 'S' || s[ry][rx] == 'T'){\n                    c = 0;\n                  } else {\n                    c = s[ry][rx] - '0';\n                  }\n                  E[M].push_back(make_pair(c, ur));\n                }\n                if (s[ry][rx] == 'S'){\n                  int c;\n                  if (s[ly][lx] == 'S' || s[ly][lx] == 'T'){\n                    c = 0;\n                  } else {\n                    c = s[ly][lx] - '0';\n                  }\n                  E[M].push_back(make_pair(c, ul));\n                }\n                if (s[ly][lx] == 'T'){\n                  E[ul].push_back(make_pair(0, M + 1));\n                }\n                if (s[ry][rx] == 'T'){\n                  E[ur].push_back(make_pair(0, M + 1));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push(make_pair(0, M));\n    map<int, int> d;\n    while (!pq.empty()){\n      int c = pq.top().first;\n      int v = pq.top().second;\n      pq.pop();\n      if (!d.count(v)){\n        d[v] = c;\n        for (auto P : E[v]){\n          int w = P.second;\n          pq.push(make_pair(c + P.first, w));\n        }\n      }\n    }\n    if (!d.count(M + 1)){\n      cout << -1 << endl;\n    } else {\n      cout << d[M + 1] << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define INF 100000009\n#define N 20005\nusing namespace std;\n\ntypedef pair<int,int> PI;//cost to;\n\nint map[65][35];\nint w,h;\n\nbool checkin(int i,int j){\n    if(i>=0&&j>=0&&i<h&&j<w&&map[i][j]!=INF){\n        return true;\n    }else{\n        return false;\n    }\n}\nint retc(int i,int j){\n    if(map[i][j]==-1){\n        return 0;\n    }else{\n        return map[i][j];\n    }\n}\n\nint make(int foot,int state,int i,int j){\n    return foot*w*h*9+state*w*h+i*w+j;\n}\n\nint main(){\n    int cango[9][2];//where right is from left,yx\n    int hoge = 0;\n    for(int y = 0;y<=2;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    for(int y = -2;y<=-1;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    while(1){\n        vector<PI> G[3600*9+5];//0???????¶? 1???????¶? to,cost\n        int dist[3600*9+5];\n        bool goal[3600*9+5];\n        rep(i,3600*9+5){\n            dist[i]=INF;\n            goal[i]=0;\n        }\n        cin>>w>>h;\n        if(w==0){\n            return 0;\n        }\n        char c;\n        rep(i,h){\n            rep(j,w){\n                cin>>c;\n                if(c=='S')        map[i][j]=0;\n                else if(c=='T')   map[i][j]=-1;\n                else if(c=='X')   map[i][j]=INF;\n                else map[i][j]=c-'0';\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(!checkin(i,j))continue;\n                rep(state1,9){\n                    int y=i+cango[state1][0],x=j+cango[state1][1];\n                    if(!checkin(y,x))continue;\n                    if(map[i][j]==-1||map[y][x]==-1){\n                        goal[make(0,state1,i,j)]=true;\n                        goal[make(1,state1,i,j)]=true;\n                    }\n                    rep(state2,9){\n                        if(state1==state2)\n                            continue;\n                        int ny=i+cango[state2][0],nx=j+cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(0,state1,i,j)].pb(mp(make(1,state2,i,j),retc(ny,nx)));\n                        }\n                        ny=y-cango[state2][0],nx=x-cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(1,state1,i,j)].pb(mp(make(0,state2,ny,nx),retc(ny,nx)));\n                        }\n                        \n                    }\n                }\n            }\n        }\n        //        rep(i,3600*9+5){\n        //            if(!G[i].empty()){\n        //                rep(j,G[i].size()){\n        //                    cout<<\"from:\"<< \" foot:\" <<i/(w*h*9) <<\" state:\"<<i/w/h%9<<\" i j:(\"<< i/w%h<< \" \"<<i%w<< \")\"<<endl;\n        //\n        //                    cout<<\"to  :\"<< \" foot:\" <<G[i][j].first/(w*h*9) <<\" state:\"<<G[i][j].first/w/h%9<<\" i j:(\"<< G[i][j].first/w%h<< \" \"<<G[i][j].first%w <<\") cost:\"<<G[i][j].second<<endl<<endl;\n        //                }\n        //            }\n        //        }\n        priority_queue<PI, vector<PI> ,greater<PI> > pq;\n        rep(j,w){\n            if(map[h-1][j]!=0){continue;}\n            rep(st,9){\n                int y = h-1+cango[st][0],x = j+cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(1,st,h-1,j))));}\n                y = h-1-cango[st][0],x = j-cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(0,st,y,x))));}\n            }\n        }\n        int ans = -1;\n        while(!pq.empty()){\n            PI now = pq.top();\n            int cost = now.first;\n            int from = now.second;\n            pq.pop();\n            if(dist[from]<cost){\n                continue;\n            }\n            dist[from]=cost;\n            if(goal[from]){\n                if(ans==-1){\n                    ans = cost;\n                }\n                ans = min(ans,cost);\n            }\n            rep(i,G[from].size()){\n                if(dist[G[from][i].first]>cost+G[from][i].second)\n                    pq.push(mp(G[from][i].second+cost,G[from][i].first));\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint w, h;\nvoid update(st p, priority_queue<st>&que) {\n\tfor (int k = -2; k <= 2; k++) {\n\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\tif (p.b) {\n\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tupdate({ i,j,0,0,0,1 }, que); update({ 0,0,i,j,0,0 }, que);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tupdate(p, que);\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\n\nint main() {\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(!w)break;\n    int n = w*h;\n    Graph g(n*2);\n    vector<vector<string>> t(h,vector<string>(w));\n    REP(i,h){\n      REP(j,w){\n        cin>>t[i][j];\n      }\n    }\n    set<int> s_set,t_set;\n    REP(i,h){\n      REP(j,w){\n        if (t[i][j] == \"S\") {\n          s_set.insert(i*w+j);\n          s_set.insert(n+i*w+j);\n        } else if (t[i][j] == \"T\") {\n          t_set.insert(i*w+j);\n          t_set.insert(n+i*w+j);\n        }\n        int p = i*w+j;\n        for(int k=-2;k<=2;++k)REP(l,3){\n          if(abs(k)+l>=3) continue;\n          int nir = i+k;\n          int njr = j+1+l;\n          int nil = i+k;\n          int njl = j-1-l;\n          if (nir >= 0 && nir < h && njr >= 0 && njr < w) {\n            if (t[nir][njr] == \"S\" || t[nir][njr] == \"T\")\n              g[p].push_back({p, n+nir*w+njr, 0});\n            else if (t[nir][njr] != \"X\")\n              g[p].push_back({p, n+nir*w+njr, t[nir][njr][0] - '0'});\n          }\n          if (nil >= 0 && nil < h && njl >= 0 && njl < w) {\n            if (t[nil][njl] == \"S\" || t[nil][njl] == \"T\")\n              g[n+p].push_back({n+p, nil*w+njl, 0});\n            else if (t[nil][njl] != \"X\")\n              g[n+p].push_back({n+p, nil*w+njl, t[nil][njl][0] - '0'});\n          }\n        }\n      }\n    }\n    int mind = INF;\n    for (int i:s_set) {\n      Array a(n*2, INF);\n      dijkstra(g, a, i);\n      for (int j:t_set)\n        mind = min(mind, a[j]);\n    }\n    if (mind < INF)\n      cout << mind << endl;\n    else\n      cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nstruct Node{\n\tint y,x,foot,cost;\n\tNode(){}\n\tNode(int a,int b,int c,int d):y(a),x(b),foot(c),cost(d){}\n\tbool operator <(const Node &a)const{return cost>a.cost;}\n};\n\nint main(){\n\tint w,h;\n\tchar map[60][30];\n\tint dp[60][30][2];\n\tpriority_queue<Node> pq;\n\tNode a,b;\n\twhile(cin>>w>>h&&(w||h)){\n\t\tint ans = -1;\n\t\twhile(!pq.empty())pq.pop();\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tpq.push(Node(i,j,0,0));\n\t\t\t\t\tpq.push(Node(i,j,1,0));\n\t\t\t\t\tdp[i][j][0]=dp[i][j][1]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tint sx,ddx;\n\t\t\ta=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(dp[a.y][a.x][a.foot] < a.cost)continue;\n\t\t\tif(map[a.y][a.x]=='T'){\n\t\t\t\tans = a.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a.foot==0){\n\t\t\t\tsx=ddx=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsx=ddx=-1;\n\t\t\t}\n\t\t\tfor(int dx=sx;abs(dx)<=3;dx+=ddx){\n\t\t\t\tfor(int dy=-2;dy<=2;dy++){\n\t\t\t\t\tif(3<abs(dy)+abs(dx))continue;\n\t\t\t\t\tint cost;\n\t\t\t\t\tb = Node(a.y+dy,a.x+dx,a.foot^1,a.cost);\n\t\t\t\t\tif(b.y<0||h<=b.y||b.x<0||w<=b.x||map[b.y][b.x]=='X')continue;\n\t\t\t\t\tif(map[b.y][b.x]=='S'||map[b.y][b.x]=='T')cost = 0;\n\t\t\t\t\telse cost = map[b.y][b.x]-'0';\n\t\t\t\t\tb.cost += cost;\n\t\t\t\t\tif(b.cost < dp[b.y][b.x][b.foot]){\n\t\t\t\t\t\tdp[b.y][b.x][b.foot] = b.cost;\n\t\t\t\t\t\tpq.push(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nconst int INF = 1e9;\n\nint X,Y;\nchar s[60][30];\nint dp[60][30][2];\n\nvoid dfs(int y,int x,int foot,int cost){\n    if(y<0 || x<0 || y>=Y || x>=X) return;\n    if(s[y][x] == 'X') return;\n    if(s[y][x] == 'T') {\n        dp[y][x][foot] = min(dp[y][x][foot], cost);\n        return;\n    }\n    assert(isdigit(s[y][x]));\n    int c = s[y][x] - '0';\n    if( dp[y][x][foot] > cost + c){\n        dp[y][x][foot] = cost + c;\n    }else{\n        return;\n    }\n    for(int dx=-3; dx<=3; dx++){\n        if(foot == 0 && dx<=0) continue;\n        if(foot == 1 && dx>=0) continue;\n        for(int dy=-2; dy<=2; dy++){\n            if(abs(dx)+abs(dy)>3) continue;\n            int ny = y + dy;\n            int nx = x + dx;\n            dfs(ny,nx,!foot,dp[y][x][foot]);\n        }\n    }\n}\n\nint main(void){\n    while(cin>>X>>Y, X|Y){\n        rep(y,60)rep(x,30)rep(i,2) dp[y][x][i] = INF;\n        vector<int> T,S;\n        rep(y,Y)rep(x,X){\n            cin>>s[y][x];\n            if(s[y][x] == 'T') T.push_back(x);\n            if(s[y][x] == 'S') {\n                S.push_back(x);\n                s[y][x] = '0';\n            }\n        }\n        int res = INF;\n        for(int x : S)rep(foot,2){\n            dfs(Y-1,x,foot,0);\n        }\n        for(int x : T)rep(foot,2){\n            res = min(res,dp[0][x][foot]);\n        }\n        cout<<(res == INF ? -1 : res)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dy[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\n\ntypedef vector<vvi> vvvi;\nstruct node{\n\tint foot,x,y,c;\n\tnode(){}\n\tnode(int foot,int x,int y,int c):foot(foot),x(x),y(y),c(c){}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w&&h){\n\t\tvvi s(w,vi(h));\n\t\tvector<pii> start,goal;\n\t\tREP(j,h)REP(i,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tswitch(c){\n\t\t\tcase 'S':\n\t\t\t\tstart.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tgoal.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\ts[i][j]=-1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts[i][j]=c-'0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvvvi cost(2,vvi(w,vi(h,MAX)));\n\t\tqueue<node> q;\n\t\tREP(i,2)REP(j,start.size()){\n\t\t\tq.push(node(i,start[j].first,start[j].second,0));\n\t\t\tcost[i][start[j].first][start[j].second]=0;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.front();\n\t\t\tq.pop();\n\t\t\tif(cost[n.foot][n.x][n.y]<n.c)continue;\n\t\t\tREP(i,9){\n\t\t\t\tint foot=(n.foot+1)%2;\n\t\t\t\tint x=n.x+dx[foot][i],y=n.y+dy[foot][i];\n\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h&&s[x][y]>=0){\n\t\t\t\t\tint newcost=cost[n.foot][n.x][n.y]+s[x][y];\n\t\t\t\t\tif(cost[foot][x][y]>newcost){\n\t\t\t\t\t\tcost[foot][x][y]=newcost;\n\t\t\t\t\t\tq.push(node(foot,x,y,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=MAX;\n\t\tREP(i,2)REP(j,goal.size()){\n\t\t\tbest=min(best,cost[i][goal[j].first][goal[j].second]);\n\t\t}\n\t\tif(best==MAX){\n\t\t\tbest=-1;\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_W 30\n#define MAX_H 60\nchar field[MAX_H][MAX_W];\n\nstruct P\n{\n    int x,y,cost,w;\n    bool operator >(const P &p) const{\n        return cost>p.cost;\n    }\n};\n\nint dx[]={\n    1,1,1,1,1,2,2,2,3\n};\nint dy[]={\n    -2,-1,0,1,2,-1,0,1,0\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, MAX_W*MAX_H, 'X');\n\n        priority_queue<P, vector<P>, greater<P> >que;\n\n        REP(y,h)REP(x,w){\n            cin >> field[y][x];\n            if(field[y][x]=='S'){\n                que.push({x, y, 0, 1});\n                que.push({x, y, 0,-1});\n            }\n        }\n\n        cout << \"input\" << endl;\n\n        vvi GL(h, vi(w, INF));\n        vvi GR(h, vi(w, INF));\n\n        int res=-1;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n\n            if(field[p.y][p.x]=='T'){\n                res=p.cost;\n                break;\n            }\n\n            REP(i, 9){\n                int sx=p.x+dx[i]*p.w;\n                int sy=p.y+dy[i];\n                if(0<=sx&&sx<w&&0<=sy&&sy<h){\n                    int cost=p.cost;\n                    switch(field[sy][sx]){\n                    case 'S':\n                    case 'T':\n                        cost+=0;\n                        break;\n                    case 'X':\n                        continue;\n                    default:\n                        cost+=field[sy][sx]-'0';\n                        break;\n                    }\n                    bool t=true;\n                    if(p.w>0&&GL[sy][sx]>cost){\n                        GL[sy][sx]=cost;\n                        t=false;\n                    }else if(p.w<0&&GR[sy][sx]>cost){\n                        GR[sy][sx]=cost;\n                        t=false;\n                    }\n                    if(t)continue;\n                    que.push({sx, sy, cost, p.w*-1});\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nvector<pi> F;\n\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      F.clear();\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\" %c\",&S[i][j]);\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  F.pb(pi(i,j));\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t}\n\t      //printf(\"%c\", S[i][j]);\n\t    }\n\t  //printf(\"\\n\");\n\t}\n      queue<pi> Q;\n      queue<bool> R;\n      rep(i,F.size())\n\t{\n\t  Q.push(F[i]);\n\t  Q.push(F[i]);\n\t  R.push(0);\n\t  R.push(1);\n\t}\n\n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vc = vector<char>;\nusing vvi = vector<vector<int> >;\nusing vvc = vector<vector<char> >;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\nint f_dir[2][4] = {{-1, 0, 1, 0}, {0, 1, 0, -1}}; //↑→↓←\nint e_dir[2][8] = {{-1, -1, -1, 0, 0, 1, 1, 1}, {-1, 0, 1, -1, 1, -1, 0, 1}};\nbool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\n\n#define INF 1e9\nint w, h;\nvvc cliff;\n\nvoid solve(){\n  cliff = vvc(h, vc(w));\n  vector<pii> starts;\n  vector<pii> goals;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> cliff[i][j];\n      if(cliff[i][j] == 'S') starts.push_back({i, j});\n      if(cliff[i][j] == 'T') goals.push_back({i, j});\n    }\n  }\n  vvvi dp(h, vvi(w, vi(2, INF)));\n  for(int i = 0; i < starts.size(); i++){\n    dp[starts[i].first][starts[i].second][0] = 0;\n    dp[starts[i].first][starts[i].second][1] = 0;\n  }\n  queue<pair<int, pii>> q;\n  vector<pii> r_foot;\n  vector<pii> l_foot;\n  for(int i = -2; i <= 2; i++){\n    for(int j = 1; j <= 3; j++){\n      if(i <= (3-j) && i >= (-3+j)) r_foot.push_back({i, j}), l_foot.push_back({i, -j});\n    }\n  }\n  for(pii i: starts) q.push({0, i}), q.push({1, i});\n  while(!q.empty()){\n    pair<int, pii> now = q.front(); q.pop();\n    int lr = now.first, y = now.second.first, x = now.second.second;\n    for(int i = 0; i < r_foot.size(); i++){\n      int nx_y, nx_x;\n      if(lr == 0) nx_y = y + r_foot[i].first, nx_x = x + r_foot[i].second;\n      else nx_y = y + l_foot[i].first, nx_x = x + l_foot[i].second;\n      if(!is_in_field(nx_y, nx_x, h, w) || cliff[nx_y][nx_x] == 'X') continue;\n      int t = (cliff[nx_y][nx_x] == 'T' || cliff[nx_y][nx_x] == 'S') ? 0 : cliff[nx_y][nx_x]-'0';\n      if(dp[nx_y][nx_x][(lr+1)%2] > dp[y][x][lr] + t){\n        dp[nx_y][nx_x][(lr+1)%2] = dp[y][x][lr] + t;\n        q.push({(lr+1)%2, {nx_y, nx_x}});\n      }\n    }\n  }\n  int ans = INF;\n  for(int i = 0; i < goals.size(); i++){\n    ans = min({ans, dp[goals[i].first][goals[i].second][0], dp[goals[i].first][goals[i].second][1]});\n  }\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  while(cin >> w >> h && w){\n    solve();\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\n\nint W,H;\nstruct Node{\n\tint x,y,cost,dir;\n\tNode(int p_x,int p_y,int p_c,int p_dir){\n\t\tx=p_x;y=p_y;dir=p_dir;cost=p_c;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.cost>b.cost;\n};\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=W || y>=H) return false;\n\treturn true;\n}\n\nint solve(){\n\tvector<vector<char> > M(H,vector<char>(W));\n\tvector<int> S;\n\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tM[y][x]=c;\n\t\t\tif(c=='S'){\n\t\t\t\tS.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Node> Q;\n\tint cost[2][60][30];\n\tmemset(cost,-1,sizeof(cost));\n\n\tfor(int i=0;i<S.size();i++){\n\t\tQ.push(Node(S[i],H-1,0,0));\n\t\tQ.push(Node(S[i],H-1,0,1));\n\t}\n\twhile(!Q.empty()){\n\t\tNode t=Q.top();\n\t\tQ.pop();\n\t\tif(cost[t.dir][t.y][t.x]>=0) continue;\n\t\tcost[t.dir][t.y][t.x]=t.cost;\n\t\tint mul,next;\n\t\tif(t.dir==0){mul=1;next=1;}\n\t\telse{mul=-1;next=0;}\n\n\t\tfor(int x=1;x<=3;x++){\n\t\t\tfor(int y=-2;y<=2;y++){\n\t\t\t\tif(x+abs(y)>3) continue;\n\t\t\t\tint nx=t.x+x*mul;\n\t\t\t\tint ny=t.y+y;\n\t\t\t\tif(!in(nx,ny)) continue;\n\n\t\t\t\tif(M[ny][nx]=='T') return t.cost;\n\t\t\t\tif(!isdigit(M[ny][nx])) continue;\n\n\t\t\t\tQ.push(Node(nx,ny,t.cost+M[ny][nx]-'0',next));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin>>W>>H){\n\t\tif(W==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_DIR 9\n#define MAX_N 100\n#define INF 1 << 30\n\nstring C;\nint X[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint G[MAX_N][MAX_N];\nint DIST[MAX_N][MAX_N][MAX_DIR];//Left,DY-DX\nint dx[MAX_DIR] = { 1,1,1,1,1,2,2,2,3 };\nint dy[MAX_DIR] = { -2,-1,0,1,2,-1,0,1,0 };\nint dz[MAX_DIR] = { 4,3,2,1,0,7,6,5,8 };\nint H, W;\nchar U[11] = \"0123456789\";\n\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>> > Q;\n\nvoid MEMSET() {\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tX[i][j] = INF;\n\t\t\tS[i][j] = 0;\n\t\t\tG[i][j] = 0;\n\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\tDIST[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DIJKSTRA() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j + dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[i][j][k] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j - dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[Y1][X1][dz[k]] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, Y1, X1, dz[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\ttuple<int, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tint LY = a2, LX = a3;\n\t\tint RY = a2 + dy[a4], RX = a3 + dx[a4];\n\n\t\t//hidari.\n\t\tfor (int k = 0; k < MAX_DIR; k++)\n\t\t{\n\t\t\tint cy = RY + dy[k];\n\t\t\tint cx = RX - dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[cy][cx][dz[k]] > dis + pos) {\n\t\t\t\t\tDIST[cy][cx][dz[k]] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[cy][cx][dz[k]], cy, cx, dz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//migi.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = LY + dy[k];\n\t\t\tint cx = LX + dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[LY][LX][k] > dis + pos) {\n\t\t\t\t\tDIST[LY][LX][k] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[LY][LX][k], LY, LX, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (G[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint ey = i + dy[k];\n\t\t\t\t\tint ex = j + dx[k];\n\t\t\t\t\tif (ey < 1 || ey > H) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ex < 1 || ex > W) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (G[ey][ex] == 1) {\n\t\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res >= INF) {\n\t\treturn -1;\n\t}\n\treturn res;\n}\n\nint power(int a, int b) {\n\tint R = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tR *= b;\n\t}\n\treturn R;\n}\n\nvoid CIN() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> C;\n\t\t\tif (C == \"X\") {\n\t\t\t\tX[i][j] = INF;\n\t\t\t}\n\t\t\telse if (C == \"S\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tS[i][j] = 1;\n\t\t\t}\n\t\t\telse if (C == \"T\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint D = C.size();\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tfor (int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif (C[k] == U[l]) {\n\t\t\t\t\t\t\tcnt1 += power(10, D - k - 1)*l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX[i][j] = cnt1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tS[H + 1][i] = 1;\n\t\tX[H + 1][i] = 0;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tMEMSET();\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tCIN();\n\t\tcout << DIJKSTRA() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\nint dy[] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvector<vi> fld(h, vi(w));\n\t\tvi st, go;\n\t\tmap<pii, int> mp;\n\t\tmp[pii(-1, -1)] = -1;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') fld[i][j] = INF;\n\t\t\telse if (c == 'S')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tst.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse if (c == 'T')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tgo.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse fld[i][j] = c - '0';\n\t\t}\n\t\tvi goal;\n\t\tGraph g(1);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tint aaa = mp.size();\n\t\t\t\tif (find(ALL(st), left) != st.end() || find(ALL(st), right) != st.end())\n\t\t\t\t{\n\t\t\t\t\tg[0].push_back(edge{ aaa, max(fld[i][j], fld[rx][ry]) });\n\t\t\t\t}\n\t\t\t\tif (find(ALL(go), left) != go.end() || find(ALL(go), right) != go.end())\n\t\t\t\t{\n\t\t\t\t\tgoal.push_back(aaa);\n\t\t\t\t}\n\t\t\t\tmp[pii(left, right)] = aaa;\n\t\t\t}\n\t\t}\n\t\tg.resize(mp.size());\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tint now = mp[pii(left, right)];\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(left, place(nx, ny, w))];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = rx + dx[l], ny = ry - dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(place(nx, ny, w), right)];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<weight> d;\n\t\tdijkstra(g, d, 0);\n\t\tint ans = INF;\n\t\tREP(i, goal.size()) chmin(ans, d[goal[i]]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst int INFTY=1<<29;\n\nstruct State{\n\tint i,j,c,f;\n\tState(){}\n\tState(int i,int j,int c,int f):i(i),j(j),c(c),f(f){}\n\tbool operator<(const State& s)const{return c<s.c;}\n\tbool operator>(const State& s)const{return c>s.c;}\n};\n\nint toint(char c)\n{\n\tif(c=='S' || c=='T')\n\t\treturn 0;\n\tif(c=='X')\n\t\treturn INFTY;\n\treturn c-'0';\n}\n\nint solve(const vector<vector<char> >& cliff,int si,int sj,int sf)\n{\n\tstatic const int di[]={-2,-1,-1,0,0,0,1,1,2};\n\tstatic const int dj[]={1,1,2,1,2,3,1,2,1};\n\t\n\tint h=cliff.size(),w=cliff[0].size();\n\tpriority_queue<State,vector<State>,greater<State> > pq;\n\tpq.push(State(si,sj,0,sf));\n\tvector<vector<vector<int> > > dp(2,vector<vector<int> >(h,vector<int>(w,INFTY)));\n\twhile(pq.size()){\n\t\tState cur=pq.top(); pq.pop();\n\t\tif(dp[cur.f][cur.i][cur.j]!=INFTY)\n\t\t\tcontinue;\n\t\tif(cliff[cur.i][cur.j]=='T')\n\t\t\treturn cur.c;\n\t\tdp[cur.f][cur.i][cur.j]=cur.c;\n\t\tfor(int k=0;k<9;k++){\n\t\t\tint ni=cur.i+di[k];\n\t\t\tint nj=cur.j+(cur.f?-dj[k]:dj[k]);\n\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || cliff[ni][nj]=='X')\n\t\t\t\tcontinue;\n\t\t\tint nc=cur.c+toint(cliff[ni][nj]);\n\t\t\tpq.push(State(ni,nj,nc,!cur.f));\n\t\t}\n\t}\n\treturn INFTY;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h && w|h;){\n\t\tvector<vector<char> > cliff(h,vector<char>(w));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin>>cliff[i][j];\n\t\tint res=INFTY;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tif(cliff[i][j]=='S'){\n\t\t\t\t\tres=min(res,solve(cliff,i,j,0));\n\t\t\t\t\tres=min(res,solve(cliff,i,j,1));\n\t\t\t\t}\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n#define COMP(key) [](const auto& a, const auto& b) { return a.key < b.key; }\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\nusing P = pair<i64, i64>;\nusing T = pair<i64, P>;\nsigned main() {\n  while (true) {\n    i64 w, h;\n    cin >> w >> h;\n    if (w == 0) break;\n    vector<vector<string>> field(h, vector<string>(w));\n    vector<vector<i64>> left(h, vector<i64>(w, inf<i64>));\n    vector<vector<i64>> right(h, vector<i64>(w, inf<i64>));\n    priority_queue<T, vector<T>, greater<T>> que;\n    REP(i, h) {\n      REP(j, w) {\n        cin >> field[i][j];\n        if (field[i][j] == \"S\") {\n          que.push({0, {i, j}});\n          left[i][j] = 0;\n          right[i][j] = 0;\n        }\n      }\n    }\n    vector<pair<i64, i64>> RIGHT({\n      {-2,1},\n      {-1,1},{-1,2},\n      {0,1},{0,2},{0,3},\n      {1,1},{1,2},\n      {2,1},\n    });\n    vector<pair<i64, i64>> LEFT({\n      {-2,-1},\n      {-1,-1},{-1,-2},\n      {0,-1},{0,-2},{0,-3},\n      {1,-1},{1,-2},\n      {2,-1},\n    });\n    while (que.size()) {\n      i64 c, i, j;\n      c = que.top().first;\n      i = que.top().second.first;\n      j = que.top().second.second;\n      que.pop();\n      for (P d : RIGHT) {\n        i64 ii = i + d.first;\n        i64 jj = j + d.second;\n        if (0 <= ii && ii < h && 0 <= jj && jj < w) {\n          if (\"0\" <= field[ii][jj] && field[ii][jj] <= \"9\") {\n            i64 d = field[ii][jj][0] - '0';\n            if (right[ii][jj] > left[i][j] + d) {\n              right[ii][jj] = left[i][j] + d;\n              que.push({right[ii][jj], {ii, jj}});\n            }\n          } else if (field[ii][jj] == \"T\") {\n            if (right[ii][jj] > left[i][j]) {\n              right[ii][jj] = left[i][j];\n            }\n          }\n        }\n      }\n      for (P d : LEFT) {\n        i64 ii = i + d.first;\n        i64 jj = j + d.second;\n        if (0 <= ii && ii < h && 0 <= jj && jj < w) {\n          if (\"0\" <= field[ii][jj] && field[ii][jj] <= \"9\") {\n            i64 d = field[ii][jj][0] - '0';\n            if (left[ii][jj] > right[i][j] + d) {\n              left[ii][jj] = right[i][j] + d;\n              que.push({left[ii][jj], {ii, jj}});\n            }\n          } else if (field[ii][jj] == \"T\") {\n            if (left[ii][jj] > right[i][j]) {\n              left[ii][jj] = right[i][j];\n            }\n          }\n        }\n      }\n    }\n    i64 ans = inf<i64>;\n    REP(i, h) {\n      REP(j, w) {\n        if (field[i][j] == \"T\") {\n          ans = min({ans, left[i][j], right[i][j]});\n          // cout << i << \", \" << j << \": \" << left[i][j] << \", \" << right[i][j] << endl;\n        }\n      }\n    }\n    cout << (ans == inf<i64> ? -1 : ans) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\tque.push(make_tuple(sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<0>(que.top());\n\t\tint y = get<1>(que.top());\n\t\tint s = get<2>(que.top());\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\"%c\", &M[i][j]);\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[H - 1][i] == 'S')\n\t\t{\n\t\t\tret = min(ret, solve(i));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 32\n\ntypedef long long ll;\nconst int dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nstruct edge {\n    int x, y, cost;\n};\n\nstruct state {\n    int x, y, all_cost, lr;\n};\n\nint w, h;\nchar field[MAXH][MAXW];\n\nint dijkstra(void) {\n    int d[MAXH][MAXW][2];\n    for (int i = 0; i < h; i++) \n        for (int j = 0; j < w; j++)\n            for (int k = 0; k < 2; k++) \n                d[i][j][k] = INF;\n    state s;\n    queue<state> que;\n    s.y = h-1; s.all_cost = 0;\n    for (int i = 0; i < w; i++) {\n        if (field[h-1][i] == 'S') {\n            d[h-1][i][0] = d[h-1][i][1] = 0;\n            s.x = i; s.lr = 0; que.push(s); s.lr = 1; que.push(s);\n        }\n    }\n    while (!que.empty()) {\n        state now = que.front(); que.pop();\n        if (d[now.y][now.x][now.lr] < now.all_cost || field[now.y][now.x] == 'T') continue;\n        if (now.lr == 0) { // 左の場合\n            for (int i = 0; i < 9; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'X') {\n                    int all_cost;\n                    if (field[ny][nx] == 'T' || field[ny][nx] == 'S') {\n                        all_cost = now.all_cost;\n                    } else {\n                        all_cost = now.all_cost + (int)(field[ny][nx] - '0');\n                    }\n                    if (d[ny][nx][1] > all_cost) {\n                        d[ny][nx][1] = all_cost;\n                        state st; st.x = nx; st.y = ny; st.all_cost = all_cost; st.lr = 1;\n                        que.push(st);\n                    }\n                }\n            }\n        }\n        else { // 右の場合\n            for (int i = 0; i < 9; i++) {\n                int nx = now.x - dx[i];\n                int ny = now.y + dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'X') {\n                    int all_cost;\n                    if (field[ny][nx] == 'T' || field[ny][nx] == 'S') {\n                        all_cost = now.all_cost;\n                    } else {\n                        all_cost = now.all_cost + (int)(field[ny][nx] - '0');\n                    }\n                    if (d[ny][nx][0] > all_cost) {\n                        d[ny][nx][0] = all_cost;\n                        state st; st.x = nx; st.y = ny; st.all_cost = all_cost; st.lr = 0;\n                        que.push(st);\n                    }\n                }\n            }\n        }\n    }\n    int ret = INF;\n    for (int i = 0; i < w; i++) {\n        if (field[0][i] == 'T') {\n            for (int j = 0; j < 2; j++) {\n                ret = min(ret, d[0][i][j]);\n            }\n        }\n    }\n    if (ret < INF) return ret;\n    else return -1;\n}\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1e10\nusing namespace std;\n\nstruct data {\n  long long x[2], y[2], dis;\n  bool turn;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.dis != r.dis) return l.dis > r.dis;\n  return 0;\n}\n\nvector<vector<char>> s;\nlong long dis[66][33][66][33][2] = {0};\nlong long h, w;\npriority_queue<data> pq;\n\nbool ch(data now);\nlong long solve();\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w + h == 0) break;\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        for(int k = 0; k < h; ++k)\n          for(int l = 0; l < w; ++l)\n            for(int m = 0; m < 2; ++m)\n              dis[i][j][k][l][m] = inf;\n    s.resize(h);\n    for(int i = 0; i < h; ++i) s[i].resize(w);\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j) cin >> s[i][j];\n    cout << solve() << endl;\n    while(pq.size() > 0) pq.pop();\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long ans = inf;\n  vector<long long> lst;\n  for(int i = 0; i < w; ++i)\n    if(s[h - 1][i] == 'S') {\n      data now;\n      now.x[0] = now.x[1] = h - 1;\n      now.y[0] = now.y[1] = i;\n      now.dis = 0;\n      now.turn = 0;\n      pq.push(now);\n      now.turn = 1;\n      pq.push(now);\n    }\n\n  while(!pq.empty()) {\n    data now = pq.top();\n    pq.pop();\n    if(now.dis >= dis[now.x[0]][now.y[0]][now.x[1]]\n                     [now.y[1]][now.turn])\n      continue;\n    dis[now.x[0]][now.y[0]][now.x[1]][now.y[1]][now.turn] =\n        now.dis;\n    for(int i = -2; i <= 2; ++i)\n      for(int j = 1; j <= 3; ++j) {\n        data nextd = now;\n        nextd.turn = !now.turn;\n        nextd.x[now.turn] = nextd.x[nextd.turn] + i;\n        nextd.y[now.turn] =\n            nextd.y[nextd.turn] + j - nextd.turn * 2 * j;\n        if(!ch(nextd)) continue;\n        if(s[nextd.x[now.turn]][nextd.y[now.turn]] >= '0' &&\n           s[nextd.x[now.turn]][nextd.y[now.turn]] <= '9') {\n          nextd.dis +=\n              s[nextd.x[now.turn]][nextd.y[now.turn]] - '0';\n          pq.push(nextd);\n        }\n        if(s[nextd.x[now.turn]][nextd.y[now.turn]] == 'S')\n          pq.push(nextd);\n        if(s[nextd.x[now.turn]][nextd.y[now.turn]] == 'T')\n          ans = min(ans, nextd.dis);\n      }\n  }\n  if(ans == inf) return -1;\n  return ans;\n}\n\nbool ch(data now) {\n  for(int i = 0; i < 2; ++i)\n    if(now.x[i] < 0 || now.x[i] >= h || now.y[i] < 0 ||\n       now.y[i] >= w)\n      return 0;\n  int mdis =\n      abs(now.x[0] - now.x[1]) + abs(now.y[0] - now.y[1]);\n  return now.y[0] < now.y[1] && mdis <= 3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1e9\nchar v[32][62][2];\nchar map[32][62];\nint dp[32][62][2];\nint w,h;\nstruct {int x,y;} d[9]={\n{1,-2},\n{1,-1},\n{1,0},\n{1,1},\n{1,2},\n{2,-1},\n{2,0},\n{2,1},\n{3,0}\n};\n\n\nclass State{\npublic:\n\tint cost;\n\tint x,y,d;\n\t\n\tState(){}\n\tState(int c, int a, int b, int e)\n\t:cost(c),x(a),y(b),d(e)\n\t{}\n\tbool operator < (const State &opp) const{\n\t\treturn cost > opp.cost;\n\t}\n};\n\nmain(){\n\tint i,j,k;\n\twhile(cin>>w>>h,w){\n\t\tpriority_queue<State> S;\n\t\tfor(i=1;i<=h;i++) \n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin>>map[j][i];\n\t\t\t\tfor(k=0;k<2;k++){\n\t\t\t\t\tif(map[j][i]=='S'){\n\t\t\t\t\t\tS.push(State(0,j,i,k));\n\t\t\t\t\t\tdp[j][i][k] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[j][i][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t\tv[j][i][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tState t;\n\t\twhile(!S.empty()){\n\t\t\tt = S.top();S.pop();\n\t\t\tif(map[t.x][t.y]=='T') break;\n\t\t\tif(v[t.x][t.y][t.d]) continue;\n\t\t\tv[t.x][t.y][t.d] = 1;\n\n\t\t\tfor(i=0;i<9;i++){\n\t\t\t\tint tx=t.x+d[i].x*(!t.d?1:-1);\n\t\t\t\tint ty=t.y+d[i].y;\n\t\t\t\tint td=(t.d+1)%2;\n\t\t\t\tif(tx<1 || ty<1 || w<tx || h<ty || map[tx][ty]=='X') continue;\n\t\t\t\tint tc=('0'<=map[tx][ty] && map[tx][ty]<='9')?map[tx][ty]-'0':0;\n\t\t\t\tif(t.cost+tc < dp[tx][ty][td]){\n\t\t\t\t\tdp[tx][ty][td] = t.cost+tc;\n\t\t\t\t\tS.push(State(dp[tx][ty][td], tx, ty, td));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (map[t.x][t.y]=='T'?dp[t.x][t.y][t.d]:-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nclass position\n{\npublic:\n    int y, x;\n    bool left;\n    position(int y0, int x0, bool left0){\n        y = y0;\n        x = x0;\n        left = left0;\n    }\n};\n\nvoid solve(int w, int h, vector<vector<int> > block)\n{\n    int dy[9] = {-2,-1,-1,0,0,0,1,1,2};\n    int dx[9] = {1,1,2,1,2,3,1,2,1};\n\n    multimap<int, position> m;\n    for(int i=3; i<w+3; ++i){\n        if(block[h+1][i] == -1){\n            m.insert(make_pair(0, position(h+1, i, true)));\n            m.insert(make_pair(0, position(h+1, i, false)));\n        }\n    }\n\n    vector<vector<vector<bool> > > check(h+4, vector<vector<bool> >(w+6, vector<bool>(2, false)));\n    while(!m.empty()){\n        multimap<int, position>::iterator it = m.begin();\n        int t = it->first;\n        int y = it->second.y;\n        int x = it->second.x;\n        bool left = it->second.left;\n        m.erase(it);\n\n        if(block[y][x] == 0){\n            cout << t << endl;\n            return;\n        }\n        if(check[y][x][left?1:0])\n            continue;\n        check[y][x][left?1:0] = true;\n\n        if(left){\n            for(int i=0; i<9; ++i){\n                if(block[y+dy[i]][x+dx[i]] >= 0 && !check[y+dy[i]][x+dx[i]][0])\n                    m.insert(make_pair(t+block[y+dy[i]][x+dx[i]], position(y+dy[i], x+dx[i], 0)));\n            }\n        }else{\n            for(int i=0; i<9; ++i){\n                if(block[y+dy[i]][x-dx[i]] >= 0 && !check[y+dy[i]][x-dx[i]][1])\n                    m.insert(make_pair(t+block[y+dy[i]][x-dx[i]], position(y+dy[i], x-dx[i], 1)));\n            }\n        }\n\n    }\n\n    cout << -1 << endl;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tvector<vector<int> > block(h+4, vector<int>(w+6, -2));\n\t\tfor(int i=2; i<h+2; ++i){\n\t\t\tfor(int j=3; j<w+3; ++j){\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif(tmp == 'S')\n                    block[i][j] = -1;\n                else if(tmp == 'T')\n                    block[i][j] = 0;\n                else if(tmp != 'X')\n\t\t\t\t\tblock[i][j] = tmp - '0';\n\t\t\t}\n\t\t}\n\n\t\tsolve(w, h, block);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\nint w,h;\nconst int INF = 1<<29;\nchar tbl[70][70];\nint cost[2][70][70];\nbool used[2][70][70];\n\n/*\n  f=0 -> left\n  f=1 -> right\n*/\nstruct V{\n  int f,x,y;\n  V(int f=0,int x=0,int y=0):f(f),x(x),y(y){}\n};\n\nbool operator <(const V& a,const V& b){\n  return cost[a.f][a.y][a.x] > cost[b.f][b.y][b.x];\n}\n\nint dijkstra(int sx,int sy,int f){\n  for(int i=0;i<h;++i)\n    for(int j=0;j<w;++j)\n      cost[0][i][j]=cost[1][i][j]=INF,\n\tused[0][i][j] = used[1][i][j]=false;\n\n  priority_queue<V,vector<V> > Q;\n  Q.push(V(f,sx,sy));\n  cost[f][sy][sx] = 0;\n  while(!Q.empty()){\n    V v = Q.top(); Q.pop();\n    if(used[v.f][v.y][v.x]) continue;\n    used[v.f][v.y][v.x] = true;\n    int mf = 1-v.f;\n    for(int dx=1;dx<=3;++dx){\n      for(int dy=-3+dx;dy<=3-dx;++dy){\n\tint mx = (v.f)?(v.x+dx):(v.x-dx);\n\tint my = v.y+dy;\n\tif(mx<0 || my<0) continue;\n\tif(mx>=w || my>=h) continue;\n\tif(tbl[my][mx]=='X') continue;\n\tint nxtcost = cost[v.f][v.y][v.x];\n\tif(tbl[my][mx]!='T') nxtcost+=tbl[my][mx]-'0';\n\tcost[mf][my][mx] = min(cost[mf][my][mx],nxtcost);\n\tQ.push(V(mf,mx,my));\n      }\n    }\n  }\n  int ret = INF;\n  for(int i=0;i<h;++i)\n    for(int j=0;j<w;++j)\n      if(tbl[i][j]=='T'){\n\tret = min(ret,cost[0][i][j]);\n\tret = min(ret,cost[1][i][j]);\n      }\n\n  return ret;\n}\nint main(){\n  while(cin>>w>>h,w||h){\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tcin>>tbl[i][j];\n\n    int ans = INF;\n    for(int j=0;j<w;++j)\n      if(tbl[h-1][j]=='S'){\n\tans = min(ans,dijkstra(j,h-1,0));\n\tans = min(ans,dijkstra(j,h-1,1));\n      }\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nstruct Data {\n\tint ry, rx, ly, lx;\n\tint cost;\n\tbool nextr;\n\tData(int ry, int rx, int ly, int lx, int c, bool n) : ry(ry), rx(rx), ly(ly), lx(lx), cost(c), nextr(n) {}\n\tbool operator< (const Data& d)const {\n\t\treturn cost > d.cost;\n\t}\n};\n\nint w, h;\nbool valid(int y, int x)\n{\n\treturn 0<=y && y<h && 0<=x && x<w;\n}\n\nconst int dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int drx[] = {-1, -2, -1, -3, -2, -1, -2, -1, -1};\nbool visited[100][100][100][100];\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\trep(i, 100) rep(j, 100) rep(k, 100) rep(l, 100)\n\t\t\tvisited[i][j][k][l] = false;\n\n\t\tchar field[100][100];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar tmp[100];\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tfield[i][j] = tmp[0];\n\t\t}\n\n\t\tpriority_queue<Data> Q;\n\t\trep(i, w){\n\t\t\tif(field[h-1][i] == 'S'){\n\t\t\t\tQ.push(Data(h-1, i, 99, 99, 0, false));\n\t\t\t\tQ.push(Data(99, 99, h-1, i, 0, true));\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(visited[d.ry][d.rx][d.ly][d.lx])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.ry][d.rx][d.ly][d.lx] = true;\n\t\t\tif(field[d.ry][d.rx] == 'T' || field[d.ly][d.lx] == 'T'){\n\t\t\t\tans = d.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 9){\n\t\t\t\tint pry, prx, ply, plx;\n\t\t\t\tif(d.nextr){\n\t\t\t\t\tif(d.ly == 99)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpry = d.ly + dy[i];\n\t\t\t\t\tprx = d.lx + drx[i];\n\t\t\t\t\tply = d.ly;\n\t\t\t\t\tplx = d.lx;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(d.ry == 99)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpry = d.ry;\n\t\t\t\t\tprx = d.rx;\n\t\t\t\t\tply = d.ry + dy[i];\n\t\t\t\t\tplx = d.rx - drx[i];\n\t\t\t\t}\n\t\t\t\tif(!valid(pry, prx) || !valid(ply, plx))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tchar c = d.nextr ? field[pry][prx] : field[ply][plx];\n\t\t\t\tif(c == 'X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint pc = d.cost + (isdigit(c) ? c-'0' : 0);\n\t\t\t\tQ.push(Data(pry, prx, ply, plx, pc, !d.nextr));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    int dp[2][60][30];\n    char mp[30][60];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>mp[i][j];\n\tdp[0][i][j]=dp[1][i][j]=1e9;\n\tif(mp[i][j]=='S')dp[0][i][j]=dp[0][i][j]=0;\n      }\n\n    int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0},ans=1e9;\n    for(int i=0;i<=100;i++)\n      for(int y=0;y<h;y++)\n\tfor(int x=0;x<w;x++)\n\t  for(int l=0;l<2;l++){\n\t    int f=1,c=0;\n\t    if(l)f=-1;\n\t    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n\t    for(int p=0;p<9;p++){\n\t      int nx=x+f*dx[p],ny=y+f*dy[p];\n\t      if(nx<0||w<=nx||ny<0||h<=ny||mp[ny][nx]=='X')continue;\n\t      dp[!l][ny][nx]=min(dp[!l][ny][nx],dp[l][y][x]+c);\n\t    }\n\t    if(mp[y][x]=='T')ans=min(ans,dp[l][y][x]);\n\t  }\n    if(ans==1e9)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define H 60\n#define W 30\n#define INF 10000\n#define R 1\n#define L 0\nint w, h;\nchar maps[H][W];\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][2];\n    bool used[H][W][2];\n    int ldx[9] = {-1, -1, -1, -1, -1, -2, -2, -2, -3};\n    int ldy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    int rdx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n    int rdy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    for (int i = 0; i < w - 1; i++) {\n        if (maps[h-1][i] == 'S') {\n            d[h - 1][i][L] = 0; d[h - 1][i+1][R] = 0;\n        }\n    }\n    \n    while (true) {\n        point p;\n        p.x = -1; p.y = -1;\n        int muki = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (!used[i][j][k] && (p.x == -1 || d[i][j][k] < d[p.y][p.x][muki])) {\n                        p.x = j; p.y = i; muki = k;\n                    }\n                }\n            }\n        }\n        \n        if (p.x == -1 && p.y == -1) {\n            break;\n        }\n        used[p.y][p.x][muki] = true;\n        \n        if (muki == R) {\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + ldx[i];\n                int my = p.y + ldy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R]);\n                }\n                else{\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n        else{\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + rdx[i];\n                int my = p.y + rdy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L]);\n                }\n                else{\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int j = 0; j < w; j++) {\n        if (maps[0][j] == 'T'){\n            for (int k = 0; k < 2; k++) {\n                ans = min(ans, d[0][j][k]);\n            }\n        }\n    }\n    if (ans == INF) {\n        return -1;\n    }\n    else {\n        return ans;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> maps[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 999999;\n\nclass Node{\npublic:\n\tint x, y, foot, cost;\n\tNode(int x, int y, int foot, int cost) : x(x), y(y), foot(foot), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nint main(){\n\tint w, h;\n\tchar b[60][30];\n\tbool visit[2][60][30];\n\tint dist[2][60][30];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint ans = INF;\n\t\tpriority_queue<Node> qu;\n\t\tmemset(visit, false, sizeof(visit));\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> b[i][j];\n\t\t\t\tif(isdigit(b[i][j])) b[i][j] -= '0';\n\t\t\t\telse if(b[i][j] == 'S'){\n\t\t\t\t\tqu.push(Node(j,i,0,0));\n\t\t\t\t\tqu.push(Node(j,i,1,0));\n\t\t\t\t\tdist[0][i][j] = 0;\n\t\t\t\t\tdist[1][i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!qu.empty()){\n\t\t\tNode e = qu.top(); qu.pop();\n\t\t\tif(visit[e.foot][e.y][e.x]) continue;\n\t\t\tif(b[e.y][e.x]=='T'){\n\t\t\t\tans = e.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvisit[e.foot][e.y][e.x] = true;\n\t\t\tfor(int dx=1;dx<=3;dx++){\n\t\t\t\tfor(int dy=dx-3;dy<=3-dx;dy++){\n\t\t\t\t\tint x = e.x + (e.foot ? -dx : dx);\n\t\t\t\t\tint y = e.y + dy;\n\t\t\t\t\tif(x<0||x>=w||y<0||y>=h||visit[(1+e.foot)%2][y][x]) continue;\n\t\t\t\t\tif(b[y][x]=='X'||b[y][x]=='S') continue;\n\t\t\t\t\tif(dist[(1+e.foot)%2][y][x] > e.cost + (b[y][x]!='T'?b[y][x]:0)){\n\t\t\t\t\t\tdist[(1+e.foot)%2][y][x] = e.cost + (b[y][x]!='T'?b[y][x]:0);\n\t\t\t\t\t\tqu.push(Node(x,y,(1+e.foot)%2,e.cost+(b[y][x]!='T'?b[y][x]:0)));\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;  \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<p,p> P;\n\nchar mp[60][30];\nint w,h;\nint cal(){\n  bool used[2][60][30]={};\n  int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0};\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<w;i++)\n    if(mp[h-1][i]=='S')q.push(P(p(0,0),p(i,h-1))),q.push(P(p(0,1),p(i,h-1)));\n  while(!q.empty()){\n    int s=q.top().first.first,l=q.top().first.second;\n    int x=q.top().second.first,y=q.top().second.second;\n    q.pop();\n    if(mp[y][x]=='T')return s;\n    if(used[l][y][x]||mp[y][x]=='X')continue;\n    used[l][y][x]=1;\n    int f=1,c=0;\n    if(l)f=-1;\n    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n    for(int d=0;d<9;d++){\n      int nx=x+f*dx[d],ny=y+f*dy[d];\n      if(nx<0||w<=nx||ny<0||h<=ny)continue;\n      q.push(P(p(s+c,!l),p(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    cout<<cal()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nchar s[100][100];\nint d[100][100][2];\n\nint dx[2][9] = { { 1, 1, 1, 1, 1, 2, 2, 2, 3 },\n\t\t\t\t{ -1, -1, -1, -1, -1, -2, -2, -2, -3 } };\nint dy[9] = { 2,1,0,-1,-2,1,0,-1,0 };\n\nconst int INF = 1e9;\n\ntypedef tuple<int, int, int> T;\n\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx && y < my;\n}\n\nint main(){\n\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\n\t\tmemset(s, 0, sizeof s);\n\n\t\trep(i, 100)rep(j, 100)rep(k, 2)d[i][j][k] = INF;\n\n\t\tqueue<T> q;\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> s[y][x];\n\t\t\tif (s[y][x] == 'S'){\n\t\t\t\tq.push(T(y, x, 0));\n\t\t\t\tq.push(T(y, x, 1));\n\t\t\t\td[y][x][0] = 0;\n\t\t\t\td[y][x][1] = 0;\n\t\t\t}\n\t\t}\n\n\t\twhile (q.size()){\n\t\t\tint y = get<0>(q.front());\n\t\t\tint x = get<1>(q.front());\n\t\t\tint r = get<2>(q.front());\n\t\t\tq.pop();\n\n\t\t\trep(i, 9){\n\t\t\t\tint tx = x + dx[r][i];\n\t\t\t\tint ty = y + dy[i];\n\n\t\t\t\tint tmp = 0;\n\t\t\t\tif (s[ty][tx] >= '0' && s[ty][tx] <= '9')tmp = s[ty][tx] - '0';\n\n\t\t\t\tif (cheak(tx, ty, w, h) && (d[ty][tx][1-r] > d[y][x][r] + tmp)\n\t\t\t\t\t&& (s[ty][tx] != 'X')){\n\n\t\t\t\t\td[ty][tx][1-r] = d[y][x][r] + tmp;\n\t\t\t\t\tq.push(T(ty, tx, 1 - r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(y, h)rep(x, w){\n\t\t\tif (s[y][x] == 'T'){\n\t\t\t\tans = min(ans, d[y][x][0]);\n\t\t\t\tans = min(ans, d[y][x][1]);\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint dist[1800][1800][2],s[100][100],w,h;\n\nint encode(int x,int y){\n    return x+w*y;\n}\n\npii decode(int pos){\n    return make_pair(pos%w,pos/w);\n}\n\nbool verify(int lp,int rp){\n    int lx=decode(lp).first,ly=decode(lp).second;\n    int rx=decode(rp).first,ry=decode(rp).second;\n    return lx<rx and abs(lx-rx)+abs(ly-ry)<=3 and s[lx][ly]!=inf and s[rx][ry]!=inf;\n}\n\nvoid solve(){\n    typedef tuple<int,int,int> state;\n    while(true){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n        vector<int> start_points,end_points;\n        rep(y,0,h) rep(x,0,w) s[x][y]=0;\n        rep(y,0,h) rep(x,0,w){\n            char tmp;\n            cin >> tmp;\n            if(tmp=='S') start_points.push_back(encode(x,y));\n            else if(tmp=='T') end_points.push_back(encode(x,y));\n            else if(tmp=='X') s[x][y]=inf;\n            else s[x][y]=tmp-'0';\n        }\n\n        rep(i,0,w*h) rep(j,0,w*h) rep(k,0,2) dist[i][j][k]=inf;\n        priority_queue<pair<int,state>,vector<pair<int,state>>,greater<pair<int,state>>> que;\n        for(int sp:start_points) rep(i,0,w*h){\n            auto push=[&](int lp,int rp,int c){\n                if(!verify(lp,rp)) return;\n                dist[lp][rp][c]=s[decode(i).first][decode(i).second];\n                que.push(make_pair(dist[lp][rp][c],make_tuple(lp,rp,c)));\n            };\n            push(sp,i,0);\n            push(i,sp,1);\n        }\n\n        while(!que.empty()){\n            int d=que.top().first;\n            state st=que.top().second;\n            que.pop();\n            int lp=get<0>(st),rp=get<1>(st),c=get<2>(st);\n            if(d>dist[lp][rp][c]) continue;\n\n            int lx=decode(lp).first,ly=decode(lp).second;\n            int rx=decode(rp).first,ry=decode(rp).second;\n            rep(dx,-5,5) rep(dy,-5,5){\n                auto renew=[&](int nlp,int nrp,int nc,int cost){\n                    if(verify(nlp,nrp) and d+cost<dist[nlp][nrp][nc]){\n                        dist[nlp][nrp][nc]=d+cost;\n                        que.push(make_pair(dist[nlp][nrp][nc],make_tuple(nlp,nrp,nc)));\n                    }\n                };\n                if(c==0){\n                    if(0<=lx+dx and lx+dx<w and 0<=ly+dy and ly+dy<h) renew(encode(lx+dx,ly+dy),rp,1-c,s[lx+dx][ly+dy]);\n                }else{\n                    if(0<=rx+dx and rx+dx<w and 0<=ry+dy and ry+dy<h) renew(lp,encode(rx+dx,ry+dy),1-c,s[rx+dx][ry+dy]);\n                }\n            }\n        }\n\n        int ans=inf;\n        rep(i,0,w*h) rep(j,0,2){\n            for(int ep:end_points){\n                ans=min(ans,dist[ep][i][j]);\n                ans=min(ans,dist[i][ep][j]);\n            }\n        }\n        if(ans==inf) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n\nstruct node_t {\n\tpair<int, int> p[2];\n\tnode_t(int x1, int y1, int x2, int y2) { \n\t\tp[0].first = y1;\n\t\tp[0].second = x1;\n\t\tp[1].first = y2;\n\t\tp[1].second = x2;\n\t}\n};\n\nint solve(void);\nbool isValid(int y, int x, int h, int w) {\n\treturn 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(void) {\n\t\t\n//\tFILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\twhile (solve());\n\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\t//\tinput\n\tint w, h;\n\n\tcin >> w >> h;\n\tif (!(w | h)) { return 0; }\n\n\ttypedef vector<int> v1;\n\ttypedef vector<v1> v2;\n\ttypedef vector<v2> v3;\n\ttypedef vector<v3> v4;\n\ttypedef pair<int, int> pii;\n\n\tvector< vector< char > > s(h, vector<char>(w));\n\tv4 costs(h, v3(w, v2(h, v1(w, (1 << 30)))));\n\n\tfor (int i = 0; i < h; i++)\n\t\tfor (int j = 0; j < w; j++)\n\t\t\tcin >> s[i][j];\n\t\t\n\t// right, down, left, up\n\tvector< vector< pii > > foot(2);\n\n\t//\tright foot\n\t//\t????¶????0,0???????????¨????????????\n\tfor (int i = -2; i <= 2; i++)\n\t\tfor (int j = 1; j < 4; j++)\n\t\t\tif (abs(i) + abs(j) <= 3) {\n\t\t\t\tfoot[0].push_back(pii(-i, -j));\n\t\t\t}\n\n\tfor (int i = 0; i < foot[0].size(); i++)\n\t\tfoot[1].push_back(pair<int, int>(-foot[0][i].first, -foot[0][i].second));\n\n\tvector< pii > startNode;\n\n\tfor (int i = 0; i < h; i++) \n\t\tfor (int j = 0; j < w; j++) \n\t\t\tif (s[i][j] == 'S') \n\t\t\t\tstartNode.push_back(pii(i, j));\n\t\t\t\n\tqueue< node_t > q;\n\n\tfor (int j = 0; j < 2; j++) {\n\t\tfor (int i = 0; i < startNode.size(); i++) {\n\t\t\tpii pp[2];\n\t\t\tpp[j] = startNode[i];\n\t\t\tfor (int k = 0; k < foot[1 - j].size(); k++) {\n\t\t\t\tpp[1 - j].first = pp[j].first + foot[1 - j][k].first;\n\t\t\t\tpp[1 - j].second = pp[j].second + foot[1 - j][k].second;\n\t\t\t\tif (isValid(pp[0].first, pp[0].second, h, w) & isValid(pp[1].first, pp[1].second, h, w)) {\n\t\t\t\t\tint weight = 0;\n\t\t\t\t\tif (pp[0].second >= pp[1].second) { continue; }\n\t\t\t\t\tif (s[pp[1 - j].first][pp[1 - j].second] == 'X') { continue; }\n\t\t\t\t\tif (s[pp[1 - j].first][pp[1 - j].second] != 'S') weight = s[pp[1 - j].first][pp[1 - j].second] - '0';\n\t\t\t\t\tcosts[pp[0].first][pp[0].second][pp[1].first][pp[1].second] = weight;\n\t\t\t\t\tq.push(node_t(pp[0].second,pp[0].first, pp[1].second, pp[1].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\n\t\tnode_t doneNode = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < foot[i].size(); j++) {\n\t\t\t\tnode_t next(doneNode);\n\t\t\t\tint weight = costs[next.p[0].first][next.p[0].second][next.p[1].first][next.p[1].second];\n\t\t\t\tnext.p[i].first = next.p[1-i].first + foot[i][j].first;\n\t\t\t\tnext.p[i].second = next.p[1 - i].second + foot[i][j].second;\n\t\t\t\tif (isValid(next.p[i].first, next.p[i].second, h, w) && next.p[0].second < next.p[1].second) {\n\t\t\t\t\tchar ch = s[next.p[i].first][next.p[i].second];\n\t\t\t\t\tif (ch >= '0' && ch <= '9') weight += ch - '0';\n\t\t\t\t\tif (ch == 'X') { continue; }\n\t\t\t\t\tif (weight < costs[next.p[0].first][next.p[0].second][next.p[1].first][next.p[1].second]) {\n\t\t\t\t\t\tcosts[next.p[0].first][next.p[0].second][next.p[1].first][next.p[1].second] = weight;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = (1 << 30);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int k = 0; k < h; k++) {\n\t\t\t\tfor (int l = 0; l < w; l++) {\n\t\t\t\t\tif (s[i][j] == 'T' || s[k][l] == 'T')\n\t\t\t\t\tans = min(ans, costs[i][j][k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == (1 << 30)) { ans = -1; }\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h) \n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 1,1,2,1,2,3,1,2,1 }; const int dy2[] = { -2, -1, -1, 0,0,0,1,1,2 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvvi cell(h, vi(w, -1));\n\t\tREP(i, h)\n\t\t\tREP(j, w) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (isdigit(c))\n\t\t\t\tcell[i][j] = c - '0';\n\t\t\tif (c == 'S' || c == 'T') {\n\t\t\t\tcell[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tmap<pair<pair<pii, pii>, bool>, int> G;\n\t\tpriority_queue<pair<int, pair<pair<pii, pii>, bool>>> Q;\n\t\tREP(i, w) {\n\t\t\tif (cell[h - 1][i] == 0) {\n\t\t\t\tG[{ { {h - 1, i}, { h - 1,i }}, false}] = 0;\n\t\t\t\tG[{ { {h - 1, i}, { h - 1,i }}, true}] = 0;\n\t\t\t\tQ.push({ 0,{{ { h - 1, i },{ h - 1,i } },false } });\n\t\t\t\tQ.push({ 0,{ { { h - 1, i },{ h - 1,i } },true } });\n\t\t\t}\n\t\t}\n\t\tint clear = -1;\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, pair<pair<pii, pii>, bool>> q = Q.top();Q.pop();\n\t\t\tq.first *= -1;\n\t\t\tint ly = q.second.first.first.first;\n\t\t\tint lx = q.second.first.first.second;\n\t\t\tint ry = q.second.first.second.first;\n\t\t\tint rx = q.second.first.second.second;\n\t\t\tbool lreg = q.second.second;\n\t\t\tif ((ly == 0 && cell[ly][lx] == 0) || (ry == 0 && cell[ry][rx] == 0)) {\n\t\t\t\tclear = q.first;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, 9) {\n\t\t\t\tint nly = ly;\n\t\t\t\tint nlx = lx;\n\t\t\t\tint nry = ry;\n\t\t\t\tint nrx = rx;\n\t\t\t\tif (lreg) {\n\t\t\t\t\tnry = ly + dy2[i];\n\t\t\t\t\tnrx = lx + dx2[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnly = ry + dy2[i];\n\t\t\t\t\tnlx = rx - dx2[i];\n\t\t\t\t}\n\t\t\t\tif (WRAP(nlx, nly, w, h) && WRAP(nrx, nry, w, h) && cell[nly][nlx] != -1 && cell[nry][nrx] != -1) {\n\t\t\t\t\tif ((G.find({ { {nly,nlx} , {nry,nrx} },!lreg }) == G.end())\n\t\t\t\t\t\t|| (G.find({ { { nly,nlx } ,{ nry,nrx } },!lreg }) != G.end() && G[{ { {nly, nlx}, { nry,nrx } }, !lreg }] > q.first + (!lreg ? cell[nly][nlx] : cell[nry][nrx]))) {\n\t\t\t\t\t\tG[{ { {nly, nlx}, { nry,nrx } }, !lreg }] = q.first + (!lreg ? cell[nly][nlx] : cell[nry][nrx]);\n\t\t\t\t\t\tQ.push({ -q.first - (!lreg ? cell[nly][nlx] : cell[nry][nrx]),{ { { nly,nlx } ,{ nry,nrx } },!lreg } });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int& _b, int &_m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint& _b, lint &_m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int& _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint& _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int& _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint& _b) { _a = max(_a, _b); }\n\n// 0 : right foot 1 : left foot\nint dx[2][9] = {\n\t{ 1, 1, 1, 1, 1, 2, 2, 2, 3 },\n\t{ -1, -1, -1, -1, -1, -2, -2, -2, -3 }\n};\nint dy[2][9] = {\n\t{ 2, 1, 0, -1, -2, 1, 0, -1, 0 },\n\t{ 2, 1, 0, -1, -2, 1, 0, -1, 0 }\n};\n\nstruct State {\n\tint x, y, c, f;\n\tState(int _x, int _y, int _c, int _f) : x(_x), y(_y), c(_c), f(_f) {}\n};\nbool operator > (const State& a, const State& b) { return a.c > b.c; }\n\nint W, H;\nchar grid[66][33];\n\nint cost[66][33][2];\n\nvoid solve() {\n\tfor_(y,0,H) for_(x,0,W) fill(cost[y][x], cost[y][x] + 2, iINF);\n\t\n\tpriority_queue< State, vector< State >, greater< State > > q;\n\t\n\tfor_(x,0,W) {\n\t\tif (grid[H - 1][x] == 'S') {\n\t\t\tq.push(State(x, H - 1, 0, 0));\n\t\t\tcost[H - 1][x][0] = 0;\n\t\t\tq.push(State(x, H - 1, 0, 1));\n\t\t\tcost[H - 1][x][1] = 0;\t\t\t\n\t\t}\n\t}\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\t\n\t\tif (cost[s.y][s.x][s.f] < s.c) continue;\n\t\t\n\t\tfor_(d,0,9) {\n\t\t\tint nx = s.x + dx[s.f][d], ny = s.y + dy[s.f][d];\n\t\t\tif (!in_range(nx, ny, W, H)) continue;\n\t\t\t\n\t\t\tchar tmp = grid[ny][nx];\n\t\t\tif (tmp == 'X') continue;\n\t\t\t\n\t\t\tint nc = 0;\n\t\t\tif (tmp != 'S' && tmp != 'T') nc = tmp - '0';\n\t\t\t\n\t\t\tif (cost[ny][nx][1 - s.f] > s.c + nc) {\n\t\t\t\tcost[ny][nx][1 - s.f] = s.c + nc;\n\t\t\t\tq.push(State(nx, ny, s.c + nc, 1 - s.f));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = iINF;\n\tfor_(x,0,W) if (grid[0][x] == 'T') {\n\t\tminUpdate(ans, cost[0][x][0]);\n\t\tminUpdate(ans, cost[0][x][1]);\n\t}\n\t\n\tif (ans == iINF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> grid[y][x];\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Foot{\n\tLeft,\n\tRight,\n};\n\nint H,W;\nint***** min_Time;\n\nint diff_row_right[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_right[9] = {1,1,2,1,2,3,1,2,1};\nint diff_row_left[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_left[9] = {-1,-2,-1,-3,-2,-1,-2,-1,-1};\n\nstruct Info{\n\tInfo(){\n\t\tleft_row = left_col = right_row = right_col = time = 0;\n\t\tfoot = Left;\n\t}\n\n\tInfo(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tvoid set(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tint left_row,left_col,right_row,right_col,time;\n\tFoot foot;\n};\n\nstruct Cell{\n\tCell(){\n\t\trow = col = 0;\n\t}\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\tmin_Time[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Cell> V;\n\n\tchar map[H][W+1];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%s\",&map[i][k]);\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tV.push_back(Cell(i,k));\n\t\t\t\tmap[i][k] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tint first_left_row,first_left_col,first_right_row,first_right_col,add_time;\n\n\tfor(int a = 0; a < V.size(); a++){\n\n\t\tfirst_left_row = V[a].row;\n\t\tfirst_left_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_right_row = first_left_row + diff_row_right[i];\n\t\t\tfirst_right_col = first_left_col + diff_col_right[i];\n\n\t\t\tif(rangeCheck(first_right_row,first_right_col) == true && map[first_right_row][first_right_col] != 'X'){\n\t\t\t\tif(map[first_right_row][first_right_col] >= '0' && map[first_right_row][first_right_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_right_row][first_right_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Right));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfirst_right_row = V[a].row;\n\t\tfirst_right_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_left_row = first_right_row + diff_row_left[i];\n\t\t\tfirst_left_col = first_right_col + diff_col_left[i];\n\n\t\t\tif(rangeCheck(first_left_row,first_left_col) == true && map[first_left_row][first_left_col] != 'X'){\n\t\t\t\tif(map[first_left_row][first_left_col] >= '0' && map[first_left_row][first_left_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_left_row][first_left_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Left));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM,next_left_row,next_left_col,next_right_row,next_right_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().left_row][Q.front().left_col] == 'T' || map[Q.front().right_row][Q.front().right_col] == 'T'){\n\t\t\tans = min(ans,Q.front().time);\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > min_Time[Q.front().left_row][Q.front().left_col][Q.front().right_row][Q.front().right_col][Q.front().foot]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(Q.front().foot == Left){\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_right_row = Q.front().left_row + diff_row_right[i];\n\t\t\t\t\tnext_right_col = Q.front().left_col + diff_col_right[i];\n\n\t\t\t\t\tif(rangeCheck(next_right_row,next_right_col) == true && map[next_right_row][next_right_col] != 'X'){\n\t\t\t\t\t\tif(map[next_right_row][next_right_col] >= '0' && map[next_right_row][next_right_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_right_row][next_right_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[Q.front().left_row][Q.front().left_col][next_right_row][next_right_col][Right] > Q.front().time+add_time){\n\t\t\t\t\t\t\tmin_Time[Q.front().left_row][Q.front().left_col][next_right_row][next_right_col][Right] = Q.front().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(Q.front().left_row,Q.front().left_col,next_right_row,next_right_col,Q.front().time+add_time,Right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //Q.front().foot == Right\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_left_row = Q.front().right_row + diff_row_left[i];\n\t\t\t\t\tnext_left_col = Q.front().right_col + diff_col_left[i];\n\n\t\t\t\t\tif(rangeCheck(next_left_row,next_left_col) == true && map[next_left_row][next_left_col] != 'X'){\n\t\t\t\t\t\tif(map[next_left_row][next_left_col] >= '0' && map[next_left_row][next_left_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_left_row][next_left_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[next_left_row][next_left_col][Q.front().right_row][Q.front().right_col][Left] > Q.front().time+add_time){\n\t\t\t\t\t\t\tmin_Time[next_left_row][next_left_col][Q.front().right_row][Q.front().right_col][Left] = Q.front().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(next_left_row,next_left_col,Q.front().right_row,Q.front().right_col,Q.front().time+add_time,Left));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_Time = new int****[60];\n\tfor(int i = 0; i < 60; i++){\n\t\tmin_Time[i] = new int***[30];\n\t\tfor(int k = 0; k < 30; k++){\n\t\t\tmin_Time[i][k] = new int**[60];\n\t\t\tfor(int p = 0; p < 60; p++){\n\t\t\t\tmin_Time[i][k][p] = new int*[30];\n\t\t\t\tfor(int q = 0; q < 30; q++)min_Time[i][k][p][q] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f;\n\t\t\t\t\tf.ly = f.ry = i;\n\t\t\t\t\tf.lx = f.rx = j;\n\t\t\t\t\tf.p = 1;\n\t\t\t\t\tf.cnt = 0;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t\tf.p = 2;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\tif(field[temp.ry][temp.rx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\tif(field[temp.ly][temp.lx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n//passed all test cases\n//but couldnt pass"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[]={2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nint L = 0, R = 1;\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n        \n        vector<vector<string>> s(h, vector<string>(w));\n        queue<T> lque, rque;\n        int ldist[h][w][2], rdist[h][w][2];\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                for(int k=0; k<2; k++){\n                    ldist[i][j][k] = 1e9;\n                    rdist[i][j][k] = 1e9;\n                }\n            }\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>>s[i][j];\n                \n                if(s[i][j] == \"S\"){\n                    ldist[i][j][L] = 0;\n                    rdist[i][j][R] = 0;\n                    lque.push(T(i, j, 0));\n                    rque.push(T(i, j, 0));\n                }\n            }\n        }\n\n        // from left\n        int ans = 1e9;\n        while(lque.size()){\n            int cy, cx, cnt;\n            tie(cy, cx, cnt) = lque.front();\n            lque.pop();\n\n            int cleg, nleg;\n            if(cnt % 2 == 0){\n                cleg = L;\n                nleg = R;\n            }\n            else{\n                cleg = R;\n                nleg = L;\n            }\n\n            for(int i=0; i<9; i++){\n                int ny = cy + (cnt % 2 == 0 ? dy[i] : - dy[i]);\n                int nx = cx + (cnt % 2 == 0 ? dx[i] : - dx[i]);\n\n                if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                    if(\"1\" <= s[ny][nx] && s[ny][nx] <= \"9\"){\n                        if(ldist[cy][cx][cleg] + stoi(s[ny][nx]) < ldist[ny][nx][nleg]){\n                            ldist[ny][nx][nleg] = ldist[cy][cx][cleg] + stoi(s[ny][nx]);\n                            lque.push(T(ny, nx, cnt + 1));\n                        }\n                    }\n                    else if(s[ny][nx] == \"T\"){\n                        ans = min(ans, ldist[cy][cx][cleg]);\n                    }\n                }\n            }\n        }\n\n        // from right\n        while(rque.size()){\n            int cy, cx, cnt;\n            tie(cy, cx, cnt) = rque.front();\n            rque.pop();\n\n            int cleg, nleg;\n            if(cnt % 2 == 1){\n                cleg = L;\n                nleg = R;\n            }\n            else{\n                cleg = R;\n                nleg = L;\n            }\n\n            for(int i=0; i<9; i++){\n                int ny = cy + (cnt % 2 == 1 ? dy[i] : - dy[i]);\n                int nx = cx + (cnt % 2 == 1 ? dx[i] : - dx[i]);\n\n                if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                    if(\"1\" <= s[ny][nx] && s[ny][nx] <= \"9\"){\n                        if(rdist[cy][cx][cleg] + stoi(s[ny][nx]) < rdist[ny][nx][nleg]){\n                            rdist[ny][nx][nleg] = rdist[cy][cx][cleg] + stoi(s[ny][nx]);\n                            rque.push(T(ny, nx, cnt + 1));\n                        }\n                    }\n                    else if(s[ny][nx] == \"T\"){\n                        ans = min(ans, rdist[cy][cx][cleg]);\n                    }\n                }\n            }\n        }\n\n        cout << (ans == 1e9 ? -1 : ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\n\nconst int INF = 1 << 28;\n\nint dlx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nint drx[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint dy[]  = {-2,-1, 0, 1, 2,-1, 0, 1, 0};\n\n\nint main ()\n{\n    int h, w;\n    while (cin >> w >> h, h + w) {\n        vector<vector<int> > field(h, vector<int>(w, INF));\n        vector<P> s;\n        vector<P> t;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char str;\n                cin >> str;\n                if ('0' <= str && str <= '9') {\n                    field[i][j] = (int)(str - '0');\n                } else if (str == 'T') {\n                    field[i][j] = 0;\n                    t.push_back(P(i,j));\n                } else if (str == 'S') {\n                    field[i][j] = 0;\n                    s.push_back(P(i,j));\n                } else if (str == 'X') {\n                    field[i][j] = INF;\n                }\n            }\n        }\n\n        priority_queue<PPP, vector<PPP>, greater<PPP> > que;\n        vector<vector<vector<int> > > d(2, vector<vector<int> >(h, vector<int>(w, INF)));\n        for (int i = 0; i < s.size(); i++) {\n            que.push(PPP(0, PP(0, P(s[i])) ) );\n            que.push(PPP(0, PP(1, P(s[i])) ) );\n            d[0][s[i].first][s[i].second] = 0;\n            d[1][s[i].first][s[i].second] = 0;\n        }\n\n        while (que.size()) {\n            PPP ppp = que.top(); que.pop();\n            int cost = ppp.first;\n            PP pp = ppp.second;\n            int dir = pp.first;\n            int y = pp.second.first;\n            int x = pp.second.second;\n\n            if (d[dir][y][x] < cost) continue;\n\n            for (int i = 0; i < 9; i++) {\n                int nx = x, ny = dy[i] + y;\n                nx += dir == 1 ? dlx[i] : drx[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != INF) {\n                    if (d[1 - dir][ny][nx] > cost + field[ny][nx]) {\n                        d[1 - dir][ny][nx] = cost + field[ny][nx];\n                        que.push(PPP(d[1 - dir][ny][nx], PP(1 - dir, P(ny, nx) ) ) );\n                    }\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < t.size(); i++) {\n            int y = t[i].first;\n            int x = t[i].second;\n            res = min(res, d[0][y][x]);\n            res = min(res, d[1][y][x]);\n        }\n\n        cout << (INF == res ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\n  int x_next[9] = {1,1,1,1,1,2,2,2,3};\n  int y_next[9] = {-2,-1,0,1,2,-1,0,1,0};\n\n  while(true) {\n\n    int w,h;\n    cin >> w >> h;\n    if ( w == 0 ) break;\n\n    char input;\n    int map[30][60];\n    int time_r[30][60] = {0};\n    int time_l[30][60] = {0};\n    vector<int> xr,yr,xl,yl;\n\n    for ( int i = 0; i < h; i++ ) {\n      for ( int j = 0; j < w; j++ ) {\n\tcin >> input;\n\tif ( input == 'S' ) {\n\t  xr.push_back(j);\n\t  yr.push_back(i);\n\t  xl.push_back(j);\n\t  yl.push_back(i);\n\t  map[j][i] = -1;\n\t}else if ( input == 'T' ) {\n\t  map[j][i] = 0;\n\t}else if ( input == 'X' ) {\n\t  map[j][i] = -1;\n\t}else {\n\t  map[j][i] = input - '0';\n\t}\n      }\n    }\n\n    while(true) {\n\n      for ( int i = 0; i < xl.size(); i++ ) {\n\tfor ( int j = 0; j < 9; j++ ) {\n\n\t  int x = xl[i] + x_next[j];\n\t  int y = yl[i] + y_next[j];\n\t  if ( x < 0 || x >= w || y < 0 || y >= h ) continue;\n\n\t  if ( map[x][y] >= 0 ) {\n\t    int t = time_l[ xl[i] ][ yl[i] ] + map[x][y];\n\t    if ( time_r[x][y] == 0 || time_r[x][y] > t ) {\n\t      time_r[x][y] = t;\n\t      if ( map[x][y] > 0 ) {\n\t\txr.push_back(x);\n\t\tyr.push_back(y);\n\t      }\n\t    }\n\t  }\n\n\t}\n      }\n      if ( xr.size() == 0 ) break;\n      xl.clear();\n      yl.clear();\n\n      for ( int i = 0; i < xr.size(); i++ ) {\n\tfor ( int j = 0; j < 9; j++ ) {\n\n\t  int x = xr[i] - x_next[j];\n\t  int y = yr[i] + y_next[j];\n\t  if ( x < 0 || x >= w || y < 0 || y >= h ) continue;\n\n\t  if ( map[x][y] >= 0 ) {\n\t    int t = time_r[ xr[i] ][ yr[i] ] + map[x][y];\n\t    if ( time_l[x][y] == 0 || time_l[x][y] > t ) {\n\t      time_l[x][y] = t;\n\t      if ( map[x][y] > 0 ) {\n\t\txl.push_back(x);\n\t\tyl.push_back(y);\n\t      }\n\t    }\n\t  }\n\n\t}\n      }\n      if ( xl.size() == 0 ) break;\n      xr.clear();\n      yr.clear();\n\n    }\n\n    int cnt = -1;\n    for ( int i = 0; i < w; i++ ) {\n      if ( map[i][0] == 0 ) {\n\tint t = time_r[i][0];\n\tif ( t == 0 ) t = time_l[i][0];\n\tif ( t > time_l[i][0] && time_l[i][0] != 0 ) t = time_l[i][0];\n\tif ( t == 0 ) continue;\n\tif ( cnt == -1 || t < cnt ) cnt = t;\n      }\n    }\n\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<string>\n#include<stdlib.h>\nconst int INF = 11 * 4 * 51 * 4 * 114514;\nusing namespace std;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<VVV> VVVV;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint w, h;\n\twhile (cin >> w >> h, w + h){\n\t\tint R = h;\n\t\tint C = w;\n\n\n\t\tvector<string> S(R);\n\t\trep(i, R)rep(j,C){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tS[i] += s;\n\t\t}\n\t\tusing P=tuple<int, int>;\n\t\tusing PPP = tuple<int,int, P>;\n\t\tvector<P> goal;\n\t\tvector<P> start;\n\t\tvector<vector<int>> cost(R + 10, vector<int>(C + 10,INF));\n\t\trep(r, R)rep(c, C){\n\t\t\tif (S[r][c] == 'S'){\n\t\t\t\tcost[r + 5][c + 5] = 0;\n\t\t\t\tstart.push_back(P(r + 5, c + 5));\n\t\t\t}\n\t\t\telse if (S[r][c] == 'T'){\n\t\t\t\tcost[r + 5][c + 5] = 0;\n\t\t\t\tgoal.push_back(P(r + 5, c + 5));\n\t\t\t}\n\t\t\telse if (S[r][c] == 'X')continue;\n\t\t\telse{\n\t\t\t\tcost[r + 5][c + 5] = S[r][c] - '0';\n\t\t\t}\n\t\t}\n\t\tR += 10, C += 10;\n\t\tVVV dp(2 ,VV(R,V(C, INF)));\n\t\tint m = start.size();\n\t\tauto check = [&](int lr, int lc, int rr, int rc){return lc < rc&&abs(lc - rc) + abs(lr - rr) <= 3; };\n\t\tpriority_queue<PPP> que;\n\t\trep(i, m){\n\t\t\tint r,c;\n\t\t\ttie(r, c) = start[i];\n\t\t\tdp[0][r][c] = 0;\n\t\t\tdp[1][r][c] = 0;\n\t\t\tque.push(PPP(0, 0, P(r, c)));\n\t\t\tque.push(PPP(0, 1, P(r, c)));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tauto v = que.top(); que.pop();\n\t\t\tint d, type; P pos;\n\t\t\ttie(d,type, pos) = v;\n\t\t\tint r, c;\n\t\t\ttie(r, c) = pos;\n\t\t\tif (dp[type][r][c]<-d)continue;\n\t\t\tif (type == 0){\n\t\t\t\trep(i, 3)rep(j, 5){\n\t\t\t\t\tint nc = c + i + 1;\n\t\t\t\t\tint nr = r - 2 + j;\n\t\t\t\t\tif (check(r, c, nr, nc) && dp[1-type][nr][nc]>dp[type][r][c] + cost[nr][nc]){\n\t\t\t\t\t\tdp[1 - type][nr][nc]=dp[type][r][c] + cost[nr][nc];\n\t\t\t\t\t\tque.push(PPP(-dp[1-type][nr][nc],1-type, P(nr, nc)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\trep(i, 3)rep(j, 5){\n\t\t\t\tint nc = c - i - 1;\n\t\t\t\tint nr = r - 2 + j;\n\t\t\t\tif (check(nr, nc, r, c) && dp[1 - type][nr][nc]>dp[type][r][c] + cost[nr][nc]){\n\t\t\t\t\tdp[1 - type][nr][nc] = dp[type][r][c] + cost[nr][nc];\n\t\t\t\t\tque.push(PPP(-dp[1 - type][nr][nc], 1 - type, P(nr, nc)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\n\t\tm = goal.size();\n\t\trep(i, m){\n\t\t\tint r, c;\n\t\t\ttie(r, c) = goal[i];\n\t\t\tres = min({ res, dp[0][r][c], dp[1][r][c] });\n\t\t}\n\t\tif (res == INF)cout << -1 << endl;\n\t\telse\n\t\tcout << res << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_W 30\n#define MAX_H 60\nchar field[MAX_H][MAX_W];\n\nstruct P\n{\n    int x,y,cost,w;\n    bool operator >(const P &p) const{\n        return cost>p.cost;\n    }\n};\n\nint dx[]={\n    1,1,1,1,1,2,2,2,3\n};\nint dy[]={\n    -2,-1,0,1,2,-1,0,1,0\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, MAX_W*MAX_H, 'X');\n\n        priority_queue<P, vector<P>, greater<P> >que;\n\n        REP(y,h)REP(x,w){\n            cin >> field[y][x];\n            if(field[y][x]=='S'){\n                que.push({x, y, 0, 1});\n                que.push({x, y, 0,-1});\n            }\n        }\n\n        vvi GL(h, vi(w, INF));\n        vvi GR(h, vi(w, INF));\n\n        int res=-1;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n\n            if(field[p.y][p.x]=='T'){\n                res=p.cost;\n                break;\n            }\n\n            REP(i, 9){\n                int sx=p.x+dx[i]*p.w;\n                int sy=p.y+dy[i];\n                if(0<=sx&&sx<w&&0<=sy&&sy<h){\n                    int cost=p.cost;\n                    switch(field[sy][sx]){\n                    case 'T':\n                    case 'S':\n                        break;\n                    case 'X':\n                        continue;\n                    default:\n                        cost+=field[sy][sx]-'0';\n                        break;\n                    }\n                    bool t=true;\n                    if(p.w>0&&GR[sy][sx]>cost){\n                        GR[sy][sx]=cost;\n                        t=false;\n                    }else if(p.w<0&&GL[sy][sx]>cost){\n                        GL[sy][sx]=cost;\n                        t=false;\n                    }\n                    if(t)continue;\n                    que.push({sx, sy, cost, -p.w});\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nconst int INF = 999999;\n\nclass Node{\npublic:\n\tint x, y, foot, cost;\n\tNode(int x, int y, int foot, int cost) : x(x), y(y), foot(foot), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nint main(){\n\tint w, h;\n\tchar b[60][30];\n\tbool visit[2][60][30];\n\tint dist[2][60][30];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint ans = INF;\n\t\tpriority_queue<Node> qu;\n\t\tmemset(visit, false, sizeof(visit));\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> b[i][j];\n\t\t\t\tif(isdigit(b[i][j])) b[i][j] -= '0';\n\t\t\t\telse if(b[i][j] == 'S'){\n\t\t\t\t\tqu.push(Node(j,i,0,0));\n\t\t\t\t\tqu.push(Node(j,i,1,0));\n\t\t\t\t\tdist[0][i][j] = 0;\n\t\t\t\t\tdist[1][i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!qu.empty()){\n\t\t\tNode e = qu.top(); qu.pop();\n\t\t\tif(visit[e.foot][e.y][e.x]) continue;\n\t\t\tif(b[e.y][e.x]=='T'){\n\t\t\t\tans = e.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvisit[e.foot][e.y][e.x] = true;\n\t\t\tfor(int dx=1;dx<=3;dx++){\n\t\t\t\tfor(int dy=dx-3;dy<=3-dx;dy++){\n\t\t\t\t\tint x = e.x + (e.foot ? -dx : dx);\n\t\t\t\t\tint y = e.y + dy;\n\t\t\t\t\tif(x<0||x>=w||y<0||y>=h||visit[(1+e.foot)%2][y][x]) continue;\n\t\t\t\t\tif(b[y][x]=='X'||b[y][x]=='S') continue;\n\t\t\t\t\tif(dist[(1+e.foot)%2][y][x] > e.cost + (b[y][x]!='T'?b[y][x]:0)){\n\t\t\t\t\t\tdist[(1+e.foot)%2][y][x] = e.cost + (b[y][x]!='T'?b[y][x]:0);\n\t\t\t\t\t\tqu.push(Node(x,y,(1+e.foot)%2,e.cost+(b[y][x]!='T'?b[y][x]:0)));\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;  \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nstruct Data {\n\tint y, x;\n\tint cost;\n\tbool nextr;\n\tData(int y, int x, int c, bool n) : y(y), x(x), cost(c), nextr(n) {}\n\tbool operator< (const Data& d)const {\n\t\treturn cost > d.cost;\n\t}\n};\n\nint w, h;\nbool valid(int y, int x) {\n\treturn 0<=y && y<h && 0<=x && x<w;\n}\n\nconst int dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int drx[] = {-1, -2, -1, -3, -2, -1, -2, -1, -1};\nbool visited[2][100][100];\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\trep(i, 2) rep(j, 100) rep(k, 100)\n\t\t\tvisited[i][j][k] = false;\n\n\t\tchar field[100][100];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar tmp[100];\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tfield[i][j] = tmp[0];\n\t\t}\n\n\t\tpriority_queue<Data> Q;\n\t\trep(i, w){\n\t\t\tif(field[h-1][i] == 'S'){\n\t\t\t\tQ.push(Data(h-1, i, 0, false));\n\t\t\t\tQ.push(Data(h-1, i, 0, true));\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(visited[d.nextr][d.x][d.y])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.nextr][d.x][d.y] = true;\n\t\t\tif(field[d.y][d.x] == 'T'){\n\t\t\t\tans = d.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 9){\n\t\t\t\tint py = d.y + dy[i];\n\t\t\t\tint px = d.x + drx[i] * (d.nextr ? 1 : -1);\n\t\t\t\tif(!valid(py, px))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tchar c = field[py][px];\n\t\t\t\tif(c == 'X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint pc = d.cost + (isdigit(c) ? c-'0' : 0);\n\t\t\t\tQ.push(Data(py, px, pc, !d.nextr));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct State{\n  int x,y,t;\n  bool isR;\n  State(){}\n  State(int a, int b, int c, bool d):\n    x(a),y(b),t(c),isR(d){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nconst int MW = 31;\nconst int MH = 51;\nconst int INF = (1<<25);\n\nint M[MH][MW],T[MH][MW][2],w,h;\nvector<P> S;\nvector<P> G;\n\nvoid print(){\n  for(int i = 0; i < h; i++){\n    for(int x = 0; x < 2; x++){\n      for(int j = 0; j < w; j++) \n\tif(T[i][j][x] == INF) cout << \"  X\";\n\telse printf(\"%3d\",T[i][j][x]);\n      cout << \"                 \";\n    } \n    cout << endl;\n  }\n  cout << endl << endl;\n}\n\nbool isInside(int x, int y) {return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  for(int i = 0; i < MH; i++)\n    for(int j = 0; j < MW; j++) T[i][j][0] = T[i][j][1] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      char c;\n      cin >> c;\n      if(c == 'X') M[i][j] = INF;\n      else if(c == 'T'){\n\tM[i][j] = 0;\n\tG.push_back(P(j,i));\n      }else if(c == 'S'){\n\tM[i][j] = 0;\n\tS.push_back(P(j,i));\n      }else M[i][j] = c-'0';\n    }\n}\n\nint solve(bool R){\n  \n  init();\n\n  priority_queue<State> Q;\n\n  for(int i = 0; i < S.size(); i++){\n    int sx = S[i].first;\n    int sy = S[i].second;\n    Q.push(State(sx,sy,0,R));\n    T[sy][sx][R] = 0;\n  }\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    if(T[now.y][now.x][now.isR] < now.t) continue;\n    \n    for(int i = 1; i <= 3; i++)\n      for(int j = -2; j <= 2; j++){\n\tint mx = i,my = j;\n\tif(now.isR) mx *= -1;\n\tint nx = now.x+mx;\n\tint ny = now.y+my;\n\t\n\t//\tif(abs(mx) + abs(my) <= 3) cout << now.isR << \" \" <<  mx << \" \" << my << \" \" << endl;\n\tif(isInside(nx,ny) && abs(mx)+abs(my) <= 3 && T[ny][nx][!now.isR] > now.t+M[ny][nx]){\n\t  T[ny][nx][!now.isR] = now.t+M[ny][nx];\n\t  Q.push(State(nx,ny,now.t+M[ny][nx],!now.isR));\n\t}\n      }\n  }\n\n  //print();\n  int ans = INF;\n\n  for(int i = 0; i < G.size(); i++) ans = min(ans,min(T[G[i].second][G[i].first][0],T[G[i].second][G[i].first][1]));\n\n  return ans;\n}\n\nint main(){\n\n  while(cin >> w >> h && w+h){\n    S.clear();\n    G.clear();\n    input();\n    cerr << \" input end \" << endl;\n    int ans = min(solve(true),solve(false));\n    cerr << \" solve end \" << endl;\n    if(ans == INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\nll dp[65][35][3];\nint main() {\n\tint w, h;\n\tint dx[9] = { 1,1,2,1,2,3,1,2,1 }, dy[9] = { -2,-1,-1,0,0,0,1,1,2 };\n\tchar s[65][35];\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tdp[i][j][0] = dp[i][j][1] = 0LL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto isOutOfRange = [] (int x, int y, int h, int w){\n\t\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t\t};\n\t\tauto cost = [&](int x, int y) {\n\t\t\tif (s[y][x] == 'X') return INF;\n\t\t\tif (s[y][x] == 'S') return INF;\n\t\t\tif (s[y][x] == 'T') return 0LL;\n\t\t\treturn (ll)s[y][x] - '0';\n\t\t};\n\t\twhile(1){\n\t\t\tbool f = false;\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int now = 0; now < 2; now++) {\n\t\t\t\t\t\tif (dp[y][x][now] == INF) continue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + (now==0?dx[i]:-dx[i]), ny = y + dy[i], nxt = (now + 1) % 2;\n\t\t\t\t\t\t\tif (isOutOfRange(nx, ny, h, w) || s[ny][nx] == 'X') continue;\n\t\t\t\t\t\t\t//dp[ny][nx][nxt] = min(dp[ny][nx][nxt], dp[y][x][now] + cost(nx, ny));\n\t\t\t\t\t\t\tif (dp[ny][nx][nxt] > dp[y][x][now] + cost(nx, ny)) {\n\t\t\t\t\t\t\t\tdp[ny][nx][nxt] = dp[y][x][now] + cost(nx, ny);\n\t\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f == false) break;\n\t\t}\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcout << \"(\" << (dp[i][j][0]==INF?-1:dp[i][j][0]) << \", \" << (dp[i][j][1]==INF?-1:dp[i][j][1])<< \")\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tll ans = INF;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] != 'T') continue;\n\t\t\t\tans = min({ ans, dp[i][j][0], dp[i][j][1] });\n\t\t\t}\n\t\t}\n\t\tif (ans == INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef pair<int,int> P;\nint dw[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dh[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\nchar mp[61][31];\nint dis[2][60][30];\nint w,h,ans;\nvoid dijkstra(int si,int sj, int sk){\n\trep(i,2) rep(j,h) rep(k,w) dis[i][j][k]=1e+8;\n\tdis[si][sj][sk]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,si*h*w+sj*w+sk));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint vs=p.second;\n\t\tint vi=vs/(h*w),vj=(vs/w)%h,vk=vs%w;\n\t\tif(dis[vi][vj][vk]<p.first) continue;\n\t\trep(i,9){\n\t\t\tint nj=vj+dh[vi][i],nk=vk+dw[vi][i],ni=1-vi;\n\t\t\tif(0<=nj && nj<h && 0<=nk && nk<w && mp[nj][nk]!='X' && mp[nj][nk]!='S'){\n\t\t\t\tint &dn=dis[ni][nj][nk],&dv=dis[vi][vj][vk],cost=0;\n\t\t\t\tif(mp[nj][nk]!='T') cost=mp[nj][nk]-'0';\n\t\t\t\tif(dn>dv+cost){\n\t\t\t\t\tdn=dv+cost;\n\t\t\t\t\tque.push(P(dn,ni*h*w+nj*w+nk));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(j,w) if(mp[0][j]=='T') rep(i,2) ans=min(ans,dis[i][0][j]);\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0) break;\n\t\tans=1e+8;\n\t\trep(i,h) rep(j,w) scanf(\" %c\",&mp[i][j]);\n\t\trep(j,w) if(mp[h-1][j]=='S') rep(i,2) dijkstra(i,h-1,j);\n\t\tif(ans==1e8) ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[66][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint mincost[2][66][33];\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  for(int i = 0; i < 66; i++) {\n    for(int j = 0; j < 33; j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[(lr+1)%2][ny][nx]) {\n\t  mincost[(lr+1)%2][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, (lr+1)%2), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint w,h;\nchar s[99][99];\nint cost[30][60][30][60][2];\n\nstruct Node{\n  int lx,ly,rx,ry;\n  int foot,cost;\n  bool operator<(const Node &r)const{\n    return cost>r.cost;\n  }\n};\nbool ok(Node &node){\n  int lx=node.lx,rx=node.rx,ly=node.ly,ry=node.ry;\n  if(lx<0||rx<0||ly<0||ry<0||lx>=w||rx>=w||ly>=h||ry>=h)return 0;\n     if(s[ly][lx]=='X'||s[ry][rx]=='X')return 0;\n     return lx<rx&&abs(lx-rx)+abs(ly-ry)<=3;\n}\n\nint main()\n{\n  while(cin>>w>>h,w){\n  \n    rep(i,h)rep(j,w)rep(ii,h)rep(jj,w)rep(k,2)cost[i][j][ii][jj][k]=inf;\n\n    priority_queue<Node>Q;\n    rep(i,h)rep(j,w){\n      cin>>s[i][j];\n      if(s[i][j]=='S'){\n\tNode node;\n\tnode.ry=-inf,node.rx=-inf;\n\tnode.ly=i,node.lx=j; node.foot=node.cost=0;\n\tQ.push(node);\n\tswap(node.ry,node.ly); swap(node.rx,node.lx);\n\tnode.foot=1;\n\tQ.push(node);\n      }\n    }\n    int ans=inf;\n    while(!Q.empty()){\n      Node cur=Q.top();\n      //dbg(cur.ly);dbg(cur.lx);dbg(cur.ry);dbg(cur.rx);\n      //dbg(cur.cost);dbg(cur.foot);\n      Q.pop();\n    \n      if(ok(cur)&&(s[cur.ly][cur.lx]=='T'||s[cur.ry][cur.rx]=='T')){\n\tans=cur.cost; break;\n      }\n\n      rep(y,h)rep(x,w){\n\tNode node=cur;\n\tif(node.foot==0)node.ry=y,node.rx=x;\n\telse node.ly=y,node.lx=x;\n\tnode.foot^=1;\n\tif(!ok(node))continue;\n\n\tnode.cost+=isdigit(s[y][x])?s[y][x]-'0':0;\n\tint &c=cost[node.ly][node.lx][node.ry][node.rx][node.foot];\n\tif(node.cost>=c)continue;\n\t\n\tc=node.cost;\n\tQ.push(node);\n      }\n    }\n    cout<<(ans==inf?-1:ans)<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define INF (1e9)\n#define H 60\n#define W 30\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<char,P> P1;\ntypedef pair<int,P1> P2;\nint dijkstra(int,int,char);\nint w,h,dl[H][W],dr[H][W],ans;\nchar s[H][W];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>s[i][j];\n    ans=INF;\n    for(int i=0;i<w;i++)\n      if(s[h-1][i]=='S') ans=min(ans,min(dijkstra(h-1,i,'l'),dijkstra(h-1,i,'r')));\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;    \n  }\n  return 0;\n}\n\nint dijkstra(int sy,int sx,char lr){\n  priority_queue<P2> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) dl[i][j]=dr[i][j]=INF;\n  q.push(P2(0,P1(lr,P(sy,sx))));\n  if(lr=='l') dl[sy][sx]=0;\n  else dr[sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    char c=t.second.first;\n    int cost=t.first,y=t.second.second.first,x=t.second.second.second;\n    int dy[9]={0,0,0,-1,-1,-2,1,1,2},dx[9]={1,2,3,1,2,1,1,2,1};\n    if(c=='l'&&dr[y][x]<cost) continue;\n    if(c=='r'&&dl[y][x]<cost) continue;\n    for(int i=0;i<9;i++){\n      int ny,nx;\n      ny=y+dy[i];\n      if(c=='l') nx=x+dx[i];\n      else nx=x-dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx||s[ny][nx]=='X'||s[ny][nx]=='S') continue;\n      if(s[ny][nx]=='T'){\n\tif(c=='l') dr[ny][nx]=min(dr[ny][nx],cost);\n\telse dl[ny][nx]=min(dl[ny][nx],cost);\n      }\n      else if(c=='l'&&dr[ny][nx]>cost+s[ny][nx]-'0'){\n\tdr[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(dr[ny][nx],P1('r',P(ny,nx))));\n      }\n      else if(c=='r'&&dl[ny][nx]>cost+s[ny][nx]-'0'){\n\tdl[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(dl[ny][nx],P1('l',P(ny,nx))));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<w;i++)\n    if(s[0][i]=='T') res=min(res,min(dl[0][i],dr[0][i]));\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 180000\n\nint t[60][30];\nint ml[60][30];\nint mr[60][30];\n\nint main() {\n    while (1) {\n        int i;\n        int w, h;\n        vector<pair<int, int> > goal;\n        queue<pair<pair<int, int>, bool> > process;\n        int ldx[] = {0,  0, -1, 0};\n        int ldy[] = {-1, 0, 0, 1};\n        int rdx[] = {0,  0, 1, 0};\n        int rdy[] = {-1, 0, 0, 1};\n\n        int min = INF;\n\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0) return 0;\n\n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                ml[i][j] = INF;\n                mr[i][j] = INF;\n            }\n        }\n\n        for (i=0;i<h;i++) {\n            int j;\n            for (j=0;j<w;j++) {\n                char c;\n                scanf(\" %c\", &c);\n\n                if (c == 'S') {\n                    t[i][j] = 0;\n                    ml[i][j] = 0;\n                    mr[i][j] = 0;\n                    process.push(make_pair(make_pair(j, i), 0));\n                    process.push(make_pair(make_pair(j, i), 1));\n                } else if (c == 'X') {\n                    t[i][j] = INF;\n                } else if (c == 'T') {\n                    t[i][j] = 0;\n                    goal.push_back(make_pair(j, i));\n                } else {\n                    t[i][j] = c - 48;\n                }\n            }\n        }\n\n        while (!process.empty()) {\n            int x1, y1;\n            bool is_right;\n            pair<pair<int, int>, bool>  point = process.front();\n\n            x1 = point.first.first;\n            y1 = point.first.second;\n            is_right = point.second;\n\n            for (i=0;i<4;i++) {\n                int j;\n                for (j=0;j<4;j++) {\n                    int value;\n                    int x2, y2;\n\n                    if (is_right) {\n                        x2 = x1 + rdx[i] + rdx[j] + 1;\n                        y2 = y1 + rdy[i] + rdy[j];\n                        if (x2 < 0 || x2 >= w || y2 < 0 || y2 >= h) continue;\n                        value = ml[y1][x1] + t[y2][x2];\n\n                        if (mr[y2][x2] > value) {\n                            mr[y2][x2] = value;\n                            process.push(make_pair(make_pair(x2, y2), 0));\n                        }\n                    } else {\n                        x2 = x1 + ldx[i] + ldx[j] - 1;\n                        y2 = y1 + ldy[i] + ldy[j];\n                        if (x2 < 0 || x2 >= w || y2 < 0 || y2 >= h) continue;\n                        value = mr[y1][x1] + t[y2][x2];\n\n                        if (ml[y2][x2] > value) {\n                            ml[y2][x2] = value;\n                            process.push(make_pair(make_pair(x2, y2), 1));\n                        }\n                    }\n                }\n            }\n\n            process.pop();\n        }\n\n        vector<pair<int, int> >::iterator it = goal.begin();\n        while (it != goal.end()) {\n            int x, y;\n\n            x = it->first;\n            y = it->second;\n            if (min > ml[y][x]) min = ml[y][x];\n            if (min > mr[y][x]) min = mr[y][x];\n            it++;\n        }\n\n        if (min == INF) min = -1;\n\n        printf(\"%d\\n\", min);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[2][9]={\n\t{-2,-1,0,1,2,-1,0,1,0},\n\t{-2,-1,0,1,2,-1,0,1,0}\n};\nint dy[2][9]={\n\t{1,1,1,1,1,2,2,2,3},\n\t{-1,-1,-1,-1,-1,-2,-2,-2,-3}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<vector<char> >in(n,vector<char>(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tint dp[62][32][2];\n\t\trep(i,62)rep(j,32)rep(k,2)dp[i][j][k]=inf;\n\t\tqueue<pair<pii,pii> >q;\n\t\trep(i,m)if(in[n-1][i]=='S'){\n\t\t\tdp[n-1][i][0]=dp[n-1][i][1]=0;\n\t\t\tq.push(pair<pii,pii>(pii(n-1,i),pii(0,0)));//x,y,r or l,cost\n\t\t\tq.push(pair<pii,pii>(pii(n-1,i),pii(1,0)));//x,y,r or l,cost\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tpii a=(q.front()).first;\n\t\t\tpii b=(q.front()).second;\n\t\t\tq.pop();\n\t\t\tif(dp[a.first][a.second][b.first]<b.second)continue;\n//\t\t\tcout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n\t\t\trep(i,9){\n\t\t\t\tint nx=a.first+dx[b.first][i];\n\t\t\t\tint ny=a.second+dy[b.first][i];\n\t\t\t\tint cost=dp[a.first][a.second][b.first];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(isdigit(in[nx][ny]))cost+=in[nx][ny]-'0';\n\t\t\t\tif(in[nx][ny]=='X')continue;\n\t\t\t\tif(dp[nx][ny][b.first^1]>cost){\n\t\t\t\t\tdp[nx][ny][b.first^1]=cost;\n\t\t\t\t\t//if(in[nx][ny]!='T')\n\t\t\t\t\t\tq.push(pair<pii,pii>(pii(nx,ny),pii(b.first^1,cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,m)if(in[0][i]=='T')out=min(out,min(dp[0][i][0],dp[0][i][1]));\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nint H,W,inf = 1e9;\nint F[70][40];\nint dp[70][40][70][40][2] = {};\nvector<pair<int,int>> goal;\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\nstruct state{\n    int time;\n    int lx,ly,rx,ry;\n    bool move = false;\n    bool operator<(const state &right)const{\n        return time > right.time;\n    }\n};\nint main(){\n    while(cin >> W >> H && H>0){\n        char c;\n        for(int i=0;i<=H;i++){\n            for(int j=0;j<=W;j++){\n                for(int k=0;k<=H;k++){\n                    for(int l=0;l<=W;l++){\n                        dp[i][j][k][l][0] = inf;\n                        dp[i][j][k][l][1] = inf;\n                    }\n                }\n            }\n        }\n        priority_queue<state> Q;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> c;\n                if(c=='X') F[i][j] = inf;\n                else if(c=='S'){\n                    dp[i][j][i][j][0] = 0;\n                    dp[i][j][i][j][1] = 0;\n                    F[i][j] = 0;\n                    Q.push((state){0,i,j,i,j,true});\n                    Q.push((state){0,i,j,i,j,false});\n                }else if(c=='T'){\n                    goal.push_back({i,j});\n                    F[i][j] = 0;\n                }else F[i][j] = c-'0';\n            }\n        }\n        while(!Q.empty()){\n            state s = Q.top(); Q.pop();\n//            cerr << s.time << \" \"  << s.lx << \" \" << s.ly << \" \" << s.rx << \" \" << s.ry << endl;\n            if(s.time>dp[s.lx][s.ly][s.rx][s.ry][s.move]) continue;\n            if(s.move){\n                for(int i=1;i<=5;i++){\n                    for(int j=1;j<=3;j++){\n                        int x = s.lx+i-3,y = s.ly+j;\n                        if(!in(x,y) || abs(s.lx-x)+abs(s.ly-y)>3) continue;\n                        if(dp[s.lx][s.ly][x][y][1]>s.time+F[x][y]){\n                            dp[s.lx][s.ly][x][y][1] = s.time+F[x][y];\n                            Q.push((state){dp[s.lx][s.ly][x][y][1],s.lx,s.ly,x,y,false});\n                        }\n                    }\n                }\n            }\n            else{\n                for(int i=1;i<=5;i++){\n                    for(int j=1;j<=3;j++){\n                        int x = s.rx+i-3,y = s.ry-j;\n                        if(!in(x,y) || abs(s.rx-x)+abs(s.ry-y)>3) continue;\n                        if(dp[x][y][s.rx][s.ry][0]>s.time+F[x][y]){\n                            dp[x][y][s.rx][s.ry][0] = s.time+F[x][y];\n                            Q.push((state){dp[x][y][s.rx][s.ry][0],x,y,s.rx,s.ry,true});\n                        }\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        for(auto x:goal){\n            int a = x.first,b = x.second;\n            //cerr << a << \" \" << b << endl;\n            for(int i=1;i<=H;i++){\n                for(int j=1;j<=W;j++){\n                    for(int k=0;k<2;k++){\n                        ans = min(ans,min(dp[a][b][i][j][k],dp[i][j][a][b][k]));\n                    }\n                }\n            }\n        }\n        cout << (ans!=inf? ans:-1) << endl;\n        goal.clear();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint w, h;\nvoid update(st p, priority_queue<st>&que) {\n\tfor (int k = -2; k <= 2; k++) {\n\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\tif (p.b) {\n\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tupdate({ i,j,0,0,0,1 }, que); update({ 0,0,i,j,0,0 }, que);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tupdate(p, que);\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)30000;\n\n\nint calc_cost(vector<vector<char> > &m, int x, int y)\n{\n\tint w = m.size(), h = m[0].size();\n\tif(x < 0 || x >= w || y < 0 || y >= h)\n\t\treturn inf;\n\tif(m[x][y] < '0' || m[x][y] > '9')\n\t\treturn (m[x][y] == 'T' || m[x][y] == 'S') ? 0 : inf;\n\treturn m[x][y] - '0'; \n}\n\n\nint calc_idx(vector<vector<char> > &m, int x1, int y1, int x2, int y2, int next)\n{\n\tint w = m.size(), h = m[0].size();\n\treturn ((x1 * h + y1) * (w * h) + (x2 * h + y2)) * 2 + next;\n}\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tint w, h, wh;\n\t\tvector<vector<char> > m;\n\t\tconst int dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\t\tconst int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\t\tconst int dir = 9;\n\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\twh = w * h;\n\t\tm.resize(w);\n\t\tfor(int i = 0; i < w; ++i)\n\t\t\tm[i].resize(h);\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x)\n\t\t\t\tscanf(\" %c\", &m[x][y]);\n\t\t}\n\n\t\tvector<short> distl, distr;\n\t\tpriority_queue<pair<int, int> > q;\n\t\tint ans = inf;\n\n\t\tdistl.resize(wh * wh * 2, inf);\n\t\tdistr.resize(wh * wh * 2, inf);\n\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\n\t\t\t\tif(m[x][y] != 'S')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx1 = x + dx[d], nx2 = x - dx[d];\n\t\t\t\t\tint ny1 = y + dy[d], ny2 = y + dy[d];\n\t\t\t\t\tint c1 = calc_cost(m, nx1, ny1);\n\t\t\t\t\tint c2 = calc_cost(m, nx2, ny2);\n\t\t\t\t\tif(c1 < inf)\n\t\t\t\t\t\tq.push(make_pair(-c1, calc_idx(m, x, y, nx1, ny1, 0)));\n\t\t\t\t\tif(c2 < inf)\n\t\t\t\t\t\tq.push(make_pair(-c2, calc_idx(m, nx2, ny2, x, y, 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!q.empty()) {\n\n\t\t\tint cost = -q.top().first;\n\t\t\tint idx = q.top().second;\n\t\t\tq.pop();\n\n\t\t\tint x1 = ((idx / 2) / wh) / h;\n\t\t\tint y1 = ((idx / 2) / wh) % h;\n\t\t\tint x2 = ((idx / 2) % wh) / h;\n\t\t\tint y2 = ((idx / 2) % wh) % h;\n\t\t\tint next = idx % 2;\n\n\t\t\t//printf(\"%d %d %d %d (%d) -> %d  / %c %c\\n\", x1, y1, x2, y2, next, cost,\n\t\t\t//\tm[x1][y1], m[x2][y2]);\n\n\t\t\tif(next == 0) {\n\t\t\t\tif(distr[idx] <= cost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdistr[idx] = cost;\n\t\t\t} else {\n\t\t\t\tif(distl[idx] <= cost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdistl[idx] = cost;\n\t\t\t}\n\n\t\t\tif((m[x1][y1] == 'T') || (m[x2][y2] == 'T')) {\n\t\t\t\tans = min(ans, cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(next == 0) {\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx = x2 - dx[d], ny = y2 + dy[d];\n\t\t\t\t\tint c = calc_cost(m, nx, ny) + cost;\n\t\t\t\t\tint i = calc_idx(m, nx, ny, x2, y2, 1);\n\t\t\t\t\tif(c >= inf)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(c >= distl[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tq.push(make_pair(-c, i));\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx = x1 + dx[d], ny = y1 + dy[d];\n\t\t\t\t\tint c = calc_cost(m, nx, ny) + cost;\n\t\t\t\t\tint i = calc_idx(m, x1, y1, nx, ny, 0);\n\t\t\t\t\tif(c >= inf)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(c >= distr[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tq.push(make_pair(-c, i));\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\tif(ans < inf)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tprintf(\"-1\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct State {\n\tint i, j, foot, dist;\n\tconst bool operator<(const State &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\nchar g[65][35];\nint dist[65][35][2];\n\nconst int LF = 0, RF = 1;\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tfor (;;) {\n\t\trep(i, 0, 65) rep(j, 0, 35) g[i][j] = ' ';\n\t\trep(i, 0, 65) rep(j, 0, 35) rep(k, 0, 2) dist[i][j][k] = 9999999;\n\n\t\tint w, h; cin >> w >> h; if (!w && !h) break;\n\t\tpriority_queue<State> pq;\n\n\t\tfor (int i = h - 1; i >= 0; i--)\n\t\t\trep(j, 0, w) {\n\t\t\t\tcin >> skipws >> g[i][j];\n\t\t\t\tif (g[i][j] == 'S') {\n\t\t\t\t\tdist[i][j][LF] = dist[i][j][RF] = 0;\n\t\t\t\t\tpq.push(State {i, j, LF, 0});\n\t\t\t\t\tpq.push(State {i, j, RF, 0});\n\t\t\t\t}\n\t\t\t}\n\n\t\twhile (!pq.empty()) {\n\t\t\tState st = pq.top(); pq.pop();\n\t\t\tif (st.dist > dist[st.i][st.j][st.foot])\n\t\t\t\tcontinue;\n\t\t\tfor (int di = -2; di <= 2; di++) {\n\t\t\t\tfor (int dj = 1; dj <= 3 - abs(di); dj++) {\n\t\t\t\t\tint ni = st.i + di, nj = st.foot == LF ? st.j + dj : st.j - dj;\n\t\t\t\t\tint nf = st.foot ^ 1;\n\t\t\t\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w) {\n\t\t\t\t\t\tif (isdigit(g[ni][nj]) && st.dist + int(g[ni][nj] - '0') < dist[ni][nj][nf]) {\n\t\t\t\t\t\t\tdist[ni][nj][nf] = st.dist + int(g[ni][nj] - '0');\n\t\t\t\t\t\t\tpq.push(State {ni, nj, nf, dist[ni][nj][nf]});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (g[ni][nj] == 'T') {\n\t\t\t\t\t\t\tcout << st.dist << endl;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\ndone: void(0);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f;\n\t\t\t\t\tf.ly = f.ry = i;\n\t\t\t\t\tf.lx = f.rx = j;\n\t\t\t\t\tf.p = 0;\n\t\t\t\t\tf.cnt = 0;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\tif(field[temp.ry][temp.rx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\tif(field[temp.ly][temp.lx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n//passed all test cases\n//but couldnt pass"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tint i = 0;\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n\nstruct Action {\n\tsize_t x;\n\tsize_t y;\n\tsize_t cost;\n\tbool left_foot_on;\n};\n\nbool operator>(Action lhs, Action rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nbool operator==(Action lhs, Action rhs) {\n\treturn lhs.x == rhs.x && lhs.y == rhs.y && lhs.left_foot_on == rhs.left_foot_on;\n}\n\nnamespace std {\n\ttemplate <>\n\tstruct hash<Action> {\n\t\tusing result_type = size_t;\n\n\t\tresult_type operator()(const Action& act) const {\n\t\t\treturn act.x * 31 + act.y * 12 + act.left_foot_on * 7;\n\t\t}\n\t};\n}\n\nclass Climber {\nprivate:\n\tusing candidates_t = std::priority_queue<Action, std::vector<Action>, std::greater<Action>>;\n\n\tsize_t _width;\n\tsize_t _height;\n\tstd::string* _cliff;\n\tcandidates_t _candidates;\n\tstd::unordered_set<Action> _traversed;\n\n\tchar get(size_t x, size_t y);\n\tvoid try_put_candidate(const Action& now, size_t x, size_t y);\n\tvoid put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on);\npublic:\n\tClimber(size_t width, size_t height);\n\tvoid load();\n\tint climb();\n};\n\nClimber::Climber(size_t width, size_t height) : _width(width), _height(height) { }\n\nvoid Climber::load() {\n\t_cliff = new std::string[_height];\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tstd::string line;\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tchar a;\n\t\t\tstd::cin >> a;\n\t\t\tline += a;\n\t\t}\n\t\t_cliff[y] = line;\n\t}\n}\n\nint Climber::climb() {\n\t// ??????????????????S????????????????¶????????¶???????????????????????????????\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tif (get(x, y) == 'S') {\n\t\t\t\tput_candidate(x, y, 0, false);\n\t\t\t\tput_candidate(x, y, 0, true);\n\t\t\t}\n\t\t}\n\t}\n\t// ???????°???????????????????????????????????????????????????????????????????\n\twhile (!_candidates.empty()) {\n\t\tconst Action now = _candidates.top();\n\t\tif (get(now.x, now.y) == 'T') {\n\t\t\treturn now.cost;\n\t\t}\n\t\tstd::cerr << \"(\" << now.x << \",\" << now.y << \")->\" << now.cost << \" [\" << now.left_foot_on << \"]\\n\";\n\t\tif (now.left_foot_on) {\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 2);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 3, now.y);\n\t\t} else {\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x - 3, now.y);\n\t\t}\n\t\t_candidates.pop();\n\t}\n\t// ????????????????????£???\n\treturn -1;\n}\n\nvoid Climber::try_put_candidate(const Action& now, size_t x, size_t y) {\n\tchar type = get(x, y);\n\tif (type == 'S' || type == 'X' || type == '\\0') {\n\t\treturn; // type==S??????????????????????????????????????????????§????????????????????????????????????????????????????\n\t}\n\tint additionalCost;\n\tif (type == 'T') {\n\t\tadditionalCost = 0; // ????????§??????????????????\n\t} else {\n\t\tadditionalCost = type - '0';\n\t}\n\tput_candidate(x, y, now.cost + additionalCost, !now.left_foot_on);\n}\n\nchar Climber::get(size_t x, size_t y) {\n\tif (x >= _width || y >= _height) {\n\t\treturn '\\0'; // invalid range\n\t}\n\treturn _cliff[y][x];\n}\n\nvoid Climber::put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on) {\n\tAction a{x, y, cost, left_foot_on};\n\tauto alreadyTraversed = _traversed.find(a);\n\tif (alreadyTraversed == _traversed.end() || alreadyTraversed->cost > cost) {\n\t\t_traversed.emplace(a);\n\t\t_candidates.emplace(std::move(a));\n\t}\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tClimber climber(width, height);\n\t\tclimber.load();\n\t\tstd::cout << climber.climb() << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1150\n// Cliff Climbing\n#include<iostream>\n#include<cmath>\n#include<stdio.h>\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1000000\n\nusing namespace std;\nchar map[MAX_H][MAX_W];\nint d[MAX_H][MAX_W][2];\t\t// ??¶???(y??????x??????foot?¶?)\nbool used[MAX_H][MAX_W][2];\nint w, h;\n\nbool transision(int x, int y, int foot, int new_x, int new_y)\n{\n  int new_foot;\n  if(foot)\n    new_foot = 0;\n  else\n    new_foot = 1;\n  if(new_foot)\t\t\t// ????¶?\n    {\n      if(x >= new_x)return false;      \n    }\n  else\t\t\t\t// ????¶?\n    {\n      if(new_x >= x)return false;\n    }\n\n  if(0 <= new_x && new_x < w && 0 <= new_y && new_y < h && map[new_y][new_x] != 'X')\n    {\n      if(abs((double)(x - new_x)) + abs((double)(y - new_y)) <= 3)\n\treturn true;\n      else\n\treturn false;\n    }\n  else\n    return false;\n}\n\nvoid dijkstra(int s_x, int s_y, int s_foot)\n{\n  d[s_y][s_x][s_foot] = 0;\t// ????????¶???=?????????0\n  while(true)\n    {\n      int x = -1, y = -1, foot = -1;\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  for(int k = 0; k < 2; k++) // ???????????????????????? ?????? ????????¶????????????????????????????°???????=???????????¢????¢????????????????\n\t    if(!used[i][j][k] && ((x == -1 && y == -1 && foot == -1) || (d[i][j][k] < d[y][x][foot])))\n\t      x = j, y = i, foot = k;\n\n      // cout << x << y << foot << endl;\n      // cout << d[y][x][foot] << endl;\n\n      if(x == -1 && y == -1 && foot == -1)\n\tbreak;\n      used[y][x][foot] = true;\n      // ??¶???(y, x, foot)??????????§????????????¶??????\"????????¶?????????????????????\"?????´??°\n      for(int i = y + 3; i >= y - 3; i--)\n\tfor(int j = x - 3; j <= x + 3; j++)\n\t  {\n\t    if(transision(x, y, foot, j, i))\n\t      {\n\t\t//\t\tcout << \"!!!\" << endl;;\n\t\tint new_f, cost;\n\t\tif(foot)\n\t\t  new_f = 0;\n\t\telse\n\t\t  new_f = 1;\n\t\tif(map[i][j] == 'S' || map[i][j] == 'T')\n\t\t  cost = 0;\n\t\telse\n\t\t  cost = map[i][j] - '0';\n\t\td[i][j][new_f] = min(d[i][j][new_f], d[y][x][foot] + cost);\n\t      }\n\t  }\n    }\n}\n\nint main(void)\n{\n  while(cin >> w >> h, (w && h))\n    {\n      for(int i = 0; i < MAX_H; i++)\n\tfor(int j = 0; j < MAX_W; j++)\n\t  for(int k = 0; k < 2; k++)\n\t    {\n\t      d[i][j][k] = INF;\n\t      used[i][j][k] = false;\n\t    }\n\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  cin >> map[i][j];\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  if(map[i][j] == 'S')\n\t    {\n\t      dijkstra(j, i, 0); // ????¶?????????????\n\t      dijkstra(j, i, 1); // ????¶?????????????\n\t    }\n\n      int ans = INF;\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  if(map[i][j] == 'T')\n\t    {\n\t      //\t      cout << d[i][j][0] << \", \" << d[i][j][1] << endl;;\n\t      ans = min(ans, d[i][j][0]);\n\t      ans = min(ans, d[i][j][1]);\n\t    }\n      if(ans != INF)\n\tcout << ans << endl;\n      else\n\tcout << \"-1\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[61][31];\nint used[2][61][31][61][31]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c; // ???????????§???????????????????¨???¶\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false; // ??????????¨???????\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c; // ?????£????????¨?????????\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true; // ?£????\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true; // ?£????\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; //????£???????\n\t  if(board[s.r.sc][s.r.fs] < 0) return true; //??????????£?\n\t  if(board[s.l.sc][s.l.fs] < 0) return true; //??????????£?\n\t  return false; // ??§??????\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true; // ????¶??????´??????\n\t  if(g.find(s.r) != g.end()) return true; // ????¶??????´??????\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n//\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost = 0 ;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  if(is_used(ns)) continue;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  foot dummy = foot(INF,INF);\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(s[i],foot(s[i].fs+dx[i], s[i].sc-dy[i]),0,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs+dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st0 = state(s[i], dummy, 0, 0);\n\t\t\t\t  int tmp0 = dijk(st0);\n\t\t\t\t  if(tmp0 != -1)\n\t\t\t\t\t\tans = min(ans, tmp0);\n\n\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(foot(s[i].fs-dx[i], s[i].sc-dy[i]), s[i], 1,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs-dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st1 = state(dummy, s[i], 1, 0);\n\t\t\t\t  int tmp1 = dijk(st1);\n\t\t\t\t  if(tmp1 != -1)\n\t\t\t\t\t\tans = min(ans, tmp1);\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define INF (1e9)\n#define H 60\n#define W 30\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<char,P> P1;\ntypedef pair<int,P1> P2;\nint dijkstra(int,int,char);\nint w,h,dl[H][W],dr[H][W],ans;\nchar s[H][W];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>s[i][j];\n    ans=INF;\n    for(int i=0;i<w;i++)\n      if(s[h-1][i]=='S') ans=min(ans,min(dijkstra(h-1,i,'l'),dijkstra(h-1,i,'r')));\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;    \n  }\n  return 0;\n}\n\nint dijkstra(int sy,int sx,char lr){\n  priority_queue<P2> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) dl[i][j]=dr[i][j]=INF;\n  q.push(P2(0,P1(lr,P(sy,sx))));\n  if(lr=='l') dl[sy][sx]=0;\n  else dr[sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    char c=t.second.first;\n    int cost=-t.first,y=t.second.second.first,x=t.second.second.second;\n    int dy[9]={0,0,0,-1,-1,-2,1,1,2},dx[9]={1,2,3,1,2,1,1,2,1};\n    if(c=='l'&&dl[y][x]<cost) continue;\n    if(c=='r'&&dr[y][x]<cost) continue;\n    for(int i=0;i<9;i++){\n      int ny,nx;\n      ny=y+dy[i];\n      if(c=='l') nx=x+dx[i];\n      else nx=x-dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx||s[ny][nx]=='X'||s[ny][nx]=='S') continue;\n      if(s[ny][nx]=='T'){\n\tif(c=='l') dr[ny][nx]=min(dr[ny][nx],cost);\n\telse dl[ny][nx]=min(dl[ny][nx],cost);\n      }\n      else if(c=='l'&&dr[ny][nx]>cost+s[ny][nx]-'0'){\n\tdr[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(-dr[ny][nx],P1('r',P(ny,nx))));\n      }\n      else if(c=='r'&&dl[ny][nx]>cost+s[ny][nx]-'0'){\n\tdl[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(-dl[ny][nx],P1('l',P(ny,nx))));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<w;i++)\n    if(s[0][i]=='T') res=min(res,min(dl[0][i],dr[0][i]));\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int W = 30;\nconst int H = 60;\nconst int INF = 1 << 29;\n\nstruct foot{\n  int ly, lx, ry, rx;\n  foot(int ly=0, int lx=0, int ry=0, int rx=0):ly(ly),lx(lx),ry(ry),rx(rx){}\n};\n\nstruct state{\n  foot p;\n  int c;\n  bool isRight;\n  state(foot p=foot(0,0,0,0), bool ir=true, int c=0):p(p),c(c),isRight(ir){}\n  bool operator < (const state &s) const {\n    return c > s.c;\n  }\n};\n\nint w,h,v[H][W];\n\nbool check(const int &y, const int &x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return v[y][x] != -1;\n}\n\nvector<foot> nextFoot(const state &s){\n  vector<foot> res;\n\n  for(int i=1;i<=3;i++){\n    for(int j=-3+i;j<=3-i;j++){\n      if(s.isRight){\n        if(!check(s.p.ly+j, s.p.lx+i)) continue;\n        res.push_back(foot(s.p.ly, s.p.lx, s.p.ly+j, s.p.lx+i));\n      } else {\n        if(!check(s.p.ry+j, s.p.rx-i)) continue;\n        res.push_back(foot(s.p.ry+j, s.p.rx-i, s.p.ry, s.p.rx));\n      }\n    }\n  }\n\n  return res;\n}\n\n  int d[H][W][H][W];\n\nint solve(){\n  priority_queue<state> q;\n  state u,u2;  \n  vector<foot> next;\n\n  for(int i=0;i<h*w;i++) for(int j=0;j<h*w;j++) d[i/w][i%w][j/w][j%w] = INF;\n\n  for(int i=0;i<w;i++){\n    if(v[h-1][i] != -3) continue;\n    u = state(foot(h-1, i, h-1, i), true);\n    next = nextFoot(u);\n    for(int j=0;j<next.size();j++){\n      if(v[next[j].ry][next[j].rx] < 0) q.push(state(next[j], false));\n      else q.push(state(next[j], false, v[next[j].ry][next[j].rx]));\n    }\n    \n    u.isRight = false;\n    next = nextFoot(u);\n    for(int j=0;j<next.size();j++){\n      if(v[next[j].ly][next[j].lx] < 0) q.push(state(next[j], true));\n      else q.push(state(next[j], true, v[next[j].ly][next[j].lx]));\n    }\n  }\n  \n  while(!q.empty()){\n    u = q.top();\n    q.pop();\n\n    if(v[u.p.ly][u.p.lx] == -2 || v[u.p.ry][u.p.rx] == -2){\n      return u.c;\n    }\n\n    //cout << u.p.ly << ' ' << u.p.lx << ' ' << u.p.ry << ' ' << u.p.rx << ' ' << u.c << endl;\n\n    next = nextFoot(u);\n    for(int i=0;i<next.size();i++){\n      if(u.isRight){\n        u2 = state(next[i], !u.isRight);\n        if(v[u2.p.ry][u2.p.rx] < 0) u2.c = u.c;\n        else u2.c = u.c + v[u2.p.ry][u2.p.rx];\n      } else {\n        u2 = state(next[i], !u.isRight);\n        if(v[u2.p.ly][u2.p.lx] < 0) u2.c = u.c;\n        else u2.c = u.c + v[u2.p.ly][u2.p.lx];\n      }\n      if(d[u2.p.ly][u2.p.lx][u2.p.ry][u2.p.rx] <= u2.c) continue;\n      d[u2.p.ly][u2.p.lx][u2.p.ry][u2.p.rx] = u2.c;\n      q.push(u2);\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        char c;\n        cin >> c;\n        if(c == 'S') v[i][j] = -3;\n        else if(c == 'T') v[i][j] = -2;\n        else if(c == 'X') v[i][j] = -1;\n        else v[i][j] = c - '0';\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define INF 100000009\n#define N 20005\nusing namespace std;\n\ntypedef pair<int,int> PI;//cost to;\n\nint map[65][35];\nint w,h;\n\nbool checkin(int i,int j){\n    if(i>=0&&j>=0&&i<h&&j<w&&map[i][j]!=INF){\n        return true;\n    }else{\n        return false;\n    }\n}\nint retc(int i,int j){\n    if(map[i][j]==-1){\n        return 0;\n    }else{\n        return map[i][j];\n    }\n}\n\nint make(int foot,int state,int i,int j){\n    return foot*w*h*9+state*w*h+i*w+j;\n}\n\nint main(){\n    int cango[9][2];//where right is from left,yx\n    int hoge = 0;\n    for(int y = 0;y<=2;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    for(int y = -2;y<=-1;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    while(1){\n        vector<PI> G[3600*9+5];//0???????¶? 1???????¶? to,cost\n        int dist[3600*9+5];\n        bool goal[3600*9+5];\n        rep(i,3600*9+5){\n            dist[i]=INF;\n            goal[i]=0;\n        }\n        cin>>w>>h;\n        if(w==0){\n            return 0;\n        }\n        char c;\n        rep(i,h){\n            rep(j,w){\n                cin>>c;\n                if(c=='S')        map[i][j]=0;\n                else if(c=='T')   map[i][j]=-1;\n                else if(c=='X')   map[i][j]=INF;\n                else map[i][j]=c-'0';\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(!checkin(i,j))continue;\n                rep(state1,9){\n                    int y=i+cango[state1][0],x=j+cango[state1][1];\n                    if(!checkin(y,x))continue;\n                    if(map[i][j]==-1||map[y][x]==-1){\n                        goal[make(0,state1,i,j)]=true;\n                        goal[make(1,state1,i,j)]=true;\n                    }\n                    rep(state2,9){\n                        if(state1==state2)\n                            continue;\n                        int ny=i+cango[state2][0],nx=j+cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(0,state1,i,j)].pb(mp(make(1,state2,i,j),retc(ny,nx)));\n                        }\n                        ny=y-cango[state2][0],nx=x-cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(1,state1,i,j)].pb(mp(make(0,state2,ny,nx),retc(ny,nx)));\n                        }\n                        \n                    }\n                }\n            }\n        }\n        //        rep(i,3600*9+5){\n        //            if(!G[i].empty()){\n        //                rep(j,G[i].size()){\n        //                    cout<<\"from:\"<< \" foot:\" <<i/(w*h*9) <<\" state:\"<<i/w/h%9<<\" i j:(\"<< i/w%h<< \" \"<<i%w<< \")\"<<endl;\n        //\n        //                    cout<<\"to  :\"<< \" foot:\" <<G[i][j].first/(w*h*9) <<\" state:\"<<G[i][j].first/w/h%9<<\" i j:(\"<< G[i][j].first/w%h<< \" \"<<G[i][j].first%w <<\") cost:\"<<G[i][j].second<<endl<<endl;\n        //                }\n        //            }\n        //        }\n        priority_queue<PI, vector<PI> ,greater<PI> > pq;\n        rep(j,w){\n            if(map[h-1][j]!=0){continue;}\n            rep(st,9){\n                int y = h-1+cango[st][0],x = j+cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(1,st,h-1,j))));}\n                y = h-1-cango[st][0],x = j-cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(0,st,y,x))));}\n            }\n        }\n        int ans = -1;\n        while(!pq.empty()){\n            PI now = pq.top();\n            int cost = now.first;\n            int from = now.second;\n            pq.pop();\n            if(dist[from]<cost){\n                continue;\n            }\n            dist[from]=cost;\n            if(goal[from]){\n                ans = cost;\n                break;\n            }\n            rep(i,G[from].size()){\n                if(dist[G[from][i].first]>cost+G[from][i].second)\n                    pq.push(mp(G[from][i].second+cost,G[from][i].first));\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef tuple<int,int,int,int,int>state;\nconst int INF=1001001001;\nint W,H;\nchar fld[60][30];\nint dist[60][30][60][30];\n\nint dy[]={-2,-1,-1,0,0,0,1,1,2};\nint dx[]={1,1,2,1,2,3,1,2,1};\n\nvoid solve(){\n    fill_n(***dist,60*30*60*30,INF);\n    priority_queue<state,vector<state>,greater<state>>que;\n    rep(a,H)rep(b,W)rep(c,H)rep(d,W){\n        if(b>=d||abs(a-c)+abs(b-d)>3)continue;\n        if(fld[a][b]=='X'||fld[c][d]=='X')continue;\n        if(a==H-1&&fld[a][b]=='0'){\n            dist[a][b][c][d]=fld[c][d]-'0';\n            que.push(make_tuple(dist[a][b][c][d],a,b,c,d));\n        }\n        if(c==H-1&&fld[c][d]=='0'){\n            dist[a][b][c][d]=fld[a][b]-'0';\n            que.push(make_tuple(dist[a][b][c][d],a,b,c,d));\n        }\n    }\n\n    while(que.size()){\n        int c,ly,lx,ry,rx;\n        tie(c,ly,lx,ry,rx)=que.top();\n        que.pop();\n        if(ly==0&&fld[ly][lx]=='0'){\n            cout<<c<<endl;\n            return;\n        }\n        if(ry==0&&fld[ry][rx]=='0'){\n            cout<<c<<endl;\n            return;\n        }\n        if(dist[ly][lx][ry][rx]<c)continue;\n\n        rep(i,9){\n            int ny=ly+dy[i],nx=lx+dx[i];\n            if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]=='X')continue;\n            int nc=c+fld[ny][nx]-'0';\n            if(dist[ly][lx][ny][nx]<=nc)continue;\n            dist[ly][lx][ny][nx]=nc;\n            que.push(make_tuple(nc,ly,lx,ny,nx));\n        }\n        rep(i,9){\n            int ny=ry+dy[i],nx=rx-dx[i];\n            if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]=='X')continue;\n            int nc=c+fld[ny][nx]-'0';\n            if(dist[ny][nx][ry][rx]<=nc)continue;\n            dist[ny][nx][ry][rx]=nc;\n            que.push(make_tuple(nc,ny,nx,ry,rx));\n        }\n    }\n\n    cout<<-1<<endl;\n}\n\nsigned main(){\n    while(cin>>W>>H,W||H){\n        rep(i,H)rep(j,W){\n            cin>>fld[i][j];\n            if(fld[i][j]=='S'||fld[i][j]=='T')fld[i][j]='0';\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nconst int inf = 1<<29;\nint mp[100][100];\nint dp[2][100][100];\n\nint movx[2][9] = { {1,1,1,1,1,2,2,2,3},\n                   {-3,-2,-2,-2,-1,-1,-1,-1,-1} };\nint movy[2][9] = { {-2, -1, 0, 1, 2, -1, 0, 1, 0},\n                   {0, -1, 0, -1, -2, -1, 0, 1, 2} };\n\nstruct State{\n    int leg;\n    int x,y;\n    State(int leg,int y,int x) : leg(leg), x(x), y(y) {;}\n};\n\nint main() {\n    int w,h;\n    string s;\n    while(cin>>w>>h, w|h) {\n        memset(mp, 0, sizeof(mp));\n        REP(i,2) REP(j,100) REP(k,100) dp[i][j][k] = inf;\n        REP(i,h) {\n            REP(j,w) {\n                cin>>s;\n                if(s[0] >= '0' && s[0] <= '9') mp[i][j] = s[0] - '0';\n                else if(s[0] == 'S') mp[i][j] = 0; // START\n                else if(s[0] == 'T') mp[i][j] = -1; // GOAL\n                else mp[i][j] = -2; // X\n            }\n        }\n\n        queue<State> Q;\n        REP(i,h) REP(j,w) if(mp[i][j] == 0) {\n            Q.push(State(0,i,j));\n            Q.push(State(1,i,j));\n            dp[0][i][j] = dp[1][i][j] = 0;\n        }\n\n        while(!Q.empty()) {\n            int l = Q.front().leg,y = Q.front().y,x = Q.front().x;\n            Q.pop();\n            // cout<<((l==0) ? \"left\" : \"right\")<<\" \"<<y<<\" \"<<x<<endl;\n            int nw = dp[l][y][x];\n            for(int i=0; i<9; ++i) {\n                int dx = x + movx[l][i],dy = y + movy[l][i];\n                if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                if(mp[dy][dx] == -2) continue;\n                if(dp[(l+1)%2][dy][dx] > nw + max(mp[dy][dx],0) ) {\n                    dp[(l+1)%2][dy][dx] = nw + max(mp[dy][dx], 0);\n                    Q.push(State((l+1)%2,dy,dx));\n                }\n            }\n        }\n\n        int ans = inf;\n        REP(i,h) {\n            REP(j,w) {\n                if(mp[i][j] == -1) {\n                    ans = min(dp[0][i][j], ans);\n                    ans = min(dp[1][i][j], ans);\n                }\n            }\n        }\n        if(ans == inf) cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[2][9] = {{0, 1, -1, 2, -2, 0, 1, -1, 0}, {0, 1, -1, 2, -2, 0, 1, -1, 0}};\nconst int dx[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nconst int MAX_N = 70;\nchar field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N][2];\nint h, w;\nstruct edge \n{\n    int cost;\n    int y, x;\n    bool flag;\n    bool operator > (const edge &d) const\n    {\n        return d.cost < cost;\n    }\n};\nint dijkstra(int y, int x, bool foot)\n{\n    priority_queue<edge, vector<edge>, greater<edge>> que;\n    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) for(int k = 0; k < 2; k++) dist[i][j][k] = INF;\n    dist[y][x][foot] = 0;\n    edge v = {0, y, x, foot};\n    que.push(v);\n    while(!que.empty())\n    {\n        edge p = que.top();\n        que.pop();\n        int ty = p.y;\n        int tx = p.x;\n        bool flag = (p.flag ? false : true);\n        if(dist[ty][tx][p.flag] < p.cost) continue;\n        for(int i = 0; i < 9; i++)\n        {\n            int ny = ty + dy[flag][i];\n            int nx = tx + dx[flag][i];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n            if(field[ny][nx] == 'X' || field[ny][nx] == 'S') continue; \n            int cost = 0;\n            if(field[ny][nx] != 'T') cost = field[ny][nx] - '0';\n            if(dist[ny][nx][flag] > dist[ty][tx][p.flag] + cost)\n            {\n                dist[ny][nx][flag] = dist[ty][tx][p.flag] + cost;\n                edge tmp = {cost, ny, nx, flag};\n                que.push(tmp);\n            }\n        }\n    }\n    int ret = INF;\n    for(int j = 0; j < w; j++)\n    {\n        if(field[0][j] != 'T') continue;\n        for(int k = 0; k < 2; k++) ret = min(dist[0][j][k], ret);\n    }\n    return ret;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        int ans = INF;\n        vector<P> start;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char ch;\n                cin >> ch;\n                if(ch == 'S') start.push_back(P(i, j));\n                field[i][j] = ch;\n            }\n        }\n        for(int i = 0; i < start.size(); i++)\n        {\n            for(int j = 0; j < 2; j++)\n            {\n                ans = min(dijkstra(start[i].first, start[i].second, j), ans);\n            }\n        }\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//54\n#include<iostream>\n#include<queue>\n#include<cstdlib>\n#include<cctype>\n\nusing namespace std;\n\nstruct S{\n  int x,y,t,f;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int w,h;cin>>w>>h,w|h;){\n    char g[60][30];\n    priority_queue<S> que;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='S'){\n\t  S is={x,y,0,0};\n\t  que.push(is);\n\t  is.f=1;\n\t  que.push(is);\n\t}\n      }\n    }\n    bool m[60][30][2]={{{}}};\n    while(!que.empty()){\n      S c=que.top();\n      if(g[c.y][c.x]=='T')break;\n      que.pop();\n      if(m[c.y][c.x][c.f]++)continue;\n      for(int y=0;y<h;y++){\n\tfor(int x=0;x<w;x++){\n\t  if(g[y][x]!='X'&&((c.f&&x<c.x)||(!c.f&&c.x<x))&&abs(x-c.x)+abs(y-c.y)<=3){\n\t    S n={x,y,c.t+(isdigit(g[y][x])?g[y][x]-'0':0),!c.f};\n\t    que.push(n);\n\t  }\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.top().t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_DIR 9\n#define MAX_N 100\n#define INF 1 << 30\n\nstring C;\nint X[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint G[MAX_N][MAX_N];\nint DIST[MAX_N][MAX_N][MAX_DIR];//Left,DY-DX\nint dx[MAX_DIR] = { 1,1,1,1,1,2,2,2,3 };\nint dy[MAX_DIR] = { -2,-1,0,1,2,-1,0,1,0 };\nint dz[MAX_DIR] = { 4,3,2,1,0,7,6,5,8 };\nint H, W;\nchar U[11] = \"0123456789\";\n\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>> > Q;\n\nvoid MEMSET() {\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tX[i][j] = INF;\n\t\t\tS[i][j] = 0;\n\t\t\tG[i][j] = 0;\n\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\tDIST[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DIJKSTRA() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j + dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[i][j][k] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j - dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[Y1][X1][dz[k]] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, Y1, X1, dz[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\ttuple<int, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tint LY = a2, LX = a3;\n\t\tint RY = a2 + dy[a4], RX = a3 + dx[a4];\n\n\t\t//hidari.\n\t\tfor (int k = 0; k < MAX_DIR; k++)\n\t\t{\n\t\t\tint cy = RY + dy[k];\n\t\t\tint cx = RX - dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tgoto H;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tgoto H;\n\t\t\t}\n\t\t\tif (RY < 1 || RY > H) {\n\t\t\t\tgoto H;\n\t\t\t}\n\t\t\tif (RX < 1 || RX > W) {\n\t\t\t\tgoto H;\n\t\t\t}\n\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[cy][cx][dz[k]] > dis + pos) {\n\t\t\t\t\tDIST[cy][cx][dz[k]] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[cy][cx][dz[k]], cy, cx, dz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\tH:;\n\t\t}\n\t\t//migi.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = LY + dy[k];\n\t\t\tint cx = LX + dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tgoto I;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tgoto I;\n\t\t\t}\n\t\t\tif (LY < 1 || LY > H) {\n\t\t\t\tgoto I;\n\t\t\t}\n\t\t\tif (LX < 1 || LX > W) {\n\t\t\t\tgoto I;\n\t\t\t}\n\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[LY][LX][k] > dis + pos) {\n\t\t\t\t\tDIST[LY][LX][k] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[LY][LX][k], LY, LX, k));\n\t\t\t\t}\n\t\t\t}\n\t\tI:;\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (G[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint ey = i + dy[k];\n\t\t\t\t\tint ex = j + dx[k];\n\t\t\t\t\tif (ey < 1 || ey > H) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ex < 1 || ex > W) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (G[ey][ex] == 1) {\n\t\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res >= INF) {\n\t\treturn -1;\n\t}\n\treturn res;\n}\n\nint power(int a, int b) {\n\tint R = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tR *= b;\n\t}\n\treturn R;\n}\n\nvoid CIN() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> C;\n\t\t\tif (C == \"X\") {\n\t\t\t\tX[i][j] = INF;\n\t\t\t}\n\t\t\telse if (C == \"S\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tS[i][j] = 1;\n\t\t\t}\n\t\t\telse if (C == \"T\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint D = C.size();\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tfor (int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif (C[k] == U[l]) {\n\t\t\t\t\t\t\tcnt1 += power(10, D - k - 1)*l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX[i][j] = cnt1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tS[H + 1][i] = 1;\n\t\tX[H + 1][i] = 0;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tMEMSET();\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tCIN();\n\t\tcout << DIJKSTRA() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      queue<pi> Q;\n      queue<bool> R;\n    \n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\" %c\",&S[i][j]);\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t  Q.push(pi(i,j));\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(0);\n\t\t  R.push(1);\n\t\t}\t      \n\t    }\n\t}\n      \n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<=B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<map>\n#include<climits>\n#include<algorithm>\nusing namespace std;\n\ntypedef tuple<int, int, int> Point;\ntypedef tuple<int, Point> Node;\nint Next[2][9][2] ={\n    {\n        {-2, 1}, {-1, 1}, {0, 1}, {1, 1}, {2, 1},\n        {-1, 2}, {0, 2}, {1, 2},\n        {0, 3}\n    },\n    {\n        {-2, -1}, {-1, -1}, {0, -1}, {1, -1}, {2, -1},\n        {-1, -2}, {0, -2}, {1, -2},\n        {0, -3}\n    },\n\n};\nenum {LEFT, RIGHT};\nenum {Y, X, SIDE};\nenum {COST, POINT};\nenum {START = -2, TOP, NIL};\n\nint Dijkstra(const vector<vector<int>>& cliff, const Point& start) {\n    int result = INT_MAX;\n    int h = cliff.size();\n    int w = cliff.front().size();\n    map<Point, int> cost;\n    priority_queue<Node> q;\n    q.push(Node(0, start));\n    cost[start] = 0;\n    while(!q.empty()) {\n        int c = get<COST>(q.top());\n        Point point = get<POINT>(q.top());\n        q.pop();\n        for(const auto& d: Next[get<SIDE>(point)]) {\n            int y = get<Y>(point) + d[Y];\n            int x = get<X>(point) + d[X];\n//             cout << y << \",\" << x << endl;\n            if(y < 0 || h  <= y) continue;\n            if(x < 0 || w  <= x) continue;\n            if(cliff[y][x] == NIL) continue;\n            if(cliff[y][x] == START) continue;\n            if(cliff[y][x] == TOP) {\n                result = min(result, c);\n            } else {\n                Point next_point(y, x, get<SIDE>(point) ^ 1);\n                if(cost.count(next_point) && cost[next_point] < c + cliff[y][x]) continue;\n                cost[next_point] = c + cliff[y][x];\n                q.push(Node(cost[next_point], next_point));\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w | h) {\n        vector<vector<int>> cliff(h, vector<int>(w));\n        for(auto& line: cliff) for(auto& v: line) {\n            char c;\n            cin >> c;\n            if(c == 'S') v = START;\n            else if(c == 'T') v = TOP;\n            else if(c == 'X') v = NIL;\n            else v = c - '0';\n        }\n\n        int answer = INT_MAX;\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n            if(cliff[y][x] != START) continue;\n            answer = min({answer, Dijkstra(cliff, Point(y, x, LEFT)), Dijkstra(cliff, Point(y, x, RIGHT))});\n        }\n        cout << ((answer == INT_MAX) ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Foot{\n\tLeft,\n\tRight,\n};\n\nint H,W;\nint***** min_Time;\n\nint diff_row_right[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_right[9] = {1,1,2,1,2,3,1,2,1};\nint diff_row_left[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_left[9] = {-1,-2,-1,-3,-2,-1,-2,-1,-1};\n\nstruct Info{\n\tInfo(){\n\t\tleft_row = left_col = right_row = right_col = time = 0;\n\t\tfoot = Left;\n\t}\n\n\tInfo(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn time > arg.time;\n\t};\n\n\tvoid set(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tint left_row,left_col,right_row,right_col,time;\n\tFoot foot;\n};\n\nstruct Cell{\n\tCell(){\n\t\trow = col = 0;\n\t}\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\n\tbool operator<(const struct Cell &arg) const{\n\t\t\treturn col < arg.col;\n\t};\n\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\tmin_Time[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Cell> V;\n\n\tchar map[H][W+1];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%s\",&map[i][k]);\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tV.push_back(Cell(i,k));\n\t\t\t\tmap[i][k] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\n\tint first_left_row,first_left_col,first_right_row,first_right_col,add_time;\n\n\tfor(int a = 0; a < V.size(); a++){\n\n\t\tfirst_left_row = V[a].row;\n\t\tfirst_left_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_right_row = first_left_row + diff_row_right[i];\n\t\t\tfirst_right_col = first_left_col + diff_col_right[i];\n\n\t\t\tif(rangeCheck(first_right_row,first_right_col) == true && map[first_right_row][first_right_col] != 'X'){\n\t\t\t\tif(map[first_right_row][first_right_col] >= '0' && map[first_right_row][first_right_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_right_row][first_right_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Right));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfirst_right_row = V[a].row;\n\t\tfirst_right_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_left_row = first_right_row + diff_row_left[i];\n\t\t\tfirst_left_col = first_right_col + diff_col_left[i];\n\n\t\t\tif(rangeCheck(first_left_row,first_left_col) == true && map[first_left_row][first_left_col] != 'X'){\n\t\t\t\tif(map[first_left_row][first_left_col] >= '0' && map[first_left_row][first_left_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_left_row][first_left_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Left));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM,next_left_row,next_left_col,next_right_row,next_right_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.top().left_row][Q.top().left_col] == 'T' || map[Q.top().right_row][Q.top().right_col] == 'T'){\n\t\t\tans = min(ans,Q.top().time);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > min_Time[Q.top().left_row][Q.top().left_col][Q.top().right_row][Q.top().right_col][Q.top().foot] || Q.top().time > ans){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(Q.top().foot == Left){\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_right_row = Q.top().left_row + diff_row_right[i];\n\t\t\t\t\tnext_right_col = Q.top().left_col + diff_col_right[i];\n\n\t\t\t\t\tif(rangeCheck(next_right_row,next_right_col) == true && map[next_right_row][next_right_col] != 'X'){\n\t\t\t\t\t\tif(map[next_right_row][next_right_col] >= '0' && map[next_right_row][next_right_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_right_row][next_right_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[Q.top().left_row][Q.top().left_col][next_right_row][next_right_col][Right] > Q.top().time+add_time){\n\t\t\t\t\t\t\tmin_Time[Q.top().left_row][Q.top().left_col][next_right_row][next_right_col][Right] = Q.top().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(Q.top().left_row,Q.top().left_col,next_right_row,next_right_col,Q.top().time+add_time,Right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //Q.top().foot == Right\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_left_row = Q.top().right_row + diff_row_left[i];\n\t\t\t\t\tnext_left_col = Q.top().right_col + diff_col_left[i];\n\n\t\t\t\t\tif(rangeCheck(next_left_row,next_left_col) == true && map[next_left_row][next_left_col] != 'X'){\n\t\t\t\t\t\tif(map[next_left_row][next_left_col] >= '0' && map[next_left_row][next_left_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_left_row][next_left_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[next_left_row][next_left_col][Q.top().right_row][Q.top().right_col][Left] > Q.top().time+add_time){\n\t\t\t\t\t\t\tmin_Time[next_left_row][next_left_col][Q.top().right_row][Q.top().right_col][Left] = Q.top().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(next_left_row,next_left_col,Q.top().right_row,Q.top().right_col,Q.top().time+add_time,Left));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_Time = new int****[60];\n\tfor(int i = 0; i < 60; i++){\n\t\tmin_Time[i] = new int***[30];\n\t\tfor(int k = 0; k < 30; k++){\n\t\t\tmin_Time[i][k] = new int**[60];\n\t\t\tfor(int p = 0; p < 60; p++){\n\t\t\t\tmin_Time[i][k][p] = new int*[30];\n\t\t\t\tfor(int q = 0; q < 30; q++)min_Time[i][k][p][q] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define MAX_W 30\n#define MAX_H 60\n\nint inf = 1<<29;\n\nint W, H;\nchar s[MAX_H+1][MAX_W+1];\nint dist[MAX_H+1][MAX_W+1][2];\n\nstruct state{\n\tint dist, y, x, foot;\n\tstate(int a, int b, int c, int d):dist(a),y(b),x(c),foot(d){}\n};\n\nbool operator<(const state& a, const state& b){ return a.dist > b.dist; }\n\nint solve(){\n\tfor (int k = 0; k < 2; k++)\n\t{\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W ; j++)\n\t\t\t{\n\t\t\t\tdist[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<state> Q;\n\tfor (int j = 0; j < W; j++)\n\t{\n\t\tif(s[H-1][j] == 'S'){\n\t\t\tQ.push(state(0, H-1, j, 1));\n\t\t\tQ.push(state(0, H-1, j, 0));\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tstate tp = Q.top(); Q.pop();\n\t\tif(s[tp.y][tp.x] == 'T') return tp.dist;\n\t\tif(dist[tp.y][tp.x][tp.foot] != inf) continue;\n\t\tdist[tp.y][tp.x][tp.foot] = tp.dist;\n\t\tfor (int dx = 1; dx <= 3; dx++)\n\t\t{\n\t\t\tfor (int dy = -2; dy <= 2 ; dy++)\n\t\t\t{\n\t\t\t\tif(dx + abs(dy) <= 3){\n\t\t\t\t\tint ny= tp.y + dy;\n\t\t\t\t\tint nx= tp.x + (tp.foot?dx:-dx);\n\t\t\t\t\tint nf = 1-tp.foot;\n\t\t\t\t\tif(0 <= ny && ny < H && 0 <= nx && nx < W && s[ny][nx] != 'X' && dist[ny][nx][nf] == inf){\n\t\t\t\t\t\tint d;\n\t\t\t\t\t\tif(s[ny][nx] >= '0' && s[ny][nx] <= '9'){\n\t\t\t\t\t\t\td = tp.dist + (s[ny][nx] - '0');\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\td = tp.dist;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.push(state(d, ny, nx, nf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(int argc, char const *argv[])\n{\n\twhile(1){\n\t\tcin >> W >> H;\n\t\tif(W == 0) break;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nchar map[64][32];\n\nclass Trl\n{\npublic:\n\tint lx, ly, rx, ry, c;\n\tbool n;\n\tTrl(int lx, int ly, int rx, int ry, int c, bool n)\n\t\t: lx(lx), ly(ly), rx(rx), ry(ry), c(c), n(n) {}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c > t.c;\n\t}\n};\n\nbool v[60][30][60][30][2];\nint dx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nint dy[] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\n\nint main()\n{\n\tint W, H;\n\twhile (cin >> W >> H, W||H)\n\t{\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tcin >> map[y][x];\n\n\t\tmemset(v, 0, sizeof(v));\n\t\tpriority_queue<Trl> q;\n\t\t\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tif (map[y][x] == 'S')\n\t\t\t{\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 1));\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 0));\n\t\t\t}\n\t\tbool f = 0;\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tTrl t = q.top(); q.pop();\n\n\t\t\tif (v[t.ly][t.lx][t.ry][t.rx][t.n]) continue;\n\t\t\tv[t.ly][t.lx][t.ry][t.rx][t.n] = 1;\n\n\t\t\tif (map[t.ly][t.lx]=='T' || map[t.ry][t.rx]=='T')\n\t\t\t{\n\t\t\t\tcout << t.c << endl;\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0; i<9; i++)\n\t\t\t{\n\t\t\t\tint nx, ny;\n\t\t\t\tTrl ne = t;\n\t\t\t\tif (t.n)\n\t\t\t\t{\n\t\t\t\t\tnx = t.lx + dx[i];\n\t\t\t\t\tny = t.ly + dy[i];\n\t\t\t\t\tne.rx = nx;\n\t\t\t\t\tne.ry = ny;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnx = t.rx - dx[i];\n\t\t\t\t\tny = t.ry - dy[i];\n\t\t\t\t\tne.lx = nx;\n\t\t\t\t\tne.ly = ny;\n\t\t\t\t}\n\n\t\t\t\tif (nx<0||nx>=W||ny<0||ny>=H) continue;\n\t\t\t\tif (map[ny][nx] == 'X') continue;\n\n\t\t\t\tif (map[ny][nx] != 'T' && map[ny][nx] != 'S')\n\t\t\t\t\tne.c += map[ny][nx] - '0';\n\t\t\t\t\n\t\t\t\tne.n = !ne.n;\n\t\t\t\tif (v[ne.ly][ne.lx][ne.ry][ne.rx][ne.n]) continue;\n\t\t\t\tq.push(ne);\n\t\t\t}\n\t\t}\n\n\t\tif (!f)\n\t\t\tcout << -1 << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n#define INF 999999999\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(n);i++)\nvector<vector<char> > inp;\nint w,h;\n\nint dx[]={-3,-2,-2,-2,-1,-1,-1,-1,-1};\nint dy[]={0,-1,0,1,-2,-1,0,1,2};\n\nstruct st{\n    pii p;\n    int bef;\n    int c;\n    bool operator < (const st & a) const{\n        return this->c > a.c;\n    }\n};\nint cost[65][65][2];\n\n#define y first\n#define x second\nint solve(vector<pii> poses){\n    fill(**cost,**cost+65*65*2,INF);\n    int ret = INF;\n    priority_queue<st> que;\n    for(int i = 0; i < poses.size(); i++) {\n        pii pos = poses[i];\n        que.push(st{pos,0,0});\n        que.push(st{pos,1,0});\n        cost[pos.y][pos.x][0] = 0;\n        cost[pos.y][pos.x][1] = 0;\n    }\n    while(que.size()){\n        st q = que.top();\n        que.pop();\n        int val, add;\n        val = q.c;\n        rep(i,9){\n            pii nex = q.p;\n            int dir = q.bef ? 1 : -1;\n            nex.y += dy[i];\n            nex.x += dx[i] * dir;\n            int bef = !q.bef;\n            if(nex.y<0||nex.x<0||nex.y>=h||nex.x>=w)continue;\n            if(inp[nex.y][nex.x] == 'T') {\n                ret = min(ret,val);\n                continue;\n            }\n            else if(inp[nex.y][nex.x] == 'S') {\n                add = 0;\n            }\n            else if(inp[nex.y][nex.x] == 'X') {\n                continue;\n            }\n            else {\n                add = inp[nex.y][nex.x] - '0';\n            }\n            if(cost[nex.y][nex.x][bef]>val+add){\n                que.push(st{nex,bef,val+add});\n                cost[nex.y][nex.x][bef]=val+add;\n            }\n        }\n    }\n    if(ret == INF) return -1;\n    return ret;\n}\n\nint main(){\n    while(cin>>w>>h,w||h){\n        inp.clear();\n        inp.resize(h,vector<char>(w));\n        rep(i,h){\n            rep(j,w){\n                cin>>inp[i][j];\n            }\n        }\n        vector<pii> vp;\n        rep(i,h)rep(j,w)if(inp[i][j]=='S')vp.push_back(pii(i,j));\n        cout<<solve(vp)<<endl;\n    }\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 19191919;\nint w,h;\nchar s[100][100];\nint f[100][100];\n\n// next step: left(0), right(1)\nint dp[60][30][60][30][2];\n\nstruct State{\n    int ly,lx,ry,rx,LR;\n};\n\nint main()\n{\n    while(scanf(\" %d %d\", &w, &h),w)\n    {\n        rep(i,h)rep(j,w)\n        {\n            scanf(\" %c\", &s[i][j]);\n            if(s[i][j]=='X') f[i][j]=-1;\n            else if(s[i][j]=='S' || s[i][j]=='T') f[i][j]=0;\n            else f[i][j] = s[i][j]-'0';\n        }\n\n        // initialize\n        rep(i,60)rep(j,30)rep(k,60)rep(l,30)rep(m,2) dp[i][j][k][l][m]=INF;\n\n        queue<State> que;\n        rep(i,h)rep(j,w)if(s[i][j]=='S')\n        {\n            dp[0][0][i][j][0] = 0;\n            que.push({0,0,i,j,0});\n            dp[i][j][0][0][1] = 0;\n            que.push({i,j,0,0,1});\n        }\n\n        #define IN(y,x) (0<=y && y<h && 0<=x && x<w)\n        int dy[5]={-2,-1,0,1,2};\n        int limx[5]={1,2,3,2,1};\n        while(!que.empty())\n        {\n            State n = que.front();\n            que.pop();\n\n            // printf(\" (%d %d %d %d %d)\\n\", n.ly,n.lx,n.ry,n.rx,n.LR);\n\n            int sx,sy,mul;\n            if(n.LR == 0)\n            {\n                sx = n.rx;\n                sy = n.ry;\n                mul = -1;\n            }\n            else\n            {\n                sx = n.lx;\n                sy = n.ly;\n                mul = 1;\n            }\n\n            rep(d,5)for(int i=1; i<=limx[d]; ++i)\n            {\n                int ny = sy+dy[d];\n                int nx = sx+mul*i;\n                if(IN(ny,nx) && f[ny][nx]!=-1)\n                {\n                    if(n.LR==0)\n                    {\n                        if(dp[ny][nx][sy][sx][1] > dp[n.ly][n.lx][n.ry][n.rx][0]+f[ny][nx])\n                        {\n                            dp[ny][nx][sy][sx][1] = dp[n.ly][n.lx][n.ry][n.rx][0]+f[ny][nx];\n                            que.push({ny,nx,sy,sx,1});\n                        }\n                    }\n                    else\n                    {\n                        if(dp[sy][sx][ny][nx][0] > dp[n.ly][n.lx][n.ry][n.rx][1]+f[ny][nx])\n                        {\n                            dp[sy][sx][ny][nx][0] = dp[n.ly][n.lx][n.ry][n.rx][1]+f[ny][nx];\n                            que.push({sy,sx,ny,nx,0});\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = INF;\n        rep(i,h)rep(j,w)if(s[i][j]=='T')\n        {\n            rep(k,h)rep(l,w)\n            {\n                ans = min(ans,dp[k][l][i][j][0]);\n                ans = min(ans,dp[i][j][k][l][1]);\n            }\n        }\n        if(ans == INF) ans = -1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[66][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint mincost[2][66][33];\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  for(int i = 0; i < 66; i++) {\n    for(int j = 0; j < 33 j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[(lr+1)%2][ny][nx]) {\n\t  mincost[(lr+1)%2][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, (lr+1)%2), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int li,lj,ri,rj,f;\n  int dist;\n};\nbool operator<(const state& a,const state& b){ return a.dist > b.dist; }\n\nint h,w;\nchar s[111][111];\nint dist[33][66][3];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    priority_queue<state> que;\n    rep(i,33)rep(j,66)rep(k,3)dist[i][j][k]=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='S'){\n        que.push((state){i,j,-1,-1,0,0});\n        que.push((state){-1,-1,i,j,1,0});\n      }\n    }\n    while(que.size()){\n      state ns=que.top(); que.pop();\n      int li=ns.li,lj=ns.lj,ri=ns.ri,rj=ns.rj,f=ns.f,nd=ns.dist;\n      if((f==0&&dist[li][lj][0]!=INF)||(f==1&&dist[ri][rj][1]!=INF))continue;\n      if(f==0){\n        //dbg(li); dbg(lj);\n        dist[li][lj][f]=nd;\n        repl(ni,li-2,li+3)repl(nj,lj+1,lj+4){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-li)+abs(nj-lj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){li,lj,ni,nj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }else{\n        dist[ri][rj][f]=nd;\n        repl(ni,ri-2,ri+3)repl(nj,rj-3,rj){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-ri)+abs(nj-rj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){ni,nj,ri,rj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }\n    }\n    int res=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='T')minch(res,min(dist[i][j][0],dist[i][j][1]));\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = f.rx = i;\n\t\t\t\tf.ly = f.ry = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tpq.push(f);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1000*1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(pq.size() > ans) break;\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 61\n#define MAX_W 31\n#define INF 1e9\n#define Fi first\n#define Se second\ntypedef pair<int,int> pii;\n\nstruct State{\n  int d,x,y;\n  bool f;\n  State(){}\n  State(int d,int x,int y,bool f) :\n    d(d),x(x),y(y),f(f) {}\n  bool operator > (const State &s)const{\n    return d > s.d;\n  }\n};\n\nint W,H;\nint ps;\npii S[MAX_W],T[MAX_W];\nchar field[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W][2];\nbool G[MAX_H][MAX_W];\n\nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n\nbool inField(int x,int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  fill(dist[0][0],dist[0][0]+MAX_H*MAX_W*2,INF);\n  for(int i = 0 ; i < ps ; i++){\n    Q.push(State(0,S[i].Fi,S[i].Se,0)); \n    Q.push(State(0,S[i].Fi,S[i].Se,1));\n    dist[S[i].Se][S[i].Fi][0] = 0;\n    dist[S[i].Se][S[i].Fi][1] = 0;\n  }\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int x = s.x, y = s.y;\n\n    if(dist[y][x][s.f] < s.d) continue;\n    if(G[y][x]) return s.d;\n    \n    if(s.f){\n      for(int i = 0 ; i < 9 ; i++){\n        int nx = x - dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == 'X') continue;\n        int t = field[ny][nx] - '0';\n        if(s.d + t < dist[ny][nx][0]){\n          dist[ny][nx][0] = s.d + t;\n          Q.push(State(dist[ny][nx][0],nx,ny,0));\n        }\n      }\n    }else{\n      for(int i = 0 ; i < 9 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == 'X') continue;\n        int t = field[ny][nx] - '0';\n        if(s.d + t < dist[ny][nx][1]){\n          dist[ny][nx][1] = s.d + t;\n          Q.push(State(dist[ny][nx][1],nx,ny,1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  dijkstra();\n  while(cin >> W >> H, W){\n    ps = 0;\n    memset(G,false,sizeof(G));\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'S'){\n          S[ps++] = pii(j,i);\n          field[i][j] = '0';\n        }else if(field[i][j] == 'T'){\n          G[i][j] = true;\n          field[i][j] = '0';      \n        }\n      }\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int li,lj,ri,rj,f;\n  int dist;\n};\nbool operator<(const state& a,const state& b){ return a.dist > b.dist; }\n\nint h,w;\nchar s[111][111];\nint dist[66][66][3];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    priority_queue<state> que;\n    rep(i,33)rep(j,66)rep(k,3)dist[i][j][k]=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='S'){\n        que.push((state){i,j,-1,-1,0,0});\n        que.push((state){-1,-1,i,j,1,0});\n      }\n    }\n    while(que.size()){\n      state ns=que.top(); que.pop();\n      int li=ns.li,lj=ns.lj,ri=ns.ri,rj=ns.rj,f=ns.f,nd=ns.dist;\n      if((f==0&&dist[li][lj][0]!=INF)||(f==1&&dist[ri][rj][1]!=INF))continue;\n      if(f==0){\n        //dbg(li); dbg(lj);\n        dist[li][lj][f]=nd;\n        repl(ni,li-2,li+3)repl(nj,lj+1,lj+4){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-li)+abs(nj-lj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){li,lj,ni,nj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }else{\n        dist[ri][rj][f]=nd;\n        repl(ni,ri-2,ri+3)repl(nj,rj-3,rj){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-ri)+abs(nj-rj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){ni,nj,ri,rj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }\n    }\n    int res=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='T')minch(res,min(dist[i][j][0],dist[i][j][1]));\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  vector<P2> G[2][100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,-1,-2,-1,0,-1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> grid[i][j];\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tG[0][i][j].clear();\n\tG[1][i][j].clear();\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      /*\n      if(grid[y][x] == 'T'){\n\tcout << t << endl;\n\tq.push(p);\n\tbreak;\n      }\n      */\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(grid[i][j] == 'T')\n\t  ans = min(ans,min(d[0][i][j],d[1][i][j]));\n    if(ans ==INF)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct State{\n  int x,y,t;\n  bool isR;\n  State(){}\n  State(int a, int b, int c, bool d):\n    x(a),y(b),t(c),isR(d){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nconst int MW = 31;\nconst int MH = 61;\nconst int INF = (1<<25);\n\nint M[MH][MW],T[MH][MW][2],w,h;\nvector<P> S;\nvector<P> G;\n\nvoid print(){\n  for(int i = 0; i < h; i++){\n    for(int x = 0; x < 2; x++){\n      for(int j = 0; j < w; j++) \n\tif(T[i][j][x] == INF) cout << \"  X\";\n\telse printf(\"%3d\",T[i][j][x]);\n      cout << \"                 \";\n    } \n    cout << endl;\n  }\n  cout << endl << endl;\n}\n\nbool isInside(int x, int y) {return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  for(int i = 0; i < MH; i++)\n    for(int j = 0; j < MW; j++) T[i][j][0] = T[i][j][1] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      char c;\n      cin >> c;\n      if(c == 'X') M[i][j] = INF;\n      else if(c == 'T'){\n\tM[i][j] = 0;\n\tG.push_back(P(j,i));\n      }else if(c == 'S'){\n\tM[i][j] = 0;\n\tS.push_back(P(j,i));\n      }else M[i][j] = c-'0';\n    }\n}\n\nint solve(bool R){\n  \n  init();\n\n  priority_queue<State> Q;\n\n  for(int i = 0; i < S.size(); i++){\n    int sx = S[i].first;\n    int sy = S[i].second;\n    Q.push(State(sx,sy,0,R));\n    T[sy][sx][R] = 0;\n  }\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    if(T[now.y][now.x][now.isR] < now.t) continue;\n    \n    for(int i = 1; i <= 3; i++)\n      for(int j = -2; j <= 2; j++){\n\tint mx = i,my = j;\n\tif(now.isR) mx *= -1;\n\tint nx = now.x+mx;\n\tint ny = now.y+my;\n\t\n\t//\tif(abs(mx) + abs(my) <= 3) cout << now.isR << \" \" <<  mx << \" \" << my << \" \" << endl;\n\tif(isInside(nx,ny) && abs(mx)+abs(my) <= 3 && T[ny][nx][!now.isR] > now.t+M[ny][nx]){\n\t  T[ny][nx][!now.isR] = now.t+M[ny][nx];\n\t  Q.push(State(nx,ny,now.t+M[ny][nx],!now.isR));\n\t}\n      }\n  }\n\n  //print();\n  int ans = INF;\n\n  for(int i = 0; i < G.size(); i++) ans = min(ans,min(T[G[i].second][G[i].first][0],T[G[i].second][G[i].first][1]));\n\n  return ans;\n}\n\nint main(){\n\n  while(cin >> w >> h && w+h){\n    S.clear();\n    G.clear();\n    input();\n    int ans = min(solve(true),solve(false));\n    if(ans == INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define H 60\n#define W 30\n#define INF 10000\n#define R 1\n#define L 0\nint w, h;\nchar maps[H][W];\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][2];\n    bool used[H][W][2];\n    int ldx[9] = {-1, -1, -1, -1, -1, -2, -2, -2, -3};\n    int ldy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    int rdx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n    int rdy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    for (int i = 0; i < w - 1; i++) {\n        if (maps[h-1][i] == 'S') {\n            d[h - 1][i][L] = 0; d[h - 1][i][R] = 0;\n        }\n    }\n    \n    while (true) {\n        point p;\n        p.x = -1; p.y = -1;\n        int muki = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (!used[i][j][k] && (p.x == -1 || d[i][j][k] < d[p.y][p.x][muki])) {\n                        p.x = j; p.y = i; muki = k;\n                    }\n                }\n            }\n        }\n        \n        if (p.x == -1 && p.y == -1) {\n            break;\n        }\n        used[p.y][p.x][muki] = true;\n        \n        if (muki == R) {\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + ldx[i];\n                int my = p.y + ldy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R]);\n                }\n                else{\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n        else{\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + rdx[i];\n                int my = p.y + rdy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L]);\n                }\n                else{\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int j = 0; j < w; j++) {\n        if (maps[0][j] == 'T'){\n            for (int k = 0; k < 2; k++) {\n                ans = min(ans, d[0][j][k]);\n            }\n        }\n    }\n    if (ans == INF) {\n        return -1;\n    }\n    else {\n        return ans;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> maps[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    はあ辛い\n */\n\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define LEFT 0\n#define RIGHT 1\n#define INF 0x3fffffff\n\ntypedef pair<int, int> Coor;\ntypedef pair<int, Coor> Data;\ntypedef pair<int, Data> Pair;\n\nint w;\nint h;\nint ans;\nbool is_goal[60][30];\nint cost[60][30];\nint lmin[60][30];\nint rmin[60][30];\n\nint main() {\n    while (1) {\n        priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0) return 0;\n\n        ans = INF;\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                lmin[i][j] = INF;\n                rmin[i][j] = INF;\n            }\n        }\n\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                char c;\n\n                is_goal[i][j] = false;\n                scanf(\" %c\", &c);\n                if (c == 'X') {\n                    cost[i][j] = INF;\n                } else if (c == 'S') {\n                    cost[i][j] = 0;\n                    lmin[i][j] = 0;\n                    rmin[i][j] = 0;\n                    q.push(Pair(0, Data(LEFT, Coor(j, i))));\n                    q.push(Pair(0, Data(RIGHT, Coor(j, i))));\n                } else if (c == 'T') {\n                    cost[i][j] = 0;\n                    is_goal[i][j] = true;\n                } else {\n                    cost[i][j] = c - '0';\n                    assert(1 <= cost[i][j] && cost[i][j] <= 9);\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            Pair p = q.top(); q.pop();\n            int dist = p.first;\n            Data d = p.second;\n            int last = d.first;\n            Coor c = d.second;\n            int x = c.first;\n            int y = c.second;\n\n            if (last ==  LEFT && dist > lmin[y][x]) continue;\n            if (last == RIGHT && dist > rmin[y][x]) continue;\n\n            if (last == LEFT) {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x + 3-i;\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n                        if (cost[_y][_x] == INF) continue;\n\n                        if (rmin[_y][_x] > dist + cost[_y][_x]) {\n                            rmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, rmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(rmin[_y][_x], Data(RIGHT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            } else {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x - (3-i);\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n                        if (cost[_y][_x] == INF) continue;\n\n                        if (lmin[_y][_x] > dist + cost[_y][_x]) {\n                            lmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, lmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(lmin[_y][_x], Data(LEFT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (ans < INF) {\n            printf(\"%d\\n\", ans);\n        } else {\n            puts(\"-1\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\ntypedef pair<int,pair<int,pint> > joutai;\n\nbool operator<(joutai a,joutai b){\n\treturn a.x<b.x;\n}\n\nint dy[2][9]={1,1,2,1,2,3,1,2,1,-1,-1,-2,-1,-2,-3,-1,-2,-1};\nint dx[2][9]={2,1,1,0,0,0,-1,-1,-2,2,1,1,0,0,0,-1,-1,-2};\n\nint main(){\n\tint gake[70][70],memo[70][70][2];\n\tint i,j,k;\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tif(w==0 && h==0) break;\n\t\tchar in;\n\t\tpriority_queue<joutai> pq;\n\t\tjoutai j1;\n\t\tfor(i=3;i<h+3;i++){\n\t\t\tfor(j=3;j<w+3;j++){\n\t\t\t\tscanf(\"%1s\",&in);\n\t\t\t\tif(in=='T'){\n\t\t\t\t\tgake[i][j]=0;\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t}else if(in=='S'){\n\t\t\t\t\tgake[i][j]=INF;\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t\tj1.x=0;\n\t\t\t\t\tj1.y.x=0;\n\t\t\t\t\tj1.y.y=pint(i,j);\n\t\t\t\t\tpq.push(j1);\n\t\t\t\t\tj1.y.x=1;\n\t\t\t\t\tj1.y.y=pint(i,j);\n\t\t\t\t\tpq.push(j1);\n\t\t\t\t}else if(in=='X'){\n\t\t\t\t\tgake[i][j]=-1;\n\t\t\t\t\tmemo[i][j][0]=-1;\n\t\t\t\t\tmemo[i][j][1]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tgake[i][j]=(in-'0');\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tj1=pq.top(); pq.pop();\n\t\t\tmemo[j1.y.y.x][j1.y.y.y][j1.y.x]= -j1.x;\n\t//\t\tcout << j1.y.y.x-1 <<\"\t\" << j1.y.y.y-1 << \"\t\" << j1.y.x <<\"\t\t\" << -j1.x << endl;\n\t\t\tif(gake[j1.y.y.x][j1.y.y.y]==0){\n\t\t\t\tcout << -j1.x << endl;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t\tfor(j=0;j<9;j++){\n\t\t\t\tjoutai nxt;\n\t\t\t\tnxt=j1;\n\t\t\t\tnxt.y.y.x= j1.y.y.x + dx[j1.y.x][j];\n\t\t\t\tnxt.y.y.y= j1.y.y.y + dy[j1.y.x][j];\n\t\t\t\tnxt.y.x= (j1.y.x+1)%2;\n\t\t\t\tif(memo[nxt.y.y.x][nxt.y.y.y][nxt.y.x]==INF){\n\t\t\t\t\tnxt.x=j1.x-gake[nxt.y.y.x][nxt.y.y.y];\n\t\t\t\t\tpq.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"-1\" << endl;\n\tok:;\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define INF (1<<28)\ntypedef pair<int,int> P;\nstruct state{\n  vector<P> pos;\n  int cost;\n  bool operator < (const state &p)const{return cost>p.cost;}\n};\nint W,H;\nint t[60][30];\nmap<vector<P>,int> d;\nvector<P> A,B;\n\nvoid init(){\n  A.clear();\n  B.clear();\n  d.clear();\n}\n\nint dist(P a,P b){\n  return abs(a.first-b.first)+abs(a.second-b.second);\n}\n\nint solve(){\n  P sl=min(A[0],A[1]),sr=max(A[0],A[1]);\n  P tl=min(B[0],B[1]),tr=max(B[0],B[1]);\n  vector<P> vec(3);\n  vec[0]=sl;vec[1]=sr;vec[2]=P(0,0);\n  state s=(state){vec,1};\n  priority_queue<state> Q;\n  Q.push(s);\n  d[s.pos]=1;\n  s.pos[2].first=1;\n  Q.push(s);\n  d[s.pos]=1;\n  \n  swap(s.pos[0],s.pos[1]);\n  Q.push(s);\n  d[s.pos]=1;\n  s.pos[2].first=1;\n  Q.push(s);\n  d[s.pos]=1;\n\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n\n    /*\n    cout<<s.pos[0].first<<\" \"<<s.pos[0].second<<endl;\n    cout<<s.pos[1].first<<\" \"<<s.pos[1].second<<endl;\n    cout<<s.cost<<endl;\n    */\n    if(s.pos[0]==tl||s.pos[1]==tr)return s.cost-1;\n    if(s.pos[1]==tl||s.pos[0]==tr)return s.cost-1;\n    int f=s.pos[2].first;\n    \n    for(int i=-4;i<=4;i++){\n      for(int j=-4;j<=4;j++){\n\tstate next=s;\n\tint nx=s.pos[1-f].first+i;\n\tint ny=s.pos[1-f].second+j;\n\tif(i==0&&j==0)continue;\n\tif(nx<0||ny<0)continue;\n\tif(nx>=W||ny>=H)continue;\n\tif(t[ny][nx]==INF)continue;\n\tnext.pos[f].first=nx;\n\tnext.pos[f].second=ny;\n\tnext.pos[2].first=1-f;\n\tnext.cost=s.cost+t[ny][nx];\n\tif(next.pos[1].first<=next.pos[0].first)continue;\n\tif(dist(next.pos[0],next.pos[1])>3)continue;\n\tif(d[next.pos]==0)d[next.pos]=INF;\n\tif(next.cost>=d[next.pos])continue;\n\t\n\td[next.pos]=next.cost;\n\tQ.push(next);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    init();\n    char ch;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>ch;\n\tt[i][j]=0;\n\tif(ch=='X')t[i][j]=INF;\n\telse if(ch=='S')A.push_back(P(j,i));\n\telse if(ch=='T')B.push_back(P(j,i));\n\telse t[i][j]=ch-'0';\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][31][61][31];\nint dl[61][61];\nint dr[61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tfill(&dl[0][0], &dl[60][60] + 1, INF);\n\t\tfill(&dr[0][0], &dr[60][60] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tdl[j][i] = dr[j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > dis + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = dis + cost;\n\t\t\t\t//\t\tdr[xr2][yr2] = min(dr[xr2][yr2], memo[xl][yl][xr2][yr2]);\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > dis + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = dis + cost;\n\t\t\t\t\t\tdl[xl2][yl2] = min(dl[xl2][yl2], memo[xl2][yl2][xr][yr]);\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q; // 0:left, 1:right\ntypedef pair<int, Q> R;\nconst int INF = 1000000000;\n\nint w, h;\nchar s[60][40];\n\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3}; // left > minas\nint dy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nint dp[2][60][30]; // before left : 0\nint dijkstra() {\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) dp[0][i][j] = dp[1][i][j] = INF;\n  priority_queue<R, vector<R>, greater<R> > que;\n  for (int j = 0; j < w; j++) if (s[h - 1][j] == 'S') {\n    dp[0][h - 1][j] = dp[1][h - 1][j] = 0;\n    que.push(R(0, Q(P(j, h - 1), 1)));\n    que.push(R(0, Q(P(j, h - 1), 0)));\n  }\n  while (!que.empty()) {\n    R r = que.top(); que.pop();\n    int cost = r.first, x = r.second.first.first, y = r.second.first.second, left = r.second.second;\n    if (cost > dp[left][y][x]) continue;\n    for (int i = 0; i < 9; i++) {\n      int nx = x, ny = y + dy[i];\n      if (left == 0) nx -= dx[i];\n      else nx += dx[i];\n      if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if (s[ny][nx] == 'X') continue;\n      if (s[ny][nx] == 'S') continue;\n      if (s[ny][nx] == 'T') {\n        return dp[left][y][x];\n      } else if (dp[!left][ny][nx] > dp[left][y][x] + (int) s[ny][nx] - '0') {\n        dp[!left][ny][nx] = dp[left][y][x] + (int) s[ny][nx] - '0';\n        que.push(R(dp[!left][ny][nx], Q(P(nx, ny), !left)));\n      }\n    }\n  }\n  int ans = INF;\n  for (int j = 0; j < w; j++) if (s[0][j] == 'T') ans = min(ans, min(dp[0][0][j], dp[1][0][j]));\n  if (ans == INF) ans = -1;\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) scanf(\" %c\", &s[i][j]);\n    printf(\"%d\\n\", dijkstra());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      queue<pi> Q;\n      queue<bool> R;\n    \n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\" %c\",&S[i][j]);\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t  Q.push(pi(i,j));\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(0);\n\t\t  R.push(1);\n\t\t}\t      \n\t    }\n\t}\n      \n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n};\n\nint main()\n{\n\twhile(1){\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0) return 0;\n\t\tchar s[61][31];\n\t\tvector<edge> v[4000];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t\tif(s[i][j]=='S'){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to=2*(i*w+j+1), e.cost=0;\n\t\t\t\t\tv[0].push_back(e);\n\t\t\t\t\te.to=2*(i*w+j)+1;\n\t\t\t\t\tv[0].push_back(e);\n\t\t\t\t}else if(s[i][j]=='T'){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to=2*h*w+1, e.cost=0;\n\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tfor(int k=1; k<=3; k++){\n\t\t\t\t\tif(j+k>=w) continue;\n\t\t\t\t\tfor(int l=-(3-k); l<=3-k; l++){\n\t\t\t\t\t\tif(i+l<0 || i+l>=h) continue;\n\t\t\t\t\t\tif(s[i+l][j+k]=='X') continue;\n\t\t\t\t\t\tif(s[i+l][j+k]=='S' || s[i+l][j+k]=='T'){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to=2*((i+l)*w+j+k)+1, e.cost=0;\n\t\t\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=s[i+l][j+k]-'0', e.to=2*((i+l)*w+j+k)+1;\n\t\t\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1; k<=3; k++){\n\t\t\t\t\tif(j-k<0) continue;\n\t\t\t\t\tfor(int l=-(3-k); l<=3-k; l++){\n\t\t\t\t\t\tif(i+l<0 || i+l>=h) continue;\n\t\t\t\t\t\tif(s[i+l][j-k]=='X') continue;\n\t\t\t\t\t\tif(s[i+l][j-k]=='S' || s[i+l][j-k]=='T'){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to=2*((i+l)*w+j-k+1), e.cost=0;\n\t\t\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=s[i+l][j-k]-'0', e.to=2*((i+l)*w+j-k+1);\n\t\t\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tint d[4000];\n\t\tfill(d, d+2*h*w+2, INF);\n\t\td[0]=0;\n\t\tque.push(P(0, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint x=p.second;\n\t\t\tif(p.first>d[x]) continue;\n\t\t\tfor(auto e:v[x]){\n\t\t\t\tif(d[e.to]>d[x]+e.cost){\n\t\t\t\t\td[e.to]=d[x]+e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[2*h*w+1]==INF){\n\t\t\tcout<<-1<<endl;\n\t\t}else{\n\t\t\tcout<<d[2*h*w+1]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint s_l, s_r, t_l, t_r;\nint d[30][60][2];\n//dijkstra\nint dijkstra(vector<vector<int>>&cost,State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = t_l; i <= t_r; i++) {\n\t\tint d_min = min(d[i][0][0], d[i][0][1]);\n\t\tres = min(res, d_min);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\t//input\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (s_flag == 0) {\n\t\t\t\t\t\ts_l = j; s_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\ts_r = j;\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (t_flag == 0) {\n\t\t\t\t\t\tt_l = j; t_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\tt_r = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = min(dijkstra(cliff, State(0, s_l, h - 1, 1)), dijkstra(cliff, State(0, s_l, h - 1, -1)));\n\t\tint ans1 = min(dijkstra(cliff, State(0, s_r, h - 1, 1)), dijkstra(cliff, State(0, s_r, h - 1, -1)));\n\t\tans = min(ans, ans1);\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nint H, W;\nint c(int h, int w, int isr) {\n\treturn isr * H * W + h * W + w;\n}\n\ntuple<int, int, int> f(int X) {\n\tint isr = X / (H * W);\n\tint h = (X % (H * W)) / W;\n\tint w = X % W;\n\treturn make_tuple(h, w, isr);\n}\n\nvector<ll> dijkstra(int start, vector<vector<pair<int, ll>>>& graph) {\n\tvector<ll> dist(graph.size(), INF); dist[start] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq; pq.emplace(0, start);\n\twhile (!pq.empty()) {\n\t\tll cost; int idx; tie(cost, idx) = pq.top(); pq.pop();\n\t\tif (dist[idx] < cost) continue;\n\t\tfor (auto next : graph[idx]) if (chmin(dist[next.first], cost + next.second)) pq.emplace(dist[next.first], next.first);\n\t}\n\treturn dist;\n}\n\nvoid solve() {\n\tcin >> W >> H; if (W == 0 and H == 0) exit(0);\n\tvector<vector<char>> a(H, vector<char>(W));\n\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) cin >> a[i][j];\n\tvector<vector<pair<int, ll>>> g(H * W * 2);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (a[i][j] == 'X') continue;\n\t\t\t//右足が最後\n\t\t\t{\n\t\t\t\tint cur = c(i, j, 1);\n\t\t\t\tfor (int nh = 0; nh < H; nh++) {\n\t\t\t\t\tfor (int nw = 0; nw < j; nw++) {\n\t\t\t\t\t\tif (abs(nh - i) + abs(nw - j) > 3) continue;\n\t\t\t\t\t\tif (a[nh][nw] == 'X') continue;\n\t\t\t\t\t\tint t = 0;\n\t\t\t\t\t\tif ('1' <= a[nh][nw] and a[nh][nw] <= '9') t += a[nh][nw] - '0';\n\t\t\t\t\t\tint nxt = c(nh, nw, 0);\n\t\t\t\t\t\tg[cur].emplace_back(nxt, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//左足が最後\n\t\t\t{\n\t\t\t\tint cur = c(i, j, 0);\n\t\t\t\tfor (int nh = 0; nh < H; nh++) {\n\t\t\t\t\tfor (int nw = j + 1; nw < W; nw++) {\n\t\t\t\t\t\tif (abs(nh - i) + abs(nw - j) > 3) continue;\n\t\t\t\t\t\tif (a[nh][nw] == 'X') continue;\n\t\t\t\t\t\tint t = 0;\n\t\t\t\t\t\tif ('1' <= a[nh][nw] and a[nh][nw] <= '9') t += a[nh][nw] - '0';\n\t\t\t\t\t\tint nxt = c(nh, nw, 1);\n\t\t\t\t\t\tg[cur].emplace_back(nxt, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll res = INF;\n\tvector<int> th, tw;\n\tvector<int> sh, sw;\n\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\tif (a[i][j] == 'T') {\n\t\t\tth.emplace_back(i);\n\t\t\ttw.emplace_back(j);\n\t\t}\n\t\tif (a[i][j] == 'S') {\n\t\t\tsh.emplace_back(i);\n\t\t\tsw.emplace_back(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < sh.size(); i++) {\n\t\t{\n\t\t\tauto d = dijkstra(c(sh[i], sw[i], 0), g);\n\t\t\tfor (int j = 0; j < th.size(); j++) {\n\t\t\t\tchmin(res, d[c(th[j], tw[j], 0)]);\n\t\t\t\tchmin(res, d[c(th[j], tw[j], 1)]);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tauto d = dijkstra(c(sh[i], sw[i], 1), g);\n\t\t\tfor (int j = 0; j < th.size(); j++) {\n\t\t\t\tchmin(res, d[c(th[j], tw[j], 1)]);\n\t\t\t\tchmin(res, d[c(th[j], tw[j], 0)]);\n\t\t\t}\n\t\t}\n\t}\n\tif (res == INF) res = -1;\n\tcout << res << \"\\n\";\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int W_MAX = 30;\nconst int H_MAX = 60;\nconst bool L = 0;\nconst bool R = 1;\n\ntypedef pair<int, int> P;\nconst int INF = INT_MAX;\nint w, h;\n\nchar board[H_MAX][W_MAX];\nint weight[H_MAX][W_MAX];\nint d[H_MAX][W_MAX][2];\n\nstruct node{\n  int cost;\n  P pos;\n  bool f;\n  bool operator>(const node& s) const {\n    return this->cost > s.cost;\n  }\n};\n\nstruct edge{\n  int cost;\n  P to;\n};\n\nvector<P> start;\nP p_pos;\nP dxy[9] = {P(1, -2), P(1, -1), P(1, 0),\n            P(1, 1), P(1, 2), P(2, -1),\n            P(2, 0), P(2, 1), P(3, 0)};\n\nbool check_pos(int x, int y) {\n  if(0 <= y && y < h && 0 <= x && x < w &&\n     !(board[y][x] == 'X')) return false;\n  return true;\n}\n\nint solve() {\n  fill(d[0][0], d[H_MAX][0], INF);\n  priority_queue<node, vector<node>, greater<node>> pq;\n  for(auto i: start) {\n    d[i.second][i.first][0] = 0;\n    d[i.second][i.first][1] = 0;\n    pq.push(node{0, P(i.first, i.second), L});\n    pq.push(node{0, P(i.first, i.second), R});\n  }\n\n  while(!pq.empty()) {\n    P pos = pq.top().pos;\n    bool f = pq.top().f;\n    pq.pop();\n    if (board[pos.second][pos.first] == 'T') {\n      return d[pos.second][pos.first][f];\n    }\n    for(int i = 0; i < 9; i++) {\n      int nextx = pos.first  + (f ? dxy[i].first : -dxy[i].first);\n      int nexty = pos.second + (f ? dxy[i].second : -dxy[i].second);\n      if(check_pos(nextx, nexty)) continue;\n      if(d[nexty][nextx][!f] > d[pos.second][pos.first][f] +\n         weight[nexty][nextx]) {\n        d[nexty][nextx][!f] =\n          d[pos.second][pos.first][f] + weight[nexty][nextx];\n        pq.push(node{d[nexty][nextx][!f], P(nextx, nexty), !f});\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> w >> h && !(w + h == 0)) {\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        cin >> board[i][j];\n        if(board[i][j] == 'S') {\n          weight[i][j] = 0;\n          start.push_back(P(j, i));\n        }else if(board[i][j] == 'T') {\n          weight[i][j] = 0;\n        }else {\n          weight[i][j] = (board[i][j] - '0');\n        }        \n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef struct {\n  int to, cost;\n}edge;\ntypedef pair<int, int> P;\n\nconst int start = 2*30*60;\nconst int MAX_V = 2*30*60+1;\nconst int INF = 1000000000;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nint ctoi(char c) {\n  if ('0' <= c and c <= '9')\n    return (int)(c - '0');\n  else if (c == 'T')\n    return 0;\n  else\n    return (int)c;\n}\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P(0, s));\n\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (int i = 0; i < G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  int lx[9] = {1, 2, 3, 1, 2, 1, 2, 1, 1};\n  int ly[9] = {0, 0, 0, 1, 1, -1, -1, 2, -2};\n  int rx[9] = {-1, -2, -3, -1, -2, -1, -2, -1, -1};\n  int ry[9] = {0, 0, 0, 1, 1, -1, -1, 2, -2};\n  while (true) {\n    int w, h;\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0 and h == 0) break;\n\n    int s[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tchar c;\n\tcin >> c;\n\ts[i][j] = ctoi(c);\n      }\n    }\n    \n    for (int i = 0; i < MAX_V; i++)\n      G[i].clear();\n\n    vector<int> t;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tswitch(s[i][j]) {\n\tcase (int)('X'): break;\n\tcase 0: \n\t  t.push_back(2*(w*i+j));\n\t  t.push_back(2*(w*i+j)+1);\n\t  break;\n\tcase (int)('S'):\n\t  G[start].push_back(edge{2*(w*i+j), 0});\n\t  G[start].push_back(edge{2*(w*i+j)+1, 0});\n\tdefault:\n\t  for (int k = 0; k < 9; k++) {\n\t    int x = j + lx[k], y = i + ly[k];\n\t    if (0 <= x and x < w and 0 <= y and y < h and s[y][x] != (int)('X') and s[y][x] != (int)('S')) {\n\t      G[2*(w*i+j)].push_back(edge{2*(w*y+x)+1, s[y][x]});\n\t    }\n\t  }\n\n\t  for (int k = 0; k < 9; k++) {\n\t    int x = j + rx[k], y = i + ry[k];\n\t    if (0 <= x and x < w and 0 <= y and y < h and s[y][x] != (int)('X') and s[y][x] != (int)('S')) {\n\t      G[2*(w*i+j)+1].push_back(edge{2*(w*y+x), s[y][x]});\n\t    }\n\t  }\n\t  break;\n\t}\n      }\n    }\n\n    dijkstra(start);\n    int res = INF;\n    for (int i = 0; i < t.size(); i++) {\n      res = min(res, d[t[i]]);\n    }\n    if (res < INF)\n      printf(\"%d\\n\", res);\n    else\n      printf(\"-1\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <queue>\n#include <ctype.h>\n\nusing namespace std;\n\nstruct Node {\n  int s;\n  int x;\n  int y;\n  int cost;\n  Node() {;}\n  Node(int s, int x, int y, int c) : s(s), x(x), y(y), cost(c) {;}\n  bool operator<(const Node &rhs) const { return cost > rhs.cost; }\n};\n\nchar field[100][100];\nbool visit[2][100][100];\nstatic const int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nstatic const int dy[9] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\n\nint main() {\n  int w, h;\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    priority_queue<Node> que;\n    for (int y = 0; y < h; y++) {\n      for (int x = 0; x < w; x++) {\n        char c;\n        scanf(\" %c \", &c);\n        field[y][x] = c;\n        if (c == 'S') {\n          que.push(Node(0, x, y, 0));\n          que.push(Node(1, x, y, 0));\n        }\n      }\n    }\n    memset(visit, false, sizeof(visit));\n    while (!que.empty()) {\n      Node node = que.top();\n      que.pop();\n      if (visit[node.s][node.y][node.x]) { continue; }\n      visit[node.s][node.y][node.x] = true;\n      if (field[node.y][node.x] == 'T') {\n        printf(\"%d\\n\", node.cost);\n        goto next;\n      }\n      for (int i = 0; i < 9; i++) {\n        int ns = 1 - node.s;\n        int nx = node.x + (node.s == 0 ? dx[i] : -dx[i]);\n        int ny = node.y + dy[i];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h || visit[ns][ny][nx] || field[ny][nx] == 'X') { continue; }\n        int ncost = node.cost;\n        if (isdigit(field[ny][nx])) {\n          ncost += field[ny][nx] - '0';\n        }\n        que.push(Node(ns, nx, ny, ncost));\n      }\n    }\n    puts(\"-1\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\n\nconst int INF = 1 << 29;\nconst int MAX_W = 30;\nconst int MAX_H = 60;\nconst int FOOT = 2;\nconst int MAX_D = 9;\n\nenum { L, R };\nstruct foot {\n\tint x, y, cost, type;\n\tfoot ( int ix, int iy, int ic, int it ): x(ix), y(iy), cost(ic), type(it) {}\n\tbool operator > ( const foot &e ) const { return cost > e.cost; }\n};\n\nint dx[MAX_D] = {  1,  1, 1, 1, 1,  2, 2, 2, 3 };\nint dy[MAX_D] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\n\nint solve ( int w, int h )\n{\n\tvector<foot> goal;\n\tVVI fd(h, VI(w));\n\tpriority_queue<foot, vector<foot>, greater<foot> > que;\n\tVVVI d(FOOT, VVI(h, VI(w, INF)));\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'X') {\n\t\t\t\tfd[i][j] = INF;\n\t\t\t\td[L][i][j] = d[R][i][j] = -1;\n\t\t\t}\n\t\t\telse if (c == 'T') {\n\t\t\t\tfd[i][j] = 0;\n\t\t\t\tgoal.push_back(foot(j, i, 0, 0));\n\t\t\t}\n\t\t\telse if (c == 'S') {\n\t\t\t\tfd[i][j] =   0;\n\t\t\t\tque.push(foot(j, i, 0, L));\n\t\t\t\tque.push(foot(j, i, 0, R));\n\t\t\t\td[L][i][j] = d[R][i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfd[i][j] = c - '0';\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tfoot f = que.top(); que.pop();\n\t\tif (d[f.type][f.y][f.x] < f.cost) { continue; }\n\t\tint k = (f.type == R ? -1 : 1);\n\t\tfor (int i = 0; i < MAX_D; ++i) {\n\t\t\tint mx = f.x + k * dx[i];\n\t\t\tint my = f.y +     dy[i];\n\t\t\tif (mx < 0 || w <= mx || my < 0 || h <= my) { continue; }\n\t\t\tint tofoot = (f.type + 1) % FOOT;\n\t\t\tif (d[tofoot][my][mx] > d[f.type][f.y][f.x] + fd[my][mx]) {\n\t\t\t\td[tofoot][my][mx] = d[f.type][f.y][f.x] + fd[my][mx];\n\t\t\t\tque.push(foot(mx, my, d[tofoot][my][mx], tofoot));\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 0, I = goal.size(); i < I; ++i) {\n\t\tfoot f = goal[i];\n\t\tres = min(res, min(d[L][f.y][f.x], d[R][f.y][f.x]));\n\t}\n\tif (res == INF) { res = -1; }\n\treturn res;\n}\n\nint main ( void )\n{\n\tint w, h;\n\twhile (cin >> w >> h, w|h) {\n\t\tcout << solve(w, h) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n#include<cstdint>\n//#include<>\nusing namespace std;\n\ntypedef int64_t i64;typedef int32_t i32;\ntypedef int16_t i16;typedef int8_t i8;\ntypedef uint64_t ui64;typedef uint32_t ui32;\ntypedef uint16_t ui16;typedef uint8_t ui8;\n\n\ntypedef i32 int__;\n#define rep(i,j) for(int__ i=0;i<j;i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);i++)\n#define repeat_eq(i,j,k) for(int__ i=(j);i<=(k);i++)\n#define all(v) begin(v),end(v)\n\ntypedef vector< vector<i32> > Mat;\ntypedef pair<i32,i32> pii;\n\n\nconst i32 INF=1<<30;//=10E10\nconst i32 dx[9]={1,1,1,1,1,2,2,2,3};\nconst i32 dy[9]={2,1,0,-1,-2,1,0,-1,0};\n\n\nint W,H;\nvector< vector<i32> > G;\nvector<int> sx,sy,gx,gy;\n\nstruct state{\n  int y,x;\n  int cost;\n  bool foot;\n  state(int y_,int x_ ,int c,bool f):y(y_),x(x_),cost(c),foot(f){;}\n  bool operator<(const state &r)const{return cost<r.cost;}\n  bool operator>(const state &r)const{return cost>r.cost;}  \n};\n\n\nvector< vector<i32> > dist[2];\n\nvoid dijkstra(){\n  priority_queue< state ,vector<state>,greater<state> > que;\n\n  rep(i,2)dist[i].resize(H,vector<i32>(W,INF));\n\n  rep(i,sx.size()){\n    que.push(state(sy[i],sx[i],0,true));\n    que.push(state(sy[i],sx[i],0,false));\n  }\n\n  while(!que.empty()){\n    state now=que.top();que.pop();\n    if(dist[now.foot][now.y][now.x]<INF)continue;\n    dist[now.foot][now.y][now.x]=now.cost;\n\n    rep(i,9){\n      i32 nx=now.x + dx[i]*(now.foot? 1:-1);\n      i32 ny=now.y+dy[i];\n      if(0<=nx && nx<W && 0<=ny && ny<H){\n\tif(G[ny][nx]<INF)\n\t  que.push(state(ny,nx,now.cost+G[ny][nx],!now.foot));\n      }\n    }   \n  }\n  \n}\n\n\nint main()\n{\n  while(1){\n    G.clear();\n    dist[0].clear();\n    dist[1].clear();\n    sx.clear();\n    sy.clear();\n    gy.clear();\n    gx.clear();\n    \n  cin>>W>>H;\n  if(W==0)break;\n  G.resize(H,vector<int>(W,INF));\n  \n  rep(y,H)rep(x,W){\n    char s;\n    cin>>s;\n    if(s=='S'){\n      sx.push_back(x);\n      sy.push_back(y);\n      G[y][x]=0;\n    }\n    else if(s=='T'){\n      gx.push_back(x);\n      gy.push_back(y);\n      G[y][x]=0;\n    }\n    else if(s=='X')G[y][x]=INF;\n    else G[y][x]=s-'0';\n  }\n  \n  dijkstra();\n\n  int ans=INF;\n  \n  rep(i,gx.size()){\n    ans=min(ans,dist[0][gy[i]][gx[i]]);\n    ans=min(ans,dist[1][gy[i]][gx[i]]);\n  }\n  \n  cout<<(ans>=INF ? -1 : ans)<<endl;\n\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nconst int INF = 1e9;\nchar field[65][65];\nint dp[65][65][65][65];\n\nstruct query {\n    int lh, lw, rh, rw, dist;\n    query(int a, int b, int c, int d, int e) {\n        lh = a;\n        lw = b;\n        rh = c;\n        rw = d;\n        dist = e;\n    }\n};\n\nbool operator> (const query &a, const query &b) {\n    return a.dist > b.dist;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int W, H;\n        cin >> W >> H;\n        if(H == 0) break;\n        int ans = INF;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                cin >> field[h][w];\n            }\n        }\n        for(int i = 0; i <= 60; i++) {\n            for(int j = 0; j <= 60; j++) {\n                for(int k = 0; k <= 60; k++) {\n                    for(int l = 0; l <= 60; l++) dp[i][j][k][l] = INF;\n                }\n            }\n        }\n        priority_queue<query, vector<query>, greater<query>> que;\n        for(int w = 1; w <= W; w++) {\n            if(field[H][w] == 'S') {\n                que.emplace(H, w, H, w, 0);\n            }\n        }\n        while(!que.empty()) {\n            query now = que.top();\n            que.pop();\n            for(int lw = now.rw - 3; lw < now.rw; lw++) {\n                if(lw <= 0) continue;\n                int delta = 3 - (now.rw - lw);\n                for(int lh = now.rh - delta; lh <= now.rh + delta; lh++) {\n                    if(lh <= 0 || lh > H) continue;\n                    if(field[lh][lw] == 'T') {\n                        ans = min(ans, now.dist);\n                        continue;\n                    }\n                    if(field[lh][lw] == 'X' || field[lh][lw] == 'S') continue;\n                    int newdist = now.dist + (int)(field[lh][lw] - '0');\n                    if(dp[lh][lw][now.rh][now.rw] > newdist) {\n                        dp[lh][lw][now.rh][now.rw] = newdist;\n                        que.emplace(lh, lw, now.rh, now.rw, newdist);\n                        //cerr << \"FROM1: \" << now.lh << \" \" << now.lw << \" \" << now.rh << \" \" << now.rw << \" TO: \" << lh << \" \" << lw << \" \" << now.rh << \" \" << now.rw << \" \" << endl;\n                    }\n                }\n            }\n            for(int rw = now.lw + 1; rw <= now.lw + 3; rw++) {\n                if(rw > W) continue;\n                int delta = 3 - (rw - now.lw);\n                for(int rh = now.lh - delta; rh <= now.lh + delta; rh++) {\n                    if(rh <= 0 || rh > H) continue;\n                    if(field[rh][rw] == 'T') {\n                        ans = min(ans, now.dist);\n                        continue;\n                    }\n                    if(field[rh][rw] == 'X' || field[rh][rw] == 'S') continue;\n                    int newdist = now.dist + (int)(field[rh][rw] - '0');\n                    if(dp[now.lh][now.lw][rh][rw] > newdist) {\n                        dp[now.lh][now.lw][rh][rw] = newdist;\n                        que.emplace(now.lh, now.lw, rh, rw, newdist);\n                        //cerr << \"FROM2: \" << now.lh << \" \" << now.lw << \" \" << now.rh << \" \" << now.rw << \" TO: \" << now.lh << \" \" << now.lw << \" \" << rh << \" \" << rw << \" \" << endl;\n                    }\n                }\n            }\n        }\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n};\n\nint main()\n{\n\twhile(1){\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0) return 0;\n\t\tchar s[61][31];\n\t\tvector<edge> v[4000];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t\tif(s[i][j]=='S'){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to=2*(i*w+j+1), e.cost=0;\n\t\t\t\t\tv[0].push_back(e);\n\t\t\t\t\te.to=2*(i*w+j)+1;\n\t\t\t\t\tv[0].push_back(e);\n\t\t\t\t}else if(s[i][j]=='T'){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to=2*h*w+1, e.cost=0;\n\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tfor(int k=1; k<=3; k++){\n\t\t\t\t\tif(j+k>=w) continue;\n\t\t\t\t\tfor(int l=-(3-k); l<=3-k; l++){\n\t\t\t\t\t\tif(i+l<0 || i+l>=h) continue;\n\t\t\t\t\t\tif(s[i+l][j+k]=='X') continue;\n\t\t\t\t\t\tif(s[i+l][j+k]=='S' || s[i+l][j+k]=='T'){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to=2*((i+l)*w+j+k)+1, e.cost=0;\n\t\t\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=s[i+l][j+k]-'0', e.to=2*((i+l)*w+j+k)+1;\n\t\t\t\t\t\t\tv[2*(i*w+j+1)].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1; k<=3; k++){\n\t\t\t\t\tif(j-k<0) continue;\n\t\t\t\t\tfor(int l=-(3-k); l<=3-k; l++){\n\t\t\t\t\t\tif(i+l<0 || i+l>=h) continue;\n\t\t\t\t\t\tif(s[i+l][j-k]=='X') continue;\n\t\t\t\t\t\tif(s[i+l][j-k]=='S' || s[i+l][j-k]=='T'){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to=2*((i+l)*w+j-k+1), e.cost=0;\n\t\t\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.cost=s[i+l][j-k]-'0', e.to=2*((i+l)*w+j-k+1);\n\t\t\t\t\t\t\tv[2*(i*w+j)+1].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tint d[4000];\n\t\tfill(d, d+2*h*w+2, INF);\n\t\td[0]=0;\n\t\tque.push(P(0, 0));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint x=p.second;\n\t\t\tif(p.first>d[x]) continue;\n\t\t\tfor(auto e:v[x]){\n\t\t\t\tif(d[e.to]>d[x]+e.cost){\n\t\t\t\t\td[e.to]=d[x]+e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[2*h*w+1]==INF){\n\t\t\tcout<<-1<<endl;\n\t\t}else{\n\t\t\tcout<<d[2*h*w+1]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nclass State {\npublic:\n\tint cost;\n\tint x, y;\n\tint next;//0??§?¬?????¶??§????,1??§?¬?????¶??§????\n\n\tState(int c, int _x, int _y, int n) :cost(c), x(_x), y(_y), next(n){}\n\n\t/*\n\tbool operator < (const State& obj) const\n\t{\n\t\treturn cost < obj.cost;\n\t}\n\t*/\n\n\tbool operator > (const State& obj) const\n\t{\n\t\treturn cost > obj.cost;\n\t}\n};\n\nconst int INF = 1 << 29;\nconst int MAXW = 30;\nconst int MAXH = 60;\nconst int dx[9] = { 1,1,1,1,1,2,2,2,3 };//leftx+dx or rightx-dx\nconst int dy[9] = { -2,-1,0,1,2,-1,0,1,0 };//lefty+dy or righty+dy\n\nint w, h;\n\nbool isranged(int x, int y)\n{\n\treturn (x >= 0 && x < w&&y >= 0 && y < h);\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> w >> h;\n\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchar grid[MAXH][MAXW];\n\t\tint dp[MAXH][MAXW][2];\n\t\tpriority_queue<State, vector<State>, greater<State>> pq;\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\n\t\trep(i, w) {\n\t\t\tif (grid[h - 1][i] == 'S') {\n\t\t\t\tpq.push(State(0, i, h - 1, 0));\n\t\t\t\tpq.push(State(0, i, h - 1, 1));\n\t\t\t\tdp[h - 1][i][0] = 0;\n\t\t\t\tdp[h - 1][i][1];\n\t\t\t}\n\t\t}\n\n\t\twhile (pq.empty() == false) {\n\t\t\tState temp = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (temp.cost > dp[temp.y][temp.x][temp.next]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (grid[temp.y][temp.x] == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (temp.next == 0) {\n\t\t\t\trep(i, 9) {\n\t\t\t\t\tint nx = temp.x + dx[i];\n\t\t\t\t\tint ny = temp.y + dy[i];\n\n\t\t\t\t\tchar tmp = grid[ny][nx];\n\t\t\t\t\tif (tmp == 'X') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nc = 0;\n\t\t\t\t\tif (tmp != 'S' && tmp != 'T') {\n\t\t\t\t\t\tnc = tmp - '0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isranged(nx, ny) == true) {\n\t\t\t\t\t\tif (dp[ny][nx][1] > temp.cost + nc) {\n\t\t\t\t\t\t\tdp[ny][nx][1] = temp.cost + nc;\n\t\t\t\t\t\t\tpq.push(State(dp[ny][nx][1], nx, ny, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, 9) {\n\t\t\t\t\tint nx = temp.x - dx[i];\n\t\t\t\t\tint ny = temp.y + dy[i];\n\n\t\t\t\t\tchar tmp = grid[ny][nx];\n\t\t\t\t\tif (tmp == 'X') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nc = 0;\n\t\t\t\t\tif (tmp != 'S' && tmp != 'T') {\n\t\t\t\t\t\tnc = tmp - '0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isranged(nx, ny) == true) {\n\t\t\t\t\t\tif (dp[ny][nx][0] > temp.cost + nc) {\n\t\t\t\t\t\t\tdp[ny][nx][0] = temp.cost + nc;\n\t\t\t\t\t\t\tpq.push(State(dp[ny][nx][0], nx, ny, 0));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\trep(i, w) {\n\t\t\tif (grid[0][i] == 'T') {\n\t\t\t\trep(j, 2) {\n\t\t\t\t\tans = min(ans, dp[0][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nint w, h;\nchar field[60][60];\nbool visited[2][60][60];\n\nclass node {\npublic:\n\tint s, f, x, y;\n\tnode(int _s, int _f, int _x, int _y) : s(_s), f(_f), x(_x), y(_y) {}\n};\n\nbool operator<(const node& l, const node& r) {\n\treturn l.s>r.s;\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w==0) return 0;\n\t\trep(y, h) rep(x, w) scanf(\" %c\", field[x]+y);\n\t\trep(i, 2) rep(x, w) rep(y, h) visited[i][x][y] = false;\n\t\tpriority_queue<node> q;\n\t\trep(x, w) rep(y, h) if(field[x][y]=='S') {\n\t\t\tq.push(node(0, 0, x, y));\n\t\t\tq.push(node(0, 1, x, y));\n\t\t}\n\t\tint ms = -1;\n\t\twhile(!q.empty()) {\n\t\t\tnode v = q.top();\n\t\t\tq.pop();\n\t\t\tif(visited[v.f][v.x][v.y]) continue;\n\t\t\tvisited[v.f][v.x][v.y] = true;\n\t\t\trep(d, 9) {\n\t\t\t\tint x=v.x+(v.f?dx[d]:-dx[d]), y=v.y+dy[d];\n\t\t\t\tif(0<=x && x<w && 0<=y && y<h) {\n\t\t\t\t\tif(field[x][y]=='T') {\n\t\t\t\t\t\tms = v.s;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[x][y]=='S') {\n\t\t\t\t\t\tq.push(node(v.s, (v.f+1)%2, x, y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[x][y]!='X') {\n\t\t\t\t\t\tq.push(node(v.s+field[x][y]-'0', (v.f+1)%2, x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tend:\n\t\tprintf(\"%d\\n\", ms);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 61\n#define MAX_W 31\n#define INF 1e9\n#define Fi first\n#define Se second\ntypedef pair<int,int> pii;\n \nstruct State{\n    int d,lx,ly,rx,ry;\n    bool f;\n    State(){}\n    State(int d,int lx,int ly,int rx,int ry,bool f) :\n\td(d),lx(lx),ly(ly),rx(rx),ry(ry),f(f) {}\n    bool operator > (const State &s)const{\n\treturn d > s.d;\n    }\n};\n \nint W,H;\nint ps,pt;\npii S[MAX_W],T[MAX_W];\nchar field[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W][MAX_H][MAX_W][2];\n \nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n \nbool inField(int x,int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n \nint dijkstra(){\n    priority_queue<State,vector<State>,greater<State> > Q;\n    fill(dist[0][0][0][0],dist[0][0][0][0]+MAX_H*MAX_W*MAX_H*MAX_W*2,INF);\n    for(int i = 0 ; i < ps ; i++){\n\tQ.push(State(0,S[i].Fi,S[i].Se,W,H,0)); \n\tQ.push(State(0,W,H,S[i].Fi,S[i].Se,1));\n\tdist[S[i].Se][S[i].Fi][H][W][0] = 0;\n\tdist[H][W][S[i].Se][S[i].Fi][1] = 0;\n    }\n \n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint lx = s.lx, ly = s.ly;\n\tint rx = s.rx, ry = s.ry;\n \n\tif(dist[ly][lx][ry][rx][s.f] < s.d) continue;\n\tfor(int i = 0 ; i < pt ; i++){\n\t    if(lx == T[i].Fi && ly == T[i].Se ||\n\t       rx == T[i].Fi && ry == T[i].Se){\n\t\treturn s.d;\n\t    }\n\t}\n\tif(s.f){\n\t    for(int i = 0 ; i < 9 ; i++){\n\t\tint nlx = rx - dx[i];\n\t\tint nly = ry + dy[i];\n\t\tif(!inField(nlx,nly)) continue;\n\t\tif(field[nly][nlx] == 'X') continue;\n\t\tint t = field[nly][nlx] - '0';\n\t\tif(s.d + t < dist[nly][nlx][ry][rx][0]){\n\t\t    dist[nly][nlx][ry][rx][0] = s.d + t;\n\t\t    Q.push(State(dist[nly][nlx][ry][rx][0],nlx,nly,rx,ry,0));\n\t\t}\n\t    }\n\t}else{\n\t    for(int i = 0 ; i < 9 ; i++){\n\t\tint nrx = lx + dx[i];\n\t\tint nry = ly + dy[i];\n\t\tif(!inField(nrx,nry)) continue;\n\t\tif(field[nry][nrx] == 'X') continue;\n\t\tint t = field[nry][nrx] - '0';\n\t\tif(s.d + t < dist[ly][lx][nry][nrx][1]){\n\t\t    dist[ly][lx][nry][nrx][1] = s.d + t;\n\t\t    Q.push(State(dist[ly][lx][nry][nrx][1],lx,ly,nrx,nry,1));\n\t\t}\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    dijkstra();\n    while(cin >> W >> H, W){\n\tps = pt = 0;\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t\tif(field[i][j] == 'S'){\n\t\t    S[ps++] = pii(j,i);\n\t\t    field[i][j] = '0';\n\t\t}else if(field[i][j] == 'T'){\n\t\t    T[pt++] = pii(j,i);\n\t\t    field[i][j] = '0';      \n\t\t}\n\t    }\n\t}\n\tcout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#define INF 100000000\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct state { int y, x, f, d; };\nclass Compare {\npublic:\n  bool operator()(struct state a, struct state b) {\n    return a.d > b.d;\n  }\n};\n\nint H, W;\nchar S[60][30];\nint dp[60][30][3];\n\nint isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, H && W) {\n    priority_queue<struct state, vector<struct state>, Compare> q;\n\n    REP(i, 0, H) REP(j, 0, W) REP(k, 0, 3) dp[i][j][k] = INF;\n\n    REP(i, 0, H) {\n      REP(j, 0, W) {\n        cin >> S[i][j];\n        if(S[i][j] == 'S') {\n          struct state l = { i, j, -1, 0 };\n          struct state r = { i, j, 1, 0 };\n          q.push(l);\n          q.push(r);\n        }\n      }\n    }\n\n    long ans = -1;\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.y << \", \" << c.x << \", \" << c.f << \", \" << c.d << endl;\n\n      if(dp[c.y][c.x][c.f + 1] <= c.d) continue;\n      dp[c.y][c.x][c.f + 1] = c.d;\n      if(S[c.y][c.x] == 'T') {\n        ans = dp[c.y][c.x][c.f + 1];\n        break;\n      }\n\n      REP(i, -2, 3) REP(j, 1, 4) {\n        int ny = c.y + i, nx = c.x - j * c.f;\n        if(abs(c.y - ny) + abs(c.x - nx) > 3) continue;\n        if(S[ny][nx] == 'X') continue;\n        if(!isin(ny, nx)) continue;\n        int nd = c.d + ('0' <= S[ny][nx] && S[ny][nx] <= '9' ? S[ny][nx] - '0' : 0);\n        int nf = -c.f;\n        if(dp[ny][nx][nf + 1] <= nd) continue;\n        struct state n = { ny, nx, nf, nd };\n        q.push(n);\n        // cout << \"  \" << n.y << \", \" << n.x << \", \" << n.f << \", \" << n.d << endl;\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,rx,ry,s,cost;\n\tbool operator<(const data &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint w,h;\nint dp[35][65][5][7][4];\nint fie[100][100];\nint flag[100][100];\nint sx[50],scnt;\n\nint dijk(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tdata inp;\n\tint res=-1;\n\tinp.y=h;\n\tinp.rx=1;\n\tinp.ry=3;\n\tinp.cost=0;\n\tfor(int i=0;i<scnt;i++){\n\t\tinp.x=sx[i];\n\t\tinp.s=2;\n\t\tque.push(inp);\n\t\tinp.x=sx[i]-1;\n\t\tinp.s=3;\n\t\tque.push(inp);\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.x][q.y][q.rx][q.ry][q.s]!=-1 && dp[q.x][q.y][q.rx][q.ry][q.s]<q.cost)continue;\n\t\tdp[q.x][q.y][q.rx][q.ry][q.s]=q.cost;\n\t\tif(flag[q.x][q.y]==1 || flag[q.x+q.rx][q.y+q.ry-3]==1){\n\t\t\tres=min(res,q.cost);\n\t\t\tif(res==-1)res=q.cost;\n\t\t}\n\t\tif(q.s%2==0){\n\t\t\tfor(int i=1;i<=3;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x][q.y][i][j+3][1]==-1 || dp[q.x][q.y][i][j+3][1]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x][q.y][i][j+3][1]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq=q;\n\t\t\t\t\t\t\t\tnq.rx=i;\n\t\t\t\t\t\t\t\tnq.ry=j+3;\n\t\t\t\t\t\t\t\tnq.s=1;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.s%2==1){\n\t\t\tq.x=q.x+q.rx;\n\t\t\tq.y=q.y+q.ry-3;\n\t\t\tfor(int i=-3;i<=-1;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(-i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x+i][q.y+j][-i][-j+3][0]==-1 || dp[q.x+i][q.y+j][-i][-j+3][0]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x+i][q.y+j][-i][-j+3][0]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq;\n\t\t\t\t\t\t\t\tnq.x=q.x+i;\n\t\t\t\t\t\t\t\tnq.y=q.y+j;\n\t\t\t\t\t\t\t\tnq.rx=-i;\n\t\t\t\t\t\t\t\tnq.ry=-j+3;\n\t\t\t\t\t\t\t\tnq.s=0;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(flag,0,sizeof(flag));\n\t\tscnt=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='S')fie[j][i]=0,sx[scnt]=j,scnt++;\n\t\t\t\tif(c=='T')fie[j][i]=0,flag[j][i]=1;\n\t\t\t\tif(c=='X')fie[j][i]=-1;\n\t\t\t\tif(c>='1' && c<='9')fie[j][i]=c-'0';\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint s_l, s_r, t_l, t_r;\nint d[30][60][2];\n//dijkstra\nint dijkstra(vector<vector<int>>&cost,State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tif ((s.foot == -1 && s.x == 0) || (s.foot && s.x == cost.size() - 1))continue;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = t_l; i <= t_r; i++) {\n\t\tint d_min = min(d[i][0][0], d[i][0][1]);\n\t\tres = min(res, d_min);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\t//input\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (s_flag == 0) {\n\t\t\t\t\t\ts_l = j; s_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\ts_r = j;\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (t_flag == 0) {\n\t\t\t\t\t\tt_l = j; t_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\tt_r = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = min(dijkstra(cliff, State(0, s_l, h - 1, 1)), dijkstra(cliff, State(0, s_l, h - 1, -1)));\n\t\tint ans1 = min(dijkstra(cliff, State(0, s_r, h - 1, 1)), dijkstra(cliff, State(0, s_r, h - 1, -1)));\n\t\tans = min(ans, ans1);\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* \nauthor: Hayato Kawakita\ndate: 2020/06/29 19:20\nvertict: AC\nURL:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=ja\n所要時間:20分\nやるだけ。スタートからdijkstra法のように調べるだけ。右足、左足の状態を分けていることに注意。\n*/\n\n#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef array<int, 4> V;\n\n//inputs\nint w, h;\nchar s[65][35];\n//distance from start {y, x, is_right_foot}\nint d[65][35][2];\n\nvoid init() {\n  rep(i, 65) rep(j, 35) rep(k, 2) d[i][j][k] = inf;\n}\n\nvoid solve() {\n  priority_queue<V, vector<V>, greater<V>> pq;\n  //start\n  rep(i, h) {\n    rep(j, w) {\n      if (s[i][j] == 'S') {\n        rep(k, 2) {\n          d[i][j][k] = 0;\n          pq.push({0, i, j, k});\n        }\n      }\n    }\n  }\n  while (pq.size()) {\n    V res = pq.top();\n    pq.pop();\n    int y = res[1], x = res[2], t = res[3];\n    //visited\n    if (res[0] > d[y][x][t]) continue;\n    //次の状態を全て調べるだけ\n    FOR(i, 1, 4) {\n      int nx = (t == 0 ? x + i : x - i);\n      if (nx < 0 || nx >= w) break;\n      FOR(j, -3 + i, 4 - i) {\n        int ny = y + j;\n        if (ny < 0 || ny >= h) continue;\n        if (s[ny][nx] == 'X' || s[ny][nx] == 'S') continue;\n        if (s[ny][nx] == 'T') {\n          cout << d[y][x][t] << '\\n';\n          return;\n        }\n        if (chmin(d[ny][nx][t ^ 1], d[y][x][t] + s[ny][nx] - '0')) {\n          pq.push({d[ny][nx][t ^ 1], ny, nx, t ^ 1});\n        }\n      }\n    }\n  }\n  //impossible\n  cout << -1 << '\\n';\n  return;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> w >> h, w) {\n    init();\n    rep(i, h) rep(j, w) cin >> s[i][j];\n\n    solve();\n  }\n\n\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\n\nint main() {\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(!w)break;\n    int n = w*h;\n    Graph g(n*2);\n    vector<vector<string>> t(h,vector<string>(w));\n    REP(i,h){\n      REP(j,w){\n        cin>>t[i][j];\n      }\n    }\n    set<int> s_set,t_set;\n    REP(i,h){\n      REP(j,w){\n        if (t[i][j] == \"S\") {\n          s_set.insert(i*w+j);\n          s_set.insert(n+i*w+j);\n        } else if (t[i][j] == \"T\") {\n          t_set.insert(i*w+j);\n          t_set.insert(n+i*w+j);\n        }\n        int p = i*w+j;\n        for(int k=-2;k<=2;++k)REP(l,3){\n          if(abs(k)+l>=3) continue;\n          int nir = i+k;\n          int njr = j+1+l;\n          int nil = i+k;\n          int njl = j-1-l;\n          if (nir >= 0 && nir < h && njr >= 0 && njr < w) {\n            if (t[nir][njr] == \"S\" || t[nir][njr] == \"T\")\n              g[p].push_back({p, n+nir*w+njr, 0});\n            else if (t[nir][njr] != \"X\")\n              g[p].push_back({p, n+nir*w+njr, t[nir][njr][0] - '0'});\n          }\n          if (nil >= 0 && nil < h && njl >= 0 && njl < w) {\n            if (t[nil][njl] == \"S\" || t[nil][njl] == \"T\")\n              g[n+p].push_back({n+p, nil*w+njl, 0});\n            else if (t[nil][njl] != \"X\")\n              g[n+p].push_back({n+p, nil*w+njl, t[nil][njl][0] - '0'});\n          }\n        }\n      }\n    }\n    int mind = INF;\n    for (int i:s_set) {\n      Array a(n*2, INF);\n      dijkstra(g, a, i);\n      for (int j:t_set)\n        mind = min(mind, a[j]);\n    }\n    if (mind < INF)\n      cout << mind << endl;\n    else\n      cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MAX = 1LL << 50;\n\nll h, w;\nll a[30][50];\nchar b[30][50];\nll minr[30][50];//????????°???????°????\nll minl[30][50];//????????°???????°????\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\nqueue<P> quer;\nqueue<P> quel;\n\nvoid doRight() {\n\twhile (!quel.empty()) {\n\t\tP p = quel.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquel.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x + dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minr[yy][xx] > minl[y][x] +a[yy][xx]) {\n\t\t\t\tminr[yy][xx] = minl[y][x] + a[yy][xx];\n\t\t\t\tquer.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid doLeft() {\n\twhile (!quer.empty()) {\n\t\tP p = quer.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquer.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x - dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minl[yy][xx] > minr[y][x] +a[yy][xx]) {\n\t\t\t\tminl[yy][xx] = minr[y][x] + a[yy][xx];\n\t\t\t\tquel.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\n\n// 0 : left, 1 : right\nint dx[2][9] = {\n    {1,1,1,1,1,2,2,2,3}, \n    {-1,-1,-1,-1,-1,-2,-2,-2,-3}\n};\nint dy[2][9] = {\n    {2,1,0,-1,-2,1,0,-1,0},\n    {2,1,0,-1,-2,1,0,-1,0}\n};\n\nchar mp[100][100];\nint cost[2][100][100];\nvoid init(){\n    for(int y = 0; y < 100; y++){\n        for(int x = 0; x < 100; x++){\n            mp[y][x] = 'X';\n            cost[0][y][x] = 11451419;\n            cost[1][y][x] = 11451419;\n        }\n    }\n}\n\nint main(){\n\n    for(int w, h; cin >> w >> h, w; ){\n        init();\n        priority_queue<PP, vector<PP>, greater<PP> >Q;\n        for(int y = 1 + 10; y <= h + 10; y++){\n            for(int x = 1 + 10; x <= w + 10; x++){\n                cin >> mp[y][x];\n                if(mp[y][x] == 'S'){\n                    Q.push(PP(P(0, 0), P(x, y)));\n                    Q.push(PP(P(0, 1), P(x, y)));\n                }\n            }\n        }\n        int ans = 11451419;\n        while(!Q.empty()){\n            int cst = Q.top().first.first;\n            int lr = Q.top().first.second;\n            int x = Q.top().second.first;\n            int y = Q.top().second.second;\n            Q.pop();\n            if(cost[lr][y][x] < 11451419)continue;\n            cost[lr][y][x] = cst;\n            if(mp[y][x] == 'T'){\n                ans = cst;\n                break;\n            }\n            for(int i = 0; i < 9; i++){\n                int nx = x + dx[lr][i];\n                int ny = y + dy[lr][i];\n                if(mp[ny][nx] == 'X')continue;\n                if(cost[lr ^ 1][ny][nx] < 11451419)continue;\n                int ncst = cst;\n                if('0' <= mp[ny][nx] && mp[ny][nx] <= '9'){\n                    ncst += mp[ny][nx] - '0';\n                }\n                Q.push(PP(P(ncst, lr ^ 1), P(nx, ny)));\n            }\n        }\n        if(ans == 11451419)cout << -1 << endl;\n        else cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint dy[2][9] = {{-2,-1,-1,0,0,0,1,1,2},{-2,-1,-1,0,0,0,1,1,2}};\nint dx[2][9] = {{1,1,2,1,2,3,1,2,1},{-1,-2,-1,-3,-2,-1,-2,-1,-1}};\nint w,h;\nchar s[61][31];\nint dis[61][31][2];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> w >> h, w) {\n    MINF(dis);\n    using P = tuple<int,int,int,int>;\n    priority_queue<P,vector<P>,greater<P>> que;\n    vector<pii> gs;\n    REP(i,h) REP(j,w) {\n      cin >> s[i][j];\n      if (s[i][j] == 'S') {\n        que.emplace(0,i,j,0);\n        que.emplace(0,i,j,1);\n        dis[i][j][0] = dis[i][j][1] = 0;\n      } else if (s[i][j] == 'T') {\n        s[i][j] = '0';\n        gs.emplace_back(i,j);\n      }\n    }\n    while (!que.empty()) {\n      int dd,y,x,t;\n      tie(dd,y,x,t) = que.top(); que.pop();\n      if (dis[y][x][t] < dd) continue;\n      for (int i = 0; i < 9; i++) {\n        int ny = y+dy[t][i];\n        int nx = x+dx[t][i];\n        if (IN(ny,0,h-1) && IN(nx,0,w-1) && s[ny][nx] != 'X') {\n          int cost = (s[ny][nx]-'0');\n          if (CHMIN(dis[ny][nx][t^1],dis[y][x][t]+cost)) {\n            que.emplace(dis[ny][nx][t^1],ny,nx,t^1);\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (pii g : gs) REP(i,2) CHMIN(ans,dis[g.first][g.second][i]);\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int h,w,leg,cost;\n  State(int a,int b,int c,int d):h(a),w(b),leg(c),cost(d){}\n  bool operator<(State s)const{\n    return s.cost<cost;\n  }\n};\n\nint w,h;\nchar s[100][100];\nint dp[100][100][2]={};\n//            a                    b\nint x[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint y[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\n\nbool in(int a,int b){\n  if(a<0 || b<0 || h<=a || w<=b)return false;\n  return true;\n}\n\nint main()\n{\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    priority_queue<State> pq;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>s[i][j];\n\tdp[i][j][0]=inf;\n\tdp[i][j][1]=inf;\n\tif(s[i][j]=='S'){\n\t  pq.push(State(i,j,0,0));\n\t  pq.push(State(i,j,1,0));\n\t  dp[i][j][0]=0;\n\t  dp[i][j][1]=0;\n\t}\n\tif(s[i][j]=='T')s[i][j]='0';\n      }\n    }\n\n    int ans=inf;\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.h][u.w][u.leg]<u.cost)continue;\n\n      if(s[u.h][u.w]=='0'){\n\tans=min(ans,u.cost);\n\tcontinue;\n      }\n\n      for(int k=0;k<9;k++){\n\tint a=u.h+y[u.leg][k],b=u.w+x[u.leg][k],c=(u.leg+1)%2;\n\tif(!in(a,b))continue;\n\tif(s[a][b]=='X' || s[a][b]=='S')continue;\n\tif((u.cost+(s[a][b]-'0'))<dp[a][b][c]){\n\t  dp[a][b][c]=u.cost+(s[a][b]-'0');\n\t  pq.push(State(a,b,c,dp[a][b][c]));\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <functional>\n#define INF 100000000\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nclass Node{\npublic:\n  Node(int x, int y, int f):x(x),y(y),f(f){}\n  int x,y,f;\n  int tonum(){return (x<<7)+(y<<1)+f;}\n};\n\nNode tonode(int num){\n  return Node(num>>7,num>>1&63,num&1);\n};\n\nint hoge[2][9][2] = {{{1,2},{1,1},{1,0},{1,-1},{1,-2},{2,1},{2,0},{2,-1},{3,0}},\n\t\t     {{-1,2},{-1,1},{-1,0},{-1,-1},{-1,-2},{-2,1},{-2,0},{-2,-1},{-3,0}}};\n\nint w,h;\nint map[100][100];\nint d[100000];\nbool visit[100000];\n\nvoid dijkstra(Node from) {\n  int m = from.tonum();\n  priority_queue<P,vector<P>,greater<P> > que;\n  fill(d,d+100000,INF); fill(visit,visit+100000,false);\n  d[m] = 0;\n  que.push(P(0,m));\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int cand = p.second;\n    if (visit[cand])\n      continue;\n    visit[cand] = true;\n    \n    for (int i=0; i<9; i++) {\n      Node n = tonode(cand);\n      int dx = hoge[n.f][i][0], dy = hoge[n.f][i][1];\n      int x = n.x+dx, y= n.y+dy, f = (n.f+1)&1;\n      if (x >= 0 && x < w && y >= 0 && y < h && map[x][y] != INF) {\n\tint next = Node(x,y,f).tonum();\n\tif (d[next] > d[cand] + map[x][y]) {\n\t  d[next] = d[cand] + map[x][y];\n\t  que.push(P(d[next],next));\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  while(scanf(\"%d %d\",&w,&h),w) {\n    vector<Node> start,goal;\n\n    for (int y=0; y<h; y++) {\n      for (int x=0; x<w; x++) {\n\tchar c;\n\twhile(isspace(c=getchar())) ;\n\tswitch (c) {\n\tcase 'X':\n\t  map[x][y]=INF;\n\t  break;\n\tcase 'S':\n\t  map[x][y] = 0;\n\t  start.push_back(Node(x,y,0));\n\t  start.push_back(Node(x,y,1));\n\t  break;\n\tcase 'T':\n\t  map[x][y] = 0;\n\t  goal.push_back(Node(x,y,0));\n\t  goal.push_back(Node(x,y,1));\n\t  break;\n\tdefault:\n\t  map[x][y] = c-'0';\n\t}\n      }\n    }\n\n    int ans = INF;\n    for (int s=0; s<start.size(); s++){\n      dijkstra(start[s]);\n      for (int g=0; g<goal.size(); g++) {\n\tans = min(ans,d[goal[g].tonum()]);\n      }\n    }\n  \n    printf (\"%d\\n\",(ans==INF)?-1:ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nchar fi[128][128];\nbool ch[2][128][128];\nint cost[2][128][128];\n// lr,x+10,y+10;\nint main(void)\n{\n  for(;;){\n    REP(j,128) REP(i,128) fi[i][j]='X';\n    REP(k,2) REP(j,128) REP(i,128) cost[k][i][j]=1048576;\n    REP(k,2) REP(j,128) REP(i,128) ch[k][i][j]=false;\n    int w,h;\n    cin >> w >> h;\n    if(!w) return 0;\n    REP(I,h) REP(J,w){\n      int i=I+10,j=J+10;\n      string tmp;\n      cin >> tmp;\n      fi[i][j]=tmp[0];\n    }\n    REP(I,h) REP(J,w){\n      int i=I+10,j=J+10;\n      if(fi[i][j]=='S') REP(k,2){\n\t  cost[k][i][j]=0;\n\t  ch[k][i][j]=true;\n\t}\n    }\n    bool flag=true;\n    while(flag){\n      flag=false;\n      REP(k,2) REP(I,h) REP(J,w){\n\tint i=I+10,j=J+10;\n\tif(!ch[k][i][j]) continue;\n\tch[k][i][j]=false;\n\tFOR(ve,-2,3){\n\t  FOR(ho,1,4-abs(ve)){\n\t    int nk=1-k,ni=i+ve,nj=j+ho*(1-2*k);\n\t    int nextcost=cost[k][i][j];\n\t    if(fi[ni][nj]=='X') continue;\n\t    else if(fi[ni][nj]=='S') continue;\n\t    else if(fi[ni][nj]!='T') nextcost+=fi[ni][nj]-'0';\n\t    if(nextcost < cost[nk][ni][nj]){\n\t      //cout << nk << ' ' << ni << ' ' << nj << ' ' << nextcost << endl;\n\t      cost[nk][ni][nj]=nextcost;\n\t      ch[nk][ni][nj]=true;\n\t      flag=true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int answer=1048576;\n    REP(k,2) REP(I,h) REP(J,w){\n      int i=I+10,j=J+10;\n      if(fi[i][j]=='T') answer=min(answer,cost[k][i][j]);\n    }\n    if(answer<1048576) cout << answer << endl;\n    else cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_W = 31;\nconst int MAX_H = 61;\nconst int INF = 1e9 + 7;\n\n//start: 0, goal: 0, X: -1\n\nint my[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\nint mx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\nclass C{\n  public:\n    int y, x, foot, cost;\n    C(int _y, int _x, int _f, int _c){ y = _y, x = _x; foot = _f, cost = _c; }\n    C(){}\n    bool operator > (const C &c) const { return cost > c.cost; }\n};\n\nint W, H, v[MAX_H][MAX_W];\n\nint dij(){\n  priority_queue<C, vector<C>, greater<C> > open;\n  REP(x, W){\n    if(v[H - 1][x] == 0){\n      open.push( C(H - 1, x, 0, 0) );\n      open.push( C(H - 1, x, 1, 0) );\n    }\n  }\n  int closed[MAX_H][MAX_W][2];\n  REP(y, H) REP(x, W) REP(i, 2) closed[y][x][i] = INF;\n  while(!open.empty()){\n    C tmp = open.top(); open.pop();\n    int y = tmp.y, x = tmp.x, foot = tmp.foot, cost = tmp.cost;\n    //cout <<y <<\", \" <<x <<\", \" <<foot <<\", \" <<cost <<endl;\n    if(closed[y][x][foot] <= cost) continue;\n    closed[y][x][foot] = cost;\n    REP(i, 9){\n      int ny = y + my[i], nx = (foot == 0 ? x + (mx[i] * -1) : x + mx[i]);\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] >= 0){\n        //cout <<\"    \" <<ny <<\", \" <<nx <<\", \" <<(foot + 1) % 2 <<endl;\n        open.push( C(ny, nx, (foot + 1) % 2, cost + v[ny][nx]) );\n      }\n    }\n  }\n  int ans = INF;\n  REP(x, W) REP(i, 2) if(v[0][x] == 0) ans = min(ans, closed[0][x][i]);\n  return (ans == INF ? -1 : ans);\n}\n\nint main() {\n  while(cin >>W >>H && W){\n    REP(y, H){\n      REP(x, W){\n        char c; cin >>c;\n        if(c == 'S') v[y][x] = 0;\n        else if(c == 'T') v[y][x] = 0;\n        else if(c == 'X') v[y][x] = -1;\n        else v[y][x] = c - '0';\n      }\n    }\n    //debug\n    //REP(y, H){\n    //  REP(x, W) cout <<v[y][x] <<\" \";\n    //  cout <<endl;\n    //}\n    //cout <<\"--------\" <<endl;\n    cout <<dij() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\n//typedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint x;\n\tint y;\n\tint cost;\n};\n\nclass Sit{\npublic:\n\tint x;\n\tint y;\n\tint foot;\n\n\tSit();\n\n\tSit(int _x,int _y,int _foot){\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n\n\tbool operator<(const Sit &a) const{\n\t\treturn a.foot < this->foot;\n\t}\n};\n\ntypedef pair<int,Sit> P;\nint V;\n\nconst int MAX_X = 30;\nconst int MAX_Y = 60;\n\n// x,yÀWAÇÌ«ð©¯é©\nvector<edge> G[MAX_Y][MAX_X][2];\n\n// RXg\nint d[MAX_Y][MAX_X][2];\nconst int INF = 100000000;\n\nvoid dijkstra(int sx,int sy,int sfoot){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i = 0; i < MAX_Y; i++)\n\t\tfor(int j = 0; j < MAX_X; j++)\n\t\t\tfill(d[i][j],d[i][j]+2,INF);\n\n\td[sy][sx][sfoot] = 0;\n\tque.push(P(0,Sit(sx,sy,sfoot)));\n\twhile(!que.empty()){\n\t\t//if(sy == 9 && que.top().second.y == 4){\n\t\t//\tcout << endl;\n\t\t//}\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tSit v = p.second;\n\t\tif(d[v.y][v.x][v.foot] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v.y][v.x][v.foot].size(); i++){\n\t\t\tedge e = G[v.y][v.x][v.foot][i];\n\t\t\tint nextStep = v.foot ? 0 : 1;\n\t\t\tif(d[e.y][e.x][nextStep] > d[v.y][v.x][v.foot] + e.cost){\n\t\t\t\td[e.y][e.x][nextStep] = d[v.y][v.x][v.foot] + e.cost;\n\t\t\t\tque.push(P(d[e.y][e.x][nextStep],Sit(e.x,e.y,nextStep)));\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\n\tint w,h;\n\tchar field[60][30];\n\tvector<pair<int,int> > startPoints;\n\tvector<pair<int,int> > terminates;\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tstartPoints.clear();\n\t\tterminates.clear();\n\t\tfor(int i = 0; i < MAX_Y; i++)\n\t\t\tfor(int j = 0; j < MAX_X; j++)\n\t\t\t\tfor(int k = 0; k <= 1; k++)\n\t\t\t\t\tG[i][j][k].clear();\n\n\t\t// make filed\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == 'S'){\n\t\t\t\t\tstartPoints.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'T'){\n\t\t\t\t\tterminates.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// GbWðÔ\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(field[i][j] == 'X' || field[i][j] == 'T')\n\t\t\t\t\tcontinue;\n\t\t\t\t// »m[hÅÂ¢Ä¢é«Ìûü(0ð¶,1ðE«Æ·é)\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t// yoko\n\t\t\t\t\t\tfor(int l = 1; l <= 3; l++){\n\t\t\t\t\t\t\t// tate\n\t\t\t\t\t\t\tfor(int m = -3+l; m <= -l+3; m++){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.y = i + m;\n\t\t\t\t\t\t\t\te.x = j + l;\n\t\t\t\t\t\t\t\tif(!(e.x < 0 || e.x >= w || e.y < 0 || e.y >= h || field[e.y][e.x] == 'X' || field[e.y][e.x] == 'S')){\n\t\t\t\t\t\t\t\t\tif(field[e.y][e.x] == 'T')\n\t\t\t\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\te.cost = field[e.y][e.x] - '0';\n\t\t\t\t\t\t\t\t\tG[i][j][k].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int l = -1; l >= -3; l--){\n\t\t\t\t\t\t\t// tate\n\t\t\t\t\t\t\tfor(int m = -l-3; m <= l+3; m++){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.y = i + m;\n\t\t\t\t\t\t\t\te.x = j + l;\n\t\t\t\t\t\t\t\tif(!(e.x < 0 || e.x >= w || e.y < 0 || e.y >= h || field[e.y][e.x] == 'X' || field[e.y][e.x] == 'S')){\n\t\t\t\t\t\t\t\t\tif(field[e.y][e.x] == 'T')\n\t\t\t\t\t\t\t\t\t\te.cost = 0;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\te.cost = field[e.y][e.x] - '0';\n\t\t\t\t\t\t\t\t\tG[i][j][k].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// en_©çD«È«ÅX^[g\n\t\tint minCost = INF;\n\t\tfor(int i = 0; i < startPoints.size(); i++){\n\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\tpair<int,int> pr = startPoints[i];\n\t\t\t\tdijkstra(pr.second,pr.first,k);\n\t\t\t\t// min cost\n\t\t\t\tfor(int l = 0; l < terminates.size(); l++){\n\t\t\t\t\tfor(int m = 0; m < 2; m++){\n\t\t\t\t\t\tminCost = min(minCost,d[terminates[l].first][terminates[l].second][m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << minCost << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    int W,H; scanf(\"%d%d\", &W, &H); if(W==0) break;\n    static char tbl[60][30];\n    for(int y = 0; y < H; y++) {\n      for(int x = 0; x < W; x++) {\n        scanf(\" %c\", &tbl[y][x]);\n      }\n    }\n    static int tim[60][30][2];\n    for(int y = 0; y < H; y++) {\n      for(int x = 0; x < W; x++) {\n        tim[y][x][0] = tim[y][x][1] = -1;\n      }\n    }\n    priority_queue<pair<pair<int,int>,pair<int,int> > > pq;\n    for(int y = 0; y < H; y++) {\n      for(int x = 0; x < W; x++) {\n        if(tbl[y][x]=='S') {\n          pq.push(make_pair(make_pair(0,0),make_pair(y,x)));\n          pq.push(make_pair(make_pair(0,1),make_pair(y,x)));\n        }\n      }\n    }\n    int score = -1;\n    while(!pq.empty()) {\n      int t = pq.top().first.first;\n      int d = pq.top().first.second;\n      int y = pq.top().second.first;\n      int x = pq.top().second.second;\n      pq.pop();\n      if(tim[y][x][d]!=-1) continue;\n      tim[y][x][d]=-t;\n      if(tbl[y][x]=='T') {\n        score = -t;\n        break;\n      }\n      for(int yy = max(0,y-3); yy <= min(H-1,y+3); yy++) {\n        for(int xx = max(0,x-3); xx <= min(W-1,x+3); xx++) {\n          bool ok = abs(yy-y)+abs(xx-x)<=3;\n          if(d==0) ok = ok && x < xx;\n          if(d==1) ok = ok && x > xx;\n          ok = ok && tbl[yy][xx] != 'X';\n          if(ok) {\n            int cost = ('0' <= tbl[yy][xx] && tbl[yy][xx] <= '9') ? tbl[yy][xx]-'0' : 0;\n            pq.push(make_pair(make_pair(t-cost,d^1),make_pair(yy,xx)));\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", score);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>;\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int w, h; cin >> w >> h &&h;) {\n\t\tvector<vector<char>> c(h, vector<char>(w));\n\t\trep(i, 0, h)rep(j, 0, w)\n\t\t\tcin >> c[i][j];\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < h && j >= 0 && j < w; };\n\t\tauto valid = [&](int li, int lj, int ri, int rj) {return abs(li - ri) + abs(lj - rj) <= 3 && lj < rj; };\n\t\tauto index = [&](int li, int lj, int ri, int rj, int right) {\n\t\t\tint ret = li;\n\t\t\tret *= w;\n\t\t\tret += lj;\n\t\t\tret *= h;\n\t\t\tret += ri;\n\t\t\tret *= w;\n\t\t\tret += rj;\n\t\t\tret += (w*h*w*h)*right;\n\t\t\treturn ret;\n\t\t};\n\t\t// next right 1\n\t\tGraph g(h*w*h*w * 2 + 2);\n\t\tint s = h*w*h*w * 2, t = s + 1;\n\t\trep(li, 0, h)rep(lj, 0, w)rep(ri, 0, h)rep(rj, lj + 1, w) {\n\t\t\tif (!valid(li, lj, ri, rj))continue;\n\t\t\t//dump(li, lj, ri, rj);\n\t\t\tif (c[li][lj] == 'X' || c[ri][rj] == 'X')continue;\n\t\t\tif (c[li][lj] == 'S') {\n\t\t\t\taddArc(g, s, index(li, lj, ri, rj, 0), c[ri][rj] == 'S' ? 0 : c[ri][rj] - '0');\n\t\t\t}\n\t\t\tif (c[ri][rj] == 'S') {\n\t\t\t\taddArc(g, s, index(li, lj, ri, rj, 1), c[li][lj] == 'S' ? 0 : c[li][lj] - '0');\n\t\t\t}\n\t\t\tif (c[li][lj] == 'T') {\n\t\t\t\taddArc(g, index(li, lj, ri, rj, 1), t, 0);\n\t\t\t}\n\t\t\tif (c[ri][rj] == 'T') {\n\t\t\t\taddArc(g, index(li, lj, ri, rj, 0), t, 0);\n\t\t\t}\n\t\t\trep(r, 0, 2) {\n\t\t\t\tint u = index(li, lj, ri, rj, r);\n\t\t\t\trep(di, -10, 10)rep(dj, -10, 10) {\n\t\t\t\t\tint nli = li, nlj = lj, nri = ri, nrj = rj;\n\t\t\t\t\tint cost;\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tnri += di;\n\t\t\t\t\t\tnrj += dj;\n\t\t\t\t\t\tif (!inrange(nri, nrj))continue;\n\t\t\t\t\t\tif (c[nri][nrj] == 'X')continue;\n\t\t\t\t\t\tcost = c[nri][nrj] == 'T' ? 0 : c[nri][nrj] - '0';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnli += di;\n\t\t\t\t\t\tnlj += dj;\n\t\t\t\t\t\tif (!inrange(nli, nlj))continue;\n\t\t\t\t\t\tif (c[nli][nlj] == 'X')continue;\n\t\t\t\t\t\tcost = c[nli][nlj] == 'T' ? 0 : c[nli][nlj] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (!valid(nli, nlj, nri, nrj))continue;\n\t\t\t\t\t//dump(nli, nlj, nri, nrj);\n\t\t\t\t\tint v = index(nli, nlj, nri, nrj, !r);\n\t\t\t\t\taddArc(g, u, v, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tArray dist;\n\t\tdijkstra(g, s, dist);\n\t\tchmin(ans, dist[t]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n\n#define fst first\n#define snd second\n\nusing namespace std;\ntypedef pair<int,int> pt;\ntypedef pair<pt,pt> state;\ntypedef pair<int,state> que;\n\nchar cmap[100][100];\nint w,h;\n\n\nbool valid(pt p) {\n    int x = p.fst, y = p.snd;\n    return (0<=x) && (x<w) && (0<=y) && (y<h);\n}\n\nvoid pushone(priority_queue<que> &q, state st, char c, int d) {\n    if(valid(st.fst) && valid(st.snd) && c != 'X') {\n        if(c == 'T' || c == 'S')\n            q.push(que(-d, st));\n        else\n            q.push(que(-(d+c), st));\n    }\n}\n\nvoid push(priority_queue<que> &q, state st, int d) {\n    const int dx[] = {1,2,3,1,2,1,1,2,1};\n    const int dy[] = {0,0,0,-1,-1,-2,1,1,2};\n\n    for(int i=0; i<9; i++) {\n        if(valid(pt(st.fst.fst+dx[i], st.fst.snd+dy[i])))\n            pushone(q, state(st.fst, pt(st.fst.fst+dx[i], st.fst.snd+dy[i])), cmap[st.fst.fst+dx[i]][st.fst.snd+dy[i]], d);\n        if(valid(pt(st.snd.fst-dx[i], st.snd.snd+dy[i])))\n            pushone(q, state(pt(st.snd.fst-dx[i], st.snd.snd+dy[i]), st.snd), cmap[st.snd.fst-dx[i]][st.snd.snd+dy[i]], d);\n    }\n}\n\n\nint main(void) {\n    while(1) {\n        scanf(\"%d%d\",&w,&h);\n        if(!w) break;\n\n        priority_queue<que> q;\n        map<state,int> dmap;\n        memset(cmap, 0, sizeof(cmap));\n\n        for(int i=0; i<h; i++)\n            for(int j=0; j<w; j++) {\n                char s[5];\n                scanf(\"%s\",s);\n                switch(s[0]) {\n                    case 'S':\n                        cmap[j][i] = 'S';\n                        break;\n                    case 'T':\n                        cmap[j][i] = 'T';\n                        break;\n                    case 'X':\n                        cmap[j][i] = 'X';\n                        break;\n                    default:\n                        cmap[j][i] = s[0]-'0';\n                        break;\n                }\n            }\n\n        for(int i=0; i<h; i++)\n            for(int j=0; j<w; j++)\n                if(cmap[j][i] == 'S')\n                    push(q, state(pt(j,i),pt(-100,-100)), 0), push(q, state(pt(-100,-100),pt(j,i)), 0);\n\n\n        int res=-1;\n        while(q.size()) {\n            que now = q.top(); q.pop();\n            state st = now.snd;\n            int d = -now.fst;\n\n            if(dmap.find(st) != dmap.end()) continue;\n            dmap[st] = d;\n\n            if(cmap[st.fst.fst][st.fst.snd] == 'T' || cmap[st.snd.fst][st.snd.snd] == 'T') {\n                res = d;\n                break;\n            }\n\n            push(q, st, d);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nstruct edge{\n    int cost, to;\n    edge(int cost, int to) : cost(cost), to(to) {};\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w){\n        vector<vector<edge>> G(h*w*2);\n        vector<vector<int>> v(h, vector<int> (w, MOD));\n        vector<int> dist(h*w*2, MOD);\n        vector<int> goal;\n        auto f = [&w](int i, int j, int k){ return (i*w+j)*2+k;};\n        using P = pair<int, int>;\n        priority_queue<P, vector<P>, greater<>> Q;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                char c;\n                cin >> c;\n                if(isdigit(c)) v[i][j] = c-'0';\n                else if(c == 'S') {\n                    v[i][j] = 0, dist[f(i, j, 0)] = dist[f(i, j, 1)] = 0;\n                    Q.emplace(0, f(i, j, 0)); Q.emplace(0, f(i, j, 1));\n                }\n                else if(c == 'T') {\n                    v[i][j] = 0;\n                    goal.emplace_back(f(i, j, 0)), goal.emplace_back(f(i, j, 1));\n                }\n            }\n        }\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (int k = 0; k < h; ++k) {\n                    for (int l = 0; l < j; ++l) {\n                        if(abs(k-i)+abs(j-l) <= 3){\n                            if(v[k][l] != MOD) G[f(i, j, 0)].emplace_back(v[k][l] , f(k, l, 1));\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (int k = 0; k < h; ++k) {\n                    for (int l = j+1; l < w; ++l) {\n                        if(abs(k-i)+abs(j-l) <= 3){\n                            if(v[k][l] != MOD) G[f(i, j, 1)].emplace_back(v[k][l], f(k, l, 0));\n                        }\n                    }\n                }\n            }\n        }\n\n        while(!Q.empty()){\n            int cost, i; tie(cost, i) = Q.top(); Q.pop();\n            if(dist[i] < cost) continue;\n            for (auto &&e : G[i]) {\n                if(dist[e.to] <= cost + e.cost) continue;\n                dist[e.to] = cost + e.cost;\n                Q.emplace(dist[e.to], e.to);\n            }\n        }\n        int ans = MOD;\n        for (auto &&i : goal) {\n            ans = min(ans, dist[i]);\n        }\n        cout << (ans == MOD ? -1 : ans) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nstruct state{\n  int leg;\n  int x,y;\n  int cost;\n  state(int x,int y,int cost,int leg) : x(x), y(y), cost(cost), leg(leg) {}\n};\nbool operator < (state s,state r){\n  return s.cost > r.cost;\n}\nint main(void){\n  int w,h;\n  while(cin>>w>>h,w){\n    char grid[100][100];\n    int mincost[100][100][2];\n    memset(mincost,-1,sizeof(mincost));\n    REP(y,h)REP(x,w){\n      cin>>grid[y][x];\n    }\n    priority_queue<state> que;\n    REP(y,h)REP(x,w){\n      if(grid[y][x]=='S'){\n        que.push(state(x,y,0,0));\n        que.push(state(x,y,0,1));\n      }\n    }\n    bool output=false;\n    while(!que.empty()){\n      state s = que.top(); que.pop();\n      if(grid[s.y][s.x]=='T'){\n        cout<<s.cost<<endl;\n        output=true;\n        break;\n      }\n      if(mincost[s.y][s.x][s.leg]!=-1&&s.cost>=mincost[s.y][s.x][s.leg]) continue;\n      mincost[s.y][s.x][s.leg] = s.cost;\n      if(s.leg==0){\n        for(int dx = 1; dx<=3; dx++){\n          for(int dy = -3; dy<=3; dy++){\n            if(dx + abs(dy) <= 3){\n              int nx = s.x + dx;\n              int ny = s.y + dy;\n              if(0<=nx&&nx<w&&0<=ny&&ny<h&&grid[ny][nx]!='X'){\n                char ch = grid[ny][nx];\n                que.push(state(nx,ny,s.cost+((ch>='0'&&ch<='9')?ch-'0':0),1));\n              }\n            }\n          }\n        }\n      }\n      if(s.leg==1){\n        for(int dx = -1; dx>=-3; dx--){\n          for(int dy = -3; dy<=3; dy++){\n            if(abs(dx) + abs(dy) <= 3){\n              int nx = s.x + dx;\n              int ny = s.y + dy;\n              if(0<=nx&&nx<w&&0<=ny&&ny<h&&grid[ny][nx]!='X'){\n                char ch = grid[ny][nx];\n                que.push(state(nx,ny,s.cost+((ch>='0'&&ch<='9')?ch-'0':0),0));\n              }\n            }\n          }\n        }\n      }\n    }\n    if(!output) cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<tuple>\n\nusing namespace std;\ntypedef tuple<int, int, int, int, int, int> t6i;\n\nint w, h;\n\nchar gake[60][30];\nint d[60][30][60][30][2];\n\nint ans = 999999999;\n\nint vx[9] = { -2,-1,-1,0,0,0,1,1,2 };\nint vy[9] = { -1,-2,-1,-3,-2,-1,-2,-1,-1 };\n//上の差分ベクトルは左足用、右足の場合は-1倍すること\n\nvoid djkstra() {\n\tpriority_queue<t6i, vector<t6i>, greater<t6i>> pq;\n\tfor (int i = 0; i < w; i++) {\n\t\tif (gake[h - 1][i] == 'S') {\n\t\t\tfor (int j = 0; j < 9; j++) {\n\t\t\t\t//右足スタート \n\t\t\t\tint nxtx = h - 1 + vx[j], nxty = i + vy[j];\n\t\t\t\tint tmp = gake[nxtx][nxty] - '0';\n\t\t\t\tif (nxtx < 0 || nxty < 0 || nxtx >= h || nxty >= w)goto left;\n\t\t\t\tif (gake[nxtx][nxty] == 'X')goto left;\n\t\t\t\tif (gake[nxtx][nxty] == 'S')goto left;\n\t\t\t\tif (gake[nxtx][nxty] == 'T')tmp = 0;\n\t\t\t\tpq.push(make_tuple(tmp, nxtx, nxty, h - 1, i, 0));\n\t\t\t\td[nxtx][nxty][h - 1][i][0] = tmp;\n\n\t\t\tleft:;\n\n\t\t\t\t//左足スタート \n\t\t\t\tnxtx = h - 1 + vx[j] * -1, nxty = i + vy[j] * -1;\n\t\t\t\ttmp = gake[nxtx][nxty] - '0';\n\t\t\t\tif (nxtx < 0 || nxty < 0 || nxtx >= h || nxty >= w)continue;\n\t\t\t\tif (gake[nxtx][nxty] == 'X')continue;\n\t\t\t\tif (gake[nxtx][nxty] == 'S')continue;\n\t\t\t\tif (gake[nxtx][nxty] == 'T')tmp = 0;\n\t\t\t\tpq.push(make_tuple(tmp, h - 1, i, nxtx, nxty, 1));\n\t\t\t\td[h - 1][i][nxtx][nxty][1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile(pq.size()){\n\t\tauto now = pq.top(); pq.pop();\n\t\tint lx = get<1>(now), ly = get<2>(now), rx = get<3>(now), ry = get<4>(now);\n\t\tint type = get<5>(now);\n\n\t\tif (get<0>(now) > d[lx][ly][rx][ry][type])continue;\n\t\t\n\t\t//ゴールに到達したのなら、その時点でansを更新\n\t\tif (gake[lx][ly] == 'T' || gake[rx][ry] == 'T') {\n\t\t\tans = min(ans, get<0>(now));\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (type == 0) {\n\t\t\t\t//右足を出す番\n\t\t\t\tint nx = lx + vx[i] * -1, ny = ly + vy[i] * -1;\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\t\tif (gake[nx][ny] == 'X')continue;\n\t\t\t\tif (gake[nx][ny] == 'S')continue;\n\n\t\t\t\t//ゴールに到達したのなら、その時点でansを更新\n\t\t\t\tif (gake[nx][ny] == 'T') {\n\t\t\t\t\tans = min(ans, get<0>(now));\n\t\t\t\t}\n\n\t\t\t\tif (d[lx][ly][nx][ny][1] > d[lx][ly][rx][ry][0] + gake[nx][ny] - '0') {\n\t\t\t\t\td[lx][ly][nx][ny][1] = d[lx][ly][rx][ry][0] + gake[nx][ny] - '0';\n\t\t\t\t\tpq.push(make_tuple(d[lx][ly][nx][ny][1], lx, ly, nx, ny, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//左足を出す番\n\t\t\t\tint nx = rx + vx[i] , ny = ry + vy[i];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\t\tif (gake[nx][ny] == 'X')continue;\n\t\t\t\tif (gake[nx][ny] == 'S')continue;\n\n\t\t\t\t//ゴールに到達したのなら、その時点でansを更新\n\t\t\t\tif (gake[nx][ny] == 'T') {\n\t\t\t\t\tans = min(ans, get<0>(now));\n\t\t\t\t}\n\n\t\t\t\tif (d[nx][ny][rx][ry][0] > d[lx][ly][rx][ry][1] + gake[nx][ny] - '0') {\n\t\t\t\t\td[nx][ny][rx][ry][0] = d[lx][ly][rx][ry][1] + gake[nx][ny] - '0';\n\t\t\t\t\tpq.push(make_tuple(d[nx][ny][rx][ry][0], nx, ny, rx, ry, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\n\twhile (1) {\n\t\n\t\tcin >> w >> h;\n\t\tif (w + h == 0)return 0;\n\t\tfor (int i = 0; i < h; i++)for (int j = 0; j < w; j++) {\n\t\t\tcin >> gake[i][j];\n\t\t}\n\n\t\tfor (int a = 0; a < h; a++)for (int b = 0; b < w; b++)for (int c = 0; c < h; c++)for (int d_ = 0; d_ < w; d_++)\n\t\t\td[a][b][c][d_][0] = 999999999, d[a][b][c][d_][1] = 999999999;\n\n\t\tdjkstra();\n\n\t\tif (ans == 999999999)cout << \"-1\" << endl;\n\t\telse cout << ans << endl;\n\n\t\tans = 999999999;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define int long long\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct to {\n    int type, x, y;\n    to(int type, int y, int x):type(type),y(y),x(x){}\n    bool operator<(const to& t) const {\n        return type < t.type;\n    }\n};\nstruct edge {\n    to t; int cost;\n    edge(to t, int cost):t(t),cost(cost){}\n};\n\nvector<edge> G[2][61][31];\nint d[2][61][31];\n\nchar fld[62][32];\n\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint W, H;\n\nbool inside(int h, int w)\n{\n    return (0 <= h && h < H && 0 <= w && w < W);\n}\n\nvoid build_graph()\n{\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (fld[i][j] == 'T' || fld[i][j] == 'X') continue;\n\n            for (int k = 0; k < 9; ++k) {\n                int y = i + dy[k], ax = j + dx[k], bx = j + dx[k] * -1;\n\n                if (inside(y, ax) && fld[y][ax] != 'X') {\n                    int cost = (isdigit(fld[y][ax]) ? fld[y][ax] - '0' : 0);\n                    G[0][i][j].push_back(edge(to(1, y, ax), cost));\n                }\n                \n                if (inside(y, bx) && fld[y][bx] != 'X') {\n                    int cost = (isdigit(fld[y][bx]) ? fld[y][bx] - '0' : 0);\n                    G[1][i][j].push_back(edge(to(0, y, bx), cost));\n                }\n            }\n        }\n    }\n}\n\nvoid dijkstra(to s)\n{\n    typedef pair<int, to> P;\n\n    priority_queue<P, vector<P>, greater<P> > q;\n\n    q.push(P(0, to(s.type, s.y, s.x)));\n\n    d[s.type][s.y][s.x] = 0;\n\n    while (q.size()) {\n        P p = q.top();\n        q.pop();\n\n        to t = p.scd;\n        \n        if (p.fst > d[t.type][t.y][t.x]) continue;\n\n        for (int i = 0; i < G[t.type][t.y][t.x].size(); ++i) {\n            edge e = G[t.type][t.y][t.x][i];\n\n            if (d[e.t.type][e.t.y][e.t.x] > d[t.type][t.y][t.x] + e.cost) {\n                d[e.t.type][e.t.y][e.t.x] = d[t.type][t.y][t.x] + e.cost;\n                q.push(P(d[e.t.type][e.t.y][e.t.x], e.t));\n            }\n        }\n    }\n}\nsigned main()\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n            G[i][j][k].clear();\n            d[i][j][k] = inf;\n        }\n\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                scanf(\"\\n%c\", &fld[i][j]);\n            }\n        }\n\n        build_graph();\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[H - 1][i] == 'S') {\n                for (int j = 0; j < 2; ++j) {\n                    dijkstra(to(j, H - 1, i));\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[0][i] == 'T') {\n                chmin(mi, min(d[0][0][i], d[1][0][i]));\n            }\n        }\n\n        printf(\"%d\\n\", mi == inf ? -1 : mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nclass state{\npublic:\n\tint foot,x,y,cost;\n\tstate(int _f, int _x, int _y, int _c){\n\t\tfoot=_f; x=_x; y=_y; cost=_c;\n\t}\n\tbool operator<(const state& tmp)const{\n\t\treturn cost<tmp.cost;\n\t}\n};\n\nint dx[2][9];\nint dy[2][9];\n\nvoid init(){\n\tint k=0;\n\tfor(int i=1; i<=3; i++){\n\t\tfor(int j=-2; j<=2; j++)if( i+abs(j)<=3 ){\n\t\t\tdx[0][k] = i; dy[0][k] = j;\n\t\t\tdx[1][k] = -i; dy[1][k] = j;\n\t\t\tk++;\n\t\t}\n\t}\n}\n\nint atai(char c){\n\tif( '0'<=c && c<='9' ) return c-'0';\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tchar field[64][64];\n\tint memo[2][64][64];\n\tinit();\n\t// 0 = right foot  , 1 = left foot\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\trep(i,64)rep(j,64)memo[0][i][j]=memo[1][i][j]=INT_MAX;\n\t\trep(i,h)rep(j,w){\n\t\t\tscanf(\" %c \",&field[i][j]);\n\t\t}\n\t\tpriority_queue<state> q;\n\t\trep(i,w)if( field[h-1][i]=='S' ){\n\t\t\tq.push(state(0,i,h-1,0));\n\t\t\tq.push(state(1,i,h-1,0));\n\t\t\tmemo[1][h-1][i] = memo[0][h-1][i] = 0;\n\t\t}\n\t\twhile( !q.empty() ){\n\t\t\tint nx = q.top().x;\n\t\t\tint ny = q.top().y;\n\t\t\tint nf = q.top().foot;\n\t\t\tint nc = q.top().cost;\n\t\t\tq.pop();\n\t\t\trep(k,9){\n\t\t\t\tint tx = nx + dx[nf][k];\n\t\t\t\tint ty = ny + dy[nf][k];\n\t\t\t\tint next = (nf+1)%2;\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='X' )continue;\n\t\t\t\tif( memo[next][ty][tx] > nc + atai(field[ny][nx]) ){\n\t\t\t\t\tmemo[next][ty][tx] = nc + atai(field[ny][nx]);\n\t\t\t\t\tq.push(state(next, tx, ty, nc+atai(field[ny][nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\trep(i,w)if( field[0][i]=='T' ){\n\t\t\tans = min(ans, min(memo[0][0][i],memo[1][0][i]));\n\t\t}\n\t\tprintf(\"%d\\n\",ans==INT_MAX?-1:ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Node{\n    int x, y, cost, pos;\n    bool nxt;//?¬????????¶???????true, ????¶???????false\n    Node(int x, int y, int c, int p, bool n)\n         : x(x), y(y), cost(c), pos(p), nxt(n){}\n    bool operator> (const Node& N) const{\n        return cost > N.cost;\n    }\n};\nint W, H;\nchar fld[61][31];\nint dist[61][31][9][2];//????¶????????????¨?????????????????????????¶????????????¨?¬??????????????¶?\nconst int dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1}, dy[9] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int dx2[9] = {-1, -1, -2, -1, -2, -3, -1, -2, -1}, dy2[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nbool cant_go(int cx, int cy){\n    return cx < 0 || cy < 0 || W <= cx || H <= cy || fld[cy][cx] == 'X';\n}\ntypedef pair<int, int> pint;\nint solve(){\n    rep(i, 61) rep(j, 31) rep(k, 9) rep(l, 2) dist[i][j][k][l] = INF;\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    vector<int> goal;\n    rep(i, W) if(fld[0][i] == 'T'){\n        goal.push_back(i);\n        fld[0][i] = '0';\n    }\n    rep(i, W) if(fld[H - 1][i] == 'S'){\n        if(i != 0){//????¶??????????\n            que.push(Node(i - 1, H, 0, 1, false));\n            dist[H][i - 1][1][0] = 0;\n        }\n        if(i != W - 1){//????¶??????????\n            que.push(Node(i, H - 1, 0, 6, true));\n            dist[H - 1][i][6][1] = 0;\n        }\n        fld[H - 1][i] = '0';\n    }\n    while(!que.empty()){\n        Node cr = que.top(); que.pop();\n        if(dist[cr.y][cr.x][cr.pos][cr.nxt] < cr.cost) continue;\n        if(cr.nxt){\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int rx = cr.x + dx[i], ry = cr.y + dy[i];\n                if(cant_go(rx, ry)) continue;\n                int ncos = fld[ry][rx] - '0';\n                if(dist[cr.y][cr.x][i][0] > dist[cr.y][cr.x][cr.pos][1] + ncos){\n                    dist[cr.y][cr.x][i][0] = dist[cr.y][cr.x][cr.pos][1] + ncos;\n                    que.push(Node(cr.x, cr.y, dist[cr.y][cr.x][i][0], i, false));\n                }\n            }\n        }else{\n            int rx = cr.x + dx[cr.pos], ry = cr.y + dy[cr.pos];\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int lx = rx + dx2[i], ly = ry + dy2[i];\n                if(cant_go(lx, ly)) continue;\n                int ncos = fld[ly][lx] - '0';\n                if(dist[ly][lx][i][1] > dist[cr.y][cr.x][cr.pos][0] + ncos){\n                    dist[ly][lx][i][1] = dist[cr.y][cr.x][cr.pos][0] + ncos;\n                    que.push(Node(lx, ly, dist[ly][lx][i][1], i, true));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for(int k : goal){\n        rep(i, 9) rep(j, 2) ans = min(ans, dist[0][k][i][j]);\n        rep(i, 9){\n            int gx = k + dx2[i], gy = 0 + dy2[i];\n            if(cant_go(gx, gy)) continue;\n            rep(j, 2) ans = min(ans, dist[gy][gx][i][j]);\n        }\n    }\n    return ans == INF ? -1 : ans;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H && W){\n        rep(i, H) rep(j, W) cin >> fld[i][j];\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dx[2][9]={\n\t{-2,-1,0,1,2,-1,0,1,0},\n\t{-2,-1,0,1,2,-1,0,1,0}\n};\nint dy[2][9]={\n\t{1,1,1,1,1,2,2,2,3},\n\t{-1,-1,-1,-1,-1,-2,-2,-2,-3}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<vector<char> >in(n,vector<char>(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\tint dp[32][62][2];\n\t\trep(i,32)rep(j,62)rep(k,2)dp[i][j][k]=inf;\n\t\tqueue<pair<pii,pii> >q;\n\t\trep(i,m)if(in[n-1][i]=='S'){\n\t\t\tdp[n-1][i][0]=dp[n-1][i][1]=0;\n\t\t\tq.push(pair<pii,pii>(pii(n-1,i),pii(0,0)));//x,y,r or l,cost\n\t\t\tq.push(pair<pii,pii>(pii(n-1,i),pii(1,0)));//x,y,r or l,cost\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tpii a=(q.front()).first;\n\t\t\tpii b=(q.front()).second;\n\t\t\tq.pop();\n\t\t\tif(dp[a.first][a.second][b.first]<b.second)continue;\n//\t\t\tcout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n\t\t\trep(i,9){\n\t\t\t\tint nx=a.first+dx[b.first][i];\n\t\t\t\tint ny=a.second+dy[b.first][i];\n\t\t\t\tint cost=dp[a.first][a.second][b.first];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(isdigit(in[nx][ny]))cost+=in[nx][ny]-'0';\n\t\t\t\tif(in[nx][ny]=='X')continue;\n\t\t\t\tif(dp[nx][ny][b.first^1]>cost){\n\t\t\t\t\tdp[nx][ny][b.first^1]=cost;\n\t\t\t\t\t//if(in[nx][ny]!='T')\n\t\t\t\t\t\tq.push(pair<pii,pii>(pii(nx,ny),pii(b.first^1,cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,m)if(in[0][i]=='T')out=min(out,min(dp[0][i][0],dp[0][i][1]));\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<climits>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\ntypedef tuple<int, int, int> Point;\ntypedef tuple<int, Point> Node;\nint Next[2][9][2] ={\n    {\n        {-2, 1}, {-1, 1}, {0, 1}, {1, 1}, {2, 1},\n        {-1, 2}, {0, 2}, {1, 2},\n        {0, 3}\n    },\n    {\n        {-2, -1}, {-1, -1}, {0, -1}, {1, -1}, {2, -1},\n        {-1, -2}, {0, -2}, {1, -2},\n        {0, -3}\n    },\n\n};\nenum {LEFT, RIGHT};\nenum {Y, X, SIDE};\nenum {COST, POINT};\nenum {START = -2, TOP, NIL};\n\nint Dijkstra(const vector<vector<int>>& cliff, const Point& start) {\n    int result = INT_MAX;\n    int h = cliff.size();\n    int w = cliff.front().size();\n    vector<vector<vector<int>>> cost(h, vector<vector<int>>(w, vector<int>(2, INT_MAX)));\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        int c = get<COST>(q.top());\n        Point point = get<POINT>(q.top());\n        q.pop();\n        if(cost[get<Y>(point)][get<X>(point)][get<SIDE>(point)] != INT_MAX) continue;\n        cost[get<Y>(point)][get<X>(point)][get<SIDE>(point)] = c;\n        for(const auto& d: Next[get<SIDE>(point)]) {\n            int y = get<Y>(point) + d[Y];\n            int x = get<X>(point) + d[X];\n            if(y < 0 || h  <= y) continue;\n            if(x < 0 || w  <= x) continue;\n            if(cliff[y][x] == NIL) continue;\n            if(cliff[y][x] == START) continue;\n            if(cliff[y][x] == TOP) {\n                result = min(result, c);\n            } else {\n                Point next_point(y, x, get<SIDE>(point) ^ 1);\n                q.push(Node(c + cliff[y][x], next_point));\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w | h) {\n        vector<vector<int>> cliff(h, vector<int>(w));\n        for(auto& line: cliff) for(auto& v: line) {\n            char c;\n            cin >> c;\n            if(c == 'S') v = START;\n            else if(c == 'T') v = TOP;\n            else if(c == 'X') v = NIL;\n            else v = c - '0';\n        }\n\n        int answer = INT_MAX;\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n            if(cliff[y][x] != START) continue;\n            answer = min({answer, Dijkstra(cliff, Point(y, x, LEFT)), Dijkstra(cliff, Point(y, x, RIGHT))});\n        }\n        cout << ((answer == INT_MAX) ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\nint DX[9]={1,1,1,1,1,2,2,2,3};\nint DY[9]={-2,-1,0,1,2,-1,0,1,0};\n\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,Pii> G;  //.F.F=cost, .F.S=0:hidari;1:migi, .S.F=y, .S.S=x\n\n#define INF 100000\n#define SUPxl 30\n#define SUPyl 60\n\nint xl,yl;\nchar tizu[SUPyl][SUPxl];\nint isVisiteds[2][SUPyl][SUPxl];\npriority_queue< G, vector<G>, greater<G> > que;\n\nint isIkisugi(int y, int x){\n\treturn (y<0 || yl<=y || x<0 || xl<=x);\n}\n\nint dijkstra(){\n\twhile(!que.empty()){\n\t\tG g = que.top(); que.pop();\n\t\tint cost=g.F.F, turn=g.F.S, y=g.S.F, x=g.S.S;\n\t\t//DEBUG(cost); DEBUG(turn); DEBUG(y); DEBUG(x);\n\t\tif(tizu[y][x]=='T') return cost;\n\t\tif(isVisiteds[turn][y][x]) continue;\n\t\tisVisiteds[turn][y][x]=true;\n\t\tFOR(di,0,9){\n\t\t\tint ny = y + DY[di];\n\t\t\tint nx = x + (turn ? -DX[di] : DX[di]);\n\t\t\tif(isIkisugi(ny,nx)||tizu[ny][nx]=='X') continue;\n\t\t\tque.push( MP(MP( cost+((tizu[ny][nx]=='T')?0:(tizu[ny][nx]-'0')) , 1-turn ),MP( ny , nx )) );\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n\nint main(){\n\twhile(true){\n\t\tcin >> xl >> yl;\t\t\tif(!xl) return 0;\n\t\tque = priority_queue< G, vector<G>, greater<G> >();\n\t\tFOR(yi,0,yl) FOR(xi,0,xl){ isVisiteds[0][yi][xi]=false; isVisiteds[1][yi][xi]=false;}\n\t\tFOR(yi,0,yl) FOR(xi,0,xl){\n\t\t\tcin>>tizu[yi][xi];\n\t\t\tif(tizu[yi][xi]=='S'){\n\t\t\t\tque.push(MP(MP(0,0),MP(yi,xi)));\n\t\t\t\tque.push(MP(MP(0,1),MP(yi,xi)));\n\t\t\t}\n\t\t}\n\t\tcout<<dijkstra()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint dist[60][30][60][30][2];\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0) return 0;\n    vector<vector<char>> f(h,vector<char>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> f[i][j];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            dist[i][j][k][l][0]=dist[i][j][k][l][1]=INF;\n          }\n        }\n      }\n    }\n    int hx[9]={1,1,2,1,2,3,1,2,1};\n    int hy[9]={2,1,1,0,0,0,-1,-1,-2};\n    priority_queue<pair<int,tuple<int,int,int,int,int>>> dijk;\n    for(int i=0;i<w;i++){\n      if(f[h-1][i]=='S'){\n        dijk.push({0,make_tuple(h-1,i,h-1,i,0)});\n        dijk.push({0,make_tuple(h-1,i,h-1,i,1)});\n      }\n    }\n    pair<int,tuple<int,int,int,int,int>> now;\n    int lx,ly,rx,ry,fl,di,nx,ny;\n    int ans=INF;\n    while(!dijk.empty()){\n      now=dijk.top();\n      dijk.pop();\n      ly=get<0>(now.second);\n      lx=get<1>(now.second);\n      ry=get<2>(now.second);\n      rx=get<3>(now.second);\n      fl=get<4>(now.second);\n      di=-now.first;\n      if(dist[ly][lx][ry][rx][fl]==INF){\n        dist[ly][lx][ry][rx][fl]=di;\n        if(fl){\n          for(int i=0;i<9;i++){\n            nx=rx-hx[i];\n            ny=ry+hy[i];\n            if(0<=nx&&nx<w&&0<=ny&&ny<h){\n              if(f[ny][nx]!='X'){\n                if(dist[ny][nx][ry][rx][0]==INF){\n                  if(f[ny][nx]=='T'){\n                    ans=min(ans,di);\n                  }else dijk.push({-di-(f[ny][nx]-'0'),make_tuple(ny,nx,ry,rx,0)});\n                }\n              }\n            }\n          }\n        }else{\n          for(int i=0;i<9;i++){\n            nx=lx+hx[i];\n            ny=ly+hy[i];\n            if(0<=nx&&nx<w&&0<=ny&&ny<h){\n              if(f[ny][nx]!='X'){\n                if(dist[ly][lx][ny][nx][1]==INF){\n                  if(f[ny][nx]=='T'){\n                    ans=min(ans,di);\n                  }else dijk.push({-di-(f[ny][nx]-'0'),make_tuple(ly,lx,ny,nx,1)});\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint dy[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nconst int INF = 1 << 30;\nint w, h;\nint dis[60][30][2];\nchar s[60][30];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n        REP (i, h) REP (j, w) cin >> s[i][j];\n        fill_n((int*)dis, 60 * 30 * 2, INF);\n        using P = tuple<int, int, int, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<pair<int, int>> ts;\n        REP (i, h) REP (j, w) {\n            if (s[i][j] == 'S') {\n                dis[i][j][0] = dis[i][j][1] = 0;\n                que.emplace(0, i, j, 0);\n                que.emplace(0, i, j, 1);\n                s[i][j] = '0';\n            } else if (s[i][j] == 'T') {\n                s[i][j] = '0';\n                ts.emplace_back(i, j);\n            }\n        }\n        while (!que.empty()) {\n            int dd, y, x, f;\n            tie(dd, y, x, f) = que.top(); que.pop();\n            if (dis[y][x][f] < dd) continue;\n            REP (i, 9) {\n                int ny = y + dy[i];\n                int nx = x + dx[i] * (f == 0 ? 1 : -1);\n                if (ny >= 0 && ny < h && nx >= 0 && nx < w && s[ny][nx] != 'X') {\n                    if (dis[ny][nx][f ^ 1] > dis[y][x][f] + (s[y][x] - '0')) {\n                        dis[ny][nx][f ^ 1] = dis[y][x][f] + (s[y][x] - '0');\n                        que.emplace(dis[ny][nx][f ^ 1], ny, nx, f ^ 1);\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for (auto t : ts) ans = min({ans, dis[t.first][t.second][0], dis[t.first][t.second][1]});\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\tque.push(make_tuple(sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<0>(que.top());\n\t\tint y = get<1>(que.top());\n\t\tint s = get<2>(que.top());\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\", &M[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint d[30][60][2];\nvector<int>sv;\nvector<int>tv;\n//dijkstra\nint dijkstra(vector<vector<int>>&cost,State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto T : tv) {\n\t\tint d_min = min(d[T][0][0], d[T][0][1]);\n\t\tres = min(res, d_min);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\t//input\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = -1;\n\t\t\t\t\tsv.push_back(j);\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\ttv.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000;\n\t\tfor (auto start : sv) {\n\t\t\tint ans1 = min(dijkstra(cliff, State(0, start, h - 1, 1)), dijkstra(cliff, State(0, start, h - 1, -1)));\n\t\t\tans = min(ans, ans1);\n\t\t}\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t\tsv.clear();\n\t\ttv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair< int , int > P;\ntypedef pair< pair< int , P > , pair< P , bool > > PP;\n//コスト,左座標,右座標,次どっちの足？(true:左,false:右)\n#define fr first\n#define sc second\n#define MAX_W 30\n#define MAX_H 60\n#define mp(a,b) make_pair(a,b)\n\nconst int dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\nint w,h;\nchar mas[MAX_H][MAX_W];\n\nbool over(int nx,int ny){\n  return nx < 0 || nx >= w || ny < 0 || ny >= h;\n}\n\nint bfs(vector<P>& st){\n  map< pair< pair< P , P > , bool > , bool > used;\n  priority_queue< PP , vector<PP> , greater<PP> > que;\n  for(int i = 0 ; i < st.size() ; i++ ){\n    que.push(PP(mp(0,st[i]),mp(P(-1,-1),false)));\n    que.push(PP(mp(0,P(-1,-1)),mp(st[i],true)));\n  }\n  while(!que.empty()){\n    PP p = que.top();\n    que.pop();\n    if(used[mp(mp(p.fr.sc,p.sc.fr),p.sc.sc)]++) continue;\n    if(mas[p.fr.sc.fr][p.fr.sc.sc] == '0') return p.fr.fr;\n    if(mas[p.sc.fr.fr][p.sc.fr.sc] == '0') return p.fr.fr;\n    for(int i = 0 ; i < 9 ; i++ ){\n      if(p.sc.sc){ // 左足を動かす\n        int ny = p.sc.fr.fr + dy[i] , nx = p.sc.fr.sc - dx[i];\n        if(over(nx,ny) || mas[ny][nx] == 'X') continue;\n        que.push(PP(mp(p.fr.fr+(mas[ny][nx]-'0'),P(ny,nx)),mp(p.sc.fr,false)));\n      }else{ //右足を動かす\n        int ny = p.fr.sc.fr + dy[i] , nx = p.fr.sc.sc + dx[i]; // p.sc.fr.sc + dx[i]\n        if(over(nx,ny) || mas[ny][nx] == 'X') continue;\n        que.push(PP(mp(p.fr.fr+(mas[ny][nx]-'0'),p.fr.sc),mp(P(ny,nx),true)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin >> w >> h , w){\n    vector<P> st;\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'S') st.push_back(P(i,j));\n        if(mas[i][j] == 'T') mas[i][j] = '0';\n      }\n    }\n    cout << bfs(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nchar f[61][31];\nvector<pair<int,int>> g[4000];\nint d[4000];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint w,h;\n\twhile(cin >> w >> h,h){\n\t\tfor(int i=0;i<4000;i++){\n\t\t\tg[i].clear();\n\t\t\td[i]=1e9;\n\t\t}\n\t\tint s=2*h*w,t=2*h*w+1;\n\t\tint a=h*w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]=='S'){\n\t\t\t\t\tg[s].push_back({i*w+j,0});\n\t\t\t\t\tg[s].push_back({a+(i*w+j),0});\n\t\t\t\t}\n\t\t\t\tif(f[i][j]=='T'){\n\t\t\t\t\tg[i*w+j].push_back({t,0});\n\t\t\t\t\tg[a+(i*w+j)].push_back({t,0});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int k=1;k<=3;k++){\n\t\t\t\t\tfor(int l=-(3-k);l<=(3-k);l++){\n\t\t\t\t\t\tint x=i+l,y=j+k;\n\t\t\t\t\t\tif(0<=x&&x<h&&0<=y&&y<w){\n\t\t\t\t\t\t\tif(f[x][y]!='X'){\n\t\t\t\t\t\t\t\tif(f[x][y]=='S'||f[x][y]=='T'){\n\t\t\t\t\t\t\t\t\tg[i*w+j].push_back({a+(x*w+y),0});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tg[i*w+j].push_back({a+(x*w+y),f[x][y]-'0'});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx=i+l,y=j-k;\n\t\t\t\t\t\tif(0<=x&&x<h&&0<=y&&y<w){\n\t\t\t\t\t\t\tif(f[x][y]!='X'){\n\t\t\t\t\t\t\t\tif(f[x][y]=='S'||f[x][y]=='T'){\n\t\t\t\t\t\t\t\t\tg[a+(i*w+j)].push_back({(x*w+y),0});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tg[a+(i*w+j)].push_back({(x*w+y),f[x][y]-'0'});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int,int>> q;\n\t\tq.push(make_pair(0,s));\n\t\td[s]=0;\n\t\twhile(q.size()){\n\t\t\tauto p=q.top(); q.pop();\n\t\t\tif(-p.first!=d[p.second])continue;\n\t\t\tfor(auto to:g[p.second]){\n\t\t\t\tif(d[to.first]>d[p.second]+to.second){\n\t\t\t\t\td[to.first]=d[p.second]+to.second;\n\t\t\t\t\tq.push(make_pair(-d[to.first],to.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[t]==1e9){\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",d[t]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,double> P;\nint main(){\n  int n,m,p,a,b;\n  while(cin>>n>>m>>p>>a>>b,n){\n    a--,b--;\n\n    double t[8],tp;\n    vector<P> e[31];\n\n    for(int i=0;i<n;i++)cin>>t[i];\n    for(int j=0,x,y;j<p;j++){\n      cin>>x>>y>>tp;\n      x--,y--;\n      e[x].push_back(P(y,tp)),e[y].push_back(P(x,tp));\n    }\n\n    double dp[1<<8][30];\n    for(int i=0;i<=n;i++)\n      for(int j=0;j<1<<n;j++)\n\tfor(int k=0;k<m;k++)dp[j][k]=1e4;\n    dp[0][a]=0;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<1<<n;j++)\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<n;l++)\n\t    if(!(j&1<<l))\n\t      for(int w=0;w<e[k].size();w++)\n\t\tdp[j+(1<<l)][e[k][w].first]\n\t   =min(dp[j+(1<<l)][e[k][w].first],dp[j][k]+e[k][w].second/t[l]);\n\n    double ans=1e4;\n    for(int i=0;i<1<<n;i++)ans=min(ans,dp[i][b]);\n    if(ans==1e4)cout<<\"Impossible\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint tesu[61][61][2];\nchar cliff[61][61];\nint w, h;\n\nint dy[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nint dx[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nvoid solve(int isnowleft, int x, int y, int nowtesu)\n{\n    if(nowtesu >= tesu[x][y][isnowleft]) return;\n    tesu[x][y][isnowleft] = nowtesu;\n    for(int i = 0; i < 9; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[isnowleft][i];\n        if(nx < 0 || ny < 0 || nx >= h || ny >= w || cliff[nx][ny] == 'X' || cliff[nx][ny] == 'S') continue;\n        if(cliff[nx][ny] == 'T') tesu[nx][ny][!isnowleft] = min(tesu[nx][ny][!isnowleft], nowtesu);\n        // else if(cliff[nx][ny] == 'S') solve(!isnowleft, nx, ny, nowtesu);\n        else solve(!isnowleft, nx, ny, nowtesu + cliff[nx][ny] - '0');\n    }\n    return;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        vector<int> sx, sy, tx, ty;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> cliff[i][j];\n                if(cliff[i][j] == 'S'){\n                    sx.push_back(i);\n                    sy.push_back(j);\n                } else if(cliff[i][j] == 'T'){\n                    tx.push_back(i);\n                    ty.push_back(j);\n                }\n            }\n        }\n        memset(tesu, 1000000, sizeof(tesu));\n        int ans = 1000000;\n        for(int i = 0; i < 2; i++){\n            for(int j = 0; j < sx.size(); j++){\n                solve(i, sx[j], sy[j], 0);\n            }\n        }\n        // for(int k = 0; k < 2; k++){\n        //     for(int i = 0; i < h; i++){\n        //             for(int j = 0; j < w; j++){\n        //                 cout << tesu[i][j][k] << \" \";\n        //             }\n        //             cout << endl;\n        //         }\n        //         cout << endl;\n        //     }\n        for(int i = 0; i < tx.size(); i++){\n            for(int j = 0; j < 2; j++){\n                ans = min(ans, tesu[tx[i]][ty[i]][j]);\n            }\n        }\n        if(ans == 1000000) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define H 30\n#define W 60\n#define INF 10000\n#define R 1\n#define L 0\nint w, h;\nchar maps[H][W];\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][2];\n    bool used[H][W][2];\n    int ldx[9] = {-1, -1, -1, -1, -1, -2, -2, -2, -3};\n    int ldy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    int rdx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n    int rdy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    for (int i = 0; i < w - 1; i++) {\n        if (maps[h-1][i] == 'S') {\n            d[h - 1][i][L] = 0; d[h - 1][i+1][R] = 0;\n        }\n    }\n    \n    while (true) {\n        point p;\n        p.x = -1; p.y = -1;\n        int muki = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (!used[i][j][k] && (p.x == -1 || d[i][j][k] < d[p.y][p.x][muki])) {\n                        p.x = j; p.y = i; muki = k;\n                    }\n                }\n            }\n        }\n        \n        if (p.x == -1 && p.y == -1) {\n            break;\n        }\n        used[p.y][p.x][muki] = true;\n        \n        if (muki == R) { // 右足でp.y, p.xにいる\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + ldx[i];\n                int my = p.y + ldy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R]);\n                }\n                else{\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n        else{             // 左足でp.y , p.xにいる\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + rdx[i];\n                int my = p.y + rdy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L]);\n                }\n                else{\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int j = 0; j < w; j++) {\n        if (maps[0][j] == 'T'){\n            for (int k = 0; k < 2; k++) {\n                ans = min(ans, d[0][j][k]);\n            }\n        }\n    }\n    if (ans == INF) {\n        return -1;\n    }\n    else {\n        return ans;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> maps[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cctype>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int> >, greater<tuple<int, int, int, int> > > que;\n\n\tque.push(make_tuple(0, sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(0, sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<1>(que.top());\n\t\tint y = get<2>(que.top());\n\t\tint s = get<3>(que.top());\n\n\t\tque.pop();\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][1], x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][0], x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret == 999999999 ? -1 : ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define Y first\n#define X second\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint W,H;\nchar s[65][35];\nint d[65][35][2];\n\nstruct cliffState{\n  int step;\n  int y;\n  int x;\n  int side;\n  cliffState(int _step, int _y, int _x, int _side){\n    step = _step;\n    y = _y;\n    x = _x;\n    side = _side;\n  }\n  bool operator >(const cliffState &e) const{\n    return step > e.step;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>W>>H;\n    if(W==0 || H==0) break;\n    vector< pair<int, int> > iniv;\n    REP(i,0,H){\n      REP(j,0,W){\n        cin>>s[i][j];\n        if(s[i][j]=='S') iniv.push_back(make_pair(i,j));\n      }\n    }\n\n    int ans = INF;\n\n    REP(inipos,0,iniv.size()){/*?????????????????°????????°?????????????????§W???H????????????*/\n      REP(iniside,0,2){\n\n        REP(i,0,H)REP(j,0,W)REP(k,0,2) d[i][j][k] = INF;\n        d[iniv[inipos].Y][iniv[inipos].X][iniside] = 0;\n\n        priority_queue< cliffState, vector<cliffState>, greater<cliffState> > PQ;\n        cliffState cs = cliffState(0,iniv[inipos].Y,iniv[inipos].X,iniside);\n        PQ.push(cs);\n\n        while(!PQ.empty()){\n\n          cliffState nowPos = PQ.top();\n          PQ.pop();\n          if(d[nowPos.y][nowPos.x][nowPos.side] < nowPos.step) continue;\n\n          REP(i,nowPos.y-2,nowPos.y+2+1){\n            if(i < 0 || H <= i) continue;\n            int diff;\n            if(i == nowPos.y-2 || i == nowPos.y+2) diff = 1;\n            else if(i == nowPos.y-1 || i == nowPos.y+1) diff = 2;\n            else diff = 3;\n            if(nowPos.side == 0){\n              REP(j,nowPos.x+1,nowPos.x+diff+1){\n                if(j < 0 || W <= j || i < 0 || H <= i) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }else{\n              REP(j,nowPos.x-diff,nowPos.x){\n                if(j < 0 || W <= j) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }\n\n          }\n\n        }\n\n        int tans = INF;\n        REP(i,0,H){\n          REP(j,0,W){\n            if(s[i][j] == 'T') tans = min(tans, min(d[i][j][0], min(d[i][j][1]));\n          }\n        }\n        ans = min(ans,tans);\n\n      }\n    }\n\n    if(ans == INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct State{\n  int x,y,t;\n  bool isR;\n  State(){}\n  State(int a, int b, int c, bool d):\n    x(a),y(b),t(c),isR(d){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\n\nconst int MW = 31;\nconst int MH = 51;\nconst int INF = (1<<25);\n\nint M[MH][MW],T[MH][MW][2],w,h;\nvector<P> S;\nvector<P> G;\n\nvoid print(){\n  for(int i = 0; i < h; i++){\n    for(int x = 0; x < 2; x++){\n      for(int j = 0; j < w; j++) \n\tif(T[i][j][x] == INF) cout << \"  X\";\n\telse printf(\"%3d\",T[i][j][x]);\n      cout << \"                 \";\n    } \n    cout << endl;\n  }\n  cout << endl << endl;\n}\n\nbool isInside(int x, int y) {return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  for(int i = 0; i < MH; i++)\n    for(int j = 0; j < MW; j++) T[i][j][0] = T[i][j][1] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      char c;\n      cin >> c;\n      if(c == 'X') M[i][j] = INF;\n      else if(c == 'T'){\n\tM[i][j] = 0;\n\tG.push_back(P(j,i));\n      }else if(c == 'S'){\n\tM[i][j] = 0;\n\tS.push_back(P(j,i));\n      }else M[i][j] = c-'0';\n    }\n}\n\nint solve(bool R){\n  \n  init();\n\n  priority_queue<State> Q;\n\n  for(int i = 0; i < S.size(); i++){\n    int sx = S[i].first;\n    int sy = S[i].second;\n    Q.push(State(sx,sy,0,R));\n    T[sy][sx][R] = 0;\n  }\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    if(T[now.y][now.x][now.isR] < now.t) continue;\n    \n    for(int i = 1; i <= 3; i++)\n      for(int j = -2; j <= 2; j++){\n\tint mx = i,my = j;\n\tif(now.isR) mx *= -1;\n\tint nx = now.x+mx;\n\tint ny = now.y+my;\n\t\n\t//\tif(abs(mx) + abs(my) <= 3) cout << now.isR << \" \" <<  mx << \" \" << my << \" \" << endl;\n\tif(isInside(nx,ny) && abs(mx)+abs(my) <= 3 && T[ny][nx][!now.isR] > now.t+M[ny][nx]){\n\t  T[ny][nx][!now.isR] = now.t+M[ny][nx];\n\t  Q.push(State(nx,ny,now.t+M[ny][nx],!now.isR));\n\t}\n      }\n  }\n\n  //print();\n  int ans = INF;\n\n  for(int i = 0; i < G.size(); i++) ans = min(ans,min(T[G[i].second][G[i].first][0],T[G[i].second][G[i].first][1]));\n\n  return ans;\n}\n\nint main(){\n\n  while(cin >> w >> h && w+h){\n    S.clear();\n    G.clear();\n    input();\n    int ans = min(solve(true),solve(false));\n    if(ans == INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\n#define INF 1<<30\nusing namespace std;\nint dy[]={2,1,0,-1,-2,1,0,-1,0},dx[]={1,1,1,1,1,2,2,2,3};\nstruct S{\n\tint y,x,f;\n\tS(int y,int x,int f):y(y),x(x),f(f){}\n};\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tchar cli[64][32]; queue<S> F;\n\t\tint cost[64][32][2],ans=INF;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>cli[i][j];\n\t\t\trep(k,2){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\tif(cli[i][j]=='S')F.push(S(i,j,k)),cost[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.front();F.pop();\n\t\t\trep(d,9){\n\t\t\t\tS ns=cs; ns.y+=dy[d],ns.x+=cs.f?dx[d]:-dx[d],ns.f^=1;\n\t\t\t\tif(!ck(ns.y,h)||!ck(ns.x,w)||cli[ns.y][ns.x]=='X')continue;\n\t\t\t\tint nc=cost[cs.y][cs.x][cs.f]+(cli[ns.y][ns.x]=='T'?0:cli[ns.y][ns.x]-'0');\n\t\t\t\tif(cost[ns.y][ns.x][ns.f]>nc)cost[ns.y][ns.x][ns.f]=nc,F.push(S(ns.y,ns.x,ns.f));\n\t\t\t\tif(cli[ns.y][ns.x]=='T'&&ans>nc)ans=nc;\n\t\t\t}\n\t\t}\n\t\tcout<<(ans==INF?-1:ans)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<map>\nusing namespace std;\n\n// #define int long long\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n\t \nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\nconst long long INF = (long long)1e9;\n\nint ans;\n\nint d[30 * 60 * 30 * 60];\nshort z[30 * 60 * 30 * 60];\nvector<vector<char>> s;\nint A , B, C;\n\n// void dijkstra(map<int,int> &d, vector<vector<pair<int,int>>> &G, \nvoid dijkstra(vector<vector<pair<int,int>>> &G, \npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>& q){\n\t\n\t\n\t// d[s] = 0;\n\t\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.top();q.pop();\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first) continue;\n\t\t\n\t\tint a = v/A;\n\t\tint b = v%A/B;\n\t\tint c = v%B/C;\n\t\tint D = v%C;\n\t\t\n\t\t\n\t\tif(s[a][b] == 'T'){\n\t\t\tans = p.first;\n\t\t\treturn ;\n\t\t}\n\t\tif(s[c][D] == 'T') {\n\t\t\tans = p.first;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tfor(pair<int,int> e : G[v]){\n\t\t\tif(d[e.first] > d[v] + e.second){\n\t\t\t\td[e.first] = d[v] + e.second;\n\t\t\t\tq.push(make_pair(d[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nsigned main(){\n\tint con = 0;\n\t\n\twhile(true){\n\t\tcon++;\n\t\tint w, h;\n\t\t// map<int,int> d;\n\t\tvector<vector<pair<int,int>>> G;\n\t\t\n\t\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n\t\tcin>>w>>h;\n\t\t\n\t\tif(!w && !h) break;\n\t\t\n\t\ts.clear();\n\t\ts.resize(h, vector<char>(w));\n\t\t\n\t\tA = w * h * w;\n\t\tB = w * h;\n\t\tC = w;\n\t\t\n\t\tG.resize(w * h * w * h);\n\t\t\n\t\t// d.resize(G.size(),INF);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[i][j] == 'X') continue;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\tfor(int l = 0; l < w; l++){// cout<<\"<>\"<<endl;\n\t\t\t\t\t\n\t\t\t\t\t\tif(s[k][l] == 'X') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(abs(i - k) + abs(j - l) > 3) continue;\n\t\t\t\t\t\n\t\t\t\t\t\tint ly = i, lx = j;\n\t\t\t\t\t\tint ry = k, rx = l;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = ly * A + lx * B + ry * C + rx;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbool fr = true;\n\t\t\t\t\t\tbool fl = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(s[ly][lx] != 'S') fr = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(s[ry][rx] != 'S') fl = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\td[cur] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int nx = 1; nx <= 3; nx++){\n\t\t\t\t\t\t\tfor(int ny = -2; ny <= 2; ny++){\n\t\t\t\t\t\t\t\tint nry = ly + ny;\n\t\t\t\t\t\t\t\tint nrx = lx + nx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint nex = ly * A + lx * B + nry * C + nrx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(nry < 0 || nry >= h || nrx < 0 || nrx >= w) continue;\n\t\t\t\t\t\t\t\tif(abs(nry - ly) + abs(nrx - lx) > 3) continue;\n\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'X') continue;\n\t\t\t\t\t\t\t\t// if(s[ly][lx] == 'S') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// d[nex] = INF;\n\t\t\t\t\t\t\t\tif(z[nex] == con) d[nex] = min(d[nex],(int)INF);\n\t\t\t\t\t\t\t\telse d[nex] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(fr) {\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) {\n\t\t\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = min(d[nex],s[nry][nrx]  - '0');\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = s[nry][nrx]  - '0';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq.push(make_pair(d[nex],nex));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tz[nex] = con;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') G[cur].push_back({nex, 0});\n\t\t\t\t\t\t\t\t// else G[cur].push_back({nex, s[nry][nrx] - '0'});\n\t\t\t\t\t\t\t\telse G[cur].push_back({nex, s[nry][nrx] - '0'});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int nx = -1; nx >= -3; nx--){\n\t\t\t\t\t\t\tfor(int ny = -2; ny <= 2; ny++){\n\t\t\t\t\t\t\t\tint nly = ry + ny;\n\t\t\t\t\t\t\t\tint nlx = rx + nx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint nex = nly * A + nlx * B + ry * C + rx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(nly < 0 || nly >= h || nlx < 0 || nlx >= w) continue;\n\t\t\t\t\t\t\t\tif(abs(nly - ry) + abs(nlx - rx) > 3) continue;\n\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'X') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if(s[ry][rx] == 'S') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) d[nex] = min(d[nex],(int)INF);\n\t\t\t\t\t\t\t\t\telse d[nex] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(fl) {\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) {\n\t\t\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T')d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = min(d[nex],s[nly][nlx] - '0');\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T')d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = s[nly][nlx] - '0';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tq.push(make_pair(d[nex],nex));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tz[nex] = con;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T') G[cur].push_back({nex, 0});\n\t\t\t\t\t\t\t\telse G[cur].push_back({nex, s[nly][nlx] - '0'});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// dijkstra((h-1) * A + 0 * B + (h-1) * C + 1,d, G);\n\t\t\n\t\t\n\t\tans = INF;\n\t\t\n\t\t// dijkstra(d, G, q);\n\t\tdijkstra(G, q);\n\t\t\n\t\t// for(int i = 0; i < h; i++){\n\t\t\t// for(int j = 0; j < w; j++){\n\t\t\t\t// for(int k = 0; k < h; k++){\n\t\t\t\t\t// for(int l = 0; l < w; l++){\n\t\t\t\t\t\t// if(s[i][j] != 'T' && s[k][l] != 'T') continue;\n\t\t\t\t\t\t// if(d[i*A + j*B + k * C + l] == 0) continue;\n\t\t\t\t\t\t// ans = min(d[i*A + j*B + k * C + l], ans);\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\t\n\t\t\n\t\tif(ans != INF)cout<<ans<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n \n \n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LINF 1000000000000000000 //9000000000000000000\n#define DINF 100000000.0\n#define PI 3.14159265358979\n#define MAXI 7500000\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n \nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0,0 };\n\nstruct edge{long long int to,cost;};\n\n \nint main(void){\n\n\twhile(1){\n\t\t\n\t\tlong long int w,h;\n\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<long long int> v(3600,LINF);\n\t\tvector<edge> G[3600];\n\t\tlong long int d[3600];\n\t\tlong long int mini=LINF;\n\t\tqueue<P> start; //y,x\n\t\tvector<P> end;\n\t\tP tmp;\n\n\t\tchar s[61][31];\n\t\tLFOR(i,1,h){\n\t\t\tLFOR(j,1,w){\n\t\t\t\tcin>>s[i][j];\n\t\t\t\tif(s[i][j]=='S'){\n\t\t\t\t\tstart.push(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\tif(s[i][j]=='T'){\n\t\t\t\t\tend.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tedge ED;\t\t\n\n\t\tLFOR(y,1,h){\n\t\t\tLFOR(x,1,w){\n\t\t\t\tLFOR(l,0,1){\n\t\t\t\t\tif(l==0){//左\n\t\t\t\t\t\tLFOR(rx,1,3){\n\t\t\t\t\t\t\tLFOR(ry,-2,2){\n\t\t\t\t\t\t\t\tif(rx+abs(ry)<=3){\n\t\t\t\t\t\t\t\t\tif(x+rx>=1&&x+rx<=w&&y+ry>=1&&y+ry<=h){\n\t\t\t\t\t\t\t\t\t\tif(s[y+ry][x+rx]!='X'){\n\t\t\t\t\t\t\t\t\t\t\tED.to=2*(y+ry-1)*w+2*(x+rx-1)+1;\n\t\t\t\t\t\t\t\t\t\t\tif(s[y+ry][x+rx]=='T'||s[y+ry][x+rx]=='S'){\n\t\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\tED.cost=(s[y+ry][x+rx]-'0');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tG[2*(y-1)*w+2*(x-1)].push_back(ED);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{//右\n\t\t\t\t\t\tLFOR(lx,-3,-1){\n\t\t\t\t\t\t\tLFOR(ly,-2,2){\n\t\t\t\t\t\t\t\tif(abs(lx)+abs(ly)<=3){\n\t\t\t\t\t\t\t\t\tif(x+lx<=w&&x+lx>=1&&y+ly>=1&&y+ly<=h){\n\t\t\t\t\t\t\t\t\t\tif(s[y+ly][x+lx]!='X'){\n\t\t\t\t\t\t\t\t\t\t\tED.to=2*(y+ly-1)*w+2*(x+lx-1);\n\t\t\t\t\t\t\t\t\t\t\tif(s[y+ly][x+lx]=='T'||s[y+ly][x+lx]=='S'){\n\t\t\t\t\t\t\t\t\t\t\t\tED.cost=0;\n\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\tED.cost=(s[y+ly][x+lx]-'0');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tG[2*(y-1)*w+2*(x-1)+l].push_back(ED);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!start.empty()){\n\t\t\ttmp=start.front();\n\t\t\tstart.pop();\n\t\t\tLFOR(l,0,1){\n\t\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\t\tLFOR(i,0,3599){\n\t\t\t\t\td[i]=LINF;\n\t\t\t\t}\n\t\t\t\td[2*(tmp.first-1)*w+2*(tmp.second-1)+l]=0;\n\t\t\t\tque.push(P(0,2*(tmp.first-1)*w+2*(tmp.second-1)+l));\n\n\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tlong long int v=p.second;\n\t\t\t\t\tif(d[v]<p.first){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(G[v].size()!=0){\n\t\t\t\t\t\tLFOR(i,0,G[v].size()-1){\n\t\t\t\t\t\tedge e=G[v][i];\n\t\t\t\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tLFOR(i,0,end.size()-1){\n\t\t\t\t\tLFOR(k,0,1){\n\t\t\t\t\t\tmini=min(mini,d[2*(end[i].first-1)*w+2*(end[i].second-1)+k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(mini!=LINF){\n\t\t\tcout<<mini<<endl;\n\t\t}else{\n\t\t\tcout<<-1<<endl;\n\t\t}\n\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\nchar s[100][100];\nint d[100][100][2];\n\nint dx[2][9] = { { 1, 1, 1, 1, 1, 2, 2, 2, 3 },\n\t\t\t\t{ -1, -1, -1, -1, -1, -2, -2, -2, -3 } };\nint dy[9] = { 2,1,0,-1,-2,1,0,-1,0 };\n\nconst int INF = 1e9;\n\ntypedef tuple<int, int, int> T;\n\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx && y < my;\n}\n\nint main(){\n\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\n\t\tmemset(s, 0, sizeof s);\n\n\t\trep(i, 100)rep(j, 100)rep(k, 2)d[i][j][k] = INF;\n\n\t\tqueue<T> q;\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> s[y][x];\n\t\t\tif (s[y][x] == 'S'){\n\t\t\t\tq.push(T(y, x, 0));\n\t\t\t\tq.push(T(y, x, 1));\n\t\t\t\td[y][x][0] = 0;\n\t\t\t\td[y][x][1] = 0;\n\t\t\t}\n\t\t}\n\n\t\twhile (q.size()){\n\t\t\tint y = get<0>(q.front());\n\t\t\tint x = get<1>(q.front());\n\t\t\tint r = get<2>(q.front());\n\t\t\tq.pop();\n\n\t\t\trep(i, 9){\n\t\t\t\tint tx = x + dx[r][i];\n\t\t\t\tint ty = y + dy[i];\n\n\t\t\t\tint tmp = 0;\n\t\t\t\tif (s[ty][tx] >= '0' && s[ty][tx] <= '9')tmp = s[ty][tx] - '0';\n\n\t\t\t\tif (cheak(x, y, w, h) && (d[ty][tx][1-r] > d[y][x][r] + tmp)\n\t\t\t\t\t&& (s[ty][tx] != 'X')){\n\n\t\t\t\t\td[ty][tx][1-r] = d[y][x][r] + tmp;\n\t\t\t\t\tq.push(T(ty, tx, 1 - r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(y, h)rep(x, w){\n\t\t\tif (s[y][x] == 'T'){\n\t\t\t\tans = min(ans, d[y][x][0]);\n\t\t\t\tans = min(ans, d[y][x][1]);\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\nint INF = 1000000;\n\n\nint dx[2][9]= { { 1,1,1,1,1,2,2,2,3},\n                {-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dy[2][9] = {{ 2,1,0,-1,-2,1,0,-1,0},\n                {2,1,0,-1,-2,1,0,-1,0}};\n\n\nint w,h;\nchar cliff[65][35];\nint dp[65][35][2];\n\nbool check(int i,int j){\n    if(i < 0 || i >= h || j < 0 || j >= w) return false;\n    if(cliff[i][j] == 'X')return false;\n    return true;\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(w + h == 0)break;\n        queue<T> que;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                dp[i][j][0] = INF;\n                dp[i][j][1] = INF;\n                cin >> cliff[i][j];\n                if(cliff[i][j] == 'S'){\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = 0;\n                    que.push(make_tuple(i,j,0,0));\n                    que.push(make_tuple(i,j,1,0));\n                    cliff[i][j] = '0';\n                }\n            }\n        }\n        while(!que.empty()){\n            T t = que.front(); que.pop();\n            int y = get<0>(t),x = get<1>(t),lr = get<2>(t),m = get<3>(t);\n            if(dp[y][x][lr] != m)continue;\n            for(int k = 0;k < 9;k++){\n                int i = y + dy[lr][k],j = x + dx[lr][k];\n                if(check(i,j) == false)continue;\n                if(dp[i][j][(lr+1)%2] > m + (int) (cliff[y][x] - '0') ){\n                    dp[i][j][(lr+1)%2] = m +  (int) (cliff[y][x] - '0') ;\n                    if(cliff[i][j] != 'T'){\n                        que.push(make_tuple(i,j,(lr+1)%2,dp[i][j][(lr+1)%2]));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                for(int k = 0;k < 2;k++){\n                    if(cliff[i][j] == 'T') ans = min(ans,dp[i][j][k]);\n                }\n            }\n        }\n        if(ans == INF)ans = -1;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXH = 60;\nconst int MAXW = 30;\nconst int dx[13] = {0,0,0,0,0,   1,1,1,  -1,-1,-1, 2, -2};\nconst int dy[13] = {2,1,0,-1,-2, 1,0,-1, 1,0,-1,   0, 0};\n\nint w, h;\nchar s[MAXH][MAXW];\n\nstruct State {\n  int lx, ly, rx, ry, f, cost;\n\n  bool operator < (const State &s) const {\n    if(lx != s.lx) return lx < s.lx;\n    if(ly != s.ly) return ly < s.ly;\n    if(rx != s.rx) return rx < s.rx;\n    if(ry != s.ry) return ry < s.ry;\n    if(f != s.f) return f < s.f;\n    return false;\n  }\n\n  bool ok() const {\n    return lx < rx && abs(lx-rx) + abs(ly-ry) <= 3 &&\n      0 <= min(lx,rx) && max(lx,rx) < w &&\n      0 <= min(ly,ry) && max(ly,ry) < h;\n  }\n};\n\nstruct GT {\n  bool operator () (const State &a, const State &b) const {\n    return a.cost > b.cost;\n  }\n};\n\nint main() {\n  while(cin >> w >> h && (w|h)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    try {\n      map<State, int> cost;\n      priority_queue<State, vector<State>, GT> que;\n      for(int x = 0; x < w; ++x) {\n        for(int y = 0; y < h; ++y) {\n          if(s[y][x] != 'S') continue;\n          State src = {x, y, x, y, 0, 0};\n          src.f = 0;\n          cost[src] = 0;\n          que.push(src);\n          src.f = 1;\n          cost[src] = 0;\n          que.push(src);\n        }\n      }\n      while(que.size()) {\n        const State a = que.top();\n        que.pop();\n        if(cost.count(a) && a.cost > cost[a]) continue;\n        for(int k = 0; k < 13; ++k) {\n          State b; int x, y;\n          if(a.f) {\n            b = (State){a.rx+dx[k]-1, a.ry+dy[k], a.rx, a.ry, !a.f, a.cost};\n            x = b.lx, y = b.ly;\n          } else {\n            b = (State){a.lx, a.ly, a.lx+dx[k]+1, a.ly+dy[k], !a.f, a.cost};\n            x = b.rx, y = b.ry;\n          }\n          if(!b.ok()) continue;\n          if(s[y][x] == 'X') continue;\n          if(s[y][x] == 'T') throw a.cost;\n          if(s[y][x] != 'S') b.cost += s[y][x] - '0';\n          if(cost.count(b) && b.cost >= cost[b]) continue;\n          cost[b] = b.cost;\n          que.push(b);\n        }\n      }\n      throw -1;\n    } catch(int res) {\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_DIR 9\n#define MAX_N 100\n#define INF 1 << 30\n\nstring C;\nint X[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint G[MAX_N][MAX_N];\nint DIST[MAX_N][MAX_N][MAX_DIR];//Left,DY-DX\nint dy[MAX_DIR] = { 1,1,1,1,1,2,2,2,3 };\nint dx[MAX_DIR] = { -2,-1,0,1,2,-1,0,1,0 };\nint dz[MAX_DIR] = { 4,3,2,1,0,7,6,5,8 };\nint H, W;\nchar U[11] = \"0123456789\";\n\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>> > Q;\n\nvoid MEMSET() {\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tX[i][j] = INF;\n\t\t\tS[i][j] = 0;\n\t\t\tG[i][j] = 0;\n\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\tDIST[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DIJKSTRA() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j + dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[i][j][k] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i - dy[k];\n\t\t\t\t\tint X1 = j - dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[Y1][X1][dz[k]] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, dz[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\ttuple<int, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tint LY = a2, LX = a3;\n\t\tint RY = a2 + dy[a4], RX = a3 + dx[a4];\n\n\t\t//hidari.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = RY - dy[k];\n\t\t\tint cx = RX - dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[cy][cx][dz[k]] > dis + pos) {\n\t\t\t\t\tDIST[cy][cx][dz[k]] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[cy][cx][dz[k]], cy, cx, dz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//migi.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = LY + dy[k];\n\t\t\tint cx = LX + dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[LY][LX][k]>dis + pos) {\n\t\t\t\t\tDIST[LY][LX][k] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[LY][LX][k], LY, LX, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (G[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint ey = i + dy[k];\n\t\t\t\t\tint ex = j + dx[k];\n\t\t\t\t\tif (ey < 1 || ey > H) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ex < 1 || ex > W) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (G[ey][ex] == 1) {\n\t\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res >= INF) {\n\t\treturn -1;\n\t}\n\treturn res;\n}\n\nint power(int a, int b) {\n\tint R = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tR *= b;\n\t}\n\treturn R;\n}\n\nvoid CIN() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> C;\n\t\t\tif (C == \"X\") {\n\t\t\t\tX[i][j] = INF;\n\t\t\t}\n\t\t\telse if (C == \"S\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tS[i][j] = 1;\n\t\t\t}\n\t\t\telse if (C == \"T\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint D = C.size();\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tfor (int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif (C[k] == U[l]) {\n\t\t\t\t\t\t\tcnt1 += power(10, D - k - 1)*l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX[i][j] = cnt1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tS[H + 1][i] = 1;\n\t\tX[H + 1][i] = 0;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tMEMSET();\n\t\t//cin.\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tCIN();\n\t\tcout << DIJKSTRA() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nP d[9] = {P(1, 2), P(1, 1), P(1, 0), P(1, -1), P(1, -2), P(2, 1), P(2, 0), P(2, -1), P(3, 0)};\nint w, h;\nbool check[60][30][2];\nint cliff[60][30];\n\nstruct state {\n  P place;\n  int cost;\n  int left;\n};\n\nbool operator<(const state &a, const state &b) {return a.cost > b.cost;}\n\nbool range(int x, int y) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n\n  while(cin >> w >> h, w) {\n    vector<P> s, t;\n    rep(i, h)rep(j, w) {\n      check[i][j][0] = check[i][j][1] = false;\n      char c;\n      cin >> c;\n      if ('0' < c && c <= '9') cliff[i][j] = c - '0';\n      else if (c == 'S') cliff[i][j] = 0, s.pb(P(j, i));\n      else if (c == 'T') cliff[i][j] = 0, t.pb(P(j, i));\n      else cliff[i][j] = -1;\n    }\n\n    priority_queue<state> q;\n    rep(i, s.size()) q.push(state{s[i], 0, 0}), q.push(state{s[i], 0, 1});\n    int ans = INF;\n    bool ok;\n    while(!q.empty()) {\n      state p = q.top(); q.pop();\n\n      if (check[p.place.se][p.place.fi][p.left]) continue;\n      else check[p.place.se][p.place.fi][p.left] = true;\n\n      ok = false;\n      rep(i, t.size()) if (p.place == t[i]) ok = true;\n      if (ok) {\n        ans = p.cost;\n        break;\n      }\n\n      rep(i, 9) {\n        int x = ((p.left == 1) ? p.place.fi - d[i].fi : p.place.fi + d[i].fi), y = p.place.se + d[i].se;\n        if (range(x, y) && !check[y][x][(p.left + 1) % 2] && cliff[y][x] >= 0) {\n          q.push(state{P(x, y), p.cost + cliff[p.place.se][p.place.fi], (p.left + 1) % 2});\n        }\n      }\n    }\n\n    if (ans == INF) print(-1);\n    else print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\nconst int lx[] = { -1, -1, -1, -1, -1, -2, -2, -2, -3 };\nconst int ly[] = { -2, -1,  0,  1,  2, -1,  0,  1,  0 };\nconst int rx[] = {  1,  1,  1,  1,  1,  2,  2,  2,  3 };\nconst int ry[] = { -2, -1,  0,  1,  2, -1,  0,  1,  0 };\n\nclass State\n{\npublic:\n\tint x, y, cost, isLeft;\n\n\tState(int xx, int yy, int c, int lr)\n\t\t:x(xx), y(yy), cost(c), isLeft(lr) {}\n\tbool operator < (const State& st) const\n\t{\n\t\treturn this->cost > st.cost;\n\t}\n};\n\n\nint main()\n{\n\t//freopen(\"D\", \"r\", stdin);\n\tconst int INF = 1 << 30;\n\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h) != EOF) {\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tstatic int cost[61][31][2];\n\t\tstatic bool visited[61][31][2];\n\t\tfor (int i = 0; i < 61; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tcost[i][j][0] = INF;\n\t\t\t\tcost[i][j][1] = INF;\n\t\t\t\tvisited[i][j][0] = false;\n\t\t\t\tvisited[i][j][1] = false;\n\t\t\t}\n\t\t}\n\n\t\tchar f[61][31];\n\t\tpriority_queue<State> que;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t\t//scanf(\"%d\", &f[i][j]);\n\t\t\t\tif (f[i][j] == 'S') {\n\t\t\t\t\tque.push(State(j, i, 0, 1));\n\t\t\t\t\tque.push(State(j, i, 0, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\twhile (!que.empty()) {\n\t\t\tconst State st = que.top();\n\t\t\tque.pop();\n\n\t\t\t//printf(\"(%d, %d) (%d, %d)\\n\", st.left.x, st.left.y, st.right.x, st.right.y);\n\n\t\t\tif (f[st.y][st.x] == 'T') {\n\t\t\t\t\tans = st.cost;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (visited[st.y][st.x][st.isLeft] ||\n\t\t\t\tcost[st.y][st.x][st.isLeft] < st.cost)\n\t\t\t\tcontinue;\n\n\t\t\tvisited[st.y][st.x][st.isLeft] = true;\n\n\t\t\tif (st.isLeft == 1) {\n\t\t\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\t\t\tint xx = st.x + rx[i];\n\t\t\t\t\tint yy = st.y + ry[i];\n\t\t\t\t\tif (xx < 0 || xx >= w || yy < 0 || yy >= h || f[yy][xx] == 'X')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint c = st.cost;\n\t\t\t\t\tif (isdigit(f[yy][xx]))\n\t\t\t\t\t\tc += (f[yy][xx] - '0');\n\t\t\t\t\tif (cost[yy][xx][0] > c) {\n\t\t\t\t\t\tcost[yy][xx][0] = c;\n\t\t\t\t\t\tque.push(State(xx, yy, c, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\t\t\tint xx = st.x + lx[i];\n\t\t\t\t\tint yy = st.y + ly[i];\n\t\t\t\t\tif (xx < 0 || xx >= w || yy < 0 || yy >= h || f[yy][xx] == 'X')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint c = st.cost;\n\t\t\t\t\tif (isdigit(f[yy][xx]))\n\t\t\t\t\t\tc += (f[yy][xx] - '0');\n\t\t\t\t\tif (cost[yy][xx][1] > c) {\n\t\t\t\t\t\tcost[yy][xx][1] = c;\n\t\t\t\t\t\tque.push(State(xx, yy, c, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)\n\t\t\tans = -1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdlib>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int lx, ly, rx, ry, foot, cost;\n    Edge(int _lx, int _ly, int _rx, int _ry, int f, int c)\n        : lx(_lx), ly(_ly), rx(_rx), ry(_ry), foot(f), cost(c) {}\n    Edge() {}\n    bool operator<(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w + h) {\n        auto mp = make_v(h, w, ' ');\n        REP(i, 0, h) {\n            REP(j, 0, w) {\n                cin >> mp[i][j];\n            }\n        }\n        priority_queue<Edge, vector<Edge>> pq;\n        REP(i, 0, h) {\n            REP(j, 0, w) {\n                if (mp[i][j] == 'S') {\n                    REP(x, -3, 4) {\n                        REP(y, -3, 4) {\n                            if (abs(x) + abs(y) > 3) continue;\n                            int nx = j + x;\n                            int ny = i + y;\n                            if (nx < 0 || ny < 0 || nx >= w || ny >= h || mp[ny][nx] == 'X') continue;\n                            if (x < 0) {\n                                pq.emplace(nx, ny, j, i, 1, mp[ny][nx] - '0');\n                            } else if (x > 0) {\n                                pq.emplace(j, i, nx, ny, 0, mp[ny][nx] - '0');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        const int inf = 1 << 29;\n        auto Cost = make_v(w, h, w, h, 2, inf);\n        auto used = make_v(w, h, w, h, 2, false);\n        int ans = -1;\n        while (pq.size()) {\n            Edge e = pq.top();\n            pq.pop();\n            if (used[e.lx][e.ly][e.rx][e.ry][e.foot]) continue;\n            used[e.lx][e.ly][e.rx][e.ry][e.foot] = true;\n            //            cout << e.lx << ' ' << e.ly << ' ' << e.rx << ' ' << e.ry << ' ' << e.foot << ' ' << e.cost << endl;\n            if (mp[e.ly][e.lx] == 'T' || mp[e.ry][e.rx] == 'T') {\n                ans = e.cost;\n                break;\n            }\n            if (e.foot) {\n                REP(x, 1, 4) {\n                    REP(y, -3, 4) {\n                        if (x + abs(y) > 3) continue;\n                        int nx = e.lx + x;\n                        int ny = e.ly + y;\n                        if (nx < 0 || ny < 0 || nx >= w || ny >= h || mp[ny][nx] == 'X') continue;\n                        int nc = mp[ny][nx] - '0';\n                        if (mp[ny][nx] == 'T') {\n                            nc = 0;\n                        }\n                        if (Cost[e.lx][e.ly][nx][ny][!e.foot] > e.cost + nc) {\n                            Cost[e.lx][e.ly][nx][ny][!e.foot] = e.cost + nc;\n                            pq.emplace(e.lx, e.ly, nx, ny, !e.foot, Cost[e.lx][e.ly][nx][ny][!e.foot]);\n                        }\n                    }\n                }\n            } else {\n                REP(x, 1, 4) {\n                    REP(y, -3, 4) {\n                        if (x + abs(y) > 3) continue;\n                        int nx = e.rx - x;\n                        int ny = e.ry + y;\n                        if (nx < 0 || ny < 0 || nx >= w || ny >= h || mp[ny][nx] == 'X') continue;\n                        int nc = mp[ny][nx] - '0';\n                        if (mp[ny][nx] == 'T') {\n                            nc = 0;\n                        }\n                        if (Cost[nx][ny][e.rx][e.ry][!e.foot] > e.cost + nc) {\n                            Cost[nx][ny][e.rx][e.ry][!e.foot] = e.cost + nc;\n                            pq.emplace(nx, ny, e.rx, e.ry, !e.foot, Cost[nx][ny][e.rx][e.ry][!e.foot]);\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,1,2,-1,0,1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    vector<P2> G[2][100][50];\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      if(grid[y][x] == 'T'){\n\tq.push(p);\n\tcout << t << endl;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    if(q.empty())cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint xv[]={1,1,1,1,1,2,2,2,3},yv[]={2,1,0,-1,-2,1,0,-1,0};\n\nvoid solve(int w,int h){\n    char in;\n    bool l;\n    int r,c;\n    stack<pair<bool,pair<int,int>>> q;\n    pair<int,int> n;\n    vector<vector<int>> mp=vector<vector<int>>(h+4,vector<int>(w+6,-1));\n    vector<vector<vector<int>>> ma(h+4,vector<vector<int>>(w+6,vector<int>(2,INT_MAX/2)));\n    set<pair<int,int>> sset,tset;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin>>in;\n            if(in=='X')mp[i+1][j+2]=-1;\n            else if(in=='S'){\n                mp[i+1][j+2]=0;\n                sset.insert(make_pair(i+1,j+2));\n            }\n            else if(in=='T'){\n                mp[i+1][j+2]=0;\n                tset.insert(make_pair(i+1,j+2));\n            }\n            else{\n                mp[i+1][j+2]=in-'0';\n            }\n        }\n    }\n    for(pair<int,int> x:sset){\n        q.push(make_pair(true,make_pair(x.first,x.second)));\n        q.push(make_pair(false,make_pair(x.first,x.second)));\n        ma[x.first][x.second][0]=0;\n        ma[x.first][x.second][1]=0;\n    }\n    while(!q.empty()){\n        l=q.top().first;n=q.top().second;q.pop();\n        for(int i=0;i<9;i++){\n            r=n.first+yv[i];\n            c=n.second+(l?xv[i]:-1*xv[i]);\n            if(mp[r][c]!=-1&&ma[n.first][n.second][!l]+mp[r][c]<ma[r][c][l]){\n                ma[r][c][l]=ma[n.first][n.second][!l]+mp[r][c];\n                q.push(make_pair(!l,make_pair(r,c)));\n            }\n        }\n    }\n    int mini=INT_MAX/2;\n    for(pair<int,int> x:tset){\n        mini=min(mini,ma[x.first][x.second][0]);\n        mini=min(mini,ma[x.first][x.second][1]);\n    }\n    cout<<(mini!=INT_MAX/2?mini:-1)<<endl;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        solve(w,h);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef vector<int> vi;\ntypedef tuple<vi, vi, int> Node;\ntypedef pair<Node, int> pii;\n\nstruct Comp {\n\tbool operator() (pii a, pii b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint dx[2][9] = { {1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3} };\nint dy[2][9] = { {-2, -1, 0, 1, 2, -1, 0, 1, 0},{ -2, -1, 0, 1, 2, -1, 0, 1, 0 } };\n\nint solve(int W, int H)\n{\n\tvector< vector<char> > S(H, vector<char>(W));\n\trep(y, 0, H) rep(x, 0, W) cin >> S[y][x];\n\t\n\tpriority_queue<pii, vector<pii>, Comp> que;\n\tmap<Node, int> dist;\n\tset<Node> done;\n\n\tvector< pair<int, int> > starts;\n\trep(x, 0, W) rep(y, 0, H) if (S[y][x] == 'S') starts.push_back( make_pair(x, y) );\n\trep(i, 0, starts.size() - 1) rep(j, i + 1, starts.size())\n\t{\n\t\tpair<int, int> a = starts[i];\n\t\tpair<int, int> b = starts[j];\n\n\t\tint d = abs(a.first - b.first) + abs(a.second - b.second);\n\t\tif (3 < d) continue;\n\t\tif (a.first == b.first) continue;\n\t\tif (b.first < a.first)\n\t\t{\n\t\t\tswap(a, b);\n\t\t}\n\n\t\trep(k, 0, 2)\n\t\t{\n\t\t\tNode node({ a.first, b.first }, { a.second, b.second }, k);\n\t\t\tque.push(pii(node, 0));\n\t\t\tdist[node] = 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tNode n = que.top().first;\n\t\tint c = que.top().second;\n\t\tque.pop();\n\n\t\tif (done.find(n) != done.end()) continue;\n\t\tdone.insert(n);\n\n\t\tvi x = get<0>(n);\n\t\tvi y = get<1>(n);\n\t\tint lr = get<2>(n);\n\n\t\tif (S[y[0]][x[0]] == 'T' || S[y[1]][x[1]] == 'T') return c;\n\n\t\trep(i, 0, 9)\n\t\t{\n\t\t\tint xx = x[lr] + dx[lr][i];\n\t\t\tint yy = y[lr] + dy[lr][i];\n\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (S[yy][xx] == 'X') continue;\n\t\t\tif (S[yy][xx] == 'S') continue;\n\n\t\t\tint next_c = c;\n\t\t\tif (S[yy][xx] != 'T') next_c += S[yy][xx] - '0';\n\n\t\t\tvi next_x(2), next_y(2);\n\t\t\trep(j, 0, 2) next_x[j] = x[j];\n\t\t\trep(j, 0, 2) next_y[j] = y[j];\n\t\t\tint next_lr = (lr + 1) % 2;\n\t\t\tnext_x[next_lr] = xx;\n\t\t\tnext_y[next_lr] = yy;\n\t\t\tNode next_n(next_x, next_y, next_lr);\n\t\t\t\n\t\t\tif (dist.find(next_n) == dist.end()) dist[next_n] = INF;\n\t\t\tif (next_c < dist[next_n])\n\t\t\t{\n\t\t\t\tdist[next_n] = next_c;\n\t\t\t\tque.push(pii(next_n, next_c));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0) return 0;\n\n\t\tcout << solve(W, H) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint dx[]={1,1,1,1,1,2,2,2,3};\nint dy[]={-2,-1,0,1,2,-1,0,1,0};\n\nclass State\n{\npublic:\n\tint lx,ly,rx,ry,c,f;\n\tState(int lx, int ly, int rx, int ry, int c, int f)\n\t\t:lx(lx),ly(ly),rx(rx),ry(ry),c(c),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c>s.c;\n\t}\n};\n\nbool v[30][60][2];\n\nint main()\n{\n\tint W,H;\n\tchar f[80][80];\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tmemset(v,0,sizeof(v));\n\n\t\tpriority_queue<State> q;\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='S')\n\t\t\t{\n\t\t\t\tfor(int k=0; k<2; k++)\n\t\t\t\t\tq.push(State(j,i,j,i,0,k));\n\t\t\t}\n\t\t}\n\n\t\tbool g=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.top(); q.pop();\n\t\t\tif(f[s.lx][s.ly]=='T' || f[s.rx][s.ry]=='T')\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t\tcout << s.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(s.f==0)\n\t\t\t{\n\t\t\t\tif(v[s.rx][s.ry][s.f]) continue;\n\t\t\t\tv[s.rx][s.ry][s.f]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(v[s.lx][s.ly][s.f]) continue;\n\t\t\t\tv[s.lx][s.ly][s.f]=1;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<9; i++)\n\t\t\t{\n\t\t\t\tif(s.f==0)\n\t\t\t\t{\n\t\t\t\t\tint tlx=s.rx-dx[i], tly=s.ry+dy[i];\n\t\t\t\t\tint tf=(s.f+1)%2;\n\t\t\t\t\tif(tlx<0||tly<0||tlx>=W||tly>=H) continue;\n\t\t\t\t\tif(f[tlx][tly]=='X') continue;\n\t\t\t\t\tif(v[tlx][tly][tf]) continue;\n\n\t\t\t\t\tint tc=s.c;\n\t\t\t\t\tif(isdigit(f[tlx][tly])) tc+=f[tlx][tly]-'0';\n\n\t\t\t\t\tq.push(State(tlx,tly,s.rx,s.ry,tc,tf));\n\t\t\t\t}\n\t\t\t\tif(s.f==1)\n\t\t\t\t{\n\t\t\t\t\tint tlx=s.lx+dx[i], tly=s.ly+dy[i];\n\t\t\t\t\tint tf=(s.f+1)%2;\n\t\t\t\t\tif(tlx<0||tly<0||tlx>=W||tly>=H) continue;\n\t\t\t\t\tif(f[tlx][tly]=='X') continue;\n\t\t\t\t\tif(v[tlx][tly][tf]) continue;\n\n\t\t\t\t\tint tc=s.c;\n\t\t\t\t\tif(isdigit(f[tlx][tly])) tc+=f[tlx][tly]-'0';\n\n\t\t\t\t\tq.push(State(s.rx,s.ry,tlx,tly,tc,tf));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(!g) cout << -1 << endl;\n\t\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint txr[] = {1,1,1,1,1,2,2,2,3};\nint tyr[] = {-2,-1,0,1,2,-1,0,1,0};\n\n\nint txl[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint tyl[] = {-2,-1,0,1,2,-1,0,1,0};\n\nchar stage[60][30];\nint cost[1800][1800];\n\nint w,h;\nvoid dfs(int lhs,int rhs,int turn,int c){\n\n\tint srx = rhs % w;\n\tint sry = rhs / w;\n\n\tint slx = lhs % w;\n\tint sly = lhs / w;\n\n\t//turn:0 moving right leg\n\tif(turn==0){\n\t\tfor(int i=0;i<9;i++){\n\t\t\tint dx = txr[i] + slx;\n\t\t\tint dy = tyr[i] + sly;\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(slx>=dx) continue;\n\t\t\tif(abs(dx - slx) + abs(dy - sly) > 3) continue;\n\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\tcost[lhs][dy*w+dx] = min(cost[lhs][dy*w+dx],c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(cost[lhs][dy*w+dx] <= c + stage[dy][dx]-'0') continue;\n\t\t\tcost[lhs][dy*w+dx] = c + stage[dy][dx]-'0';\n\t\t\tdfs(lhs,dy*w+dx,1,c + stage[dy][dx]-'0');\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<9;i++){\n\t\t\tint dx = txl[i] + srx;\n\t\t\tint dy = tyl[i] + sry;\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(dx>=srx) continue;\n\t\t\tif(abs(dx - srx) + abs(dy - sry) > 3) continue;\n\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\tcost[dy*w+dx][rhs] = min(cost[dy*w+dx][rhs],c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(cost[dy*w+dx][rhs] <= c + stage[dy][dx]-'0') continue;\n\t\t\tcost[dy*w+dx][rhs] = c + stage[dy][dx]-'0';\n\t\t\tdfs(dy*w+dx,rhs,0,c + stage[dy][dx]-'0');\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tmemset(cost,0x3f,sizeof(cost));\n\t\tvector<P> S;\n\t\tvector<P> T;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%s\",&stage[y][x]);\n\t\t\t\tif(stage[y][x]=='S') S.push_back(P(x,y));\n\t\t\t\tif(stage[y][x]=='T') T.push_back(P(x,y));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<S.size();i++){\n\t\t\tint x = S[i].first;\n\t\t\tint y = S[i].second;\n\t\t\tdfs(y*w+x,y*w+x,0,0);\n\t\t\tdfs(y*w+x,y*w+x,1,0);\n\t\t}\n\n\t\tint res = numeric_limits<int>::max();\n\t\tfor(int lhs=0;lhs < 1800; lhs++){\n\t\t\tfor(int rhs=0; rhs < 1800; rhs++){\n\t\t\t\tint srx = rhs % w;\n\t\t\t\tint sry = rhs / w;\n\n\t\t\t\tint slx = lhs % w;\n\t\t\t\tint sly = lhs / w;\n\n\t\t\t\tif(srx < 0 || srx >= w || sry < 0 || sry >= h) continue;\n\t\t\t\tif(slx < 0 || slx >= w || sly < 0 || sly >= h) continue;\n\n\t\t\t\tif(stage[sry][srx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t\tif(stage[sly][slx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res >= 0x3f3f3f3f ? -1 : res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\nusing namespace std;\n#define INF (1<<28)\ntypedef pair<int,int> P;\nstruct state{\n  int ay,ax,by,bx,f,cost;\n  bool operator < (const state &p)const{return cost>p.cost;}\n};\nint W,H;\nint t[60][30];\nvector<P> A,B;\n\nvoid init(){\n  A.clear();B.clear();\n}\n\nint dist(int a,int b,int c,int d){return abs(a-c)+abs(b-d);}\nint d[60][30][60][30][2];\nint solve(){\n  fill((int*)d,(int*)(d+60),INF);\n  sort(A.begin(),A.end());\n  sort(B.begin(),B.end());\n  state s;\n  priority_queue<state> Q;\n  for(int i=0;i<(int)A.size();i++){\n    s.ay=A[i].second;\n    s.ax=A[i].first;\n    s.by=A[i].second;\n    s.bx=A[i].first;\n    s.cost=0;\n    for(int j=0;j<2;j++){\n      s.f=j;\n      d[s.ay][s.ax][s.by][s.bx][s.f]=0;\n      Q.push(s);\n    }\n  }\n  while(!Q.empty()){\n    s=Q.top();Q.pop();\n    if(s.cost>d[s.ay][s.ax][s.by][s.bx][s.f])continue;\n    if(t[s.ay][s.ax]==0||t[s.by][s.bx]==0)return s.cost;\n    \n    for(int i=-4;i<=4;i++){\n      for(int j=-4;j<=4;j++){\n\tstate w=s;\n\tint ny,nx;\n\tif(s.f)ny=w.ay+i,nx=w.ax+j;\n\telse   ny=w.by+i,nx=w.bx+j;\n\tif(ny<0||nx<0)continue;\n\tif(ny>=H||nx>=W)continue;\n\tif(s.f)w.ay=ny,w.ax=nx;\n\telse   w.by=ny,w.bx=nx;\n\tw.f=1-s.f;\n\tw.cost=s.cost+t[ny][nx];\n\tif(w.bx>=w.ax)continue;\n\tif(dist(w.ay,w.ax,w.by,w.bx)>3)continue;\n\tif(w.cost>d[w.ay][w.ax][w.by][w.bx][w.f])continue;\n\td[w.ay][w.ax][w.by][w.bx][w.f]=w.cost;\n\tQ.push(w);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    init();\n    char ch;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>ch;\n\tt[i][j]=INF;\n        if(ch=='S')A.push_back(P(j,i));\n\telse if(ch=='T')t[i][j]=0;\n\telse if('0'<=ch&&ch<='9')t[i][j]=ch-'0';\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[61][31];\nint used[2][61][31][61][31]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c; // ???????????§???????????????????¨???¶\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false; // ??????????¨???????\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c; // ?????£????????¨?????????\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true; // ?£????\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true; // ?£????\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; //????£???????\n\t  if(board[s.r.sc][s.r.fs] < 0) return true; //??????????£?\n\t  if(board[s.l.sc][s.l.fs] < 0) return true; //??????????£?\n\t  return false; // ??§??????\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true; // ????¶??????´??????\n\t  if(g.find(s.r) != g.end()) return true; // ????¶??????´??????\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost = 0 ;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  if(is_used(ns)) continue;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  foot dummy = foot(INF,INF);\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(s[i],foot(s[i].fs+dx[i], s[i].sc-dy[i]),0,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs+dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st0 = state(s[i], dummy, 0, 0);\n\t\t\t\t  int tmp0 = dijk(st0);\n\t\t\t\t  if(tmp0 != -1)\n\t\t\t\t\t\tans = min(ans, tmp0);\n\n\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(foot(s[i].fs-dx[i], s[i].sc-dy[i]), s[i], 1,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs-dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st1 = state(dummy, s[i], 1, 0);\n\t\t\t\t  int tmp1 = dijk(st1);\n\t\t\t\t  if(tmp1 != -1)\n\t\t\t\t\t\tans = min(ans, tmp1);\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Node{\n    int x, y, cost, pos;\n    bool nxt;//?¬????????¶???????true, ????¶???????false\n    Node(int x, int y, int c, int p, bool n)\n         : x(x), y(y), cost(c), pos(p), nxt(n){}\n    bool operator> (const Node& N) const{\n        return cost > N.cost;\n    }\n};\nint W, H;\nchar fld[61][31];\nint dist[61][31][9][2];//????¶????????????¨?????????????????????????¶????????????¨?¬??????????????¶?\nconst int dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1}, dy[9] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int dx2[9] = {-1, -1, -2, -1, -2, -3, -1, -2, -1}, dy2[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nbool cant_go(int cx, int cy){\n    return cx < 0 || cy < 0 || W <= cx || H <= cy || fld[cy][cx] == 'X';\n}\ntypedef pair<int, int> pint;\nint solve(){\n    rep(i, 61) rep(j, 31) rep(k, 9) rep(l, 2) dist[i][j][k][l] = INF;\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    vector<int> goal;\n    rep(i, W) if(fld[0][i] == 'T'){\n        goal.push_back(i);\n        fld[0][i] = '0';\n    }\n    rep(i, W) if(fld[H - 1][i] == 'S'){\n        if(i != 0){//????¶??????????\n            que.push(Node(i - 1, H, 0, 1, false));\n            dist[H][i - 1][1][0] = 0;\n        }\n        if(i != W - 1){//????¶??????????\n            que.push(Node(i, H - 1, 0, 6, true));\n            dist[H - 1][i][6][1] = 0;\n        }\n        fld[H - 1][i] = '0';\n    }\n    while(!que.empty()){\n        Node cr = que.top(); que.pop();\n        if(dist[cr.y][cr.x][cr.pos][cr.nxt] < cr.cost) continue;\n        if(cr.nxt){\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int rx = cr.x + dx[i], ry = cr.y + dy[i];\n                if(cant_go(rx, ry)) continue;\n                int ncos = fld[ry][rx] - '0';\n                if(dist[cr.y][cr.x][i][0] > dist[cr.y][cr.x][cr.pos][1] + ncos){\n                    dist[cr.y][cr.x][i][0] = dist[cr.y][cr.x][cr.pos][1] + ncos;\n                    que.push(Node(cr.x, cr.y, dist[cr.y][cr.x][i][0], i, false));\n                    //cout << \"right:\" << cr.x << ' ' << cr.y << ' ' << rx << ' ' << ry << ' '<<dist[cr.y][cr.x][i][0] << endl;\n                }\n            }\n        }else{\n            int rx = cr.x + dx[cr.pos], ry = cr.y + dy[cr.pos];\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int lx = rx + dx2[i], ly = ry + dy2[i];\n                if(cant_go(lx, ly)) continue;\n                int ncos = fld[ly][lx] - '0';\n                if(dist[ly][lx][i][1] > dist[cr.y][cr.x][cr.pos][0] + ncos){\n                    dist[ly][lx][i][1] = dist[cr.y][cr.x][cr.pos][0] + ncos;\n                    que.push(Node(lx, ly, dist[ly][lx][i][1], i, true));\n                    //cout << \"left:\" << lx << ' ' << ly << ' ' << rx << ' ' << ry << ' ' <<dist[ly][lx][i][1] << endl;\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for(int k : goal){\n        rep(i, 9) rep(j, 2) ans = min(ans, dist[0][k][i][j]);\n        for(int i = 8; i >= 0; --i){\n            int gx = k - dx[i], gy = 0 + dy[i];\n            if(cant_go(gx, gy)) continue;\n            rep(j, 2) ans = min(ans, dist[gy][gx][i][j]);\n        }\n    }\n    return ans == INF ? -1 : ans;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H && W){\n        rep(i, H) rep(j, W) cin >> fld[i][j];\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint s_l, s_r, t_l, t_r;\nint d[30][60][2];\n//dijkstra\nint dijkstra(vector<vector<int>>&cost,State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = t_l; i <= t_r; i++) {\n\t\tint d_min = min(d[i][0][0], d[i][0][1]);\n\t\tres = min(res, d_min);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\t//input\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (s_flag == 0) {\n\t\t\t\t\t\ts_l = j; s_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\ts_r = j;\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (t_flag == 0) {\n\t\t\t\t\t\tt_l = j; t_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\tt_r = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = min(dijkstra(cliff, State(0, s_l, h - 1, 1)), dijkstra(cliff, State(0, s_l, h - 1, -1)));\n\t\tint ans1 = min(dijkstra(cliff, State(0, s_r, h - 1, 1)), dijkstra(cliff, State(0, s_r, h - 1, -1)));\n\t\tans = min(ans, ans1);\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector <vector<int>>;\nusing vvll = vector <vector<ll>>;\n\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-9;\n\ntemplate<class T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<class T>\nvector<T> dijkstra(const vector<vector<edge<T>>>& g, int s) {\n    const T INF = inf(T);\n    vector<T> d(g.size(), INF);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    d[s] = 0;\n    que.emplace(d[s], s);\n    while (!que.empty()) {\n        T cost; int v;\n        tie(cost, v) = que.top();\n        que.pop();\n        if (d[v] < cost) continue;\n        for (const auto &e : g[v]) {\n            T nxt = cost + e.cost;\n            if (d[e.to] > nxt) {\n                d[e.to] = nxt;\n                que.emplace(nxt, e.to);\n            }\n        }\n    }\n    return d;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int w, h; cin >> w >> h;\n        if (w == 0) break;\n\n        vector<vector<char>> s(h, vector<char>(w));\n        REP(i, h) REP(j, w) {\n            cin >> s[i][j];\n        }\n\n        vector<vector<edge<int>>> G(h*w*2 + 1);\n        REP(i, h) REP(j, w) {\n            for (int di = -3; di <= 3; ++di) {\n                for (int dj = -3; dj < 0; ++dj) {\n                    if (abs(di) + abs(dj) > 3) continue;\n                    int y = i + di, x = j + dj;\n                    if (y < 0 or x < 0 or h <= y or w <= x) continue;\n                    if (s[y][x] == 'X' or s[y][x] == 'S') continue;\n                    int cost = s[y][x] == 'T' ? 0 : s[y][x] - '0';\n                    G[i*w + j].emplace_back(h*w + y*w + x, cost);\n                }\n            }\n            for (int di = -3; di <= 3; ++di) {\n                for (int dj = 1; dj <= 3; ++dj) {\n                    if (abs(di) + abs(dj) > 3) continue;\n                    int y = i + di, x = j + dj;\n                    if (y < 0 or x < 0 or h <= y or w <= x) continue;\n                    if (s[y][x] == 'X' or s[y][x] == 'S') continue;\n                    int cost = s[y][x] == 'T' ? 0 : s[y][x] - '0';\n                    G[h*w + i*w + j].emplace_back(y*w + x, cost);\n                }\n            }\n        }\n\n        REP(i, h) REP(j, w) {\n            if (s[i][j] == 'S') {\n                G[2*h*w].emplace_back(i*w + j, 0);\n                G[2*h*w].emplace_back(h*w + i*w + j, 0);\n            }\n        }\n\n        auto dist = dijkstra(G, 2*h*w);\n\n        int ans = inf(int);\n        REP(i, h) REP(j, w) {\n            if (s[i][j] != 'T') continue;\n            chmin(ans, dist[i*w + j]);\n            chmin(ans, dist[h*w + i*w + j]);\n        }\n\n        if (ans == inf(int)) ans = -1;\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n#define inf 101010\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pp;\n\nint w,h;\nint g[61][31];\nvector<pii> st;\nvector<pii> gl;\npriority_queue<pp, vector<pp>, greater<pp> > que;\nvector<vector<vector<int> > > d;\n\nbool r(int y, int x) {\n    if (y >= 0 && y < h && x >= 0 && x < w) return true;\n    else return false;\n}\n\nvoid solve() {\n    int ans = inf;\n    while (!que.empty()) {\n        pp p = que.top(); que.pop();\n        int cost = p.first.first, foot = p.first.second;\n        int ty = p.second.first, tx = p.second.second;\n        if (g[ty][tx] == 10) {\n            ans = cost-10;\n            break;\n        }\n        \n        for (int i = 1; i < 4; i++) {\n            for (int j = -3+i; j < 4-i; j++) {\n                int t = i * (1 - 2*foot); // 0 then +1, 1 then -1 so foot 0 is left, foot 1 is right\n                int ny = ty+j, nx = tx+t;\n                int co = g[ny][nx];\n                if (!r(ny,nx) || g[ny][nx] == -1) continue;\n                \n                if (d[1-foot][ny][nx] > cost + co) {\n                    d[1-foot][ny][nx] = cost+co;\n                    que.push(mp(mp(cost+co, 1-foot), mp(ny, nx)));\n                }\n            }\n        }\n    }\n    if (ans == inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\n\nint main(void){\n    while (cin>>w>>h && w) {\n        st.clear();\n        gl.clear();\n        priority_queue<pp, vector<pp>, greater<pp> > que2;\n        que = que2;\n        vector<vector<vector<int> > > d2(2, vector<vector<int> >(h+1, vector<int>(w+1, inf)));\n        d = d2;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == 'S') {\n                    g[i][j] = -1;\n                    que.push(mp(mp(0, 0), mp(i, j)));\n                    que.push(mp(mp(0, 1), mp(i, j)));\n                    d[0][i][j] = 0;\n                    d[1][i][j] = 0;\n                }\n                else if (c == 'T') g[i][j] = 10;\n                else if (c == 'X') g[i][j] = -1;\n                else g[i][j] = c-'0';\n            }\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n\nconstexpr int CANT_GO = 114514;\n\nint field[60][30] = {0};\nint dp[2][60][30][5][3] = { 0 }; //[?¬???????][??????y][x][?????????y][x] = cost\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nstruct Node {\n\tint x, y; \n\tint rx, ry; //????¶???????????????????\n\tint cost;\n\tbool nextR; //?¬?????????????????????????true\n\tbool operator>(const Node& rhs) const {\n\t\tif (cost == rhs.cost) return y > rhs.y;\n\t\treturn cost > rhs.cost;\n\t}\n};\nint main() {\n\tint w, h;\n\twhile (std::cin >> w >> h && (w || h)) {\n\t\tstd::memset(dp, 0x7f, sizeof(int) * 2 * 60 * 30 * 5 * 3);\n\t\tstd::vector<int> startList;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; std::cin >> c;\n\t\t\t\tif ('0' <= c && c <= '9') field[i][j] = c - '0';\n\t\t\t\telse if(c == 'X') field[i][j] = CANT_GO;\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tstartList.push_back(j);\n\t\t\t\t}\n\t\t\t\telse if (c == 'T') field[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tstd::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n\t\tbool isOk = false;\n\t\t//??¨start???????????????\n\t\tfor (int i = 0; i < startList.size(); i++) {\n\t\t\tq.push({ startList[i], h - 1, 1, 0, 0, true }); //??????????????????\n\t\t\tq.push({ startList[i] - 1, h - 1, 1, 0, 0, false }); //??????????????????\n\t\t}\n\t\tint minCost = 0;\n\t\twhile (!q.empty() && !isOk) {\n\t\t\tauto node = q.top(); q.pop();\n\t\t\tif ((field[node.y][node.x] == 0 && node.y == 0) || (field[node.y + node.ry][node.x + node.rx] == 0 && node.y + node.ry == 0)) {\n\t\t\t\tisOk = true;\n\t\t\t\tminCost = node.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tif (node.nextR) {\n\t\t\t\t\tnext.rx = dx[i]; //?????´????????????????????????OK?????????????????????????§????\n\t\t\t\t\tnext.ry = dy[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint rx = node.x + node.rx; //????¶???§?¨?\n\t\t\t\t\tint ry = node.y + node.ry;\n\t\t\t\t\tnext.x = rx - dx[i]; //????¶???????????????????????????§?¨?\n\t\t\t\t\tnext.y = ry + dy[i];\n\t\t\t\t\tnext.rx = rx - next.x;//????????§?¨??????????\n\t\t\t\t\tnext.ry = ry - next.y;\n\t\t\t\t}\n\t\t\t\tnext.nextR = !node.nextR;\n\t\t\t\t//check\n\t\t\t\tif (next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\tif (next.x + next.rx < 0 || next.x + next.rx >= w || next.y + next.ry < 0 || next.y + next.ry >= h) continue;\n\t\t\t\tif (!next.rx) continue;\n\n\t\t\t\tint cost;\n\t\t\t\tif (node.nextR) {\n\t\t\t\t\tcost = field[next.y + next.ry][next.x + next.rx];\n\t\t\t\t}\n\t\t\t\telse cost = field[next.y][next.x];\n\n\t\t\t\tif (cost < 0 || 9 < cost) continue; //X?????¨???\n\n\t\t\t\tnext.cost += cost;\n\t\t\t\tif (dp[next.nextR][next.y][next.x][next.ry + 2][next.rx - 1] <= next.cost) continue;\n\t\t\t\tdp[next.nextR][next.y][next.x][next.ry + 2][next.rx - 1] = next.cost;\n\t\t\t\t//std::cout << next.x << \", \" << next.y << \", \" << next.x + next.rx << \", \" << next.y + next.ry << \", \" << next.cost << \", \" << next.nextR << std::endl;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tif (isOk) std::cout << minCost << std::endl;\n\t\telse std::cout << -1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-8;\nint INF=1e9;\nint txr[] = {1,1,1,1,1,2,2,2,3};\nint tyr[] = {-2,-1,0,1,2,-1,0,1,0};\nint txl[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint tyl[] = {-2,-1,0,1,2,-1,0,1,0};\nchar stage[60][30];\nint cost[1800][1800];\nint d[60][30][2];\nstruct dat{\npublic:\n    int cost;\n    int rhs;\n    int lhs;\n    bool turn;\n    dat(){}\n    dat(int cost,int lhs,int rhs,bool turn):cost(cost),lhs(lhs),rhs(rhs),turn(turn){\n    }\n\n    bool operator>(const dat& d) const{\n        return cost > d.cost;\n    }\n};\nint main(){\n    int w,h;\n    while(scanf(\"%d %d\",&w,&h)&&(w||h)){\n\t  REP(i,1800)REP(j,1800)cost[i][j]=INF;\n        vector<P> S;\n        vector<P> T;\n        for(int y=0;y<h;y++){\n            for(int x=0;x<w;x++){\n                scanf(\"%s\",&stage[y][x]);\n                if(stage[y][x]=='S') S.push_back(P(x,y));\n                if(stage[y][x]=='T') T.push_back(P(x,y));\n            }\n        }\n        priority_queue<dat,vector<dat>,greater<dat> > que;\n        for(int i=0;i<S.size();i++){\n            int x = S[i].first;\n            int y = S[i].second;\n            que.push(dat(0,y*w+x,y*w+x,false));\n            que.push(dat(0,y*w+x,y*w+x,true));\n        }\n        int res = INF;\n        while(!que.empty()){\n            dat d = que.top();\n            int srx = d.rhs % w;\n            int sry = d.rhs / w;\n            int slx = d.lhs % w;\n            int sly = d.lhs / w;\n            que.pop();\n            if(d.cost >= res) continue;\n            if(d.turn){\n                for(int i=0;i<9;i++){\n                    int dx = txl[i] + srx;\n                    int dy = tyl[i] + sry;\n                    if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                    if(dx>=srx) continue;\n                    if(abs(dx - srx) + abs(dy - sry) > 3) continue;\n                    if(stage[dy][dx] == 'X') continue;\n                    if(stage[dy][dx] == 'T'){\n                        res = cost[dy*w+dx][d.rhs] = min(cost[dy*w+dx][d.rhs],d.cost);\n                        continue;\n                    }\n                    if(cost[dy*w+dx][d.rhs] <= d.cost + stage[dy][dx]-'0') continue;\n                    cost[dy*w+dx][d.rhs] = d.cost + stage[dy][dx]-'0';\n                    que.push(dat(d.cost + stage[dy][dx]-'0',dy*w+dx,d.rhs,false));\n                }\n            }\n            else{\n                for(int i=0;i<9;i++){\n                    int dx = txr[i] + slx;\n                    int dy = tyr[i] + sly;\n                    if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                    if(slx>=dx) continue;\n                    if(abs(dx - slx) + abs(dy - sly) > 3) continue;\n                    if(stage[dy][dx] == 'X') continue;\n                    if(stage[dy][dx] == 'T'){\n                        res = cost[d.lhs][dy*w+dx] = min(cost[d.lhs][dy*w+dx],d.cost);\n                        continue;\n                    }\n                    if(cost[d.lhs][dy*w+dx] <= d.cost + stage[dy][dx]-'0') continue;\n                    cost[d.lhs][dy*w+dx] = d.cost + stage[dy][dx]-'0';\n                    que.push(dat(d.cost + stage[dy][dx]-'0',d.lhs,dy*w+dx,true));\n                }\n            }\n        }\n        printf(\"%d\\n\",res >= INF ? -1 : res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define LEFT 0\n#define RIGHT 1\n#define INF 0x60000000\n\ntypedef pair<int, int> Coor;\ntypedef pair<int, Coor> Data;\ntypedef pair<int, Data> Pair;\n\nint w;\nint h;\nint ans;\nbool is_goal[60][30];\nint cost[60][30];\nint lmin[60][30];\nint rmin[60][30];\n\nint main() {\n    while (1) {\n        priority_queue<Pair> q;\n\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0) return 0;\n\n        ans = INF;\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                lmin[i][j] = INF;\n                rmin[i][j] = INF;\n            }\n        }\n\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                char c;\n\n                is_goal[i][j] = false;\n                scanf(\" %c\", &c);\n                if (c == 'X') {\n                    cost[i][j] = INF;\n                } else if (c == 'S') {\n                    cost[i][j] = 0;\n                    lmin[i][j] = 0;\n                    rmin[i][j] = 0;\n                    q.push(Pair(0, Data(LEFT, Coor(j, i))));\n                    q.push(Pair(0, Data(RIGHT, Coor(j, i))));\n                } else if (c == 'T') {\n                    cost[i][j] = 0;\n                    is_goal[i][j] = true;\n                } else {\n                    cost[i][j] = c - '0';\n                    assert(1 <= cost[i][j] && cost[i][j] <= 9);\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            Pair p = q.top(); q.pop();\n            int dist = p.first;\n            Data d = p.second;\n            int last = d.first;\n            Coor c = d.second;\n            int x = c.first;\n            int y = c.second;\n\n            if (last ==  LEFT && dist > lmin[y][x]) continue;\n            if (last == RIGHT && dist > rmin[y][x]) continue;\n\n            if (last == LEFT) {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x + 3-i;\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n\n                        if (rmin[_y][_x] > dist + cost[_y][_x]) {\n                            rmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, rmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(rmin[_y][_x], Data(RIGHT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            } else {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x - (3-i);\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n\n                        if (lmin[_y][_x] > dist + cost[_y][_x]) {\n                            lmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, lmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(lmin[_y][_x], Data(LEFT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (ans < INF) {\n            printf(\"%d\\n\", ans);\n        } else {\n            puts(\"-1\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// start: 21:57\n// AC: 00:12\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n#define INF INT_MAX\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\nvoid dump(vector< vector<char> > &f, int x = -1, int y = -1, int l = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == y && j == x ) {\n                if ( l == 0 )\n                    cout << \"R\";\n                else\n                    cout << \"L\";\n            }\n            else\n                cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nclass Climb {\npublic:\n    int cost;\n    int leg;\n    xy foot;\n    Climb(xy f, int l, int c): foot(f), leg(l), cost(c){}\n};\n\nbool operator< (const Climb& cl1, const Climb &cl2) {\n    return cl1.cost > cl2.cost;\n}\nbool operator> (const Climb& cl1, const Climb &cl2) {\n    return cl1.cost < cl2.cost;\n}\n\n// 左足のときに置ける右足\nint mx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    my[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        priority_queue< Climb, vector<Climb>, less<vector<Climb>::value_type> > pq;\n\n        int closed[h][w][2];\n        // vector< queue<xy> > foot(2);   // 0:右 1:左\n        // queue<int> cost, leg;\n        vector< vector<char> > f(h);\n        vector< xy > start;\n\n        REP(i, h) REP(j, w) REP(k, 2) closed[i][j][k] = 0;\n\n        REP(i, h) {\n            REP(j, w) {\n                char tmp;\n                cin >> tmp;\n                f[i].push_back(tmp);\n                if ( f[i][j] == 'S' ) {\n                    start.push_back( make_pair(j, i) );\n                }\n            }\n        }\n\n        // スタート地点＋左右を初期値としてpush\n        REP(i, start.size()) {\n            // 0:右, 1:左\n            pq.push( Climb( make_pair(start[i].first, start[i].second), 0, 0) );\n            pq.push( Climb( make_pair(start[i].first, start[i].second), 1, 0) );\n        }\n\n        int min = INF;\n        while(!pq.empty()) {\n            Climb climb = pq.top(); pq.pop();\n\n            int c = climb.cost;\n            int l = climb.leg;\n\n            xy ft = climb.foot;\n            int x = ft.first;\n            int y = ft.second;\n\n            // printf(\"f:%d, x:%d, y:%d, xy:%c\\n\", l, x, y, f[y][x]);\n            // dump(f, x, y, l);\n            if ( f[y][x] == 'T' ) {\n                min = c;\n                break;\n            }\n\n            REP(i, 9) {\n                int dir = l == 0 ? -1: 1,\n                    nx = x + mx[i] * dir,\n                    ny = y + my[i],\n                    nl = !l;\n\n                if ( !(0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n                if ( f[ny][nx] == 'X' || f[ny][nx] == 'S' ) continue;   // バグ出るかも\n\n                int nc;\n                if ( ((int)f[ny][nx] - 48) > 9 )\n                    nc = c + 1;\n                else\n                    nc = c + ((int)f[ny][nx] - 48);\n\n                if ( closed[ny][nx][nl] != 0 && closed[ny][nx][nl] < nc ) continue;\n\n                pq.push( Climb( make_pair(nx, ny), nl, nc) );\n                closed[ny][nx][nl] = nc;\n\n            }\n        }\n\n        if ( min == INF )\n            cout << -1 << endl;\n        else\n            cout << (min-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint w, h;\nchar s[100][100];\n\nstruct edge {\n\tint to;\n\tll cost;\n};\n\nll dx[2][10] = { { 1,1,1, 1, 1,2,2, 2,3 },{ -1,-1,-1,-1,-1,-2,-2,-2,-3 } };\nll dy[2][10] = { { 2,1,0,-1,-2,1,0,-1,0 },{  2, 1, 0,-1,-2, 1, 0,-1, 0 } };\nll d[2][100][100];\nvector<edge> G[100010];//各頂点からの辺\n\nvoid dijkstra(P start, bool _t) {\n\trep(i, 100)rep(j, 100) {\n\t\td[0][i][j] = INF;\n\t\td[1][i][j] = INF;\n\t}\n\td[_t][start.first][start.second] = 0;\n\n\ttypedef pair<P, P> PP;\n\n\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push({ { 0,_t },start });\n\n\twhile (que.size()) {\n\t\tPP p = que.top();\n\t\tque.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint t = p.first.second;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tint ny = y + dy[t][i];\n\t\t\tint nx = x + dx[t][i];\n\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n\t\t\tif (s[ny][nx] == 'X')continue;\n\t\t\tif (d[!t][ny][nx] > d[t][y][x] + s[ny][nx] - '0') {\n\t\t\t\td[!t][ny][nx] = d[t][y][x] + s[ny][nx] - '0';\n\t\t\t\tque.push({ { d[!t][ny][nx],!t}, P(ny,nx) });\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<P> S, T;\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tS.clear();\n\t\tT.clear();\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tS.push_back(P(i, j));\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'T') {\n\t\t\t\t\tT.push_back(P(i, j));\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, S.size()) {\n\t\t\tdijkstra(S[i], 0);\n\t\t\trep(j, T.size()) {\n\t\t\t\tans = min(ans, d[0][T[j].first][T[j].second]);\n\t\t\t\tans = min(ans, d[1][T[j].first][T[j].second]);\n\t\t\t}\n\t\t\tdijkstra(S[i], 1);\n\t\t\trep(j, T.size()) {\n\t\t\t\tans = min(ans, d[0][T[j].first][T[j].second]);\n\t\t\t\tans = min(ans, d[1][T[j].first][T[j].second]);\n\t\t\t}\n\t\t}\n\t\tif (ans == INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXH = 60;\nconst int MAXW = 30;\nconst int dx[13] = {0,0,0,0,0,   1,1,1,  -1,-1,-1, 2, -2};\nconst int dy[13] = {2,1,0,-1,-2, 1,0,-1, 1,0,-1,   0, 0};\n\nint w, h;\nchar s[MAXH][MAXW];\n\nstruct State {\n  int lx, ly, rx, ry, f, cost;\n\n  bool operator < (const State &s) const {\n    if(lx != s.lx) return lx < s.lx;\n    if(ly != s.ly) return ly < s.ly;\n    if(rx != s.rx) return rx < s.rx;\n    if(ry != s.ry) return ry < s.ry;\n    if(f != s.f) return f < s.f;\n    return false;\n  }\n\n  bool ok() const {\n    return lx < rx && abs(lx-rx) + abs(ly-ry) <= 3;\n  }\n};\n\nstruct GT {\n  bool operator () (const State &a, const State &b) const {\n    return a.cost > b.cost;\n  }\n};\n\nint main() {\n  while(cin >> w >> h && (w|h)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    try {\n      map<State, int> cost;\n      priority_queue<State, vector<State>, GT> que;\n      for(int x = 0; x < w; ++x) {\n        for(int y = 0; y < h; ++y) {\n          if(s[y][x] != 'S') continue;\n          State src = {x, y, x, y, 0, 0};\n          src.f = 0;\n          cost[src] = 0;\n          que.push(src);\n          src.f = 1;\n          cost[src] = 0;\n          que.push(src);\n        }\n      }\n      while(que.size()) {\n        const State a = que.top();\n        que.pop();\n        if(cost.count(a) && a.cost > cost[a]) continue;\n        for(int k = 0; k < 13; ++k) {\n          State b;\n          int x, y;\n          if(a.f) {\n            b = (State){a.lx+dx[k], a.ly+dy[k], a.rx, a.ry, !a.f, a.cost};\n            x = b.lx, y = b.ly;\n          } else {\n            b = (State){a.lx, a.ly, a.rx+dx[k], a.ry+dy[k], !a.f, a.cost};\n            x = b.rx, y = b.ry;\n          }\n          if(!b.ok()) continue;\n          if(s[y][x] == 'X') continue;\n          if(s[y][x] == 'T') throw a.cost;\n          if(s[y][x] != 'S') b.cost += s[y][x] - '0';\n          if(cost.count(b) && b.cost >= cost[b]) continue;\n          cost[b] = b.cost;\n          que.push(b);\n        }\n      }\n      throw -1;\n    } catch(int res) {\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int dy[16] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\nconst int dx[16] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\n\nmap<char, vvi> cost;\n\nchar m[31][61];\nint w, h;\n\nstruct Data{\n    char ft;\n    int y, x;\n};\n\nvoid dfs(Data s){\n\n    queue<Data> q;\n    q.push(s);\n\n    while(not q.empty()){\n       // cout << endl;\n       // rep(i,h){ rep(j,w){ cout << cost['R'][i][j] << ' ' ; } cout << endl; }\n       // cout << endl;\n       // rep(i,h){ rep(j,w){ cout << cost['L'][i][j] << ' ' ; } cout << endl; }\n       // cout << endl;\n        struct Data u = q.front(); q.pop();\n        char nft = (u.ft == 'L' ? 'R' : 'L');\n        rep(i,9){\n            int ny = u.y + dy[i];\n            int nx = u.x + dx[i] * (nft == 'R' ? 1 : -1);\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n            if(m[ny][nx] == 'X' || m[ny][nx] == 'S') continue;\n            if(m[ny][nx] == 'T'){\n                    //show(cost[u.ft][u.y][u.x])\n                cost[nft][ny][nx] = min(cost[nft][ny][nx], cost[u.ft][u.y][u.x]);\n                continue;\n            }\n            if(cost[u.ft][u.y][u.x] + (m[ny][nx] - '0') < cost[nft][ny][nx]){\n                cost[nft][ny][nx] = cost[u.ft][u.y][u.x] + (m[ny][nx] - '0');\n                q.push(Data{nft,ny,nx});\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        cost['R'] = vvi(31, vi(31,INF));\n        cost['L'] = vvi(31, vi(31,INF));\n\n        rep(i,h) rep(j,w) cin >> m[i][j];\n\n        rep(i,w) if(m[h - 1][i] == 'S'){\n            cost['R'][h - 1][i] = 0;\n            dfs(Data{'R', h - 1, i});\n            cost['L'][h - 1][i] = 0;\n            dfs(Data{'L', h - 1, i});\n        }\n\n        int mini = INF;\n        rep(i,w){\n            int tmp = INF;\n            if(m[0][i] == 'T') tmp = min(cost['R'][0][i], cost['L'][0][i]);\n            mini = min(mini, tmp);\n        }\n        cout << (mini == INF ? -1 : mini) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid dijkstra(int n, vector< vector<edge> >& G, int s, vector<ll>& d) {\n\tfill(d.begin(), d.end(), LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > q;\n\tq.push(ll_i(0, s));\n\twhile (!q.empty()) {\n\t\tll_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (;;) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (w == 0) break;\n\t\tvector< vector<char> > s(h, vector<char>(w));\n\t\tfor (int y = 0; y < h; y++)\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tstring z; cin >> z;\n\t\t\t\ts[y][x] = z[0];\n\t\t\t}\n\t\tvector< vector<edge> > G(h * w * 2 + 2);\n\t\tfor (int y = 0; y < h; y++)\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tif (s[y][x] == 'S') {\n\t\t\t\t\ts[y][x] = '0';\n\t\t\t\t\tedge e = {h * w * 2, y * w + x, 0};\n\t\t\t\t\tedge _e = {h * w * 2, h * w + y * w + x, 0};\n\t\t\t\t\tG[h * w * 2].push_back(e);\n\t\t\t\t\tG[h * w * 2].push_back(_e);\n\t\t\t\t}\n\t\t\t\tif (s[y][x] == 'T') {\n\t\t\t\t\ts[y][x] = '0';\n\t\t\t\t\tedge e = {y * w + x, h * w * 2 + 1, 0};\n\t\t\t\t\tedge _e = {h * w + y * w + x, h * w * 2 + 1, 0};\n\t\t\t\t\tG[y * w + x].push_back(e);\n\t\t\t\t\tG[h * w + y * w + x].push_back(_e);\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int y = 0; y < h; y++)\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tif (s[y][x] == 'X') continue;\n\t\t\t\tfor (int _y = 0; _y < h; _y++)\n\t\t\t\t\tfor (int _x = 0; _x < w; _x++) {\n\t\t\t\t\t\tif (s[_y][_x] == 'X') continue;\n\t\t\t\t\t\tif (x >= _x || abs(x - _x) + abs(y - _y) > 3) continue;\n\t\t\t\t\t\tedge e = {y * w + x, h * w + _y * w + _x, s[_y][_x] - '0'};\n\t\t\t\t\t\tedge _e = {h * w + _y * w + _x, y * w + x, s[y][x] - '0'};\n\t\t\t\t\t\tG[y * w + x].push_back(e);\n\t\t\t\t\t\tG[h * w + _y * w + _x].push_back(_e);\n\t\t\t\t\t}\n\t\t\t}\n\t\tvector<ll> d(h * w * 2 + 2);\n\t\tdijkstra(h * w * 2 + 2, G, h * w * 2, d);\n\t\tll ans = d[h * w * 2 + 1];\n\t\tcout << (ans < LLONG_MAX ? ans : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][61][61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pair<int,int> > piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\n\nstruct Edge{\n\tint cost;\n\tint x,y;\n\tbool asi; // true:left\n\n\tEdge(int c,int xx,int yy,bool a) : cost(c), x(xx), y(yy), asi(a){}\n\n\tbool operator <(const Edge &e) const\n\t{\n\t\treturn cost < e.cost;\n\t}\n\tbool operator >(const Edge &e) const\n\t{\n\t\treturn cost > e.cost;\n\t}\n};\n\nint mv[61][31];\nint w,h;\n\nvector<pii> start;\nvector<pii> goal;\n\nint solve(){\n\tvvvi dist(w , vvi(h, vi(2, INT_MAX)));\n\tpriority_queue<Edge, vector<Edge>, greater<Edge> > que;\n\tfor(int i=0;i<start.size();i++){\n\t\tdist[start[i].first][start[i].second][0] = 0;\n\t\tdist[start[i].first][start[i].second][1] = 0;\n\t\tEdge e1(0,start[i].first,start[i].second,true);\n\t\tEdge e2(0,start[i].first,start[i].second,false);\n\t\tque.push(e1);\n\t\tque.push(e2);\n\t}\n\t\n\twhile(!que.empty()){\n\t\tEdge e = que.top();\n\t\tque.pop();\n\n\t\tfor(int i=-2;i<=2;i++){\n\t\t\tfor(int j=1;j<=3;j++){\n\t\t\t\tint dir = abs(i) + j;\n\t\t\t\tif(dir > 3){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint nj = j;\n\t\t\t\tif(!e.asi){\n\t\t\t\t\tnj *= -1;\n\t\t\t\t}\n\t\t\t\tint yy = e.y+i;\n\t\t\t\tint xx = e.x+nj;\n\t\t\t\tif(xx < 0 || xx >= w || yy < 0 || yy >= h){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(mv[e.y+i][e.x+nj] == -1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint ncost = e.cost + mv[e.y+i][e.x+nj];\n\t\t\t\tint nasi = !e.asi;\n\t\t\t\tif(ncost < dist[e.x+nj][e.y+i][nasi]){\n\t\t\t\t\tdist[e.x+nj][e.y+i][nasi] = ncost;\n\t\t\t\t\tEdge ne(ncost,e.x+nj,e.y+i,nasi);\n\t\t\t\t\tque.push(ne);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tfor(int i=0;i<goal.size();i++){\n\t\tans = min(ans,dist[goal[i].first][goal[i].second][0]);\n\t\tans = min(ans,dist[goal[i].first][goal[i].second][1]);\n\t}\n\n\tif(ans == INT_MAX){\n\t\tans = -1;\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tstart.clear();\n\t\tgoal.clear();\n\t\tcin >> w >> h;\n\t\tif(w == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar buf;\n\t\t\t\tcin >> buf;\n\t\t\t\tif(buf == 'S'){\n\t\t\t\t\tstart.push_back(make_pair(j,i));\n\t\t\t\t\tmv[i][j] = 0;\n\t\t\t\t}else if(buf == 'T'){\n\t\t\t\t\tgoal.push_back(make_pair(j,i));\n\t\t\t\t\tmv[i][j] = 0;\n\t\t\t\t}else if(buf == 'X'){\n\t\t\t\t\tmv[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\tmv[i][j] = buf - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define INF (1e9)\n#define H 60\n#define W 30\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<char,P1> P2;\nint dijkstra(int,int,char);\nint w,h,dl[H][W],dr[H][W],ans;\nchar s[H][W];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>s[i][j];\n    ans=INF;\n    for(int i=0;i<w;i++)\n      if(s[h-1][i]=='S')\n\tans=min(ans,min(dijkstra(h-1,i,'l'),dijkstra(h-1,i,'r')));\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;    \n  }\n  return 0;\n}\n\nint dijkstra(int sy,int sx,char lr){\n  priority_queue<P2> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) dl[i][j]=dr[i][j]=INF;\n  q.push(P2(lr,P1(0,P(sy,sx))));\n  if(lr=='l') dl[sy][sx]=0;\n  else dr[sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    char c=t.first;\n    int cost=t.second.first,y=t.second.second.first,x=t.second.second.second;\n    int dy[9]={0,0,0,-1,-1,-2,1,1,2},dx[9]={1,2,3,1,2,1,1,2,1};\n    if(c=='l'&&dl[y][x]<cost) continue;\n    if(c=='r'&&dr[y][x]<cost) continue;\n    for(int i=0;i<9;i++){\n      int ny,nx;\n      ny=y+dy[i];\n      if(c=='l') nx=x+dx[i];\n      else nx=x-dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx||s[ny][nx]=='X'||s[ny][nx]=='S') continue;\n      if(s[ny][nx]=='T'){\n\tif(c=='l') dr[ny][nx]=min(dr[ny][nx],cost);\n\telse dl[ny][nx]=min(dl[ny][nx],cost);\n      }\n      else if(c=='l'&&dr[ny][nx]>cost+s[ny][nx]-'0'){\n\tdr[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2('r',P1(dr[ny][nx],P(ny,nx))));\n      }\n      else if(c=='r'&&dl[ny][nx]>cost+s[ny][nx]-'0'){\n\tdl[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2('l',P1(dl[ny][nx],P(ny,nx))));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<w;i++)\n    if(s[0][i]=='T') res=min(res,min(dl[0][i],dr[0][i]));\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nusing tp = tuple<int, int, int, int>;\n\nconst int dx[2][9] = {\n\t{ -2, -1, 0, 1, 2, -1, 0, 1, 0 },\n\t{ -2, -1, 0, 1, 2, -1, 0, 1, 0 }\n};\n\nconst int dy[2][9] = {\n\t{ 1, 1, 1, 1, 1, 2, 2, 2, 3 },\n\t{ -1, -1, -1, -1, -1, -2, -2, -2, -3 }\n};\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<int> si, sj, ti, tj;\n\t\tvector<vector<char>> s(h, vector<char>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tsi.push_back(i);\n\t\t\t\t\tsj.push_back(j);\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'T') {\n\t\t\t\t\tti.push_back(i);\n\t\t\t\t\ttj.push_back(j);\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vector<int>>> d(h, vector<vector<int>>(w, vector<int>(2, INF)));\n\t\tpriority_queue<tp, vector<tp>, greater<tp>> pq;\n\t\tfor (int i = 0; i < (int)si.size(); i++) {\n\t\t\tpq.emplace(0, si[i], sj[i], 0);\n\t\t\tpq.emplace(0, si[i], sj[i], 1);\n\t\t}\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint x = get<1>(p), y = get<2>(p), b = get<3>(p), c = get<0>(p);\n\t\t\tif (d[x][y][b] != INF) continue;\n\t\t\td[x][y][b] = c;\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tint tx = x + dx[b][i], ty = y + dy[b][i];\n\t\t\t\tif (0 <= tx && tx < h && 0 <= ty && ty < w && s[tx][ty] != 'X' && d[tx][ty][1 - b] == INF) {\n\t\t\t\t\tpq.emplace(c + (s[tx][ty] - '0'), tx, ty, 1 - b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < (int)ti.size(); i++) {\n\t\t\tres = min(res, d[ti[i]][tj[i]][0]);\n\t\t\tres = min(res, d[ti[i]][tj[i]][1]);\n\t\t}\n\t\tcout << (res == INF ? -1 : res) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint W,H;\nint tiles[31][61] = {};\nint tleft[31][61] = {};\nint tright[31][61] = {};\nstruct Position {\n    int x,y;\n    bool foot; // true:left false:right\n};\nstruct CompareByFirst {\n    bool operator()(pair<int, Position> const & a,\n                              pair<int, Position> const & b) const\n    { return a.first > b.first; }\n};\nvector<int> answers;\n\nint main() {\nSTART:\n    while (cin>>W>>H && W != 0 && H != 0) {\n        priority_queue<pair<int, Position>, vector<pair<int, Position> >, CompareByFirst> pqueue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                tleft[w][h] = -1;\n                tright[w][h] = -1;\n                char tile = 0;\n                cin>>tile;\n                switch(tile) {\n                    case 'S':\n                    {\n                        tiles[w][h] = 0;\n                        Position pos = {w,h,true};\n                        pqueue.push(make_pair(0, pos));\n                        pos.foot = false;\n                        pqueue.push(make_pair(0, pos));\n                        break;\n                    }\n\n                    case 'T':\n                    {\n                        tiles[w][h] = -2;\n                        break;\n                    }\n\n                    case 'X':\n                        tiles[w][h] = -1;\n                        break;\n\n                    default:\n                        tiles[w][h] = atoi(&tile);\n                }\n            }\n        }\n\n        while (!pqueue.empty()) {\n            pair<int, Position> p = pqueue.top();\n            pqueue.pop();\n            if (p.second.foot == true) {\n                if (tleft[p.second.x][p.second.y] == -1) tleft[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = 1; w <= 3 - abs(h); w++) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                answers.push_back(p.first);\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, false};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (tright[p.second.x][p.second.y] == -1) tright[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = -1; w >= abs(h) - 3; w--) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                answers.push_back(p.first);\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, true};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        answers.push_back(-1);\n    }\n\n    for (int i = 0; i < answers.size() - 1; i++) cout<<answers[i]<<endl;\n    cout<<answers[answers.size()-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntemplate<class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\nconst int INF = 1<<29;\n\nint N, M;\nvector<vector<int> > fi;\ntypedef pair<int,int> pint;\ntypedef pair<pint,bool> state;\n\nint dp[65][35][2]; // 0: 左足、1: 右足\n\nint main() {\n  while (cin >> M >> N) {\n\tif (N == 0) break;\n\tfi.clear(); fi.resize(N);\n\tvector<pint> starts;\n\tset<pint> goals;\n\tfor (int i = 0; i < N; ++i) {\n\t  for (int j = 0; j < M; ++j) {\n\t\tchar c; cin >> c;\n\t\tint time = 0;\n\t\tif (c == 'X') time = -1;\n\t\telse if (c == 'S') starts.push_back(pint(i, j)), time = 0;\n\t\telse if (c == 'T') goals.insert(pint(i, j)), time = 0;\n\t\telse time = (int)(c - '0');\n\t\tfi[i].push_back(time);\n\t  }\n\t}\n\tint res = INF;\n\tpriority_queue<pair<int,state>, vector<pair<int,state> >, greater<pair<int,state> > > que;\n\tfor (int i = 0; i < 65; ++i) for (int j = 0; j < 35; ++j) {\n\t\tfor (int it = 0; it < 2; ++it)\n\t\t  dp[i][j][it] = INF;\n\t  }\n\tfor (auto p : starts) {\n\t  for (int it = 0; it < 2; ++it) {\n\t\tdp[p.first][p.second][it] = 0;\n\t\tque.push(make_pair(0, state(p,it)));\n\t  }\n\t}\n\twhile (!que.empty()) {\n\t  auto cur = que.top(); que.pop();\n\t  int curdist = cur.first;\n\t  pint p = cur.second.first;\n\t  int lr = cur.second.second;\n\t  if (goals.count(p)) chmin(res, curdist);\n\t  if (curdist > dp[p.first][p.second][lr]) continue;\n\t  for (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t  if (lr == 0 && j <= p.second) continue;\n\t\t  if (lr == 1 && j >= p.second) continue;\n\t\t  if (abs(i - p.first) + abs(j - p.second) > 3) continue;\n\t\t  if (fi[i][j] == -1) continue;\n\t\t  if (chmin(dp[i][j][1-lr], curdist + fi[i][j])) {\n\t\t\tque.push(make_pair(dp[i][j][1-lr], state(pint(i,j), 1-lr)));\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif (res < INF) cout << res << endl;\n\telse cout << -1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[66][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint mincost[2][66][33];\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[(lr+1)%2][ny][nx]) {\n\t  mincost[(lr+1)%2][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, (lr+1)%2), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair< int , int > P;\ntypedef pair< pair< int , P > , bool > PP;\n//コスト,座標,次どっちの足？(true:左,false:右)\n#define fr first\n#define sc second\n#define MAX_W 30\n#define MAX_H 60\n#define mp(a,b) make_pair(a,b)\n\nconst int dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\nint w,h;\nchar mas[MAX_H][MAX_W];\n\nbool over(int nx,int ny){\n  return nx < 0 || nx >= w || ny < 0 || ny >= h;\n}\n\nint bfs(vector<P>& st){\n  bool used[MAX_H][MAX_W][2] = {};\n  priority_queue< PP , vector<PP> , greater<PP> > que;\n  for(int i = 0 ; i < st.size() ; i++ ){\n    que.push(PP(mp(0,st[i]),false));\n    que.push(PP(mp(0,st[i]),true));\n  }\n  while(!que.empty()){\n    PP p = que.top();\n    que.pop();\n    if(used[p.fr.sc.fr][p.fr.sc.sc][p.sc]++) continue;\n    if(mas[p.fr.sc.fr][p.fr.sc.sc] == '0') return p.fr.fr;\n    for(int i = 0 ; i < 9 ; i++ ){\n      int ny = p.fr.sc.fr + dy[i] , nx = p.fr.sc.sc + (p.sc ? dx[i] : -dx[i]);\n      if(over(nx,ny) || mas[ny][nx] == 'X') continue;\n      que.push(PP(mp(p.fr.fr+(mas[ny][nx]-'0'),P(ny,nx)),!p.sc));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin >> w >> h , w){\n    vector<P> st;\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'S') st.push_back(P(i,j));\n        if(mas[i][j] == 'T') mas[i][j] = '0';\n      }\n    }\n    cout << bfs(st) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\n#include <cstdlib>\n#define H 60\n#define W 30\n#define SC signed char\n#define INF INT_MAX\n#define GOAL 10\n#define LABEL_X -1\n#define DEBUG false\nusing namespace std;\n\nint cost[H][W];\nSC s[H][W];\n\nint mv[9][2] = { // 右足の移動範囲( isL=falseの時 )\n  {1,-2},{1,-1},{1,0},{1,1},{1,2},\n  {2,-1},{2,0},{2,1},\n  {3,0}\n};\n\nint w,h;\nstruct P{\n  SC lx,ly, rx,ry;\n  bool isL; // 左足を動かすしたあとtrue\n  int cost; // 経過時間\n};\n\nvoid pr(P p ){\n  cout << \"(\"<<(int)p.lx<<\",\"<<(int)p.ly<<\") (\"\n       <<(int)p.rx<<\",\"<<(int)p.ry<<\") \"\n       << \"cost=\" << p.cost;\n  if( p.isL ) cout << \" left\" << endl;\n  else        cout << \" right\"<< endl;\n}\nvoid prCost(){\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ){\n      cout.width(11);\n      cout << cost[i][j];\n    }\n    cout << endl;\n  }\n}\n\n\nint main(){\n  queue<P> qu;\n  P p, q;\n\n  while( cin>>w >> h && (h||w) ){\n    p.lx=SCHAR_MAX; p.ly=SCHAR_MAX;\n    p.isL=true; p.cost=0;\n\n    while( !qu.empty() ) qu.pop();\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tchar c;\n\tcin >> c;\n\tswitch( c ){\n\tcase 'S' : s[i][j] = 0;\n\t  p.rx=j; p.ry=i; p.lx=p.rx+1;\n\t  qu.push( p ); p.isL=!p.isL;\n\t  p.lx=j; p.ly=i; p.rx=p.lx+1;\n\t  qu.push( p );\n\t  break;\n\tcase 'T' : \n\t  s[i][j] = GOAL;\n\t  break;\n\tcase 'X' : s[i][j] = LABEL_X; break;\n\tdefault :  s[i][j] = c-'0';   break;\n\t}\n      }\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcost[i][j] = INT_MAX;\n\n    int ans=INT_MAX, x,y;\n    while( !qu.empty() ){\n      p=qu.front(); qu.pop();\n      //      pr( p );\n\n      if( p.lx==p.rx && p.ly==p.ry ) continue;\n\n      if( p.isL ){ x=p.lx; y=p.ly; }\n      else {       x=p.rx; y=p.ry; }\n\n      if( x<0 || x>=w ) continue;\n      if( y<0 || y>=h ) continue;\n\n      if( s[y][x]==LABEL_X ) continue; // 'X'\n      \n      // goal\n      if( s[p.ly][p.lx]==GOAL || s[p.ry][p.rx]==GOAL ){\n\tif( ans > p.cost ){\n\t  ans = p.cost;\n\t  if( DEBUG ){\n\t    cout << \"*************************\"<< endl;\n\t    pr( p );\n\t  }\n\t}\n\tcontinue;\n      }\n\n      p.cost += s[y][x];\n      if( p.isL ){ // 左足をs[y][x] に置いたときの最小コスト\n\tif( p.cost >= cost[y][x] ) continue;\n\tcost[y][x] = p.cost;\n      }\n\n      if( DEBUG ){\n\tpr( p );\n\tprCost();\n      }\n      q=p;\n      if( p.isL ){ // 次に右足を動かす\n\tq.isL=false;\n\tfor( int i=0;i<9;i++ ){\n\t  q.rx = x + mv[i][0];\n\t  q.ry = y + mv[i][1];\n\t  qu.push( q );\n\t}\n      }else{     // 次に左足を動かす\n\tq.isL=true;\n\tfor( int i=0;i<9;i++ ){\n\t  q.lx = x - mv[i][0];\n\t  q.ly = y + mv[i][1];\n\t  qu.push( q );\n\t}\n      }\n    }\n    if( ans==INT_MAX ) ans=-1;\n    cout << ans << endl;\n\n    //    break;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define int long long\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct to {\n    int type, x, y;\n    to(int type, int y, int x):type(type),y(y),x(x){}\n    bool operator<(const to& t) const {\n        return type < t.type;\n    }\n};\nstruct edge {\n    to t; int cost;\n    edge(to t, int cost):t(t),cost(cost){}\n};\n\nvector<edge> G[2][61][31];\nint d[2][61][31];\n\nchar fld[62][32];\n\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint W, H;\n\nbool inside(int h, int w)\n{\n    return (0 <= h && h < H && 0 <= w && w < W);\n}\n\nvoid build_graph()\n{\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (fld[i][j] == 'T' || fld[i][j] == 'X') continue;\n\n            for (int k = 0; k < 9; ++k) {\n                int y = i + dy[k], ax = j + dx[k], bx = j + dx[k] * -1;\n\n                if (inside(y, ax) && fld[y][ax] != 'X') {\n                    int cost = (isdigit(fld[y][ax]) ? fld[y][ax] - '0' : 0);\n                    G[0][i][j].push_back(edge(to(1, y, ax), cost));\n                }\n                \n                if (inside(y, bx) && fld[y][bx] != 'X') {\n                    int cost = (isdigit(fld[y][bx]) ? fld[y][bx] - '0' : 0);\n                    G[1][i][j].push_back(edge(to(0, y, bx), cost));\n                }\n            }\n        }\n    }\n}\n\nvoid dijkstra(to s)\n{\n    typedef pair<int, to> P;\n\n    for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n        d[i][j][k] = inf;\n    }\n\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(0, to(s.type, s.y, s.x)));\n\n    d[s.type][s.y][s.x] = 0;\n\n    while (q.size()) {\n        P p = q.top();\n        q.pop();\n\n        to t = p.scd;\n        \n        if (p.fst > d[t.type][t.y][t.x]) continue;\n\n        for (int i = 0; i < G[t.type][t.y][t.x].size(); ++i) {\n            edge e = G[t.type][t.y][t.x][i];\n\n            if (d[e.t.type][e.t.y][e.t.x] > d[t.type][t.y][t.x] + e.cost) {\n                d[e.t.type][e.t.y][e.t.x] = d[t.type][t.y][t.x] + e.cost;\n                q.push(P(d[e.t.type][e.t.y][e.t.x], e.t));\n            }\n        }\n    }\n}\nsigned main()\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n            G[i][j][k].clear();\n        }\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                scanf(\"\\n%c\", &fld[i][j]);\n            }\n        }\n\n        build_graph();\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[H - 1][i] == 'S') {\n                for (int j = 0; j < 2; ++j) {\n                    dijkstra(to(j, H - 1, i));\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[0][i] == 'T') {\n                chmin(mi, min(d[0][0][i], d[1][0][i]));\n            }\n        }\n\n        printf(\"%d\\n\", mi == inf ? -1 : mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cctype>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int> >, greater<tuple<int, int, int, int> > > que;\n\n\tque.push(make_tuple(0, sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(0, sx, H - 1, 0)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<1>(que.top());\n\t\tint y = get<2>(que.top());\n\t\tint s = get<3>(que.top());\n\n\t\tque.pop();\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][1], x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(d[y2][x2][0], x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n/*\n3 3\nT X T\n4 1 5\nS S 3*/\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define INF 100000009\n#define N 20005\nusing namespace std;\n\ntypedef pair<int,int> PI;//cost to;\n\nint dg(int a){\n    if(a%2){\n        return 1;\n    }else{\n        return -1;\n    }\n}\n\nint map[65][35];\nint w,h;\n\nbool checkin(int i,int j){\n    if(i>=0&&j>=0&&i<h&&j<w&&map[i][j]!=INF){\n        return true;\n    }else{\n        return false;\n    }\n}\nint retc(int i,int j){\n    if(map[i][j]==-1){\n        return 0;\n    }else{\n        return map[i][j];\n    }\n}\n\nint main(){\n    int cango[9][2];//where right is from left,yx\n    int hoge = 0;\n    for(int y = 0;y<=2;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    for(int y = -2;y<=-1;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    while(1){\n        vector<PI> G[3600*9+5];//0???????¶? 1???????¶? to,cost\n        bool visited[3600*9+5],goal[3600*9+5];\n        priority_queue<PI, vector<PI> ,greater<PI> > pq;\n        rep(i,3600*9+5){\n            visited[i]=0;\n            goal[i]=0;\n        }\n        cin>>w>>h;\n        if(w==0){\n            return 0;\n        }\n        char c;\n        rep(i,h){\n            rep(j,w){\n                cin>>c;\n                if(c=='S')        map[i][j]=0;\n                else if(c=='T')   map[i][j]=-1;\n                else if(c=='X')   map[i][j]=INF;\n                else map[i][j]=c-'0';\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(!checkin(i,j))continue;\n                rep(state1,9){\n                    int y=i+cango[state1][0],x=j+cango[state1][1];\n                    if(!checkin(y,x))continue;\n                    if(map[i][j]==-1||map[y][x]==-1){\n                        goal[state1*w*h+i*w+j]=true;\n                        goal[w*h*9+state1*w*h+i*w+j]=true;\n                    }\n                    rep(state2,9){\n                        if(state1==state2)\n                            continue;\n                        int ny=i+cango[state2][0],nx=j+cango[state2][1];\n                        if(checkin(y,x)&&checkin(ny,nx)){\n                            G[state1*w*h+i*w+j].pb(mp(w*h*9+state2*w*h+i*w+j,retc(ny,nx)));\n                        }\n                        ny=y-cango[state2][0],nx=x-cango[state2][1];\n                        if(checkin(y,x)&&checkin(ny,nx)){\n                            G[w*h*9+state1*w*h+i*w+j].pb(mp(state2*w*h+ny*w+nx,retc(ny,nx)));\n                        }\n\n                    }\n                }\n            }\n        }\n//        rep(i,3600*9+5){\n//            if(!G[i].empty()){\n//                rep(j,G[i].size()){\n//                    cout<<\"from:\"<< \" foot:\" <<i/(w*h*9) <<\" state:\"<<i/w/h%9<<\" i j:(\"<< i/w%h<< \" \"<<i%w<< \")\"<<endl;\n//\n//                    cout<<\"to  :\"<< \" foot:\" <<G[i][j].first/(w*h*9) <<\" state:\"<<G[i][j].first/w/h%9<<\" i j:(\"<< G[i][j].first/w%h<< \" \"<<G[i][j].first%w <<\") cost:\"<<G[i][j].second<<endl<<endl;\n//                }\n//            }\n//        }\n        rep(j,w){\n            if(map[h-1][j]!=0)\n                continue;\n            rep(st,9){\n                int y = h-1+cango[st][0],x = j+cango[st][1];\n                if(!checkin(y,x)||map[y][x]!=0)\n                    continue;\n                pq.push(make_pair(0,0+st*w*h+w*(h-1)+j));\n                pq.push(make_pair(0,w*h*9+st*w*h+w*(h-1)+j));\n            }\n        }\n        int ans = -1;\n        while(!pq.empty()){\n            PI now = pq.top();\n            int cost = now.first;\n            int from = now.second;\n            pq.pop();\n            if(visited[from]){\n                continue;\n            }\n            visited[from]=true;\n            if(goal[from]){\n                ans = cost;\n                break;\n            }\n            rep(i,G[from].size()){\n                pq.push(mp(G[from][i].second+cost,G[from][i].first));\n            }\n        }\n        cout<<ans<<endl;\n\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\ntypedef pair<int,Q> R;\nint dist[105][105][2];\nint f[105][105];\nint n,m;\nint main(){\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(n ==0 )return 0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tstring sd; cin >> sd;\n\t\t\t\tchar s = sd[0];\n\t\t\t\tif(s == 'S'){\n\t\t\t\t\tf[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(s == 'T'){\n\t\t\t\t\tf[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if('0'<=s&&s<='9') f[i][j] = s-'0';\n\t\t\t\telse f[i][j] = 1e8;\n\t\t\t}\n\t\t}\n\t\trep(i,105)rep(j,105)rep(k,2) dist[i][j][k] = 1e8;\n\t\tpriority_queue<R,vector<R>,greater<R> >que;\n\t\trep(j,m){\n\t\t\tif(f[n-1][j] == 0){\n\t\t\t\tdist[n-1][j][0] = 0;\n\t\t\t\tque.push(mp(0,mp(0,mp(n-1,j))));\n\t\t\t\tdist[n-1][j][1] = 0;\n\t\t\t\tque.push(mp(0,mp(1,mp(n-1,j))));\n\t\t\t//\tcout << j << \" \" <<m << \" \" << n << endl;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tR r = que.top(); que.pop();\n\t\t\tint d = r.sc.fi , x = r.sc.sc.fi , y = r.sc.sc.sc;\n\t\t\tif(dist[x][y][d] != r.fi) continue;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int i=-2;i<=2;i++) for(int j=1;j<=3;j++){\n\t\t\t\t\tif(abs(i)+abs(j) > 3) continue;\n\t\t\t\t\tif(0<=x+i&&x+i<n&&0<=y+j&&y+j<m){\n\t\t\t\t\t\t//dist[x+i][y+j][1]\n\t\t\t\t\t\tif(dist[x+i][y+j][1] > dist[x][y][0]+f[x+i][y+j]){\n\t\t\t\t\t\t\tdist[x+i][y+j][1] = dist[x][y][0]+f[x+i][y+j];\n\t\t\t\t\t\t\tque.push(mp(dist[x+i][y+j][1],mp(1,mp(x+i,y+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=-2;i<=2;i++) for(int j=-3;j<=-1;j++){\n\t\t\t\t\tif(abs(i)+abs(j) > 3) continue;\n\t\t\t\t\tif(0<=x+i&&x+i<n&&0<=y+j&&y+j<m){\n\t\t\t\t\t\t//dist[x+i][y+j][0]\n\t\t\t\t\t\tif(dist[x+i][y+j][0] > dist[x][y][1]+f[x+i][y+j]){\n\t\t\t\t\t\t\tdist[x+i][y+j][0] = dist[x][y][1]+f[x+i][y+j];\n\t\t\t\t\t\t\tque.push(mp(dist[x+i][y+j][0],mp(0,mp(x+i,y+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e8;\n\t\trep(j,m){\n\t\t\tif(f[0][j] == 0){ ans = min(ans,min(dist[0][j][0],dist[0][j][1])); }\n\t\t}\n\t\tif(ans > 5e7) ans = -1;cout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate<class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w) {\n        vector<vector<int>> field(h, vector<int>(w));\n        vector<pair<int, int>> starts, goals;\n        for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n            char c; cin >> c;\n            int time = 0;\n            if (c == 'X') time = -1;\n            else if (c == 'S') starts.emplace_back(i, j);\n            else if (c == 'T') goals.emplace_back(i, j);\n            else time = c - '0';\n            field[i][j] = time;\n        }\n        auto dist = make_v(h, w, 2, INF);\n        using P = tuple<int, int, int, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        for (auto &p: starts) for (bool b: {true, false}) {\n            dist[p.first][p.second][b] = 0;\n            que.emplace(0, p.first, p.second, b);\n        }\n        while (!que.empty()) {\n            int d, i, j, b; tie(d, i, j, b) = que.top(); que.pop();\n            if (dist[i][j][b] < d) continue;\n            for (int di = -2; di <= 2; di++) for (int dj = 1; dj <= 3; dj++) {\n                if (abs(di) + dj > 3) continue;\n                int ni = i + di, nj = j + (b ? dj : -dj);\n                if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                if (field[ni][nj] == -1) continue;\n                if (chmin(dist[ni][nj][!b], d + field[ni][nj])) {\n                    que.emplace(dist[ni][nj][!b], ni, nj, !b);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto &p: goals) for (bool b: {true, false}) {\n            chmin(ans, dist[p.first][p.second][b]);\n        }\n        if (ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\n\nchar stage[60][30];\nint cost[1800][1800];\n\nint w,h;\nvoid dfs(int lhs,int rhs,int turn,int c){\n\n\tint srx = rhs % w;\n\tint sry = rhs / w;\n\n\tint slx = lhs % w;\n\tint sly = lhs / w;\n\n\t//turn:0 moving right leg\n\tif(turn==0){\n\t\tfor(int ty = -4; ty <= 4; ty++){\n\t\t\tfor(int tx = -4;tx <= 4; tx++){\n\t\t\t\tint dx = tx + srx;\n\t\t\t\tint dy = ty + sry;\n\n\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\tif(slx>=dx) continue;\n\t\t\t\tif(abs(dx - slx) + abs(dy - sly) > 3) continue;\n\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\tcost[lhs][dy*w+dx] = min(cost[lhs][dy*w+dx],c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cost[lhs][dy*w+dx] <= c + stage[dy][dx]-'0') continue;\n\t\t\t\tcost[lhs][dy*w+dx] = c + stage[dy][dx]-'0';\n\t\t\t\tdfs(lhs,dy*w+dx,1,c + stage[dy][dx]-'0');\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int ty = -4; ty <= 4; ty++){\n\t\t\tfor(int tx = -4;tx <= 4; tx++){\n\t\t\t\tint dx = tx + slx;\n\t\t\t\tint dy = ty + sly;\n\n\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\tif(dx>=srx) continue;\n\t\t\t\tif(abs(dx - srx) + abs(dy - sry) > 3) continue;\n\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\tcost[dy*w+dx][rhs] = min(cost[dy*w+dx][rhs],c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(cost[dy*w+dx][rhs] <= c + stage[dy][dx]-'0') continue;\n\t\t\t\tcost[dy*w+dx][rhs] = c + stage[dy][dx]-'0';\n\t\t\t\tdfs(dy*w+dx,rhs,0,c + stage[dy][dx]-'0');\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tmemset(cost,0x3f,sizeof(cost));\n\t\tvector<P> S;\n\t\tvector<P> T;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%s\",&stage[y][x]);\n\t\t\t\tif(stage[y][x]=='S') S.push_back(P(x,y));\n\t\t\t\tif(stage[y][x]=='T') T.push_back(P(x,y));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<S.size();i++){\n\t\t\tint x = S[i].first;\n\t\t\tint y = S[i].second;\n\t\t\tdfs(y*w+x,y*w+x,0,0);\n\t\t\tdfs(y*w+x,y*w+x,1,0);\n\t\t}\n\n\t\tint res = numeric_limits<int>::max();\n\t\tfor(int lhs=0;lhs < 1800; lhs++){\n\t\t\tfor(int rhs=0; rhs < 1800; rhs++){\n\t\t\t\tint srx = rhs % w;\n\t\t\t\tint sry = rhs / w;\n\n\t\t\t\tint slx = lhs % w;\n\t\t\t\tint sly = lhs / w;\n\n\t\t\t\tif(srx < 0 || srx >= w || sry < 0 || sry >= h) continue;\n\t\t\t\tif(slx < 0 || slx >= w || sly < 0 || sly >= h) continue;\n\n\t\t\t\tif(stage[sry][srx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t\tif(stage[sly][slx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res >= 0x3f3f3f3f ? -1 : res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\n\nstruct P\n{\n\tint x, y, f, c;\n\tP(int x, int y, int f, int c)\n\t\t: x(x), y(y), f(f), c(c) { }\n\tbool operator<(const P& a) const { return c > a.c; }\n};\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint w, h;\n\tchar s[64][64];\n\twhile (cin >> w >> h, w)\n\t{\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tcin >> s[y][x];\n\n\t\tstatic int dp[64][64][2];\n\t\tconst int INF = 1 << 26;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tdp[y][x][0] = dp[y][x][1] = INF;\n\n\t\tpriority_queue<P> q;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (s[y][x] == 'S')\n\t\t\t\t{\n\t\t\t\t\tdp[y][x][0] = dp[y][x][1] = 0;\n\t\t\t\t\tq.push(P(x, y, 0, 0));\n\t\t\t\t\tq.push(P(x, y, 1, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP cur = q.top(); q.pop();\n\t\t\tint x = cur.x, y = cur.y, f = cur.f, c = cur.c;\n\t\t\tif (c > dp[y][x][f])\n\t\t\t\tcontinue;\n\n\t\t\tint dir = f == 0 ? 1 : -1;\n\t\t\tint nf = f ^ 1;\n\t\t\tfor (int dy = -2; dy <= 2; ++dy)\n\t\t\t{\n\t\t\t\tfor (int dx = 1; dx <= 3; ++dx)\n\t\t\t\t{\n\t\t\t\t\tint tx = x + dir * dx, ty = y + dy;\n\t\t\t\t\tif (abs(dx) + abs(dy) <= 3\n\t\t\t\t\t\t&& valid_pos(tx, ty, w, h) && s[ty][tx] != 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\tint nc = c;\n\t\t\t\t\t\tif (isdigit(s[ty][tx]))\n\t\t\t\t\t\t\tnc += s[ty][tx] - '0';\n\t\t\t\t\t\tif (nc < dp[ty][tx][nf])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[ty][tx][nf] = nc;\n\t\t\t\t\t\t\tq.push(P(tx, ty, nf, nc));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tif (s[y][x] == 'T')\n\t\t\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\t\t\tmin_swap(res, dp[y][x][i]);\n\t\tif (res == INF)\n\t\t\tres = -1;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0xfffffff, MAX_W = 30, MAX_H = 60;\nconst int LEFT = 0, RIGHT = 1;\nint w, h;\nchar field[MAX_H][MAX_W];\n\nstruct state {\n\tint x, y, dist;\n\tbool right;\n\n\tstate(int x, int y, bool right, int dist):x(x), y(y), right(right), dist(dist){};\n\tbool operator>(const state& s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\n\nint dijkstra() {\n\tvector<vector<vector<int> > > dist(h, vector<vector<int> >(w, vector<int>(2, INT_MAX)));\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'S') {\n\t\t\t\tdist[i][j][LEFT] = dist[i][j][RIGHT] = 0;\n\t\t\t\tque.push(state(j, i, LEFT, 0));\n\t\t\t\tque.push(state(j, i, RIGHT, 0));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.y][s.x][s.right] < s.dist)\n\t\t\tcontinue;\n\n\t\tif(field[s.y][s.x] == 'T')\n\t\t\treturn s.dist;\n\n\t\tconst int sign = (s.right ? -1 : 1);\n\n\t\tfor(int i = 1; i <= 3; ++i) {\n\t\t\tconst int nx = s.x + sign * i;\n\t\t\tif(nx < 0 || nx >= w)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int j = -3 + i; j + i <= 3; ++j) {\n\t\t\t\tconst int ny = s.y + j;\n\t\t\t\tif(ny < 0 || ny >= h || field[ny][nx] == 'X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tconst bool n_right = !s.right;\n\t\t\t\tconst int n_dist = s.dist + (isdigit(field[ny][nx]) ? field[ny][nx] - '0' : 0);\n\t\t\t\tif(dist[ny][nx][n_right] > n_dist) {\n\t\t\t\t\tdist[ny][nx][n_right] = n_dist;\n\t\t\t\t\tque.push(state(nx, ny, n_right, n_dist));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> field[i][j];\n\n\t\tcout << dijkstra() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_W 30\n#define MAX_H 60\nchar field[MAX_H][MAX_W];\n\nstruct P\n{\n    int x,y,cost,w;\n    bool operator >(const P &p) const{\n        return cost>p.cost;\n    }\n};\n\nint dx[]={\n    1,1,1,1,1,2,2,2,3\n};\nint dy[]={\n    -2,-1,0,1,2,-1,0,1,0\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, MAX_W*MAX_H, 'X');\n\n        priority_queue<P, vector<P>, greater<P> >que;\n\n        REP(y,h)REP(x,w){\n            cin >> field[y][x];\n            if(field[y][x]=='S'){\n                que.push({x, y, 0, 1});\n                que.push({x, y, 0,-1});\n            }\n        }\n\n        vvi GL(h, vi(w, INF));\n        vvi GR(h, vi(w, INF));\n\n        int res=-1;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n\n            if(field[p.y][p.x]=='T'){\n                res=p.cost;\n                break;\n            }\n\n            REP(i, 9){\n                int sx=p.x+dx[i]*p.w;\n                int sy=p.y+dy[i];\n                if(0<=sx&&sx<w&&0<=sy&&sy<h){\n                    int cost=p.cost;\n                    switch(field[sy][sx]){\n                    case 'T':\n                    case 'S':\n                        break;\n                    case 'X':\n                        continue;\n                    default:\n                        cost+=field[sy][sx]-'0';\n                        break;\n                    }\n                    bool t=true;\n                    if(p.w>0&&GL[sy][sx]>cost){\n                        GL[sy][sx]=cost;\n                        t=false;\n                    }else if(p.w<0&&GR[sy][sx]>cost){\n                        GR[sy][sx]=cost;\n                        t=false;\n                    }\n                    if(t)continue;\n                    que.push({sx, sy, cost, -p.w});\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State {\n  int which; int y; int x;\n  bool operator<(const State &other) const {\n    return\n      (y != other.y) ? y > other.y :\n      (x != other.x) ? x < other.x : which < other.which;\n  };\n};\n\nconst int INF = 1e9;\nconst int dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\ntemplate<typename T> struct Dijkstra {\n  struct Edge { State to; T cost; };\n  map<State, vector<Edge>> g;\n  map<State, T> init;\n\n  Dijkstra(int h, int w) {\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        State s0 = {0, i, j};\n        State s1 = {1, i, j};\n        init[s0] = init[s1] = -1;\n      }\n    }\n  }\n  void addEdge(State u, State v, T w) {\n    g[u].push_back({v, w});\n  }\n  map<State, T> build(vector<State> starts) {\n    map<State, T> dist(init);\n    using Node = pair<T, State>;\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    for (auto&& s : starts) {\n      pq.push({dist[s] = 0, s});\n    }\n\n    while (!pq.empty()) {\n      auto d = pq.top().first;\n      auto u = pq.top().second;\n      pq.pop();\n      if (dist[u] < d) continue;\n      for (auto&& v : g[u]) {\n        if (dist[v.to] < 0 || dist[v.to] > dist[u] + v.cost) {\n          dist[v.to] = dist[u] + v.cost;\n          pq.push({dist[v.to], v.to});\n        }\n      }\n    }\n    return dist;\n  }\n};\n\nint main() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    vector<vector<char>> s(h, vector<char>(w));\n    vector<State> starts;\n    vector<State> goals;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> s[i][j];\n        if (s[i][j] == 'S') {\n          starts.push_back({0, i, j});\n          starts.push_back({1, i, j});\n        }\n        if (s[i][j] == 'T') {\n          goals.push_back({0, i, j});\n          goals.push_back({1, i, j});\n        }\n      }\n    }\n    Dijkstra<int> g(h, w);\n    for (int sy = 0; sy < h; sy++) {\n      for (int sx = 0; sx < w; sx++) {\n        if (s[sy][sx] == 'X') continue;\n        for (int i = 0; i < 2; i++) {\n          for (int j = 0; j < 9; j++) {\n            int ty = sy + dy[j];\n            int tx = sx + ((i % 2 == 0) ? dx[j] : -dx[j]);\n            if (-1 < ty && ty < h && -1 < tx && tx < w && s[ty][tx] != 'X') {\n              State u = {i, sy, sx};\n              State v = {i ^ 1, ty, tx};\n              int w = (s[ty][tx] - '0') * (s[ty][tx] != 'S') * (s[ty][tx] != 'T');\n              g.addEdge(u, v, w);\n            }\n          }\n        }\n      }\n    }\n    auto dist = g.build(starts);\n    int ans = INF;\n    for (auto&& t : goals) {\n      int mn = (dist[t] != -1) ? dist[t] : INF;\n      ans = min(ans, mn);\n    }\n    cout << ( (ans != INF) ? ans : -1 ) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,rx,ry,s,cost;\n\tbool operator<(const data &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint w,h;\nint dp[35][65][5][7][2];\nint fie[100][100];\nint flag[100][100];\nint sx[5],gx[5];\n\nint dijk(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tdata inp;\n\tint res=-1;\n\tinp.x=sx[0];\n\tinp.y=h;\n\tinp.rx=sx[1]-sx[0];\n\tinp.ry=3;\n\tinp.cost=0;\n\tinp.s=0;\n\tque.push(inp);\n\tinp.s=1;\n\tque.push(inp);\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.x][q.y][q.rx][q.ry][q.s]!=-1 && dp[q.x][q.y][q.rx][q.ry][q.s]<q.cost)continue;\n\t\tdp[q.x][q.y][q.rx][q.ry][q.s]=q.cost;\n\t\tif(flag[q.x][q.y]==1 || flag[q.x+q.rx][q.y+q.ry-3]==1){\n\t\t\tres=min(res,q.cost);\n\t\t\tif(res==-1)res=q.cost;\n\t\t}\n\t\t//printf(\"%d %d %d %d %d %d\\n\",q.x,q.y,q.rx,q.ry,q.s,q.cost);\n\t\tif(q.s==0){\n\t\t\tfor(int i=1;i<=3;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x][q.y][i][j+3][1]==-1 || dp[q.x][q.y][i][j+3][1]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x][q.y][i][j+3][1]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq=q;\n\t\t\t\t\t\t\t\tnq.rx=i;\n\t\t\t\t\t\t\t\tnq.ry=j+3;\n\t\t\t\t\t\t\t\tnq.s=1;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.s==1){\n\t\t\tq.x=q.x+q.rx;\n\t\t\tq.y=q.y+q.ry-3;\n\t\t\tfor(int i=-3;i<=-1;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(-i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x+i][q.y+j][-i][-j+3][0]==-1 || dp[q.x+i][q.y+j][-i][-j+3][0]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x+i][q.y+j][-i][-j+3][0]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq;\n\t\t\t\t\t\t\t\tnq.x=q.x+i;\n\t\t\t\t\t\t\t\tnq.y=q.y+j;\n\t\t\t\t\t\t\t\tnq.rx=-i;\n\t\t\t\t\t\t\t\tnq.ry=-j+3;\n\t\t\t\t\t\t\t\tnq.s=0;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(flag,0,sizeof(flag));\n\t\tint scnt=0,gcnt=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='S')fie[j][i]=0,sx[scnt++]=j;\n\t\t\t\tif(c=='T')fie[j][i]=0,flag[j][i]=1;\n\t\t\t\tif(c=='X')fie[j][i]=-1;\n\t\t\t\tif(c>='1' && c<='9')fie[j][i]=c-'0';\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[2][9] = {{2,1,0,-1,-2,1,0,-1,0},{2,1,0,-1,-2,1,0,-1,0}};\nint dw[2][9] = {{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\n\nint cost[2][60][30];\nint w, h;\nint brd[60][30];\nvector<P> st,goal;\n\nvoid func(int hh, int ww, int ty){\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0,hh*10000+ww*100+ty));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tint H = q.second/10000, W = (q.second%10000)/100, TY = q.second%100;\n\t\tif(cost[TY][H][W] < q.first) continue;\n\t\trep(i,9){\n\t\t\tif(0>H+dh[TY][i]||H+dh[TY][i]>=h||0>W+dw[TY][i]||W+dw[TY][i]>=w) continue;\n\t\t\tif(brd[H+dh[TY][i]][W+dw[TY][i]] == INF) continue;\n\t\t\tif(cost[(TY+1)%2][H+dh[TY][i]][W+dw[TY][i]] <= cost[TY][H][W]+brd[H+dh[TY][i]][W+dw[TY][i]]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcost[(TY+1)%2][H+dh[TY][i]][W+dw[TY][i]] = cost[TY][H][W]+brd[H+dh[TY][i]][W+dw[TY][i]];\n\t\t\tque.push(P(cost[(TY+1)%2][H+dh[TY][i]][W+dw[TY][i]],(H+dh[TY][i])*10000+(W+dw[TY][i])*100+(TY+1)%2));\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tst.clear(); goal.clear();\n\trep(i,2) rep(j,60) rep(k,30) cost[i][j][k] = INF;\n\trep(i,h) rep(j,w){\n\t\tchar tmp; cin >> tmp;\n\t\tif(tmp == 'X') brd[i][j] = INF;\n\t\telse if(tmp == 'T'){\n\t\t\tbrd[i][j] = 0;\n\t\t\tgoal.push_back(P(i,j));\n\t\t} else if(tmp == 'S'){\n\t\t\tbrd[i][j] = 0;\n\t\t\trep(k,2) cost[k][i][j] = 0;\n\t\t\tst.push_back(P(i,j));\n\t\t} else{\n\t\t\tbrd[i][j] = tmp-'0';\n\t\t}\n\t}\n\trep(i,st.size()){\n\t\trep(j,2){\n\t\t\tfunc(st[i].first,st[i].second,j);\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,goal.size()){\n\t\trep(j,2){\n\t\t\tans = min(ans,cost[j][goal[i].first][goal[i].second]);\n\t\t}\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P ,int > Pi;\ntypedef long long ll;\n\nint w,h;\nchar s[61][31];\nint d[61][31][2];\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nvoid bfs(int y,int x,int foot) {\n    d[y][x][foot]=0;\n    queue<Pi> que;\n    que.push(Pi(P(y,x),foot));\n    while(que.size()) {\n        Pi p=que.front();\n        que.pop();\n        int cur_y=p.fr.fr;\n        int cur_x=p.fr.sc;\n        int cur_foot=p.sc;\n        int a[]={0,2,1,0};\n        //printf(\"[debug] %d %d %d\\n\",cur_y,cur_x,cur_foot);\n\n        for(int dx=1;dx<=3;dx++) {\n            for(int dy=-a[dx];dy<=a[dx];dy++) {\n                int ny=dy+cur_y;\n                int nx=dx+cur_x;\n                if(cur_foot==1) {\n                    nx=cur_x-dx;\n                }\n                if(ny<0 || nx<0) continue;\n                if(h<=ny || w<=nx) continue;\n                if(s[ny][nx] == 'X') continue;\n                if(s[ny][nx] == 'S') continue;\n\n                //printf(\"[debug] %d %d : %d -> %d %d : %d\\n\",cur_y,cur_x,d[cur_y][cur_x][cur_foot],ny,nx,d[ny][nx][cur_foot^1]);\n                if(s[ny][nx]=='T') {\n                    chmin(d[ny][nx][cur_foot^1],d[cur_y][cur_x][cur_foot]);\n                }\n                else if(chmin(d[ny][nx][cur_foot^1],d[cur_y][cur_x][cur_foot]+s[ny][nx]-'0')) {\n                    que.push(Pi(P(ny,nx),cur_foot^1));\n                }\n            }\n        }\n\n    }\n}\n\nvoid solve() {\n    rep(y,h) rep(x,w) cin>>s[y][x];\n    rep(y,h) rep(x,w) d[y][x][0]=d[y][x][1]=INF;\n    rep(y,h) rep(x,w) if(s[y][x]=='S') {\n        bfs(y,x,0);\n        bfs(y,x,1);\n    }\n    int ans=INF;\n    rep(y,h) rep(x,w) if(s[y][x]=='T') rep(i,2) chmin(ans,d[y][x][i]);\n\n    if(ans==INF) ans=-1;\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nconst int dy[9] = { 2, 1, 0, -1, -2, 1, 0, -1, 0 };\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\n\nint main() {\n    int w, h;\n    while ( cin >> w >> h && w && h ) {\n        char M[61][31];\n        int MT[2][61][31];\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                for ( int k = 0; k < 2; k++ ) {\n                    MT[k][i][j] = 1<<24;\n                }\n            }\n        }\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                cin >> M[i][j];\n            }\n        }\n\n        Queue Q;\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( M[i][j] != 'S' ) continue;\n                for ( int k = 0; k < 2; k++ ) {\n                    Node start_node( PII( 0, k?1:-1 ), PII( i, j ) );\n                    Q.push( start_node );\n                    MT[k][i][j] = 0;\n                }\n            }\n        }\n\n        bool ok = false;\n        while ( !Q.empty() ) {\n            Node node = Q.top();\n            Q.pop();\n\n            int t = node.first.first;\n            int l = node.first.second;\n            int r = node.second.first;\n            int c = node.second.second;\n\n            if ( M[r][c] == 'T' ) {\n                cout << t << endl;\n                ok = true;\n                break;\n            }\n\n            for ( int i = 0; i < 9; i++ ) {\n                int nr = r + dy[i] * l;\n                int nc = c + dx[i] * l;\n                if ( nr < 0 || nr >= h || nc < 0 || nc >= w ) continue;\n                if ( M[nr][nc] == 'X' ) continue;\n                int nt = t + M[nr][nc] - '0';\n                if ( M[nr][nc] == 'S' || M[nr][nc] == 'T' ) nt = t;\n                int nl = l * -1;\n                // cout << i << \": \" << t << \", \" << l << \", \" << r << \", \" << c << \" -> \";\n                // cout << nt << \", \" << nl << \", \" << nr << \", \" << nc << endl;\n                int ind = ( nl == 1 ? 0 : 1 );\n                if ( nt >= MT[ind][nr][nc] ) continue;\n                MT[ind][nr][nc] = nt;\n                Node next_node( PII( nt, nl ), PII( nr, nc ) );\n                Q.push( next_node );\n            }\n        }\n\n        if ( !ok ) cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n//#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define INF 10000;\n\n\nbool check[100][100][2] = { false };\nint cost[100][100][2];\nint move[] = { 1, -1 };\n\nclass Node{\npublic:\n\tint x;\n\tint y;\n\tint lr;//0 -> left, 1 -> right\n\tint num;\n\n\tNode(){ x = 0; y = 0; lr = 0; num = 0; }\n\tNode(int x, int y, int lr, int num) : x(x), y(y), lr(lr), num(num){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.num < n2.num;\n}\n\nbool operator> (const Node &n1, const Node &n2){\n\treturn n1.num > n2.num;\n}\n\nint main(void){\n\n\tint w, h;\n\twhile (cin >> w >> h, w, h){\n\t\tchar map[100][100];\n\t\tint result = -1;\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcost[j][i][1] = cost[j][i][0] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcheck[j][i][1] = check[j][i][0] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif (map[j][i] == 'X') check[j][i][1] = check[j][i][0] = true;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que;\n\n\t\tfor (int i = 0; i < w; i++){\n\t\t\tif (map[0][i] == 'S'){\n\t\t\t\tque.push(Node(i, 0, 0, 0));\n\t\t\t\tque.push(Node(i, 0, 1, 0));\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\twhile (!que.empty()){\n\t\t\tNode buff = que.top();\n\t\t\tque.pop();\n\n\t\t\tif (check[buff.y][buff.x][buff.lr]) continue;\n\t\t\tcheck[buff.y][buff.x][buff.lr] = true;\n\t\t\tcost[buff.y][buff.x][buff.lr] = min(cost[buff.y][buff.x][buff.lr], buff.num);\n\n\t\t\tfor (int i = 1; i <= 3; i++){\n\t\t\t\tfor (int j = 3 - i; abs(j) + i <= 4; j--){\n\t\t\t\t\tif (flag) break;\n\t\t\t\t\tint nextx = buff.x + move[buff.lr] * i;\n\t\t\t\t\tint nexty = buff.y + j;\n\t\t\t\t\tif (nextx < 0 || w <= nextx || nexty < 0 || h <= nexty || map[nexty][nextx] == 'S' || map[nexty][nextx] == 'X') continue;\n\t\t\t\t\tif (map[nexty][nextx] == 'T'){\n\t\t\t\t\t\tresult = buff.num;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(Node(nextx, nexty, (buff.lr + 1) % 2, buff.num + (map[nexty][nextx] - '0')));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\t/*\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << map[j][i] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << min(cost[j][i][0], cost[j][i][1]) << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif (!flag) cout << -1 << endl;\n\t\telse cout << result << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dy[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\n\ntypedef vector<vvi> vvvi;\nstruct node{\n\tint foot,x,y,c;\n\tnode(){}\n\tnode(int foot,int x,int y,int c):foot(foot),x(x),y(y),c(c){}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\tvvi s(w,vi(h));\n\t\tvector<pii> start,goal;\n\t\tREP(j,h)REP(i,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tswitch(c){\n\t\t\tcase 'S':\n\t\t\t\tstart.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tgoal.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\ts[i][j]=-1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts[i][j]=c-'0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvvvi cost(2,vvi(w,vi(h,MAX)));\n\t\tqueue<node> q;\n\t\tREP(i,2)REP(j,start.size()){\n\t\t\tq.push(node(i,start[j].first,start[j].second,0));\n\t\t\tcost[i][start[j].first][start[j].second]=0;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.front();\n\t\t\tq.pop();\n\t\t\tif(cost[n.foot][n.x][n.y]<n.c)continue;\n\t\t\tREP(i,9){\n\t\t\t\tint foot=(n.foot+1)%2;\n\t\t\t\tint x=n.x+dx[foot][i],y=n.y+dy[foot][i];\n\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h&&s[x][y]>=0){\n\t\t\t\t\tint newcost=cost[n.foot][n.x][n.y]+s[x][y];\n\t\t\t\t\tif(cost[foot][x][y]>newcost){\n\t\t\t\t\t\tcost[foot][x][y]=newcost;\n\t\t\t\t\t\tq.push(node(foot,x,y,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=MAX;\n\t\tREP(i,2)REP(j,goal.size()){\n\t\t\tbest=min(best,cost[i][goal[j].first][goal[j].second]);\n\t\t}\n\t\tif(best==MAX){\n\t\t\tbest=-1;\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint dx[]={1,1,1,1,1,2,2,2,3};\nint dy[]={-2,-1,0,1,2,-1,0,1,0};\n\nclass State\n{\npublic:\n\tint lx,ly,rx,ry,c,f;\n\tState(int lx, int ly, int rx, int ry, int c, int f)\n\t\t:lx(lx),ly(ly),rx(rx),ry(ry),c(c),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c>s.c;\n\t}\n};\n\nbool v[30][60][30][60][2];\n\nint main()\n{\n\tint W,H;\n\tchar f[80][80];\n\twhile(cin >> W >> H, (W||H))\n\t{\n\t\tmemset(v,0,sizeof(v));\n\n\t\tpriority_queue<State> q;\n\t\tfor(int i=0; i<H; i++)\n\t\tfor(int j=0; j<W; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='S')\n\t\t\t{\n\t\t\t\tfor(int k=0; k<2; k++)\n\t\t\t\t\tq.push(State(j,i,j,i,0,k));\n\t\t\t}\n\t\t}\n\n\t\tbool g=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tState s=q.top(); q.pop();\n\t\t\tif(f[s.lx][s.ly]=='T' || f[s.rx][s.ry]=='T')\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t\tcout << s.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(v[s.lx][s.ly][s.rx][s.ry][s.f]) continue;\n\t\t\tv[s.lx][s.ly][s.rx][s.ry][s.f]=1;\n\n\t\t\tfor(int i=0; i<9; i++)\n\t\t\t{\n\t\t\t\tif(s.f==0)\n\t\t\t\t{\n\t\t\t\t\tint tlx=s.rx-dx[i], tly=s.ry+dy[i];\n\t\t\t\t\tint tf=(s.f+1)%2;\n\t\t\t\t\tif(tlx<0||tly<0||tlx>=W||tly>=H) continue;\n\t\t\t\t\tif(f[tlx][tly]=='X') continue;\n\t\t\t\t\tif(v[tlx][tly][s.rx][s.ry][tf]) continue;\n\n\t\t\t\t\tint tc=s.c;\n\t\t\t\t\tif(isdigit(f[tlx][tly])) tc+=f[tlx][tly]-'0';\n\n\t\t\t\t\tq.push(State(tlx,tly,s.rx,s.ry,tc,tf));\n\t\t\t\t}\n\t\t\t\tif(s.f==1)\n\t\t\t\t{\n\t\t\t\t\tint tlx=s.lx+dx[i], tly=s.ly+dy[i];\n\t\t\t\t\tint tf=(s.f+1)%2;\n\t\t\t\t\tif(tlx<0||tly<0||tlx>=W||tly>=H) continue;\n\t\t\t\t\tif(f[tlx][tly]=='X') continue;\n\t\t\t\t\tif(v[s.lx][s.ly][tlx][tly][tf]) continue;\n\n\t\t\t\t\tint tc=s.c;\n\t\t\t\t\tif(isdigit(f[tlx][tly])) tc+=f[tlx][tly]-'0';\n\n\t\t\t\t\tq.push(State(s.rx,s.ry,tlx,tly,tc,tf));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(!g) cout << -1 << endl;\n\t\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n \n#define INF 100000000\n#define EPS 1e-9\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX_W 30\n#define MAX_H 60\nint W, H;\nchar maze[MAX_H][MAX_W];\n\nvector<int> ans_list;\n\nint d[2][MAX_H][MAX_W];\nbool used[2][MAX_H][MAX_W];\n\n//右足を動かすとき\nint rdx[] = {1,1,2,1,2,3,1,2,1};\nint rdy[] = {-2,-1,-1,0,0,0,1,1,2};\n//左足を動かすとき\nint ldx[] = {-1,-1,-2,-1,-2,-3,-1,-2,-1};\nint ldy[] = {-2,-1,-1,0,0,0,1,1,2};\n\nvector<P> start_pos;\nvector<P> goal_pos;\n\nvoid solve(vector<P> dir[2][MAX_H][MAX_W]){\n  \n  /*\n  cout << endl << \"山の確認\" << endl;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      if(maze[i][j] != 'X')\n\tcout << maze[i][j] - '0' << \" \";\n      else\n\tcout << maze[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  */  \n\n  for(int i = 0; i < 2; i++){\n    for(int j = 0; j < H; j++){\n      for(int k = 0; k < W; k++){\n\td[i][j][k] = INF;\n\tused[i][j][k] = false;\n      }\n    }\n  }\n\n  for(int i = 0; i < start_pos.size(); i++){\n    for(int k = 0; k < 2; k++){\n      d[k][start_pos[i].second][start_pos[i].first] = 0;\n    }\n  }\n\n  while(true){\n\n    P kk;// k.first = x :: k.second = y\n    int mode = -1;// 左足か、右足どちらを動かすのか\n\n    for(int i = 0; i < 2; i++){\n      for(int j = 0; j < H; j++){\n\tfor(int k = 0; k < W; k++){\n\t  if(!used[i][j][k] && (mode == -1 || d[i][j][k] < d[mode][kk.second][kk.first])){\n\t    mode = i;\n\t    kk.first = k;\n\t    kk.second = j;\n\t  }\n\t}\n      }\n    }\n\n    if(mode == -1)\n      break;\n\n    //cout << mode << \" \" << kk.first << \" \" << kk.second << endl;\n\n    used[mode][kk.second][kk.first] = true;\n\n    mode = (mode + 1)%2;\n\n    for(int i = 0; i < dir[mode][kk.second][kk.first].size(); i++){\n      int x = dir[mode][kk.second][kk.first][i].first;\n      int y = dir[mode][kk.second][kk.first][i].second;\n      /*\n      if(d[mode][y][x] > d[(mode+1)%2][kk.second][kk.first]\n\t + maze[y][x] - '0'){\n\tprintf(\"ok  %d %d -> %d %d\\n\", kk.first, kk.second, x, y);\n\tcout << maze[y][x] << endl;\n      }\n      */\n      d[mode][y][x] = min(d[mode][y][x], \n\t\t\t  d[(mode+1)%2][kk.second][kk.first]\n\t\t\t  + maze[y][x] - '0');\n    }\n\n  }\n\n}\n\nint main(){\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0)\n      break;\n\n    start_pos.clear();\n    goal_pos.clear();\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> maze[i][j];\n\tif(maze[i][j] == 'S'){\n\t  start_pos.push_back(P(j,i));\n\t  maze[i][j] = '0';\n\t}\n\telse if(maze[i][j] == 'T'){\n\t  goal_pos.push_back(P(j,i));\n\t  maze[i][j] = '0';\n\t}\n      }\n    }\n\n    vector<P> dir[2][MAX_H][MAX_W]; //dir[0] : 右足を動かすとき dir[1] : 左足\n\n    //cout << \"道の生成開始\" << endl;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tif(maze[i][j] == 'X')\n\t  continue;\n\tfor(int k = 0; k < 9; k++){\n\t  int x = j + rdx[k];\n\t  int y = i + rdy[k];\n\t  if(x >= 0 && x < W && y >= 0 && y < H && maze[y][x] != 'X'){\n\t    dir[0][i][j].push_back(P(x,y));\n\t  }\n\t  x = j + ldx[k];\n\t  y = i + ldy[k];\n\t  if(x >= 0 && x < W && y >= 0 && y < H && maze[y][x] != 'X'){\n\t    dir[1][i][j].push_back(P(x,y));\n\t  }\n\t}\n      }\n    }\n\n    //cout << \"道の生成終了\" << endl;\n    //cout << \"探索開始\" << endl;\n\n    solve(dir);\n\n    //cout << \"探索終了\" << endl;\n\n    int ans = INF;\n\n    /*\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tprintf(\"%2d \", d[0][i][j]);\n      }\n      cout << endl;\n    }\n    */\n\n    for(int i = 0; i < goal_pos.size(); i++){\n      for(int k = 0; k < 2; k++){\n\tans = min(ans, d[k][goal_pos[i].second][goal_pos[i].first]);\n      }\n    }\n\n    ans_list.push_back(ans);\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    if(ans_list[i] == INF)\n      cout << -1 << endl;\n    else\n      cout << ans_list[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <string>\nusing namespace std;\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF (1<<28)\n\nint w, h;\nchar s[MAX_H][MAX_W];\nint m[MAX_H][MAX_W][2];\n\nconst int l = 0;\nconst int r = 1;\n\nstruct P {\n    int lx, ly;\n    int rx, ry;\n    int t;\n    int cur;\n    P() {}\n    P(int ly, int lx, int ry, int rx, int cur, int t) :\n        ly(ly), lx(lx), ry(ry), rx(rx), cur(cur), t(t) {}\n};\n\nint ldx[] = {-1, -1, -1, -1, -1,\n                 -2, -2, -2,\n                     -3\n};\nint ldy[] = {-2, -1, 0, 1, 2,\n                 -1, 0, 1,\n                     0\n};\nint rdx[] = {1, 1, 1, 1, 1,\n                2, 2, 2,\n                   3,\n};\nint rdy[] = {-2, -1, 0, 1, 2,\n                 -1, 0, 1,\n                     0\n};\n\nint bfs(int sy, int sx, int f) {\n    int ans = INF;\n    m[sy][sx][f] = 0;\n    queue<P> q;\n    if (f == r) q.push(P(sy, sx, -1, -1, f, 0));\n    else q.push(P(-1, -1, sy, sx, f, 0));\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        if (p.cur == l) {\n            for (int i = 0; i < 9; i++) {\n                int ny = p.ry + ldy[i];\n                int nx = p.rx + ldx[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && \n                        s[ny][nx] != 'X' && s[ny][nx] != 'S' && m[ny][nx][l] > p.t + s[ny][nx] - '0') {\n                    if (s[ny][nx] == 'T') {\n                        ans = min(ans, p.t);\n                        continue;\n                    }\n                    q.push(P(ny, nx, p.ry, p.rx, r, p.t+s[ny][nx]-'0'));\n                    m[ny][nx][l] = p.t + s[ny][nx] - '0';\n                }\n            }\n        } else {\n            for (int i = 0; i < 9; i++) {\n                int ny = p.ly + rdy[i];\n                int nx = p.lx + rdx[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && \n                        s[ny][nx] != 'X' && s[ny][nx] != 'S' && m[ny][nx][r] > p.t + s[ny][nx] - '0') {\n                    if (s[ny][nx] == 'T') {\n                        ans = min(ans, p.t);\n                        continue;\n                    }\n                    q.push(P(p.ly, p.lx, ny, nx, l, p.t+s[ny][nx]-'0'));\n                    m[ny][nx][r] = p.t + s[ny][nx] - '0';\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) \n                cin >> s[i][j];\n\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++)\n                m[i][j][l] = m[i][j][r] = INF;\n        int ans = INF;\n        for (int i = 0; i < w; i++) {\n            if (s[h-1][i] == 'S') {\n                ans = min(ans, bfs(h-1, i, l));\n                ans = min(ans, bfs(h-1, i, r));\n            }\n        }\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\n#include <cstdlib>\n#define H 60\n#define W 30\n#define SC signed char\n#define INF INT_MAX\n#define GOAL 10\n#define LABEL_X -1\n#define DEBUG false\nusing namespace std;\n\nint cost[H][W];\nSC s[H][W];\n\nint mv[9][2] = { // 右足の移動範囲( isL=falseの時 )\n  {1,-2},{1,-1},{1,0},{1,1},{1,2},\n  {2,-1},{2,0},{2,1},\n  {3,0}\n};\n\nint w,h;\nstruct P{\n  SC lx,ly, rx,ry;\n  bool isL; // 左足を動かすしたあとtrue\n  int cost; // 経過時間\n};\n\nvoid pr(P p ){\n  cout << \"(\"<<(int)p.lx<<\",\"<<(int)p.ly<<\") (\"\n       <<(int)p.rx<<\",\"<<(int)p.ry<<\") \"\n       << \"cost=\" << p.cost;\n  if( p.isL ) cout << \" left\" << endl;\n  else        cout << \" right\"<< endl;\n}\nvoid prCost(){\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ){\n      cout.width(11);\n      cout << cost[i][j];\n    }\n    cout << endl;\n  }\n}\n\n\nint main(){\n  queue<P> qu;\n  P p, q;\n\n  while( cin>>w >> h && (h||w) ){\n    p.lx=SCHAR_MAX; p.ly=SCHAR_MAX;\n    p.isL=true; p.cost=0;\n\n    while( !qu.empty() ) qu.pop();\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcost[i][j] = INT_MAX;\n\n\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tchar c;\n\tcin >> c;\n\tswitch( c ){\n\tcase 'S' : s[i][j] = 0;\n\t  p.rx=j; p.ry=i; p.lx=-1; p.isL=false;\n\t  qu.push( p );\n\t  p.lx=j; p.ly=i; p.rx=-1; p.isL=true;\n\t  qu.push( p );\n\t  break;\n\tcase 'T' : \n\t  s[i][j] = GOAL;\n\t  break;\n\tcase 'X' : s[i][j] = LABEL_X; break;\n\tdefault :  s[i][j] = c-'0';   break;\n\t}\n      }\n\n    int ans=INT_MAX, x,y;\n    while( !qu.empty() ){\n      p=qu.front(); qu.pop();\n      //      pr( p );\n\n      if( p.lx==p.rx && p.ly==p.ry ) continue;\n\n      if( p.isL ){ x=p.lx; y=p.ly; }\n      else {       x=p.rx; y=p.ry; }\n\n      if( x<0 || x>=w ) continue;\n      if( y<0 || y>=h ) continue;\n\n      if( s[y][x]==LABEL_X ) continue; // 'X'\n      \n      // goal\n      if( s[y][x]==GOAL ){\n\tif( ans > p.cost ){\n\t  ans = p.cost;\n\t  if( DEBUG ){\n\t    cout << \"*************************\"<< endl;\n\t    pr( p );\n\t  }\n\t}\n\tcontinue;\n      }\n\n      p.cost += s[y][x];\n      if( p.isL ){ // 左足をs[y][x] に置いたときの最小コスト\n\tif( p.cost >= cost[y][x] ) continue;\n\tcost[y][x] = p.cost;\n      }\n\n      if( DEBUG ){\n\tpr( p );\n\tprCost();\n      }\n      q=p;\n      if( p.isL ){ // 次に右足を動かす\n\tq.isL=false;\n\tfor( int i=0;i<9;i++ ){\n\t  q.rx = x + mv[i][0];\n\t  q.ry = y + mv[i][1];\n\t  qu.push( q );\n\t}\n      }else{     // 次に左足を動かす\n\tq.isL=true;\n\tfor( int i=0;i<9;i++ ){\n\t  q.lx = x - mv[i][0];\n\t  q.ly = y + mv[i][1];\n\t  qu.push( q );\n\t}\n      }\n    }\n    if( ans==INT_MAX ) ans = -1;\n    cout << ans << endl;\n\n    //    break;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\ntypedef pair<pair<int,int> ,pair<pair<int,int>,pair<int,int> > > p6;\n#define P6(a,b,c,d,e,f) make_pair(make_pair(a,b),make_pair(make_pair(c,d),make_pair(e,f)))\n#define P(a,b) make_pair(a,b)\n\nbool solve(){\n  int w,h;\n  char s[61][31];\n  bool dp[61][31][61][31][2] = {};\n  \n  scanf(\"%d%d\",&w,&h);\n\n  if(w == 0) return false;\n\n  priority_queue<p6> pq;\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\" %c\",s[i]+j);\n\n      if(s[i][j] == 'S'){\n        pq.push(P6(0,i,j,i,j,0));\n        pq.push(P6(0,i,j,i,j,1));\n      }\n    }\n  }\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n    \n    int cost = p.first.first;\n    int y1 = p.first.second;\n    int x1 = p.second.first.first;\n    int y2 = p.second.first.second;\n    int x2 = p.second.second.first;\n    int e = p.second.second.second;\n    \n    if(dp[y1][x1][y2][x2][e]) continue;\n    dp[y1][x1][y2][x2][e] = true;\n\n    if(s[y1][x1] == 'T' || s[y2][x2] == 'T'){\n      printf(\"%d\\n\",-cost);\n      return true;\n    }\n\n    for(int i=-2;i<=2;i++){\n      for(int j=1;j+abs(i)<=3;j++){\n        if(e == 0){\n          if(s[y1+i][x1+j] != 'X' &&\n             0 <= y1+i && y1+i < h &&\n             0 <= x1+j && x1+j < w){\n            int add_cost = (s[y1+i][x1+j]-'0')*(s[y1+i][x1+j] != 'T');\n            pq.push(P6(cost-add_cost,y1,x1,y1+i,x1+j,1));\n          }\n        }else{\n          if(s[y2+i][x2-j] != 'X' &&\n             0 <= y2+i && y2+i < h &&\n             0 <= x2-j && x2-j < w){\n            int add_cost = (s[y2+i][x2-j]-'0')*(s[y2+i][x2-j] != 'T');\n            pq.push(P6(cost-add_cost,y2+i,x2-j,y2,x2,0));\n          }\n        }\n      }\n    }\n  }\n\n  puts(\"-1\");\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\tint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\tint y[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\t\tset<int> t;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X') \n\t\t\t\t\tfield[i][j] = INF;\n\t\t\t\telse if(input == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tpq.push(feet(j, i, 0, 0));\n\t\t\t\t\tpq.push(feet(j, i, 1, 0));\n\t\t\t\t}\n\t\t\t\telse if(input == 'T') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tt.insert(j*100+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n/*\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tcout << field[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n//\t\t\tcout << f.x << ' ' << f.y << ' ' << f.cnt << ' ' << f.p << endl;\n\n\t\t\tif(t.count(f.x*100+f.y)) { // 'T'\n\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<9; i++) {\n\t\t\t\tfeet temp(f.x+x[i], f.y+y[i], !f.p, f.cnt+field[f.y+y[i]][f.x+x[i]]);\n\t\t\t\tif(f.p) {\n\t\t\t\t\ttemp.x = f.x-x[i];\n\t\t\t\t\ttemp.cnt = f.cnt+field[f.y+y[i]][f.x-x[i]];\n\t\t\t\t}\n\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\tif(field[temp.y][temp.x] != INF) { // 'x'\n\t\t\t\t\t\tif(temp.x < 0 || w-1 < temp.x || temp.y < 0 || h-1 < temp.y) { //out of range\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans==INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nchar map[64][32];\n\nclass Trl\n{\npublic:\n\tint lx, ly, rx, ry, c;\n\tbool n;\n\tTrl(int lx, int ly, int rx, int ry, int c, bool n)\n\t\t: lx(lx), ly(ly), rx(rx), ry(ry), c(c), n(n) {}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c > t.c;\n\t}\n};\n\nbool v[60][30][60][30];\nint dx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nint dy[] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\n\nint main()\n{\n\tint W, H;\n\twhile (cin >> W >> H, W||H)\n\t{\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tcin >> map[y][x];\n\n\t\tmemset(v, 0, sizeof(v));\n\t\tpriority_queue<Trl> q;\n\t\t\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tif (map[y][x] == 'S')\n\t\t\t{\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 1));\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 0));\n\t\t\t}\n\t\tbool f = 0;\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tTrl t = q.top(); q.pop();\n\n\t\t\tif (v[t.ly][t.lx][t.ry][t.rx]) continue;\n\t\t\tv[t.ly][t.lx][t.ry][t.rx] = 1;\n\n\t\t\tif (map[t.ly][t.lx]=='T' || map[t.ry][t.rx]=='T')\n\t\t\t{\n\t\t\t\tcout << t.c << endl;\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0; i<9; i++)\n\t\t\t{\n\t\t\t\tint nx, ny;\n\t\t\t\tTrl ne = t;\n\t\t\t\tif (t.n)\n\t\t\t\t{\n\t\t\t\t\tnx = t.lx + dx[i];\n\t\t\t\t\tny = t.ly + dy[i];\n\t\t\t\t\tne.rx = nx;\n\t\t\t\t\tne.ry = ny;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnx = t.rx - dx[i];\n\t\t\t\t\tny = t.ry - dy[i];\n\t\t\t\t\tne.lx = nx;\n\t\t\t\t\tne.ly = ny;\n\t\t\t\t}\n\n\t\t\t\tif (nx<0||nx>=W||ny<0||ny>=H) continue;\n\t\t\t\tif (map[ny][nx] == 'X') continue;\n\n\t\t\t\tif (map[ny][nx] != 'T' && map[ny][nx] != 'S')\n\t\t\t\t\tne.c += map[ny][nx] - '0';\n\t\t\t\t\n\t\t\t\tne.n = !ne.n;\n\t\t\t\tif (v[ne.ly][ne.lx][ne.ry][ne.rx]) continue;\n\t\t\t\tq.push(ne);\n\t\t\t}\n\t\t}\n\n\t\tif (!f)\n\t\t\tcout << -1 << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W,H;\nchar s[64][32];\nint dy[]={2,1,1,0,0,0,-1,-1,-2};\nint dx[]={1,1,2,1,2,3,1,2,1};\n\nstruct P{\n  int y,x,cost,prev;\n  P(int y, int x, int cost, int prev):y(y),x(x),cost(cost),prev(prev){}\n  bool operator>(const P& a)const{ return cost > a.cost; }\n};\n\nvoid dijkstra(){\n  int res = INF;\n  rep(i,2){\n    //    cout << i << endl;\n    int foot = i?1:-1;\n    int table[64][32][2];\n    rep(l,64) rep(j,32) rep(k,2) table[l][j][k] = INF;\n\n    priority_queue<P, vector<P>, greater<P> >q;\n    rep(x,W) if(s[H-1][x]=='S'){\n      q.push(P(H-1,x,0,foot));\n      table[H-1][x][foot] = 0;\n    }\n    //    cout << q.size() << endl;\n    while(!q.empty()){\n      P p = q.top(); q.pop();\n      int y = p.y, x = p.x, f = p.prev;\n      //      cout << y << \" \" << x << \" \" << f << endl;\n      if(table[y][x][(f+2)%3] < p.cost) continue;\n      f*= -1;\n      rep(d,9){\n\tint ny = y+dy[d], nx = x+f*dx[d];\n\tif(ny<0||ny>=H||nx<0||nx>=W||s[ny][nx]=='X') continue;\n\tif(s[ny][nx]=='T'){\n\t  res = min(res, p.cost);\n\t  break;\n\t}\n\tif(table[ny][nx][(2+f)%3] > p.cost + s[ny][nx]-'0'){\n\t  table[ny][nx][(2+f)%3] = p.cost+s[ny][nx]-'0';\n\t  q.push(P(ny, nx, table[ny][nx][(2+f)%3], f));\n\t}\n      }\n    }\n  }\n  cout << (res==INF?-1:res) << endl;\n  return;\n}\n\nint main(){\n  while(cin >> W >> H, W||H){\n    //    cout << W << \" \" << H <<endl;\n    rep(i,H) rep(j, W) cin >> s[i][j];\n    dijkstra();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <cassert>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint first,second,right;\n}POINT;\n\nint w,h;\n\nconst int HUGE_VALUE = 1000000;\n\ntypedef struct{\n\tchar s; //«ê\n\tint cost[2]; //±±ÜÅÌRXg\n\tbool used[2];\n\n\tint GetTime(){\n\t\tif(s == 'T' || s == 'S') return 0;\n\t\telse if(s == 'X') assert(true);\n\n\t\treturn s - '0';\n\t}\n} BLOCK;\n\nBLOCK blocks[60][30];\n\ntypedef pair<int,int> P;\nstatic P foots[] = {P(2,1),P(1,1),P(1,2),P(0,1),P(0,2),P(0,3),P(-1,1),P(-1,2),P(-2,1)};\n\nvoid DP()\n{\n\tqueue<POINT> p_q;\n\tfor(int i = 0; i < w; i++){\n\t\tif(blocks[h-1][i].s == 'S'){\n\t\t\tPOINT p;\n\t\t\tp.first = h-1,p.second = i;\n\t\t\tp.right = 0; p_q.push(p);\n\t\t\tp.right = 1; p_q.push(p);\n\t\t}\n\t}\n\n\twhile(!p_q.empty()){\n\t\tPOINT p= p_q.front(); p_q.pop();\n\t\tint s_h = p.first, s_w = p.second;\n\t\tif(blocks[s_h][s_w].used[p.right]) continue;\n\t\tblocks[s_h][s_w].used[p.right] = true;\n\t\tfor(int i = 0; i < sizeof(foots) / sizeof(P); i++){\n\t\t\tint next_h = s_h + ((p.right==0)?-1:1) * foots[i].first,next_w = s_w + ((p.right==0)?-1:1) * foots[i].second;\n\t\t\tif(next_h < 0 || next_h >= h || next_w < 0 || next_w >= w) continue; //«E´¦ \n\t\t\tBLOCK &next = blocks[next_h][next_w];\n\t\t\tif(next.s == 'X') continue; //±±ÉÍs¯È¢\n\t\t\tif(!next.used[p.right^1]){ //Ü¾«êðgÁÄÈ¢\n\t\t\t\tPOINT next_p;\n\t\t\t\tnext_p.first = next_h; next_p.second = next_w; next_p.right = p.right ^ 1;\n\t\t\t\tp_q.push(next_p); //ÌubNðÇÁ\n\t\t\t}\n\t\t\t//¬³¢Ù¤ªRXgÉÈé\n\t\t\tnext.cost[p.right ^ 1] = min(next.cost[p.right ^ 1],blocks[s_h][s_w].cost[p.right] + next.GetTime()); //RXgÇÁ\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tBLOCK &b = blocks[i][j];\n\t\t\tcin >> b.s;\n\t\t\tb.cost[0] = b.cost[1] = (b.s == 'S') ? 0 : HUGE_VALUE;\n\t\t\tb.used[0] = b.used[1] = false; //¶Eàú»\n\t\t}\n\t}\n\n\tDP();\n\n\tint min_cost = HUGE_VALUE;\n\tfor(int i = 0; i < w; i++){\n\t\tBLOCK &b = blocks[0][i];\n\t\tif(b.s == 'T')\n\t\t\tmin_cost = min(min_cost,min(b.cost[0],b.cost[1]));\n\t}\n\n\tcout << ((min_cost >= HUGE_VALUE) ? -1 : min_cost) << endl;\n}\n\nint main()\n{\n\twhile(cin >> w >>h,(w||h)){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint w,h;\nchar s[99][99];\nint cost[99][99][99][99][2];\n\nstruct Node{\n  int lx,ly,rx,ry;\n  int foot,cost;\n  bool operator<(const Node &r)const{\n    return cost>r.cost;\n  }\n};\nbool ok(Node &node){\n  int lx=node.lx,rx=node.rx,ly=node.ly,ry=node.ry;\n  if(lx<0||rx<0||ly<0||ry<0||lx>=w||rx>=w||ly>=h||ry>=h)return 0;\n     if(s[ly][lx]=='X'||s[ry][rx]=='X')return 0;\n     return lx<rx&&abs(lx-rx)+abs(ly-ry)<=3;\n}\n\nint main()\n{\n  while(cin>>w>>h,w){\n  \n    rep(i,h)rep(j,w)rep(ii,h)rep(jj,w)rep(k,2)cost[i][j][ii][jj][k]=inf;\n\n    priority_queue<Node>Q;\n    rep(i,h)rep(j,w){\n      cin>>s[i][j];\n      if(s[i][j]=='S'){\n\tNode node;\n\tnode.ry=-inf,node.rx=-inf;\n\tnode.ly=i,node.lx=j; node.foot=node.cost=0;\n\tQ.push(node);\n\tswap(node.ry,node.ly); swap(node.rx,node.lx);\n\tnode.foot=1;\n\tQ.push(node);\n      }\n    }\n    int ans=inf;\n    while(!Q.empty()){\n      Node cur=Q.top();\n      //dbg(cur.ly);dbg(cur.lx);dbg(cur.ry);dbg(cur.rx);\n      //dbg(cur.cost);dbg(cur.foot);\n      Q.pop();\n    \n      if(ok(cur)&&(s[cur.ly][cur.lx]=='T'||s[cur.ry][cur.rx]=='T')){\n\tans=cur.cost; break;\n      }\n\n      rep(y,h)rep(x,w){\n\tNode node=cur;\n\tif(node.foot==0)node.ry=y,node.rx=x;\n\telse node.ly=y,node.lx=x;\n\tnode.foot^=1;\n\tif(!ok(node))continue;\n\n\tnode.cost+=isdigit(s[y][x])?s[y][x]-'0':0;\n\tint &c=cost[node.ly][node.lx][node.ry][node.rx][node.foot];\n\tif(node.cost>=c)continue;\n\t\n\tc=node.cost;\n\tQ.push(node);\n      }\n    }\n    cout<<(ans==inf?-1:ans)<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = f.rx = i;\n\t\t\t\tf.ly = f.ry = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tpq.push(f);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1000*1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXH = 60;\nconst int MAXW = 30;\n\nint w, h;\nchar s[MAXH][MAXW];\n\nstruct State {\n  int lx, ly, rx, ry, f, cost;\n\n  bool operator < (const State &s) const {\n    if(lx != s.lx) return lx < s.lx;\n    if(ly != s.ly) return ly < s.ly;\n    if(rx != s.rx) return rx < s.rx;\n    if(ry != s.ry) return ry < s.ry;\n    if(f != s.f) return f < s.f;\n    return false;\n  }\n\n  bool ok() const {\n    return lx < rx && abs(lx-rx) + abs(ly-ry) <= 3;\n  }\n};\n\nstruct GT {\n  bool operator () (const State &a, const State &b) const {\n    return a.cost > b.cost;\n  }\n};\n\nint main() {\n  while(cin >> w >> h && (w|h)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        cin >> s[i][j];\n      }\n    }\n    try {\n      map<State, int> cost;\n      priority_queue<State, vector<State>, GT> que;\n      for(int x = 0; x < w; ++x) {\n        for(int y = 0; y < h; ++y) {\n          if(s[y][x] != 'S') continue;\n          State src = {x, y, x, y, 0, 0};\n          src.f = 0;\n          cost[src] = 0;\n          que.push(src);\n          src.f = 1;\n          cost[src] = 0;\n          que.push(src);\n        }\n      }\n      while(que.size()) {\n        const State a = que.top();\n        que.pop();\n        if(cost.count(a) && a.cost > cost[a]) continue;\n        int lx = a.lx, ly = a.ly, rx = a.rx, ry = a.ry;\n        int *x, *y;\n        if(a.f) x = &lx, y = &ly;\n        else x = &rx, y = &ry;\n        for(*x = 0; *x < w; ++*x) {\n          for(*y = 0; *y < h; ++*y) {\n            State b = {lx, ly, rx, ry, !a.f, a.cost};\n            if(!b.ok()) continue;\n            if(s[*y][*x] == 'X') continue;\n            if(s[*y][*x] == 'T') throw a.cost;\n            if(s[*y][*x] != 'S') b.cost += s[*y][*x] - '0';\n            if(cost.count(b) && b.cost >= cost[b]) continue;\n            cost[b] = b.cost;\n            que.push(b);\n          }\n        }\n      }\n      throw -1;\n    } catch(int res) {\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\n\nconst int inf=1<<29;\n\nint w,h;\nchar s[30][60];\n\n\nint dist[2][30][60][30][60];\n\n\n// cost l foot r foot isl\n\nstruct state{\n\tint cost;\n\tint last;\n\tint lw,lh;\n\tint rw,rh;\n\tbool operator>(const state &arg)const{\n\t\treturn cost > arg.cost;\n\t}\n};\n\nint dx[9]={1,1,1,1,1,2,2,2,3};\nint dy[9]={-2,-1,0,1,2,-1,0,1,0};\n\ninline bool valid(int ww,int hh){\n\treturn 0<=ww&&ww<w&&0<=hh&&hh<h;\n}\n\nint dijkstra(){\n\trep(a,2)rep(b,30)rep(c,60)rep(d,30)rep(e,60)\n\t\tdist[a][b][c][d][e]=inf;\n\n\tpriority_queue <state,vector<state>,greater<state> >q;\n\n\tstate init;\n\tinit.cost=0;\n\tinit.lw=-1,init.lh=-1;\n\tinit.rw=-1,init.rh=-1;\n\n\trep(i,w){\n\t\tif(s[i][h-1]=='S'){\n\t\t\tstate initl=init;\n\t\t\tstate initr=init;\n\t\t\tinitl.lw=i,initl.lh=h-1,initl.last=0;\n\t\t\tinitr.lw=i,initr.lh=h-1,initr.last=1;\n\t\t\tq.push(initl);\n\t\t\tq.push(initr);\n\t\t}\n\t}\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\t//cerr << cur.last << \" \" << cur.lw << \" \" << cur.lh << \" \" << cur.rw << \" \" <<cur.rh << endl;\n\t\tif(dist[cur.last][cur.lw][cur.lh][cur.rw][cur.rh]<cur.cost)\n\t\t\tcontinue;\n\n\t\tif(s[cur.lw][cur.lh]=='T'||s[cur.rw][cur.rh]=='T')\n\t\t\treturn cur.cost;\n\n\t\tif(cur.last){\n\t\t\trep(i,9){\n\t\t\t\tstate next=cur;\n\t\t\t\tnext.last^=1;\n\t\t\t\tnext.lw=next.rw-dx[i];\n\t\t\t\tnext.lh=next.rh+dy[i];\n\t\t\t\tif(!valid(next.lw,next.lh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(s[next.lw][next.lh]=='X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(isdigit(s[next.lw][next.lh])) next.cost+=s[next.lw][next.lh]-'0';\n\n\t\t\t\tif(dist[next.last][next.lw][next.lh][next.rw][next.rh]>next.cost){\n\t\t\t\t\tdist[next.last][next.lw][next.lh][next.rw][next.rh]=next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,9){\n\t\t\t\tstate next=cur;\n\t\t\t\tnext.last^=1;\n\t\t\t\tnext.rw=next.lw+dx[i];\n\t\t\t\tnext.rh=next.lh+dy[i];\n\t\t\t\tif(!valid(next.rw,next.rh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(s[next.rw][next.rh]=='X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(isdigit(s[next.rw][next.rh])) next.cost+=s[next.rw][next.rh]-'0';\n\n\t\t\t\tif(dist[next.last][next.lw][next.lh][next.rw][next.rh]>next.cost){\n\t\t\t\t\tdist[next.last][next.lw][next.lh][next.rw][next.rh]=next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(cin >> w >> h){\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\t\trep(j,h)rep(i,w) cin >> s[i][j];\n\t\tcout << dijkstra() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\n\nconst int INF = 1 << 28;\n\nint dlx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3}; \nint drx[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint dy[]  = {-2,-1, 0, 1, 2,-1, 0, 1, 0};\n\n\nint main ()\n{\n    int h, w;\n    while (cin >> w >> h, h + w) {\n        vector<vector<int> > field(h, vector<int>(w, INF));\n        vector<P> s;\n        vector<P> t;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char str;\n                cin >> str;\n                if ('0' <= str && str <= '9') {\n                    field[i][j] = (int)(str - '0');\n                } else if (str == 'T') {\n                    field[i][j] = 0;\n                    t.push_back(P(i,j));\n                } else if (str == 'S') {\n                    field[i][j] = 0;\n                    s.push_back(P(i,j));\n                } else if (str == 'X') {\n                    field[i][j] = INF;\n                }\n            }\n        }\n\n        priority_queue<PPP, vector<PPP>, greater<PPP> > que;\n        vector<vector<vector<int> > > d(2, vector<vector<int> >(h, vector<int>(w, INF)));\n        for (int i = 0; i < s.size(); i++) {\n            que.push(PPP(0, PP(0, P(s[i])) ) );\n            que.push(PPP(0, PP(1, P(s[i])) ) );\n            d[0][s[i].first][s[i].second] = 0;\n            d[1][s[i].first][s[i].second] = 0;\n        }\n\n        while (que.size()) {\n            PPP ppp = que.top(); que.pop();\n            int cost = ppp.first;\n            PP pp = ppp.second;\n            int dir = pp.first;\n            int y = pp.second.first;\n            int x = pp.second.second;\n\n            if (d[dir][y][x] < cost) continue;\n            \n            for (int i = 0; dir == 0 && i < 9; i++) {\n                int nx = drx[i] + x,\n                    ny = dy[i] + y;\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != INF) {\n                    if (d[1][ny][nx] > cost + field[ny][nx]) {\n                        d[1][ny][nx] = cost + field[ny][nx];\n                        que.push(PPP(d[1][ny][nx], PP(1, P(ny, nx) ) ) );\n                    }\n                }\n            }\n            \n            for (int i = 0; dir == 1 && i < 9; i++) {\n                int nx = dlx[i] + x,\n                    ny = dy[i] + y;\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != INF) {\n                    if (d[0][ny][nx] > cost + field[ny][nx]) {\n                        d[0][ny][nx] = cost + field[ny][nx];\n                        que.push(PPP(d[0][ny][nx], PP(0, P(ny, nx) ) ) );\n                    }\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < t.size(); i++) {\n            int y = t[0].first;\n            int x = t[0].second;\n            res = min(res, d[0][y][x]);\n            res = min(res, d[1][y][x]);\n        }\n\n        cout << (INF == res ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Node{\n    int x, y, cost, pos;\n    bool nxt;//?¬????????¶???????true, ????¶???????false\n    Node(int x, int y, int c, int p, bool n)\n         : x(x), y(y), cost(c), pos(p), nxt(n){}\n    bool operator> (const Node& N) const{\n        return cost > N.cost;\n    }\n};\nint W, H;\nchar fld[61][31];\nint dist[61][31][9][2];//????¶????????????¨?????????????????????????¶????????????¨?¬??????????????¶?\nconst int dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1}, dy[9] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int dx2[9] = {-1, -1, -2, -1, -2, -3, -1, -2, -1}, dy2[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nbool cant_go(int cx, int cy){\n    return cx < 0 || cy < 0 || W <= cx || H <= cy || fld[cy][cx] == 'X';\n}\ntypedef pair<int, int> pint;\nint solve(){\n    rep(i, 61) rep(j, 31) rep(k, 9) rep(l, 2) dist[i][j][k][l] = INF;\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    vector<int> goal;\n    rep(i, W) if(fld[0][i] == 'T'){\n        goal.push_back(i);\n        fld[0][i] = '0';\n    }\n    rep(i, W) if(fld[H - 1][i] == 'S'){\n        if(i != 0){//????¶??????????\n            que.push(Node(i - 1, H, 0, 1, false));\n            dist[H][i - 1][1][0] = 0;\n        }\n        if(i != W - 1){//????¶??????????\n            que.push(Node(i, H - 1, 0, 6, true));\n            dist[H - 1][i][6][1] = 0;\n        }\n        fld[H - 1][i] = '0';\n    }\n    while(!que.empty()){\n        Node cr = que.top(); que.pop();\n        if(dist[cr.y][cr.x][cr.pos][cr.nxt] < cr.cost) continue;\n        if(cr.nxt){\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int rx = cr.x + dx[i], ry = cr.y + dy[i];\n                if(cant_go(rx, ry)) continue;\n                int ncos = fld[ry][rx] - '0';\n                if(dist[cr.y][cr.x][i][0] > dist[cr.y][cr.x][cr.pos][1] + ncos){\n                    dist[cr.y][cr.x][i][0] = dist[cr.y][cr.x][cr.pos][1] + ncos;\n                    que.push(Node(cr.x, cr.y, dist[cr.y][cr.x][i][0], i, false));\n                }\n            }\n        }else{\n            int rx = cr.x + dx[cr.pos], ry = cr.y + dy[cr.pos];\n            rep(i, 9){\n                if(i == cr.pos) continue;\n                int lx = rx + dx2[i], ly = ry + dy2[i];\n                if(cant_go(lx, ly)) continue;\n                int ncos = fld[ly][lx] - '0';\n                if(dist[ly][lx][i][1] > dist[cr.y][cr.x][cr.pos][0] + ncos){\n                    dist[ly][lx][i][1] = dist[cr.y][cr.x][cr.pos][0] + ncos;\n                    que.push(Node(lx, ly, dist[ly][lx][i][1], i, true));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for(int k : goal){\n        rep(i, 9) ans = min(ans, dist[0][k][i][1]);\n        rep(i, 9){\n            int gx = k + dx2[i], gy = 0 + dy2[i];\n            if(cant_go(gx, gy)) continue;\n            ans = min(ans, dist[gy][gx][i][0]);\n        }\n    }\n    return ans == INF ? -1 : ans;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H && W){\n        rep(i, H) rep(j, W) cin >> fld[i][j];\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=5005,INF=1<<28;\nvector<pair<int,ll>> G[MAX];\nll dis[MAX];\nint H,W;\n\nvoid dijkstra(vector<int> s){\n    \n    priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> PQ;\n    \n    for(int j:s){\n        dis[(H-1)*W+j]=0;\n        dis[H*W+(H-1)*W+j]=0;\n        \n        PQ.push(make_pair(0,(H-1)*W+j));\n        PQ.push(make_pair(0,H*W+(H-1)*W+j));\n    }\n    \n    while(!PQ.empty()){\n        ll a=PQ.top().first;\n        int b=PQ.top().second;\n        PQ.pop();\n        if(dis[b]<a) continue;\n        for(int i=0;i<G[b].size();i++){\n            int c=G[b][i].first;\n            ll d=G[b][i].second;\n            if(dis[c]>dis[b]+d){\n                dis[c]=dis[b]+d;\n                PQ.push(make_pair(dis[c],c));\n            }\n        }\n    }\n    return;\n}//a,dが長さ\n\nvector<int> dh={-2,-1,-1,0,0,0,1,1,2},lw={-1,-2,-1,-3,-2,-1,-2,-1,-1},rw={1,1,2,1,2,3,1,2,1};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>W>>H;\n        if(H+W==0) break;\n        \n        for(int i=0;i<2*H*W;i++){\n            dis[i]=INF;\n            G[i].clear();\n        }\n        \n        vector<vector<char>> S(H,vector<char>(W));\n        vector<int> s,g;\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>S[i][j];\n                if(S[i][j]=='S') s.push_back(j);\n                if(S[i][j]=='T') g.push_back(j);\n            }\n        }\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<9;k++){\n                    int toh=i+dh[k],tow=j+rw[k];\n                    \n                    if(toh<0||toh>=H||tow<0||tow>=W) continue;\n                    \n                    if(S[toh][tow]=='X') continue;\n                    \n                    if(S[toh][tow]=='S'||S[toh][tow]=='T'){\n                        G[i*W+j].push_back({H*W+toh*W+tow,0});\n                    }else{\n                        G[i*W+j].push_back({H*W+toh*W+tow,int(S[toh][tow]-'0') });\n                    }\n                }\n                \n                for(int k=0;k<9;k++){\n                    int toh=i+dh[k],tow=j+lw[k];\n                    \n                    if(toh<0||toh>=H||tow<0||tow>=W) continue;\n                    \n                    if(S[toh][tow]=='X') continue;\n                    \n                    if(S[toh][tow]=='S'||S[toh][tow]=='T'){\n                        G[H*W+i*W+j].push_back({toh*W+tow,0});\n                    }else{\n                        G[H*W+i*W+j].push_back({toh*W+tow,int(S[toh][tow]-'0') });\n                    }\n                }\n            }\n        }\n        \n        dijkstra(s);\n        \n        ll ans=INF;\n        \n        for(int j:g){\n            ans=min(ans,dis[j]);\n            ans=min(ans,dis[H*W+j]);\n        }\n        \n        if(ans==INF) cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<(int)N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\nint dp[61][31][2];\nint ccdx[9]={1,1,1,1,1,2,2,2,3};\nint ccdy[9]={2,1,0,-1,-2,1,0,-1,0};\nstruct st{\n\tint nx,ny,nlr;\n\tst(int _nlr,int _nx,int _ny){\n\t\tnlr = _nlr;\n\t\tnx = _nx;\n\t\tny = _ny;\n\t}\n};\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tREP(i,0,61) REP(j,0,31) REP(k,0,2) dp[i][j][k]=inf;\n\t\tchar field[61][31];\n\t\tstack<st> s;//L or R ,(x,y)\n\t\tvector<pair<int,int>> vt;\n\t\tREP(i,0,h) REP(j,0,w) {\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S') {\n\t\t\t\ts.push(st(0,j,i));\n\t\t\t\ts.push(st(1,j,i));\n\t\t\t\tdp[i][j][0]=dp[i][j][1]=0;\n\t\t\t}else if(field[i][j]=='T') {\n\t\t\t\tvt.push_back({j,i});\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tst now=s.top();s.pop();\n\t\t\tREP(i,0,9){\n\t\t\t\tst next=st(0,0,0);\n\t\t\t\tif(now.nlr%2)\tnext=st(1-now.nlr,now.nx+ccdx[i],now.ny+ccdy[i]);\n\t\t\t\telse\tnext=st(1-now.nlr,now.nx-ccdx[i],now.ny+ccdy[i]);\n\t\t\t\tif(!ck(next.nx,0,w)||!ck(next.ny,0,h)) continue;\n\t\t\t\tif(isdigit(field[next.ny][next.nx])){\n\t\t\t\t\tif(dp[next.ny][next.nx][next.nlr]>dp[now.ny][now.nx][now.nlr]+(field[next.ny][next.nx]-'0')){\n\t\t\t\t\t\tdp[next.ny][next.nx][next.nlr]=dp[now.ny][now.nx][now.nlr]+(field[next.ny][next.nx]-'0');\n\t\t\t\t\t\ts.push(st(next.nlr,next.nx,next.ny));\n\t\t\t\t\t}\n\t\t\t\t}else if(field[next.ny][next.nx]=='T'){\n\t\t\t\t\tdp[next.ny][next.nx][next.nlr]=min(dp[next.ny][next.nx][next.nlr],dp[now.ny][now.nx][now.nlr]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint ans=inf;\n\t\tREP(i,0,vt.size())\t\tans=min(ans,min(dp[vt[i].S][vt[i].F][0],dp[vt[i].S][vt[i].F][1]));\n\t\tp(ans==inf?-1:ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\n\nconst int inf=1<<29;\n\nint w,h;\nchar s[30][60];\n\n\nint dist[2][30][60][30][60];\n\n\n// cost l foot r foot isl\n\nstruct state{\n\tint cost;\n\tint last;\n\tint lw,lh;\n\tint rw,rh;\n\tbool operator>(const state &arg)const{\n\t\treturn cost > arg.cost;\n\t}\n};\n\nint dx[9]={1,1,1,1,1,2,2,2,3};\nint dy[9]={-2,-1,0,1,2,-1,0,1,0};\n\ninline bool valid(int ww,int hh){\n\treturn 0<=ww&&ww<w&&0<=hh&&hh<h;\n}\n\nint dijkstra(){\n\trep(a,2)rep(b,30)rep(c,60)rep(d,30)rep(e,60)\n\t\tdist[a][b][c][d][e]=inf;\n\n\tpriority_queue <state,vector<state>,greater<state> >q;\n\n\tstate init;\n\tinit.cost=0;\n\tinit.lw=-1,init.lh=-1;\n\tinit.rw=-1,init.rh=-1;\n\n\trep(i,w){\n\t\tif(s[i][h-1]=='S'){\n\t\t\tstate initl=init;\n\t\t\tstate initr=init;\n\t\t\tinitl.lw=i,initl.lh=h-1,initl.last=0;\n\t\t\tinitr.rw=i,initr.rh=h-1,initr.last=1;\n\t\t\tq.push(initl);\n\t\t\tq.push(initr);\n\t\t}\n\t}\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t//\tcerr << cur.last << \" \" << cur.lw << \" \" << cur.lh << \" \" << cur.rw << \" \" <<cur.rh << endl;\n\t//\tcerr << cur.cost << endl;\n\n\t\tif(dist[cur.last][cur.lw][cur.lh][cur.rw][cur.rh]<cur.cost)\n\t\t\tcontinue;\n\n\t\tif(s[cur.lw][cur.lh]=='T'||s[cur.rw][cur.rh]=='T')\n\t\t\treturn cur.cost;\n\n\t\tif(cur.last){\n\t\t\trep(i,9){\n\t\t\t\tstate next=cur;\n\t\t\t\tnext.last^=1;\n\t\t\t\tnext.lw=next.rw-dx[i];\n\t\t\t\tnext.lh=next.rh+dy[i];\n\t\t\t\tif(!valid(next.lw,next.lh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(s[next.lw][next.lh]=='X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(isdigit(s[next.lw][next.lh])) next.cost+=s[next.lw][next.lh]-'0';\n\n\t\t\t\tif(dist[next.last][next.lw][next.lh][next.rw][next.rh]>next.cost){\n\t\t\t\t\tdist[next.last][next.lw][next.lh][next.rw][next.rh]=next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\trep(i,9){\n\t\t\t\tstate next=cur;\n\t\t\t\tnext.last^=1;\n\t\t\t\tnext.rw=next.lw+dx[i];\n\t\t\t\tnext.rh=next.lh+dy[i];\n\t\t\t\tif(!valid(next.rw,next.rh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(s[next.rw][next.rh]=='X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(isdigit(s[next.rw][next.rh])) next.cost+=s[next.rw][next.rh]-'0';\n\n\t\t\t\tif(dist[next.last][next.lw][next.lh][next.rw][next.rh]>next.cost){\n\t\t\t\t\tdist[next.last][next.lw][next.lh][next.rw][next.rh]=next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(cin >> w >> h){\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\t\trep(j,h)rep(i,w) cin >> s[i][j];\n\t\tcout << dijkstra() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct D\n{\n\tint ry,rx,ly,lx,t,s;//r l y x  0-nextR 1-nextL\n\tbool operator <(const D& a)const{return a.t<t;};\n}D;\n\nint W,H,F[63][33][2],ans,mv[9][2]={{-2,1},{-1,1},{-1,2},{0,1},{0,2},{0,3},{1,1},{1,2},{2,1}};\nchar C[63][33];\n\nbool check(int y,int x)\n{\n\treturn 0<=y&&y<H&&0<=x&&x<W?true:false;\n}\n\nint cost(int y,int x)\n{\n\tif('0'<=C[y][x]&&C[y][x]<='9')return C[y][x]-'0';\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W+H;)\n\t{\n\t\tmemset(F,0x7f,sizeof(F));\n\t\tans=1000000000;\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tscanf(\"%c%*c\",&C[i][j]);\n\t\tpriority_queue<D>Q;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tD tmp={H-1,0,H-1,0,0,0};\n\t\t\tif(C[H-1][i]=='S')\n\t\t\t{\n\t\t\t\tF[H-1][i][0]=F[H-1][i][1]=0;\n\t\t\t\ttmp.lx=tmp.rx=i;\n\t\t\t\tQ.push(tmp);\n\t\t\t\ttmp.s=1;\n\t\t\t\tQ.push(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\tD t=Q.top();Q.pop();\n\t\t\tif(C[t.ly][t.lx]=='T'||C[t.ry][t.rx]=='T')\n\t\t\t{\n\t\t\t\tans=min(ans,t.t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(t.s==0)//move right leg\n\t\t\t{\n\t\t\t\tfor(int i=0;i<9;i++)\n\t\t\t\t{\n\t\t\t\t\tint nry=t.ly+mv[i][0],nrx=t.lx+mv[i][1];\n\t\t\t\t\tif(check(nry,nrx)&&C[nry][nrx]!='X'&&F[nry][nrx][t.s]>t.t+cost(nry,nrx))\n\t\t\t\t\t{\n\t\t\t\t\t\tF[nry][nrx][t.s]=t.t+cost(nry,nrx);\n\t\t\t\t\t\tD ins={nry,nrx,t.ly,t.lx,t.t+cost(nry,nrx),1};\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i=0;i<9;i++)\n\t\t\t\t{\n\t\t\t\t\tint nly=t.ry+mv[i][0],nlx=t.rx-mv[i][1];\n\t\t\t\t\tif(check(nly,nlx)&&C[nly][nlx]!='X'&&F[nly][nlx][t.s]>t.t+cost(nly,nlx))\n\t\t\t\t\t{\n\t\t\t\t\t\tF[nly][nlx][t.s]=t.t+cost(nly,nlx);\n\t\t\t\t\t\tD ins={t.ry,t.rx,nly,nlx,t.t+cost(nly,nlx),0};\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans==1000000000?-1:ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\tint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\tint y[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10) field[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X') field[i][j] = 10;\n\t\t\t\telse if(input == 'S') field[i][j] = 11;\n\t\t\t\telse if(input == 'T') field[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tpq.push(feet(j, i, 0, 0));\n\t\t\t\t\tpq.push(feet(j, i, 1, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.x < 0 || w-1 < f.x || f.y < 0 || h-1 < f.y) continue; //out of range\n\t\t\tif(field[f.y][f.x] == 10) continue; // 'x'\n\t\t\tif(field[f.y][f.x] == 12) { // 'T'\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<8; i++) {\n\t\t\t\tfeet temp(f.x+x[i], f.y+y[i], !f.p, f.cnt+field[f.y+y[i]][f.x+x[i]]);\n\t\t\t\tif(f.p) {\n\t\t\t\t\ttemp.x = f.x-x[i];\n\t\t\t\t\ttemp.cnt = f.cnt+field[f.y+y[i]][f.x-x[i]];\n\t\t\t\t}\n\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\tpq.push(temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans==INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\nint dist[60][30][60][30];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  int w, h;\n  while (cin >> w >> h)\n  {\n    if (w == 0 && h == 0)\n      break;\n    vector<vector<char>> v(h, vector<char>(w));\n    REP(i, h)\n    {\n      REP(j, w)\n      {\n        cin >> v[i][j];\n      }\n    }\n    REP(i, h)\n    {\n      REP(j, w)\n      {\n        REP(k, h)\n        {\n          REP(l, w)\n          {\n            dist[i][j][k][l] = INT_MAX;\n          }\n        }\n      }\n    }\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;\n    vector<int> tmp;\n    int mi = INT_MAX;\n    REP(i, h)\n    {\n      REP(j, w)\n      {\n        if (v[i][j] == 'S')\n        {\n\n          {\n            //左足を(i, j)とする\n            int y1 = i, x1 = j;\n            for (int dy = -2; dy <= 2; dy++)\n            {\n              for (int dx = 1; dx <= 3; dx++)\n              {\n                int ny2 = y1 + dy, nx2 = x1 + dx;\n\n                if (ny2 >= 0 && ny2 < h && nx2 >= 0 && nx2 < w && x1 < nx2 && abs(y1 - ny2) + abs(x1 - nx2) <= 3)\n                {\n                  if (v[ny2][nx2] == 'T')\n                  {\n                    mi = 0;\n                  }\n                  else if (v[ny2][nx2] != 'X')\n                  {\n                    dist[y1][x1][ny2][nx2] = v[ny2][nx2] - '0';\n                    q.push(make_pair(dist[y1][x1][ny2][nx2], make_pair(y1 * w + x1, ny2 * w + nx2)));\n                  }\n                }\n              }\n            }\n          }\n          {\n            //右足を(i, j)とする\n            int y2 = i, x2 = j;\n\n            for (int dy = -2; dy <= 2; dy++)\n            {\n              for (int dx = -3; dx <= -1; dx++)\n              {\n                int ny1 = y2 + dy, nx1 = x2 + dx;\n                if (ny1 >= 0 && ny1 < h && nx1 >= 0 && nx1 < w && nx1 < x2 && abs(ny1 - y2) + abs(nx1 - x2) <= 3)\n                {\n                  if (v[ny1][nx1] == 'T')\n                  {\n                    mi = 0;\n                  }\n                  else if (v[ny1][nx1] != 'X')\n                  {\n                    dist[ny1][nx1][y2][x2] = v[ny1][nx1] - '0';\n                    q.push(make_pair(dist[ny1][nx1][y2][x2], make_pair(ny1 * w + nx1, y2 * w + x2)));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    while (q.size())\n    {\n\n      auto p = q.top();\n      q.pop();\n\n      int d = p.first;\n      int y1 = p.second.first / w, x1 = p.second.first % w, y2 = p.second.second / w, x2 = p.second.second % w;\n      //cout << y1 << \" \" << x1 << \" \" << y2 << \" \" << x2 << endl;\n      //左足について調べる\n      for (int dy = -2; dy <= 2; dy++)\n      {\n        for (int dx = -3; dx <= -1; dx++)\n        {\n          int ny1 = y2 + dy, nx1 = x2 + dx;\n          if (ny1 >= 0 && ny1 < h && nx1 >= 0 && nx1 < w && nx1 < x2 && abs(ny1 - y2) + abs(nx1 - x2) <= 3)\n          {\n            if (v[ny1][nx1] == 'T')\n            {\n              mi = min(mi, d);\n            }\n            else if (v[ny1][nx1] != 'X' && dist[ny1][nx1][y2][x2] > dist[y1][x1][y2][x2] + v[ny1][nx1] - '0')\n            {\n              dist[ny1][nx1][y2][x2] = dist[y1][x1][y2][x2] + v[ny1][nx1] - '0';\n              q.push(make_pair(dist[ny1][nx1][y2][x2], make_pair(ny1 * w + nx1, y2 * w + x2)));\n            }\n          }\n        }\n      }\n      //右足について調べる\n      for (int dy = -2; dy <= 2; dy++)\n      {\n        for (int dx = 1; dx <= 3; dx++)\n        {\n          int ny2 = y1 + dy, nx2 = x1 + dx;\n\n          if (ny2 >= 0 && ny2 < h && nx2 >= 0 && nx2 < w && x1 < nx2 && abs(y1 - ny2) + abs(x1 - nx2) <= 3)\n          {\n            if (v[ny2][nx2] == 'T')\n            {\n              mi = min(mi, d);\n            }\n            else if (v[ny2][nx2] != 'X' && dist[y1][x1][ny2][nx2] > dist[y1][x1][y2][x2] + v[ny2][nx2] - '0')\n            {\n              dist[y1][x1][ny2][nx2] = dist[y1][x1][y2][x2] + v[ny2][nx2] - '0';\n              q.push(make_pair(dist[y1][x1][ny2][nx2], make_pair(y1 * w + x1, ny2 * w + nx2)));\n            }\n          }\n        }\n      }\n    }\n    if (mi == INT_MAX)\n    {\n      cout << -1 << endl;\n    }\n    else\n    {\n      cout << mi << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000\nint dy[9]={1,1,1,1,1,2,2,2,3};\nint dx[9]={2,1,0,-1,-2,1,0,-1,0};\nint d[2][60][30];\nint cost[60][30];\nbool used[2][60][30];\nint w,h;\nbool check(int i,int j,int k){\n\tif(j>=0&&j<h&&k>=0&&k<w&&!used[i][j][k]&&cost[j][k]!=-1)return true;\n\treturn false;\n}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\twhile(1){\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tint i,j,k;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\td[0][i][j]=INF;\n\t\t\td[1][i][j]=INF;\n\t\t\tused[0][i][j]=false;\n\t\t\tused[1][i][j]=false;\n\t\t\tcost[i][j]=-1;\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='T')cost[i][j]=0;\n\t\t\telse if(c=='S'){\n\t\t\t\td[0][i][j]=0;\n\t\t\t\td[1][i][j]=0;\n\t\t\t}\n\t\t\telse if(c!='X')cost[i][j]=c-'0';\n\t\t}\n\t}\n\twhile(1){\n\t\tint ni=-1,nj,nk;\n\t\tfor(i=0;i<2;i++)for(j=0;j<h;j++)for(k=0;k<w;k++)if(!used[i][j][k]&&(ni==-1||d[i][j][k]<d[ni][nj][nk])){ni=i;nj=j;nk=k;}\n\t\tif(ni==-1)break;\n\t\tused[ni][nj][nk]=true;\n\t\tfor(i=0;i<9;i++){\n\t\t\tint x=nj+dx[i];\n\t\t\tint y=nk;\n\t\t\tif(ni==0)y+=dy[i];\n\t\t\telse y-=dy[i];\n\t\t\tif(check((ni+1)%2,x,y)){\n\t\t\t\tif(d[(ni+1)%2][x][y]>d[ni][nj][nk]+cost[x][y]){\n\t\t\t\t\td[(ni+1)%2][x][y]=d[ni][nj][nk]+cost[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(cost[i][j]==0){\n\t\t\t\tans=min(ans,d[0][i][j]);\n\t\t\t\tans=min(ans,d[1][i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans==INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\nenum LR{L,R};\n\nstruct Info{\n\tint x,y;\n\tLR bef;\n\tInfo(int _x,int _y,LR _bef){ x=_x,y=_y,bef=_bef; }\n};\n\nbool operator<(const Info &i1,const Info &i2){\n\treturn true;\n}\n\nchar clif[60][30];\nint tmin[60][30][2];\nbool visited[60][30][2];\nconst int dx[]={1,1,1,1,1,2,2,2,3};\nconst int dy[]={-2,-1,0,1,2,-1,0,1,0};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d \",&w,&h),w;){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%c \",clif[i]+j);\n\n\t\tpriority_queue< pair<int,Info> > pq;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(clif[i][j]=='S'){\n\t\t\t\tpq.push(mp(0,Info(j,i,L)));\n\t\t\t\tpq.push(mp(0,Info(j,i,R)));\n\t\t\t\tclif[i][j]='0';\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\ttmin[i][j][k]=1<<30;\n\t\t\t\tvisited[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t\tint ans=-1;\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,Info> a=pq.top();\tpq.pop();\n\t\t\tint t=-a.first,x=a.second.x,y=a.second.y;\n\t\t\tLR bef=a.second.bef;\n\t\t\tif(visited[y][x][bef])\tcontinue;\n\t\t\tvisited[y][x][bef]=true;\n\n\t\t\tif(clif[y][x]=='T'){ ans=t; break; }\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint xx,yy;\n\t\t\t\tif(bef==L)\txx=x+dx[i],yy=y+dy[i];\n\t\t\t\telse\t\txx=x-dx[i],yy=y-dy[i];\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h\n\t\t\t\t&& clif[yy][xx]!='X' && !visited[yy][xx][bef]){\n\t\t\t\t\tint nextt=t+(clif[yy][xx]=='T'?0:clif[yy][xx]-'0');\n\t\t\t\t\tLR foot=(bef==L?R:L);\n\t\t\t\t\tif(nextt<tmin[yy][xx][bef]){\n\t\t\t\t\t\tpq.push(mp(-nextt,Info(xx,yy,foot)));\n\t\t\t\t\t\ttmin[yy][xx][bef]=nextt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// start: 21:57\n// AC: 00:12\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\n// 左足のときに置ける右足\nint mx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    my[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nvoid dump(vector< vector<char> > &f, int x = -1, int y = -1, int l = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == y && j == x ) {\n                if ( l == 0 )\n                    cout << \"R\";\n                else\n                    cout << \"L\";\n            }\n            else\n                cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        int closed[h][w][2];\n        vector< queue<xy> > foot(2);   // 0:右 1:左\n        queue<int> cost, leg;\n        vector< vector<char> > f(h);\n        vector< xy > start;\n\n        REP(i, h) REP(j, w) REP(k, 2) closed[i][j][k] = 0;\n\n        REP(i, h) {\n            REP(j, w) {\n                char tmp;\n                cin >> tmp;\n                f[i].push_back(tmp);\n                if ( f[i][j] == 'S' ) {\n                    start.push_back( make_pair(j, i) );\n                }\n            }\n        }\n\n        // スタート地点＋左右を初期値としてpush\n        REP(i, start.size()) {\n            int l = 0;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n\n            l = 1;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n        }\n\n        int min = INT_MAX;\n        while(!cost.empty()) {\n            int c = cost.front(); cost.pop();\n            int l = leg.front(); leg.pop();\n            xy ft = foot[l].front(); foot[l].pop();\n            int x = ft.first, y = ft.second;\n\n            // printf(\"f:%d, x:%d, y:%d, xy:%c\\n\", l, x, y, f[y][x]);\n            // dump(f, x, y, l);\n            if ( f[y][x] == 'T' && c < min ) {\n                min = c;\n                continue;\n            }\n\n            REP(i, 9) {\n                int dir = l == 0 ? -1: 1,\n                    nx = x + mx[i] * dir,\n                    ny = y + my[i],\n                    nl = !l;\n\n                if ( !(0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n                if ( f[ny][nx] == 'X' || f[ny][nx] == 'S' ) continue;   // バグ出るかも\n\n                int nc;\n                if ( ((int)f[ny][nx] - 48) > 9 )\n                    nc = c + 1;\n                else\n                    nc = c + ((int)f[ny][nx] - 48);\n\n                if ( closed[ny][nx][nl] != 0 && closed[ny][nx][nl] < nc ) continue;\n\n                cost.push(nc);\n                leg.push(nl);   // 逆足\n                foot[nl].push( make_pair(nx, ny) );\n                closed[ny][nx][nl] = nc;\n\n            }\n        }\n\n        if ( min == INT_MAX )\n            cout << -1 << endl;\n        else\n            cout << (min-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<p,p> P;\n\nchar mp[60][30];\nint w,h;\nint cal(){\n  bool used[2][60][30]={};\n  int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0};\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<w;i++)\n    if(mp[h-1][i]=='S')q.push(P(p(0,0),p(i,h-1))),q.push(P(p(0,1),p(i,h-1)));\n  while(!q.empty()){\n    int s=q.top().first.first,l=q.top().first.second;\n    int x=q.top().second.first,y=q.top().second.second;\n    q.pop();\n    if(mp[y][x]=='T')return s;\n    used[l][y][x]=1;\n    int f=1,c=0;\n    if(l)f=-1;\n    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n    for(int d=0;d<9;d++){\n      int nx=x+f*dx[d],ny=y+f*dy[d];\n      if(nx<0||w<=nx||ny<0||h<=ny||mp[ny][nx]=='X'||used[!l][ny][nx])continue;\n      q.push(P(p(s+c,!l),p(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    cout<<cal()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int W_MAX = 30;\nconst int H_MAX = 60;\nconst bool L = 0;\nconst bool R = 1;\n\ntypedef pair<int, int> P;\nconst int INF = INT_MAX;\nint w, h;\n\nchar board[H_MAX][W_MAX];\nint weight[H_MAX][W_MAX];\nint d[H_MAX][W_MAX][2];\n\ntypedef struct node{\n  int cost;\n  P pos;\n  bool f;\n  bool operator>(const node& s) const {\n    return this->cost > s.cost;\n  }\n}node;\n\ntypedef struct edge{\n  int cost;\n  P to;\n}edge;\n\nvector<P> start;\nP p_pos;\nP dxy[9] = {P(1, -2), P(1, -1), P(1, 0),\n            P(1, 1), P(1, 2), P(2, -1),\n            P(2, 0), P(2, 1), P(3, 0)};\n\nbool check_pos(P pos) {\n  if(0 <= pos.second && pos.second < h &&\n     0 <= pos.first && pos.first < w &&\n     !(board[pos.second][pos.first] == 'X')) return false;\n  return true;\n}\n\nint solve() {\n  fill(d[0][0], d[H_MAX][0], INF);\n  priority_queue<node, vector<node>, greater<node>> pq;\n  for(auto i: start) {\n    d[i.second][i.first][0] = 0;\n    d[i.second][i.first][1] = 0;\n    pq.push(node{0, P(i.first, i.second), L});\n    pq.push(node{0, P(i.first, i.second), R});\n  }\n\n  while(!pq.empty()) {\n    P pos = pq.top().pos;\n    bool f = pq.top().f;\n    pq.pop();\n    if (board[pos.second][pos.first] == 'T') {\n      return d[pos.second][pos.first][f];\n    }\n    for(int i = 0; i < 9; i++) {\n      int nextx = pos.first  + (f ? dxy[i].first : -dxy[i].first);\n      int nexty = pos.second + (f ? dxy[i].second : -dxy[i].second);\n      if(check_pos(P(nextx, nexty))) continue;\n      if(d[nexty][nextx][!f] > d[pos.second][pos.first][f] +\n         weight[nexty][nextx]) {\n        d[nexty][nextx][!f] =\n          d[pos.second][pos.first][f] + weight[nexty][nextx];\n        pq.push(node{d[nexty][nextx][!f], P(nextx, nexty), !f});\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> w >> h && !(w + h == 0)) {\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        cin >> board[i][j];\n        if(board[i][j] == 'S') {\n          weight[i][j] = 0;\n          start.push_back(P(j, i));\n        }else if(board[i][j] == 'T') {\n          weight[i][j] = 0;\n        }else {\n          weight[i][j] = (int) (board[i][j] - '0');\n        }        \n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint txr[] = {1,1,1,1,1,2,2,2,3};\nint tyr[] = {-2,-1,0,1,2,-1,0,1,0};\n\n\nint txl[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint tyl[] = {-2,-1,0,1,2,-1,0,1,0};\n\nchar stage[60][30];\nint cost[1800][1800];\n\nclass Data{\npublic:\n\tint cost;\n\tint rhs;\n\tint lhs;\n\tbool turn;\n\tData(int _cost,int _lhs,int _rhs,bool _turn){\n\t\tcost = _cost;\n\t\tlhs = _lhs;\n\t\trhs = _rhs;\n\t\tturn = _turn;\n\t}\n\n\tbool operator>(const Data& d) const{\n\t\treturn cost > d.cost;\n\t}\n};\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tmemset(cost,0x3f,sizeof(cost));\n\t\tvector<P> S;\n\t\tvector<P> T;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%s\",&stage[y][x]);\n\t\t\t\tif(stage[y][x]=='S') S.push_back(P(x,y));\n\t\t\t\tif(stage[y][x]=='T') T.push_back(P(x,y));\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\n\t\tfor(int i=0;i<S.size();i++){\n\t\t\tint x = S[i].first;\n\t\t\tint y = S[i].second;\n\t\t\tque.push(Data(0,y*w+x,y*w+x,false));\n\t\t\tque.push(Data(0,y*w+x,y*w+x,true));\n\t\t}\n\n\t\tint res = numeric_limits<int>::max();\n\t\twhile(!que.empty()){\n\t\t\tData d = que.top();\n\n\t\t\tint srx = d.rhs % w;\n\t\t\tint sry = d.rhs / w;\n\n\t\t\tint slx = d.lhs % w;\n\t\t\tint sly = d.lhs / w;\n\t\t\tque.pop();\n\n\t\t\tif(d.cost >= res) continue;\n\n\t\t\tif(d.turn){\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tint dx = txl[i] + srx;\n\t\t\t\t\tint dy = tyl[i] + sry;\n\n\t\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\t\tif(dx>=srx) continue;\n\t\t\t\t\tif(abs(dx - srx) + abs(dy - sry) > 3) continue;\n\t\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\t\tres = cost[dy*w+dx][d.rhs] = min(cost[dy*w+dx][d.rhs],d.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cost[dy*w+dx][d.rhs] <= d.cost + stage[dy][dx]-'0') continue;\n\t\t\t\t\tcost[dy*w+dx][d.rhs] = d.cost + stage[dy][dx]-'0';\n\n\t\t\t\t\tque.push(Data(d.cost + stage[dy][dx]-'0',dy*w+dx,d.rhs,false));\n\t\t\t\t\t//dfs(dy*w+dx,d.rhs,0,d.cost + stage[dy][dx]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tint dx = txr[i] + slx;\n\t\t\t\t\tint dy = tyr[i] + sly;\n\n\t\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\t\tif(slx>=dx) continue;\n\t\t\t\t\tif(abs(dx - slx) + abs(dy - sly) > 3) continue;\n\t\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\t\tres = cost[d.lhs][dy*w+dx] = min(cost[d.lhs][dy*w+dx],d.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(cost[d.lhs][dy*w+dx] <= d.cost + stage[dy][dx]-'0') continue;\n\t\t\t\t\tcost[d.lhs][dy*w+dx] = d.cost + stage[dy][dx]-'0';\n\t\t\t\t\tque.push(Data(d.cost + stage[dy][dx]-'0',d.lhs,dy*w+dx,true));\n\t\t\t\t\t//dfs(d.lhs,dy*w+dx,1,d.cost + stage[dy][dx]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res >= 0x3f3f3f3f ? -1 : res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint w, h;\nchar s[100][100];\n\nstruct edge {\n\tint to;\n\tll cost;\n};\n\nll dx[2][10] = { { 1,1,1, 1, 1,2,2, 2,3 },{ -1,-1,-1,-1,-1,-2,-2,-2,-3 } };\nll dy[2][10] = { { 2,1,0,-1,-2,1,0,-1,0 },{  2, 1, 0,-1,-2, 1, 0,-1, 0 } };\nll d[2][100][100];\nvector<edge> G[100010];//各頂点からの辺\n\nvoid dijkstra(P start, bool _t) {\n\trep(i, 100)rep(j, 100) {\n\t\td[0][i][j] = INF;\n\t\td[1][i][j] = INF;\n\t}\n\td[_t][start.first][start.second] = 0;\n\n\ttypedef pair<P, P> PP;\n\n\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push({ { 0,_t },start });\n\n\twhile (que.size()) {\n\t\tPP p = que.top();\n\t\tque.pop();\n\t\tint y = p.second.first;\n\t\tint x = p.second.second;\n\t\tint t = p.first.second;\n\t\t//if (d[y][x] < p.first.first)continue;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tint ny = y + dy[t][i];\n\t\t\tint nx = x + dx[t][i];\n\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n\t\t\tif (s[ny][nx] == 'X')continue;\n\t\t\tif (d[!t][ny][nx] > d[t][y][x] + s[ny][nx] - '0') {\n\t\t\t\td[!t][ny][nx] = d[t][y][x] + s[ny][nx] - '0';\n\t\t\t\tque.push({ { d[!t][ny][nx],!t}, P(ny,nx) });\n\t\t\t}\n\t\t}\n\t\t//rep(j, h) {\n\t\t//\trep(k, w) {\n\t\t//\t\tif (d[j][k] != INF)printf(\"%2d \", d[j][k]);\n\t\t//\t\telse cout << -1 << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t}\n}\n\nvector<P> S, T;\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tS.clear();\n\t\tT.clear();\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tS.push_back(P(i, j));\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'T') {\n\t\t\t\t\tT.push_back(P(i, j));\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, S.size()) {\n\t\t\tdijkstra(S[i], 0);\n\t\t\trep(j, T.size()) {\n\t\t\t\tans = min(ans, d[0][T[j].first][T[j].second]);\n\t\t\t\tans = min(ans, d[1][T[j].first][T[j].second]);\n\t\t\t}\n\t\t\t//rep(kk, 2) {\n\t\t\t//\trep(j, h) {\n\t\t\t//\t\trep(k, w) {\n\t\t\t//\t\t\tif (d[kk][j][k] != INF)cout << d[kk][j][k] << \" \";\n\t\t\t//\t\t\telse cout << -1 << \" \";\n\t\t\t//\t\t}\n\t\t\t//\t\tcout << endl;\n\t\t\t//\t}\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t\tdijkstra(S[i], 1);\n\t\t\trep(j, T.size()) {\n\t\t\t\tans = min(ans, d[0][T[j].first][T[j].second]);\n\t\t\t\tans = min(ans, d[1][T[j].first][T[j].second]);\n\t\t\t}\n\t\t\t//rep(kk, 2) {\n\t\t\t//\trep(j, h) {\n\t\t\t//\t\trep(k, w) {\n\t\t\t//\t\t\tif (d[kk][j][k] != INF)cout << d[kk][j][k] << \" \";\n\t\t\t//\t\t\telse cout << -1 << \" \";\n\t\t\t//\t\t}\n\t\t\t//\t\tcout << endl;\n\t\t\t//\t}\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t}\n\t\tif (ans == INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint tesu[61][61][2];\nchar cliff[61][61];\nint w, h;\n\nint dy[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nint dx[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nvoid solve(int isnowleft, int x, int y, int nowtesu)\n{\n    if(nowtesu >= tesu[x][y][isnowleft]) return;\n    tesu[x][y][isnowleft] = nowtesu;\n    for(int i = 0; i < 9; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[isnowleft][i];\n        if(nx < 0 || ny < 0 || nx >= h || ny >= w || cliff[nx][ny] == 'X') continue;\n        if(cliff[nx][ny] == 'T') tesu[nx][ny][!isnowleft] = min(tesu[nx][ny][!isnowleft], nowtesu);\n        else if(cliff[nx][ny] == 'S') solve(!isnowleft, nx, ny, nowtesu);\n        else solve(!isnowleft, nx, ny, nowtesu + cliff[nx][ny] - '0');\n    }\n    return;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        vector<int> sx, sy, tx, ty;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> cliff[i][j];\n                if(cliff[i][j] == 'S'){\n                    sx.push_back(i);\n                    sy.push_back(j);\n                } else if(cliff[i][j] == 'T'){\n                    tx.push_back(i);\n                    ty.push_back(j);\n                }\n            }\n        }\n        memset(tesu, 1000000, sizeof(tesu));\n        int ans = 1000000;\n        for(int i = 0; i < 2; i++){\n            for(int j = 0; j < sx.size(); j++){\n                solve(i, sx[j], sy[j], 0);\n            }\n        }\n        // for(int k = 0; k < 2; k++){\n        //     for(int i = 0; i < h; i++){\n        //             for(int j = 0; j < w; j++){\n        //                 cout << tesu[i][j][k] << \" \";\n        //             }\n        //             cout << endl;\n        //         }\n        //         cout << endl;\n        //     }\n        for(int i = 0; i < tx.size(); i++){\n            for(int j = 0; j < 2; j++){\n                ans = min(ans, tesu[tx[i]][ty[i]][j]);\n            }\n        }\n        if(ans == 1000000) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\nint H, W;\n\nint dp[66][33][2];  // dp[i][j][k]=マス(i,j)に足kを置くための最短時間\nchar A[101][101];\nint dist[66][33][2][66][33][2];\nvoid init() {\n    REP(i, H) REP(j, W) REP(k, 2) REP(x, H) REP(y, W) REP(l, 2) { dist[i][j][k][x][y][l] = 1e9; }\n    REP(i, H) REP(j, W) REP(k, 2) {\n        dp[i][j][k] = 1e9;\n        // dist[i][j][k][i][j][k] = 0;\n    }\n}\nint dijkstra(int x, int y, int foot) {\n    REP(i, H) REP(j, W) REP(k, 2) REP(x, H) REP(y, W) REP(l, 2) { dist[i][j][k][x][y][l] = 1e9; }\n    REP(i, H) REP(j, W) REP(k, 2) {\n        dp[i][j][k] = 1e9;\n        // dist[i][j][k][i][j][k] = 0;\n    }\n}\nusing arr4 = array<int, 4>;\nbool solve() {\n    cin >> W >> H;\n    if (W == 0) return false;\n    REP(i, H) {\n        REP(j, W) { cin >> A[i][j]; }\n    }\n    init();\n    REP(i, H) REP(j, W) REP(k, 2) {\n        if (A[i][j] == 'X') continue;\n        if (k == 0) {\n            REP(x, H) FOR(y, j + 1, W) {\n                int l = 1;\n                if (A[x][y] == 'X') continue;\n                int cost = 0;\n                if (isdigit(A[x][y])) {\n                    cost = A[x][y] - '0';\n                }\n                if (abs(x - i) + abs(y - j) <= 3) {\n                    dist[i][j][k][x][y][l] = cost;\n                }\n            }\n        } else {\n            int l = 0;\n            REP(x, H) REP(y, j) {\n                if (A[x][y] == 'X') continue;\n                int cost = 0;\n                if (isdigit(A[x][y])) {\n                    cost = A[x][y] - '0';\n                }\n                if (abs(x - i) + abs(y - j) <= 3) {\n                    dist[i][j][k][x][y][l] = cost;\n                }\n            }\n        }\n    }\n    priority_queue<arr4, vector<arr4>, greater<arr4>> que;\n    REP(j, W) {\n        if (A[H - 1][j] == 'S') {\n            REP(k, 2) {\n                dp[H - 1][j][k] = 0;\n                que.push({0, H - 1, j, k});\n            }\n        }\n    }\n    while (!que.empty()) {\n        arr4 ar = que.top();\n        que.pop();\n        int res = ar[0], i = ar[1], j = ar[2], k = ar[3];\n        if (res > dp[i][j][k]) continue;\n        REP(x, H) REP(y, W) REP(z, 2) {\n            if (res + dist[i][j][k][x][y][z] < dp[x][y][z]) {\n                dp[x][y][z] = res + dist[i][j][k][x][y][z];\n                que.push({dp[x][y][z], x, y, z});\n            }\n        }\n    }\n    int ans = 1e9;\n    REP(j, W) {\n        if (A[0][j] == 'T') {\n            REP(k, 2) { ans = min(ans, dp[0][j][k]); }\n        }\n    }\n    if (ans >= 1e9)\n        cout << -1 << endl;\n    else\n        cout << ans << endl;\n    // REP(i, H) {\n    //     REP(j, W) { cout << A[i][j] << \" \"; }\n    //     cout << endl;\n    // }\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define H 60\n#define W 30\n#define INF 10000\n#define R 1\n#define L 0\nint w, h;\nchar maps[H][W];\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][2];\n    bool used[H][W][2];\n    int ldx[9] = {-1, -1, -1, -1, -1, -2, -2, -2, -3};\n    int ldy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    int rdx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n    int rdy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    for (int i = 0; i < w - 1; i++) {\n        if (maps[h-1][i] == 'S') {\n            d[h - 1][i][L] = 0; d[h - 1][i+1][R] = 0;\n        }\n    }\n    if (maps[h-1][w-1] == 'S') {\n        d[h-1][w-1][R] = 0;\n    }\n    \n    while (true) {\n        point p;\n        p.x = -1; p.y = -1;\n        int muki = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (!used[i][j][k] && (p.x == -1 || d[i][j][k] < d[p.y][p.x][muki])) {\n                        p.x = j; p.y = i; muki = k;\n                    }\n                }\n            }\n        }\n        \n        if (p.x == -1 && p.y == -1) {\n            break;\n        }\n        used[p.y][p.x][muki] = true;\n        \n        if (muki == R) {\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + ldx[i];\n                int my = p.y + ldy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R]);\n                }\n                else{\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n        else{\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + rdx[i];\n                int my = p.y + rdy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L]);\n                }\n                else{\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int j = 0; j < w; j++) {\n        if (maps[0][j] == 'T'){\n            for (int k = 0; k < 2; k++) {\n                ans = min(ans, d[0][j][k]);\n            }\n        }\n    }\n    if (ans == INF) {\n        return -1;\n    }\n    else {\n        return ans;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> maps[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n\nstruct Action {\n\tsize_t x;\n\tsize_t y;\n\tsize_t cost;\n\tbool left_foot_on;\n};\n\nbool operator>(Action lhs, Action rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nbool operator==(Action lhs, Action rhs) {\n\treturn lhs.x == rhs.x && lhs.y == rhs.y && lhs.left_foot_on == rhs.left_foot_on;\n}\n\nnamespace std {\n\ttemplate <>\n\tstruct hash<Action> {\n\t\tusing result_type = size_t;\n\n\t\tresult_type operator()(const Action& act) const {\n\t\t\treturn act.x * 31 + act.y * 12 + act.left_foot_on * 7;\n\t\t}\n\t};\n}\n\nclass Climber {\nprivate:\n\tusing candidates_t = std::priority_queue<Action, std::vector<Action>, std::greater<Action>>;\n\n\tsize_t _width;\n\tsize_t _height;\n\tstd::string* _cliff;\n\tcandidates_t _candidates;\n\tstd::unordered_set<Action> _traversed;\n\n\tchar get(size_t x, size_t y);\n\tvoid try_put_candidate(const Action& now, size_t x, size_t y);\n\tvoid put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on);\npublic:\n\tClimber(size_t width, size_t height);\n\tvoid load();\n\tint climb();\n};\n\nClimber::Climber(size_t width, size_t height) : _width(width), _height(height) { }\n\nvoid Climber::load() {\n\t_cliff = new std::string[_height];\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tstd::string line;\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tchar a;\n\t\t\tstd::cin >> a;\n\t\t\tline += a;\n\t\t}\n\t\t_cliff[y] = line;\n\t}\n}\n\nint Climber::climb() {\n\t// ??????????????????S????????????????¶????????¶???????????????????????????????\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tif (get(x, y) == 'S') {\n\t\t\t\tput_candidate(x, y, 0, false);\n\t\t\t\tput_candidate(x, y, 0, true);\n\t\t\t}\n\t\t}\n\t}\n\t// ???????°???????????????????????????????????????????????????????????????????\n\twhile (!_candidates.empty()) {\n\t\tconst Action now = _candidates.top();\n\t\tif (get(now.x, now.y) == 'T') {\n\t\t\treturn now.cost;\n\t\t}\n#ifdef _DEBUG\n\t\tstd::cerr << \"(\" << now.x << \",\" << now.y << \")->\" << now.cost << \" [\" << now.left_foot_on << \"]\\n\";\n#endif\n\t\tif (now.left_foot_on) {\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 2);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 3, now.y);\n\t\t} else {\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x - 3, now.y);\n\t\t}\n\t\t_candidates.pop();\n\t}\n\t// ????????????????????£???\n\treturn -1;\n}\n\nvoid Climber::try_put_candidate(const Action& now, size_t x, size_t y) {\n\tchar type = get(x, y);\n\tif (type == 'S' || type == 'X' || type == '\\0') {\n\t\treturn; // type==S??????????????????????????????????????????????§????????????????????????????????????????????????????\n\t}\n\tint additionalCost;\n\tif (type == 'T') {\n\t\tadditionalCost = 0; // ????????§??????????????????\n\t} else {\n\t\tadditionalCost = type - '0';\n\t}\n\tput_candidate(x, y, now.cost + additionalCost, !now.left_foot_on);\n}\n\nchar Climber::get(size_t x, size_t y) {\n\tif (x >= _width || y >= _height) {\n\t\treturn '\\0'; // invalid range\n\t}\n\treturn _cliff[y][x];\n}\n\nvoid Climber::put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on) {\n\tAction a{x, y, cost, left_foot_on};\n\tauto alreadyTraversed = _traversed.find(a);\n\tif (alreadyTraversed == _traversed.end() || alreadyTraversed->cost > cost) {\n\t\t_traversed.emplace(a);\n\t\t_candidates.emplace(std::move(a));\n\t}\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tClimber climber(width, height);\n\t\tclimber.load();\n\t\tstd::cout << climber.climb() << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int li,lj,ri,rj,f;\n  int dist;\n};\nbool operator<(const state& a,const state& b){ return a.dist > b.dist; }\n\nint h,w;\nchar s[111][111];\nint dist[111][111][10];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    priority_queue<state> que;\n    rep(i,111)rep(j,111)rep(k,10)dist[i][j][k]=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='S'){\n        que.push((state){i,j,-1,-1,0,0});\n        que.push((state){-1,-1,i,j,1,0});\n      }\n    }\n    while(que.size()){\n      state ns=que.top(); que.pop();\n      int li=ns.li,lj=ns.lj,ri=ns.ri,rj=ns.rj,f=ns.f,nd=ns.dist;\n      if((f==0&&dist[li][lj][0]!=INF)||(f==1&&dist[ri][rj][1]!=INF))continue;\n      if(f==0){\n        //dbg(li); dbg(lj);\n        dist[li][lj][f]=nd;\n        repl(ni,li-2,li+3)repl(nj,lj+1,lj+4){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-li)+abs(nj-lj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){li,lj,ni,nj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }else{\n        dist[ri][rj][f]=nd;\n        repl(ni,ri-2,ri+3)repl(nj,rj-3,rj){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-ri)+abs(nj-rj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){ni,nj,ri,rj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }\n    }\n    int res=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='T')minch(res,min(dist[i][j][0],dist[i][j][1]));\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nchar board[60][60];\nint dist[60][60][2];\n\nint dx[9]={1,1,1,1,1,2,2,2,3};\nint dy[9]={-2,-1,0,1,2,-1,0,1,0};\n\ntypedef tuple<int, int, int, int> state;\n\nint main(){\n\tint w,h;\n\tchar buf[2];\n\twhile(cin>>w>>h,w){\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tscanf(\"%s\",buf);\n\t\t\t\tboard[h-1-i][j]=buf[0];\n\t\t\t}\n\t\t}\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tpriority_queue<state, vector<state>, greater<state> > q;\n\t\tREP(i,w)if(board[0][i]=='S')REP(j,2)q.push(state(0,0,i,j));\n\t\tint ans = -1;\n\t\twhile(!q.empty()){\n\t\t\tstate tmp = q.top();\n\t\t\tq.pop();\n\t\t\tint cd = get<0>(tmp);\n\t\t\tint cy = get<1>(tmp);\n\t\t\tint cx = get<2>(tmp);\n\t\t\tint lr = get<3>(tmp);\n\t\t\tif(dist[cy][cx][lr]!=-1)continue;\n\t\t\tdist[cy][cx][lr]=cd;\n\t\t\tif(board[cy][cx]=='T'){\n\t\t\t\tans = cd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i,9){\n\t\t\t\tint nx=cx+(2*lr-1)*dx[i];\n\t\t\t\tint ny=cy+(2*lr-1)*dy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tif(board[ny][nx]=='X'||board[ny][nx]=='S')continue;\n\t\t\t\tif(board[ny][nx]=='T')q.push(state(cd, ny, nx, 1-lr));\n\t\t\t\telse q.push(state(cd+board[ny][nx]-'0', ny, nx, 1-lr));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\nstruct Node {\n        int step, s, x, y;\n};\nstruct NodeComparator {\n        bool operator()(const Node &a, const Node &b) const {\n                return a.step > b.step;\n        }\n};\n\nint memo[2][64][34];\nint field[64][34];\nint dx[] = {  0,  0,  1, 0, 1, 2, 0, 1, 0 };\nint dy[] = { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\nint dcount = 9;\n\nint main(){\n        while(true){\n                int w, h;\n                cin >> w >> h;\n                if(w == 0 || h == 0){ break; }\n                memset(field, -1, sizeof(field));\n                memset(memo, -1, sizeof(memo));\n                priority_queue<Node, vector<Node>, NodeComparator> q;\n                for(int i = 0; i < h; ++i){\n                        for(int j = 0; j < w; ++j){\n                                string panel;\n                                cin >> panel;\n                                if(panel == \"X\"){\n                                }else if(panel == \"S\"){\n                                        Node n = { 0, 0, j + 2, i + 2 };\n                                        q.push(n);\n                                        n.s = 1;\n                                        q.push(n);\n                                        memo[0][i + 2][j + 2] = memo[1][i + 2][j + 2] = 0;\n                                }else if(panel == \"T\"){\n                                        field[i + 2][j + 2] = -2;\n                                }else{\n                                        field[i + 2][j + 2] = atoi(panel.c_str());\n                                }\n                        }\n                }\n                int answer = -1;\n                while(!q.empty() && answer < 0){\n                        Node n = q.top(); q.pop();\n                        if(n.step <= memo[n.s][n.y][n.x]){\n                                int bx = n.x, by = n.y, sign;\n                                if(n.s){\n                                        --bx; sign = -1;\n                                }else{\n                                        ++bx; sign = 1;\n                                }\n                                for(int i = 0; i < dcount; ++i){\n                                        Node next = {\n                                                n.step, 1 - n.s,\n                                                bx + dx[i] * sign, by + dy[i]\n                                        };\n                                        if(field[next.y][next.x] == -1){\n                                                continue;\n                                        }else if(field[next.y][next.x] == -2){\n                                                answer = next.step;\n                                                break;\n                                        }\n                                        next.step += field[next.y][next.x];\n                                        if(\n                                                memo[next.s][next.y][next.x] == -1 ||\n                                                memo[next.s][next.y][next.x] > next.step\n                                        ){\n                                                memo[next.s][next.y][next.x] = next.step;\n                                                q.push(next);\n                                        }\n                                }\n                        }\n                }\n                cout << answer << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\n \nint main() {\n  int w, h;\n  while (cin >> w >> h, w || h) {\n    int maps[h][w];\n    //step,LR,x,y;\n    priority_queue<pair<pair<int,bool>,pair<int,int> > >qu;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    {\n      char tmp;\n      cin>>tmp;\n      maps[i][j]=tmp-'0';\n      if(tmp=='X')\n        maps[i][j]=-1;\n      if(tmp=='S')\n        {\n          qu.push(make_pair(make_pair(0,false),make_pair(i,j)));\n          qu.push(make_pair(make_pair(0,true),make_pair(i,j)));\n          maps[i][j]=0;\n        }\n      if(tmp=='T')\n        maps[i][j]=-2;\n    }\n    /*\n    for(int i=0;i<h;i++,cout<<endl)\n      for(int j=0;j<w;j++)\n    {\n      cout<<\"i,j=\"<<i<<\",\"<<j<<\" \";\n      cout<<maps[i][j]<<\" \";\n    }\n    */\n    int ans = -1;\n    int dy[]={1,1,1,1,1,2,2,2,3};\n    int dx[]={2,1,0,-1,-2,-1,0,1,0};\n    bool closed[2][h][w];\n    memset(closed,false,sizeof(closed));\n    while(!qu.empty())\n      {\n    int step=-qu.top().first.first;\n    bool foot =qu.top().first.second;\n    pair<int,int> pos=qu.top().second;\n    int x=pos.first;\n    int y=pos.second;\n    qu.pop();\n    //  cout<<step<<\" \"<<foot<<\" \"<<x<<\" \"<<y<<endl;\n    if(closed[foot][x][y])\n      continue;\n    closed[foot][x][y]=true;    \n    for(int i=0;i<9;i++)\n      {\n        int ny=y;\n        int nx=x+dx[i];\n        if(foot)\n          ny+=dy[i];\n        else\n          ny-=dy[i];\n        if(nx>=0 && nx<h &&\n           ny>=0 && ny<w)\n          {\n        if(maps[nx][ny]==-2)\n          {\n            ans=step;\n            break;\n          }\n        if(maps[nx][ny]>=0 && !closed[!foot][nx][ny])\n          {\n            qu.push(make_pair(make_pair(-(step+maps[nx][ny]),!foot),make_pair(nx,ny)));\n            //cout<<\"next: \";\n            //cout<<step<<\"+\"<<maps[nx][ny]<<\" \"<<!foot<<\" \"<<nx<<\" \"<<ny<<endl;\n          }\n          }\n      }\n    if(ans!=-1)\n      break;\n      }\n    cout << ans << endl;\n     \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\ntypedef std::vector<long> LI;\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\ntemplate<> void scan1(std::string& x) { if( not ( std::cin >> x ) ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\ntemplate<typename W>\nstruct N008 {\n   typedef std::vector<long> LI;\n   typedef std::vector<W>    LW;\n   long n, e;\n   const LI &ss, &ds;\n   const LW &ws;\n   std::vector<LI> fi;\n   std::vector<LI> ri;\n   N008(long n_, const LI& ss_, const LI& ds_, const LW& ws_)\n      : n(n_), e(ss_.size()), ss(ss_), ds(ds_), ws(ws_) {\n      ri.resize(n+1);\n      fi.resize(n+1);\n      for(long i = 0; i < e; ++i) {\n         fi[ss[i]].push_back(i);\n         ri[ds[i]].push_back(i);\n      }\n   }\n};\n\ntemplate<typename W>\nstruct N013 {\n   std::vector<W> xs;\n   N013(const N008<W>& g, long s, W inf) : xs(g.n+1, inf) {\n      std::priority_queue<std::pair<W, long>> q;\n      q.push(std::make_pair(0, s));\n      while( not q.empty() ) {\n         W d2; long i;\n         std::tie(d2, i) = q.top(); q.pop();\n         W d = -d2;\n         if( not ( d < xs[i] ) ) continue;\n         xs[i] = d;\n         for(long k : g.fi[i]) {\n            W nd = d + g.ws[k];\n            if( not ( nd < xs[g.ds[k]] ) ) continue;\n            q.push(std::make_pair(-nd, g.ds[k]));\n         }\n      }\n   }\n};\n\n\nstruct Solver {\n   void solve() {\n      long w, h; scan(w, h);\n      if( w == 0 and h == 0 ) exit(0);\n      getchar();\n      std::string sss[64];\n      for(long i = 0; i < h; ++i) std::getline(std::cin, sss[i]);\n      std::string field[64];\n      for(long i = 0; i < h; ++i) {\n         for(long k = 0; k < w; ++k) {\n            field[i].push_back(sss[i][k*2]);\n         }\n      }\n      LI ss, ds, ws;\n      long src = 64 * 64 * 2;\n      long dst = 64 * 64 * 2 + 1;\n      // left is kotei, right move, code = 0, left move, ocode = 1\n      long dx[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3},{-1, -1, -1, -1, -1, -2, -2, -2, -3}};\n      long dy[2][9] = {{-2, -1, 0, 1, 2, -1, 0, 1, 0},{-2, -1, 0, 1, 2, -1, 0, 1, 0}};\n      for(long y = 0; y < h; ++y) {\n         for(long x = 0; x < w; ++x) {\n            for(long k = 0; k < 2; ++k) {\n               for(long i = 0; i < 9; ++i) {\n                  long nx = x + dx[k][i];\n                  long ny = y + dy[k][i];\n                  if( not ( 0 <= nx and nx < w and 0 <= ny and ny < h ) ) continue;\n                  long w = 0;\n                  if( field[ny][nx] == 'X' ) continue;\n                  if( '0' <= field[ny][nx] and field[ny][nx] <= '9' ) w = field[ny][nx] - '0';\n                  ss.push_back(y * 64 + x + k * 64 * 64);\n                  ds.push_back(ny * 64 + nx + (1-k) * 64 * 64);\n                  ws.push_back(w);\n               }\n            }\n         }\n      }\n      for(long y = 0; y < h; ++y) {\n         for(long x = 0; x < w; ++x) {\n            if( field[y][x] == 'S' ) {\n               ss.push_back(src);\n               ds.push_back(y*64+x);\n               ws.push_back(0);\n               ss.push_back(src);\n               ds.push_back(y*64+x+64*64);\n               ws.push_back(0);\n            }\n            if( field[y][x] == 'T' ) {\n               ss.push_back(y*64+x);\n               ds.push_back(dst);\n               ws.push_back(0);\n               ss.push_back(y*64+x+64*64);\n               ds.push_back(dst);\n               ws.push_back(0);\n            }\n         }\n      }\n      N008<long> graph(64*64*2+10, ss, ds, ws);\n      N013<long> dijkstra(graph, src, (1LL << 50));\n      long res = dijkstra.xs[dst];\n      if( res != (1LL << 50) ) {\n         printf(\"%ld\\n\", dijkstra.xs[dst]);\n      }\n      else {\n         puts(\"-1\");\n      }\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<map>\n#include<climits>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\ntypedef tuple<int, int, int> Point;\ntypedef tuple<int, Point> Node;\nint Next[2][9][2] ={\n    {\n        {-2, 1}, {-1, 1}, {0, 1}, {1, 1}, {2, 1},\n        {-1, 2}, {0, 2}, {1, 2},\n        {0, 3}\n    },\n    {\n        {-2, -1}, {-1, -1}, {0, -1}, {1, -1}, {2, -1},\n        {-1, -2}, {0, -2}, {1, -2},\n        {0, -3}\n    },\n\n};\nenum {LEFT, RIGHT};\nenum {Y, X, SIDE};\nenum {COST, POINT};\nenum {START = -2, TOP, NIL};\n\nint Dijkstra(const vector<vector<int>>& cliff, const Point& start) {\n    int result = INT_MAX;\n    int h = cliff.size();\n    int w = cliff.front().size();\n    map<Point, int> cost;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        int c = get<COST>(q.top());\n        Point point = get<POINT>(q.top());\n        q.pop();\n        if(cost.count(point)) continue;\n        cost[point] = c;\n        for(const auto& d: Next[get<SIDE>(point)]) {\n            int y = get<Y>(point) + d[Y];\n            int x = get<X>(point) + d[X];\n            if(y < 0 || h  <= y) continue;\n            if(x < 0 || w  <= x) continue;\n            if(cliff[y][x] == NIL) continue;\n            if(cliff[y][x] == START) continue;\n            if(cliff[y][x] == TOP) {\n                result = min(result, c);\n            } else {\n                Point next_point(y, x, get<SIDE>(point) ^ 1);\n                q.push(Node(c + cliff[y][x], next_point));\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w | h) {\n        vector<vector<int>> cliff(h, vector<int>(w));\n        for(auto& line: cliff) for(auto& v: line) {\n            char c;\n            cin >> c;\n            if(c == 'S') v = START;\n            else if(c == 'T') v = TOP;\n            else if(c == 'X') v = NIL;\n            else v = c - '0';\n        }\n\n        int answer = INT_MAX;\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n            if(cliff[y][x] != START) continue;\n            answer = min({answer, Dijkstra(cliff, Point(y, x, LEFT)), Dijkstra(cliff, Point(y, x, RIGHT))});\n        }\n        cout << ((answer == INT_MAX) ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n\nstruct Action {\n\tsize_t x;\n\tsize_t y;\n\tsize_t cost;\n\tbool left_foot_on;\n};\n\nbool operator>(Action lhs, Action rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nbool operator==(Action lhs, Action rhs) {\n\treturn lhs.x == rhs.x && lhs.y == rhs.y && lhs.left_foot_on == rhs.left_foot_on;\n}\n\nnamespace std {\n\ttemplate <>\n\tstruct hash<Action> {\n\t\tusing result_type = size_t;\n\n\t\tresult_type operator()(const Action& act) const {\n\t\t\treturn act.x * 31 + act.y * 12 + act.left_foot_on * 7;\n\t\t}\n\t};\n}\n\nclass Climber {\nprivate:\n\tusing candidates_t = std::priority_queue<Action, std::vector<Action>, std::greater<Action>>;\n\n\tsize_t _width;\n\tsize_t _height;\n\tstd::string* _cliff;\n\tcandidates_t _candidates;\n\tstd::unordered_set<Action> _traversed;\n\n\tchar get(size_t x, size_t y);\n\tvoid try_put_candidate(const Action& now, size_t x, size_t y);\n\tvoid put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on);\npublic:\n\tClimber(size_t width, size_t height);\n\tvoid load();\n\tint climb();\n};\n\nClimber::Climber(size_t width, size_t height) : _width(width), _height(height) { }\n\nvoid Climber::load() {\n\t_cliff = new std::string[_height];\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tstd::string line;\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tchar a;\n\t\t\tstd::cin >> a;\n\t\t\tline += a;\n\t\t}\n\t\t_cliff[y] = line;\n\t}\n}\n\nint Climber::climb() {\n\t// ??????????????????S????????????????¶????????¶???????????????????????????????\n\tfor (size_t y = 0; y < _height; ++y) {\n\t\tfor (size_t x = 0; x < _width; ++x) {\n\t\t\tif (get(x, y) == 'S') {\n\t\t\t\tput_candidate(x, y, 0, false);\n\t\t\t\tput_candidate(x, y, 0, true);\n\t\t\t}\n\t\t}\n\t}\n\t// ???????°???????????????????????????????????????????????????????????????????\n\twhile (!_candidates.empty()) {\n\t\tconst Action now = _candidates.top();\n\t\tif (get(now.x, now.y) == 'T') {\n\t\t\treturn now.cost;\n\t\t}\n\t\t_candidates.pop();\n#ifdef _DEBUG\n\t\t//std::cerr << \"(\" << now.x << \",\" << now.y << \")->\" << now.cost << \" [\" << now.left_foot_on << \"]\\n\";\n#endif\n\t\tif (now.left_foot_on) {\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 1, now.y + 2);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y);\n\t\t\ttry_put_candidate(now, now.x + 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x + 3, now.y);\n\t\t} else {\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 2);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x - 1, now.y + 2);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y - 1);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y);\n\t\t\ttry_put_candidate(now, now.x - 2, now.y + 1);\n\t\t\ttry_put_candidate(now, now.x - 3, now.y);\n\t\t}\n\t}\n\t// ????????????????????£???\n\treturn -1;\n}\n\nvoid Climber::try_put_candidate(const Action& now, size_t x, size_t y) {\n\tchar type = get(x, y);\n\tif (type == 'S' || type == 'X' || type == '\\0') {\n\t\treturn; // type==S??????????????????????????????????????????????§????????????????????????????????????????????????????\n\t}\n\tint additionalCost;\n\tif (type == 'T') {\n\t\tadditionalCost = 0; // ????????§??????????????????\n\t} else {\n\t\tadditionalCost = type - '0';\n\t}\n\tput_candidate(x, y, now.cost + additionalCost, !now.left_foot_on);\n}\n\nchar Climber::get(size_t x, size_t y) {\n\tif (x >= _width || y >= _height) {\n\t\treturn '\\0'; // invalid range\n\t}\n\treturn _cliff[y][x];\n}\n\nvoid Climber::put_candidate(size_t x, size_t y, size_t cost, bool left_foot_on) {\n\tAction a{x, y, cost, left_foot_on};\n\tauto alreadyTraversed = _traversed.find(a);\n\tif (alreadyTraversed == _traversed.end() || alreadyTraversed->cost > cost) {\n\t\t_traversed.emplace(a);\n\t\t_candidates.emplace(std::move(a));\n\t}\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tClimber climber(width, height);\n\t\tclimber.load();\n\t\tstd::cout << climber.climb() << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\nstruct state {int step, foot, lx, ly, rx, ry;};\n\nbool operator< (const state &lhs, const state &rhs)\n{\n    return lhs.step < rhs.step;\n}\n\nbool operator== (const state &lhs, const state &rhs)\n{\n    return lhs.step == rhs.step;\n}\n\nbool operator> (const state &lhs, const state &rhs)\n{\n    return lhs.step > rhs.step;\n}\n\nchar field[66][36];\nbool visited[2][66][36]; //lx, ly, rx, ry\n\nint main()\n{\n    int w, h;\n    while(cin >> w >> h && w && h) {\n        vector<int> sx, sy;\n\n        for(int i = 0; i < 66; i++) {\n            for(int j = 0; j < 36; j++) {\n                field[i][j] = 'X';\n            }\n        }\n        \n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                cin >> field[i + 3][j + 3];\n                if(field[i + 3][j + 3] == 'S') {\n                    sx.push_back(j + 3);\n                    sy.push_back(i + 3);\n                    field[i + 3][j + 3] = '0';\n                } \n            }\n        }\n        \n        int dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n        int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n        \n        int ret = 9999999;\n        for(int start = 0; start < sx.size(); start++) {\n            for(int sfoot = 0; sfoot < 2; sfoot++) {\n                for(int f = 0; f < 2; f++) {\n                    for(int i = 0; i < 66; i++) {\n                        fill(visited[f][i], visited[f][i] + 36, false);\n                    }\n                }\n                \n                priority_queue<state, vector<state>, greater<state> > que;\n                que.push((state){0, sfoot, sx[start], sy[start], sx[(start + 1)%2], sy[(start + 1)%2]});\n                while(!que.empty()) {\n                    state cur = que.top(); que.pop();\n                    //cout << cur.step << \" \" << cur.foot << \" \" << cur.lx << \" \" << cur.ly << \" \" << field[cur.ly][cur.lx] << \" \" << cur.rx << \" \" << cur.ry << \" \" << field[cur.ry][cur.rx] << endl;\n                    if(cur.foot == 0) {\n                        if(visited[cur.foot][cur.ly][cur.lx]) {\n                            continue;\n                        } else if(field[cur.ly][cur.lx] == 'T') {\n                            ret = min(ret, cur.step);\n                            break;\n                        }\n                        visited[cur.foot][cur.ly][cur.lx] = true;\n                    } else {\n                        if(visited[cur.foot][cur.ry][cur.rx]) {                        \n                            continue;\n                        } else if(field[cur.ry][cur.rx] == 'T') {\n                            ret = min(ret, cur.step);\n                            break;\n                        }\n                        visited[cur.foot][cur.ry][cur.rx] = true;\n                    }\n                    \n                    for(int i = 0; i < 9; i++) {\n                        int nx, ny;\n                        if (cur.foot == 0) {\n                            nx = cur.lx + dx[i]; \n                            ny = cur.ly + dy[i];\n                            if(field[ny][nx] == 'T') {\n                                que.push((state){cur.step, 1, cur.lx, cur.ly, nx, ny});\n                            } else if(field[ny][nx] != 'X') {\n                                que.push((state){cur.step + field[ny][nx] - '0', 1, cur.lx, cur.ly, nx, ny});\n                            } else {\n                                \n                            }\n                        } else {\n                            nx = cur.rx - dx[i]; \n                            ny = cur.ry + dy[i];\n                            if(field[ny][nx] == 'T') {\n                                que.push((state){cur.step, 0, nx, ny, cur.rx, cur.ry});\n                            } else if(field[ny][nx] != 'X') {\n                                que.push((state){cur.step + field[ny][nx] - '0', 0, nx, ny, cur.rx, cur.ry});\n                            } else {\n                                \n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(ret == 9999999) {\n            cout << -1 << endl;\n        } else {\n            cout << ret << endl;\n        }\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef vector<int> vi;\ntypedef tuple<int, int, int> Node;\ntypedef pair<Node, int> pii;\n\nstruct Comp {\n\tbool operator() (pii a, pii b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nint dx[2][9] = { {1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3} };\nint dy[2][9] = { {-2, -1, 0, 1, 2, -1, 0, 1, 0},{ -2, -1, 0, 1, 2, -1, 0, 1, 0 } };\n\nint solve(int W, int H)\n{\n\tvector< vector<char> > S(H, vector<char>(W));\n\trep(y, 0, H) rep(x, 0, W) cin >> S[y][x];\n\t\n\tpriority_queue<pii, vector<pii>, Comp> que;\n\tmap<Node, int> dist;\n\tset<Node> done;\n\n\trep(x, 0, W) rep(y, 0, H) if (S[y][x] == 'S')\n\t{\n\t\tS[y][x] = '0';\n\t\trep(i, 0, 2) que.push(pii(Node(x, y, i), 0));\n\t\trep(i, 0, 2) dist[Node(x, y, i)] = 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tNode n = que.top().first;\n\t\tint c = que.top().second;\n\t\tque.pop();\n\n\t\tif (done.find(n) != done.end()) continue;\n\t\tdone.insert(n);\n\n\t\tint x = get<0>(n);\n\t\tint y = get<1>(n);\n\t\tint lr = get<2>(n);\n\n\t\tif (S[y][x] == 'T') return c;\n\n\t\trep(i, 0, 9)\n\t\t{\n\t\t\tint xx = x + dx[lr][i];\n\t\t\tint yy = y + dy[lr][i];\n\n\t\t\tif (xx < 0 || W <= xx) continue;\n\t\t\tif (yy < 0 || H <= yy) continue;\n\t\t\tif (S[yy][xx] == 'X') continue;\n\t\t\tif (S[yy][xx] == 'S') continue;\n\n\t\t\tint next_c = c;\n\t\t\tif (S[yy][xx] != 'T') next_c += S[yy][xx] - '0';\n\n\t\t\tint next_lr = (lr + 1) % 2;\n\t\t\tNode next_n(xx, yy, next_lr);\n\t\t\t\n\t\t\tif (dist.find(next_n) == dist.end()) dist[next_n] = INF;\n\t\t\tif (next_c < dist[next_n])\n\t\t\t{\n\t\t\t\tdist[next_n] = next_c;\n\t\t\t\tque.push(pii(next_n, next_c));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0) return 0;\n\n\t\tcout << solve(W, H) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct D\n{\n\tint ry,rx,ly,lx,t,s;//r l y x  0-nextR 1-nextL\n\tbool operator <(const D& a)const{return a.t<t;};\n}D;\n\nint W,H,F[63][33][2],ans,mv[9][2]={{-2,1},{-1,1},{-1,2},{0,1},{0,2},{0,3},{1,1},{1,2},{2,1}};\nchar C[63][33];\n\nbool check(int y,int x)\n{\n\treturn 0<=y&&y<H&&0<=x&&x<W?true:false;\n}\n\nint cost(int y,int x)\n{\n\tif('0'<=C[y][x]&&C[y][x]<='9')return C[y][x]-'0';\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W+H;)\n\t{\n\t\tmemset(F,0x7f,sizeof(F));\n\t\tans=1000000000;\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tscanf(\"%c%*c\",&C[i][j]);\n\t\tpriority_queue<D>Q;\n\t\tfor(int i=0;i<W;i++)\n\t\t{\n\t\t\tD tmp={H-1,0,H-1,0,0,0};\n\t\t\tif(C[H-1][i]=='S')\n\t\t\t{\n\t\t\t\tF[H-1][i][0]=F[H-1][i][1]=0;\n\t\t\t\ttmp.lx=tmp.rx=i;\n\t\t\t\tQ.push(tmp);\n\t\t\t\ttmp.s=1;\n\t\t\t\tQ.push(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\tD t=Q.top();Q.pop();\n\t\t\tif(C[t.ly][t.lx]=='T'||C[t.ry][t.rx]=='T')\n\t\t\t{\n\t\t\t\tans=min(ans,t.t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(t.s==0)//move right leg\n\t\t\t{\n\t\t\t\tfor(int i=0;i<9;i++)\n\t\t\t\t{\n\t\t\t\t\tint nry=t.ly+mv[i][0],nrx=t.lx+mv[i][1];\n\t\t\t\t\tif(check(nry,nrx)&&C[nry][nrx]!='X'&&F[nry][nrx][t.s]>t.t+cost(nry,nrx))\n\t\t\t\t\t{\n\t\t\t\t\t\tF[nry][nrx][t.s]=t.t+cost(nry,nrx);\n\t\t\t\t\t\tD ins={nry,nrx,t.ly,t.lx,t.t+cost(nry,nrx),1};\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i=0;i<9;i++)\n\t\t\t\t{\n\t\t\t\t\tint nly=t.ry+mv[i][0],nlx=t.rx-mv[i][1];\n\t\t\t\t\tif(check(nly,nlx)&&C[nly][nlx]!='X'&&F[nly][nlx][t.s]>t.t+cost(nly,nlx))\n\t\t\t\t\t{\n\t\t\t\t\t\tF[nly][nlx][t.s]=t.t+cost(nly,nlx);\n\t\t\t\t\t\tD ins={t.ry,t.rx,nly,nlx,t.t+cost(nly,nlx),0};\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans==1000000000?-1:ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nconst int INF = INT_MAX/2-1;\n\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nint dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\n\ntypedef vector<char> vc;\n\nstruct state {\n\tint x, y, c;\n\tbool l;\n\tstate(int x, int y, int c, bool l) : x(x), y(y), c(c), l(l) {};\n\tbool operator<(const state &o)const {\n\t\treturn c<o.c;\n\t}\n};\n\nint get(char c) {\n\tswitch(c) {\n\tcase 'S':\n\tcase 'T':\n\t\treturn 0;\n\tdefault:\n\t\treturn c - '0';\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvector<vc> field(h, vc(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tvector<vvi> cost(2, vvi(h, vi(w, INF)));\t\t\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'S') {\n\t\t\t\t\tQ.push(state(j, i, 0, true));\n\t\t\t\t\tQ.push(state(j, i, 0, false));\n\t\t\t\t\tcost[0][i][j] = 0;\n\t\t\t\t\tcost[1][i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tint k = (st.l ? 1 : -1);\n\t\t\tint l = (st.l ? 1 : 0);\n\n\t\t\tif(field[st.y][st.x] == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, 9) {\n\t\t\t\tint nx = st.x + dx[i]*k;\n\t\t\t\tint ny = st.y + dy[i];\n\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'X') {\n\t\t\t\t\tint nc = st.c + get(field[ny][nx]);\n\t\t\t\t\tif(nc < cost[l][ny][nx]) {\n\t\t\t\t\t\tcost[l][ny][nx] = nc;\n\t\t\t\t\t\tQ.push(state(nx, ny, nc, !st.l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'T') {\n\t\t\t\t\tans = min(ans, cost[0][i][j]);\n\t\t\t\t\tans = min(ans, cost[1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint d[30][60][2];\nvector<int>sv;\n\nint dijkstra(vector<vector<int>>&cost, State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\tint flag = 0;\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tif (cost[s.x][s.y] == 0 && res > s.d) res = s.d;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = -1;\n\t\t\t\t\tsv.push_back(j);\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') cliff[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000;\n\t\tfor (auto start : sv) {\n\t\t\tint ans1 = min(dijkstra(cliff, State(0, start, h - 1, 1)), dijkstra(cliff, State(0, start, h - 1, -1)));\n\t\t\tans = min(ans, ans1);\n\t\t}\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t\tsv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int INF = 1001001001;\n\nstruct Data {\n\tint ry, rx, ly, lx;\n\tint cost;\n\tbool nextr;\n\tData(int ry, int rx, int ly, int lx, int c, bool n) : ry(ry), rx(rx), ly(ly), lx(lx), cost(c), nextr(n) {}\n\tbool operator< (const Data& d)const {\n\t\treturn cost > d.cost;\n\t}\n};\n\nint w, h;\nbool valid(int y, int x)\n{\n\treturn 0<=y && y<h && 0<=x && x<w;\n}\n\nconst int dy[] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nconst int drx[] = {-1, -2, -1, -3, -2, -1, -2, -1, -1};\nbool visited[100][100][100][100];\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\trep(i, 100) rep(j, 100) rep(k, 100) rep(l, 100)\n\t\t\tvisited[i][j][k][l] = false;\n\n\t\tchar field[100][100];\n\t\trep(i, h) rep(j, w){\n\t\t\tchar tmp[100];\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tfield[i][j] = tmp[0];\n\t\t}\n\n\t\tpriority_queue<Data> Q;\n\t\trep(i, w){\n\t\t\tif(field[h-1][i] == 'S'){\n\t\t\t\tQ.push(Data(h-1, i, 99, 99, 0, false));\n\t\t\t\tQ.push(Data(99, 99, h-1, i, 0, true));\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\twhile(!Q.empty()){\n\t\t\tData d = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(visited[d.ry][d.rx][d.ly][d.lx])\n\t\t\t\tcontinue;\n\t\t\tvisited[d.ry][d.rx][d.ly][d.lx] = true;\n\t\t\tif(field[d.ry][d.rx] == 'T' || field[d.ly][d.lx] == 'T'){\n\t\t\t\tans = d.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 9){\n\t\t\t\tint pry, prx, ply, plx;\n\t\t\t\tif(d.nextr){\n\t\t\t\t\tif(d.ly == 99)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpry = d.ly + dy[i];\n\t\t\t\t\tprx = d.lx + drx[i];\n\t\t\t\t\tply = d.ly;\n\t\t\t\t\tplx = d.lx;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(d.ry == 99)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpry = d.ry;\n\t\t\t\t\tprx = d.rx;\n\t\t\t\t\tply = d.ry + dy[i];\n\t\t\t\t\tplx = d.rx - drx[i];\n\t\t\t\t}\n\t\t\t\tif(!valid(pry, prx) || !valid(ply, plx))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tchar c = d.nextr ? field[pry][prx] : field[ply][plx];\n\t\t\t\tif(c == 'X')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint pc = d.cost + (isdigit(c) ? c-'0' : 0);\n\t\t\t\tQ.push(Data(pry, prx, ply, plx, pc, !d.nextr));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint dy[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\n\ntypedef vector<vvi> vvvi;\nstruct node{\n\tint foot,x,y,c;\n\tnode(){}\n\tnode(int foot,int x,int y,int c):foot(foot),x(x),y(y),c(c){}\n};\nconst int MAX=INT_MAX/10;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w&h){\n\t\tvvi s(w,vi(h));\n\t\tvector<pii> start,goal;\n\t\tREP(j,h)REP(i,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tswitch(c){\n\t\t\tcase 'S':\n\t\t\t\tstart.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tgoal.push_back(make_pair(i,j));\n\t\t\t\ts[i][j]=0;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\ts[i][j]=-1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts[i][j]=c-'0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvvvi cost(2,vvi(w,vi(h,MAX)));\n\t\tqueue<node> q;\n\t\tREP(i,2)REP(j,start.size()){\n\t\t\tq.push(node(i,start[j].first,start[j].second,0));\n\t\t\tcost[i][start[j].first][start[j].second]=0;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.front();\n\t\t\tq.pop();\n\t\t\tif(cost[n.foot][n.x][n.y]<n.c)continue;\n\t\t\tREP(i,9){\n\t\t\t\tint foot=(n.foot+1)%2;\n\t\t\t\tint x=n.x+dx[foot][i],y=n.y+dy[foot][i];\n\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h&&s[x][y]>=0){\n\t\t\t\t\tint newcost=cost[n.foot][n.x][n.y]+s[x][y];\n\t\t\t\t\tif(cost[foot][x][y]>newcost){\n\t\t\t\t\t\tcost[foot][x][y]=newcost;\n\t\t\t\t\t\tq.push(node(foot,x,y,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint best=MAX;\n\t\tREP(i,2)REP(j,goal.size()){\n\t\t\tbest=min(best,cost[i][goal[j].first][goal[j].second]);\n\t\t}\n\t\tif(best==MAX){\n\t\t\tbest=-1;\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nclass state{\npublic:\n\tint foot,x,y,cost;\n\tstate(int _f, int _x, int _y, int _c){\n\t\tfoot=_f; x=_x; y=_y; cost=_c;\n\t}\n\tbool operator<(const state& tmp)const{\n\t\treturn cost<tmp.cost;\n\t}\n};\n\nint dx[2][9];\nint dy[2][9];\n\nvoid init(){\n\tint k=0;\n\tfor(int i=1; i<=3; i++){\n\t\tfor(int j=-2; j<=2; j++)if( i+abs(j)<=3 ){\n\t\t\tdx[0][k] = i; dy[0][k] = j;\n\t\t\tdx[1][k] = -i; dy[1][k] = j;\n\t\t\tk++;\n\t\t}\n\t}\n}\n\nint atai(char c){\n\tif( '0'<=c && c<='9' ) return c-'0';\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tchar field[64][64];\n\tint memo[2][64][64];\n\tinit();\n\t// 0 = right foot  , 1 = left foot\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\trep(i,64)rep(j,64)memo[0][i][j]=memo[1][i][j]=INT_MAX;\n\t\trep(i,h)rep(j,w){\n\t\t\tscanf(\" %c \",&field[i][j]);\n\t\t}\n\t\tpriority_queue<state> q;\n\t\trep(i,w)if( field[h-1][i]=='S' ){\n\t\t\tq.push(state(0,i,h-1,0));\n\t\t\tq.push(state(1,i,h-1,0));\n\t\t\tmemo[1][h-1][i] = memo[0][h-1][i] = 0;\n\t\t}\n\t\tint karikari = INT_MAX;\n\t\twhile( !q.empty() ){\n\t\t\tint nx = q.top().x;\n\t\t\tint ny = q.top().y;\n\t\t\tint nf = q.top().foot;\n\t\t\tint nc = q.top().cost;\n\t\t\tq.pop();\n\t\t\trep(k,9){\n\t\t\t\tint tx = nx + dx[nf][k];\n\t\t\t\tint ty = ny + dy[nf][k];\n\t\t\t\tint next = (nf+1)%2;\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='X' )continue;\n\t\t\t\tif( memo[next][ty][tx] > nc + atai(field[ty][tx]) ){\n\t\t\t\t\tmemo[next][ty][tx] = nc + atai(field[ty][tx]);\n\t\t\t\t\tq.push(state(next, tx, ty, nc+atai(field[ty][tx])));\n\t\t\t\t\t//if( field[ty][tx]=='T' ){\n\t\t\t\t\t//\tkarikari = min(karikari,nc);\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\trep(i,w)if( field[0][i]=='T' ){\n\t\t\tans = min(ans, min(memo[0][0][i],memo[1][0][i]));\n\t\t}\n\t\tprintf(\"%d\\n\",ans==INT_MAX?-1:ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}},\n \t\tdy[2][9] = {{-2, -1, 0, 1, 2, -1, 0, 1, 0}, {-2, -1, 0, 1, 2, -1, 0, 1, 0}};\n\nchar s[65][35];\nint d[65][35][2];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(!w && !h) break;\n\t\tREP(i, h) REP(j, w) cin >> s[i][j];\n\n\t\tvector<PII> sxy, gxy;\n\t\tREP(i, h) REP(j, w) {\n\t\t\tif(s[i][j] == 'S') {\n\t\t\t\tsxy.PB(MP(i, j));\n\t\t\t} else if(s[i][j] == 'T') {\n        gxy.PB(MP(i, j));\n      }\n\t\t}\n\n    int ans = INF;\n\t\tfor(PII i: sxy) {\n\t\t\t//i.first, i.second ???????§???°?????¨??????????¶?????¶???????????????????????????????\n\t\t\t//0?????????1??????\n\t\t\tREP(l, 2) {\n\t\t\t\tREP(j, h) REP(k, w) d[j][k][0] = d[j][k][1] = INF;\n\t\t\t\tqueue<VI> que;\n\t\t\t\tque.push({i.first, i.second, (int)l});\n\t\t\t\td[i.first][i.second][l] = 0;\n\n\t\t\t\twhile(que.size()) {\n\t\t\t\t\tVI p = que.front(); que.pop();\n\t\t\t\t\tint y = p[0], x = p[1], left = p[2];\n\t\t\t\t\tif(s[y][x] == 'T') continue;\n\t\t\t\t\tREP(j, 9) {\n\t\t\t\t\t\tint nx, ny;\n\t\t\t\t\t\t//left???1???????¬????????¶?????????????\n\t\t\t\t\t\t//left???0???????¬????????¶?????????????\n\t\t\t\t\t\tnx = x + dx[left][j], ny = y + dy[left][j];\n\t\t\t\t\t\tif(IN(0, h, ny) && IN(0, w, nx) && s[ny][nx] != 'X') {\n              int tmp;\n              if(s[ny][nx] == 'S') tmp = d[y][x][left];\n              else if(s[ny][nx] == 'T') tmp = d[y][x][left];\n              else tmp = d[y][x][left] + s[ny][nx] - '0';\n              if(d[ny][nx][!left] > tmp) {\n    \t\t\t\t\t\tque.push({ny, nx, !left});\n                d[ny][nx][!left] = tmp;\n              }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n        for(PII j: gxy) {\n          ans = min(ans, d[j.first][j.second][0]);\n          ans = min(ans, d[j.first][j.second][1]);\n        }\n        //cout << i.first << \" \" << i.second << \" \" << l << \" \" << ans << endl;\n        /*REP(j, h) {\n          REP(k, w) {\n            cout << \"(\";\n            if(d[j][k][0] == INF) cout << -1 << \",\";\n            else cout << d[j][k][0] << \",\";\n            if(d[j][k][1] == INF) cout << -1 << \",\";\n            else cout << d[j][k][1] << \",\";\n            cout << \")\";\n          }\n          cout << endl;\n        }*/\n\t\t\t}\n\t\t}\n    if(ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n//#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define INF 10000;\n\n\nbool check[100][100][2] = { false };\nint cost[100][100][2];\nint move[] = { -1, 1 };\n\nclass Node{\npublic:\n\tint x;\n\tint y;\n\tint lr;//0 -> left, 1 -> right\n\tint num;\n\n\tNode(){ x = 0; y = 0; lr = 0; num = 0; }\n\tNode(int x, int y, int lr, int num) : x(x), y(y), lr(lr), num(num){}\n\n};\n\nbool operator< (const Node &n1, const Node &n2){\n\treturn n1.num < n2.num;\n}\n\nbool operator> (const Node &n1, const Node &n2){\n\treturn n1.num > n2.num;\n}\n\nint main(void){\n\n\tint w, h;\n\twhile (cin >> w >> h, w, h){\n\t\tchar map[100][100];\n\t\tint result = INF;\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcost[j][i][1] = cost[j][i][0] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcheck[j][i][1] = check[j][i][0] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif (map[j][i] == 'X') check[j][i][1] = check[j][i][0] = true;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Node, vector<Node>, greater<vector<Node>::value_type> > que;\n\n\t\tfor (int i = 0; i < w; i++){\n\t\t\tif (map[0][i] == 'S'){\n\t\t\t\tque.push(Node(i, 0, 0, 0));\n\t\t\t\tque.push(Node(i, 0, 1, 0));\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\twhile (!que.empty()){\n\t\t\tNode buff = que.top();\n\t\t\tque.pop();\n\n\t\t\tif (check[buff.y][buff.x][buff.lr]) continue;\n\t\t\tcheck[buff.y][buff.x][buff.lr] = true;\n\t\t\tcost[buff.y][buff.x][buff.lr] = min(cost[buff.y][buff.x][buff.lr], buff.num);\n\n\t\t\tfor (int i = 1; i <= 3; i++){\n\t\t\t\tfor (int j = 3 - i; abs(j) + i <= 4; j--){\n\t\t\t\t\tif (flag) break;\n\t\t\t\t\tint nextx = buff.x + move[buff.lr] * i;\n\t\t\t\t\tint nexty = buff.y + j;\n\t\t\t\t\tif (nextx < 0 || w <= nextx || nexty < 0 || h <= nexty || map[nexty][nextx] == 'S' || map[nexty][nextx] == 'X') continue;\n\t\t\t\t\tif (map[nexty][nextx] == 'T'){\n\t\t\t\t\t\tresult = buff.num;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(Node(nextx, nexty, (buff.lr + 1) % 2, buff.num + (map[nexty][nextx] - '0')));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\t/*\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << map[j][i] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (int j = h - 1; j >= 0; j--){\n\t\t\tfor (int i = 0; i < w; i++){\n\t\t\t\tcout << min(cost[j][i][0], cost[j][i][1]) << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif (!flag) cout << -1 << endl;\n\t\telse cout << result << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n    int w=1,h=1,i,j,k,dp[111][111][2],p,flag[111];\n    char s[111][111];\n    while(1){\n        cin>>w>>h;\nif(w==0)\nreturn 0;\n    for(i=0;i<111;i++){\n        for(j=0;j<111;j++)\n        s[i][j]='X';\n    }\n    for(i=10;i-10<h;i++){\n        for(j=10;j-10<w;j++){\n            dp[i][j][0]=100000000;\n            dp[i][j][1]=100000000;\n            cin>>s[i][j];\n            if(s[i][j]=='S'){\n                dp[i][j][0]=0;\n                dp[i][j][1]=0;\n                s[i][j]='0';\n            }\n        }\n    }\n    for(k=0;k<h*w/2;k++){\n        for(i=10;i-10<h;i++){\n            for(j=10;j-10<w;j++){\n                if(s[i][j+1]!='X'){\n                    p=s[i][j+1]-'0';\n                    if(dp[i][j][0]+p<dp[i][j+1][1])\n                    dp[i][j+1][1]=dp[i][j][0]+p;\n                }\n                if(s[i][j+2]!='X'){\n                    p=s[i][j+2]-'0';\n                    if(dp[i][j][0]+p<dp[i][j+2][1])\n                    dp[i][j+2][1]=dp[i][j][0]+p;\n                }\n                if(s[i][j+3]!='X'){\n                    p=s[i][j+3]-'0';\n                    if(dp[i][j][0]+p<dp[i][j+3][1])\n                    dp[i][j+3][1]=dp[i][j][0]+p;\n                }\n                if(s[i+1][j+1]!='X'){\n                    p=s[i+1][j+1]-'0';\n                    if(dp[i][j][0]+p<dp[i+1][j+1][1])\n                    dp[i+1][j+1][1]=dp[i][j][0]+p;\n                }\n                if(s[i+1][j+2]!='X'){\n                    p=s[i+1][j+2]-'0';\n                    if(dp[i][j][0]+p<dp[i+1][j+2][1])\n                    dp[i+1][j+2][1]=dp[i][j][0]+p;\n                }\n                if(s[i+2][j+1]!='X'){\n                    p=s[i+2][j+1]-'0';\n                    if(dp[i][j][0]+p<dp[i+2][j+1][1])\n                    dp[i+2][j+1][1]=dp[i][j][0]+p;\n                }\n                if(s[i-1][j+1]!='X'){\n                    p=s[i-1][j+1]-'0';\n                    if(dp[i][j][0]+p<dp[i-1][j+1][1])\n                    dp[i-1][j+1][1]=dp[i][j][0]+p;\n                }\n                if(s[i-1][j+2]!='X'){\n                    p=s[i-1][j+2]-'0';\n                    if(dp[i][j][0]+p<dp[i-1][j+2][1])\n                    dp[i-1][j+2][1]=dp[i][j][0]+p;\n                }\n                if(s[i-2][j+1]!='X'){\n                    p=s[i-2][j+1]-'0';\n                    if(dp[i][j][0]+p<dp[i-2][j+1][1])\n                    dp[i-2][j+1][1]=dp[i][j][0]+p;\n                }\n                if(s[i][j-1]!='X'){\n                    p=s[i][j-1]-'0';\n                    if(dp[i][j][1]+p<dp[i][j-1][0])\n                    dp[i][j-1][0]=dp[i][j][1]+p;\n                }\n                if(s[i][j-2]!='X'){\n                    p=s[i][j-2]-'0';\n                    if(dp[i][j][1]+p<dp[i][j-2][0])\n                    dp[i][j-2][0]=dp[i][j][1]+p;\n                }\n                if(s[i][j-3]!='X'){\n                    p=s[i][j-3]-'0';\n                    if(dp[i][j][1]+p<dp[i][j-3][0])\n                    dp[i][j-3][0]=dp[i][j][1]+p;\n                }\n                if(s[i+1][j-1]!='X'){\n                    p=s[i+1][j-1]-'0';\n                    if(dp[i][j][1]+p<dp[i+1][j-1][0])\n                    dp[i+1][j-1][0]=dp[i][j][1]+p;\n                }\n                if(s[i+1][j-2]!='X'){\n                    p=s[i+1][j-2]-'0';\n                    if(dp[i][j][1]+p<dp[i+1][j-2][0])\n                    dp[i+1][j-2][0]=dp[i][j][1]+p;\n                }\n                if(s[i+2][j-1]!='X'){\n                    p=s[i+2][j-1]-'0';\n                    if(dp[i][j][1]+p<dp[i+2][j-1][0])\n                    dp[i+2][j-1][0]=dp[i][j][1]+p;\n                }\n                if(s[i-1][j-1]!='X'){\n                    p=s[i-1][j-1]-'0';\n                    if(dp[i][j][1]+p<dp[i-1][j-1][0])\n                    dp[i-1][j-1][0]=dp[i][j][1]+p;\n                }\n                if(s[i-1][j-2]!='X'){\n                    p=s[i-1][j-2]-'0';\n                    if(dp[i][j][1]+p<dp[i-1][j-2][0])\n                    dp[i-1][j-2][0]=dp[i][j][1]+p;\n                }\n                if(s[i-2][j-1]!='X'){\n                    p=s[i-2][j-1]-'0';\n                    if(dp[i][j][1]+p<dp[i-2][j-1][0])\n                    dp[i-2][j-1][0]=dp[i][j][1]+p;\n                }\n                \n            }\n        }\n    }\n    int ans=100000000;\n    for(j=10;j-10<w;j++){\n        if(s[10][j]=='T'){\n            if(dp[10][j][0]<ans)\n                ans=dp[10][j][0];\n            if(dp[10][j][1]<ans)\n                ans=dp[10][j][1];\n        }\n    }\n    if(ans==100000000)\n    cout<<\"-1\"<<endl;\n    else\n    cout<<ans-36<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define INF (1e9)\n#define H 60\n#define W 30\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<char,P> P1;\ntypedef pair<int,P1> P2;\nint dijkstra(int,int,char);\nint w,h,dl[H][W],dr[H][W],ans;\nchar s[H][W];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>s[i][j];\n    ans=INF;\n    for(int i=0;i<w;i++)\n      if(s[h-1][i]=='S') ans=min(ans,min(dijkstra(h-1,i,'l'),dijkstra(h-1,i,'r')));\n    if(ans==INF) cout<<-1<<endl;\n    else cout<<ans<<endl;    \n  }\n  return 0;\n}\n\nint dijkstra(int sy,int sx,char lr){\n  priority_queue<P2> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) dl[i][j]=dr[i][j]=INF;\n  q.push(P2(0,P1(lr,P(sy,sx))));\n  if(lr=='l') dl[sy][sx]=0;\n  else dr[sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.top(); q.pop();\n    char c=t.second.first;\n    int cost=t.first,y=t.second.second.first,x=t.second.second.second;\n    int dy[9]={0,0,0,-1,-1,-2,1,1,2},dx[9]={1,2,3,1,2,1,1,2,1};\n    if(c=='l'&&dl[y][x]<cost) continue;\n    if(c=='r'&&dr[y][x]<cost) continue;\n    for(int i=0;i<9;i++){\n      int ny,nx;\n      ny=y+dy[i];\n      if(c=='l') nx=x+dx[i];\n      else nx=x-dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx||s[ny][nx]=='X'||s[ny][nx]=='S') continue;\n      if(s[ny][nx]=='T'){\n\tif(c=='l') dr[ny][nx]=min(dr[ny][nx],cost);\n\telse dl[ny][nx]=min(dl[ny][nx],cost);\n      }\n      else if(c=='l'&&dr[ny][nx]>cost+s[ny][nx]-'0'){\n\tdr[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(dr[ny][nx],P1('r',P(ny,nx))));\n      }\n      else if(c=='r'&&dl[ny][nx]>cost+s[ny][nx]-'0'){\n\tdl[ny][nx]=cost+s[ny][nx]-'0';\n\tq.push(P2(dl[ny][nx],P1('l',P(ny,nx))));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<w;i++)\n    if(s[0][i]=='T') res=min(res,min(dl[0][i],dr[0][i]));\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\tint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\tint y[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\t\tset<int> t;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X') \n\t\t\t\t\tfield[i][j] = INF;\n\t\t\t\telse if(input == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tpq.push(feet(j, i, 0, 0));\n\t\t\t\t\tpq.push(feet(j, i, 1, 0));\n\t\t\t\t}\n\t\t\t\telse if(input == 'T') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tt.insert(j*100+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n/*\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tcout << field[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n//\t\t\tcout << f.x << ' ' << f.y << ' ' << f.cnt << ' ' << f.p << endl;\n\n\t\t\tif(t.count(f.x*100+f.y)) { // 'T'\n\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<9; i++) {\n\t\t\t\tfeet temp(f.x+x[i], f.y+y[i], !f.p, f.cnt+field[f.y+y[i]][f.x+x[i]]);\n\t\t\t\tif(f.p) {\n\t\t\t\t\ttemp.x = f.x-x[i];\n\t\t\t\t\ttemp.cnt = f.cnt+field[f.y+y[i]][f.x-x[i]];\n\t\t\t\t}\n\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\tif(field[temp.y][temp.x] != INF) { // 'x'\n\t\t\t\t\t\tif(temp.x < 0 || w-1 < temp.x || temp.y < 0 || h-1 < temp.y) { //out of range\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans==INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, char> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n/*struct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};*/\n\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n\nint fld[61][31];\nint w, h;\nint dx[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\nint dy[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\ntypedef int Weight;\nstruct Edge{\n\tint src, dest; Weight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size()) {\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.dest] > d[v] + e.weight) {\n\t\t\t\td[e.dest] = d[v] + e.weight;\n\t\t\t\tque.push(P(d[e.dest], e.dest));\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Dijkstra (build path version)\nvector<Weight> dijkstra(Graph &g, int s, vector<int> &prev) {\n\tvector<Weight> dist(g.size(), INF); dist[s] = 0;\n\tprev.assign(g.size(), -1);\n\tpriority_queue<Edge> q;\n\tfor (q.push(Edge{ -1, s, 0 }); !q.empty();) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (prev[e.dest] != -1) continue;\n\t\tprev[e.dest] = e.src;\n\t\tfor (Edge f : g[e.dest]) {\n\t\t\tif (dist[f.dest] > e.weight + f.weight) {\n\t\t\t\tdist[f.dest] = e.weight + f.weight;\n\t\t\t\tq.push(Edge{ f.src, f.dest, e.weight + f.weight });\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\ntypedef pair<P, P> data;\n\n\nint main()\n{\n\t\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvi st, go;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') fld[i][j] = INF;\n\t\t\telse if (c == 'T')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tgo.push_back(j);\n\t\t\t}\n\t\t\telse if (c == 'S')\n\t\t\t{\n\t\t\t\tst.push_back(j);\n\t\t\t\tfld[i][j] = 0;\n\t\t\t}\n\t\t\telse fld[i][j] = c - '0';\n\t\t}\n\t\tmap<data, int> mp;\n\t\tmp[data{ P(-1, -1), P(-1, -1) }] = 0;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (valid(rx, ry, h, w))\n\t\t\t\t{\n\t\t\t\t\tdata tmp = data{P(i, j), P(rx, ry) };\n\t\t\t\t\tmp[tmp] = mp.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tGraph g(mp.size());\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint lx = i, ly = j;\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tdata from = data{ P(lx, ly), P(rx, ry) };\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = lx + dx[l], ny = ly + dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)||fld[nx][ny] == INF) continue;\n\t\t\t\t\tdata to = data{ P(lx, ly), P(nx, ny) };\n\t\t\t\t\tg[mp[from]].push_back(Edge{ mp[from], mp[to], fld[nx][ny] });\n\t\t\t\t}\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = rx + dx[l], ny = ry - dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == INF) continue;\n\t\t\t\t\tdata to = data{ P(nx, ny), P(rx, ry) };\n\t\t\t\t\tg[mp[from]].push_back(Edge{ mp[from], mp[to], fld[nx][ny] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, st.size())\n\t\t{\n\t\t\tint lx = h - 1, ly = st[i];\n\t\t\tREP(j, 9)\n\t\t\t{\n\t\t\t\tint rx = lx + dx[j], ry = ly + dy[j];\n\t\t\t\tdata tmp = data{ P(lx, ly), P(rx, ry) };\n\t\t\t\tif (valid(rx, ry, h, w) && fld[rx][ry] != INF) g[0].push_back(Edge{ 0, mp[tmp], fld[rx][ry] });\n\t\t\t}\n\t\t}\n\t\tREP(i, st.size())\n\t\t{\n\t\t\tint rx = h - 1, ry = st[i];\n\t\t\tREP(j, 9)\n\t\t\t{\n\t\t\t\tint lx = rx + dx[j], ly = ry + dy[j];\n\t\t\t\tdata tmp = data{ P(lx, ly), P(rx, ry) };\n\t\t\t\tif (valid(lx, ly, h, w) && fld[lx][ly] != INF) g[0].push_back(Edge{ 0, mp[tmp], fld[lx][ly] });\n\t\t\t}\n\t\t}\n\t\tArray d;\n\t\tdijkstra(g, d, 0);\n\t\tint ans = INF;\n\t\tvi v;\n\t\tREP(i, go.size())\n\t\t{\n\t\t\tint lx = 0, ly = go[i];\n\t\t\tREP(j, 9)\n\t\t\t{\n\t\t\t\tint rx = lx + dx[j], ry = ly + dy[j];\n\t\t\t\tdata tmp = data{ P(lx, ly), P(rx, ry) };\n\t\t\t\tif (valid(rx, ry, h, w)) v.push_back(mp[tmp]);\n\t\t\t}\n\t\t}\n\t\tREP(i, go.size())\n\t\t{\n\t\t\tint rx = 0, ry = go[i];\n\t\t\tREP(j, 9)\n\t\t\t{\n\t\t\t\tint lx = rx + dx[j], ly = ry - dy[j];\n\t\t\t\tdata tmp = data{ P(lx, ly), P(rx, ry) };\n\t\t\t\tif (valid(lx, ly, h, w)) v.push_back(mp[tmp]);\n\t\t\t}\n\t\t}\n\t\tREP(i, v.size())\n\t\t{\n\t\t\tans = min(ans, d[v[i]]);\n\t\t}\n\t\tif (ans >= INF) puts(\"-1\");\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, step;\n    int feet;\n\n    bool operator >(const P& p) const {\n        return step > p.step;\n    }\n};\n\nconst int dx[] = {1,1,1,1,1,2,2,2,3}; const int dy[] = {2,1,0,-1,-2,1,0,-1,0};\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1e8\n\nconst char START = 'S';\nconst char GOAL = 'T';\nconst char WALL = 'X';\n\nchar field[MAX_H][MAX_W];\nint G[MAX_H][MAX_W][2];\n\nint w, h;\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_H*MAX_W, WALL);\n        fill_n((int *)G, MAX_H*MAX_W*2, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> field[y][x];\n                if ('0' <= field[y][x] && field[y][x] <= '9') {\n                    field[y][x] -= '0';\n                }\n                if (field[y][x] == START) {\n                    que.push({x, y, 0, 1});\n                    que.push({x, y, 0, -1});\n                }\n            }\n        }\n\n        int step = -1;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            if (field[p.y][p.x] == GOAL) {\n                step = p.step;\n                break;\n            }\n\n            REP(i, 9) {\n                int sx = p.x + dx[i] * p.feet, sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    switch (field[sy][sx]) {\n                    case WALL:\n                        break;\n                        break;\n                    case GOAL:\n                        que.push({sx, sy, p.step, -p.feet});\n                        break;\n                    case START:\n                    default:\n                        int f = p.feet > 0 ? 0 : 1;\n                        int s = p.step + field[sy][sx];\n                        if (G[sx][sy][f] > s) {\n                            G[sx][sy][f] = s;\n                            que.push({sx, sy, s, -p.feet});\n                        }\n                    }\n                }\n            }\n        }\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// 15:10-15:34\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint w, h;\nchar a[100][100];\nint d[100][100][2]; // (i, j): pos, k: foot(0:right, 1:left)\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint dijkstra() {\n    using State = tuple<int, int, int, int>; // cost, i, j, k\n    priority_queue<State, vector<State>, greater<State>> pq;\n    rep(i, h) rep(j, w) rep(k, 2) {\n        if (a[i][j] == 'S') {\n            d[i][j][k] = 0;\n            pq.push(State(0, i, j, k));\n        }\n        else {\n            d[i][j][k] = inf;\n        }\n    }\n\n    while (!pq.empty()) {\n        int cost, i, j, k;\n        tie(cost, i, j, k) = pq.top(); pq.pop();\n        if (d[i][j][k] < cost) continue;\n        int nk = k^1;\n        for (int dr = -2; dr <= +2; dr++) {\n            for (int dc = 1; dc <= 3; dc++) {\n                int ni = i + dr;\n                int nj = j + dc * (k ? +1 : -1);\n                if (!inside(ni, nj)) continue;\n                if (abs(ni - i) + abs(nj - j) > 3) continue;\n                if (a[ni][nj] == 'X') continue;\n                int ncost = 0;\n                if (isdigit(a[ni][nj])) ncost = a[ni][nj] - '0';\n                if (d[ni][nj][nk] > cost + ncost) {\n                    d[ni][nj][nk] = cost + ncost;\n                    if (a[ni][nj] != 'T') pq.push(State(cost + ncost, ni, nj, nk));\n                }\n            }\n        }\n    }\n\n    int ret = inf;\n    rep(i, h) rep(j, w) rep(k, 2) {\n        if (a[i][j] == 'T') chmin(ret, d[i][j][k]);\n    }\n    if (ret == inf) ret = -1;\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> w >> h, w) {\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\n\nint dx[9]={1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9]={2, 1, 0,-1,-2, 1, 0,-1, 0};\n\nstruct info{\n\tint y,x,lr,cost;\n\tinfo(int y, int x, int lr, int c):y(y),x(x),lr(lr),cost(c){}\n};\n\nnamespace std{\n\tbool operator < (const info& a, const info& b){\n\t\treturn b.cost < a.cost;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0) break;\n\t\t\n\t\tvector<vector<char> > map(h+2, vector<char>(w));\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<vector<vector<info> > > > adj(2,\n\t\t\tvector<vector<vector<info> > >(h, vector<vector<info> >(w)));\n\t\tfor(int f=0; f<2; f++){\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(map[i][j]=='X') continue;\n\t\t\t\t\tfor(int d=0; d<9; d++){\n\t\t\t\t\t\tint dir = (f==0)? 1: -1;\n\t\t\t\t\t\tint ny = i+dy[d];\n\t\t\t\t\t\tint nx = j+dir*dx[d];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w){\n\t\t\t\t\t\t\tif(map[ny][nx]=='X') continue;\n\t\t\t\t\t\t\tint cost=0;\n\t\t\t\t\t\t\tif('0'<=map[ny][nx] && map[ny][nx]<='9'){\n\t\t\t\t\t\t\t\tcost = map[ny][nx]-'0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadj[f][i][j].push_back(info(ny, nx, 1-f, cost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<info> wait;\n\t\tvector<vector<vector<int> > > mincost(2, vector<vector<int> >(h, vector<int>(w, inf)));\n\t\tfor(int i=0; i<w; i++){\n\t\t\tif(map[h-1][i]=='S'){\n\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\twait.push(info(h-1, i, f, 0));\n\t\t\t\t\tmincost[f][h-1][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!wait.empty()){\n\t\t\tint y = wait.top().y;\n\t\t\tint x = wait.top().x;\n\t\t\tint f = wait.top().lr;\n\t\t\tint cost = wait.top().cost;\n\t\t\twait.pop();\n\t\t\tif(cost > mincost[f][y][x]) continue;\n\t\t\tif(map[y][x] == 'T') break;\n\t\t\tfor(int i=0; i<(int)adj[f][y][x].size(); i++){\n\t\t\t\tinfo next = adj[f][y][x][i];\n\t\t\t\tif(cost +next.cost < mincost[next.lr][next.y][next.x]){\n\t\t\t\t\tmincost[next.lr][next.y][next.x] = cost+next.cost;\n\t\t\t\t\tnext.cost += cost;\n\t\t\t\t\twait.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0; i<w; i++){\n\t\t\tif(map[0][i]=='T'){\n\t\t\t\tans = min(ans, min(mincost[0][0][i], mincost[1][0][i]));\n\t\t\t}\n\t\t}\n\t\tif(ans==inf){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <limits>\n\nusing Bool = bool;\nusing Int = long long int;\nusing Char = char;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n\nInt dp[60][30][60][30][2];\n\nBool solve() {\n    Int w, h;\n    std::cin >> w >> h;\n    if (w == 0) return false;\n\n    Vector<Tuple<Int, Int>> start, goal;\n    Matrix<Int> s = genv<Int>(h, w, 0LL);\n    for (Int x = 0; x < h; ++x) {\n        for (Int y = 0; y < w; ++y) {\n            Char c;\n            std::cin >> c;\n            if (isdigit(c)) {\n                s[x][y] = c - '0';\n            } else if (c == 'S') {\n                start.emplace_back(x, y);\n            } else if (c == 'T') {\n                goal.emplace_back(x, y);\n            } else {\n                s[x][y] = INF;\n            }\n        }\n    }\n\n    for (Int lx = 0; lx < h; ++lx) {\n        for (Int ly = 0; ly < w; ++ly) {\n            for (Int rx = 0; rx < h; ++rx) {\n                for (Int ry = 0; ry < w; ++ry) {\n                    for (Int e = 0; e < 2; ++e) {\n                        dp[lx][ly][rx][ry][e] = INF;\n                    }\n                }\n            }\n        }\n    }\n\n    MinHeap<Tuple<Int, Int, Int, Int, Int, Int>> heap;\n    for (auto t : start) {\n        Int x, y;\n        std::tie(x, y) = t;\n        for (Int e = 0; e < 2; ++e) {\n            dp[x][y][x][y][e] = 0;\n            heap.emplace(0, x, y, x, y, e);\n        }\n    }\n\n    while (!heap.empty()) {\n        Int d, lx, ly, rx, ry, e;\n        std::tie(d, lx, ly, rx, ry, e) = heap.top();\n        heap.pop();\n        if (d > dp[lx][ly][rx][ry][e]) continue;\n\n        for (Int x = 0; x < h; ++x) {\n            for (Int y = 0; y < w; ++y) {\n                Int nlx = lx, nly = ly, nrx = rx, nry = ry;\n                if (e == 0) {\n                    nrx = x, nry = y;\n                } else {\n                    nlx = x, nly = y;\n                }\n\n                if (nly >= nry ||\n                    std::abs(nlx - nrx) + std::abs(nly - nry) > 3 ||\n                    dp[nlx][nly][nrx][nry][1 - e] <= d + s[x][y]) {\n                    continue;\n                }\n\n                dp[nlx][nly][nrx][nry][1 - e] = d + s[x][y];\n                heap.emplace(dp[nlx][nly][nrx][nry][1 - e], nlx, nly, nrx, nry, 1 - e);\n            }\n        }\n    }\n\n    Int ans = INF;\n    for (auto t : goal) {\n        Int gx, gy;\n        std::tie(gx, gy) = t;\n\n        for (Int x = 0; x < h; ++x) {\n            for (Int y = 0; y < w; ++y) {\n                for (Int e = 0; e < 2; ++e) {\n                    ans = std::min({ans, dp[x][y][gx][gy][e], dp[gx][gy][x][y][e]});\n                }\n            }\n        }\n    }\n\n    std::cout << (ans >= INF ? -1 : ans) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[36][64],q=0;\nshort b[2][36][64][36][64];\nint fn(int,int,int,int);\nint gn(int,int,int,int);\nint fn(int lx,int ly,int rx,int ry){\n  int mn=30000;\n  if(0){\n  }else if(a[lx][ly]==-1){\n  }else if(a[lx][ly]==-2){\n    mn=q;\n  }else{\n    q+=a[lx][ly];\n    if(b[1][lx][ly][rx][ry]>q){\n      b[1][lx][ly][rx][ry]=q;\n      mn=min(mn,gn(lx,ly,lx+1,ly-2));\n      mn=min(mn,gn(lx,ly,lx+1,ly-1));\n      mn=min(mn,gn(lx,ly,lx+1,ly));\n      mn=min(mn,gn(lx,ly,lx+1,ly+1));\n      mn=min(mn,gn(lx,ly,lx+1,ly+2));\n      mn=min(mn,gn(lx,ly,lx+2,ly-1));\n      mn=min(mn,gn(lx,ly,lx+2,ly));\n      mn=min(mn,gn(lx,ly,lx+2,ly+1));\n      mn=min(mn,gn(lx,ly,lx+3,ly));\n    }\n    q-=a[lx][ly];\n  }\n  return mn;\n}\nint gn(int lx,int ly,int rx,int ry){\n  int mn=30000;\n  if(0){\n  }else if(a[rx][ry]==-1){\n  }else if(a[rx][ry]==-2){\n    mn=q;\n  }else{\n    q+=a[rx][ry];\n    if(b[0][lx][ly][rx][ry]>q){\n      b[0][lx][ly][rx][ry]=q;\n      mn=min(mn,fn(rx-1,ry-2,rx,ry));\n      mn=min(mn,fn(rx-1,ry-1,rx,ry));\n      mn=min(mn,fn(rx-1,ry,rx,ry));\n      mn=min(mn,fn(rx-1,ry+1,rx,ry));\n      mn=min(mn,fn(rx-1,ry+2,rx,ry));\n      mn=min(mn,fn(rx-2,ry-1,rx,ry));\n      mn=min(mn,fn(rx-2,ry,rx,ry));\n      mn=min(mn,fn(rx-2,ry+1,rx,ry));\n      mn=min(mn,fn(rx-3,ry,rx,ry));\n    }\n    q-=a[rx][ry];\n  }\n  return mn;\n}\nint main(){\n  int i,j,k,l;\n  int x[30],y[30],n,w,h;\n  int mn;\n  char s;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=2;i<h+2;i++){\n      for(j=3;j<w+3;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='S'){\n\t  a[j][i]=0;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  n++;\n\t}else if(s=='T'){\n\t  a[j][i]=-2;\n\t}else if(s=='X'){\n\t}else{\n\t  a[j][i]=s-'0';\n\t}\n      }\n    }\n    for(i=0;i<w+6;i++){\n      for(j=0;j<h+4;j++){\n\tfor(k=0;k<w+6;k++){\n\t  for(l=0;l<h+4;l++){\n\t    b[0][i][j][k][l]=30000;\n\t    b[1][i][j][k][l]=30000;\n\t  }\n\t}\n      }\n    }\n    mn=30000;\n    for(i=0;i<n;i++){\n      mn=min(mn,fn(x[i],y[i],x[i],y[i]));\n      mn=min(mn,gn(x[i],y[i],x[i],y[i]));\n    }\n    if(mn==30000)\n      cout<<-1<<endl;\n    else\n      cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<map>\nusing namespace std;\n\n// #define int long long\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n\t \nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\nconst long long INF = (long long)1e9;\n\nint ans;\n\nint d[30 * 60 * 30 * 60];\nshort z[30 * 60 * 30 * 60];\nvector<vector<char>> s;\nint A , B, C;\n\n// void dijkstra(map<int,int> &d, vector<vector<pair<int,int>>> &G, \nvoid dijkstra(vector<vector<pair<int,int>>> &G, \npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>& q){\n\t\n\t\n\t// d[s] = 0;\n\t\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.top();q.pop();\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first) continue;\n\t\t\n\t\tint a = v/A;\n\t\tint b = v%A/B;\n\t\tint c = v%B/C;\n\t\tint D = v%C;\n\t\t\n\t\t\n\t\tif(s[a][b] == 'T'){\n\t\t\tans = p.first;\n\t\t\treturn ;\n\t\t}\n\t\tif(s[c][D] == 'T') {\n\t\t\tans = p.first;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tfor(pair<int,int> e : G[v]){\n\t\t\tif(d[e.first] > d[v] + e.second){\n\t\t\t\td[e.first] = d[v] + e.second;\n\t\t\t\tq.push(make_pair(d[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nsigned main(){\n\tint con = 0;\n\t\n\twhile(true){\n\t\tcon++;\n\t\tint w, h;\n\t\t// map<int,int> d;\n\t\tvector<vector<pair<int,int>>> G;\n\t\t\n\t\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n\t\tcin>>w>>h;\n\t\t\n\t\tif(!w && !h) break;\n\t\t\n\t\ts.clear();\n\t\ts.resize(h, vector<char>(w));\n\t\t\n\t\tA = w * h * w;\n\t\tB = w * h;\n\t\tC = w;\n\t\t\n\t\tG.resize(w * h * w * h);\n\t\t\n\t\t// d.resize(G.size(),INF);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[i][j] == 'X') continue;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\tfor(int l = 0; l < w; l++){// cout<<\"<>\"<<endl;\n\t\t\t\t\t\n\t\t\t\t\t\tif(s[k][l] == 'X') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(abs(i - k) + abs(j - l) > 3) continue;\n\t\t\t\t\t\n\t\t\t\t\t\tint ly = i, lx = j;\n\t\t\t\t\t\tint ry = k, rx = l;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = ly * A + lx * B + ry * C + rx;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbool fr = true;\n\t\t\t\t\t\tbool fl = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(s[ly][lx] != 'S') fr = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(s[ry][rx] != 'S') fl = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\td[cur] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int nx = 1; nx <= 3; nx++){\n\t\t\t\t\t\t\tfor(int ny = -2; ny <= 2; ny++){\n\t\t\t\t\t\t\t\tint nry = ly + ny;\n\t\t\t\t\t\t\t\tint nrx = lx + nx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint nex = ly * A + lx * B + nry * C + nrx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(nry < 0 || nry >= h || nrx < 0 || nrx >= w) continue;\n\t\t\t\t\t\t\t\tif(abs(nry - ly) + abs(nrx - lx) > 3) continue;\n\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'X') continue;\n\t\t\t\t\t\t\t\t// if(s[ly][lx] == 'S') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// d[nex] = INF;\n\t\t\t\t\t\t\t\tif(z[nex] == con) d[nex] = min(d[nex],(int)INF);\n\t\t\t\t\t\t\t\telse d[nex] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(fr) {\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) {\n\t\t\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = min(d[nex],s[nry][nrx]  - '0');\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = s[nry][nrx]  - '0';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tq.push(make_pair(d[nex],nex));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tz[nex] = con;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(s[nry][nrx] == 'S' || s[nry][nrx] == 'T') G[cur].push_back({nex, 0});\n\t\t\t\t\t\t\t\t// else G[cur].push_back({nex, s[nry][nrx] - '0'});\n\t\t\t\t\t\t\t\telse G[cur].push_back({nex, s[nry][nrx] - '0'});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int nx = -1; nx >= -3; nx--){\n\t\t\t\t\t\t\tfor(int ny = -2; ny <= 2; ny++){\n\t\t\t\t\t\t\t\tint nly = ry + ny;\n\t\t\t\t\t\t\t\tint nlx = rx + nx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint nex = nly * A + nlx * B + ry * C + rx;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(nly < 0 || nly >= h || nlx < 0 || nlx >= w) continue;\n\t\t\t\t\t\t\t\tif(abs(nly - ry) + abs(nlx - rx) > 3) continue;\n\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'X') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if(s[ry][rx] == 'S') {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) d[nex] = min(d[nex],(int)INF);\n\t\t\t\t\t\t\t\t\telse d[nex] = INF;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(fl) {\n\t\t\t\t\t\t\t\t\tif(z[nex] == con) {\n\t\t\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T')d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = min(d[nex],s[nly][nlx] - '0');\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T')d[nex] = 0;\n\t\t\t\t\t\t\t\t\t\telse d[nex] = s[nly][nlx] - '0';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tq.push(make_pair(d[nex],nex));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tz[nex] = con;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(s[nly][nlx] == 'S' || s[nly][nlx] == 'T') G[cur].push_back({nex, 0});\n\t\t\t\t\t\t\t\telse G[cur].push_back({nex, s[nly][nlx] - '0'});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// dijkstra((h-1) * A + 0 * B + (h-1) * C + 1,d, G);\n\t\t\n\t\t\n\t\tans = INF;\n\t\t\n\t\t// dijkstra(d, G, q);\n\t\tdijkstra(G, q);\n\t\t\n\t\t// for(int i = 0; i < h; i++){\n\t\t\t// for(int j = 0; j < w; j++){\n\t\t\t\t// for(int k = 0; k < h; k++){\n\t\t\t\t\t// for(int l = 0; l < w; l++){\n\t\t\t\t\t\t// if(s[i][j] != 'T' && s[k][l] != 'T') continue;\n\t\t\t\t\t\t// if(d[i*A + j*B + k * C + l] == 0) continue;\n\t\t\t\t\t\t// ans = min(d[i*A + j*B + k * C + l], ans);\n\t\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\t\n\t\t\n\t\tif(ans != INF)cout<<ans<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n#define MAX_W 30\n#define MAX_H 60\nchar field[MAX_H][MAX_W];\n\nstruct P\n{\n    int x,y,cost,w;\n    bool operator >(const P &p) const{\n        return cost>p.cost;\n    }\n};\n\nint dx[]={\n    1,1,1,1,1,2,2,2,3\n};\nint dy[]={\n    -2,-1,0,1,2,-1,0,1,0\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, MAX_W*MAX_H, 'X');\n\n        priority_queue<P, vector<P>, greater<P> >que;\n\n        REP(y,h)REP(x,w){\n            cin >> field[y][x];\n            if(field[y][x]=='S'){\n                que.push({x, y, 0, 1});\n                que.push({x, y, 0,-1});\n            }\n        }\n\n        cout << \"input\" << endl;\n\n        vvi GL(h, vi(w, INF));\n        vvi GR(h, vi(w, INF));\n\n        int res=-1;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n\n            if(field[p.y][p.x]=='T'){\n                res=p.cost;\n                break;\n            }\n\n            REP(i, 9){\n                int sx=p.x+dx[i]*p.w;\n                int sy=p.y+dy[i];\n                if(0<=sx&&sx<w&&0<=sy&&sy<h){\n                    int cost=p.cost;\n                    switch(field[sy][sx]){\n                    case 'S':\n                    case 'T':\n                        cost+=0;\n                        break;\n                    case 'X':\n                        continue;\n                    default:\n                        cost+=field[sy][sx]-'0';\n                        break;\n                    }\n                    bool t=true;\n                    if(p.w>0&&GL[sy][sx]>cost){\n                        GL[sy][sx]=cost;\n                        t=false;\n                    }else if(p.w<0&&GR[sy][sx]>cost){\n                        GR[sy][sx]=cost;\n                        t=false;\n                    }\n                    if(t)continue;\n                    que.push({sx, sy, cost, p.w*-1});\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// 15:10-\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\n// d[i][j][k] = ??????(i, j)????¶?k(0?????????1??????)??§??\\??????????????¢\n\nint w, h;\nchar a[100][100];\nint d[100][100][2];\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint dijkstra() {\n    using State = tuple<int, int, int, int>; // cost, i, j, k\n    priority_queue<State, vector<State>, greater<State>> pq;\n    rep(i, h) rep(j, w) rep(k, 2) {\n        if (a[i][j] == 'S') {\n            d[i][j][k] = 0;\n            pq.push(State(0, i, j, k));\n        }\n        else {\n            d[i][j][k] = inf;\n        }\n    }\n\n    while (!pq.empty()) {\n        int cost, i, j, k;\n        tie(cost, i, j, k) = pq.top(); pq.pop();\n        if (d[i][j][k] < cost) continue;\n        int nk = k^1;\n        // cout << \"i = \" << i << \", j = \" << j << \", k = \" << k << \", cost = \" << cost << endl;\n        for (int dr = -2; dr <= +2; dr++) {\n            for (int dc = 1; dc <= 3; dc++) {\n                int ni = i + dr;\n                int nj = j + dc * (k ? +1 : -1);\n                if (!inside(ni, nj)) continue;\n                if (abs(ni - i) + abs(nj - j) > 3) continue;\n                if (a[ni][nj] == 'X') continue;\n                int ncost = 0;\n                // cout << \"ni = \" << ni << \", nj = \" << nj << \", nk = \" << nk << \", ncost = \" << ncost << endl;\n                if (isdigit(a[ni][nj])) ncost = a[ni][nj] - '0';\n                if (d[ni][nj][nk] > cost + ncost) {\n                    d[ni][nj][nk] = cost + ncost;\n                    if (a[ni][nj] != 'T') pq.push(State(cost + ncost, ni, nj, nk));\n                }\n            }\n        }\n    }\n\n    int ret = inf;\n    rep(i, h) rep(j, w) rep(k, 2) {\n        if (a[i][j] == 'T') chmin(ret, d[i][j][k]);\n    }\n    if (ret == inf) ret = -1;\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    while (cin >> w >> h, w) {\n        // cerr << \"--- testcase \" << ++testcase << \" ---\" << endl;\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        // if (testcase != 1) continue;\n        cout << dijkstra() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int dy[16] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\nconst int dx[16] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\n\nmap<char, vvi> cost;\n\nchar m[71][71];\nint w, h;\n\nstruct Data{\n    char ft;\n    int y, x;\n};\n\nvoid dfs(Data s){\n\n    queue<Data> q;\n    q.push(s);\n\n    while(not q.empty()){\n        // cout << endl;\n        // rep(i,h){ rep(j,w){ cout << cost['R'][i][j] << ' ' ; } cout << endl; }\n        // cout << endl;\n        // rep(i,h){ rep(j,w){ cout << cost['L'][i][j] << ' ' ; } cout << endl; }\n        // cout << endl;\n        struct Data u = q.front(); q.pop();\n        char nft = (u.ft == 'L' ? 'R' : 'L');\n        rep(i,9){\n            int ny = u.y + dy[i];\n            int nx = u.x + dx[i] * (nft == 'R' ? 1 : -1);\n            if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n            if(m[ny][nx] == 'X' || m[ny][nx] == 'S') continue;\n            if(m[ny][nx] == 'T'){\n                //show(cost[u.ft][u.y][u.x])\n                cost[nft][ny][nx] = min(cost[nft][ny][nx], cost[u.ft][u.y][u.x]);\n                continue;\n            }\n            if(cost[u.ft][u.y][u.x] + (m[ny][nx] - '0') < cost[nft][ny][nx]){\n                cost[nft][ny][nx] = cost[u.ft][u.y][u.x] + (m[ny][nx] - '0');\n                q.push(Data{nft,ny,nx});\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        cost['R'] = vvi(71, vi(71,INF));\n        cost['L'] = vvi(71, vi(71,INF));\n\n        rep(i,h) rep(j,w) cin >> m[i][j];\n\n        rep(i,w) if(m[h - 1][i] == 'S'){\n            cost['R'][h - 1][i] = 0;\n            dfs(Data{'R', h - 1, i});\n            cost['L'][h - 1][i] = 0;\n            dfs(Data{'L', h - 1, i});\n        }\n\n        int mini = INF;\n        rep(i,w){\n            int tmp = INF;\n            if(m[0][i] == 'T') tmp = min(cost['R'][0][i], cost['L'][0][i]);\n            mini = min(mini, tmp);\n        }\n        cout << (mini == INF ? -1 : mini) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * cliff_climbing.cpp\n *\n *  Created on: 2017/04/25\n *      Author: Nishio\n */\n#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<(int)N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\nint dp[61][31][2];\nint ccdx[9]={1,1,1,1,1,2,2,2,3};\nint ccdy[9]={2,1,0,-1,-2,1,0,-1,0};\nstruct st{\n\tint nx,ny,nlr;\n\tst(int _nlr,int _nx,int _ny){\n\t\tnlr = _nlr;\n\t\tnx = _nx;\n\t\tny = _ny;\n\t}\n};\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tREP(i,0,61) REP(j,0,31) REP(k,0,2) dp[i][j][k]=inf;\n\t\tchar field[61][31];\n\t\tstack<st> s;//L or R ,(x,y)\n\t\tvector<pair<int,int>> vt;\n\t\tREP(i,0,h) REP(j,0,w) {\n\t\t\tcin>>field[i][j];\n\t\t\tif(field[i][j]=='S') {\n\t\t\t\ts.push(st(0,j,i));\n\t\t\t\ts.push(st(1,j,i));\n\t\t\t\tdp[i][j][0]=dp[i][j][1]=0;\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\twhile(!s.empty()){\n\t\t\tst now=s.top();s.pop();\n\t\t\tREP(i,0,9){\n\t\t\t\tst next=st(0,0,0);\n\t\t\t\tif(now.nlr%2)\tnext=st(1-now.nlr,now.nx+ccdx[i],now.ny+ccdy[i]);\n\t\t\t\telse\tnext=st(1-now.nlr,now.nx-ccdx[i],now.ny+ccdy[i]);\n\t\t\t\tif(!ck(next.nx,0,w)||!ck(next.ny,0,h)) continue;\n\t\t\t\tif(isdigit(field[next.ny][next.nx])){\n\t\t\t\t\tif(dp[next.ny][next.nx][next.nlr]>dp[now.ny][now.nx][now.nlr]+(field[next.ny][next.nx]-'0')){\n\t\t\t\t\t\tdp[next.ny][next.nx][next.nlr]=dp[now.ny][now.nx][now.nlr]+(field[next.ny][next.nx]-'0');\n\t\t\t\t\t\ts.push(st(next.nlr,next.nx,next.ny));\n\t\t\t\t\t}\n\t\t\t\t}else if(field[next.ny][next.nx]=='T'){\n\t\t\t\t\tans=min(ans,dp[now.ny][now.nx][now.nlr]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(ans==inf?-1:ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint f[60][30];\nint memo[2][60][30];\nint lx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1};\nint ly[9] = {-2,-1,-1, 0, 0, 0, 1, 1, 2};\nint rx[9] = {-1,-1,-2,-1,-2,-3,-1,-2,-1};\nint ry[9] = {-2,-1,-1, 0, 0, 0, 1, 1, 2};\nint w,h;\nclass state{\npublic:\n    int foot;\n    int x;\n    int y;\n    int cost;\n\n    state(int f,int x, int y, int c):foot(f),x(x),y(y),cost(c){}\n};\n\n#define INF 1 << 29\n\nint main(){\n    char tmp;\n    while(cin >> w >> h){\n        if((w|h) == 0) break;\n        deque<state> q;\n        vector<pair<int,int> > v;\n        fill((int *)memo, (int *)memo+2*60*30, INF);\n        \n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> tmp;\n                if(tmp == 'X'){\n                    f[i][j] = INF;\n                }else if(tmp == 'S'){\n                    f[i][j] = 0;\n                    q.push_back(state(0,j,i,0));\n                    q.push_back(state(1,j,i,0));\n                    memo[0][i][j] = 0;\n                    memo[1][i][j] = 0;\n                }else if(tmp == 'T'){\n                    f[i][j] = 0;\n                    v.push_back(make_pair(i,j));\n                }else{\n                    f[i][j] = tmp - '0';\n                }\n            }\n        }\n        \n        int tx,ty,tf,tc,nx,ny;\n        int ret = INF;\n        while(!q.empty()){\n            tx = q.front().x;\n            ty = q.front().y;\n            tf = q.front().foot; //0:left 1:right\n            tc = q.front().cost;\n\n            //cout << \"(\" << tf << \")\" << ty << \" \" << tx << \" \" << tc << endl;\n            q.pop_front();\n\n            for(int i=0;i<9;i++){\n                if(tf == 0){\n                    nx = tx + lx[i];\n                    ny = ty + ly[i];\n                }else{\n                    nx = tx + rx[i];\n                    ny = ty + ry[i];\n                }\n\n                //cout << \"ny =\" << ny << \" nx = \" << nx << endl;\n                if(!(0 <= nx && nx < w && 0 <= ny && ny < h)){\n                    continue;\n                }else{\n                    if(tc+f[ny][nx] < memo[1-tf][ny][nx]){\n                        memo[1-tf][ny][nx] = tc+f[ny][nx];\n                        q.push_back(state(1-tf,nx,ny,memo[1-tf][ny][nx]));\n                    }\n                }\n            }\n        }\n\n        for(int i=0;i<v.size();i++){\n            ret = min(ret, memo[0][v[i].first][v[i].second]);\n            ret = min(ret, memo[1][v[i].first][v[i].second]);\n        }\n\n        if(ret == INF){\n            cout << -1 << endl;\n        }else{\n            cout << ret << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n#define INF 999999999\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(n);i++)\nvector<vector<char> > inp;\nint w,h;\n\nint dx[]={-3,-2,-2,-2,-1,-1,-1,-1,-1};\nint dy[]={0,-1,0,1,-2,-1,0,1,2};\n\nstruct st{\n    pii p;\n    int bef;\n    int c;\n    bool operator < (st a) const{\n        return this->c>a.c;\n    }\n};\nint cost[65][65][2];\n\n#define y first\n#define x second\nint solve(vector<pii> poses){\n    fill(**cost,**cost+65*65*2,INF);\n    int ret = INF;\n    priority_queue<st> que;\n    for(int i = 0; i < poses.size(); i++) {\n        pii pos = poses[i];\n        que.push(st{pos,0,0});\n        que.push(st{pos,1,0});\n        cost[pos.y][pos.x][0] = 0;\n        cost[pos.y][pos.x][1] = 0;\n    }\n    while(que.size()){\n        st q = que.top();\n        que.pop();\n        int val, add;\n        val = q.c;\n        rep(i,9){\n            pii nex = q.p;\n            int dir = q.bef ? 1 : -1;\n            nex.y += dy[i];\n            nex.x += dx[i] * dir;\n            int bef = q.bef;\n            if(nex.y<0||nex.x<0||nex.y>=h||nex.x>=w)continue;\n            if(inp[nex.y][nex.x] == 'T') {\n                ret = min(ret,val);\n                continue;\n            }\n            else if(inp[nex.y][nex.x] == 'S') {\n                add = 0;\n            }\n            else {\n                add = inp[nex.y][nex.x] - '0';\n            }\n            if(inp[nex.y][nex.x] == 'X')continue;\n            if(cost[nex.y][nex.x][bef]>val+add){\n                que.push(st{nex,!bef,val+add});\n                cost[nex.y][nex.x][bef]=val+add;\n            }\n        }\n    }\n    if(ret == INF) return -1;\n    return ret;\n}\n\nint main(){\n    while(cin>>w>>h,w||h){\n        inp.resize(h,vector<char>(w));\n        rep(i,h){\n            rep(j,w){\n                cin>>inp[i][j];\n            }\n        }\n        vector<pii> vp;\n        rep(i,h)rep(j,w)if(inp[i][j]=='S')vp.push_back(pii(i,j));\n        cout<<solve(vp)<<endl;\n    }\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint W,H;\nint tiles[31][61] = {};\nint tleft[31][61] = {};\nint tright[31][61] = {};\nstruct Position {\n    int x,y;\n    bool foot; // true:left false:right\n};\nstruct CompareByFirst {\n    bool operator()(pair<int, Position> const & a,\n                              pair<int, Position> const & b) const\n    { return a.first > b.first; }\n};\n\nint main() {\nSTART:\n    while (cin>>W>>H && W != 0 && H != 0) {\n        priority_queue<pair<int, Position>, vector<pair<int, Position> >, CompareByFirst> pqueue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                tleft[w][h] = -1;\n                tright[w][h] = -1;\n                char tile = 0;\n                cin>>tile;\n                switch(tile) {\n                    case 'S':\n                    {\n                        tiles[w][h] = 0;\n                        Position pos = {w,h,true};\n                        pqueue.push(make_pair(0, pos));\n                        pos.foot = false;\n                        pqueue.push(make_pair(0, pos));\n                        break;\n                    }\n\n                    case 'T':\n                    {\n                        tiles[w][h] = -2;\n                        break;\n                    }\n\n                    case 'X':\n                        tiles[w][h] = -1;\n                        break;\n\n                    default:\n                        tiles[w][h] = atoi(&tile);\n                }\n            }\n        }\n\n        while (!pqueue.empty()) {\n            pair<int, Position> p = pqueue.top();\n            pqueue.pop();\n            if (p.second.foot == true) {\n                if (tleft[p.second.x][p.second.y] == -1) tleft[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = 1; w <= 3 - abs(h); w++) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                cout<<p.first<<endl;\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, false};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (tright[p.second.x][p.second.y] == -1) tright[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = -1; w >= abs(h) - 3; w--) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                cout<<p.first<<endl;\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, true};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        cout<<-1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf = 1e10;\ntypedef pair<mp,mp> mmp; //cost left-right-state(0,1)\n\nint main(){\n    while(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tvector<vector<ll> > s(h+8,vector<ll>(w+8,inf) );\n\tvector<vector<vector<bool> > > used(h+8,vector<vector<bool> >(w+8,vector<bool>(2,false) ) );\n\tvector<vector<bool> > goal(h+8,vector<bool>(w+8,false) );\n\tpriority_queue<mmp,vector<mmp>,greater<mmp> > q;\n\tfor(int i=4;i<h+4;i++){\n\t    for(int j=4;j<w+4;j++){\n\t\tchar tmp;\n\t\tcin>>tmp;\n\t\tif(tmp=='S'){\n\t\t    s[i][j] = 0;\n\t\t    q.push(mmp( mp(0,0),mp(i,j) ) );\n\t\t    q.push(mmp( mp(0,1),mp(i,j) ) );\n\t\t}else if(tmp=='T'){\n\t\t    s[i][j] = 0;\n\t\t    goal[i][j] = true;\n\t\t}else if(tmp=='X'){\n\t\t    used[i][j][0] = true;\n\t\t    used[i][j][1] = true;\n\t\t}else{\n\t\t    s[i][j] = tmp-'0';\n\t\t}\n\t    }\n\t}\n\tbool flag = true;\n\twhile(!q.empty() ){\n\t    mmp now = q.top();\n\t    q.pop();\n\t    ll cost = now.first.first;\n\t    ll state = now.first.second;\n\t    ll x = now.second.first;\n\t    ll y = now.second.second;\n\t    if(goal[x][y]){\n\t\tcout<<cost<<endl;\n\t\tflag  = false;\n\t\tbreak;\n\t    }\n\t    if(s[x][y] == inf) continue;\n\t    if(used[x][y][state])continue;\n\t    used[x][y][state] = true;\n\t    ll ddx = 1;\n\t    if(state == 1)ddx *= -1;\n\t    state = (state+1)%2;\n\t    for(int i=1;i<=3;i++){\n\t\tfor(int j=-3+i ; j <= 3-i  ;j++){\n\t\t    ll nx = x + j;\n\t\t    ll ny = y + i*ddx;\n\t\t    ll nc = cost + s[nx][ny];\n\t\t    if(used[nx][ny][state])continue;\n\t\t    q.push( mmp( mp( nc , state ), mp( nx,ny ) )  );\n\t\t}\n\t    }\n\t}\n\tif(flag) cout<<-1<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[71][41];\nint used[2][71][41][71][41]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c;\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false;\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c;\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true;\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true;\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; \n\t  if(board[s.r.sc][s.r.fs] < 0) return true;\n\t  if(board[s.l.sc][s.l.fs] < 0) return true;\n\t  return false;\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true;\n\t  if(g.find(s.r) != g.end()) return true;\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n//\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n//\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost=0;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tsort(s.begin(),s.end());\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  for(int j=i+1; j<s.size(); j++){\n\t\t\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\t\t\t  state st = state(s[i], s[j], (f+1)%2, 0);\n\t\t\t\t\t\t\t  if( valid(st) ) continue;\n\t\t\t\t\t\t\t  int tmp = dijk(st);\n\t\t\t\t\t\t\t  if(tmp != -1)\n\t\t\t\t\t\t\t\t\tans = min(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\tque.push(make_tuple(sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<0>(que.top());\n\t\tint y = get<1>(que.top());\n\t\tint s = get<2>(que.top());\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + 1;\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\", &M[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][61][61][61];\nint dl[61][61];\nint dr[61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tfill(&dl[0][0], &dl[60][60] + 1, INF);\n\t\tfill(&dr[0][0], &dr[60][60] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tdl[j][i] = dr[j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr] || (dis > dl[xl][yl] && dis > dr[xr][yr])) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tdr[xr2][yr2] = min(dr[xr2][yr2], memo[xl][yl][xr2][yr2]);\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tdl[xl2][yl2] = min(dl[xl2][yl2], memo[xl2][yl2][xr][yr]);\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 100000000\n#include<algorithm>\n#include<queue>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct pla{\n\tint lx,ly,rx,ry,nowc;\n\tpla(){}\n\tpla(int lx,int ly,int rx,int ry,int nowc):\n\tlx(lx),ly(ly),rx(rx),ry(ry),nowc(nowc){}\n\toperator<(const pla &x)const{\n\t\treturn nowc>x.nowc;\n\t}\n};\nint main(){\n\tint w,h,dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\n\twhile(cin>>w>>h,w||h){\n\t\tchar s[70][40];\n\t\trep(i,h)\n\t\trep(j,w){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\tpriority_queue<pla> que;\n\t\tint d[20][20][20][20];\n\t\trep(i,h)\n\t\trep(j,w)\n\t\trep(k,h)\n\t\trep(l,w)\n\t\td[i][j][k][l]=INF;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\tfor(int j=i+1;j<w;j++){\n\t\t\t\t\tif(s[h-1][j]=='S'){\n\t\t\t\t\t\tque.push(pla(i,h-1,j,h-1,0));\n\t\t\t\t\t\td[h-1][i][h-1][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint llx,lly,rrx,rry,nrrc,nllc;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\trep(j,9){\n\t\t\t\t\trrx=i+dx[j];\n\t\t\t\t\trry=h-1+dy[j];\n\t\t\t\t\tif(rrx<0||rrx>w-1||rry>h-1||rry<0||s[rry][rrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnrrc=isdigit(s[rry][rrx])?s[rry][rrx]-'0':0;\n\t\t\t\t\tque.push(pla(i,h-1,rrx,rry,nrrc));\n\t\t\t\t\td[h-1][i][rry][rrx]=nrrc;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\trep(j,9){\n\t\t\t\t\tllx=i-dx[j];\n\t\t\t\t\tlly=h-1+dy[j];\n\t\t\t\t\tif(llx<0||llx>w-1||lly>h-1||lly<0||s[lly][llx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnllc=isdigit(s[lly][llx])?s[lly][llx]-'0':0;\n\t\t\t\t\tque.push(pla(llx,lly,i,h-1,nllc));\n\t\t\t\t\td[lly][llx][h-1][i]=nllc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\twhile(!que.empty()){\n\t\t\tpla now=que.top();\n\t\t\tque.pop();\n\t\t\t//cout<<now.nowc<<' '<<now.lx<<' '<<now.ly<<endl;\n\t\t\tif(d[now.ly][now.lx][now.ry][now.rx]<now.nowc){\n\t\t\t//\tcout<<\"77777\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[now.ly][now.lx]=='T'||s[now.ry][now.rx]=='T'){\n\t\t\t\tflag=false;\n\t\t\t\tcout<<now.nowc<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nrx,nry,nrc;\n\t\t\t\tnrx=now.lx+dx[i];\n\t\t\t\tnry=now.ly+dy[i];\n\t\t\t\tif((nrx==now.rx&&nry==now.ry)||nry<0||nry>h-1||nrx<0||nrx>w-1||s[nry][nrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\tnrc=isdigit(s[nry][nrx])?s[nry][nrx]-'0':0;\n\t\t\t//\tcout<<nrc<<endl;\n\t\t\t\tif(d[now.ly][now.lx][nry][nrx]>now.nowc+nrc){\n\t\t\t\t\tque.push(pla(now.lx,now.ly,nrx,nry,now.nowc+nrc));\n\t\t\t\t\td[now.ly][now.lx][nry][nrx]=now.nowc+nrc;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nlx,nly,nlc;\n\t\t\t\tnlx=now.rx-dx[i];\n\t\t\t\tnly=now.ry+dy[i];\n\t\t\t\tif((nlx==now.lx&&nly==now.ly)||nly<0||nly>h-1||nlx<0||nlx>w-1||s[nly][nlx]=='X')\n\t\t\t\tcontinue;\n\t\t\t\tnlc=isdigit(s[nly][nlx])?s[nly][nlx]-'0':0;\n\t\t\t\tif(d[nly][nlx][now.ry][now.rx]>now.nowc+nlc){\n\t\t\t\t\tque.push(pla(nlx,nly,now.rx,now.ry,now.nowc+nlc));\n\t\t\t\t\td[nly][nlx][now.ry][now.rx]=now.nowc+nlc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tif(flag)\n\t\tcout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define Y first\n#define X second\n#define RANGE(x, y, mX, mY) (0 <= (x) && 0 <= (y) && (x) < (mX) && (y) < (mY))\n#define MP make_pair\n\nconst int INF = 0x3f3f3f3f;\n\nstruct State {\n    State () {}\n    State (PII p_, bool l, int c) :\n        p(p_.Y, p_.X), leg(l), cost(c) {}\n    PII p;\n    bool leg;\n    int cost;\n\n    bool operator > (const State &s) const {\n        return cost > s.cost;\n    }\n};\n\nint W, H;\n\nVVC ts;\n\nconst char WALL = 'X';\nconst char GOAL = 'T';\nconst char START = 'S';\n\nconst int DX[2][9] = {\n    {1, 2, 3, 1, 2, 1, 1, 2, 1},\n    {-1, -2, -3, -1, -2, -1, -1, -2, -1}\n};\nconst int DY[2][9] = {\n    {0, 0, 0, 1, 1, 2, -1, -1, -2},\n    {0, 0, 0, 1, 1, 2, -1, -1, -2}\n};\n\n\nint solve() {\n    // dist[y][x][leg] = min_cost;\n    VVVI dist(H, VVI(W, VI(2, INF)));\n\n    priority_queue<State, vector<State>, greater<State>> q;\n\n    // ?????????\n    for (int x = 0; x < W; x++) {\n        int y = H - 1;\n        if (ts[y][x] == START) {\n            for (int i = 0; i < 2; i++) {\n                q.push(State(MP(y, x), i, 0));\n            }\n        }\n    }\n\n    // ??????????????????\n    while (q.size()) {\n        State c = q.top();\n        q.pop();\n\n        // ????°?????????????\n        if (c.cost > dist[c.p.Y][c.p.X][c.leg]) continue;\n\n        // ?¬?\n        for (int i = 0; i < 9; i++) {\n            State n;\n            n.leg = !c.leg;\n            n.p.Y = c.p.Y + DY[n.leg][i];\n            n.p.X = c.p.X + DX[n.leg][i];\n\n            if (!RANGE(n.p.X, n.p.Y, W, H)) continue; // ??´???\n\n            char t = ts[n.p.Y][n.p.X];\n            if (t == WALL) continue; // ?£?\n\n            n.cost = c.cost;\n            if ('0' <= t && t <= '9') n.cost += t - '0';\n\n            if (dist[n.p.Y][n.p.X][n.leg] > n.cost) {\n                dist[n.p.Y][n.p.X][n.leg] = n.cost;\n                q.push(n);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int x = 0; x < W; x++) {\n        for (int i = 0; i < 2; i++) {\n            if (ts[0][x] == GOAL) {\n                ans = min(ans, dist[0][x][i]);\n            }\n        }\n    }\n\n    return ans == INF ? -1 : ans;\n}\n\nint main(void) {\n    while (cin >> W >> H, W) {\n        ts = VVC(H, VC(W));\n\n        for (int y = 0; y  <H; y++) {\n            for (int x = 0; x < W; x++) {\n                cin >> ts[y][x];\n            }\n        }\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//http://drken1215.hatenablog.com/entry/2018/07/18/214400\n//を参考\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V=1e3+5;\nconst int INF=1e9;\nchar board[35][35];\nvector<vector<int> > graph;//整数の形に予め整備しておければ大分手間が省ける\ntypedef pair<int,int> pii;\ntypedef pair<pii,bool> state;\nint dp[65][35][2];// x座標,y座標,右足or左足:0,1\nint w,h;\nint ans=INF;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nint main(void)\n{\n  while(cin >> w >> h && w)\n    {\n      ans=INF;\n      vector<pii> starts;\n      set<pii> goals;//goalについた時点で終わりなので,存在判定などがすぐにできるsetだと都合が良い\n      graph.clear();\n      graph.resize(h);\n      for (int i = 0; i < h; ++i)\n\t{\n\t  for (int j = 0; j < w; ++j)\n\t    {\n\t      char c;\n\t      int time=0;\n\t      cin >> c;\n\t      if(c=='X') time=-1;\n\t      else if(c=='S') starts.push_back(pii(i,j)),time=0;\n\t      else if(c=='T') goals.insert(pii(i,j)),time=0;\n\t      else time=(int)(c-'0');\n\t      graph[i].push_back(time);\n\t    }\n\t}\n      priority_queue<pair<int,state>,vector<pair<int,state> >,greater<pair<int,state> > > que;//(距離,状態)  状態:((y座標,x座標),今の足)\n      Fill(dp,INF);\n      for(auto p: starts)\n\t{\n\t  for(int foot=0;foot<2;foot++)\n\t    {\n\t      dp[p.first][p.second][foot]=0;\n\t      que.push(make_pair(0,state(p,foot) ) );\n\t    }\n\t}\n      //startが多くても,全て左右の足で試してみる.\n      while(!que.empty())\n\t{\n\t  auto now=que.top();que.pop();\n\t  int nowdist=now.first;//dpから持ってくる!　dp更新が起きた時だけqueに詰めるようにすれば計算量削減に繋がるようだ.\n\t  pii p=now.second.first;\n\t  int foot=now.second.second;\n\t  if(goals.count(p)) ans=min(ans,nowdist);//とにかく今の(y座標,x座標)が,どれかのゴールであれば答えを更新.\n\t  if(nowdist>dp[p.first][p.second][foot]) continue;\n\t  for (int i = 0; i < h; ++i)\n\t    {\n\t      for (int j = 0; j < w; ++j)\n\t\t{\n\t\t  //登り得る候補はh*w程度なので全て試してみる.(条件に合わせてより好みするのは少し難しそう)\n\t\t  if(foot==0 && j<=p.second) continue;//右足が左足より左\n\t\t  if(foot==1 && j>=p.second) continue;//左足が右足より右\n\t\t  if(abs(i-p.first)+abs(j-p.second)>3) continue; // | lx - rx | + | ly - ry | ≤ 3\n\t\t  if(graph[i][j]==-1) continue;\n\t\t  if(dp[i][j][1-foot]>nowdist+graph[i][j])//1-1=0↔1-0=1\n\t\t    {\n\t\t      dp[i][j][1-foot]=nowdist+graph[i][j];\n\t\t      que.push(make_pair(dp[i][j][1-foot],state(pii(i,j),1-foot)));\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(ans==INF) cout << -1 << endl;\n      else cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint DP[60][30][60][30], w, h;\nconst int INF = (1e9);\nchar S[60][30];\nstruct state{int lx, ly, rx, ry;};\nbool operator<(const state &x, const state &y){ return x.lx < y.lx;}\n\nbool in_range(int a, int b){ return a >= 0 && a < b;}\n\nint solve(){\n  priority_queue< pair<int, state> > wait;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if(S[i][j] == 'S'){\n        wait.emplace(0,(state){i,j,-1,-1});\n        wait.emplace(0,(state){-1,-1,i,j});\n      }\n    }\n  }\n  while(!wait.empty()){\n    state s = wait.top().second;\n    int t = -wait.top().first, lx = s.lx, ly = s.ly, rx = s.rx, ry = s.ry;\n    wait.pop();\n    //printf(\"%d %d %d %d %d\\n\",lx,ly,rx,ry,t);\n    if(lx >= 0 && rx >= 0 && DP[s.lx][s.ly][s.rx][s.ry] < t) continue;\n    if(lx >= 0 && ly >= 0){\n      for(int i = -2; i < 3; ++i){\n        for(int j = 0; j < 3; ++j){\n          int rx_ = lx + i, ry_ = ly + j + 1;\n          if((!in_range(rx_,h)) || (!in_range(ry_,w)) ||\n             (abs(j)+abs(i) > 2) || (S[rx_][ry_] == 'X')) continue;\n          int t_;\n          if(S[rx_][ry_] > '9' || S[rx_][ry_] < '0') t_ = t;\n          else t_ = t + S[rx_][ry_] - '0';\n          if(t_ >= DP[lx][ly][rx_][ry_]) continue;\n          DP[lx][ly][rx_][ry_] = t_;\n          wait.emplace(-t_,(state){lx,ly,rx_,ry_});\n        }\n      }\n    }\n    if(rx >= 0 && ry >= 0){\n      for(int i = -2; i < 3; ++i){\n        for(int j = 0; j < 3; ++j){\n          int lx_ = rx + i, ly_ = ry - j - 1;\n          if((!in_range(lx_,h)) || (!in_range(ly_,w)) ||\n             (abs(j)+abs(i) > 2) || (S[lx_][ly_] == 'X')) continue;\n          int t_;\n          if(S[lx_][ly_] > '9' || S[lx_][ly_] < '0') t_ = t;\n          else t_ = t + S[lx_][ly_] - '0';\n          if(t_ >= DP[lx_][ly_][rx][ry]) continue;\n          DP[lx_][ly_][rx][ry] = t_;\n          wait.emplace(-t_,(state){lx_,ly_,rx,ry});\n        }\n      }\n    }\n  }\n  //  cout << \"while loop finished\" << endl;\n  int ret = INF;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if(S[i][j] != 'T') continue;\n      for(int k = 0; k < h; ++k)\n        for(int l = 0; l < w; ++l)\n          ret = min({ret, DP[i][j][k][l], DP[k][l][i][j]});\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        cin >> S[i][j];\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        for(int k = 0; k < h; ++k)\n          for(int l = 0; l < w; ++l)\n            DP[i][j][k][l] = INF;\n    int ans = solve();\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 100000000\n#include<algorithm>\n#include<queue>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct pla{\n\tint lx,ly,rx,ry,nowc;\n\tpla(){}\n\tpla(int lx,int ly,int rx,int ry,int nowc):\n\tlx(lx),ly(ly),rx(rx),ry(ry),nowc(nowc){}\n\tbool operator<(const pla &x)const{\n\t\treturn nowc>x.nowc;\n\t}\n};\nint main(){\n\tint w,h,dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\n\twhile(cin>>w>>h,w||h){\n\t\tchar s[70][40];\n\t\trep(i,h)\n\t\trep(j,w){\n\t\t\tcin>>s[i][j];\n\t\t}\n\t\tpriority_queue<pla> que;\n\t\tint d[63][63][33][33];\n\t\trep(i,h)\n\t\trep(j,w)\n\t\trep(k,h)\n\t\trep(l,w)\n\t\td[i][j][k][l]=INF;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\tfor(int j=i+1;j<w;j++){\n\t\t\t\t\tif(s[h-1][j]=='S'){\n\t\t\t\t\t\tque.push(pla(i,h-1,j,h-1,0));\n\t\t\t\t\t\td[h-1][i][h-1][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint llx,lly,rrx,rry,nrrc,nllc;\n\t\trep(i,w){\n\t\t\tif(s[h-1][i]=='S'){\n\t\t\t\trep(j,9){\n\t\t\t\t\trrx=i+dx[j];\n\t\t\t\t\trry=h-1+dy[j];\n\t\t\t\t\tif(rrx<0||rrx>w-1||rry>h-1||rry<0||s[rry][rrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnrrc=isdigit(s[rry][rrx])?s[rry][rrx]-'0':0;\n\t\t\t\t\tque.push(pla(i,h-1,rrx,rry,nrrc));\n\t\t\t\t\td[h-1][i][rry][rrx]=nrrc;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\trep(j,9){\n\t\t\t\t\tllx=i-dx[j];\n\t\t\t\t\tlly=h-1+dy[j];\n\t\t\t\t\tif(llx<0||llx>w-1||lly>h-1||lly<0||s[lly][llx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\t\tnllc=isdigit(s[lly][llx])?s[lly][llx]-'0':0;\n\t\t\t\t\tque.push(pla(llx,lly,i,h-1,nllc));\n\t\t\t\t\td[lly][llx][h-1][i]=nllc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\twhile(!que.empty()){\n\t\t\tpla now=que.top();\n\t\t\tque.pop();\n\t\t\t//cout<<now.nowc<<' '<<now.lx<<' '<<now.ly<<endl;\n\t\t\tif(d[now.ly][now.lx][now.ry][now.rx]<now.nowc){\n\t\t\t//\tcout<<\"77777\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[now.ly][now.lx]=='T'||s[now.ry][now.rx]=='T'){\n\t\t\t\tflag=false;\n\t\t\t\tcout<<now.nowc<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nrx,nry,nrc;\n\t\t\t\tnrx=now.lx+dx[i];\n\t\t\t\tnry=now.ly+dy[i];\n\t\t\t\tif((nrx==now.rx&&nry==now.ry)||nry<0||nry>h-1||nrx<0||nrx>w-1||s[nry][nrx]=='X')\n\t\t\t\t\tcontinue;\n\t\t\t\tnrc=isdigit(s[nry][nrx])?s[nry][nrx]-'0':0;\n\t\t\t//\tcout<<nrc<<endl;\n\t\t\t\tif(d[now.ly][now.lx][nry][nrx]>now.nowc+nrc){\n\t\t\t\t\tque.push(pla(now.lx,now.ly,nrx,nry,now.nowc+nrc));\n\t\t\t\t\td[now.ly][now.lx][nry][nrx]=now.nowc+nrc;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,9){\n\t\t\t\tint nlx,nly,nlc;\n\t\t\t\tnlx=now.rx-dx[i];\n\t\t\t\tnly=now.ry+dy[i];\n\t\t\t\tif((nlx==now.lx&&nly==now.ly)||nly<0||nly>h-1||nlx<0||nlx>w-1||s[nly][nlx]=='X')\n\t\t\t\tcontinue;\n\t\t\t\tnlc=isdigit(s[nly][nlx])?s[nly][nlx]-'0':0;\n\t\t\t\tif(d[nly][nlx][now.ry][now.rx]>now.nowc+nlc){\n\t\t\t\t\tque.push(pla(nlx,nly,now.rx,now.ry,now.nowc+nlc));\n\t\t\t\t\td[nly][nlx][now.ry][now.rx]=now.nowc+nlc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tif(flag)\n\t\tcout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][61][61][61];\nchar field[61][61];\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tfill(&memo[0][0][0][0], &memo[60][60][60][60] + 1, INF);\n\t\tpriority_queue<Ps, vector<Ps>, greater<Ps> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tque.push(Ps(0, P2(P(j, i), P(j, i))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tPs ps = que.top();\n\t\t\tque.pop();\n\t\t\tint xl = ps.second.first.first;\n\t\t\tint yl = ps.second.first.second;\n\t\t\tint xr = ps.second.second.first;\n\t\t\tint yr = ps.second.second.second;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tint dis = ps.first;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tint xr2 = xl + dx[i];\n\t\t\t\tint yr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tint cost;\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(Ps(memo[xl][yl][xr2][yr2], P2(P(xl, yl), P(xr2, yr2))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tint xl2 = xr - dx[i];\n\t\t\t\tint yl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tint cost;\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(Ps(memo[xl2][yl2][xr][yr], P2(P(xl2, yl2), P(xr, yr))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <string>\n#include <list>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {int to, dist;\n\tedge(const int t, const int c): to(t), dist(c){}\n};\n\nint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint y[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nconst int INF = 99999;\n\ntypedef pair<int, int> P;\n\nvoid set_edge(vector<edge> G[], int s, int t, int w)\n{\n\tG[s].push_back(edge(t,w));\n}\n\nint Dijkstra(const vector<edge> G[], int n, int s, int t)\n{\n\tint* d = new int[n];\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d+n, INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor (int i=0; i< G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v]+e.dist){\n\t\t\t\td[e.to] = d[v]+e.dist;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\tint dist = d[t];\n\n\tdelete[] d;\n\n\treturn dist;\n}\n\nint main()\n{\n\tint w, h, ans;\n\tstring str;\n\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0){return 0;}\n\t\tint* graph = new int[w*2*h];\n\t\tvector<edge> Graph[w*2*h];\n\t\tvector<int> s;\n\t\tvector<int> t;\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> str;\n\t\t\t\tif(str == \"X\"){graph[i*w+j] = INF; graph[(i*w+j)+(h*w)] = INF;}\n\t\t\t\telse if(str == \"S\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; s.push_back(i*w+j); s.push_back((i*w+j)+(h*w));}\n\t\t\t\telse if(str == \"T\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; t.push_back(i*w+j); t.push_back((i*w+j)+(h*w));}\n\t\t\t\telse{ graph[i*w+j] = atoi(str.c_str()); graph[(i*w+j)+(h*w)] = graph[i*w+j];}\n\t\t\t}\n\t\t}\n\t\t/* \t二部グラフの作成 */\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(graph[i*w+j]!=INF){\n\t\t\t\t\tfor(int k=0; k<9; k++){\n\t\t\t\t\t\tif((j+x[k]<w)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j+x[k])]!=INF){ \n\t\t\t\t\t\t\t\tset_edge(Graph, i*w+j, (i-y[k])*w+(j+x[k])+h*w, graph[(i-y[k])*w+(j+x[k])+h*w]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((j-x[k]>=0)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j-x[k])]!=INF){ \n\t\t\t\t\t\t\t\tset_edge(Graph, i*w+j+h*w, (i-y[k])*w+(j-x[k]), graph[(i-y[k])*w+(j-x[k])+h*w]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdelete[] graph;\n\n\t\t/* SどうしとTどうしを接続 */\n\t\tfor(int i=0; i< s.size(); i++){\n\t\t\tfor(int j=0; j< s.size(); j++){\n\t\t\t\tset_edge(Graph, s[i], s[j], 0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\tfor(int j=0; j< t.size(); j++){\n\t\t\t\tset_edge(Graph, t[i], t[j], 0);\n\t\t\t}\n\t\t}\n\n\t\tans = INF; ans = min(ans,Dijkstra( Graph, w*h*2, s[0], t[0]));\n\t\tif(ans!=INF){cout << ans << endl;}\n\t\telse{cout << -1 << endl;}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define INF 100000009\n#define N 20005\nusing namespace std;\n\ntypedef pair<int,int> PI;//cost to;\n\nint map[65][35];\nint w,h;\n\nbool checkin(int i,int j){\n    if(i>=0&&j>=0&&i<h&&j<w&&map[i][j]!=INF){\n        return true;\n    }else{\n        return false;\n    }\n}\nint retc(int i,int j){\n    if(map[i][j]==-1){\n        return 0;\n    }else{\n        return map[i][j];\n    }\n}\n\nint make(int foot,int state,int i,int j){\n    return foot*w*h*9+state*w*h+i*w+j;\n}\n\nint main(){\n    int cango[9][2];//where right is from left,yx\n    int hoge = 0;\n    for(int y = 0;y<=2;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    for(int y = -2;y<=-1;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    while(1){\n        vector<PI> G[3600*9+5];//0???????¶? 1???????¶? to,cost\n        int dist[3600*9+5];\n        bool goal[3600*9+5];\n        rep(i,3600*9+5){\n            dist[i]=INF;\n            goal[i]=0;\n        }\n        cin>>w>>h;\n        if(w==0){\n            return 0;\n        }\n        char c;\n        rep(i,h){\n            rep(j,w){\n                cin>>c;\n                if(c=='S')        map[i][j]=0;\n                else if(c=='T')   map[i][j]=-1;\n                else if(c=='X')   map[i][j]=INF;\n                else map[i][j]=c-'0';\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(!checkin(i,j))continue;\n                rep(state1,9){\n                    int y=i+cango[state1][0],x=j+cango[state1][1];\n                    if(!checkin(y,x))continue;\n                    if(map[i][j]==-1||map[y][x]==-1){\n                        goal[make(0,state1,i,j)]=true;\n                        goal[make(1,state1,i,j)]=true;\n                    }\n                    rep(state2,9){\n                        if(state1==state2)\n                            continue;\n                        int ny=i+cango[state2][0],nx=j+cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(0,state1,i,j)].pb(mp(make(1,state2,i,j),retc(ny,nx)));\n                        }\n                        ny=y-cango[state2][0],nx=x-cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(1,state1,i,j)].pb(mp(make(0,state2,ny,nx),retc(ny,nx)));\n                        }\n\n                    }\n                }\n            }\n        }\n//        rep(i,3600*9+5){\n//            if(!G[i].empty()){\n//                rep(j,G[i].size()){\n//                    cout<<\"from:\"<< \" foot:\" <<i/(w*h*9) <<\" state:\"<<i/w/h%9<<\" i j:(\"<< i/w%h<< \" \"<<i%w<< \")\"<<endl;\n//\n//                    cout<<\"to  :\"<< \" foot:\" <<G[i][j].first/(w*h*9) <<\" state:\"<<G[i][j].first/w/h%9<<\" i j:(\"<< G[i][j].first/w%h<< \" \"<<G[i][j].first%w <<\") cost:\"<<G[i][j].second<<endl<<endl;\n//                }\n//            }\n//        }\n        priority_queue<PI, vector<PI> ,greater<PI> > pq;\n        rep(j,w){\n            if(map[h-1][j]!=0){continue;}\n            rep(st,9){\n                int y = h-1+cango[st][0],x = j+cango[st][1];\n                if(checkin(y,x)){pq.push(mp(\bretc(y,x),(make(1,st,y,x))));}\n                y = h-1-cango[st][0],x = j-cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(0,st,y,x))));}\n            }\n        }\n        int ans = -1;\n        while(!pq.empty()){\n            PI now = pq.top();\n            int cost = now.first;\n            int from = now.second;\n            pq.pop();\n            if(dist[from]<cost){\n                continue;\n            }\n            dist[from]=cost;\n            if(goal[from]){\n                if(ans==-1){\n                    ans = cost;\n                }\n                ans = min(ans,cost);\n            }\n            rep(i,G[from].size()){\n                if(dist[G[from][i].first]>cost+G[from][i].second)\n                    pq.push(mp(G[from][i].second+cost,G[from][i].first));\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define Y first\n#define X second\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint W,H;\nchar s[65][35];\nint d[65][35][2];\n\nstruct cliffState{\n  int step;\n  int y;\n  int x;\n  int side;\n  cliffState(int _step, int _y, int _x, int _side){\n    step = _step;\n    y = _y;\n    x = _x;\n    side = _side;\n  }\n  bool operator >(const cliffState &e) const{\n    return step > e.step;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>W>>H;\n    if(W==0 || H==0) break;\n    vector< pair<int, int> > iniv;\n    REP(i,0,H){\n      REP(j,0,W){\n        cin>>s[i][j];\n        if(s[i][j]=='S') iniv.push_back(make_pair(i,j));\n      }\n    }\n\n    int ans = INF;\n\n    REP(inipos,0,iniv.size()){/*?????????????????°????????°?????????????????§W???H????????????*/\n      REP(iniside,0,2){\n\n        REP(i,0,H)REP(j,0,W)REP(k,0,2) d[i][j][k] = INF;\n        d[iniv[inipos].Y][iniv[inipos].X][iniside] = 0;\n\n        priority_queue< cliffState, vector<cliffState>, greater<cliffState> > PQ;\n        cliffState cs = cliffState(0,iniv[inipos].Y,iniv[inipos].X,iniside);\n        PQ.push(cs);\n\n        while(!PQ.empty()){\n\n          cliffState nowPos = PQ.top();\n          PQ.pop();\n          if(d[nowPos.y][nowPos.x][nowPos.side] < nowPos.step) continue;\n\n          REP(i,nowPos.y-2,nowPos.y+2+1){\n            if(i < 0 || H <= i) continue;\n            int diff;\n            if(i == nowPos.y-2 || i == nowPos.y+2) diff = 1;\n            else if(i == nowPos.y-1 || i == nowPos.y+1) diff = 2;\n            else diff = 3;\n            if(nowPos.side == 0){\n              REP(j,nowPos.x+1,nowPos.x+diff+1){\n                if(j < 0 || W <= j || i < 0 || H <= i) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }else{\n              REP(j,nowPos.x-diff,nowPos.x){\n                if(j < 0 || W <= j) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }\n\n          }\n\n        }\n\n        int tans = INF;\n        REP(i,0,H){\n          REP(j,0,W){\n            REP(k,0,2){\n              if(s[i][j] == 'T') tans = min(tans, d[i][j][k]);\n            }\n          }\n        }\n        ans = min(ans,tans);\n\n      }\n    }\n\n    if(ans == INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MAX = 1LL << 50;\n\nll h, w;\nll a[30][50];\nchar b[30][50];\nll minr[30][50];//????????°???????°????\nll minl[30][50];//????????°???????°????\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\nqueue<P> quer;\nqueue<P> quel;\n\nvoid doRight() {\n\twhile (!quel.empty()) {\n\t\tP p = quel.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquel.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x + dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minr[yy][xx] > minl[y][x] +a[yy][xx]) {\n\t\t\t\tminr[yy][xx] = minl[y][x] + a[yy][xx];\n\t\t\t\tquer.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid doLeft() {\n\twhile (!quer.empty()) {\n\t\tP p = quer.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquer.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x - dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minl[yy][xx] > minr[y][x] +a[yy][xx]) {\n\t\t\t\tminl[yy][xx] = minr[y][x] + a[yy][xx];\n\t\t\t\tquel.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n//enum LR{L=-1,R=1};\nint w,h;\nchar s[65][35];\nint ddx[9]={1,1,1,1,1,2,2,2,3};\nint ddy[9]={2,1,0,-1,-2,1,0,-1,0};\nint dis[65][35][2];\n\nstruct cliff{\n\tint x;\n\tint y;\n\tint cost;\n\tint LR;\n\tcliff(int _x,int _y,int _cost,int _LR){\n\t\tx=_x;\n\t\ty=_y;\n\t\tcost=_cost;\n\t\tLR=_LR;\n\t};\n\tbool operator<(const cliff& c) const{\n\t\treturn cost>c.cost;\n\t}\n};\npriority_queue<cliff> PP;\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tREP(i,65)\n\t\t\tREP(j,35)\n\t\t\t\tREP(k,2)\n\t\t\t\tdis[i][j][k]=1e8;\n\t\tfor(int i=h-1;i>=0;i--){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>s[i][j];\n\t\t\t\tif(s[i][j]=='S'){\n\t\t\t\t\tPP.push(cliff(j,i,0,-1));//右足がついている\n\t\t\t\t\tPP.push(cliff(j,i,0,1));//左足\n\t\t\t\t\tdis[i][j][0]=0;\n\t\t\t\t\tdis[i][j][1]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<PP.size()<<endl;\n\t\tint cou=0;\n\t\twhile(PP.size()){\n\t\t\t\n\t\t\tcliff c=PP.top();PP.pop();\n\t\t\t//if(cou<=4)cout<<c.x<<c.y<<c.LR<<endl;\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint nx=c.x+ddx[i]*c.LR;\n\t\t\t\tint ny=c.y+ddy[i];\n\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\t\tif(s[ny][nx]!='X'){\n\t\t\t\t\t\tint nLR;\n\t\t\t\t\t\tif(c.LR==-1)nLR=1;\n\t\t\t\t\t\telse nLR=0;\n\t\t\t\t\t\tint ncost;\n\t\t\t\t\t\tif(s[ny][nx]=='T')ncost=0;\n\t\t\t\t\t\telse if(s[ny][nx]>='1'&&s[ny][nx]<='9')ncost=s[ny][nx]-'0';\n\t\t\t\t\t\telse continue;\n\t\t\t\t\t\tif(dis[ny][nx][nLR]==1e8){\n\t\t\t\t\t\t\tdis[ny][nx][nLR]=ncost+c.cost;\n\t\t\t\t\t\t\tif(ncost!=0){\n\t\t\t\t\t\t\t\tPP.push(cliff(nx,ny,dis[ny][nx][nLR],c.LR*-1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcou++;\n\t\t}\n\t\tint ans=1e8;\n\t\tfor(int i=h-1;i>=0;i--){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t//printf(\"%10d\",dis[i][j][0]);\n\t\t\t\tif(s[i][j]=='T'){\n\t\t\t\t\tans=min(min(ans,dis[i][j][0]),dis[i][j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\t//cout<<endl;\n\t\t/*for(int i=h-1;i>=0;i--){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%10d\",min(dis[i][j][1],dis[i][j][0]));\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tif(ans==1e8)cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct state{\n  int li,lj,ri,rj,f;\n  int dist;\n};\nbool operator<(const state& a,const state& b){ return a.dist > b.dist; }\n\nint h,w;\nchar s[111][111];\nint dist[33][66][3];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    rep(i,h)rep(j,w)cin>>s[i][j];\n    priority_queue<state> que;\n    rep(i,33)rep(j,66)rep(k,3)dist[i][j][k]=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='S'){\n        que.push((state){i,j,-1,-1,0,0});\n        que.push((state){-1,-1,i,j,1,0});\n      }\n    }\n    while(que.size()){\n      state ns=que.top(); que.pop();\n      int li=ns.li,lj=ns.lj,ri=ns.ri,rj=ns.rj,f=ns.f,nd=ns.dist;\n      if((f==0&&dist[li][lj][0]!=INF)||(f==1&&dist[ri][rj][1]!=INF))continue;\n      if(f==0){\n        //dbg(li); dbg(lj);\n        dist[li][lj][f]=nd;\n        repl(ni,li-2,li+3)repl(nj,lj+1,lj+4){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-li)+abs(nj-lj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){li,lj,ni,nj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }else{\n        dist[ri][rj][f]=nd;\n        repl(ni,ri-2,ri+3)repl(nj,rj-3,rj){\n          if(ni>=0&&ni<h&&nj>=0&&nj<w&&abs(ni-ri)+abs(nj-rj)<=3&&s[ni][nj]!='X'&&s[ni][nj]!='S'){\n            que.push((state){ni,nj,ri,rj,1-f,nd+(s[ni][nj]=='T'?0:(s[ni][nj]-'0'))});\n          }\n        }\n      }\n    }\n    int res=INF;\n    rep(i,h)rep(j,w){\n      if(s[i][j]=='T')minch(res,min(dist[i][j][0],dist[i][j][1]));\n    }\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<pair<ll, ll>, pair<ll, ll>> P;\n\nvector<pair<ll, ll>> move_L;\nvector<pair<ll, ll>> move_R;\n\nint d[2][111][55];\nchar mp[111][55];\n\nvoid make_move(){\n\tfor(int i = -2;i <= 2;i++){\n\t\tfor(int j = 1;j <= 3;j++){\n\t\t\tif(abs(i) + abs(j) <= 3)move_R.EB(i, j);\n\t\t}\n\t}\n\n\tfor(int i = -2;i <= 2;i++){\n\t\tfor(int j = -3;j <= -1;j++){\n\t\t\tif(abs(i) + abs(j) <= 3)move_L.EB(i, j);\n\t\t}\n\t}\n}\n\nvoid init() {\n\tREP(i, 2)REP(j, 111)REP(k, 55){\n\t\td[i][j][k] = INF;\n\t\tmp[j][k] = 'X';\n\t}\n}\n\nvoid solve(int h, int w){\n\tinit();\n\tvector<pair<ll, ll>> goal;\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\n\tREP(i, h){\n\t\tREP(j, w){\n\t\t\tcin >> mp[i + 5][j + 5];\n\t\t\tif(mp[i + 5][j + 5] == 'S'){\n\t\t\t\td[0][i + 5][j + 5] = 0;\n\t\t\t\td[1][i + 5][j + 5] = 0;\n\n\t\t\t\tpq.push(MP(MP(0, 0), MP(i + 5, j + 5)));\n\t\t\t\tpq.push(MP(MP(0, 1), MP(i + 5, j + 5)));\n\n\t\t\t\tmp[i + 5][j + 5] = '0';\n\t\t\t}\n\n\t\t\tif(mp[i + 5][j + 5] == 'T'){\n\t\t\t\tgoal.EB(i + 5, j + 5);\n\n\t\t\t\tmp[i + 5][j + 5] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << \"end inpit \" << endl;\n\n\twhile(!pq.empty()){\n\t\tint now_d = pq.top().FI.FI;\n\t\tint now_type = pq.top().FI.SE;\n\t\tint now_y = pq.top().SE.FI;\n\t\tint now_x = pq.top().SE.SE;\n\n\t\t//cout << now_d << \" \" << now_type << \" \" << now_y << \" \" << now_x << endl;\n\n\t\tpq.pop();\n\n\t\tif(now_d > d[now_type][now_y][now_x])continue;\n\t\tif(now_type){\n\t\t\tREP(i, move_L.size()){\n\t\t\t\tint nxt_y = now_y + move_L[i].FI;\n\t\t\t\tint nxt_x = now_x + move_L[i].SE;\n\n\t\t\t\tif(mp[nxt_y][nxt_x] == 'X')continue;\n\n\t\t\t\tint nxt_d = d[now_type][now_y][now_x] + (mp[nxt_y][nxt_x] - '0');\n\t\t\t\tif(d[1 - now_type][nxt_y][nxt_x] > nxt_d) {\n\t\t\t\t\td[1 - now_type][nxt_y][nxt_x] = nxt_d;\n\t\t\t\t\tpq.push(MP(MP(nxt_d, 1 - now_type), MP(nxt_y, nxt_x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tREP(i, move_R.size()){\n\t\t\t\tint nxt_y = now_y + move_R[i].FI;\n\t\t\t\tint nxt_x = now_x + move_R[i].SE;\n\n\t\t\t\tif(mp[nxt_y][nxt_x] == 'X')continue;\n\n\t\t\t\tint nxt_d = d[now_type][now_y][now_x] + (mp[nxt_y][nxt_x] - '0');\n\t\t\t\tif(d[1 - now_type][nxt_y][nxt_x] > nxt_d) {\n\t\t\t\t\td[1 - now_type][nxt_y][nxt_x] = nxt_d;\n\t\t\t\t\tpq.push(MP(MP(nxt_d, 1 - now_type), MP(nxt_y, nxt_x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << \"end daikusutora\" << endl;\n\n\tint ans = INF;\n\tREP(i, goal.size()){\n\t\tans = min(ans, d[0][goal[i].FI][goal[i].SE]);\n\t\tans = min(ans, d[1][goal[i].FI][goal[i].SE]);\n\t}\n\n\tcout << (ans < INF ? ans:-1) << endl;\n\n\treturn;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tmake_move();\n\tint h, w;\n\twhile(cin >> w >> h,h | w){\n\t\tsolve(h, w);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Foot{\n\tLeft,\n\tRight,\n};\n\nint H,W;\nint**** min_Time;\n\nint diff_row_right[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_right[9] = {1,1,2,1,2,3,1,2,1};\nint diff_row_left[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_left[9] = {-1,-2,-1,-3,-2,-1,-2,-1,-1};\n\nstruct Info{\n\tInfo(){\n\t\tleft_row = left_col = right_row = right_col = time = 0;\n\t\tfoot = Left;\n\t}\n\n\tInfo(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tvoid set(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tint left_row,left_col,right_row,right_col,time;\n\tFoot foot;\n};\n\nstruct Cell{\n\tCell(){\n\t\trow = col = 0;\n\t}\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tmin_Time[a][b][c][d] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Cell> V;\n\n\tchar map[H][W+1];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%s\",&map[i][k]);\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tV.push_back(Cell(i,k));\n\t\t\t\tmap[i][k] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tint first_left_row,first_left_col,first_right_row,first_right_col,add_time;\n\n\tfor(int a = 0; a < V.size(); a++){\n\n\t\tfirst_left_row = V[a].row;\n\t\tfirst_left_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_right_row = first_left_row + diff_row_right[i];\n\t\t\tfirst_right_col = first_left_col + diff_col_right[i];\n\n\t\t\tif(rangeCheck(first_right_row,first_right_col) == true && map[first_right_row][first_right_col] != 'X'){\n\t\t\t\tif(map[first_right_row][first_right_col] >= '0' && map[first_right_row][first_right_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_right_row][first_right_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Right));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfirst_right_row = V[a].row;\n\t\tfirst_right_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_left_row = first_right_row + diff_row_left[i];\n\t\t\tfirst_left_col = first_right_col + diff_col_left[i];\n\n\t\t\tif(rangeCheck(first_left_row,first_left_col) == true && map[first_left_row][first_left_col] != 'X'){\n\t\t\t\tif(map[first_left_row][first_left_col] >= '0' && map[first_left_row][first_left_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_left_row][first_left_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Left));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM,next_left_row,next_left_col,next_right_row,next_right_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.front().left_row][Q.front().left_col] == 'T' || map[Q.front().right_row][Q.front().right_col] == 'T'){\n\t\t\tans = min(ans,Q.front().time);\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > min_Time[Q.front().left_row][Q.front().left_col][Q.front().right_row][Q.front().right_col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(Q.front().foot == Left){\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_right_row = Q.front().left_row + diff_row_right[i];\n\t\t\t\t\tnext_right_col = Q.front().left_col + diff_col_right[i];\n\n\t\t\t\t\tif(rangeCheck(next_right_row,next_right_col) == true && map[next_right_row][next_right_col] != 'X'){\n\t\t\t\t\t\tif(map[next_right_row][next_right_col] >= '0' && map[next_right_row][next_right_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_right_row][next_right_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[Q.front().left_row][Q.front().left_col][next_right_row][next_right_col] > Q.front().time+add_time){\n\t\t\t\t\t\t\tmin_Time[Q.front().left_row][Q.front().left_col][next_right_row][next_right_col] = Q.front().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(Q.front().left_row,Q.front().left_col,next_right_row,next_right_col,Q.front().time+add_time,Right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //Q.front().foot == Right\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_left_row = Q.front().right_row + diff_row_left[i];\n\t\t\t\t\tnext_left_col = Q.front().right_col + diff_col_left[i];\n\n\t\t\t\t\tif(rangeCheck(next_left_row,next_left_col) == true && map[next_left_row][next_left_col] != 'X'){\n\t\t\t\t\t\tif(map[next_left_row][next_left_col] >= '0' && map[next_left_row][next_left_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_left_row][next_left_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[next_left_row][next_left_col][Q.front().right_row][Q.front().right_col] > Q.front().time+add_time){\n\t\t\t\t\t\t\tmin_Time[next_left_row][next_left_col][Q.front().right_row][Q.front().right_col] = Q.front().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(next_left_row,next_left_col,Q.front().right_row,Q.front().right_col,Q.front().time+add_time,Left));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_Time = new int***[60];\n\tfor(int i = 0; i < 60; i++){\n\t\tmin_Time[i] = new int**[30];\n\t\tfor(int k = 0; k < 30; k++){\n\t\t\tmin_Time[i][k] = new int*[60];\n\t\t\tfor(int p = 0; p < 60; p++){\n\t\t\t\tmin_Time[i][k][p] = new int[30];\n\t\t\t\t//for(int q = 0; q < 30; q++)min_Time[i][k][p][q] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    脳がない\n */\n\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define LEFT 0\n#define RIGHT 1\n#define INF 0x3fffffff\n\ntypedef pair<int, int> Coor;\ntypedef pair<int, Coor> Data;\ntypedef pair<int, Data> Pair;\n\nint w;\nint h;\nint ans;\nbool is_goal[60][30];\nint cost[60][30];\nint lmin[60][30];\nint rmin[60][30];\n\nint main() {\n    while (1) {\n        queue<Pair> q;\n\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0) return 0;\n\n        ans = INF;\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                lmin[i][j] = INF;\n                rmin[i][j] = INF;\n            }\n        }\n\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                char c;\n\n                is_goal[i][j] = false;\n                scanf(\" %c\", &c);\n                if (c == 'X') {\n                    cost[i][j] = INF;\n                } else if (c == 'S') {\n                    cost[i][j] = 0;\n                    lmin[i][j] = 0;\n                    rmin[i][j] = 0;\n                    q.push(Pair(0, Data(LEFT, Coor(j, i))));\n                    q.push(Pair(0, Data(RIGHT, Coor(j, i))));\n                } else if (c == 'T') {\n                    cost[i][j] = 0;\n                    is_goal[i][j] = true;\n                } else {\n                    cost[i][j] = c - '0';\n                    assert(1 <= cost[i][j] && cost[i][j] <= 9);\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            Pair p = q.front(); q.pop();\n            int dist = p.first;\n            Data d = p.second;\n            int last = d.first;\n            Coor c = d.second;\n            int x = c.first;\n            int y = c.second;\n\n            if (last ==  LEFT && dist > lmin[y][x]) continue;\n            if (last == RIGHT && dist > rmin[y][x]) continue;\n\n            if (last == LEFT) {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x + 3-i;\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n                        if (cost[_y][_x] == INF) continue;\n\n                        if (rmin[_y][_x] > dist + cost[_y][_x]) {\n                            rmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, rmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(rmin[_y][_x], Data(RIGHT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            } else {\n                for (int i=2; i>=0; i--) {\n                    for (int j=-i; j<=i; j++) {\n                        int _x = x - (3-i);\n                        int _y = y + j;\n\n                        if (_x < 0 || w <= _x) continue;\n                        if (_y < 0 || h <= _y) continue;\n                        if (cost[_y][_x] == INF) continue;\n\n                        if (lmin[_y][_x] > dist + cost[_y][_x]) {\n                            lmin[_y][_x] = dist + cost[_y][_x];\n                            if (is_goal[_y][_x]) {\n                                ans = min(ans, lmin[_y][_x]);\n                                continue;\n                            }\n                            q.push(Pair(lmin[_y][_x], Data(LEFT, Coor(_x, _y))));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (ans < INF) {\n            printf(\"%d\\n\", ans);\n        } else {\n            puts(\"-1\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\n\nconst int INF = 1 << 28;\n\nint dlx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nint drx[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint dy[]  = {-2,-1, 0, 1, 2,-1, 0, 1, 0};\n\n\nint main ()\n{\n    int h, w;\n    while (cin >> w >> h, h + w) {\n        vector<vector<int> > field(h, vector<int>(w, INF));\n        vector<P> s;\n        vector<P> t;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char str;\n                cin >> str;\n                if ('0' <= str && str <= '9') {\n                    field[i][j] = (int)(str - '0');\n                } else if (str == 'T') {\n                    field[i][j] = 0;\n                    t.push_back(P(i,j));\n                } else if (str == 'S') {\n                    field[i][j] = 0;\n                    s.push_back(P(i,j));\n                } else if (str == 'X') {\n                    field[i][j] = INF;\n                }\n            }\n        }\n\n        priority_queue<PPP, vector<PPP>, greater<PPP> > que;\n        vector<vector<vector<int> > > d(2, vector<vector<int> >(h, vector<int>(w, INF)));\n        for (int i = 0; i < s.size(); i++) {\n            que.push(PPP(0, PP(0, P(s[i])) ) );\n            que.push(PPP(0, PP(1, P(s[i])) ) );\n            d[0][s[i].first][s[i].second] = 0;\n            d[1][s[i].first][s[i].second] = 0;\n        }\n\n        while (que.size()) {\n            PPP ppp = que.top(); que.pop();\n            int cost = ppp.first;\n            PP pp = ppp.second;\n            int dir = pp.first;\n            int y = pp.second.first;\n            int x = pp.second.second;\n\n            if (d[dir][y][x] < cost) continue;\n\n            for (int i = 0; i < 9; i++) {\n                int nx = x, ny = dy[i] + y;\n                nx += dir == 1 ? dlx[i] : drx[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != INF) {\n                    if (d[1 - dir][ny][nx] > cost + field[ny][nx]) {\n                        d[1 - dir][ny][nx] = cost + field[ny][nx];\n                        que.push(PPP(d[1 - dir][ny][nx], PP(1 - dir, P(ny, nx) ) ) );\n                    }\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < t.size(); i++) {\n            int y = t[0].first;\n            int x = t[0].second;\n            res = min(res, d[0][y][x]);\n            res = min(res, d[1][y][x]);\n        }\n\n        cout << (INF == res ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nint INF = 1 << 10;\n\nvector<P> start;\nvector<int> d;\nP dxy[] = {P(1, 2), P(1, 1), P(1, 0), P(1, -1), P(1, -2),\n\t\t   P(2, 1), P(2, 0), P(2, -1),\n\t\t   P(3, 0)};\nvector<vector<int> > weights;\n\n\nstruct node{\n  int cost;\n  P pos;\n  int left;\n  bool operator>(const node& a) const{\n\treturn this->cost > a.cost;\n  }\n  node(int c, P p, int l){\n\tcost = c;\n\tpos = p;\n\tleft = l;\n  }\n  \n};\n\nvoid test(){\n  cout << \"=====test=====\" << endl;\n  node a(10, P(0, 0), 1), b(11, P(10, 2), 0);\n  a.cost = 10; a.pos = P(0, 0); a.left = 1;\n  b.cost = 11; b.pos = P(10, 2); b.left = 0;\n  if(a > b) cout << \"a > b\" << endl;\n  else cout << \"a < b\" << endl;\n}\n\n\nvoid displayStage(vector<vector<char> > stage, int w, int h){\n  for(int i = 0; i < h; i ++){\n\tfor(int j = 0; j < w; j++){\n\t  cout << stage[i][j] << \" \";\n\t}\n\tcout << endl;\n  }\n  cout << endl;\n}\n\nvoid getStart(vector<vector<char> > stage, int w, int h){\n  start.clear();\n  for(int i = 0; i < h; i++){\n\tfor(int j = 0; j < w; j++){\n\t  if(stage[i][j] == 'S'){\n\t\tstart.push_back(P(i, j));\n\t  }\n\t}\n  }\n}\n\nvoid displayStart(){\n  for(int i = 0; i < start.size(); i++){\n\tcout << \"( \" << start[i].first << \", \" << start[i].second << \" )\" << endl;\n  }\n  cout << endl;\n}\n\nvoid init(int w, int h){\n  d.clear();\n  for(int i = 0; i < w * h * 2; i++){\n\td.push_back(INF);\n  }\n}\n\nvoid displayD(int w, int h, int left){\n  if(left == 0){\n\tcout << \"right\" << endl;\n\tfor(int i = 0; i < h; i++){\n\t  for(int j = 0; j < w; j++){\n\t\tif(d[i*w + j] == INF) cout << \"INF \";\n\t\telse cout << d[i*w + j] << \" \";\n\t  }\n\t  cout << endl;\n\t}\n\tcout << endl;\n  }\n  else{\n\tcout << \"left\" << endl;\n\tfor(int i = 0; i < h; i++){\n\t  for(int j = 0; j < w; j++){\n\t\tif(d[(h*w) + i*w + j] == INF) cout << \"INF \";\n\t\telse cout << d[(h*w) + i*w + j] << \" \";\n\t  }\n\t  cout << endl;\n\t}\n\tcout << endl;\n  }\n}\n\nvoid makeWeights(vector<vector<char> > stage, int w, int h){\n  weights.clear();\n  weights.resize(h);\n  for(int i = 0; i < h; i++){\n\tweights[i].resize(w);\n\tfor(int j = 0; j < w; j++){\n\t  if(stage[i][j] == 'T' || stage[i][j] == 'S') weights[i][j] = 0;\n\t  else weights[i][j] = (int)(stage[i][j] - '0');\n\t}\n  }\n}\n\nint solve(vector<vector<char> > stage, int w, int h){\n  init(w, h);\n  getStart(stage, w, h);\n  makeWeights(stage, w, h);\n  priority_queue<node, vector<node>, greater<node> > pq;\n  for(int i = 0; i < start.size(); i++){\n\td[0 * (h*w) + start[i].first*w + start[i].second] = 0;\n\td[1 * (h*w) + start[i].first*w + start[i].second] = 0;\n\tpq.push(node(0, start[i], 1));\n\tpq.push(node(0, start[i], 0));\n  }\n\n  while(!pq.empty()){\n\tnode n = pq.top(); pq.pop();\n\tif(stage[n.pos.first][n.pos.second] == 'T'){\n\t  return d[n.left * (h*w) + n.pos.first*w + n.pos.second];\n\t}\n\tfor(int i = 0; i < 9; i++){\n\t  int nx = n.pos.second + (n.left ? dxy[i].first : -dxy[i].first);\n\t  int ny = n.pos.first + (n.left ? dxy[i].second : -dxy[i].second);\n\t  if(0 <= nx && nx < w && 0 <= ny && ny < h && stage[ny][nx] != 'X'){\n\t\tint t = n.left ^ 1;\n\t\tif(d[t * (h*w) + ny*w + nx] > d[n.left * (h*w) + n.pos.first*w + n.pos.second] + weights[ny][nx]){\n\t\t  d[t * (h*w) + ny*w + nx] = d[n.left * (h*w) + n.pos.first*w + n.pos.second] + weights[ny][nx];\n\t\t  pq.push(node(d[t * (h*w) + ny*w + nx], P(ny, nx), t));\n\t\t}\n\t  }\n\t}\n  }\n  return -1;\n  \n}\n\n\nint main(){\n  int w, h;\n  while(1){\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tvector<vector<char> > stage(h);\n\tfor(int i = 0; i < h; i++){\n\t  stage[i].resize(w);\n\t  for(int j = 0; j < w; j++){\n\t\tcin >> stage[i][j];\n\t  }\n\t}\n\n\tcout << solve(stage, w, h) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n//((コスト, 次動かす足), (left(y, x), right(y, x)))\ntypedef pair<pii, pair<pii, pii>> State;\n#define F first\n#define S second\n\nenum {kLeft = 0, kRight};\n\nconst vi dx = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst vi dy = {-2,-1, 0, 1, 2,-1, 0, 1, 0};\n\nint main(void){\n    for(int w, h; cin >> w >> h, w;){\n        vector<vector<char>> field(h, vector<char>(w));\n\n        priority_queue<State, vector<State>, greater<State>> q;\n\n        rep(y, h){\n            rep(x, w){\n                cin >> field[y][x];\n\n                if(field[y][x] == 'S'){\n                    q.push(mp(mp(0, kLeft),  mp(mp(y, x), mp(y, x))));\n                    q.push(mp(mp(0, kRight), mp(mp(y, x), mp(y, x))));\n\n                    field[y][x] = '0';\n                }\n            }\n        }\n\n        map<pair<int, pair<pii, pii>>, int> min_dist;\n        int res = -1;\n        while(!q.empty()){\n            int cur_cost = q.top().F.F;\n            int cur_foot = q.top().F.S;\n            pair<pii, pii> cur_pos = q.top().S;\n            q.pop();\n\n            if(min_dist.find(mp(cur_foot, cur_pos)) != min_dist.end()) continue;\n            \n            min_dist[mp(cur_foot, cur_pos)] = cur_cost;\n\n            if(field[cur_pos.F.F][cur_pos.F.S] == 'T' || \n               field[cur_pos.S.F][cur_pos.S.S] == 'T'){\n                res = cur_cost;\n                break;\n            }\n\n            int next_foot = cur_foot == kLeft ? kRight:kLeft;\n            rep(i, dx.size()){\n                pair<pii, pii> next_pos = cur_pos;\n\n                if(cur_foot == kLeft){\n                    next_pos.F.F = cur_pos.S.F + dy[i];\n                    next_pos.F.S = cur_pos.S.S - dx[i];\n                }\n                else{\n                    next_pos.S.F = cur_pos.F.F + dy[i];\n                    next_pos.S.S = cur_pos.F.S + dx[i];\n                }\n\n                if(next_pos.F.F < 0 || h <= next_pos.F.F ||\n                   next_pos.F.S < 0 || w <= next_pos.F.S ||\n                   next_pos.S.F < 0 || h <= next_pos.S.F ||\n                   next_pos.S.S < 0 || w <= next_pos.S.S)\n                    continue;\n\n                if(min_dist.find(mp(next_foot, next_pos)) != min_dist.end()) continue;\n\n                int next_cost = cur_cost;\n                char c = cur_foot == kLeft ? field[next_pos.F.F][next_pos.F.S]:field[next_pos.S.F][next_pos.S.S];\n                if(c == 'X') continue;\n                if(c != 'T') next_cost += c - '0';\n\n                q.push(mp(mp(next_cost, next_foot), next_pos));\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int W, H;\n    while (cin >> W >> H, W || H) {\n        vector<vector<int>> S(H, vector<int>(W));\n        vector<PII> goals;\n\n        int d[100][100][2] = {};\n        fill(d[0][0], d[0][0] + 100 * 100 * 2, INF);\n\n        rep(h, H) rep(w, W) {\n            char T; cin >> T;\n            if (T == 'S') {\n                S[h][w] = 0;\n                rep(i, 2) d[h][w][i] = 0;\n            } else if (T == 'T') {\n                S[h][w] = 0;\n                goals.emplace_back(h, w);\n            } else if (T == 'X') {\n                S[h][w] = -1;\n            } else {\n                S[h][w] = T - '0';\n            }\n        }\n\n        bool update = true;\n        while (update) {\n            update = false;\n            rep(y, H) rep(x, W) rep(leg, 2) {\n                if (d[y][x][leg] != INF) {\n                    REP(ny, y-3, y+4) REP(nx, x-3, x+4) {\n                        if (!in_range(nx, ny, W, H) || S[ny][nx] < 0 || abs(nx - x) + abs(ny - y) > 3) continue;\n                        if ((leg == 0 && x < nx) || (leg == 1 && x > nx)) {\n                            int nleg = 1 - leg;\n                            if (d[ny][nx][nleg] > d[y][x][leg] + S[ny][nx]) {\n                                update = true;\n\n#ifdef DEBUG\n                                cerr << \"update: (x, y, leg) = (\" << x << \", \" << y << \", \" << leg << \")\" << endl;\n                                cerr << d[ny][nx][nleg] << \" -> \" << d[y][x][leg] + S[ny][nx] << endl;\n#endif\n\n                                d[ny][nx][nleg] = d[y][x][leg] + S[ny][nx];\n\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = INF;\n        for (auto g : goals) {\n            rep(leg, 2) ans = min(ans, d[g.first][g.second][leg]);\n        }\n\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <queue>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define MP make_pair\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nstruct state{\n\tint x, y;\n\tint foot; // 現在かけている足 0 => 左 1 => 右\n\tint time;\n\tstate(int x, int y, int f, int t):x(x),y(y),foot(f),time(t){}\n\tbool operator<(const state &r)const{\n\t\treturn time > r.time;\n\t}\n};\n\nint feet[30][60][2];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\t\t// 左足の時は*-1して使う\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tvector<string> cliff(h);\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tcliff[i].push_back(c);\n\t\t\t}\n\t\t}\n\n\t\tmemset(feet, -1, sizeof(feet));\n\t\tpriority_queue<state> q;\n\t\trep(i, h)rep(j, w){\n\t\t\tif(cliff[i][j] == 'S'){\n\t\t\t\tq.push(state(j, i, 0, 0));\n\t\t\t\tq.push(state(j, i, 1, 0));\n\t\t\t\tfeet[j][i][0] = 0;\n\t\t\t\tfeet[j][i][1] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\twhile(!q.empty()){\n\t\t\tstate s = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(feet[s.x][s.y][s.foot] != s.time) continue;\n\t\t\t\n\t\t\tif(cliff[s.y][s.x] == 'T'){\n\t\t\t\tans = s.time;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 9){\n\t\t\t\tint x = s.x+dx[i]*(s.foot?-1:1); // 現在右足なら*-1\n\t\t\t\tint y = s.y+dy[i];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h) continue;\n\t\t\t\tif(cliff[y][x] == 'X') continue;\n\t\t\t\tint t = (cliff[y][x]=='T'?0:cliff[y][x]-'0');\n\t\t\t\tstate next = s;\n\t\t\t\tnext.foot = !s.foot;\n\t\t\t\tnext.time += t;\n\t\t\t\tif(feet[x][y][next.foot] != -1 && feet[x][y][next.foot] <= next.time) continue;\n\t\t\t\tfeet[x][y][next.foot] = next.time;\n\t\t\t\tnext.x = x;\n\t\t\t\tnext.y = y;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t} // end while\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PIB(P(a,b),IB(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,bool> IB;\ntypedef pair<P,IB> PIB;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int left_dx[9] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nconst int left_dy[9] = {-2,-1,+0,+1,+2,-1,+0,+1,+0};\nconst int right_dx[9] = {+1,+1,+1,+1,+1,+2,+2,+2,+3};\nconst int right_dy[9] = {-2,-1,0,+1,+2,-1,+0,+1,+0};\n\n\nclass Solve{\n private:\n  int w,h;\n  int d[61][31][2]; // 0->left, 1->right\n  char cmap[61][31];\n public:\n  Solve(int w,int h):w(w),h(h){\n    rep(i,h)rep(j,w)rep(k,2)d[i][j][k] = INT_MAX;\n  }\n  ~Solve(){}\n\n  void input(){\n    rep(i,h)\n      rep(j,w)\n      cin >> cmap[i][j];\n  }\n\n  void printAll(){\n    cout << endl << \"### START ###\" << endl;\n    cout << \"w = \" << w << \",h = \" << h << endl;\n    cout << \"cmap --- \" << endl;\n    rep(i,h){\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n    cout << \"d_left --- \"<< endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][0] != INT_MAX)cout << d[i][j][0] << ' ';\n\telse cout << \"0 \";\n      }\n      cout << endl;\n    }\n\n    cout << endl << \"d_right --- \"<< endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][1] != INT_MAX)cout << d[i][j][1] << ' ';\n\telse cout << \"0 \";\n      }\n      cout << endl;\n    }\n    cout << endl << \"comb---\" << endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][0] == INT_MAX && d[i][j][1] != INT_MAX)cout << d[i][j][1] << ' ';\n\telse if(d[i][j][0] != INT_MAX && d[i][j][1] == INT_MAX)cout << d[i][j][0] << \" \";\n\telse if(d[i][j][0] != INT_MAX && d[i][j][1] != INT_MAX)cout << min(d[i][j][0],d[i][j][1]) << ' ';\n\telse cout << 0 << ' ';\n      }\n      cout << endl;\n    }\n    cout << \"### END ###\" << endl << endl;\n  }\n\n  void run(){\n    input();\n    deque<PIB> deq; // bool true->left,false->right\n    rep(i,w){\n      if(cmap[h-1][i] != 'S')continue;\n      d[h-1][i][1] = d[h-1][i][0] = 0; // %%%\n      deq.pb(insert(i,h-1,0,1));      \n      deq.pb(insert(i,h-1,0,0));\n    }\n\n    while(!deq.empty()){\n      PIB pib = deq.front(); deq.pop_front();\n      if(cmap[pib.F.S][pib.F.F] == 'T'){\n\tint lr = pib.S.S==0?0:1;\n\td[pib.F.S][pib.F.F][lr] = min(d[pib.F.S][pib.F.F][lr],pib.S.F);\n\tcontinue;\n      }\n     \n\n      P p = pib.F;\n      int LR = pib.S.S==0?0:1;\n      int rLR = LR == 0?1:0;\n      rep(i,9){\n\tint nx,ny;\n\tif(LR == 0)nx = p.F+right_dx[i],ny = p.S+right_dy[i];\n\telse nx = p.F+left_dx[i],ny = p.S+left_dy[i];\n\n\tif(!(0<= nx && nx < w && 0<= ny && ny < h))continue;\n\tif(cmap[ny][nx] == 'X')continue;\n\tint cost;\n\tif(cmap[ny][nx] == 'T')cost = 0;\n\telse cost = (cmap[ny][nx]-'0');\n\tif(d[ny][nx][rLR] <= cost+pib.S.F)continue;\n\td[ny][nx][rLR] =  cost+pib.S.F;\n\tif(deq.front().S.F < d[ny][nx][rLR])deq.pb(insert(nx,ny,d[ny][nx][rLR],rLR));\n\telse deq.pf(insert(nx,ny,d[ny][nx][rLR],rLR));  \n \n      }\n    }\n\n    output();\n\n  }\n  \n  void output(){\n    int MIN = INT_MAX;\n    rep(i,w){\n      if(cmap[0][i] == 'T')MIN = min(MIN,min(d[0][i][1],d[0][i][0]));\n    }\n    if(MIN != INT_MAX)cout << MIN << endl;\n    else cout << -1 << endl;\n  }\n\n\n};\n\nint main(){\n  int _w,_h;\n  while(cin >> _w >> _h && _w+_h){\n    Solve ans = Solve(_w,_h);\n    ans.run();\n    //ans.printAll();\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 2;\n\nstruct Edge\n{\n\tint y, x, cost;\n\tEdge( int y, int x, int c ) : y( y ), x( x ), cost( c )\n\t{\n\t\treturn;\n\t}\n};\n\nstruct State\n{\n\tint y, x, foot;\n\tState( int y, int x, int f ) : y( y ), x( x ), foot( f )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\treturn true;\n\t}\n};\n\ntypedef vector<Edge> VE;\ntypedef vector<VE> VVE;\ntypedef vector<VVE> VVVE;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< vector<char> > board( h, vector<char>( w ) );\n\t\tpriority_queue< pair<int,State>, vector< pair<int,State> >, greater< pair<int,State> > > que;\n\t\tvector<VVI> distance( h, VVI( w, VI( 2, INF ) ) );\n\t\tvector<PII> goals;\n\n\t\tREP( i, 0, h )\n\t\t{\n\t\t\tREP( j, 0, w )\n\t\t\t{\n\t\t\t\tcin >> board[i][j];\n\t\t\t\t\n\t\t\t\tswitch ( board[i][j] )\n\t\t\t\t{\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tque.push( MP( 0, State( i, j, 0 ) ) );\n\t\t\t\t\t\tque.push( MP( 0, State( i, j, 1 ) ) );\n\t\t\t\t\t\tdistance[i][j][0] = distance[i][j][1] = 0;\n\t\t\t\t\t\tboard[i][j] = '0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tgoals.PB( MP( i, j ) );\n\t\t\t\t\t\tboard[i][j] = '0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<VVVE> G( h, VVVE( w, VVE( 2 ) ) );\n\t\tREP( y1, 0, h )\n\t\t{\n\t\t\tREP( x1, 0, w )\n\t\t\t{\n\t\t\t\tif ( !( 0 <= y1 && y1 < h && 0 <= x1 && x1 < w ) || board[ y1 ][ x1 ] == 'X' )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP( y2, 0, h )\n\t\t\t\t{\n\t\t\t\t\tREP( x2, 0, w )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !( 0 <= y2 && y2 < h && 0 <= x2 && x2 < w ) || board[ y2 ][ x2 ] == 'X' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( x1 != x2 && abs( x1 - x2 ) + abs( y1 - y2 ) <= 3 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t( x1 < x2 ? G[ y1 ][ x1 ][0] : G[ y1 ][ x1 ][1] ).PB( Edge( y2, x2, board[ y1 ][ x1 ] - '0' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint dist = que.top().fst;\n\t\t\tState cur = que.top().snd;\n\t\t\tque.pop();\n\n\t\t\tif ( distance[ cur.y ][ cur.x ][ cur.foot ] < dist )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFOR( e, G[ cur.y ][ cur.x ][ cur.foot ] )\n\t\t\t{\n\t\t\t\tif ( dist + e.cost < distance[ e.y ][ e.x ][ !( cur.foot ) ] )\n\t\t\t\t{\n\t\t\t\t\tdistance[ e.y ][ e.x ][ !( cur.foot ) ] = dist + e.cost;\n\t\t\t\t\tque.push( MP( dist + e.cost, State( e.y, e.x, !( cur.foot ) ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\t\tFOR( goal, goals )\n\t\t{\n\t\t\tres = min( res, distance[ goal.fst ][ goal.snd ][0] );\n\t\t\tres = min( res, distance[ goal.fst ][ goal.snd ][1] );\n\t\t}\n\n\t\tcout << ( res == INF ? -1 : res ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) repi(i,0,n)\n#define mp make_pair\n#define pb push_back\n\nint w, h;\nstruct node {\n  int cst, state, x, y;\n  bool operator<(const node &o) const {\n    return cst > o.cst;\n  }\n};\n\nconst int MAX = 64;\nint f[MAX][MAX];\nbool inrange(int x, int y) {\n  return x >= 0 && y >= 0 && x < w && y < h;\n}\nint main()\n{\n  while(cin >> w >> h, w||h) {\n    rep(i, h) rep(j, w) {\n      char c;\n      cin >> c;\n      if(c == 'X') f[j][i] = -1;\n      else if(c == 'S' || c == 'T') f[j][i] = 0;\n      else f[j][i] = c-'0';\n    }\n    \n    priority_queue<node> pq;\n    rep(j, w) if(f[j][h-1] == 0) {\n      pq.push((node){0, 1, j, h-1});\n      pq.push((node){0, -1, j, h-1});\n    }\n    set<pair<pair<int, int>, int> > done;\n    int ans = -1;\n    while(pq.size()) {\n      int cst = pq.top().cst;\n      int state = pq.top().state;\n      int x = pq.top().x;\n      int y = pq.top().y;\n      pq.pop();\n      pair<pair<int, int>, int> key = mp(mp(x, y), state);\n      if(done.find(key) != done.end()) continue;\n      done.insert(key);\n      //      cout << x << \" \" << y << \" \" << cst << \" \" << state << endl;\n      if(f[x][y] == 0 && y == 0) {\n\tans = cst;\n\tbreak;\n      }\n      repi(i, 1, 4) repi(j,-2, 3) {\n\tint nx = x+state * i, ny = y+j;\n\tif(inrange(nx, ny) && f[nx][ny] != -1 && abs(x-nx) + abs(y-ny) <= 3) pq.push((node){cst+f[nx][ny], -state, nx, ny});\n      }\n      \n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int W = 30;\nconst int H = 60;\nconst int INF = 1 << 29;\n\nstruct foot{\n  int ly, lx, ry, rx;\n  foot(int ly=0, int lx=0, int ry=0, int rx=0):ly(ly),lx(lx),ry(ry),rx(rx){}\n};\n\nstruct state{\n  foot p;\n  int c;\n  bool isRight;\n  state(foot p=foot(0,0,0,0), bool ir=true, int c=0):p(p),c(c),isRight(ir){}\n  bool operator < (const state &s) const {\n    return c > s.c;\n  }\n};\n\nint w,h,v[H][W];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return v[y][x] != -1;\n}\n\nvector<foot> nextFoot(state s){\n  vector<foot> res;\n\n  for(int i=1;i<=3;i++){\n    for(int j=-3+i;j<=3-i;j++){\n      if(s.isRight){\n        if(!check(s.p.ly+j, s.p.lx+i)) continue;\n        res.push_back(foot(s.p.ly, s.p.lx, s.p.ly+j, s.p.lx+i));\n      } else {\n        if(!check(s.p.ry+j, s.p.rx-i)) continue;\n        res.push_back(foot(s.p.ry+j, s.p.rx-i, s.p.ry, s.p.rx));\n      }\n    }\n  }\n\n  return res;\n}\n\n  int d[H][W][H][W];\n\nint solve(){\n  priority_queue<state> q;\n  state u,u2;  \n\n  for(int i=0;i<h*w;i++) for(int j=0;j<h*w;j++) d[i/w][i%w][j/w][j%w] = INF;\n\n  for(int i=0;i<w-1;i++){\n    if(v[h-1][i] != -3) continue;\n    for(int j=1;j<3;j++){\n      if(j >= w || v[h-1][j] != -3) continue;\n      d[h-1][i][h-1][j] = 0;\n      q.push(state(foot(h-1, i, h-1, j), true));\n      q.push(state(foot(h-1, i, h-1, j), false));\n    }\n  }\n\n  while(!q.empty()){\n    u = q.top();\n    q.pop();\n\n    if(v[u.p.ly][u.p.lx] == -2 || v[u.p.ry][u.p.rx] == -2){\n      return u.c;\n    }\n\n    //cout << u.p.ly << ' ' << u.p.lx << ' ' << u.p.ry << ' ' << u.p.rx << ' ' << u.c << endl;\n\n    vector<foot> next = nextFoot(u);\n    for(int i=0;i<next.size();i++){\n      if(u.isRight){\n        u2 = state(next[i], !u.isRight);\n        if(v[u2.p.ry][u2.p.rx] < 0) u2.c = u.c;\n        else u2.c = u.c + v[u2.p.ry][u2.p.rx];\n      } else {\n        u2 = state(next[i], !u.isRight);\n        if(v[u2.p.ly][u2.p.lx] < 0) u2.c = u.c;\n        else u2.c = u.c + v[u2.p.ly][u2.p.lx];\n      }\n      if(d[u2.p.ly][u2.p.lx][u2.p.ry][u2.p.rx] <= u2.c) continue;\n      d[u2.p.ly][u2.p.lx][u2.p.ry][u2.p.rx] = u2.c;\n      q.push(u2);\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        char c;\n        cin >> c;\n        if(c == 'S') v[i][j] = -3;\n        else if(c == 'T') v[i][j] = -2;\n        else if(c == 'X') v[i][j] = -1;\n        else v[i][j] = c - '0';\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][31][61][31];\nint dl[61][61];\nint dr[61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tfill(&dl[0][0], &dl[60][60] + 1, INF);\n\t\tfill(&dr[0][0], &dr[60][60] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tdl[j][i] = dr[j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > dis + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = dis + cost;\n\t\t\t\t//\t\tdr[xr2][yr2] = min(dr[xr2][yr2], memo[xl][yl][xr2][yr2]);\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > dis + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = dis + cost;\n\t\t\t//\t\t\tdl[xl2][yl2] = min(dl[xl2][yl2], memo[xl2][yl2][xr][yr]);\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nchar field[100][100];\nint memo[100][100][2];\n\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nint main(){\n  int w, h;\n  while(cin >> w >> h && (w || h)){\n    fill(&memo[0][0][0], &memo[99][99][1]+1, INF);\n    priority_queue<PPP, vector<PPP>, greater<PPP> > que;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> field[j][i];\n\tif(field[j][i] == 'S'){\n\t  field[j][i] = '0';\n\t  memo[j][i][0] = memo[j][i][1] = 0;\n\t  que.push(PPP(0, PP(0, P(j, i))));\n\t  que.push(PPP(0, PP(1, P(j, i))));\n\t}\n      }\n    }\n\n    bool ok = false;\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n      int dis = ppp.first;\n      int foot = ppp.second.first;\n      int next = foot ^ 1;\n      int x = ppp.second.second.first;\n      int y = ppp.second.second.second;\n      if(dis > memo[x][y][foot]) continue;\n      if(field[x][y] == 'T'){\n\tcout << memo[x][y][foot] << endl;\n\tok = true;\n\tbreak;\n      }\n      for(int i = 0; i < 9; i++){\n\tint nx, ny;\n\tif(foot == 0) nx = x + dx[i];\n\telse nx = x - dx[i];\n\tny = y + dy[i];\n\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] != 'X'){\n\t  int cost;\n\t  if(isdigit(field[nx][ny])) cost = field[nx][ny] - '0';\n\t  else cost = 0;\n\t  if(memo[nx][ny][next] > memo[x][y][foot] + cost){\n\t    //\t    cout << x << \" \" << y  << \" \" << nx << \" \" << ny << endl;\n\t    memo[nx][ny][next] = memo[x][y][foot] + cost;\n\t    que.push(PPP(memo[nx][ny][next], PP(next, P(nx, ny))));\n\t  }\n\t}\n      }\n    }\n    if(!ok) cout << -1 << endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n//経路もわかるダイクストラ法\n\n//pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<pair<int, int> > dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<pair<int, int > > result(v);          //first  コスト　　second　どこから来たか\n    for(int i = 0; i < v; i++){\n        result[i].first = INF;\n    }\n\n    //スタート地点を追加\n    result[s].first = 0;\n    //result[s].second.push_back(s);\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint].first < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint].first > nextcost){\n                \n                result[nextpoint].first = nextcost;\n                result[nextpoint].second = nowpoint;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    while(1){\n        int h, w; cin >> w >> h;\n        if(!h) break;\n        \n        map<pair<int, pair<int, int> >, int>  m;\n        vector<vector<char> > a(h, vector<char> (w));\n        int node = 1;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n                if(a[i][j] != 'S' && a[i][j] != 'T' && a[i][j] != 'X'){\n                    m[{0, {i, j}}] = node;\n                    m[{1, {i, j}}] = node + 1;                    \n                    node += 2;\n                } \n            }\n        }\n\n        /*for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(m.find({0, {i, j}}) != m.end()){\n                    cout << i << \" \" << j << \" \" << m[{0, {i, j}}] << \" \" << m[{1, {i, j}}] << \" \" << endl;\n                }\n            }\n        }*/\n\n        /*for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cout << a[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n        //cout << node << endl;\n        \n        vector<vector<pair<int, int> > > adjlist(node + 1);      //first := コスト　second := 行先\n        //cout << h << \" \" << w << endl;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                //int n;\n                //cout << i << \" \" << j << \" \" << a[i][j] << endl;\n                if(a[i][j] == 'S'){\n\n                    //cout << i << \" \" << j << endl;\n                    //右に行こう\n                    for(int k = 1; k <= 3; k++){\n                        for(int l = -(3 - k); l <= 3 - k; l++){\n                            int nj = j + k;\n                            int ni = i + l;\n                            if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                                int cost;\n                                if(a[ni][nj] == 'S' || a[ni][nj] == 'X') continue;\n                                else if(a[ni][nj] == 'T'){\n                                    //cout << \"ok\" << endl;\n                                    adjlist[0].push_back({0, node});\n                                    continue;\n                                }else cost = (int)(a[ni][nj] - '0');\n\n                                int n1 = m[{0, {ni, nj}}];\n                                \n\n                                adjlist[0].push_back({cost, n1});\n                                //adjlist[0].push_back({cost, n2});                                \n                            }\n                        }\n                    }   \n\n                    //左に行こう\n                    for(int k = 1; k <= 3; k++){\n                        for(int l = -(3 - k); l <= 3 - k; l++){\n                            int nj = j - k;\n                            int ni = i + l;\n                            if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                                int cost;\n                                if(a[ni][nj] == 'S' || a[ni][nj] == 'X') continue;\n                                else if(a[ni][nj] == 'T'){\n                                    adjlist[0].push_back({0, node});\n                                    continue;                                       \n                                }else cost = (int)(a[ni][nj] - '0');\n\n                                //int n1 = m[{0, {ni, nj}}];\n                                int n2 = m[{1, {ni, nj}}];\n\n                                //adjlist[0].push_back({cost, n1});\n                                adjlist[0].push_back({cost, n2});                                \n                            }\n                        }\n                    }   \n\n                }else if(a[i][j] != 'T' && a[i][j] != 'X'){\n                    \n                    int n = m[{1, {i, j}}];\n                    //右に行く\n                    for(int k = 1; k <= 3; k++){\n                        for(int l = -(3 - k); l <= 3 - k; l++){\n                            int nj = j + k;\n                            int ni = i + l;\n                            if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                                int cost;\n                                if(a[ni][nj] == 'S' || a[ni][nj] == 'X') continue;\n                                else if(a[ni][nj] == 'T'){\n                                    adjlist[n].push_back({0, node});\n                                    continue;\n                                }else cost = (int)(a[ni][nj] - '0');\n\n                                int nn = m[{0, {ni, nj}}];\n\n                                adjlist[n].push_back({cost, nn});\n                                                                \n                            }\n                        }\n                    }\n\n                    n = m[{0, {i, j}}];\n\n                    //左に行こう\n                    for(int k = 1; k <= 3; k++){\n                        for(int l = -(3 - k); l <= 3 - k; l++){\n                            int nj = j - k;\n                            int ni = i + l;\n                            if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                                int cost;\n                                if(a[ni][nj] == 'S' || a[ni][nj] == 'X') continue;\n                                else if(a[ni][nj] == 'T'){\n                                    adjlist[n].push_back({0, node});\n                                    continue;                                    \n                                }else cost = (int)(a[ni][nj] - '0');\n\n                                int nn = m[{1, {ni, nj}}];\n                                adjlist[n].push_back({cost, nn});                                \n                            }\n                        }\n                    }   \n                }\n\n                //cout << \"ok\" << \" \" << i << \" \" << j << \" \" << h << \" \" << w << endl;\n            }\n        }\n\n        /*for(int i = 0; i < adjlist.size(); i++){\n            cout << i << \": \";\n            for(int j = 0; j < adjlist[i].size(); j++){\n                cout << adjlist[i][j].second << \" \";\n            }\n            cout << endl;\n        }*/\n        //cout << node << endl;\n        vector<pair<int, int> > result(node + 1);\n        result = dijk(0, node + 1, adjlist);\n        /*for(int i = 0; i < node + 1; i++){\n            cout << i << \": \" << result[i].first << \"  \" << result[i].second << endl;\n        }*/\n\n        if(result[node].first == INF) cout << -1 << endl;\n        else cout << result[node].first << endl;\n\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct edge {int from, to, dist;};\nint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint y[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nconst int INF = 99999;\n\nint Dijkstra(const vector<edge>& es, int n, int s, int t){\n\tint* cal_graph = new int[n*n];\n\tint* d = new int[n];\n\tbool* used= new bool[n];\n\tint dist;\n\tfor(int j=0; j<n*n; j++){cal_graph[j]=INF;}\n\tfor(int j=0; j<n; j++){cal_graph[j*n+j]=0;}\n\tfor(int j=0; j<es.size(); j++){ cal_graph[ ((&es[j])->from)*n + (&es[j])->to ] = (&es[j])->dist;}\n\n\tfill(d,d+n, INF); fill(used,used+n,false); d[s]=0;\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0; u<n; u++){ if(!used[u] && (v==-1 || d[u]<d[v])){v=u;}}\n\t\tif(v==-1){ break;}\n\t\tused[v]=true;\n\t\tfor(int u=0; u<n; u++){ d[u] = min(d[u],d[v]+cal_graph[v*n+u]);}\n\t}\n\tdist = d[t];\n\n\tdelete[] cal_graph;\n\tdelete[] d;\n\n\treturn dist;\n}\n\nint main()\n{\n\tint w, h, ans;\n\tstring str;\n\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0){return 0;}\n\t\tint* graph = new int[w*2*h];\n\t\tvector<edge> es;\n\t\tedge e;\n\t\tvector<int> s;\n\t\tvector<int> t;\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> str;\n\t\t\t\tif(str == \"X\"){graph[i*w+j] = INF; graph[(i*w+j)+(h*w)] = INF;}\n\t\t\t\telse if(str == \"S\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; s.push_back(i*w+j); s.push_back((i*w+j)+(h*w));}\n\t\t\t\telse if(str == \"T\"){graph[i*w+j]=0; graph[(i*w+j)+(h*w)]=0; t.push_back(i*w+j); t.push_back((i*w+j)+(h*w));}\n\t\t\t\telse{ graph[i*w+j] = atoi(str.c_str()); graph[(i*w+j)+(h*w)] = graph[i*w+j];}\n\t\t\t}\n\t\t}\n\t\t/* \t二部グラフの作成 */\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(graph[i*w+j]!=INF){\n\t\t\t\t\tfor(int k=0; k<9; k++){\n\t\t\t\t\t\tif((j+x[k]<w)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j+x[k])]!=INF){ \n\t\t\t\t\t\t\t\t(e.from)=i*w+j; (e.to)=(i-y[k])*w+(j+x[k])+h*w; (e.dist)=graph[(i-y[k])*w+(j+x[k])+h*w]; es.push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((j-x[k]>=0)&&(i-y[k]>=0)&&(i-y[k]<h)){\n\t\t\t\t\t\t\tif(graph[(i-y[k])*w+(j-x[k])]!=INF){ \n\t\t\t\t\t\t\t\t(e.from)=i*w+j+h*w; (e.to)=(i-y[k])*w+(j-x[k]); (e.dist)=graph[(i-y[k])*w+(j-x[k])+h*w]; es.push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* SどうしとTどうしを接続 */\n\t\tfor(int i=0; i< s.size(); i++){\n\t\t\tfor(int j=0; j< s.size(); j++){\n\t\t\t\t(e.from)=s[i]; (e.to)=s[j]; (e.dist)=0; es.push_back(e);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\tfor(int j=0; j< t.size(); j++){\n\t\t\t\t(e.from)=t[i]; (e.to)=t[j]; (e.dist)=0; es.push_back(e);\n\t\t\t}\n\t\t}\n\t\tans = INF; ans = min(ans,Dijkstra(es, w*h*2, s[0], t[0]));\n\t\tif(ans!=INF){cout << ans << endl;}\n\t\telse{cout << -1 << endl;}\n\n\t\tdelete[] graph;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nvector<pi> F;\n\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      F.clear();\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      scanf(\" %c\",&S[i][j]);\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  F.pb(pi(i,j));\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t}\n\t      //printf(\"%c\", S[i][j]);\n\t    }\n\t  //printf(\"\\n\");\n\t}\n      queue<pi> Q;\n      queue<bool> R;\n      rep(i,F.size())\n\t{\n\t  Q.push(F[i]);\n\t  Q.push(F[i]);\n\t  R.push(0);\n\t  R.push(1);\n\t}\n\n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__);\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\n\nstruct P {\n\tint x, y, c, l;\n\tbool operator < (P a) const {\n\t\treturn c > a.c; } };\n\nint main() {\n\tfor (int w, h; w = in, h = in;) {\n\t\tenum {S = 10, T, M = INT_MAX / 2};\n\t\tV<V<int>> s(h + 6, V<int>(w + 6, M));\n\t\trange rw(3, w + 3), rh(3, h + 3);\n\t\tpriority_queue<P> q;\n\t\tV<V<V<int>>> v(h + 6, V<V<int>>(w + 6, V<int>(2, INT_MAX / 2)));\n\t\tfor (int i: rh)\n\t\t\tfor (int j: rw) {\n\t\t\t\tchar t = in;\n\t\t\t\ts[i][j] = isdigit(t) ? t - '0' : t == 'T' ? 0 : t == 'S' ? S : T;\n\t\t\t\tif (t == 'S')\n\t\t\t\t\tfor (int k : {1, -1}) {\n\t\t\t\t\t\tv[i][j][!(k + 1)] = 0;\n\t\t\t\t\t\tq.push({j, i, 0, k});\n\t\t\t\t\t}\n\t\t\t}\n\t\tint r = [&] {\n\t\t\twhile (!q.empty()) {\n\t\t\t\tP t {q.top()};\n\t\t\t\tq.pop();\n\t\t\t\tint vi {!(t.l + 1)};\n\t\t\t\tif (!s[t.y][t.x])\n\t\t\t\t\treturn t.c;\n\t\t\t\tfor (int dy: range(-2, 3))\n\t\t\t\t\tfor (int dx {1}; dx <= 3 - abs(dy); dx++) {\n\t\t\t\t\t\tint x {t.x + dx * t.l}, y {t.y + dy * t.l}, a = v[t.y][t.x][vi] + s[y][x];\n\t\t\t\t\t\tif (s[y][x] < 10 && v[y][x][!vi] > a) {\n\t\t\t\t\t\t\tv[y][x][!vi] = a;\n\t\t\t\t\t\t\tq.push({x, y, a, t.l * -1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn static_cast<int>(M);\n\t\t}();\n\t\toutl(r == M ? -1 : r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 1e+9\nusing namespace std;\n\n\nint dx[] = {-2,-1,-1,0,0,0,1,1,2},dy[] = {1,1,2,1,2,3,1,2,1};\nstruct edge{ int to,cost; };\ntypedef pair<int,int> P;\n\nint w,h;\nint field[60][30],d[60][30][2];\nvector<P> s;\n\nvoid dfs(int x,int y,int t,int foot){\n\tif(field[x][y] == -1){\n\t\td[x][y][(foot + 1) / 2] = t;\n\t\treturn;\n\t}\n\tif(t > d[x][y][(foot + 1) / 2]) return;\n\td[x][y][(foot + 1) / 2] = t;\n\tfor(int i = 0;i < 9;i++){\n\t\tint nx = x + dx[i],ny = y + foot * dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != INF && t + field[x][y] < d[nx][ny][(1 - foot) / 2]){\n\t\t\tdfs(nx,ny,t + field[x][y],-foot);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\ts.clear();\n\t\tfor(int i = 0;i < 60;i++){\n\t\t\tfor(int j = 0;j < 30;j++) {\n\t\t\t\td[i][j][0] = INF;\n\t\t\t\td[i][j][1] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c != 'X') {\n\t\t\t\t\tif(c == 'S'){\n\t\t\t\t\t\ts.push_back(P(i,j));\n\t\t\t\t\t\td[i][j][0] = 0;\n\t\t\t\t\t\td[i][j][1] = 0;\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 'T') {\n\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse field[i][j] = c - '0';\n\t\t\t\t}else field[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < (int)s.size();i++){\n\t\t\tfor(int j = -1;j <= 1;j += 2){\n\t\t\t\tdfs(s[i].first,s[i].second,0,j);\n\t\t\t\tfor(int k = 0;k < h;k++){\n\t\t\t\t\tfor(int l = 0;l < w;l++){\n\t\t\t\t\t\tif(field[k][l] == -1) mi = min(mi,min(d[k][l][0],d[k][l][1]));\n\t\t\t\t\t\tif(field[k][l] != 0){\n\t\t\t\t\t\t\td[k][l][0] = INF;\n\t\t\t\t\t\t\td[k][l][1] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mi != INF) cout << mi << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vt = vector<T>;\ntemplate<class T> using vvt = vector<vt<T>>;\ntemplate<class T> using ttt = tuple<T,T>;\nusing tii = tuple<int,int>;\nusing vi = vector<int>;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define mt make_tuple\n#define ALL(a) (a).begin(),(a).end()\n#define FST first\n#define SEC second\n#define DEB cerr<<\"!\"<<endl\n#define SHOW(a,b) cerr<<(a)<<\" \"<<(b)<<endl\n#define DIV int(1e9+7)\nconst ll LLINF = (LLONG_MAX/2);\nconst double eps = 1e-8;\n//const double PI = M_PI;\ninline ll pow(ll x,ll n,ll m){ll r=1;while(n>0){if((n&1)==1)r=r*x%m;x=x*x%m;n>>=1;}return r%m;}\ninline ll lcm(ll d1, ll d2){return d1 / __gcd(d1, d2) * d2;}\n#define chmax(a,b) a=max(a,b)\n\n/*Coding Space*/\nconst short INF = 1800*10;\nusing tiiii = tuple<int,int,int,int>;\nint main(){\n  int w,h;\n  while(cin >> w >> h , w){\n    priority_queue<tuple<short,bool,short,short,short,short>,vt<tuple<short,bool,short,short,short,short>>,greater<tuple<short,bool,short,short,short,short>> > q;\n    unordered_map<int,unordered_map<int,int>> c;\n    rep(i,80)rep(j,80)  c[i][j] = 0;\n    rep(i,h)rep(j,w)  {char cc; cin >> cc;\n      if(cc == 'X')  c[h-i-1][j] = 0;\n      else if(cc == 'T')  c[h-i-1][j] = -INF;\n      else if(cc == 'S'){\n        c[h-i-1][j] = INF;\n        q.push(tuple<short,bool,short,short,short,short>{0,1,-100,-100,h-i-1,j});\n        q.push(tuple<short,bool,short,short,short,short>{0,0,h-i-1,j,-100,-100});\n        q.push(tuple<short,bool,short,short,short,short>{0,0,-100,-100,h-i-1,j});\n        q.push(tuple<short,bool,short,short,short,short>{0,1,h-i-1,j,-100,-100});\n      }\n      else c[h-i-1][j] = cc - '0';\n    }\n    map<tuple<short,short,short,short>,short> min_table;\n    bool is_ans = 0;\n    while(!q.empty()){\n      bool lr;\n      short a,lw,lh,rw,rh; tie(a,lr,lh,lw,rh,rw) = q.top(); q.pop();\n      //cerr << a << \" \" << lh << \" \" << lw << \" \" << rh << \" \" << rw << \" \" << q.size() << endl;\n      //cerr << c[lh][lw] << \" \" << c[rh][rw] << endl;\n      if(c[lh][lw] == -INF){\n        cout << a << endl;\n        is_ans = 1;\n        break;\n      }\n      if(c[rh][rw] == -INF){\n        cout << a << endl;\n        is_ans = 1;\n        break;\n      }\n      //cerr << min_table.size() << endl;\n      if(lr){\n        for(short d = -2; d <= 2; d++)for(short dd = 1; dd <= 3; ++dd){\n          if(abs(d)+abs(dd) >= 4)continue;\n          short nh = rh + d,nw = rw - dd;\n          if(nh < 0 || nw < 0 || rh < 0 || rw < 0)  continue;\n          if(c[nh][nw] == 0)  continue;\n          short new_c = a + c[nh][nw];\n          if(min_table.count(tiiii{nh,nw,rh,rw})){\n            if(min_table[tiiii{nh,nw,rh,rw}] > new_c){\n              min_table[tiiii{nh,nw,rh,rw}] = new_c;\n              if(c[nh][nw] == -INF)            q.push(tuple<short,bool,short,short,short,short>{a,0,nh,nw,rh,rw});\n              else q.push(tuple<short,bool,short,short,short,short>{new_c,0,nh,nw,rh,rw});            }else{\n;\n            }\n          }else{\n            min_table[tiiii{nh,nw,rh,rw}] = new_c;\n            if(c[nh][nw] == -INF)            q.push(tuple<short,bool,short,short,short,short>{a,0,nh,nw,rh,rw});\n            else q.push(tuple<short,bool,short,short,short,short>{new_c,0,nh,nw,rh,rw});\n          }\n        }\n      }else{\n        for(short d = -2; d <= 2; d++)for(short dd = 1; dd <= 3; ++dd){\n          if(abs(d)+abs(dd) >= 4)continue;\n          short nh = lh + d,nw = lw + dd;\n          if(nh < 0 || nw < 0 || lh < 0 || lw < 0)  continue;\n          if(c[nh][nw] == 0)  continue;\n          short new_c = a + c[nh][nw];\n          if(min_table.count(tiiii{lh,lw,nh,nw})){\n            if(min_table[tiiii{lh,lw,nh,nw}] > new_c){\n              min_table[tiiii{lh,lw,nh,nw}] = new_c;\n              if(c[nh][nw] == -INF)q.push(tuple<short,bool,short,short,short,short>{a,1,lh,lw,nh,nw});\n              else q.push(tuple<short,bool,short,short,short,short>{new_c,1,lh,lw,nh,nw});\n            }else{\n;\n            }\n          }else{\n            min_table[tiiii{lh,lw,nh,nw}] = new_c;\n            if(c[nh][nw] == -INF)q.push(tuple<short,bool,short,short,short,short>{a,1,lh,lw,nh,nw});\n            else q.push(tuple<short,bool,short,short,short,short>{new_c,1,lh,lw,nh,nw});\n          }\n        }\n      }\n    }\n    if(!is_ans){cout << -1 << endl;}\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\n\nll h,w;\nvector<vector<ll>> s;\nvector<P> sp;\nset<P> gp;\nll gy,gx;\nP table[2][9] = { {P(1,2),P(1,1),P(1,0),P(1,-1),P(1,-2),P(2,1),P(2,0),P(2,-1),P(3,0)},\n                    {P(-1,2),P(-1,1),P(-1,0),P(-1,-1),P(-1,-2),P(-2,1),P(-2,0),P(-2,-1),P(-3,0)} };\n\nvector<vector<ll>> d[2];\n\nbool in(ll y,ll x){\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nvoid dijkstra(){\n    typedef pair<P,P> PP;\n    priority_queue<PP, vector<PP>, greater<PP>> que;\n    rep(i,h)rep(j,w){\n        d[0][i][j] = INF;\n        d[1][i][j] = INF;\n    }\n\n    rep(i,sp.size()){\n        ll sy = sp[i].first;\n        ll sx = sp[i].second;\n        d[0][sy][sx] = 0;\n        d[1][sy][sx] = 0;\n        que.push(PP(P(0,0),P(sy,sx)));\n        que.push(PP(P(0,1),P(sy,sx)));\n    }\n\n    while (!que.empty()){\n        PP p = que.top();\n        que.pop();\n        ll cy = p.second.first;\n        ll cx = p.second.second;\n        ll cost = p.first.first;\n        ll turn = p.first.second;\n        if(gp.find(P(cy,cx)) != gp.end())continue;\n        if(cost > d[turn][cy][cx])continue;\n        // cout << \"!\" << cy << \" \" << cx << \" \" << cost << endl;\n        rep(i,9){\n            ll ny = cy + table[turn][i].second;\n            ll nx = cx + table[turn][i].first;\n            if(!in(ny,nx))continue;\n            ll ncost = cost + s[ny][nx];\n            if (d[!turn][ny][nx] > ncost){\n                d[!turn][ny][nx] = ncost;\n                que.push(PP(P(d[!turn][ny][nx],!turn),P(ny,nx)));\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h&&h){\n        s.clear();\n        sp.clear();\n        gp.clear();\n        d[0].clear();\n        d[1].clear();\n        s.resize(h);\n        d[0].resize(h);\n        d[1].resize(h);\n        rep(i,h){\n            s[i].resize(w);\n            d[0][i].resize(w);\n            d[1][i].resize(w);\n            rep(j,w){\n                char c;\n                cin >> c;\n                if(c >= '0' && c <= '9')s[i][j] = c - '0';\n                else{\n                    s[i][j] = 0;\n                    if(c == 'S')sp.push_back(P(i,j));\n                    else if(c == 'T')gp.insert(P(i,j));\n                    else s[i][j] = INF;\n                } \n            }\n        }\n        dijkstra();\n        ll ans = INF;\n        rep(i,h){\n            rep(j,w){\n                if(gp.find(P(i,j)) != gp.end()){\n                    // cout << i <<\" \" << j << endl;\n                    ans = min(ans,d[0][i][j]);\n                    ans = min(ans,d[1][i][j]);\n                }\n            }\n        }\n        if(ans == INF)cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif(((int)input - '0') < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = i;\n\t\t\t\tf.ly = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tfor(int j=i+1; j<w; j++) {\n\t\t\t\t\tif(field[h-1][j] == 11) {\n\t\t\t\t\t\tf.rx = j;\n\t\t\t\t\t\tf.ry = h-1;\n\t\t\t\t\t\tpq.push(f);\n\t\t\t\t\t\tstring chk = to_string(f.rx) + to_string(f.ry) + to_string(f.p);\n\t\t\t\t\t\tmemo[chk] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\tcout << field[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}\n\t\tint ans = 1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n//\t\t\tcout << pq.size() << \" size\" << endl;\n\t\t\tif(f.lx < 0 || w-2 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 1 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n//\t\t\t\t\tcout << ans << ' ' << f.cnt << \" ans\" << endl;\n//\t\t\t\t\tcout << f.lx << ' ' << f.ly << ' ' << f.rx << ' ' << f.ry << ' ' << f.cnt << ' ' << f.p << \" ans\"  << endl;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcout << f.lx << ' ' << f.ly << ' ' << f.rx << ' ' << f.ry << ' ' << f.cnt << ' ' << f.p << endl;\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, step;\n    int feet;\n\n    bool operator >(const P& p) const {\n        return step > p.step;\n    }\n};\n\nconst int dx[] = {1,1,1,1,1,2,2,2,3}; const int dy[] = {2,1,0,-1,-2,1,0,-1,0};\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1e8\n\nconst char START = 'S';\nconst char GOAL = 'T';\nconst char WALL = 'X';\n\nchar field[MAX_H][MAX_W];\nint G[MAX_H][MAX_W][2];\n\nint w, h;\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_H*MAX_W, WALL);\n        fill_n((int *)G, MAX_H*MAX_W*2, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> field[y][x];\n                if ('0' <= field[y][x] && field[y][x] <= '9') {\n                    field[y][x] -= '0';\n                }\n                if (field[y][x] == START) {\n                    que.push({x, y, 0, 1});\n                    que.push({x, y, 0, -1});\n                }\n            }\n        }\n\n        int step = -1;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            //LOG(\"%d %d [%d] left=%d\\n\", p.x, p.y,p.step, p.feet == 1);\n\n            if (field[p.y][p.x] == GOAL) {\n                step = p.step;\n                break;\n            }\n\n            for (int i = 0; i < 9; i++) {\n                int sx = p.x + dx[i] * p.feet, sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    switch (field[sy][sx]) {\n                    case WALL:\n                    case START:\n                        break;\n                    case GOAL:\n                        que.push({sx, sy, p.step, -p.feet});\n                        break;\n                    default:\n                        int f = p.feet > 0 ? 0 : 1;\n                        int s = p.step + field[sy][sx];\n                        if (G[sx][sy][f] > s) {\n                            G[sx][sy][f] = s;\n                            que.push({sx, sy, s, -p.feet});\n                        }\n                    }\n                }\n            }\n        }\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint xv[]={1,1,1,1,1,2,2,2,3},yv[]={2,1,0,-1,-2,1,0,-1,0};\n\nvoid solve(int w,int h){\n    char in;\n    bool l;\n    int r,c;\n    queue<pair<bool,pair<int,int>>> q;\n    pair<int,int> n;\n    vector<vector<int>> mp=vector<vector<int>>(h+4,vector<int>(w+6,-1));\n    vector<vector<vector<int>>> ma(h+4,vector<vector<int>>(w+6,vector<int>(2,INT_MAX/2)));\n    set<pair<int,int>> sset,tset;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin>>in;\n            if(in=='X')mp[i+1][j+2]=-1;\n            else if(in=='S'){\n                mp[i+1][j+2]=0;\n                sset.insert(make_pair(i+1,j+2));\n            }\n            else if(in=='T'){\n                mp[i+1][j+2]=0;\n                tset.insert(make_pair(i+1,j+2));\n            }\n            else{\n                mp[i+1][j+2]=in-'0';\n            }\n        }\n    }\n    for(pair<int,int> x:sset){\n        q.push(make_pair(true,make_pair(x.first,x.second)));\n        q.push(make_pair(false,make_pair(x.first,x.second)));\n        ma[x.first][x.second][0]=0;\n        ma[x.first][x.second][1]=0;\n    }\n    while(!q.empty()){\n        l=q.front().first;n=q.front().second;q.pop();\n        for(int i=0;i<9;i++){\n            r=n.first+yv[i];\n            c=n.second+(l?xv[i]:-1*xv[i]);\n            if(mp[r][c]!=-1&&ma[n.first][n.second][!l]+mp[r][c]<ma[r][c][l]){\n                ma[r][c][l]=ma[n.first][n.second][!l]+mp[r][c];\n                q.push(make_pair(!l,make_pair(r,c)));\n            }\n        }\n    }\n    int mini=INT_MAX/2;\n    for(pair<int,int> x:tset){\n        mini=min(mini,ma[x.first][x.second][0]);\n        mini=min(mini,ma[x.first][x.second][1]);\n    }\n    cout<<(mini!=INT_MAX/2?mini:-1)<<endl;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        solve(w,h);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const float EPS = 1e-8;\n\nint txr[] = {1,1,1,1,1,2,2,2,3};\nint tyr[] = {-2,-1,0,1,2,-1,0,1,0};\n\n\nint txl[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint tyl[] = {-2,-1,0,1,2,-1,0,1,0};\n\nchar stage[60][30];\nint cost[1800][1800];\n\nclass Data{\npublic:\n\tint cost;\n\tint rhs;\n\tint lhs;\n\tbool turn;\n\tData(int _cost,int _lhs,int _rhs,bool _turn){\n\t\tcost = _cost;\n\t\tlhs = _lhs;\n\t\trhs = _rhs;\n\t\tturn = _turn;\n\t}\n\n\tbool operator>(const Data& d) const{\n\t\treturn cost > d.cost;\n\t}\n};\n\nint w,h;\nvoid dfs(int lhs,int rhs,int turn,int c){\n\n\tint srx = rhs % w;\n\tint sry = rhs / w;\n\n\tint slx = lhs % w;\n\tint sly = lhs / w;\n\n\t//turn:0 moving right leg\n\tif(turn==0){\n\t\tfor(int i=0;i<9;i++){\n\t\t\tint dx = txr[i] + slx;\n\t\t\tint dy = tyr[i] + sly;\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(slx>=dx) continue;\n\t\t\tif(abs(dx - slx) + abs(dy - sly) > 3) continue;\n\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\tcost[lhs][dy*w+dx] = min(cost[lhs][dy*w+dx],c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(cost[lhs][dy*w+dx] <= c + stage[dy][dx]-'0') continue;\n\t\t\tcost[lhs][dy*w+dx] = c + stage[dy][dx]-'0';\n\t\t\tdfs(lhs,dy*w+dx,1,c + stage[dy][dx]-'0');\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<9;i++){\n\t\t\tint dx = txl[i] + srx;\n\t\t\tint dy = tyl[i] + sry;\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(dx>=srx) continue;\n\t\t\tif(abs(dx - srx) + abs(dy - sry) > 3) continue;\n\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\tcost[dy*w+dx][rhs] = min(cost[dy*w+dx][rhs],c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(cost[dy*w+dx][rhs] <= c + stage[dy][dx]-'0') continue;\n\t\t\tcost[dy*w+dx][rhs] = c + stage[dy][dx]-'0';\n\t\t\tdfs(dy*w+dx,rhs,0,c + stage[dy][dx]-'0');\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tmemset(cost,0x3f,sizeof(cost));\n\t\tvector<P> S;\n\t\tvector<P> T;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%s\",&stage[y][x]);\n\t\t\t\tif(stage[y][x]=='S') S.push_back(P(x,y));\n\t\t\t\tif(stage[y][x]=='T') T.push_back(P(x,y));\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\n\t\tfor(int i=0;i<S.size();i++){\n\t\t\tint x = S[i].first;\n\t\t\tint y = S[i].second;\n\t\t\tque.push(Data(0,y*w+x,y*w+x,false));\n\t\t\tque.push(Data(0,y*w+x,y*w+x,true));\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\tData d = que.top();\n\n\t\t\tint srx = d.rhs % w;\n\t\t\tint sry = d.rhs / w;\n\n\t\t\tint slx = d.lhs % w;\n\t\t\tint sly = d.lhs / w;\n\t\t\tque.pop();\n\n\t\t\tif(d.turn){\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tint dx = txl[i] + srx;\n\t\t\t\t\tint dy = tyl[i] + sry;\n\n\t\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\t\tif(dx>=srx) continue;\n\t\t\t\t\tif(abs(dx - srx) + abs(dy - sry) > 3) continue;\n\t\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\t\tcost[dy*w+dx][d.rhs] = min(cost[dy*w+dx][d.rhs],d.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cost[dy*w+dx][d.rhs] <= d.cost + stage[dy][dx]-'0') continue;\n\t\t\t\t\tcost[dy*w+dx][d.rhs] = d.cost + stage[dy][dx]-'0';\n\n\t\t\t\t\tque.push(Data(d.cost + stage[dy][dx]-'0',dy*w+dx,d.rhs,false));\n\t\t\t\t\t//dfs(dy*w+dx,d.rhs,0,d.cost + stage[dy][dx]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tint dx = txr[i] + slx;\n\t\t\t\t\tint dy = tyr[i] + sly;\n\n\t\t\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\t\t\tif(slx>=dx) continue;\n\t\t\t\t\tif(abs(dx - slx) + abs(dy - sly) > 3) continue;\n\t\t\t\t\tif(stage[dy][dx] == 'X') continue;\n\t\t\t\t\tif(stage[dy][dx] == 'T'){\n\t\t\t\t\t\tcost[d.lhs][dy*w+dx] = min(cost[d.lhs][dy*w+dx],d.cost);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(cost[d.lhs][dy*w+dx] <= d.cost + stage[dy][dx]-'0') continue;\n\t\t\t\t\tcost[d.lhs][dy*w+dx] = d.cost + stage[dy][dx]-'0';\n\t\t\t\t\tque.push(Data(d.cost + stage[dy][dx]-'0',d.lhs,dy*w+dx,true));\n\t\t\t\t\t//dfs(d.lhs,dy*w+dx,1,d.cost + stage[dy][dx]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint res = numeric_limits<int>::max();\n\t\tfor(int lhs=0;lhs < 1800; lhs++){\n\t\t\tfor(int rhs=0; rhs < 1800; rhs++){\n\t\t\t\tint srx = rhs % w;\n\t\t\t\tint sry = rhs / w;\n\n\t\t\t\tint slx = lhs % w;\n\t\t\t\tint sly = lhs / w;\n\n\t\t\t\tif(srx < 0 || srx >= w || sry < 0 || sry >= h) continue;\n\t\t\t\tif(slx < 0 || slx >= w || sly < 0 || sly >= h) continue;\n\n\t\t\t\tif(stage[sry][srx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t\tif(stage[sly][slx] == 'T') res = min(cost[lhs][rhs],res);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res >= 0x3f3f3f3f ? -1 : res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    int dp[2][60][30];\n    char mp[30][60];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>mp[i][j];\n\tdp[0][i][j]=dp[1][i][j]=1e9;\n\tif(mp[i][j]=='S')dp[0][i][j]=dp[0][i][j]=0;\n      }\n\n    int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0},ans=1e9;\n    for(int i=0;i<=2*h*w;i++)\n      for(int y=0;y<h;y++)\n\tfor(int x=0;x<w;x++)\n\t  for(int l=0;l<2;l++){\n\t    int f=1,c=0;\n\t    if(l)f=-1;\n\t    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n\t    for(int p=0;p<9;p++){\n\t      int nx=x+f*dx[p],ny=y+f*dy[p];\n\t      if(nx<0||w<=nx||ny<0||h<=ny||mp[ny][nx]=='X')continue;\n\t      dp[!l][ny][nx]=min(dp[!l][ny][nx],dp[l][y][x]+c);\n\t    }\n\t    if(mp[y][x]=='T')ans=min(ans,dp[l][y][x]);\n\t  }\n    if(ans==1e9)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,1,2,-1,0,1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(scanf(\"%d%d\",&w,&h), w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      if(grid[y][x] == 'T'){\n\tq.push(p);\n\tcout << t << endl;\n\tbreak;\n      }\n\n      for(int k=0;k<9;k++){\n\tint ty = y+dy[k], tx = !f?(x+dx[k]):(x-dx[k]),tt = -1;\n\tif(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n\tif(d[1-f][ty][tx]<INF)continue;\n\n\tif('1'<=grid[ty][tx] && grid[ty][tx]<='9')tt = grid[ty][tx]-'0';\n\tif(grid[ty][tx] == 'T')tt = 0;\n\n\tif(tt>=0 && d[1-f][ty][tx] > t + tt){\n\t  d[1-f][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,1-f),P(ty,tx)));\n\t}\n      }\n    }\n    if(q.empty())cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<p,p> P;\nchar mp[30][60];\nint w,h;\nint cal(){\n  bool used[2][60][30]={};\n  int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0};\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<w;i++)\n    if(mp[h-1][i]=='S')q.push(P(p(0,0),p(i,h-1))),q.push(P(p(0,1),p(i,h-1)));\n  while(!q.empty()){\n    int s=q.top().first.first,l=q.top().first.second;\n    int x=q.top().second.first,y=q.top().second.second;\n    q.pop();\n    if(mp[y][x]=='T')return s;\n    used[l][y][x]=1;\n    int f=1,c=0;\n    if(l)f=-1;\n    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n    for(int d=0;d<9;d++){\n      int nx=x+f*dx[d],ny=y+f*dy[d];\n      if(nx<0||w<=nx||ny<0||h<=ny||mp[ny][nx]=='X'||used[!l][ny][nx])continue;\n      q.push(P(p(s+c,!l),p(nx,ny)));\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    cout<<cal()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define Y first\n#define X second\n#define RANGE(x, y, mX, mY) (0 <= (x) && 0 <= (y) && (x) < (mX) && (y) < (mY))\n#define MP make_pair\n\nconst int INF = 0x3f3f3f3f;\n\nint N, M;\nvector<string> ss;\n\nset<char> not_zero;\n\nVC as;\n\nmap<char, int> ks;\n\n// alphabet?????????\nVC find_alphas() {\n    set<char> as_set;\n    for (auto s : ss) {\n        for (auto c : s) {\n            as_set.insert(c);\n        }\n    }\n\n    VC res;\n    for (auto c : as_set) {\n        res.push_back(c);\n    }\n\n    return res;\n}\n\nvoid find_not_zero() {\n    not_zero.clear();\n\n    for (auto &s : ss) {\n        if (s.size() == 1) continue;\n        not_zero.insert(s[0]);\n    }   \n}\n\n// ?????°?¨????\nvoid calc_ks() {\n    ks.clear();\n\n    for (auto c : as) {\n        ks[c] = 0;\n    }\n\n    for (int i = 0; i < N; i++) {\n        int v = 1;\n        string &s = ss[i];\n\n        for (int j = (int)s.size() - 1; j >= 0; --j) {\n            ks[s[j]] += v * (i == N - 1 ? -1 : 1);\n            v *= 10;\n        }\n    }\n}\n\nbool calc_siki(VI &idxes) {\n    int sum = 0;\n\n    for (int i = 0; i < M; i++) {\n        char c = as[i];\n        int n = idxes[i];\n        sum += ks[c] * n;\n    }\n\n    return sum == 0;\n}\n\nint solve() {\n    as = find_alphas();\n    M = as.size();\n    find_not_zero();\n    calc_ks();\n\n    int cnt = 0;\n\n    for (int p = (1 << M) - 1; p < 1 << 10; p++) {\n        if (__builtin_popcount(p) != M) continue;\n\n        // ?????????????????°???\n        VI idxes;\n        for (int i = 0; i < 10; i++) {\n            if (1 << i & p) {\n                idxes.push_back(i);\n            }\n        }\n\n        do {\n            // ??????0?????????\n            auto it = find(idxes.begin(), idxes.end(), 0);\n            if (it != idxes.end()) {\n                char zero_c = as[it - idxes.begin()];\n                if (not_zero.count(zero_c)) continue;\n            }\n\n            cnt += calc_siki(idxes);\n        } while (next_permutation(idxes.begin(), idxes.end()));\n    }\n\n    return cnt;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        ss.clear();\n        ss.resize(N);\n\n        for (auto &s : ss) cin >> s;\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 61\n#define MAX_W 31\n#define INF 1e9\n#define Fi first\n#define Se second\ntypedef pair<int,int> pii;\n\nstruct State{\n  int d,x,y;\n  bool f;\n  State(){}\n  State(int d,int x,int y,bool f) :\n    d(d),x(x),y(y),f(f) {}\n  bool operator > (const State &s)const{\n    return d > s.d;\n  }\n};\n\nint W,H;\nint ps,pt;\npii S[MAX_W],T[MAX_W];\nchar field[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W][2];\n\nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n\nbool inField(int x,int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  fill(dist[0][0],dist[0][0]+MAX_H*MAX_W*2,INF);\n  for(int i = 0 ; i < ps ; i++){\n    Q.push(State(0,S[i].Fi,S[i].Se,0)); \n    Q.push(State(0,S[i].Fi,S[i].Se,1));\n    dist[S[i].Se][S[i].Fi][0] = 0;\n    dist[S[i].Se][S[i].Fi][1] = 0;\n  }\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int x = s.x, y = s.y;\n\n    if(dist[y][x][s.f] < s.d) continue;\n    for(int i = 0 ; i < pt ; i++){\n      if(x == T[i].Fi && y == T[i].Se){\n        return s.d;\n      }\n    }\n    if(s.f){\n      for(int i = 0 ; i < 9 ; i++){\n        int nx = x - dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == 'X') continue;\n        int t = field[ny][nx] - '0';\n        if(s.d + t < dist[ny][nx][0]){\n          dist[ny][nx][0] = s.d + t;\n          Q.push(State(dist[ny][nx][0],nx,ny,0));\n        }\n      }\n    }else{\n      for(int i = 0 ; i < 9 ; i++){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(!inField(nx,ny)) continue;\n        if(field[ny][nx] == 'X') continue;\n        int t = field[ny][nx] - '0';\n        if(s.d + t < dist[ny][nx][1]){\n          dist[ny][nx][1] = s.d + t;\n          Q.push(State(dist[ny][nx][1],nx,ny,1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  dijkstra();\n  while(cin >> W >> H, W){\n    ps = pt = 0;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'S'){\n          S[ps++] = pii(j,i);\n          field[i][j] = '0';\n        }else if(field[i][j] == 'T'){\n          T[pt++] = pii(j,i);\n          field[i][j] = '0';      \n        }\n      }\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\nstruct Node {\n        int step, s, x, y;\n};\nstruct NodeComparator {\n        bool operator()(const Node &a, const Node &b) const {\n                return a.step > b.step;\n        }\n};\n\nint memo[2][64][34];\nint field[64][34];\nint dx[] = {  0,  0,  1, 0, 1, 2, 0, 1, 0 };\nint dy[] = { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\nint dcount = 9;\n\nint main(){\n        while(true){\n                int w, h;\n                cin >> w >> h;\n                if(w == 0 || h == 0){ break; }\n                memset(field, -1, sizeof(field));\n                memset(memo, -1, sizeof(memo));\n                priority_queue<Node, vector<Node>, NodeComparator> q;\n                for(int i = 0; i < h; ++i){\n                        for(int j = 0; j < w; ++j){\n                                string panel;\n                                cin >> panel;\n                                if(panel == \"X\"){\n                                }else if(panel == \"S\"){\n                                        Node n = { 0, 0, j + 2, i + 2 };\n                                        q.push(n);\n                                        n.s = 1;\n                                        q.push(n);\n                                        memo[0][i + 2][j + 2] = memo[1][i + 2][j + 2] = 0;\n                                }else if(panel == \"T\"){\n                                        field[i + 2][j + 2] = -2;\n                                }else{\n                                        field[i + 2][j + 2] = atoi(panel.c_str());\n                                }\n                        }\n                }\n                int answer = -1;\n                while(!q.empty() && answer < 0){\n                        Node n = q.top(); q.pop();\n                        if(n.step <= memo[n.s][n.y][n.x]){\n                                int bx = n.x, by = n.y, sign;\n                                if(n.s){\n                                        --bx; sign = -1;\n                                }else{\n                                        ++bx; sign = 1;\n                                }\n                                for(int i = 0; i < dcount; ++i){\n                                        Node next = {\n                                                n.step, 1 - n.s,\n                                                bx + dx[i] * sign, by + dy[i]\n                                        };\n                                        if(field[next.y][next.x] == -1){\n                                                continue;\n                                        }else if(field[next.y][next.x] == -2){\n                                                answer = next.step;\n                                                break;\n                                        }\n                                        next.step += field[next.y][next.x];\n                                        if(\n                                                memo[next.s][next.y][next.x] == -1 ||\n                                                memo[next.s][next.y][next.x] > next.step\n                                        ){\n                                                memo[next.s][next.y][next.x] = next.step;\n                                                q.push(next);\n                                        }\n                                }\n                        }\n                }\n                cout << answer << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>;\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//??§?¨???§???\n//index()??¨??????????????????\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int w, h; cin >> w >> h &&h;) {\n\t\tvector<vector<char>> c(h, vector<char>(w));\n\t\trep(i, 0, h)rep(j, 0, w)\n\t\t\tcin >> c[i][j];\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < h && j >= 0 && j < w; };\n\t\tauto valid = [&](int li, int lj, int ri, int rj) {return abs(li - ri) + abs(lj - rj) <= 3 && lj < rj; };\n\t\tauto idx = [&](int li, int lj, int ri, int rj, int right) {\n\t\t\tint ret = li;\n\t\t\tret *= w;\n\t\t\tret += lj;\n\t\t\tret *= h;\n\t\t\tret += ri;\n\t\t\tret *= w;\n\t\t\tret += rj;\n\t\t\tret += (w*h*w*h)*right;\n\t\t\treturn ret;\n\t\t};\n\n\t\tvector<int> v;\n\t\trep(li, 0, h)rep(lj, 0, w)rep(ri, 0, h)rep(rj, 0, w) {\n\t\t\tif (valid(li, lj, ri, rj)) {\n\t\t\t\tv.push_back(idx(li, lj, ri, rj, 0));\n\t\t\t\tv.push_back(idx(li, lj, ri, rj, 1));\n\t\t\t}\n\t\t}\n\t\tvector<int> zip = compress(v);\n\n\t\tauto index = [&](int li, int lj, int ri, int rj, int r) {\n\t\t\treturn lower_bound(zip.begin(), zip.end(), idx(li, lj, ri, rj, r)) - zip.begin();\n\t\t};\n\t\tGraph g(zip.size() + 2);\n\t\t// next right 1\n\t\tint s = zip.size(), t = s + 1;\n\n\t\trep(li, 0, h)rep(lj, 0, w)rep(ri, 0, h)rep(rj, lj + 1, w) {\n\t\t\tif (!valid(li, lj, ri, rj))continue;\n\t\t\t//dump(li, lj, ri, rj);\n\t\t\tif (c[li][lj] == 'X' || c[ri][rj] == 'X')continue;\n\t\t\tif (c[li][lj] == 'S') {\n\t\t\t\taddArc(g, s, index(li, lj, ri, rj, 0), c[ri][rj] == 'S' ? 0 : c[ri][rj] - '0');\n\t\t\t}\n\t\t\tif (c[ri][rj] == 'S') {\n\t\t\t\taddArc(g, s, index(li, lj, ri, rj, 1), c[li][lj] == 'S' ? 0 : c[li][lj] - '0');\n\t\t\t}\n\t\t\tif (c[li][lj] == 'T') {\n\t\t\t\taddArc(g, index(li, lj, ri, rj, 1), t, 0);\n\t\t\t}\n\t\t\tif (c[ri][rj] == 'T') {\n\t\t\t\taddArc(g, index(li, lj, ri, rj, 0), t, 0);\n\t\t\t}\n\t\t\trep(r, 0, 2) {\n\t\t\t\tint u = index(li, lj, ri, rj, r);\n\t\t\t\trep(di, -10, 10)rep(dj, -10, 10) {\n\t\t\t\t\tint nli = li, nlj = lj, nri = ri, nrj = rj;\n\t\t\t\t\tint cost;\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tnri += di;\n\t\t\t\t\t\tnrj += dj;\n\t\t\t\t\t\tif (!inrange(nri, nrj))continue;\n\t\t\t\t\t\tif (c[nri][nrj] == 'X')continue;\n\t\t\t\t\t\tcost = c[nri][nrj] == 'T' ? 0 : c[nri][nrj] - '0';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnli += di;\n\t\t\t\t\t\tnlj += dj;\n\t\t\t\t\t\tif (!inrange(nli, nlj))continue;\n\t\t\t\t\t\tif (c[nli][nlj] == 'X')continue;\n\t\t\t\t\t\tcost = c[nli][nlj] == 'T' ? 0 : c[nli][nlj] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (!valid(nli, nlj, nri, nrj))continue;\n\t\t\t\t\t//dump(nli, nlj, nri, nrj);\n\t\t\t\t\tint v = index(nli, nlj, nri, nrj, !r);\n\t\t\t\t\taddArc(g, u, v, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tArray dist;\n\t\tdijkstra(g, s, dist);\n\t\tchmin(ans, dist[t]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define GOAL 10\n#define START 0\n#define WALL -1\n\nclass State{\npublic:\n  int x,y;\n  int cost;\n  bool left;\n\n  State(){}\n  State(int _x,int _y,int _cost,bool _left){\n    x = _x;\n    y = _y;\n    cost = _cost;\n    left = _left;\n  }\n\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint w,h;\nint t[62][62];\n\nint dx[2][9] = {\n  {1,1,1,1,1,2,2,2,3},\n  {-1,-1,-1,-1,-1,-2,-2,-2,-3}\n};\n\nint dy[2][9] = {\n  {-2,-1,0,1,2,-1,0,1,0},\n  {-2,-1,0,1,2,-1,0,1,0},\n};\n\n\nint main(){\n  while(cin>>w>>h,w||h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        char ch;\n        cin>>ch;\n\n        if(ch == 'T'){\n          t[i][j] = GOAL;\n        }\n        else if(ch == 'S'){\n          t[i][j] = START;\n        }\n        else if(ch == 'X'){\n          t[i][j] = WALL;\n        }\n        else{\n          t[i][j] = ch - '0';\n        }\n      }\n    }\n\n    priority_queue<State> open;\n    bool closed[62][62][2];\n    memset(closed,0,sizeof(closed));\n\n    for(int i=0;i<w;i++){\n      if(t[h-1][i] == START){\n        open.push(State(i,h-1,0,true));\n        open.push(State(i,h-1,0,false));\n      }\n    }\n\n    bool goal = false;\n\n    while(!open.empty()){\n      State st = open.top(); open.pop();\n      if(closed[st.x][st.y][st.left]) continue;\n      closed[st.x][st.y][st.left] = true;\n\n      if(t[st.y][st.x] == GOAL){\n        cout<<st.cost-GOAL<<endl;\n        goal = true;\n        break;\n      }\n\n      for(int i=0;i<9;i++){\n        int nx = st.x + dx[st.left][i];\n        int ny = st.y + dy[st.left][i];\n\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && t[ny][nx] != WALL){\n          open.push(State(nx,ny,st.cost+t[ny][nx],!st.left));\n        }\n      }\n    }\n    if(!goal) cout<<\"-1\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[71][41];\nint used[2][61][41][61][41]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c;\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false;\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c;\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true;\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true;\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; \n\t  if(board[s.r.sc][s.r.fs] < 0) return true;\n\t  if(board[s.l.sc][s.l.fs] < 0) return true;\n\t  return false;\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true;\n\t  if(g.find(s.r) != g.end()) return true;\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n//\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n//\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost=0;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tsort(s.begin(),s.end());\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  for(int j=i+1; j<s.size(); j++){\n\t\t\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\t\t\t  state st = state(s[i], s[j], (f+1)%2, 0);\n\t\t\t\t\t\t\t  if( valid(st) ) continue;\n\t\t\t\t\t\t\t  int tmp = dijk(st);\n\t\t\t\t\t\t\t  if(tmp != -1)\n\t\t\t\t\t\t\t\t\tans = min(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 1e9\nusing namespace std;\n\nint w, h;\nchar cliff[64][32];\nint dx[] = { 1, 1, 1, 1, 1,\n                2, 2, 2,\n                   3 };\nint dy[] = { 2, 1, 0, -1, -2,\n                1, 0, -1,\n                   0 };\n\nstruct S {\n  int x, y, cost;\n  bool foot;\n  S(int x, int y, int cost, bool foot) : x(x), y(y), cost(cost), foot(foot) {}\n  bool operator>(const S &s) const {\n    return cost > s.cost;\n  }\n};\n\nint solve() {\n  int ans = INF;\n  int d[64][32][2]; // ????????????????´?\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      for (int f = 0; f < 2; f++) {\n        d[y][x][f] = INF;\n      }\n    }\n  } // ????????????Infinity??§?????????\n\n  priority_queue<S, vector<S>, greater<S> > que; // ?????????????????????????????\\???\n  for (int x = 0; x < w; x++) {\n    if (cliff[h - 1][x] == 'S') {\n      que.push(S(x, h - 1, 0, false));\n      que.push(S(x, h - 1, 0, true));\n      d[h - 1][x][0] = 0;\n      d[h - 1][x][1] = 0;\n    }\n  } // ??????????????????????????????????????°??????????¶????Queue?????\\??????\n\n  while (!que.empty()) { // Queue????????????????????§\n    S st = que.top(); // Queue????????????????????????\n    que.pop();\n    int x = st.x, y = st.y;\n    bool f = st.foot;\n    f = !f; // ?¶??????????\n    for (int i = 0; i < 9; i++) { // ?¬?????¶???????????????¨?????§??????9??????\n      int nx = x + (f ? 1 : -1) * dx[i], ny = y + dy[i]; // ?¬??????????????£??????§?¨?\n      if (x >= 0 && x < w && y >= 0 && y < h && cliff[y][x] != 'X') { // ?´???????????????§???X??§?????????\n        if (cliff[ny][nx] == 'T') {\n          ans = min(ans, st.cost);\n          break;\n        } // ????????§????????°????°????????????´??°????????????\n        int tmp = st.cost + cliff[ny][nx] - '0'; // ?¬??????????????????????\n        if (d[ny][nx][(f ? 1 : 0)] > tmp) {\n          d[ny][nx][(f ? 1 : 0)] = tmp;\n          que.push(S(nx, ny, d[ny][nx][(f ? 1 : 0)], f));\n        } // ??????????????????????????\\??????????????????????????????????????´??°???Queue?????§?¨???¨?????????????¶?????????±?????\\??????\n      }\n    }\n  }\n  return (ans == INF ? -1 : ans);\n}\n\nint main() {\n  while (cin >> w >> h, (w || h)) {\n    for (int y = 0; y < h; y++) {\n      for (int x = 0; x < w; x++) {\n        cin >> cliff[y][x];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint x, y;\n\tint t;\n\tint c;\n\tP(int x, int y, int t, int c) :x(x), y(y), t(t), c(c) {}\n\tbool operator<(const P &other)const { return t < other.t; }\n\tbool operator>(const P &other)const { return t > other.t; }\n};\n\n\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint w, h; cin >> w >> h;\n\t\tif ( !w )break;\n\t\tint a[100][100];\n\t\tbool goal[100][100] = {};\n\t\tint flag[100][100][2];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, 100)FOR(j, 100)FOR(k, 2)flag[i][j][k] = INF;\n\t\tvector<pii> s;\n\t\tpriority_queue< P, vector<P>, greater<P> >que;\n\t\tFORI(i, 10, h + 10)\n\t\t{\n\t\t\tFORI(j, 10, w + 10)\n\t\t\t{\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tswitch ( c )\n\t\t\t\t{\n\t\t\t\tcase 'X':\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\tque.emplace(i, j, 0, 0);\n\t\t\t\t\tque.emplace(i, j, 0, 1);\n\t\t\t\t\tflag[i][j][0] = flag[i][j][1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\tgoal[i][j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ta[i][j] = c - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tconst int dy[9] = { 1,1,2,1,2,3,1,2,1 };\n\t\tconst int dx[9] = { 2,1,1,0,0,0,-1,-1,-2 };\n\t\tbool ok = false;\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif ( goal[now.x][now.y] )\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tcout << now.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tFOR(i, 9)\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tif ( now.c % 2 )next.y += dy[i];\n\t\t\t\telse next.y -= dy[i];\n\t\t\t\tnext.x += dx[i];\n\t\t\t\tnext.c = (next.c + 1) % 2;\n\t\t\t\tnext.t += a[next.x][next.y];\n\t\t\t\tif ( a[next.x][next.y] != -1 && flag[next.x][next.y][next.c] > next.t )\n\t\t\t\t{\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tflag[next.x][next.y][next.c] = next.t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !ok )cout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000001\n\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\ntypedef pair<int,pair<int,pint> > joutai;\n\nbool operator<(joutai a,joutai b){\n\treturn a.x<b.x;\n}\n\nint dy[2][9]={1,1,2,1,2,3,1,2,1,-1,-1,-2,-1,-2,-3,-1,-2,-1};\nint dx[2][9]={2,1,1,0,0,0,-1,-1,-2,2,1,1,0,0,0,-1,-1,-2};\n\nint main(){\n\tint gake[70][70],memo[70][70][2];\n\tint i,j,k;\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tif(w==0 && h==0) break;\n\t\tchar in;\n\t\tpriority_queue<joutai> pq;\n\t\tjoutai j1;\n\t\tfor(i=2;i<h+2;i++){\n\t\t\tfor(j=2;j<w+2;j++){\n\t\t\t\tscanf(\"%1s\",&in);\n\t\t\t\tif(in=='T'){\n\t\t\t\t\tgake[i][j]=0;\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t}else if(in=='S'){\n\t\t\t\t\tgake[i][j]=INF;\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t\tj1.x=0;\n\t\t\t\t\tj1.y.x=0;\n\t\t\t\t\tj1.y.y=pint(i,j);\n\t\t\t\t\tpq.push(j1);\n\t\t\t\t\tj1.y.x=1;\n\t\t\t\t\tj1.y.y=pint(i,j);\n\t\t\t\t\tpq.push(j1);\n\t\t\t\t}else if(in=='X'){\n\t\t\t\t\tgake[i][j]=-1;\n\t\t\t\t\tmemo[i][j][0]=-1;\n\t\t\t\t\tmemo[i][j][1]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tgake[i][j]=(in-'0');\n\t\t\t\t\tmemo[i][j][0]=INF;\n\t\t\t\t\tmemo[i][j][1]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tj1=pq.top(); pq.pop();\n\t\t\tmemo[j1.y.y.x][j1.y.y.y][j1.y.x]= -j1.x;\n\t//\t\tcout << j1.y.y.x-1 <<\"\t\" << j1.y.y.y-1 << \"\t\" << j1.y.x <<\"\t\t\" << -j1.x << endl;\n\t\t\tif(gake[j1.y.y.x][j1.y.y.y]==0){\n\t\t\t\tcout << -j1.x << endl;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t\tfor(j=0;j<9;j++){\n\t\t\t\tjoutai nxt;\n\t\t\t\tnxt=j1;\n\t\t\t\tnxt.y.y.x= j1.y.y.x + dx[j1.y.x][j];\n\t\t\t\tnxt.y.y.y= j1.y.y.y + dy[j1.y.x][j];\n\t\t\t\tnxt.y.x= (j1.y.x+1)%2;\n\t\t\t\tif(memo[nxt.y.y.x][nxt.y.y.y][nxt.y.x]==INF){\n\t\t\t\t\tnxt.x=j1.x-gake[nxt.y.y.x][nxt.y.y.y];\n\t\t\t\t\tpq.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"-1\" << endl;\n\tok:;\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int a[36][64];\n    memset(a,-1,sizeof(a));\n    for(i=2;i<h+2;i++){\n      for(j=3;j<w+3;j++){\n\tchar s;\n\tcin>>s;\n\tif(0){\n\t}else if(s=='S'){\n\t  a[j][i]=0;\n\t}else if(s=='T'){\n\t  a[j][i]=0;\n\t}else if(s=='X'){\n\t  a[j][i]=-1;\n\t}else{\n\t  a[j][i]=s-'0';\n\t}\n      }\n    }\n    int b[36][66][2];\n    memset(b,-1,sizeof(b));\n    priority_queue<pair<pair<int,int>,pair<int,int> >,vector<pair<pair<int,int>,pair<int,int> > >,greater<pair<pair<int,int>,pair<int,int> > > > c;\n    for(i=3;i<w+3;i++){\n      if(a[i][h+1]==0){\n\tc.push(make_pair(make_pair(0,0),make_pair(i,h+1)));\n\tc.push(make_pair(make_pair(0,1),make_pair(i,h+1)));\n      }\n    }\n    while(c.empty()==0){\n      int v,w,x,y;\n      v=c.top().first.first;\n      w=c.top().first.second;\n      x=c.top().second.first;\n      y=c.top().second.second;\n      if(y==2&&a[x][y]==0)\n\tbreak;\n      c.pop();\n      if(b[x][y][w]==-1||b[x][y][w]>v){\n\tb[x][y][w]=v;\n\tif(w){\n\t  int p,q;\n\t  p=x-1;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-2;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-3;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-1;\n\t  q=y+1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-2;\n\t  q=y+1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-1;\n\t  q=y-1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-2;\n\t  q=y-1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-1;\n\t  q=y+2;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t  p=x-1;\n\t  q=y-2;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],0),make_pair(p,q)));\n\t}else{\n\t  int p,q;\n\t  p=x+1;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+2;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+3;\n\t  q=y;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+1;\n\t  q=y+1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+2;\n\t  q=y+1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+1;\n\t  q=y-1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+2;\n\t  q=y-1;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+1;\n\t  q=y+2;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t  p=x+1;\n\t  q=y-2;\n\t  if(a[p][q]!=-1)\n\t    c.push(make_pair(make_pair(v+a[p][q],1),make_pair(p,q)));\n\t}\n      }\n    }\n    cout<<(c.empty()?-1:c.top().first.first)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\nstruct xy{\n  int x,y,f;\n  bool operator<(const xy& a)const{\n    return true;\n  }\n};\ntypedef pair<int, xy > P;\n\nint w,h;\nbool in(xy a){\n  if(a.x<0||a.x>=w||a.y<0||a.y>=h) return false;\n  return true;\n}\n\nint main(){\n  int inf = 1<<20;\n  cin >> w >> h;\n  while(w!=0){\n    char st[30][60];\n    char c;\n    int i,j,k;\n    int d[31][61][2];\n    fill(d[0][0],d[30][60],inf);\n    priority_queue<P,vector<P>,greater<P> > q;\n\n    xy v,b;\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> st[j][i];\n\tif(st[j][i]=='S'){\n\t  v.x=j;v.y=i;v.f=0;\n\t  q.push(mp(0,v));\n\t  v.f=1;\n\t  q.push(mp(0,v));\n\t  d[j][i][0]=0;\n\t  d[j][i][1]=0;\n\t}\n      }\n    }\n    int o=inf;\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      v = p.second;\n      if(d[v.x][v.y][v.f] < p.first) continue;\n      d[v.x][v.y][v.f]=p.first;\n      if(v.f==0){\n\tfor(i=1;i<=3;i++){\n\t  for(j=-3+i;j<=3-i;j++){\n\t    b.x=v.x+i;b.y=v.y+j;b.f=1;\n\t    if(in(b)){\n\t      if(st[b.x][b.y]=='T'){\n\t\to=min(o,p.first);\n\t      }else{\n\t\tint g;\n\t\tif(st[b.x][b.y]=='S') g=0;\n\t\telse if(st[b.x][b.y]=='X') g=inf;\n\t\telse g=st[b.x][b.y]-'0';\n\t\tif(d[b.x][b.y][b.f] > d[v.x][v.y][v.f]+g){\n\t\t  d[b.x][b.y][b.f] = d[v.x][v.y][v.f]+g;\n\t\t  q.push(mp(d[b.x][b.y][b.f],b));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }else{\n\tfor(i=1;i<=3;i++){\n\t  for(j=-3+i;j<=3-i;j++){\n\t    b.x=v.x-i;b.y=v.y+j;b.f=0;\n\t    if(in(b)){\n\t      if(st[b.x][b.y]=='T'){\n\t\to=min(o,p.first);\n\t      }else{\n\t\tint g;\n\t\tif(st[b.x][b.y]=='S') g=0;\n\t\telse if(st[b.x][b.y]=='X') g=inf;\n\t\telse g=st[b.x][b.y]-'0';\n\t\tif(d[b.x][b.y][b.f] > d[v.x][v.y][v.f]+g){\n\t\t  d[b.x][b.y][b.f] = d[v.x][v.y][v.f]+g;\n\t\t  q.push(mp(d[b.x][b.y][b.f],b));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(o==inf) cout << -1 << endl;\n    else cout << o << endl;\n    cin >> w >> h;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nconst int INF = 1e9;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    fill( (T*)array, (T*)(array+N), val );\n}\n\nusing Cost = int;\nstruct Edge{\n    Cost cost;\n    int y,x,foot;\n    bool operator>(const Edge &right)const{\n        return cost > right.cost;\n    }\n};\n\nint X,Y;\nchar s[60][30];\nCost dp[60][30][2];\n\nint main(void){\n    while(cin>>X>>Y, X|Y){\n        Fill(dp, (Cost)INF);\n        vector<int> T,S;\n        rep(y,Y)rep(x,X){\n            cin>>s[y][x];\n            if(s[y][x] == 'T'){\n                T.push_back(x);\n                s[y][x] = '0';\n            }\n            if(s[y][x] == 'S') {\n                S.push_back(x);\n                s[y][x] = '0';\n            }\n        }\n        priority_queue<Edge,vector<Edge>,greater<Edge>> qu;\n        for(int x : S)rep(foot,2){\n            dp[Y-1][x][foot] = 0;\n            qu.push({0,Y-1,x,foot});\n        }\n\n        while(qu.size()){\n            Edge cur = qu.top(); qu.pop();\n            int y = cur.y;\n            int x = cur.x;\n            int foot = cur.foot;\n            if(dp[y][x][foot] < cur.cost) continue;\n            for(int dx=-3; dx<=3; dx++){\n                if(foot==0 && dx<=0) continue;\n                if(foot==1 && dx>=0) continue;\n                for(int dy=-2; dy<=2; dy++){\n                    if(abs(dx)+abs(dy)>3) continue;\n                    int ny = y + dy;\n                    int nx = x + dx;\n                    if(ny<0 || nx<0 || ny>=Y || nx>=X) continue;\n                    if(s[ny][nx] == 'X') continue;\n                    int c = s[y][x]-'0';\n                    if( dp[ny][nx][!foot] > cur.cost + c){\n                        dp[ny][nx][!foot] = cur.cost + c;\n                        qu.push({dp[ny][nx][!foot], ny,nx,!foot});\n                    }\n                }\n            }\n        }\n\n        int res = INF;        \n        for(int x : T)rep(foot,2){\n            res = min(res,dp[0][x][foot]);\n        }\n        cout<<(res == INF ? -1 : res)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<int, piii> piiii;\n\nint dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\nint dy[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint main(int argc, char *argv[]){\n  priority_queue<piiii, vector<piiii>, greater<piiii> > que;\n  int w, h;\n  while(cin >> w >> h, h){\n    int foot[2][h][w];\n    char g[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> g[i][j];\n        if(g[i][j] == 'S'){\n          que.push(mp(0, mp(0, mp(j, i))));\n          que.push(mp(0, mp(1, mp(j, i))));\n        }\n      }\n    }\n    int ans = 1e9;\n    for (int j = 0; j < h; j++) {\n      for (int k = 0; k < w; k++) {\n        if(g[j][k] != 'S'){\n          foot[0][j][k] = 1e9;\n          foot[1][j][k] = 1e9;\n        }else{\n          foot[0][j][k] = 0;\n          foot[1][j][k] = 0;\n        }\n      }\n    }\n    \n    while(!que.empty()){\n      piiii v = que.top();que.pop();\n      int c = v.first;\n      int f = v.second.first;\n      int x = v.second.second.first;\n      int y = v.second.second.second;\n      for (int i = 0; i < 9; i++) {\n        int nx, ny, nc;\n        if(f == 1){\n          nx = x - dx[i], ny = y + dy[i];\n        }else{\n          nx = x + dx[i], ny = y + dy[i];\n        }\n        if(g[ny][nx] == 'S' || g[ny][nx] == 'T')nc = c;\n        else nc = c + g[ny][nx] - '0';\n        // std::cout << \"ny:\" << ny << std::endl;\n        // std::cout << \"nx:\"<<nx << std::endl;\n        // std::cout << (int)g[ny][nx]  - '0'<< std::endl;\n        if(0 <= nx && nx < w &&\n           0 <= ny && ny < h &&\n           g[ny][nx] != 'X' &&\n           foot[f][ny][nx] > nc){\n          foot[f][ny][nx] = nc;\n          que.push(mp(nc, mp((f+1)&1, mp(nx, ny))));\n        }\n      }\n    }\n    for (int j = 0; j < h; j++) {\n      for (int k = 0; k < w; k++) {\n        if(g[j][k] == 'T'){\n        ans = min(ans, foot[0][j][k]);\n        ans = min(ans, foot[1][j][k]);\n        }\n      }\n    }\n    if(ans != 1e9)std::cout << ans << std::endl;\n    else std::cout << -1 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,1,2,-1,0,1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(scanf(\"%d%d\",&w,&h), w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      if(grid[y][x] == 'T'){\n\tq.push(p);\n\tcout << t << endl;\n\tbreak;\n      }\n\n      for(int k=0;k<9;k++){\n\tint ty = y+dy[k], tx = !f?(x+dx[k]):(x-dx[k]);\n\tif(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n\tif(d[1-f][ty][tx]<INF)continue;\n\n\tint tt;\n\tif('1'<=grid[ty][tx] && grid[ty][tx]<='9')tt = grid[ty][tx]-'0';\n\telse if(grid[ty][tx] == 'T')tt = 0;\n\telse tt = -1;\n\n\tif(tt>=0){\n\t  if(d[1-f][ty][tx] > t + tt){\n\t    d[1-f][ty][tx] = t+tt;\n\t    q.push(P2(P(t+tt,1-f),P(ty,tx)));\n\t  }\n\t}\n      }\n    }\n    if(q.empty())cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define int long long\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct to {\n    int type, x, y;\n    to(int type, int y, int x):type(type),y(y),x(x){}\n    bool operator<(const to& t) const {\n        return type < t.type;\n    }\n};\nstruct edge {\n    to t; int cost;\n    edge(to t, int cost):t(t),cost(cost){}\n};\n\nvector<edge> G[2][61][31];\nint d[2][61][31];\n\nchar fld[62][32];\n\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint W, H;\n\nbool inside(int h, int w)\n{\n    if (0 <= h && h < H && 0 <= w && w < W) return true;\n    return false;\n}\n\nvoid build_graph()\n{\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (fld[i][j] == 'T' or fld[i][j] == 'X') continue;\n\n            for (int k = 0; k < 9; ++k) {\n                int y = i + dy[k], ax = j + dx[k], bx = j + dx[k] * -1;\n\n                if (inside(y, ax) && fld[y][ax] != 'X') {\n                    int cost = (isdigit(fld[y][ax]) ? fld[y][ax] - '0' : 0);\n                    G[0][i][j].push_back(edge(to(1, y, ax), cost));\n                }\n                \n                if (inside(y, bx) && fld[y][bx] != 'X') {\n                    int cost = (isdigit(fld[y][bx]) ? fld[y][bx] - '0' : 0);\n                    G[1][i][j].push_back(edge(to(0, y, bx), cost));\n                }\n            }\n        }\n    }\n}\n\nvoid dijkstra(to s)\n{\n    typedef pair<int, to> P;\n\n    for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n        d[i][j][k] = inf;\n    }\n\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(0, to(s.type, s.y, s.x)));\n\n    d[s.type][s.y][s.x] = 0;\n\n    while (q.size()) {\n        P p = q.top();\n        q.pop();\n\n        to t = p.scd;\n        \n        if (p.fst > d[t.type][t.y][t.x]) continue;\n\n        for (int i = 0; i < G[t.type][t.y][t.x].size(); ++i) {\n            edge e = G[t.type][t.y][t.x][i];\n\n            if (d[e.t.type][e.t.y][e.t.x] > d[t.type][t.y][t.x] + e.cost) {\n                d[e.t.type][e.t.y][e.t.x] = d[t.type][t.y][t.x] + e.cost;\n                q.push(P(d[e.t.type][e.t.y][e.t.x], e.t));\n            }\n        }\n    }\n}\nsigned main()\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n            G[i][j][k].clear();\n        }\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                scanf(\"\\n%c\", &fld[i][j]);\n            }\n        }\n\n        build_graph();\n\n        int mi = inf;\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[H - 1][i] == 'S') {\n                for (int j = 0; j < 2; ++j) {\n                    dijkstra(to(j, H - 1, i));\n                    for (int k = 0; k < W; ++k) {\n                        if (fld[0][k] == 'T') {\n                            chmin(mi, d[j ^ 1][0][k]);\n                        }\n                    }\n                }\n            }\n        }\n\n        printf(\"%d\\n\", mi == inf ? -1 : mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[9]={-2,-1,-1,0,0,0,1,1,2},dy[9]={1,1,2,1,2,3,1,2,1};\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<P,P2> PP;\n\nint d[2][61][31][61][31];\nvoid Main() {\n  int n,m;\n  while(cin >> m >> n && n) {\n    int a[n][m];\n    rep(i,n)rep(j,m) {\n      char c;\n      R c;\n      if(isdigit(c)) a[i][j]=c-'0';\n      else if(c=='X') a[i][j]=-1;\n      else a[i][j]=0;\n    }\n    rep(i,2)rep(i2,n)rep(i3,m)rep(i4,n)rep(i5,m)d[i][i2][i3][i4][i5]=MAX;\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    rep(i,m) {\n      if(!a[n-1][i]) {\n        rep(k,2) {\n          que.push(PP(P(0,k),P2(P(n-1,i),P(n-1,i))));\n          d[k][n-1][i][n-1][i]=0;\n        }\n      }\n    }\n    int ans=MAX;\n    while(!que.empty()) {\n      PP p=que.top();que.pop();\n      int nx1=p.S.F.F,ny1=p.S.F.S,nx2=p.S.S.F,ny2=p.S.S.S,c=p.F.F,t=p.F.S;\n      if(!nx1&&!a[0][ny1]) ans=min(ans,c);\n      if(!nx2&&!a[0][ny2]) ans=min(ans,c);\n      if(d[t][nx1][ny1][nx2][ny2]<c) continue;\n      int s=t^1;\n      rep(i,9) {\n        if(!t) {\n          int x=nx1+dx[i],y=ny1+dy[i];\n          if(!check(n,m,x,y)||a[x][y]==-1||d[s][nx1][ny1][x][y]<=c+a[x][y]) continue;\n          d[s][nx1][ny1][x][y]=c+a[x][y];\n          que.push(PP(P(c+a[x][y],s),P2(P(nx1,ny1),P(x,y))));\n        } else {\n          int x=nx2+dx[i],y=ny2-dy[i];\n          if(!check(n,m,x,y)||a[x][y]==-1||d[s][x][y][nx2][ny2]<=c+a[x][y]) continue;\n          d[s][x][y][nx2][ny2]=c+a[x][y];\n          que.push(PP(P(c+a[x][y],s),P2(P(x,y),P(nx2,ny2))));\n        }\n      }\n    }\n    if(ans==MAX) ans=-1;\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[61][31];\n//int used[2][61][31][61][31]; // f, ly, lx, ry, rx\nint used[2][61][31]; // f, y, x\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n//\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c; // ???????????§???????????????????¨???¶\n\t  if(s.f == 0)\n\t\t\tused[0][s.l.sc][s.l.fs] = s.c;\n\t  if(s.f == 1)\n\t\t\tused[1][s.r.sc][s.r.fs] = s.c;\n}\nbool is_used(state s){\n/*\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false; // ??????????¨???????\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c; // ?????£????????¨?????????\n*/\n\t  if(s.f == 0){\n\t\t\tif( used[0][s.l.sc][s.l.fs] == -1) return false;\n\t\t\treturn  used[0][s.l.sc][s.l.fs] <= s.c;\n\t  }\n\t  else{\n\t\t\tif( used[1][s.r.sc][s.r.fs] == -1) return false;\n\t\t\treturn  used[1][s.r.sc][s.r.fs] <= s.c;\n\t  }\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true; // ?£????\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true; // ?£????\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; //????£???????\n\t  if(board[s.r.sc][s.r.fs] < 0) return true; //??????????£?\n\t  if(board[s.l.sc][s.l.fs] < 0) return true; //??????????£?\n\t  return false; // ??§??????\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true; // ????¶??????´??????\n\t  if(g.find(s.r) != g.end()) return true; // ????¶??????´??????\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost = 0 ;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  if(is_used(ns)) continue;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  foot dummy = foot(INF,INF);\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tif( !valid( state(s[i],foot(s[i].fs+dx[i], s[i].sc-dy[i]),0,0) ) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs+dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st0 = state(s[i], dummy, 0, 0);\n\t\t\t\t  int tmp0 = dijk(st0);\n\t\t\t\t  if(tmp0 != -1)\n\t\t\t\t\t\tans = min(ans, tmp0);\n\n\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tif( !valid( state(foot(s[i].fs-dx[i], s[i].sc-dy[i]), s[i], 1,0) ) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs-dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st1 = state(dummy, s[i], 1, 0);\n\t\t\t\t  int tmp1 = dijk(st1);\n\t\t\t\t  if(tmp1 != -1)\n\t\t\t\t\t\tans = min(ans, tmp1);\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 1e+9\nusing namespace std;\n\n\nint dx[] = {-2,-1,-1,0,0,0,1,1,2},dy[] = {1,1,2,1,2,3,1,2,1};\nstruct edge{ int to,cost; };\ntypedef pair<int,int> P;\n\nint w,h;\nint field[60][30],d[60][30][2];\nvector<P> s;\n\nvoid dfs(int x,int y,int t,int foot){\n\tif(field[x][y] == -1){\n\t\td[x][y][(foot + 1) / 2] = t;\n\t\treturn;\n\t}\n\tif(t > d[x][y][(foot + 1) / 2]) return;\n\td[x][y][(foot + 1) / 2] = t;\n\tfor(int i = 0;i < 9;i++){\n\t\tint nx = x + dx[i],ny = y + foot * dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[x][y] != INF && t + field[x][y] < d[nx][ny][(1 - foot) / 2]){\n\t\t\tdfs(nx,ny,t + field[x][y],-foot);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\ts.clear();\n\t\tfor(int i = 0;i < 60;i++){\n\t\t\tfor(int j = 0;j < 30;j++) {\n\t\t\t\td[i][j][0] = INF;\n\t\t\t\td[i][j][1] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c != 'X') {\n\t\t\t\t\tif(c == 'S'){\n\t\t\t\t\t\ts.push_back(P(i,j));\n\t\t\t\t\t\td[i][j][0] = 0;\n\t\t\t\t\t\td[i][j][1] = 0;\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 'T') {\n\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse field[i][j] = c - '0';\n\t\t\t\t}else field[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < (int)s.size();i++){\n\t\t\tfor(int j = -1;j <= 1;j += 2){\n\t\t\t\tdfs(s[i].first,s[i].second,0,j);\n\t\t\t\tfor(int k = 0;k < h;k++){\n\t\t\t\t\tfor(int l = 0;l < w;l++){\n\t\t\t\t\t\tif(field[k][l] == -1) mi = min(mi,min(d[k][l][0],d[k][l][1]));\n\t\t\t\t\t\tif(field[k][l] != 0){\n\t\t\t\t\t\t\td[k][l][0] = INF;\n\t\t\t\t\t\t\td[k][l][1] = INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mi != INF) cout << mi << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nstruct State{\n    int y, x, lr, c;\n    State(int y, int x, int lr, int c): y(y), x(x), lr(lr), c(c){}\n    bool operator<(const State& right ) const {\n        return c > right.c;\n    }\n};\n\nint main(){\n    while(1){\n        int W, H;\n        cin >> W >> H;\n        if(W == 0) break;\n\n        char field[60][30];\n        int minDist[60][30][2];\n        memset(minDist, -1, sizeof(minDist));\n        priority_queue<State> que;\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j] == 'S'){\n                    minDist[i][j][0] = 0;\n                    minDist[i][j][1] = 0;\n                    que.emplace(i, j, 0, 0);\n                    que.emplace(i, j, 1, 0);\n                }\n            }\n        }\n\n        int ans = -1;\n        while(que.size()){\n            State s = que.top(); que.pop();\n            if(minDist[s.y][s.x][s.lr] < s.c) continue;\n            if(field[s.y][s.x] == 'T'){\n                ans = s.c;\n                break;\n            }\n            int mul = s.lr == 0 ? 1 : -1;\n            for(int dx=mul;abs(dx)<=3;dx+=mul){\n                for(int dy=-3+abs(dx);abs(dy)+abs(dx)<=3;dy++){\n                    int ny = s.y + dy, nx = s.x + dx, nlr = (s.lr+1)%2, nc = s.c;;\n                    if(ny<0 || H<=ny || nx<0 || W<=nx) continue;\n                    if(field[ny][nx] == 'X') continue;\n                    if('1' <= field[ny][nx] && field[ny][nx] <= '9'){\n                        nc += field[ny][nx] - '0';\n                    }\n                    if(minDist[ny][nx][nlr] == -1 || minDist[ny][nx][nlr] > nc){\n                        minDist[ny][nx][nlr] = nc;\n                        que.emplace(ny, nx, nlr, nc);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, step;\n    int feet;\n\n    bool operator >(const P& p) const {\n        return step > p.step;\n    }\n};\n\nconst int dx[] = {1,1,1,1,1,2,2,2,3}; const int dy[] = {2,1,0,-1,-2,1,0,-1,0};\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1e8\n\nconst char START = 'S';\nconst char GOAL = 'T';\nconst char WALL = 'X';\n\nchar field[MAX_H][MAX_W];\nint G[MAX_H][MAX_W][2];\n\nint w, h;\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_H*MAX_W, WALL);\n        fill_n((int *)G, MAX_H*MAX_W*2, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> field[y][x];\n                if ('0' <= field[y][x] && field[y][x] <= '9') {\n                    field[y][x] -= '0';\n                }\n                if (field[y][x] == START) {\n                    que.push({x, y, 0, 1});\n                    que.push({x, y, 0, -1});\n                }\n            }\n        }\n\n        int step = -1;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            if (field[p.y][p.x] == GOAL) {\n                step = p.step;\n                break;\n            }\n\n            REP(i, 9) {\n                int sx = p.x + dx[i] * p.feet, sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    switch (field[sy][sx]) {\n                    case WALL:\n                        break;\n                    case GOAL:\n                        que.push({sx, sy, p.step, -p.feet});\n                        break;\n                    default:\n                        int f = p.feet > 0 ? 0 : 1;\n                        int s;\n                        if (field[sy][sx] == START) {\n                            s = p.step;\n                        } else {\n                            s = p.step + field[sy][sx];\n                        }\n                        if (G[sx][sy][f] > s) {\n                            G[sx][sy][f] = s;\n                            que.push({sx, sy, s, -p.feet});\n                        }\n                    }\n                }\n            }\n        }\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_DIR 9\n#define MAX_N 100\n#define INF 1 << 30\n\nstring C;\nint X[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint G[MAX_N][MAX_N];\nint DIST[MAX_N][MAX_N][MAX_DIR];//Left,DY-DX\nint dx[MAX_DIR] = { 1,1,1,1,1,2,2,2,3 };\nint dy[MAX_DIR] = { -2,-1,0,1,2,-1,0,1,0 };\nint dz[MAX_DIR] = { 4,3,2,1,0,7,6,5,8 };\nint H, W;\nchar U[11] = \"0123456789\";\n\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>> > Q;\n\nvoid MEMSET() {\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tX[i][j] = INF;\n\t\t\tS[i][j] = 0;\n\t\t\tG[i][j] = 0;\n\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\tDIST[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DIJKSTRA() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j + dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[i][j][k] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i - dy[k];\n\t\t\t\t\tint X1 = j - dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[Y1][X1][dz[k]] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, dz[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\ttuple<int, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tint LY = a2, LX = a3;\n\t\tint RY = a2 + dy[a4], RX = a3 + dx[a4];\n\n\t\t//hidari.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = RY - dy[k];\n\t\t\tint cx = RX - dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[cy][cx][dz[k]] > dis + pos) {\n\t\t\t\t\tDIST[cy][cx][dz[k]] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[cy][cx][dz[k]], cy, cx, dz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//migi.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = LY + dy[k];\n\t\t\tint cx = LX + dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[LY][LX][k] > dis + pos) {\n\t\t\t\t\tDIST[LY][LX][k] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[LY][LX][k], LY, LX, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (G[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint ey = i + dy[k];\n\t\t\t\t\tint ex = j + dx[k];\n\t\t\t\t\tif (ey < 1 || ey > H) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ex < 1 || ex > W) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (G[ey][ex] == 1) {\n\t\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res >= INF) {\n\t\treturn -1;\n\t}\n\treturn res;\n}\n\nint power(int a, int b) {\n\tint R = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tR *= b;\n\t}\n\treturn R;\n}\n\nvoid CIN() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> C;\n\t\t\tif (C == \"X\") {\n\t\t\t\tX[i][j] = INF;\n\t\t\t}\n\t\t\telse if (C == \"S\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tS[i][j] = 1;\n\t\t\t}\n\t\t\telse if (C == \"T\") {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint D = C.size();\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tfor (int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif (C[k] == U[l]) {\n\t\t\t\t\t\t\tcnt1 += power(10, D - k - 1)*l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX[i][j] = cnt1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tS[H + 1][i] = 1;\n\t\tX[H + 1][i] = 0;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tMEMSET();\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tCIN();\n\t\tcout << DIJKSTRA() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nconst int inf = 1<<29;\nint mp[31][61];\nint dp[2][31][61];\n\nint movx[2][9] = { {1,1,1,1,1,2,2,2,3},\n                   {-3,-2,-2,-2,-1,-1,-1,-1,-1} };\nint movy[2][9] = { {-2, -1, 0, 1, 2, -1, 0, 1, 0},\n                   {0, -1, 0, -1, -2, -1, 0, 1, 2} };\n\nstruct State{\n    int leg;\n    int x,y;\n    State(int leg,int y,int x) : leg(leg), x(x), y(y) {;}\n};\n\nint main() {\n    int w,h;\n    string s;\n    while(cin>>w>>h, w|h) {\n        memset(mp, 0, sizeof(mp));\n        REP(i,2) REP(j,31) REP(k,61) dp[i][j][k] = inf;\n        REP(i,h) {\n            REP(j,w) {\n                cin>>s;\n                if(s[0] >= '0' && s[0] <= '9') mp[i][j] = s[0] - '0';\n                else if(s[0] == 'S') mp[i][j] = 0; // START\n                else if(s[0] == 'T') mp[i][j] = -1; // GOAL\n                else mp[i][j] = -2; // X\n            }\n        }\n\n        queue<State> Q;\n        REP(i,h) REP(j,w) if(mp[i][j] == 0) {\n            Q.push(State(0,i,j));\n            Q.push(State(1,i,j));\n            dp[0][i][j] = dp[1][i][j] = 0;\n        }\n\n        while(!Q.empty()) {\n            int l = Q.front().leg,y = Q.front().y,x = Q.front().x;\n            Q.pop();\n            // cout<<((l==0) ? \"left\" : \"right\")<<\" \"<<y<<\" \"<<x<<endl;\n            int nw = dp[l][y][x];\n            for(int i=0; i<9; ++i) {\n                int dx = x + movx[l][i],dy = y + movy[l][i];\n                if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                if(mp[dy][dx] == -2) continue;\n                if(dp[(l+1)%2][dy][dx] > nw + max(mp[dy][dx],0) ) {\n                    dp[(l+1)%2][dy][dx] = nw + max(mp[dy][dx], 0);\n                    Q.push(State((l+1)%2,dy,dx));\n                }\n            }\n        }\n\n        int ans = inf;\n        REP(i,h) {\n            REP(j,w) {\n                if(mp[i][j] == -1) {\n                    ans = min(dp[0][i][j], ans);\n                    ans = min(dp[1][i][j], ans);\n                }\n            }\n        }\n        if(ans == inf) cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nstruct Node{\n\tint y,x,foot,cost;\n\tNode(){}\n\tNode(int a,int b,int c,int d):y(a),x(b),foot(c),cost(d){}\n\tbool operator <(const Node &a)const{return cost>a.cost;}\n};\n\nint main(){\n\tint w,h;\n\tchar map[60][30];\n\tint dp[60][30][2];\n\tpriority_queue<Node> pq;\n\tNode a,b;\n\twhile(cin>>w>>h&&(w||h)){\n\t\tint ans = -1;\n\t\twhile(!pq.empty())pq.pop();\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tpq.push(Node(i,j,0,0));\n\t\t\t\t\tpq.push(Node(i,j,1,0));\n\t\t\t\t\tdp[i][j][0]=dp[i][j][1]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tint sx,ddx;\n\t\t\ta=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(dp[a.y][a.x][a.foot] < a.cost)continue;\n\t\t\tif(map[a.y][a.x]=='T'){\n\t\t\t\tans = a.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a.foot==0){\n\t\t\t\tsx=ddx=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsx=ddx=-1;\n\t\t\t}\n\t\t\tfor(int dx=sx;abs(dx)<=3;dx+=ddx){\n\t\t\t\tfor(int dy=-2;dy<=2;dy++){\n\t\t\t\t\tif(3<abs(dy)+abs(dx))continue;\n\t\t\t\t\tint cost;\n\t\t\t\t\tb = Node(a.y+dy,a.x+dx,a.foot^1,a.cost);\n\t\t\t\t\tif(b.y<0||h<=b.y||b.x<0||w<=b.x||map[b.y][b.x]=='X')continue;\n\t\t\t\t\tif(map[b.y][b.x]=='S'||map[b.y][b.x]=='T')cost = 0;\n\t\t\t\t\telse cost = map[b.y][b.x]-'0';\n\t\t\t\t\tb.cost += cost;\n\t\t\t\t\tif(b.cost < dp[b.y][b.x][b.foot]){\n\t\t\t\t\t\tdp[b.y][b.x][b.foot] = b.cost;\n\t\t\t\t\t\tpq.push(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint xv[]={1,1,1,1,1,2,2,2,3},yv[]={2,1,0,-1,-2,1,0,-1,0};\n\nvoid solve(int w,int h){\n    char in;\n    bool l;\n    int r,c;\n    stack<pair<bool,pair<int,int>>> q;\n    pair<int,int> n;\n    vector<vector<int>> mp=vector<vector<int>>(h+4,vector<int>(w+6,-1));\n    vector<vector<vector<int>>> ma(h+4,vector<vector<int>>(w+6,vector<int>(2,INT_MAX/2)));\n    set<pair<int,int>> sset,tset;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin>>in;\n            if(in=='X')mp[i+1][j+2]=-1;\n            else if(in=='S'){\n                mp[i+1][j+2]=0;\n                sset.insert(make_pair(i+1,j+2));\n            }\n            else if(in=='T'){\n                mp[i+1][j+2]=0;\n                tset.insert(make_pair(i+1,j+2));\n            }\n            else{\n                mp[i+1][j+2]=in-'0';\n            }\n        }\n    }\n    for(pair<int,int> x:sset){\n        q.push(make_pair(true,make_pair(x.first,x.second)));\n        q.push(make_pair(false,make_pair(x.first,x.second)));\n        ma[x.first][x.second][0]=0;\n        ma[x.first][x.second][1]=0;\n    }\n    while(!q.empty()){\n        l=q.top().first;n=q.top().second;q.pop();\n        for(int i=0;i<9;i++){\n            r=n.first+yv[i];\n            c=n.second+(l?xv[i]:-1*xv[i]);\n            if(mp[r][c]!=-1&&ma[n.first][n.second][!l]+mp[r][c]<ma[r][c][l]){\n                ma[r][c][l]=ma[n.first][n.second][!l]+mp[r][c];\n                q.push(make_pair(!l,make_pair(r,c)));\n            }\n        }\n    }\n    int mini=INT_MAX/2;\n    for(pair<int,int> x:tset){\n        mini=min(mini,ma[x.first][x.second][0]);\n        mini=min(mini,ma[x.first][x.second][1]);\n    }\n    cout<<(mini!=INT_MAX/2?mini:-1)<<endl;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        solve(w,h);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={1,1,1,1,1,2,2,2,3},h,w;\nint dy[]={-2,-1,0,1,2,-1,0,1,0};\nstring t;\nint main(){\n  while(cin>>w>>h,w){\n    int d[h][w][2],a[h][w],ans=1e9;\n    r(i,h)r(j,w)r(k,2)d[i][j][k]=1e9;\n    r(i,h)r(j,w){\n      cin>>t;\n      if(t==\"X\")a[i][j]=-1;\n      else if(t==\"T\")a[i][j]=0;\n      else if(t==\"S\")a[i][j]=0,\n        d[i][j][0]=d[i][j][1]=0;\n      else a[i][j]=(t[0]-'0');\n    }\n    r(q,h)for(int i=h-1;i>=0;i--)\n      r(j,w)r(k,2)r(l,9)if(d[i][j][k]!=1e9){\n        int x=j,y=i+dy[l];\n        if(k)x+=dx[l];\n        else x-=dx[l];\n        if(x<0||x>=w||y<0||y>=h)continue;\n        if(a[y][x]==-1)continue;\n        if(d[i][j][k]+a[y][x]<d[y][x][!k])\n          d[y][x][!k]=d[i][j][k]+a[y][x];\n      }\n    r(i,w)if(a[0][i]==0)\n      ans=min(ans,min(d[0][i][0],d[0][i][1]));\n    if(ans!=1e9)cout<<ans<<endl;\n    else cout<<(-1)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repp(i,m,n) for(int i=(m);i<(n);i++)\n\n#define PUTLINE cout<<__LINE__<<endl;\n\nint cost[70][40][2];\nstring s[70][40];\n\nclass State{\npublic:\n\tint w,h,foot,cost;\n\tbool operator>(State state)const{return cost>state.cost;}\n};\n\nint main() {\n\tint w,h;\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>s[i][j];\n\t\t\tcost[i][j][0]=cost[i][j][1]=100100100;\n\t\t}\n\t\tpriority_queue<State,vector<State>,greater<State> > que;\n\t\trep(j,w){\n\t\t\tif(s[h-1][j]==\"S\"){\n\t\t\t\tState buf;\n\t\t\t\tbuf.h=h-1;\n\t\t\t\tbuf.w=j;\n\t\t\t\tbuf.cost=0;\n\t\t\t\tbuf.foot=0;\n\t\t\t\tque.push(buf);\n\t\t\t\tbuf.foot=1;\n\t\t\t\tque.push(buf);\n\t\t\t}\n\t\t}\n\t\tint result=100100100;\n\t\twhile(!que.empty()){\n\t\t\tState state=que.top();\n\t\t\tque.pop();\n//cout<<state.h<<\" \"<<state.w<<\" \"<<state.cost<<\" \"<<state.foot<<endl;\n\t\t\tif(state.cost>=cost[state.h][state.w][state.foot])continue;\n\t\t\tif(s[state.h][state.w]==\"X\")continue;\n\t\t\tchmin(cost[state.h][state.w][state.foot],state.cost);\n\t\t\tState next;\n\t\t\tnext.foot=state.foot^1;\n\t\t\tint i,j;\n\t\t\tif(state.foot==0){\n\t\t\t\tfor(i=-2;i<=2;i++){\n\t\t\t\t\tfor(j=1;j<=3;j++){\n\t\t\t\t\t\tif(abs(i)+j>3)continue;\n\t\t\t\t\t\tif(!(0<=state.h+i&&state.h+i<h&&0<=state.w+j&&state.w+j<w))continue;\n\t\t\t\t\t\tnext.h=state.h+i;\n\t\t\t\t\t\tnext.w=state.w+j;\n\t\t\t\t\t\tif(s[next.h][next.w]==\"S\")continue;\n\t\t\t\t\t\tif(s[next.h][next.w]==\"T\"){\n\t\t\t\t\t\t\tchmin(result,state.cost);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.cost=state.cost+s[next.h][next.w][0]-'0';\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(state.foot==1){\n\t\t\t\tfor(i=-2;i<=2;i++){\n\t\t\t\t\tfor(j=-3;j<=-1;j++){\n\t\t\t\t\t\tif(abs(i)-j>3)continue;\n\t\t\t\t\t\tif(!(0<=state.h+i&&state.h+i<h&&0<=state.w+j&&state.w+j<w))continue;\n\t\t\t\t\t\tif(s[next.h][next.w]==\"T\"){\n\t\t\t\t\t\t\tchmin(result,state.cost);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.h=state.h+i;\n\t\t\t\t\t\tnext.w=state.w+j;\n\t\t\t\t\t\tif(s[next.h][next.w]==\"S\")continue;\n\t\t\t\t\t\tnext.cost=state.cost+s[next.h][next.w][0]-'0';\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(result==100100100)cout<<-1<<endl;\n\t\telse cout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define exist(c, x) find(all(c), x) != (c).end()\n#define mp(a, b) make_pair(a, b)\nconst int inf = 1 << 28;\nconst int dx[][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1,  0,  0,  0,  1,  1,  2}},\n          dy[][9] = {{ 1,  1,  2, 1, 2, 3, 1, 2, 1}, {-1, -1, -2, -1, -2, -3, -1, -2, -1}};\n\nint w, h;\nvector<vector<int> > cliff;\nvector<vector<int> > gmem;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint calc(vector<int> T, int lf, int rf){\n    vector<vector<int> > &mem = gmem;\n    auto comp = [&](const pair<int, int> &a, const pair<int, int> &b){\n        return mem[a.first][a.second] > mem[b.first][b.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int> >, decltype(comp)> q(comp);\n    for(q.push(mp(lf, rf)); !q.empty();){\n        pair<int, int> p = q.top(); q.pop();\n        if(exist(T, p.first) || exist(T, p.second)){\n            return mem[p.first][p.second];\n            continue;\n        }\n        int lx = p.first / 100, ly = p.first % 100, rx = p.second / 100, ry = p.second % 100;\n        rep(i, 2)rep(j, 9){\n            int nx = (i? rx: lx) + dx[i][j], ny = (i? ry: ly) + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int cost = mem[p.first][p.second] + cliff[nx][ny], nxt = nx * 100 + ny;\n                if(mem[i? nxt: p.first][i? p.second: nxt] <= cost)continue;\n                mem[i? nxt: p.first][i? p.second: nxt] = cost;\n                q.push(mp(i? nxt: p.first, i? p.second: nxt));\n            }\n        }\n    }\n    return inf;\n}\n\nint solve(){\n    int res = inf;\n    gmem.assign(h * 100 + w, vector<int>(h * 100 + w, inf));\n    vector<int> T;\n    rep(j, w)if(cliff[0][j] == 0)T.push_back(j);\n    rep(k, w)if(cliff[h-1][k] == -1){\n        int st = (h-1) * 100 + k;\n        rep(i, 2)rep(j, 9){\n            int nx = h-1 + dx[i][j], ny = k + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int nxt = nx * 100 + ny;\n                gmem[i? nxt: st][i? st: nxt] = cliff[nx][ny];\n                res = min(res, calc(T, i? nxt: st, i? st: nxt));\n            }\n        }\n    }\n    return res == inf? -1: res;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        cin.ignore();\n        cliff.assign(h, vector<int>(w, 0));\n        rep(i, h){\n            string in;\n            getline(cin, in);\n            in.erase(remove_if(all(in), [](char c){return c == ' ';}), in.end());\n            rep(j, w)cliff[i][j] = in[j] == 'X'? -2: in[j] == 'S'? -1: in[j] == 'T'? 0: in[j] - '0';\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nint a[61][61];\nint d[2][61][61];\n\nint dx[2][9] = { {-2, -1, -1, 0, 0, 0, 1, 1, 2},\n                 {-2, -1, -1, 0, 0, 0, 1, 1, 2} };\nint dy[2][9] = { {1, 1, 2, 1, 2, 3, 1, 2, 1},\n                 {-1, -1, -2, -1, -2, -3, -1, -2, -1} };\n\nstruct node{\n    bool left;\n    int dist;\n    int x,y;\n    node(bool l,int d,int x,int y) : left(l), dist(d), x(x), y(y) {;}\n};\n\nbool operator<(const node &n,const node &m) {\n    return n.dist > m.dist;\n}\n\nint main() {\n    int w,h;\n    while(cin>>w>>h) {\n        if(h == 0 && w == 0) break;\n\n        rep(i,61) rep(j,61) d[0][i][j] = d[1][i][j] = 1<<29;\n        string s;\n        rep(i,h)\n            rep(j,w) {\n            cin>>s;\n            if(s[0] >= '0' && s[0] <= '9') a[i][j] = s[0] - '0';\n            else if(s[0] == 'X') a[i][j] = -1;\n            else if(s[0] == 'S') a[i][j] = -2;\n            else a[i][j] = -3;\n        }\n\n        // rep(i,h) {\n        //     rep(j,w) cout<<a[i][j]<<\" \";\n        //     cout<<endl;\n        // }\n\n        priority_queue<node> q;\n        rep(i,h) rep(j,w) {\n            if(a[i][j] == -2) {\n                q.push(node(1,0,i,j));\n                q.push(node(0,0,i,j));\n                d[0][i][j] = d[1][i][j] = 0;\n            }\n        }\n\n        while(!q.empty()) {\n            int x = q.top().x, y = q.top().y;\n            int di = q.top().dist,leg = q.top().left^1;\n            q.pop();\n\n            rep(i,9) {\n                int nx = x + dx[leg][i], ny = y + dy[leg][i];\n                if(nx < 0 || nx >= h || ny < 0 || ny > w-1) continue;\n                if(a[nx][ny] == -1) continue;\n                int pp = (a[nx][ny] == -2 || a[nx][ny] == -3) ? 0 : a[nx][ny];\n                if(d[leg][nx][ny] > di + pp) {\n                    d[leg][nx][ny] = di + pp;\n                    q.push(node(leg,di+pp,nx,ny));\n                }\n            }\n        }\n\n        int ans = 1<<29;\n        rep(i,h) rep(j,w) {\n            if(a[i][j] != -3) continue;\n            ans = min(ans, min(d[0][i][j], d[1][i][j]));\n        }\n\n        cout<<((ans==(1<<29))? -1 : ans)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int h,w,leg,cost;\n  State(int a,int b,int c,int d):h(a),w(b),leg(c),cost(d){}\n  bool operator<(State s)const{\n    return cost<s.cost;\n  }\n};\n\nint w,h;\nchar s[100][100];\nint dp[100][100][2]={};\n//            a                    b\nint x[2][9]={{1,1,1,1,1,2,2,2,3},{-1,-1,-1,-1,-1,-2,-2,-2,-3}};\nint y[2][9]={{-2,-1,0,1,2,-1,0,1,0},{-2,-1,0,1,2,-1,0,1,0}};\n\nbool in(int a,int b){\n  if(a<0 || b<0 || h<=a || w<=b)return false;\n  return true;\n}\n\nint main()\n{\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    priority_queue<State> pq;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>s[i][j];\n\tdp[i][j][0]=inf;\n\tdp[i][j][1]=inf;\n\tif(s[i][j]=='S'){\n\t  pq.push(State(i,j,0,0));\n\t  pq.push(State(i,j,1,0));\n\t  dp[i][j][0]=0;\n\t  dp[i][j][1]=0;\n\t}\n\tif(s[i][j]=='T')s[i][j]='0';\n      }\n    }\n\n    int ans=inf;\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.h][u.w][u.leg]<u.cost)continue;\n\n      if(s[u.h][u.w]=='0'){\n\tans=min(ans,u.cost);\n\tcontinue;\n      }\n\n      for(int k=0;k<9;k++){\n\tint a=u.h+y[u.leg][k],b=u.w+x[u.leg][k],c=(u.leg+1)%2;\n\tif(!in(a,b))continue;\n\tif(s[a][b]=='X' || s[a][b]=='S')continue;\n\tif((u.cost+(s[a][b]-'0'))<dp[a][b][c]){\n\t  dp[a][b][c]=u.cost+(s[a][b]-'0');\n\t  pq.push(State(a,b,c,dp[a][b][c]));\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<map>\n#include<climits>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\ntypedef tuple<int, int, int> Point;\ntypedef tuple<int, Point> Node;\nint Next[2][9][2] ={\n    {\n        {-2, 1}, {-1, 1}, {0, 1}, {1, 1}, {2, 1},\n        {-1, 2}, {0, 2}, {1, 2},\n        {0, 3}\n    },\n    {\n        {-2, -1}, {-1, -1}, {0, -1}, {1, -1}, {2, -1},\n        {-1, -2}, {0, -2}, {1, -2},\n        {0, -3}\n    },\n\n};\nenum {LEFT, RIGHT};\nenum {Y, X, SIDE};\nenum {COST, POINT};\nenum {START = -2, TOP, NIL};\n\nint Dijkstra(const vector<vector<int>>& cliff, const Point& start) {\n    int result = INT_MAX;\n    int h = cliff.size();\n    int w = cliff.front().size();\n    map<Point, int> cost;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        int c = get<COST>(q.top());\n        Point point = get<POINT>(q.top());\n        q.pop();\n        if(cost.count(point)) continue;\n        cost[point] = c;\n        for(const auto& d: Next[get<SIDE>(point)]) {\n            int y = get<Y>(point) + d[Y];\n            int x = get<X>(point) + d[X];\n            if(y < 0 || h  <= y) continue;\n            if(x < 0 || w  <= x) continue;\n            if(cliff[y][x] == NIL) continue;\n            if(cliff[y][x] == START) continue;\n            if(cliff[y][x] == TOP) {\n                result = min(result, c);\n            } else {\n                Point next_point(y, x, get<SIDE>(point) ^ 1);\n                if(cost.count(next_point)) continue;\n                q.push(Node(c + cliff[y][x], next_point));\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w | h) {\n        vector<vector<int>> cliff(h, vector<int>(w));\n        for(auto& line: cliff) for(auto& v: line) {\n            char c;\n            cin >> c;\n            if(c == 'S') v = START;\n            else if(c == 'T') v = TOP;\n            else if(c == 'X') v = NIL;\n            else v = c - '0';\n        }\n\n        int answer = INT_MAX;\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n            if(cliff[y][x] != START) continue;\n            answer = min({answer, Dijkstra(cliff, Point(y, x, LEFT)), Dijkstra(cliff, Point(y, x, RIGHT))});\n        }\n        cout << ((answer == INT_MAX) ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int LEF=0;\nconst int RIG=1;\nconst int UNTOUCH=1e8;\nstruct State{\n  pair<int,int> lef;\n  pair<int,int> rig;\n  int next;\n};\n\nbool operator<(State lhs,State rhs){\n  if(lhs.lef!=rhs.lef) return lhs.lef>rhs.lef;\n  if(lhs.rig!=rhs.rig) return lhs.rig>rhs.rig;\n  return lhs.next>rhs.next;\n}\n\n\nint main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    vector<vector<char>> buf(h,vector<char>(w));\n    vector<vector<int>> clif(h,vector<int>(w));\n    vector<int> s;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>buf[i][j];\n\tif(buf[i][j]=='X'){\n\t  clif[i][j]=UNTOUCH;\n\t}\n\telse if(buf[i][j]=='S' || buf[i][j]=='T'){\n\t  clif[i][j]=0;\n\t  if(buf[i][j]=='S'){\n\t    s.push_back(j);\n\t  }\n\t}\n\telse{\n\t  clif[i][j]=buf[i][j]-'0';\n\t}\n      }\n    }\n    map<State,int> dp;\n    priority_queue<pair<int,State>,vector<pair<int,State>>,greater<pair<int,State>>> que;\n    for(int i=0;i<s.size();i++){\n      State st;\n      st.lef=make_pair(h-1,s[i]);\n      st.rig=make_pair(h-1,s[i]);\n      st.next=LEF;\n      dp[st]=0;\n      que.push(make_pair(0,st));\n      st.next=RIG;\n      dp[st]=0;\n      que.push(make_pair(0,st));\n    }\n    const int REACH=3;\n    vector<int> dh={2,1,0};\n    auto isrange=[&h,&w](int i,int j){return 0<=i && i<h && 0<=j && j<w;};\n    bool touchable=false;\n    while(!que.empty()){\n      auto val=que.top();\n      que.pop();\n      if(val.first>dp[val.second]) continue;\n      State st=val.second;\n      if(buf[st.lef.first][st.lef.second]=='T' || buf[st.rig.first][st.rig.second]=='T'){\n\ttouchable=true;\n\tcout<<val.first<<endl;\n\tbreak;\n      }\n      pair<int,int> pivot=(st.next==LEF ? st.rig :st.lef);\n      for(int i=1;i<=REACH;i++){\n\tfor(int j=-dh[i-1];j<=dh[i-1];j++){\n\t  int toh=j+pivot.first;\n\t  int tow=i*(st.next==LEF ? -1 : 1)+pivot.second;\n\t  if(isrange(toh,tow) && clif[toh][tow]!=UNTOUCH){\n\t    State tos=st;\n\t    int cost=dp[st]+clif[toh][tow];\n\t    if(st.next==LEF){\n\t      tos.lef=make_pair(toh,tow);\n\t      tos.next=RIG;\n\t    }\n\t    else{\n\t      tos.rig=make_pair(toh,tow);\n\t      tos.next=LEF;\n\t    }\n\t    if(dp.count(tos)){\n\t      if(dp[tos]>cost){\n\t\tdp[tos]=cost;\n\t\tque.push(make_pair(cost,tos));\n\t      }\n\t    }\n\t    else{\n\t      dp[tos]=cost;\n\t      que.push(make_pair(cost,tos));\n\t    }\n\t  }\n\t}\n      }\n\n      \n    }\n    if(!touchable) cout<<-1<<endl;\n    \n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint w,h;\nint d[60][30][2];\nchar s[60][30];\nstruct point{\n    int y,x,f;\n    point(int y,int x,int f):y(y),x(x),f(f){};\n    bool operator<(const point& a)const{\n        return true;\n    }\n};\n\nusing P=pair<int,point>;\n\nbool is_valid(int y,int x){\n    return 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid run(){\n    cin>>w>>h;\n    if(!w)return;\n    rep(i,h)rep(j,w)rep(k,2)d[i][j][k]=inf;\n    priority_queue<P,vector<P>,greater<P>> q;\n    rep(i,h)rep(j,w){\n        cin>>s[i][j];\n        if(s[i][j]=='S'){\n            q.push(mp(0,point(i,j,0)));\n            q.push(mp(0,point(i,j,1)));\n            d[i][j][0]=d[i][j][1]=0;\n        }\n    }\n    int ans=inf;\n    while(!q.empty()){\n        P p=q.top();\n        q.pop();\n        point v=p.se;\n        if(d[v.y][v.x][v.f]<p.fi)continue;\n        int dy[]={-2,-1,-1,0,0,0,1,1,2},dx[]={1,1,2,1,2,3,1,2,1};\n        rep(i,9){\n            int y=v.y+dy[i],x=v.x+(v.f?-dx[i]:dx[i]),f=!v.f;\n            if(!is_valid(y,x))continue;\n            if(s[y][x]=='T')ans=min(ans,p.fi);\n            else{\n                int c;\n                if(s[y][x]=='S')c=0;\n                else if(s[y][x]=='X')c=inf;\n                else c=s[y][x]-'0';\n                if(d[y][x][f]>d[v.y][v.x][v.f]+c){\n                    d[y][x][f]=d[v.y][v.x][v.f]+c;\n                    q.push(mp(d[y][x][f],point(y,x,f)));\n                }\n            }\n        }\n    }\n    cout<<(ans!=inf?ans:-1)<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\nint DP[60][30][60][30], w, h;\nconst int INF = (1e9);\nchar S[60][30];\nstruct state{int lx, ly, rx, ry;};\nbool operator<(const state &x, const state &y){ return x.lx < y.lx;}\n\nbool in_range(int a, int b){ return a >= 0 && a < b;}\n\nint solve(){\n  priority_queue< pair<int, state> > wait;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if(S[i][j] == 'S'){\n        wait.emplace(0,(state){i,j,-1,-1});\n        wait.emplace(0,(state){-1,-1,i,j});\n      }\n    }\n  }\n  while(!wait.empty()){\n    state s = wait.top().second;\n    int t = -wait.top().first, lx = s.lx, ly = s.ly, rx = s.rx, ry = s.ry;\n    wait.pop();\n    //printf(\"%d %d %d %d %d\\n\",lx,ly,rx,ry,t);\n    if(lx >= 0 && rx >= 0 && DP[s.lx][s.ly][s.rx][s.ry] < t) continue;\n    if(lx >= 0 && ly >= 0){\n      for(int i = -2; i < 3; ++i){\n        for(int j = 0; j < 3; ++j){\n          int rx_ = lx + i, ry_ = ly + j + 1;\n          if((!in_range(rx_,h)) || (!in_range(ry_,w)) ||\n             (abs(j)+abs(i) > 2) || (S[rx_][ry_] == 'X')) continue;\n          int t_;\n          if(S[rx_][ry_] > '9' || S[rx_][ry_] < '0') t_ = t;\n          else t_ = t + S[rx_][ry_] - '0';\n          if(t_ >= DP[lx][ly][rx_][ry_]) continue;\n          DP[lx][ly][rx_][ry_] = t_;\n          wait.emplace(-t_,(state){lx,ly,rx_,ry_});\n        }\n      }\n    }\n    if(rx >= 0 && ry >= 0){\n      for(int i = -2; i < 3; ++i){\n        for(int j = 0; j < 3; ++j){\n          int lx_ = rx + i, ly_ = ry - j - 1;\n          if((!in_range(lx_,h)) || (!in_range(ly_,w)) ||\n             (abs(j)+abs(i) > 2) || (S[lx_][ly_] == 'X')) continue;\n          int t_;\n          if(S[lx_][ly_] > '9' || S[lx_][ly_] < '0') t_ = t;\n          else t_ = t + S[lx_][ly_] - '0';\n          if(t_ >= DP[lx_][ly_][rx][ry]) continue;\n          DP[lx_][ly_][rx][ry] = t_;\n          wait.emplace(-t_,(state){lx_,ly_,rx,ry});\n        }\n      }\n    }\n  }\n  //  cout << \"while loop finished\" << endl;\n  int ret = INF;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if(S[i][j] != 'T') continue;\n      for(int k = 0; k < h; ++k)\n        for(int l = 0; l < w; ++l)\n          ret = min({ret, DP[i][j][k][l], DP[k][l][i][j]});\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        cin >> S[i][j];\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n        for(int k = 0; k < h; ++k)\n          for(int l = 0; l < w; ++l)\n            DP[i][j][k][l] = INF;\n    int ans = solve();\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define H 60\n#define W 30\n#define INF 10000\n#define R 1\n#define L 0\nint w, h;\nchar maps[H][W];\nstruct point{\n    int x, y;\n};\n\nbool invalid(int x, int y){\n    return (x < 0 || x >= w || y < 0 || y >= h);\n}\n\nint dijkstra(){\n    int d[H][W][2];\n    bool used[H][W][2];\n    int ldx[9] = {-1, -1, -1, -1, -1, -2, -2, -2, -3};\n    int ldy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    int rdx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n    int rdy[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int k = 0; k < 2; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    for (int i = 0; i < w; i++) {\n        if (maps[h-1][i] == 'S') {\n            d[h - 1][i][L] = 0; d[h - 1][i][R] = 0;\n        }\n    }\n    \n    while (true) {\n        point p;\n        p.x = -1; p.y = -1;\n        int muki = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (!used[i][j][k] && (p.x == -1 || d[i][j][k] < d[p.y][p.x][muki])) {\n                        p.x = j; p.y = i; muki = k;\n                    }\n                }\n            }\n        }\n        \n        if (p.x == -1 && p.y == -1) {\n            break;\n        }\n        used[p.y][p.x][muki] = true;\n        \n        if (muki == R) {\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + ldx[i];\n                int my = p.y + ldy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R]);\n                }\n                else{\n                    d[my][mx][L] = min(d[my][mx][L], d[p.y][p.x][R] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n        else{\n            for (int i = 0; i < 9; i++) {\n                int mx = p.x + rdx[i];\n                int my = p.y + rdy[i];\n                \n                if (invalid(mx, my)) {\n                    continue;\n                }\n                if (maps[my][mx] == 'X') {\n                    continue;\n                }\n                if (maps[my][mx] == 'S' || maps[my][mx] == 'T') {\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L]);\n                }\n                else{\n                    d[my][mx][R] = min(d[my][mx][R], d[p.y][p.x][L] + (maps[my][mx] - '0'));\n                }\n            }\n        }\n    }\n    \n    int ans = INF;\n    for (int j = 0; j < w; j++) {\n        if (maps[0][j] == 'T'){\n            for (int k = 0; k < 2; k++) {\n                ans = min(ans, d[0][j][k]);\n            }\n        }\n    }\n    if (ans == INF) {\n        return -1;\n    }\n    else {\n        return ans;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> maps[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nint di[] = {2, 1, 0, -1, -2, 1, 0, -1, 0}, dj[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\nmain {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    auto g = vectors(h, w, char());\n    cin >> g;\n    using state = tuple<int, int, int, int>;\n    priority_queue<state, vector<state>, greater<state>> q;\n    auto dist = vectors(h, w, 2, INF);\n    rep(i, h) rep(j, w) {\n      if (g[i][j] == 'S') {\n        rep(k, 2) {\n          dist[i][j][k] = 0;\n          q.emplace(0, i, j, k);\n        }\n      }\n    }\n    int ans = INF;\n    while (q.size()) {\n      int d, i, j, k;\n      tie(d, i, j, k) = q.top();\n      q.pop();\n      rep(t, 9) {\n        int ni = i + di[t], nj = j + (k ? dj[t] : -dj[t]), nk = not k;\n        if (ni < 0 || nj < 0 || ni >= h || nj >= w || g[ni][nj] == 'X') continue;\n        int cost = dist[i][j][k] + (isdigit(g[ni][nj]) ? g[ni][nj] - '0' : 0);\n        if (cmin(dist[ni][nj][nk], cost)) q.emplace(dist[ni][nj][nk], ni, nj, nk);\n        if (g[ni][nj] == 'T') cmin(ans, cost);\n      }\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f;\n\t\t\t\t\tf.ly = f.ry = i;\n\t\t\t\t\tf.lx = f.rx = j;\n\t\t\t\t\tf.p = 0;\n\t\t\t\t\tf.cnt = 0;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\tif(field[temp.ry][temp.rx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\tif(field[temp.ly][temp.lx] != 11)\n\t\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n//passed all test cases\n//but couldnt pass"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define exist(c, x) find(all(c), x) != (c).end()\n#define mp(a, b) make_pair(a, b)\nconst int inf = 1 << 28;\nconst int dx[][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1,  0,  0,  0,  1,  1,  2}},\n          dy[][9] = {{ 1,  1,  2, 1, 2, 3, 1, 2, 1}, {-1, -1, -2, -1, -2, -3, -1, -2, -1}};\n\nint w, h;\nvector<vector<int> > cost;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(){\n    vector<vector<vector<int> > > mem(h, vector<vector<int> >(w, vector<int>(2, inf)));\n    auto comp = [&](const pair<int, int> &a, const pair<int, int> &b){\n        int ax = a.first / 100, ay = a.first % 100, bx = b.first / 100, by = b.first % 100;\n        return mem[bx][by][b.second] < mem[ax][ay][a.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int> >, decltype(comp)> q(comp);\n    vector<int> T;\n    rep(j, w){\n        if(cost[0][j] == 0)T.push_back(j);\n        if(cost[h-1][j] == -1){\n            rep(foot, 2){\n                mem[h-1][j][foot] = 0;\n                q.push(mp((h-1) * 100 + j, foot));\n            }\n        }\n    }\n    while(!q.empty()){\n        pair<int, int> p = q.top(); q.pop();\n        if(exist(T, p.first))continue;\n        int x = p.first / 100, y = p.first % 100;\n        rep(k, 9){\n            int nx = x + dx[p.second][k], ny = y + dy[p.second][k];\n            if(inrect(nx, ny) && 0 <= cost[nx][ny] && mem[nx][ny][p.second^1] == inf){\n                mem[nx][ny][p.second^1] = mem[x][y][p.second] + cost[nx][ny];\n                q.push(mp(nx * 100 + ny, p.second ^ 1));\n            }\n        }\n    }\n    int res = inf;\n    for(auto t: T)rep(k, 2)res = min(res, mem[0][t][k]);\n    return res == inf? -1: res;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        cin.ignore();\n        cost.assign(h, vector<int>(w, 0));\n        rep(i, h){\n            string in;\n            getline(cin, in);\n            in.erase(remove_if(all(in), [](char c){return c == ' ';}), in.end());\n            rep(j, w)cost[i][j] = in[j] == 'X'? -2: in[j] == 'S'? -1: in[j] == 'T'? 0: in[j] - '0';\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c;\n\tbool b;\n};\nbool operator<(const st&a, const st&b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint w, h;\ninline void update(st p, priority_queue<st>&que) {\n\tfor (int k = -2; k <= 2; k++) {\n\t\tfor (int t = 1; t <= 3 - abs(k); t++) {\n\t\t\tif (p.b) {\n\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tupdate({ i,j,0,0,0,1 }, que); update({ 0,0,i,j,0,0 }, que);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tupdate(p, que);\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_H = 100;\nconst int MAX_W = 100;\n\nclass Node{\npublic:\n    int cost;\n    int h, w;\n    bool right;\n    \n    Node(int cost, int h, int w, bool right): cost(cost), h(h), w(w), right(right){};\n    \n    bool operator < (const Node &r) const {\n        return cost > r.cost;\n    }\n};\n\nint W, H;\nchar field[MAX_H][MAX_W];\nint d[MAX_H][MAX_W][2];\n\nint solve(){\n    for(int i=0; i<MAX_H; i++)\n        for(int j=0; j<MAX_W; j++)\n            for(int k=0; k<2; k++)\n                d[i][j][k] = INF;\n    \n    priority_queue<Node> que;\n    \n    for(int i=0; i<W; i++) if(field[H-1][i] == 'S'){\n        que.push(Node(0, H-1, i, false));\n        d[H-1][i][false] = 0;\n        \n        que.push(Node(0, H-1, i, true));\n        d[H-1][i][true] = 0;\n    }\n    \n    while(!que.empty()){\n        Node v = que.top(); que.pop();\n        if(field[v.h][v.w] == 'T')\n            return d[v.h][v.w][v.right];\n        \n        if(d[v.h][v.w][v.right] < v.cost) continue;\n        \n        for(int dh=-3; dh<4; dh++){\n            for(int dw=-3; dw<4; dw++){\n                int nh = v.h + dh;\n                int nw = v.w + dw;\n                bool ns = v.right^true;\n                \n                if(nh<0 || H<=nh || nw<0 || W<=nw) continue;\n                if(abs(nh-v.h) + abs(nw-v.w) > 3) continue;\n                if(!((v.right && nw < v.w) || (!v.right && v.w < nw))) continue;\n                if(field[nh][nw] == 'X' || field[nh][nw] == 'S') continue;\n                \n                int cost;\n                if(field[nh][nw] == 'T')\n                    cost = 0;\n                else\n                    cost = field[nh][nw] - '0';\n                \n                if(cost + v.cost < d[nh][nw][ns]){\n                    d[nh][nw][ns] = cost + v.cost;\n                    que.push(Node(d[nh][nw][ns], nh, nw, ns));\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main(){\n    while(cin >> W >> H, W|H){\n        for(int h=0; h<H; h++)\n            for(int w=0; w<W; w++)\n                cin >> field[h][w];\n        \n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint h,w;\nchar s[66][33];\nint d[2][66][33];\nmain()\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin>>s[i][j];\n\t\t\td[0][i][j]=d[1][i][j]=1e9;\n\t\t}\n\t\tpriority_queue<pair<pair<int,int>,pair<int,int> > >P;\n\t\tfor(int i=0;i<w;i++)if(s[h-1][i]=='S')\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tP.push({{0,j},{h-1,i}});\n\t\t\t\td[j][h-1][i]=0;\n\t\t\t}\n\t\t}\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint c,r,x,y;\n\t\t\tc=-P.top().first.first;\n\t\t\tr=P.top().first.second;\n\t\t\tx=P.top().second.first;\n\t\t\ty=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(d[r][x][y]<c)continue;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\tfor(int tx=x-2;tx<=x+2;tx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int ty=y-3;ty<y;ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(abs(tx-x)+abs(ty-y)>3)continue;\n\t\t\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||s[tx][ty]=='X')continue;\n\t\t\t\t\t\tint cost=c+(s[tx][ty]>'A'?0:s[tx][ty]-'0');\n\t\t\t\t\t\tif(d[!r][tx][ty]>cost)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td[!r][tx][ty]=cost;\n\t\t\t\t\t\t\tP.push({{-cost,!r},{tx,ty}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int tx=x-2;tx<=x+2;tx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int ty=y+1;ty<=y+3;ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(abs(tx-x)+abs(ty-y)>3)continue;\n\t\t\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||s[tx][ty]=='X')continue;\n\t\t\t\t\t\tint cost=c+(s[tx][ty]>'A'?0:s[tx][ty]-'0');\n\t\t\t\t\t\tif(d[!r][tx][ty]>cost)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td[!r][tx][ty]=cost;\n\t\t\t\t\t\t\tP.push({{-cost,!r},{tx,ty}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=0;i<w;i++)if(s[0][i]=='T')ans=min(ans,min(d[0][0][i],d[1][0][i]));\n\t\tcout<<(ans<1e9?ans:-1)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 123456789;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\n\ntypedef vector< vector<Edge> > Graph;\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(auto& e:edges[v]){\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint W, H;\nint idx(int x, int y, int i = 0){\n  return y*W + x + i * W*H;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> W >> H, W){\n\tGraph G(W*H*2);\n\tint tab[80][50];\n\tfill((int*)tab, (int*)tab+80*50, -1);\n\tVI s, t;\n\tREP(y,H){\n\t  REP(x,W){\n\t\tchar c; cin >> c;\n\t\tint cost = 0;\n\t\tif(c == 'S'){\n\t\t  s.PB(idx(x,y,0));\n\t\t  s.PB(idx(x,y,1));\t\t  \n\t\t}\n\t\telse if(c == 'T'){\n\t\t  t.PB(idx(x,y,0));\n\t\t  t.PB(idx(x,y,1));\n\t\t}\n\t\telse if(c == 'X')\n\t\t  cost = -1;\n\t\telse\n\t\t  cost = c - '0';\n\t\ttab[y][x] = cost;\n\t  }\n\t}\n\tfor(int y=0;y<H;++y){\n\t  for(int x=0;x<W;++x){\n\t\tif(tab[y][x] < 0) continue;\n\t\tfor(int dx=1;dx<=3;++dx){\n\t\t  for(int dy=-(3-dx);dy<=3-dx;++dy){\n\t\t\tint tx = x + dx, ty = y + dy;\n\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && tab[ty][tx] != -1){\n\t\t\t  G[idx(x,y)].PB(Edge(idx(tx,ty,1), tab[ty][tx]));\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tfor(int dx=-1;dx>=-3;--dx){\n\t\t  for(int dy=-(3+dx);dy<=3+dx;++dy){\n\t\t\tint tx = x + dx, ty = y + dy;\n\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && tab[ty][tx] != -1){\n\t\t\t  G[idx(x,y,1)].PB(Edge(idx(tx,ty,0), tab[ty][tx]));\n\t\t\t}\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\tint ans = INF;\n\tREP(i,SZ(s)){\n\t  VI dist(W*H*2);\n\t  Dijkstra(G, dist, s[i]);\n\t  REP(j,SZ(t)){\n\t\tans = min(ans, dist[t[j]]);\n\t  }\n\t}\n\tif(ans >= INF) ans = -1;\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define x first\n#define y second \n#define INF 1e+9\n\nint w,h;\nint board[61][31];\nint used[2][61][31][61][31]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\nvector<foot> s,g;\n\nstruct state{\n\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.x = lx; l.y = ly; r.x = rx; r.y = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.x << \",\" << l.y << \"),\";\n\t\t\tcout << \"(\" << r.x << \",\" << r.y << \")\";\n\t\t\tcout << \":\" << f << \", \" << c << endl;\n\t  }\n\t  \n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.y][s.l.x][s.r.y][s.r.x] = 1;\n}\nbool is_used(state s){\n\t  return  used[s.f][s.l.y][s.l.x][s.r.y][s.r.x];\n}\nbool valid(state s){\n\t  if(s.r.y >=h or s.r.y < 0 or s.r.x >=w or s.r.x < 0) return true;\n\t  if(s.l.y >=h or s.l.y < 0 or s.l.x >=w or s.l.x < 0) return true;\n\t  if(board[s.r.y][s.r.x] < 0) return true;\n\t  if(board[s.l.y][s.l.x] < 0) return true;\n\t  return false;\n}\nbool goal(state s){\n\t  for(int i=0; i<g.size(); i++)\n\t\t\tif(g[i] == s.l or g[i] == s.r) return true;\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  memset(used,0,sizeof(used));\n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n\t  \n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\t\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\t\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost=0;\n\t\t\t\t  if(corr.f == 0){ // ????¶?\n\t\t\t\t\t\tns.r.x = corr.l.x + dx[i];\n\t\t\t\t\t\tns.r.y = corr.l.y - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.y][ns.r.x];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?\n\t\t\t\t\t\tns.l.x = corr.r.x - dx[i];\n\t\t\t\t\t\tns.l.y = corr.r.y - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.y][ns.l.x];\n\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tsort(s.begin(),s.end());\n\t\t\tstate st0 = state(s[0],s[1],0,0);\n\t\t\tstate st1 = state(s[0],s[1],1,0);\n\t\t\tint ans0 = dijk(st0);\n\t\t\tint ans1 = dijk(st1);\n\t\t\tif(ans0 == -1)\n\t\t\t\t  cout << ans1 << endl;\n\t\t\telse if(ans1 == -1)\n\t\t\t\t  cout << ans0 << endl;\n\t\t\telse\n\t\t\t\t  cout << min(ans0,ans1) << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\tint x[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\tint y[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<int, int> memo;\n\t\tset<int> t;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X') \n\t\t\t\t\tfield[i][j] = INF;\n\t\t\t\telse if(input == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tpq.push(feet(j, i, 0, 0));\n\t\t\t\t\tpq.push(feet(j, i, 1, 0));\n\t\t\t\t}\n\t\t\t\telse if(input == 'T') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tt.insert(j*100+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(t.count(f.x*100+f.y)) { // 'T'\n\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<9; i++) {\n\t\t\t\tfeet temp(f.x+x[i], f.y+y[i], !f.p, f.cnt+field[f.y+y[i]][f.x+x[i]]);\n\t\t\t\tif(f.p) {\n\t\t\t\t\ttemp.x = f.x-x[i];\n\t\t\t\t\ttemp.cnt = f.cnt+field[f.y+y[i]][f.x-x[i]];\n\t\t\t\t}\n\t\t\t\tint chk = temp.x*10000 + temp.y*100 + temp.p;\n\t\t\t\tif(field[temp.y][temp.x] != INF) { // 'x'\n\t\t\t\t\tif(0 <= temp.x && temp.x < w && 0 <= temp.y && temp.y < h) { //out of range\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans==INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nint w,h;\nstring mp[61];\nint memo[61][31][61][31];\nint visited[61][31][61][31];\nint ans;\nint cnt = 0;\n\nvoid check(int rx,int ry,int lx,int ly) {\n\n  for(int i=h-1;i>=0;i--) {\n    for(int j=0;j<w;j++) {\n      if(i == ry && j == rx) cout <<'>';\n      else if(i == ly && j == lx) cout <<'<';\n      else cout << mp[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid saiki(int rx,int ry,int lx,int ly,int sta,int sum) {\n  cnt++;\n  sta %= 2;  \n  //cout << cnt << endl;\n  //check(rx,ry,lx,ly);\n\n  if((mp[ry][rx] == 'T'||mp[ly][lx] =='T') && ans > sum) ans = sum;\n  \n  for(int i=1;i<=3;i++){\n    for(int j=-2+i-1;j<=2-i+1;j++) {\n      int rnx=rx,rny=ry,lnx=lx,lny=ly,cost,cost2;\n      if(sta == 0) lnx=rx-i,lny=ry+j;\n      if(sta == 1) rnx=lx+i,rny=ly+j;\n      if(rnx<0 || rny<0 || rnx>=w || rny>=h) continue;\n      if(lnx<0 || lny<0 || lnx>=w || lny>=h) continue;\n      if(mp[rny][rnx]=='X' || mp[lny][lnx]=='X') continue;\n      if(sta==0) {\n\tcost = mp[lny][lnx]-'0';\n\tcost2 = mp[rny][rnx] - '0';\n\tif(mp[lny][lnx] == 'S' || mp[lny][lnx] == 'T') cost = 0;\n\tif(mp[rny][rnx] == 'S' || mp[rny][rnx] == 'T') cost2= 0;\n\tif(mp[rny][rnx] == 'T') continue;\n\n      } else if(sta==1) {\n\tcost = mp[rny][rnx]-'0';\n\tcost2 = mp[lny][lnx]-'0';\n\tif(mp[rny][rnx] == 'S' || mp[rny][rnx] == 'T') cost = 0;\n\tif(mp[lny][lnx] == 'S' || mp[lny][lnx] == 'T') cost2= 0;\n\tif(mp[lny][lnx] == 'T') continue;\n      }\n      if(visited[rny][rnx][lny][lnx]  <= sum+cost) continue;\n      else visited[rny][rnx][lny][lnx] = sum+cost;\n      \n  \n      saiki(rnx,rny,lnx,lny,sta+1,sum+cost);\n      \n      \n    }\n  }\n  \n}\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n\n    for(int i=0;i<h;i++) {\n      mp[h-1-i] = \"\";\n      for(int j=0;j<w;j++) {\n\tstring a;\n\tcin >> a;\n\tmp[h-1-i]+= a;\n      }\n    }\n\n  \n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++)\n\tfor(int k=0;k<=h;k++)\n\t  for(int m=0;m<=w;m++)\n\t    memo[i][j][k][m] = visited[i][j][k][m] = INF;\n    cnt = 0;\n    ans = INF;\n    for(int i=0;i<w;i++) {\n      if(mp[0][i] == 'S')saiki(i,0,i,0,0,0),saiki(i,0,i,0,1,0);\n    }\n\n    if(ans == INF) cout << -1<<endl;\n    else cout << ans <<endl;\n \n  }\n\n  return 0;\n}\n  \n \n \n \n "
  },
  {
    "language": "C++",
    "code": "// start: 21:57\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <sstream>\n#include <deque>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\n// テ・ツキツヲティツカツウテ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ォテァツスツョテ」ツ?妥」ツつ凝・ツ渉ウティツカツウ\nint mx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    my[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nvoid dump(vector< vector<char> > &f, int x = -1, int y = -1, int l = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == y && j == x ) {\n                if ( l == 0 )\n                    cout << \"R\";\n                else\n                    cout << \"L\";\n            }\n            else\n                cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        int closed[h][w][2];\n        vector< queue<xy> > foot(2);   // 0:テ・ツ渉ウ 1:テ・ツキツヲ\n        queue<int> cost, leg;\n        vector< vector<char> > f(h);\n        vector< xy > start;\n\n        REP(i, h) REP(j, w) REP(k, 2) closed[i][j][k] = 0;\n\n        REP(i, h) {\n            REP(j, w) {\n                char tmp;\n                cin >> tmp;\n                f[i].push_back(tmp);\n                if ( f[i][j] == 'S' ) {\n                    start.push_back( make_pair(j, i) );\n                }\n            }\n        }\n\n        // テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗・ツ慊ーテァツつケテッツシツ凝・ツキツヲテ・ツ渉ウテ」ツつ津・ツ按敕ヲツ慊淌・ツ?、テ」ツ?ィテ」ツ?療」ツ?ヲpush\n        REP(i, start.size()) {\n            int l = 0;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n\n            l = 1;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n\n            // cout << start[i].first << \" \" << start[i].second << \" \" << f[start[i].second][start[i].first] << endl;\n        }\n\n        int min = INT_MAX;\n        while(!cost.empty()) {\n            int c = cost.front(); cost.pop();\n            int l = leg.front(); leg.pop();\n            xy ft = foot[l].front(); foot[l].pop();\n            int x = ft.first, y = ft.second;\n\n            // printf(\"f:%d, x:%d, y:%d, xy:%c\\n\", l, x, y, f[y][x]);\n            // dump(f, x, y, l);\n            if ( f[y][x] == 'T' && c < min ) {\n                min = c;\n                continue;\n            }\n\n            REP(i, 9) {\n                int dir = l == 0 ? -1: 1,\n                    nx = x + mx[i] * dir,\n                    ny = y + my[i],\n                    nl = !l;\n\n                if ( !(0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n                if ( f[ny][nx] == 'X' || f[ny][nx] == 'S' ) continue;   // テ」ツδ静」ツつーテ・ツ?コテ」ツつ凝」ツ?凝」ツつ?\n\n                // int nc = (int)f[ny][nx] - 48;\n                int nc;\n                if ( ((int)f[ny][nx] - 48) > 9 )\n                    nc = c + 1;\n                else\n                    nc = c + ((int)f[ny][nx] - 48);\n                // nc += c;\n                // int nc = c + 1;\n                // cout << nc << \" \" << f[ny][nx] << endl;\n\n                if ( closed[ny][nx][nl] != 0 && closed[ny][nx][nl] < nc ) continue;\n\n                cost.push(nc);\n                leg.push(nl);   // テゥツ??ィツカツウ\n                foot[nl].push( make_pair(nx, ny) );\n                closed[ny][nx][nl] = nc;\n\n            }\n            // cout << c << endl;\n            // REP(i, h) {REP(j, w) {cout << closed[i][j][0];} cout << endl;}\n            // cout << endl << c << endl;\n            // REP(i, h) {REP(j, w) {cout << closed[i][j][1];} cout << endl;}\n            // cout << endl;\n\n        }\n\n        if ( min == INT_MAX )\n            cout << -1 << endl;\n        else\n            cout << (min-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tll w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<char> > cell(h, vector<char>(w));\n\t\tvector<P> s;\n\t\tvector<P> g;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin>>cell[i][j];\n\t\t\t\tif(cell[i][j] == 'S') s.pb(P(i, j));\n\t\t\t\tif(cell[i][j] == 'T') g.pb(P(i, j));\n\t\t\t}\n\t\t}\n\t\tvector<vector<vector<ll> > > d(h, vector<vector<ll> >(w, vector<ll>(2, INF)));\n\t\tpriority_queue<pair<ll, pair<P, ll> >, vector<pair<ll, pair<P, ll> > > , greater<pair<ll, pair<P, ll> > > > q;\n\t\twhile(s.size()) {\n\t\t\tREP(i, 2) {\n\t\t\t\td[s[s.size() - 1].first][s[s.size() - 1].second][i] = 0;\n\t\t\t\tq.push({0, {P(s[s.size() - 1].first, s[s.size() - 1].second), i}});\n\t\t\t\twhile(!q.empty()) {\n\t\t\t\t\tpair<ll, pair<P, ll> > p = q.top();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(d[p.second.first.first][p.second.first.second][p.second.second] != p.first) continue;\n\t\t\t\t\tswitch(p.second.second) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tFOR(j, 1, 4) {\n\t\t\t\t\t\t\t\tFOR(k, (- 3 + j), (3 - j) + 1) {\n\t\t\t\t\t\t\t\t\tll nh = p.second.first.first + k;\n\t\t\t\t\t\t\t\t\tll nw = p.second.first.second + j;\n\t\t\t\t\t\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && cell[nh][nw] != 'X') {\n\t\t\t\t\t\t\t\t\t\tif(cell[nh][nw] == 'T') {\n\t\t\t\t\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][0]) {\n\t\t\t\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][0];\n\t\t\t\t\t\t\t\t\t\t\tq.push({d[nh][nw][1], {P(nh, nw), 1}});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(cell[nh][nw] == 'S') continue;\n\t\t\t\t\t\t\t\t\t\tif(d[nh][nw][1] > d[p.second.first.first][p.second.first.second][0] + (cell[nh][nw] - '0')) {\n\t\t\t\t\t\t\t\t\t\t\td[nh][nw][1] = d[p.second.first.first][p.second.first.second][0] + (cell[nh][nw] - '0');\n\t\t\t\t\t\t\t\t\t\t\tq.push({d[nh][nw][1], {P(nh, nw), 1}});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tFOR(j, -3, 0) {\n\t\t\t\t\t\t\t\tFOR(k, (- 3 - j), (3 + j) + 1) {\n\t\t\t\t\t\t\t\t\tll nh = p.second.first.first + k;\n\t\t\t\t\t\t\t\t\tll nw = p.second.first.second + j;\n\t\t\t\t\t\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && cell[nh][nw] != 'X') {\n\t\t\t\t\t\t\t\t\t\tif(cell[nh][nw] == 'T') {\n\t\t\t\t\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][1]) {\n\t\t\t\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][1];\n\t\t\t\t\t\t\t\t\t\t\tq.push({d[nh][nw][0], {P(nh, nw), 0}});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(cell[nh][nw] == 'S') continue;\n\t\t\t\t\t\t\t\t\t\tif(d[nh][nw][0] > d[p.second.first.first][p.second.first.second][1] + (cell[nh][nw] - '0')) {\n\t\t\t\t\t\t\t\t\t\t\td[nh][nw][0] = d[p.second.first.first][p.second.first.second][1] + (cell[nh][nw] - '0');\n\t\t\t\t\t\t\t\t\t\t\tq.push({d[nh][nw][0], {P(nh, nw), 0}});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.pop_back();\n\t\t}\n\t\tll ans = INF;\n\t\twhile(g.size()) {\n\t\t\tREP(i, 2) {\n\t\t\t\tans = min(ans, d[g[g.size() - 1].first][g[g.size() - 1].second][i]);\n\t\t\t}\n\t\t\tg.pop_back();\n\t\t}\n\t\tif(ans != INF) cout<<ans<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-10;\nint INF=1e9;\nint MOD=1000000007;\nint memo[30][60][2];//0:left,1:right;\nbool used[30][60][2];\nint dxL[9]={1,1,1,1,1,2,2,2,3};\nint dyL[9]={-2,-1,0,1,2,-1,0,1,0};\nint dxR[9]={-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint dyR[9]={-2,-1,0,1,2,-1,0,1,0};\nint w,h;\nchar fld[30][60];\nvoid rec(int x,int y,int leg,int cnt){\n\tif(fld[x][y]=='S'){\n\t\tmemo[x][y][leg]=min(memo[x][y][leg],cnt);\n\t\treturn;\n\t}\n\tif(memo[x][y][leg]<=cnt+(fld[x][y]-'0'))return;\n\tif(fld[x][y]=='T')memo[x][y][leg]=0;\n\telse memo[x][y][leg]=cnt+(fld[x][y]-'0');\n\tif(leg==0){\n\t\tREP(i,9){\n\t\t\tint nx=x+dxL[i],ny=y+dyL[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||fld[nx][ny]=='X')continue;\n\t\t\trec(nx,ny,1,memo[x][y][leg]);\n\t\t}\n\t}else{\n\t\tREP(i,9){\n\t\t\tint nx=x+dxR[i],ny=y+dyR[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||fld[nx][ny]=='X')continue;\n\t\t\trec(nx,ny,0,memo[x][y][leg]);\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\twhile(cin>>w>>h&&(w||h)){\n\t\tREP(i,30)REP(j,60)REP(k,2)memo[i][j][k]=INF;\n\t\tvector<P>S,T;\n\t\tREP(i,h)REP(j,w){\n\t\t\tcin>>fld[j][i];\n\t\t\tif(fld[j][i]=='S'){\n\t\t\t\tS.PB(MP(j,i));\n\t\t\t}else if(fld[j][i]=='T'){\n\t\t\t\tT.PB(MP(j,i));\n\t\t\t}\n\t\t}\n\t\tREP(i,T.size()){\n\t\t\trec(T[i].first,T[i].second,0,0);\n\t\t\trec(T[i].first,T[i].second,1,0);\n\t\t}\n\t\tint ans=INF;\n\t\tREP(i,S.size()){\n\t\t\tans=min(ans,min(memo[S[i].first][S[i].second][0],memo[S[i].first][S[i].second][1]));\n\t\t}\n\t\tif(ans==INF)cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define INF 10000000\n\nusing namespace std;\n\nclass State{\npublic:\n  int x, y;\n  int t;\n  int f;\n};\n\nint dx[2][9]={1, 1, 2, 1, 2, 3, 1, 2, 1, -1, -1, -2, -1, -2, -3, -1, -2, -1};\nint dy[9]={-2, -1, -1, 0, 0, 0, 1, 1, 2};\nchar in[60][30];\nint  w, h;\nint bfs(int);\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in[i][j];\n      }\n    }\n    int ans=INF;\n    int tmp;\n    tmp=bfs(0);\n    if(ans>tmp) ans=tmp;\n    tmp=bfs(1);\n    if(ans>tmp) ans=tmp;\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint bfs(int sf){\n  queue<State> Q;\n  int tmp;\n  int cost[2][60][30];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cost[0][i][j]=cost[1][i][j]=INF;\n    }\n  }\n  State u;\n  int ans=INF;\n  for(int i=0;i<w;i++){\n    if(in[h-1][i]=='S'){\n      u.x=i;\n      u.y=h-1;\n      u.t=0;\n      u.f=sf;\n      Q.push(u);\n      cost[u.f][u.y][u.x]=0;\n      bool end=false;\n      while(!Q.empty()){\n\tu=Q.front(), Q.pop();\n\tint tx, ty;\n\tfor(int j=0;j<9;j++){\n\t  tx=u.x+dx[u.f][j];\n\t  ty=u.y+dy[j];\n\t  if(ty>=0 && ty<h){\n\t    if(tx>=0 && tx<w){\n\t      if(in[ty][tx]!='X'){\n\t\tint num;\n\t\tif(in[ty][tx]=='T'){\n\t\t  if(cost[(u.f+1)%2][ty][tx]>u.t) cost[(u.f+1)%2][ty][tx]=u.t;\n\t\t  break;\n\t\t}else if(in[ty][tx]=='S') num=0;\n\t\telse num=in[ty][tx]-'0';\n\t\tif(cost[(u.f+1)%2][ty][tx]>u.t+num){\n\t\t  State v;\n\t\t  v.x=tx;\n\t\t  v.y=ty;\n\t\t  v.t=u.t+num;\n\t\t  v.f=(u.f+1)%2;\n\t\t  cost[v.f][ty][tx]=v.t;\n\t\t  Q.push(v);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\ttmp=INF;\n\tfor(int i=0;i<w;i++){\n\t  if(in[0][i]=='T'){\n\t    if(tmp>cost[0][0][i]){\n\t      tmp=cost[0][0][i];\n\t    }\n\t    if(tmp>cost[1][0][i]){\n\t      tmp=cost[1][0][i];\n\t    }\n\t  }\n\t}\n      }\n      if(ans>tmp) ans=tmp;\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define INF 100000009\n#define N 20005\nusing namespace std;\n\ntypedef pair<int,int> PI;//cost to;\n\nint map[65][35];\nint w,h;\n\nbool checkin(int i,int j){\n    if(i>=0&&j>=0&&i<h&&j<w&&map[i][j]!=INF){\n        return true;\n    }else{\n        return false;\n    }\n}\nint retc(int i,int j){\n    if(map[i][j]==-1){\n        return 0;\n    }else{\n        return map[i][j];\n    }\n}\n\nint make(int foot,int state,int i,int j){\n    return foot*w*h*9+state*w*h+i*w+j;\n}\n\nint main(){\n    int cango[9][2];//where right is from left,yx\n    int hoge = 0;\n    for(int y = 0;y<=2;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    for(int y = -2;y<=-1;y++){\n        for(int x = 1;x<=3-abs(y);x++){\n            cango[hoge][0]=y;\n            cango[hoge++][1]=x;\n        }\n    }\n    while(1){\n        vector<PI> G[3600*9+5];//0???????¶? 1???????¶? to,cost\n        bool flag[3600*9+5];\n        bool goal[3600*9+5];\n        rep(i,3600*9+5){\n            flag[i]=0;\n            goal[i]=0;\n        }\n        cin>>w>>h;\n        if(w==0){\n            return 0;\n        }\n        char c;\n        rep(i,h){\n            rep(j,w){\n                cin>>c;\n                if(c=='S')        map[i][j]=0;\n                else if(c=='T')   map[i][j]=-1;\n                else if(c=='X')   map[i][j]=INF;\n                else map[i][j]=c-'0';\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(!checkin(i,j))continue;\n                rep(state1,9){\n                    int y=i+cango[state1][0],x=j+cango[state1][1];\n                    if(!checkin(y,x))continue;\n                    if(map[i][j]==-1||map[y][x]==-1){\n                        goal[make(0,state1,i,j)]=true;\n                        goal[make(1,state1,i,j)]=true;\n                    }\n                    rep(state2,9){\n                        if(state1==state2)\n                            continue;\n                        int ny=i+cango[state2][0],nx=j+cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(0,state1,i,j)].pb(mp(make(1,state2,i,j),retc(ny,nx)));\n                        }\n                        ny=y-cango[state2][0],nx=x-cango[state2][1];\n                        if(checkin(ny,nx)){\n                            G[make(1,state1,i,j)].pb(mp(make(0,state2,ny,nx),retc(ny,nx)));\n                        }\n                        \n                    }\n                }\n            }\n        }\n        //        rep(i,3600*9+5){\n        //            if(!G[i].empty()){\n        //                rep(j,G[i].size()){\n        //                    cout<<\"from:\"<< \" foot:\" <<i/(w*h*9) <<\" state:\"<<i/w/h%9<<\" i j:(\"<< i/w%h<< \" \"<<i%w<< \")\"<<endl;\n        //\n        //                    cout<<\"to  :\"<< \" foot:\" <<G[i][j].first/(w*h*9) <<\" state:\"<<G[i][j].first/w/h%9<<\" i j:(\"<< G[i][j].first/w%h<< \" \"<<G[i][j].first%w <<\") cost:\"<<G[i][j].second<<endl<<endl;\n        //                }\n        //            }\n        //        }\n        priority_queue<PI, vector<PI> ,greater<PI> > pq;\n        rep(j,w){\n            if(map[h-1][j]!=0){continue;}\n            rep(st,9){\n                int y = h-1+cango[st][0],x = j+cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(1,st,h-1,j))));}\n                y = h-1-cango[st][0],x = j-cango[st][1];\n                if(checkin(y,x)){pq.push(mp(retc(y,x),(make(0,st,y,x))));}\n            }\n        }\n        int ans = -1;\n        while(!pq.empty()){\n            PI now = pq.top();\n            int cost = now.first;\n            int from = now.second;\n            pq.pop();\n            if(flag[from]){\n                continue;\n            }\n            flag[from]=true;\n            if(goal[from]){\n                ans = cost;\n                break;\n            }\n            rep(i,G[from].size()){\n                if(!flag[G[from][i].first])\n                    pq.push(mp(G[from][i].second+cost,G[from][i].first));\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define  range(i, l, r) for (int i = (int)(l); i < (int)(r); (i) += 1)\n#define rrange(i, l, r) for (int i = (int)(r) - 1; i >= (int)(l); (i) -= 1)\n\n#define  whole(f, x, ...) ([&](decltype((x)) container) { return (f)(  begin(container),  end(container), ## __VA_ARGS__); })(x)\n#define rwhole(f, x, ...) ([&](decltype((x)) container) { return (f)( rbegin(container), rend(container), ## __VA_ARGS__); })(x)\n\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\nusing i32 = int;\nusing u32 = unsigned int;\nusing i64 = long long;\nusing u64 = unsigned long long;\n\n// constexpr i32 mod   = 998244353;\nconstexpr i32 mod   = 1e9 + 7;\nconstexpr i32 inf   = 1001001001;\nconstexpr i64 infll = 1001001001001001001ll;\n\nconstexpr int dx[] = {0, -1, 1, 0, -1, 1, -1, 1};\nconstexpr int dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\nstruct IoSetup { IoSetup(int x = 15){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(x); cerr << fixed << setprecision(x); } } iosetup;\n\ntemplate <typename T = i64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { range(i, 0, v.size()) { os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\n\ntemplate <typename T> vector<T> make_vector(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_vector(size_t a, Ts... ts) { return vector<decltype(make_vector(ts...))>(a, make_vector(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// }}}\n\nvoid solver(int w, int h) {\n    auto ss = make_vector(h, w, '.');\n    range(i, 0, h) range(j, 0, w) cin >> ss[i][j];\n\n    auto as = make_vector(h, w, 0);\n    vector< pair< int, int > > st, gl;\n    int lx, ly, rx, ry;\n    range(i, 0, h) range(j, 0, w) {\n        if (ss[i][j] == 'X') {\n            as[i][j] = -1;\n        } else if (ss[i][j] == 'S') {\n            st.emplace_back(i, j);\n        } else if (ss[i][j] == 'T') {\n            gl.emplace_back(i, j);\n        } else {\n            as[i][j] = ss[i][j] - '0';\n        }\n    }\n\n//    for (auto a: as) cerr << a << endl;\n\n    auto dijkstra = [&](int y, int x, bool is_right) {\n        auto dist = make_vector(h, w, 2, inf);\n\n        dist[y][x][is_right] = 0;\n        using pq_type = pair< int, pair< pair< int, int >, bool> >;\n        priority_queue< pq_type, vector<pq_type>, greater<pq_type>> pq;\n        pq.emplace(0, make_pair(make_pair(y, x), is_right));\n\n        while (!pq.empty()) {\n            auto cur = pq.top();\n            pq.pop();\n\n            int cy = cur.second.first.first;\n            int cx = cur.second.first.second;\n            bool pre_right = cur.second.second;\n\n//            cerr << make_pair(cy, cx) << endl;\n\n            if (cur.first > dist[cy][cx][pre_right]) continue;\n\n            range(dy, -3, 4) range(dx, -3, 4) {\n                int ny = cy + dy;\n                int nx = cx + dx;\n\n                if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue; \n                if (abs(nx - cx) + abs(ny - cy) > 3) continue;\n\n                if (pre_right && nx >= cx) continue; \n                if (!pre_right && nx <= cx) continue;\n\n                if (as[ny][nx] == -1) continue;\n\n                if (dist[ny][nx][!pre_right] > dist[cy][cx][pre_right] + as[ny][nx]) {\n                    dist[ny][nx][!pre_right] = dist[cy][cx][pre_right] + as[ny][nx];\n                    pq.emplace(dist[ny][nx][!pre_right], make_pair(make_pair(ny, nx), !pre_right));\n                }\n            }\n        }\n\n        int res = inf;\n        for (auto p: gl) {\n            chmin(res, dist[p.first][p.second][0]);\n            chmin(res, dist[p.first][p.second][1]);\n        }\n\n        return res;\n    };\n\n    int ans = inf;\n    for (auto p: st) {\n        chmin(ans, dijkstra(p.first, p.second, true));\n        chmin(ans, dijkstra(p.first, p.second, false));\n    }\n\n    if (ans == inf) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\n\nsigned main(int argc, char *argv[]) {\n    int h, w;\n    while (cin >> w >> h, w) {\n        solver(w, h);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <cstring>\n\nconstexpr int CANT_GO = 114514;\n\nint field[60][30] = {0};\nint dp[2][60][30][5][3] = { 0 }; //[?¬???????][??????y][x][?????????y][x] = cost\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nstruct Node {\n\tint x, y; \n\tint rx, ry; //????¶???????????????????\n\tint cost;\n\tbool nextR; //?¬?????????????????????????true\n\tbool operator>(const Node& rhs) const {\n\t\tif (cost == rhs.cost) return y > rhs.y;\n\t\treturn cost > rhs.cost;\n\t}\n};\nint main() {\n\tint w, h;\n\twhile (std::cin >> w >> h && (w || h)) {\n\t\tstd::memset(dp, 0x7f, sizeof(int) * 2 * 60 * 30 * 5 * 3);\n\t\tstd::vector<int> startList;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; std::cin >> c;\n\t\t\t\tif ('0' <= c && c <= '9') field[i][j] = c - '0';\n\t\t\t\telse if(c == 'X') field[i][j] = CANT_GO;\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tstartList.push_back(j);\n\t\t\t\t}\n\t\t\t\telse if (c == 'T') field[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tstd::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n\t\tbool isOk = false;\n\t\t//??¨start???????????????\n\t\tfor (int i = 0; i < startList.size(); i++) {\n\t\t\tq.push({ startList[i], h - 1, 1, 0, 0, true }); //??????????????????\n\t\t\tq.push({ startList[i] - 1, h - 1, 1, 0, 0, false }); //??????????????????\n\t\t}\n\t\tint minCost = 0;\n\t\twhile (!q.empty() && !isOk) {\n\t\t\tauto node = q.top(); q.pop();\n\t\t\tif ((field[node.y][node.x] == 0 && node.y == 0) || (field[node.y + node.ry][node.x + node.rx] == 0 && node.y + node.ry == 0)) {\n\t\t\t\tisOk = true;\n\t\t\t\tminCost = node.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tif (node.nextR) {\n\t\t\t\t\tnext.rx = dx[i]; //?????´????????????????????????OK?????????????????????????§????\n\t\t\t\t\tnext.ry = dy[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint rx = node.x + node.rx; //????¶???§?¨?\n\t\t\t\t\tint ry = node.y + node.ry;\n\t\t\t\t\tnext.x = rx - dx[i]; //????¶???????????????????????????§?¨?\n\t\t\t\t\tnext.y = ry + dy[i];\n\t\t\t\t\tnext.rx = rx - next.x;//????????§?¨??????????\n\t\t\t\t\tnext.ry = ry - next.y;\n\t\t\t\t}\n\t\t\t\tnext.nextR = !node.nextR;\n\t\t\t\t//check\n\t\t\t\tif (next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\t\tif (next.x + next.rx < 0 || next.x + next.rx >= w || next.y + next.ry < 0 || next.y + next.ry >= h) continue;\n\t\t\t\tif (!next.rx) continue;\n\n\t\t\t\tint cost;\n\t\t\t\tif (node.nextR) {\n\t\t\t\t\tcost = field[next.y + next.ry][next.x + next.rx];\n\t\t\t\t}\n\t\t\t\telse cost = field[next.y][next.x];\n\n\t\t\t\tif (cost < 0 || 9 < cost) continue; //X?????¨???\n\n\t\t\t\tnext.cost += cost;\n\t\t\t\tif (dp[next.nextR][next.y][next.x][next.ry + 2][next.rx - 1] <= next.cost) continue;\n\t\t\t\tdp[next.nextR][next.y][next.x][next.ry + 2][next.rx - 1] = next.cost;\n\t\t\t\t//std::cout << next.x << \", \" << next.y << \", \" << next.x + next.rx << \", \" << next.y + next.ry << \", \" << next.cost << \", \" << next.nextR << std::endl;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tif (isOk) std::cout << minCost << std::endl;\n\t\telse std::cout << -1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  vector<P2> G[2][100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,-1,-2,-1,0,-1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tG[0][i][j].clear();\n\tG[1][i][j].clear();\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'S' || grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(grid[i][j] == 'T')\n\t  ans = min(ans,min(d[0][i][j],d[1][i][j]));\n    if(ans ==INF)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P{\n  int lx,ly;\n  int rx,ry;\n  bool f;                       // f : ツ篠淞右ツ堕ォ(0) ツ債カツ堕ォ(1)\n  int dis;\n  P(int lx,int ly,int rx,int ry, bool f, int dis):lx(lx),ly(ly),rx(rx),ry(ry),f(f),dis(dis) {}\n};\n\nconst bool operator<(const P &a, const P &b) {\n  return a.dis > b.dis;\n}\n\nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n\nint main() {\n  int w,h;\n  while(cin>>w>>h,w||h) {\n    char ba[w][h];\n    priority_queue<P> Q;\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba[x][y];\n        if (ba[x][y] == 'S') {\n          Q.push(P(x,y,x,y,0,0));\n          Q.push(P(x,y,x,y,1,0));\n        }\n      }\n    }\n    int dist[w][h][w][h][2];\n    REP(i,w)REP(j,h)REP(k,w)REP(l,h)REP(m,2)dist[i][j][k][l][m] = INF;\n//    memset(visited,0,sizeof(visited));\n    int res = -1;\n    while(!Q.empty()) {\n      P p = Q.top();\n      Q.pop();\n      if (dist[p.lx][p.ly][p.rx][p.ry][p.f] < p.dis) continue;\n\n      //printf(\"%d,%d,%d,%d\\n\",p.lx,p.ly,p.rx,p.ry);\n      if (ba[p.lx][p.ly] == 'T' || ba[p.rx][p.ry] == 'T') {\n        res = p.dis;\n        break;\n      }\n      REP(k,9) {\n        if (p.f) {                // ツ債カツ堕ォ\n          int xx = p.rx - dx[k];\n          int yy = p.ry + dy[k];\n          if (xx<0||xx>=w||yy<0||yy>=h)continue;\n          //printf(\"ssdfsdf\\n\");\n          if (ba[xx][yy] == 'X') continue;\n          int hoge = 0;\n          if (isdigit(ba[xx][yy])) \n            hoge = ba[xx][yy] - '0';\n          if (dist[xx][yy][p.rx][p.ry][0] > p.dis + hoge) {\n            dist[xx][yy][p.rx][p.ry][0] = p.dis + hoge;\n            Q.push(P(xx,yy,p.rx,p.ry,0,p.dis+hoge));\n          }\n        } else {\n          int xx = p.lx + dx[k];\n          int yy = p.ly + dy[k];\n          if (xx<0||xx>=w||yy<0||yy>=h)continue;\n          if (ba[xx][yy] == 'X') continue;\n          int hoge = 0;\n          if (isdigit(ba[xx][yy])) \n            hoge = ba[xx][yy] - '0';\n          if (dist[p.lx][p.ly][xx][yy][1] > p.dis + hoge) {\n            dist[p.lx][p.ly][xx][yy][1] = p.dis + hoge;\n            Q.push(P(p.lx,p.ly,xx,yy,1,p.dis+hoge));\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint dist[60][30][60][30][2];\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0) return 0;\n    vector<vector<char>> f(h,vector<char>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> f[i][j];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            dist[i][j][k][l][0]=dist[i][j][k][l][1]=INF;\n          }\n        }\n      }\n    }\n    int hx[9]={1,1,2,1,2,3,1,2,1};\n    int hy[9]={2,1,1,0,0,0,-1,-1,-2};\n    priority_queue<pair<int,tuple<int,int,int,int,int>>> dijk;\n    for(int i=0;i<w;i++){\n      if(f[h-1][i]=='S'){\n        dijk.push({0,{h-1,i,h-1,i,0}});\n        dijk.push({0,{h-1,i,h-1,i,1}});\n      }\n    }\n    pair<int,tuple<int,int,int,int,int>> now;\n    int lx,ly,rx,ry,fl,di,nx,ny;\n    int ans=INF;\n    while(!dijk.empty()){\n      now=dijk.top();\n      dijk.pop();\n      ly=get<0>(now.second);\n      lx=get<1>(now.second);\n      ry=get<2>(now.second);\n      rx=get<3>(now.second);\n      fl=get<4>(now.second);\n      di=-now.first;\n      if(dist[ly][lx][ry][rx][fl]==INF){\n        dist[ly][lx][ry][rx][fl]=di;\n        if(fl){\n          for(int i=0;i<9;i++){\n            nx=rx-hx[i];\n            ny=ry+hy[i];\n            if(0<=nx&&nx<w&&0<=ny&&ny<h){\n              if(f[ny][nx]!='X'){\n                if(dist[ny][nx][ry][rx][0]==INF){\n                  if(f[ny][nx]=='T'){\n                    ans=min(ans,di);\n                  }else dijk.push({-di-(f[ny][nx]-'0'),{ny,nx,ry,rx,0}});\n                }\n              }\n            }\n          }\n        }else{\n          for(int i=0;i<9;i++){\n            nx=lx+hx[i];\n            ny=ly+hy[i];\n            if(0<=nx&&nx<w&&0<=ny&&ny<h){\n              if(f[ny][nx]!='X'){\n                if(dist[ly][lx][ny][nx][1]==INF){\n                  if(f[ny][nx]=='T'){\n                    ans=min(ans,di);\n                  }else dijk.push({-di-(f[ny][nx]-'0'),{ly,lx,ny,nx,1}});\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> foot; // x,y\n#define fs first\n#define sc second\n\n#define INF 1e+9\n\nint w,h;\nint board[61][31];\nint used[2][61][31][61][31]; // f, ly, lx, ry, rx\n\nconst int dx[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[9] = { 2, 1, 0,-1,-2, 1, 0,-1, 0};\n\t  \nvector<foot> s;\nset<foot> g;\nstruct state{\n\t  foot l,r;\n\t  int f,c;\n\t  state(int lx, int ly, int rx, int ry, int fl, int co){\n\t\t\tl.fs = lx; l.sc = ly; r.fs = rx; r.sc = ry, f = fl; c = co;\n\t  }\n\t  state(foot le, foot ri, int fl, int co){\n\t\t\tl = le; r = ri; f = fl; c = co;\n\t  }\n\t  bool operator < (const state & tgt) const {\n\t\t\treturn c < tgt.c;\n\t  }\n\t  bool operator > (const state & tgt) const {\n\t\t\treturn c > tgt.c;\n\t  }\n\t  void dump(){\n\t\t\tcout << \"(\" << l.fs << \",\" << l.sc << \"),\";\n\t\t\tcout << \"(\" << r.fs << \",\" << r.sc << \")\";\n\t\t\tcout << \" : \" << f << \", \" << c << endl;\n\t  }\n};\n\nvoid memo(state s){\n\t  used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] = s.c; // ???????????§???????????????????¨???¶\n}\nbool is_used(state s){\n\t  if( used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] == -1) return false; // ??????????¨???????\n\t  return used[s.f][s.l.sc][s.l.fs][s.r.sc][s.r.fs] <= s.c; // ?????£????????¨?????????\n}\nbool valid(state s){\n\t  if(s.r.sc >= h or s.r.sc < 0 or s.r.fs >= w or s.r.fs < 0) return true; // ?£????\n\t  if(s.l.sc >= h or s.l.sc < 0 or s.l.fs >= w or s.l.fs < 0) return true; // ?£????\n\t  if(s.l.fs >= s.r.fs and abs(s.l.fs - s.r.fs) + abs(s.l.sc - s.r.sc) > 3) return true; //????£???????\n\t  if(board[s.r.sc][s.r.fs] < 0) return true; //??????????£?\n\t  if(board[s.l.sc][s.l.fs] < 0) return true; //??????????£?\n\t  return false; // ??§??????\n}\nbool goal(state s){\n\t  if(g.find(s.l) != g.end()) return true; // ????¶??????´??????\n\t  if(g.find(s.r) != g.end()) return true; // ????¶??????´??????\n\t  return false;\n}\n\nint dijk(state st){\n\t  \n\t  priority_queue<state,vector<state>,greater<state> > pq;\n\t  pq.push( st );\n//\t  memset(used,-1,sizeof(used));\n\t  while(pq.size()){\n\t\t\tstate corr = pq.top(); pq.pop();\n//\t\t\tcorr.dump();\n\t\t\tif( valid(corr)   ) continue;\n\t\t\tif( is_used(corr) ) continue;\n\t\t\tif( goal(corr)    ) return corr.c;\n\n\t\t\tmemo(corr); // ??°??????????????¨????????¢\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t  state ns = state(corr.l, corr.r, (corr.f+1)%2, corr.c);\n\t\t\t\t  int cost = 0 ;\n\t\t\t\t  if(corr.f == 0){ // ????¶?????????????\n\t\t\t\t\t\tns.r.fs = corr.l.fs + dx[i];\n\t\t\t\t\t\tns.r.sc = corr.l.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.r.sc][ns.r.fs];\n\t\t\t\t  }\n\t\t\t\t  if(corr.f == 1){ // ????¶?????????????\n\t\t\t\t\t\tns.l.fs = corr.r.fs - dx[i];\n\t\t\t\t\t\tns.l.sc = corr.r.sc - dy[i];\n\t\t\t\t\t\tif(valid(ns)) continue;\n\t\t\t\t\t\tcost = board[ns.l.sc][ns.l.fs];\n\t\t\t\t  }\n\t\t\t\t  ns.c += cost;\n\t\t\t\t  if(is_used(ns)) continue;\n\t\t\t\t  pq.push(ns);\n\t\t\t}\n\t  }\n\t  return -1;\n}\n\nint main(){\n\t  while(1){\n\t\t\tcin >> w >> h;\n\t\t\tif(!w and !h) break;\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\ts.clear(); g.clear();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\t  for(int j=0; j<w; j++){\n\t\t\t\t\t\tstring tmp; cin >> tmp;\n\t\t\t\t\t\tif(tmp == \"S\"){\n\t\t\t\t\t\t\t  s.push_back( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"T\"){\n\t\t\t\t\t\t\t  g.insert( foot(j,i) );\n\t\t\t\t\t\t\t  board[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(tmp == \"X\"){\n\t\t\t\t\t\t\t  board[i][j] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  board[i][j] = stoi(tmp);\n\t\t\t\t  }\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0; i<s.size(); i++){\n\t\t\t\t  foot dummy = foot(INF,INF);\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(s[i],foot(s[i].fs+dx[i], s[i].sc-dy[i]),0,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs+dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st0 = state(s[i], dummy, 0, 0);\n\t\t\t\t  for(int i=0; i<9; i++){\n\t\t\t\t\t\tstate hoge = state(foot(s[i].fs-dx[i], s[i].sc-dy[i]), s[i], 0,0);\n\t\t\t\t\t\tif( !valid(hoge) ) {\n\t\t\t\t\t\t\t  dummy = foot(s[i].fs-dx[i], s[i].sc-dy[i]);\n\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  state st1 = state(dummy, s[i], 1, 0);\n\t\t\t\t  int tmp0 = dijk(st0);\n\t\t\t\t  int tmp1 = dijk(st1);\n\t\t\t\t  if(tmp0 != -1)\n\t\t\t\t\t\tans = min(ans, tmp0);\n\t\t\t\t  if(tmp1 != -1)\n\t\t\t\t\t\tans = min(ans, tmp1);\n\t\t\t}\n\t\t\tif(ans == INF) cout << -1 << endl;\n\t\t\telse cout << ans << endl;\n\t  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint xv[]={1,1,1,1,1,2,2,2,3},yv[]={2,1,0,-1,-2,1,0,-1,0};\n\nvoid solve(int w,int h){\n    char in;\n    bool l;\n    int r,c;\n    stack<pair<bool,pair<int,int>>> q;\n    pair<int,int> n;\n    vector<vector<int>> mp=vector<vector<int>>(h+4,vector<int>(w+6,-1));\n    vector<vector<vector<int>>> ma(h+4,vector<vector<int>>(w+6,vector<int>(2,INT_MAX/2)));\n    set<pair<int,int>> sset,tset;\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin>>in;\n            if(in=='X')mp[i+1][j+2]=-1;\n            else if(in=='S'){\n                mp[i+1][j+2]=0;\n                sset.insert(make_pair(i+1,j+2));\n            }\n            else if(in=='T'){\n                mp[i+1][j+2]=0;\n                tset.insert(make_pair(i+1,j+2));\n            }\n            else{\n                mp[i+1][j+2]=in-'0';\n            }\n        }\n    }\n    for(pair<int,int> x:sset){\n        q.push(make_pair(true,make_pair(x.first,x.second)));\n        q.push(make_pair(false,make_pair(x.first,x.second)));\n        ma[x.first][x.second][0]=0;\n        ma[x.first][x.second][1]=0;\n    }\n    while(!q.empty()){\n        l=q.pop().first;n=q.front().second;q.pop();\n        for(int i=0;i<9;i++){\n            r=n.first+yv[i];\n            c=n.second+(l?xv[i]:-1*xv[i]);\n            if(mp[r][c]!=-1&&ma[n.first][n.second][!l]+mp[r][c]<ma[r][c][l]){\n                ma[r][c][l]=ma[n.first][n.second][!l]+mp[r][c];\n                q.push(make_pair(!l,make_pair(r,c)));\n            }\n        }\n    }\n    int mini=INT_MAX/2;\n    for(pair<int,int> x:tset){\n        mini=min(mini,ma[x.first][x.second][0]);\n        mini=min(mini,ma[x.first][x.second][1]);\n    }\n    cout<<(mini!=INT_MAX/2?mini:-1)<<endl;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        solve(w,h);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cctype>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\tque.push(make_tuple(sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<0>(que.top());\n\t\tint y = get<1>(que.top());\n\t\tint s = get<2>(que.top());\n\n\t\tque.pop();\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <mutex>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> P;\n\nstruct position {\n\tint i, j;\n\n\tposition(int i, int j) :i(i), j(j){\n\t}\n};\n\nstruct edge {\n\tint to, cost;\n\n\tedge(int to, int cost) :to(to), cost(cost){\n\t};\n};\n\nconst int MAX_V = 3600;\nconst int INF = 9999999;\n\nint dxl[] = {1, 1, 1, 1, 1, 2, 2, 2, 3}, dyl[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nint dxr[] = {-1, -1, -1, -1, -1, -2, -2, -2, -3}, dyr[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint d[MAX_V];\nint V;\nvector<edge> G[MAX_V];\n\nint h, w;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint toV(int i, int j, int foot){\n\treturn 2 * (i * w + j) + foot;\n}\n\nvoid calc(int s){\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (auto&& e : G[v]) {\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tauto s = vvc(h, vc(w, 0));\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> s[i][j];\n\n\t\tV = w * h * 2;\n\n\t\tauto start = vector<position>();\n\t\tauto goal = vector<position>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') start.push_back(position(i, j));\n\t\t\t\telse if (s[i][j] == 'T') goal.push_back(position(i, j));\n\t\t\t}\n\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t// left foot\n\t\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\t\tint ni = i + dyl[k], nj = j + dxl[k];\n\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\tif ('1' <= s[ni][nj] && s[ni][nj] <= '9')\n\t\t\t\t\t\tG[toV(i, j, 0)].push_back(edge(toV(ni, nj, 1), s[ni][nj] - '0'));\n\t\t\t\t\telse if (s[ni][nj] == 'S' || s[ni][nj] == 'T')\n\t\t\t\t\t\tG[toV(i, j, 0)].push_back(edge(toV(ni, nj, 1), 0));\n\t\t\t\t}\n\t\t\t\t// right foot\n\t\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\t\tint ni = i + dyr[k], nj = j + dxr[k];\n\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\tif ('1' <= s[ni][nj] && s[ni][nj] <= '9')\n\t\t\t\t\t\tG[toV(i, j, 1)].push_back(edge(toV(ni, nj, 0), s[ni][nj] - '0'));\n\t\t\t\t\telse if (s[ni][nj] == 'S' || s[ni][nj] == 'T')\n\t\t\t\t\t\tG[toV(i, j, 1)].push_back(edge(toV(ni, nj, 0), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (auto&& sp : start) {\n\t\t\tcalc(toV(sp.i, sp.j, 0));\n\t\t\tfor (auto&& gp : goal) {\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 0)]);\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 1)]);\n\t\t\t}\n\t\t\tcalc(toV(sp.i, sp.j, 1));\n\t\t\tfor (auto&& gp : goal) {\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 0)]);\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 1)]);\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Foot{\n\tLeft,\n\tRight,\n};\n\nint H,W;\nint***** min_Time;\n\nint diff_row_right[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_right[9] = {1,1,2,1,2,3,1,2,1};\nint diff_row_left[9] = {-2,-1,-1,0,0,0,1,1,2},diff_col_left[9] = {-1,-2,-1,-3,-2,-1,-2,-1,-1};\n\nstruct Info{\n\tInfo(){\n\t\tleft_row = left_col = right_row = right_col = time = 0;\n\t\tfoot = Left;\n\t}\n\n\tInfo(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn time < arg.time;\n\t};\n\n\tvoid set(int arg_left_row,int arg_left_col,int arg_right_row,int arg_right_col,int arg_time,Foot arg_foot){\n\t\tleft_row = arg_left_row;\n\t\tleft_col = arg_left_col;\n\t\tright_row = arg_right_row;\n\t\tright_col = arg_right_col;\n\t\ttime = arg_time;\n\t\tfoot = arg_foot;\n\t}\n\tint left_row,left_col,right_row,right_col,time;\n\tFoot foot;\n};\n\nstruct Cell{\n\tCell(){\n\t\trow = col = 0;\n\t}\n\tCell(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\n\tbool operator<(const struct Cell &arg) const{\n\t\t\treturn col < arg.col;\n\t};\n\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\tmin_Time[a][b][c][d][e] = BIG_NUM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Cell> V;\n\n\tchar map[H][W+1];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%s\",&map[i][k]);\n\t\t\tif(map[i][k] == 'S'){\n\t\t\t\tV.push_back(Cell(i,k));\n\t\t\t\tmap[i][k] = '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\n\tint first_left_row,first_left_col,first_right_row,first_right_col,add_time;\n\n\tfor(int a = 0; a < V.size(); a++){\n\n\t\tfirst_left_row = V[a].row;\n\t\tfirst_left_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_right_row = first_left_row + diff_row_right[i];\n\t\t\tfirst_right_col = first_left_col + diff_col_right[i];\n\n\t\t\tif(rangeCheck(first_right_row,first_right_col) == true && map[first_right_row][first_right_col] != 'X'){\n\t\t\t\tif(map[first_right_row][first_right_col] >= '0' && map[first_right_row][first_right_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_right_row][first_right_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Right] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Right));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfirst_right_row = V[a].row;\n\t\tfirst_right_col = V[a].col;\n\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfirst_left_row = first_right_row + diff_row_left[i];\n\t\t\tfirst_left_col = first_right_col + diff_col_left[i];\n\n\t\t\tif(rangeCheck(first_left_row,first_left_col) == true && map[first_left_row][first_left_col] != 'X'){\n\t\t\t\tif(map[first_left_row][first_left_col] >= '0' && map[first_left_row][first_left_col] <= '9'){\n\t\t\t\t\tadd_time = map[first_left_row][first_left_col] - '0';\n\t\t\t\t}else{\n\t\t\t\t\tadd_time = 0;\n\t\t\t\t}\n\t\t\t\tif(min_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] > add_time){\n\t\t\t\t\tmin_Time[first_left_row][first_left_col][first_right_row][first_right_col][Left] = add_time;\n\t\t\t\t\tQ.push(Info(first_left_row,first_left_col,first_right_row,first_right_col,add_time,Left));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM,next_left_row,next_left_col,next_right_row,next_right_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(map[Q.top().left_row][Q.top().left_col] == 'T' || map[Q.top().right_row][Q.top().right_col] == 'T'){\n\t\t\tans = min(ans,Q.top().time);\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > min_Time[Q.top().left_row][Q.top().left_col][Q.top().right_row][Q.top().right_col][Q.top().foot] || Q.top().time > ans){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(Q.top().foot == Left){\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_right_row = Q.top().left_row + diff_row_right[i];\n\t\t\t\t\tnext_right_col = Q.top().left_col + diff_col_right[i];\n\n\t\t\t\t\tif(rangeCheck(next_right_row,next_right_col) == true && map[next_right_row][next_right_col] != 'X'){\n\t\t\t\t\t\tif(map[next_right_row][next_right_col] >= '0' && map[next_right_row][next_right_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_right_row][next_right_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[Q.top().left_row][Q.top().left_col][next_right_row][next_right_col][Right] > Q.top().time+add_time){\n\t\t\t\t\t\t\tmin_Time[Q.top().left_row][Q.top().left_col][next_right_row][next_right_col][Right] = Q.top().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(Q.top().left_row,Q.top().left_col,next_right_row,next_right_col,Q.top().time+add_time,Right));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //Q.top().foot == Right\n\t\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\t\tnext_left_row = Q.top().right_row + diff_row_left[i];\n\t\t\t\t\tnext_left_col = Q.top().right_col + diff_col_left[i];\n\n\t\t\t\t\tif(rangeCheck(next_left_row,next_left_col) == true && map[next_left_row][next_left_col] != 'X'){\n\t\t\t\t\t\tif(map[next_left_row][next_left_col] >= '0' && map[next_left_row][next_left_col] <= '9'){\n\t\t\t\t\t\t\tadd_time = map[next_left_row][next_left_col]-'0';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd_time = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(min_Time[next_left_row][next_left_col][Q.top().right_row][Q.top().right_col][Left] > Q.top().time+add_time){\n\t\t\t\t\t\t\tmin_Time[next_left_row][next_left_col][Q.top().right_row][Q.top().right_col][Left] = Q.top().time+add_time;\n\t\t\t\t\t\t\tQ.push(Info(next_left_row,next_left_col,Q.top().right_row,Q.top().right_col,Q.top().time+add_time,Left));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_Time = new int****[60];\n\tfor(int i = 0; i < 60; i++){\n\t\tmin_Time[i] = new int***[30];\n\t\tfor(int k = 0; k < 30; k++){\n\t\t\tmin_Time[i][k] = new int**[60];\n\t\t\tfor(int p = 0; p < 60; p++){\n\t\t\t\tmin_Time[i][k][p] = new int*[30];\n\t\t\t\tfor(int q = 0; q < 30; q++)min_Time[i][k][p][q] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define sz(c) ((int)c.size())\n#define all(c) c.begin(), c.end()\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nconst int INF = 1e9;\ntemplate <class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> using heap = priority_queue<T, vector<T>, greater<T>>;\n\nint DY[2][9] = {\n    {-2, -1, -1, 0, 0, 0, 1, 1, 2},\n    {-2, -1, -1, 0, 0, 0, 1, 1, 2},\n};\nint DX[2][9] = {\n    {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    {-1, -1, -2, -1, -2, -3, -1, -2, -1},\n};\n\nbool inrange(int x, int l, int r) {\n    return l <= x and x < r;\n}\n\nvoid solve(int W, int H) {\n    vvi A(H, vi(W));\n    rep(i, 0, H) rep(j, 0, W) {\n        char x;\n        cin >> x;\n        A[i][j] = x;\n    }\n\n    vector<vvi> dist(H, vvi(W, vi(2, INF)));\n    using dijkstra_state = tuple<int, int, int, int>;\n    heap<dijkstra_state> hp;\n    rep(i, 0, H) rep(j, 0, W) if (A[i][j] == 'S') {\n        dist[i][j][0] = dist[i][j][1] = 0;\n        hp.push(dijkstra_state(0, i, j, 0));\n        hp.push(dijkstra_state(0, i, j, 1));\n    }\n    while (sz(hp)) {\n        int c, y, x, foot;\n        tie(c, y, x, foot) = hp.top(); hp.pop();\n        if (c > dist[y][x][foot]) continue;\n        rep(step, 0, 9) {\n            int yy = y + DY[foot][step];\n            int xx = x + DX[foot][step];\n            if (!(inrange(yy, 0, H) && inrange(xx, 0, W))) continue;\n            if (A[yy][xx] == 'X') continue;\n\n            int cost = A[yy][xx] - '0';\n            if (A[yy][xx] == 'S' || A[yy][xx] == 'T') cost = 0;\n            if (chmin(dist[yy][xx][foot ^ 1], c + cost)) {\n                hp.push(dijkstra_state(dist[yy][xx][foot ^ 1], yy, xx, foot ^ 1));\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i, 0, H) rep(j, 0, W) if (A[i][j] == 'T') {\n        chmin(ans, dist[i][j][0]);\n        chmin(ans, dist[i][j][1]);\n    }\n    if (ans == INF) ans = -1;\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0 && h ==0 ) break;\n        solve(w, h);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define WMAX 30\n#define HMAX 60\n\nint W,H;\nvector<pi> F;\n\nchar S[HMAX][WMAX];\nint B[HMAX][WMAX][2];\n\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d%d\",&W,&H);\n      if(W==0&&H==0)break;\n      memset(B, -1, sizeof(B));\n      F.clear();\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      cin>>S[i][j];\n\t      if(S[i][j]=='S')\n\t\t{\n\t\t  F.pb(pi(i,j));\n\t\t  B[i][j][0]=0;\n\t\t  B[i][j][1]=0;\n\t\t}\n\t    }\n\t}\n      queue<pi> Q;\n      queue<bool> R;\n      rep(i,F.size())\n\t{\n\t  Q.push(F[i]);\n\t  Q.push(F[i]);\n\t  R.push(0);\n\t  R.push(1);\n\t}\n\n      int M = 114514;\n      while(!Q.empty())\n\t{\n\t  int h=Q.front().first;\n\t  int w=Q.front().second;\n\t  Q.pop();\n\t  bool r=R.front();\n\t  R.pop();\n\n\t  if(S[h][w]=='T')\n\t    {\n\t      M=min(B[h][w][r], M);\n\t      continue;\n\t    }\n\t  repi(i,h-2,h+3)\n\t    {\n\t      \n\t      repi(j,w-3,w+4)\n\t\t{\n\t\t  if(i<0||i>=H||j<0||j>=W)continue;\n\t\t  if(r && j<=w)continue;\n\t\t  if(!r && w<=j)continue;\n\t\t  if(abs(h-i)+abs(w-j)>3)continue;\n\t\t  if(S[i][j]=='X' || S[i][j]=='S')continue;\n\t\t  int dis;\n\t\t  if(S[i][j]=='T')dis=0;\n\t\t  else dis = S[i][j] -'0';\n\t\t  if(B[i][j][!r]!=-1 && B[i][j][!r]<B[h][w][r]+dis)continue;\n\t\t  B[i][j][!r]=B[h][w][r]+dis;\n\t\t  Q.push(pi(i,j));\n\t\t  R.push(!r);\n\t\t}\n\t    }\n\t    \n\t  \n\t}\n      /* rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      printf(\"%d \",min(B[i][j][0],B[i][j][1]));\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      if(M==114514)M=-1;\n      printf(\"%d\\n\",M);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nclass state{\npublic:\n\tint foot,x,y,cost;\n\tstate(int _f, int _x, int _y, int _c){\n\t\tfoot=_f; x=_x; y=_y; cost=_c;\n\t}\n\tbool operator<(const state& tmp)const{\n\t\treturn cost>tmp.cost;\n\t}\n};\n\nint dx[2][9];\nint dy[2][9];\n\nvoid init(){\n\tint k=0;\n\tfor(int i=1; i<=3; i++){\n\t\tfor(int j=-2; j<=2; j++)if( i+abs(j)<=3 ){\n\t\t\tdx[0][k] = i; dy[0][k] = j;\n\t\t\tdx[1][k] = -i; dy[1][k] = j;\n\t\t\tk++;\n\t\t}\n\t}\n}\n\nint atai(char c){\n\tif( '0'<=c && c<='9' ) return c-'0';\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tchar field[64][64];\n\tint memo[2][64][64];\n\tinit();\n\t// 0 = right foot  , 1 = left foot\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\trep(i,64)rep(j,64)memo[0][i][j]=memo[1][i][j]=INT_MAX;\n\t\trep(i,h)rep(j,w){\n\t\t\tscanf(\" %c \",&field[i][j]);\n\t\t}\n\t\tpriority_queue<state> q;\n\t\trep(i,w)if( field[h-1][i]=='S' ){\n\t\t\tq.push(state(0,i,h-1,0));\n\t\t\tq.push(state(1,i,h-1,0));\n\t\t\tmemo[1][h-1][i] = memo[0][h-1][i] = 0;\n\t\t}\n\t\tint karikari = INT_MAX;\n\t\twhile( !q.empty() ){\n\t\t\tint nx = q.top().x;\n\t\t\tint ny = q.top().y;\n\t\t\tint nf = q.top().foot;\n\t\t\tint nc = q.top().cost;\n\t\t\tif( karikari<nc ) break;\n\t\t\t//printf(\"nc:%d\\n\",nc);\n\t\t\tq.pop();\n\t\t\trep(k,9){\n\t\t\t\tint tx = nx + dx[nf][k];\n\t\t\t\tint ty = ny + dy[nf][k];\n\t\t\t\tint next = (nf+1)%2;\n\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='X' )continue;\n\t\t\t\tif( memo[next][ty][tx] > nc + atai(field[ty][tx]) ){\n\t\t\t\t\tmemo[next][ty][tx] = nc + atai(field[ty][tx]);\n\t\t\t\t\tq.push(state(next, tx, ty, nc+atai(field[ty][tx])));\n\t\t\t\t\tif( field[ty][tx]=='T' ){\n\t\t\t\t\t\tkarikari = min(karikari,memo[next][ty][tx]);\n\t\t\t\t\t\t//printf(\"karikari:%d\\n\",karikari);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\trep(i,w)if( field[0][i]=='T' ){\n\t\t\tans = min(ans, min(memo[0][0][i],memo[1][0][i]));\n\t\t}\n\t\tprintf(\"%d\\n\",ans==INT_MAX?-1:ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint w, h;\nint graph[60][30];\n\nconst int dx[9] = { 1, 1, 1,  1,  1, 2, 2,  2, 3};\nconst int dy[9] = { 2, 1, 0, -1, -2, 1, 0, -1, 0};\n\nint get_cost(int y, int x)\n{\n    return graph[y][x];\n}\n\nint c2i(char c)\n{\n\tif(isdigit(c))\n\t{\n\t\treturn (int)c - 48;\n\t}\n\tif(c == 'S')return 0;\n\tif(c == 'T')return -10;\n\tif(c == 'X')return INF;\n\n\tcout << \"????????? : \" << c << endl;\n\treturn 100;\n}\n\nbool isValid(int y, int x)\n{\n\tbool ret = true;\n\tret &= (y < h && y >= 0);\n\tret &= (x < w && x >= 0);\n\tif(ret)ret &= (graph[y][x] != INF);\n\treturn ret;\n}\n\n// n?¬??????????????????????????¬¬????????°???????????????????????¨???????????????????????????\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nclass Path\n{\npublic:\n    Path(bool _is_right, int _x, int _y, int _cost)\n    {\n\t\tis_right = _is_right;\n        x = _x;\n\t\ty = _y;\n        cost = _cost;\n    }\n\tbool is_right;\n    int x, y;\n    int cost;\n    bool operator < (const Path& other) const //??????const???????????¨priority_queue??§??¨???????????????\n    {\n        return this->cost < other.cost;\n    }\n    bool operator > (const Path& other) const //??????const???????????¨priority_queue??§??¨???????????????\n    {\n        return !(*this < other);\n    }\n};\n\nint main()\n{\n\n\twhile(true)\n\t{\n\t\tcin >> w >> h;\n\t\tif(w == 0)break;\n\n\t\tfor(int _h = 0; _h < h; ++_h)\n\t\t{\n\t\t\tfor(int _w = 0; _w < w; ++_w)\n\t\t\t{\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tgraph[_h][_w] = c2i(tmp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int _h = 0; _h < h; ++_h)\n\t\t{\n\t\t\tfor(int _w = 0; _w < w; ++_w)\n\t\t\t{\n\t\t\t\tif(graph[_h][_w] != INF)\n\t\t\t\tcout << graph[_h][_w] << \" \";\n\t\t\t\telse cout << \"X \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t//*/\n\n\t    int start = 0;\n\n    \t//??????????????????????°??????????\n\t\t//0:???   1:???\n    \tint min_cost[2][60][30];\n    \tFill(min_cost, INF);\n\n\t\tpriority_queue< Path, vector<Path>, greater<Path> > que;\n\n\n    \tfor(int _w = 0; _w < w; ++_w)\n\t\t{\n\t\t\tif(graph[h - 1][_w]\t== 0)\n\t\t\t{\n\t\t\t\tmin_cost[0][h-1][_w] = min_cost[1][h-1][_w] = 0;\n\t\t    \tque.push( Path(0, _w, h-1, 0) );\n\t\t    \tque.push( Path(1, _w, h-1, 0) );\n\t\t\t}\n\t\t}\n\n\t\tint answer = INF;\n\n\t    while(!que.empty())\n\t    {\n\t        Path now = que.top();\n\t        que.pop();\n\n    \t    //???????????????????°????????????????????????°?????????\n    \t    if(min_cost[now.is_right][now.y][now.x] < now.cost)continue;\n\n\n\t\t\tfor(int i = 0; i < 9; ++i)\n\t\t\t{\n\t\t\t\t//?§??????§???????????£???????????????\n\t\t\t\tint next_x = now.x + dx[i] * (now.is_right ? -1 : 1);\n\t\t\t\tint next_y = now.y + dy[i];\n\n\t\t\t\tif(!isValid(next_y, next_x))continue;\n\n\t\t\t\tif(graph[next_y][next_x] == -10)\n\t\t\t\t{\n\t\t\t\t\tanswer = min(answer, now.cost);\n\t\t\t\t\t//cout << now.x << \" \" << now.y << \" \" << answer << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n \n    \t        //??????????????????????????????i????????????????????????????????????min_cost??????????°????????????°??´??°\n       \t    \tint next_cost = now.cost + get_cost(next_y, next_x);\n\t    \t    if(min_cost[!now.is_right][next_y][next_x] > next_cost)\n   \t\t        {\n   \t    \t \t    min_cost[!now.is_right][next_y][next_x] = next_cost;\n        \t\t    que.push( Path(!now.is_right, next_x, next_y, next_cost) );\n\t\t\t\t}\n\t        }\n\t    }\n\t\tcout << ((answer == INF) ? -1 : answer) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> Pi;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define fi first\n#define se second\n\ntemplate<typename T> inline bool chmax(T &a, T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T> ostream& operator<<(ostream& s,const complex<T>& d) {return s<<\"(\"<<d.real()<<\", \"<<d.imag()<< \")\";}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const pair<T1,T2>& d) {return s<<\"(\"<<d.first<<\", \"<<d.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d){int len=d.size();rep(i,len){s<<d[i];if(i<len-1) s<<\" \";}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const vector<vector<T>>& d){int len=d.size();rep(i,len){s<<d[i]<<endl;}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const set<T>& v){s<<\"{ \";for(auto itr=v.begin();itr!=v.end();++itr) {if (itr!=v.begin()) {s<< \", \";}s<<(*itr);}s<<\" }\";return s;}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const map<T1,T2>& m){s<<\"{\"<<endl;for(auto itr=m.begin();itr!=m.end();++itr){s<<\" \"<<(*itr).first<<\" : \"<<(*itr).second<<endl;}s<<\"}\"<<endl;return s;}\n\nconst ll mod=1e9+7;\nconst ll inf=1e17;\nconst int INF=1e9;\nconst double PI=acos(-1);\nconst double EPS=1e-10;\n\nint dist[100][100][2];\n\nstruct state{\n\tint d,x,y,flag;\n};\n\nbool operator>(const state& a,const state& b){\n    return a.d>b.d;\n}\n\nint main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\twhile(true){\n\t\tint h,w;\n\t\tcin>>w>>h;\n\t\tif(h==0 && w==0) return 0;\n\t\tvector<vector<char>> g(h,vector<char>(w));\n\t\trep(i,h)rep(j,w) cin>>g[i][j];\n\t\tauto check=[&](int x,int y){\n\t\t\treturn (0<=x && x<h && 0<=y && y<w && g[x][y]!='X');\n\t\t};\n\t\tint ans=INF;\n\t\trep(st,w){\n\t\t\tif(g[h-1][st]!='S') continue;\n\t\t\trep(ii,2){\n\t\t\t\trep(i,100)rep(j,100)rep(k,2) dist[i][j][k]=INF;\n\t\t\t\tpriority_queue<state,vector<state>,greater<state>> que;\n\t\t\t\tdist[h-1][st][ii]=0;\n\t\t\t\tque.push({0,h-1,st,ii});\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tauto now=que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(dist[now.x][now.y][now.flag]<now.d) continue;\n\t\t\t\t\tint x=now.x,y=now.y;\n\t\t\t\t\tFOR(j,1,4){\n\t\t\t\t\t\tfor(int i=j-3;i<=3-j;i++){\n\t\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\t\tif(now.flag){//次は右足を動かす\n\t\t\t\t\t\t\t\tnx=x+i,ny=y+j;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tnx=x+i,ny=y-j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!check(nx,ny)) continue;\n\t\t\t\t\t\t\tint nd;\n\t\t\t\t\t\t\tif(g[nx][ny]!='T') nd=g[nx][ny]-'0';\n\t\t\t\t\t\t\telse nd=0;\n\t\t\t\t\t\t\tif(chmin(dist[nx][ny][!now.flag],now.d+nd)){\n\t\t\t\t\t\t\t\tque.push({now.d+nd,nx,ny,!now.flag});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(en,w){\n\t\t\t\t\tif(g[0][en]!='T') continue;\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tchmin(ans,dist[0][en][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans!=INF) cout<<ans<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint ijk[61][30][61][30][2];//left,right... 0:last-left 1:last-right\nbool v[61][30][61][30][2];\nint map[60][30];\nint dx[]={2,1,1,0,0,0,-1,-1,-2};\nint dy[]={1,1,2,1,2,3,1,2,1};\nchar str[2];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\tif(str[0]=='X')map[i][j]=-1;\n\t\t\t\telse if(str[0]=='S'||str[0]=='T')map[i][j]=0;\n\t\t\t\telse map[i][j]=str[0]-'0';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tfor(int k=0;k<a;k++)\n\t\t\t\t\tfor(int l=0;l<b;l++){\n\t\t\t\t\t\tijk[i][j][k][l][0]=ijk[i][j][k][l][1]=-1;\n\t\t\t\t\t\tv[i][j][k][l][0]=v[i][j][k][l][1]=false;\n\t\t\t\t\t}\n\t\tpriority_queue<pair<pair<int,int>,pair<pair<int,int > ,pair<int,int> > > >Q;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(map[a-1][i]==0){\n\t\t\t\tijk[a-1][i][0][0][0]=0;\n\t\t\t\tQ.push(make_pair(make_pair(0,0),make_pair(make_pair(a-1,i),make_pair(0,0))));\n\t\t\t\tijk[0][0][a-1][i][1]=0;\n\t\t\t\tQ.push(make_pair(make_pair(0,1),make_pair(make_pair(0,0),make_pair(a-1,i))));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first.first;\n\t\t\tint last=Q.top().first.second;\n\t\t\tint Lrow=Q.top().second.first.first;\n\t\t\tint Lcol=Q.top().second.first.second;\n\t\t\tint Rrow=Q.top().second.second.first;\n\t\t\tint Rcol=Q.top().second.second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[Lrow][Lcol][Rrow][Rcol][last])continue;\n\t\t\tv[Lrow][Lcol][Rrow][Rcol][last]=true;\n\t\t\tif(!last){\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tif(0<=Lrow+dx[i]&&Lrow+dx[i]<a&&Lcol+dy[i]<b&&~map[Lrow+dx[i]][Lcol+dy[i]]&&\n\t\t\t\t\t\t(ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]==-1||ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]>cost+map[Lrow+dx[i]][Lcol+dy[i]])){\n\t\t\t\t\t\tijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]=cost+map[Lrow+dx[i]][Lcol+dy[i]];\n\t\t\t\t\t\tQ.push(make_pair(make_pair(-ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1],1),make_pair(make_pair(Lrow,Lcol),make_pair(Lrow+dx[i],Lcol+dy[i]))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tif(0<=Rrow+dx[i]&&Rrow+dx[i]<a&&Rcol-dy[i]>=0&&~map[Rrow+dx[i]][Rcol-dy[i]]&&\n\t\t\t\t\t\t(ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]==-1||ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]>cost+map[Rrow+dx[i]][Rcol-dy[i]])){\n\t\t\t\t\t\tijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]=cost+map[Rrow+dx[i]][Rcol-dy[i]];\n\t\t\t\t\t\tQ.push(make_pair(make_pair(-ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0],0),make_pair(make_pair(Rrow+dx[i],Rcol-dy[i]),make_pair(Rrow,Rcol))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\t\tif(~ijk[0][i][j][k][0])ret=min(ret,ijk[0][i][j][k][0]);\n\t\t\t\t\t\tif(~ijk[j][k][0][i][1])ret=min(ret,ijk[j][k][0][i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret==99999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\nll dp[65][35][3];\nint main() {\n\tint w, h;\n\tint dx[9] = { 1,1,2,1,2,3,1,2,1 }, dy[9] = { -2,-1,-1,0,0,0,1,1,2 };\n\tchar s[65][35];\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tdp[i][j][0] = dp[i][j][1] = 0LL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto isOutOfRange = [] (int x, int y, int h, int w){\n\t\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t\t};\n\t\tauto cost = [&](int x, int y) {\n\t\t\tif (s[y][x] == 'X') return INF;\n\t\t\tif (s[y][x] == 'S') return INF;\n\t\t\tif (s[y][x] == 'T') return 0LL;\n\t\t\treturn (ll)s[y][x] - '0';\n\t\t};\n\t\tfor (int _ = 0; _ < 1800*10; _++) {\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int now = 0; now < 2; now++) {\n\t\t\t\t\t\tif (dp[y][x][now] == INF) continue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + (now==0?dx[i]:-dx[i]), ny = y + dy[i], nxt = (now + 1) % 2;\n\t\t\t\t\t\t\tif (isOutOfRange(nx, ny, h, w) || s[ny][nx] == 'X') continue;\n\t\t\t\t\t\t\tdp[ny][nx][nxt] = min(dp[ny][nx][nxt], dp[y][x][now] + cost(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcout << \"(\" << (dp[i][j][0]==INF?-1:dp[i][j][0]) << \", \" << (dp[i][j][1]==INF?-1:dp[i][j][1])<< \")\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tll ans = INF;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] != 'T') continue;\n\t\t\t\tans = min({ ans, dp[i][j][0], dp[i][j][1] });\n\t\t\t}\n\t\t}\n\t\tif (ans == INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[60][30], buf[2];\nint d[60][30][60][30][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tint i = 0;\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 32\n\ntypedef long long ll;\nconst int dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nconst int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nstruct edge {\n    int x, y, cost;\n};\n\nstruct state {\n    int x, y, all_cost, lr;\n};\n\nint w, h;\nchar field[MAXH][MAXW];\n\nint dijkstra(void) {\n    int d[MAXH][MAXW][2];\n    for (int i = 0; i < h; i++) \n        for (int j = 0; j < w; j++)\n            for (int k = 0; k < 2; k++) \n                d[i][j][k] = INF;\n    state s;\n    queue<state> que;\n    s.y = h-1; s.all_cost = 0;\n    for (int i = 0; i < w; i++) {\n        if (field[h-1][i] == 'S') {\n            d[h-1][i][0] = d[h-1][i][1] = 0;\n            s.x = i; s.lr = 0; que.push(s); s.lr = 1; que.push(s);\n        }\n    }\n    while (!que.empty()) {\n        state now = que.front(); que.pop();\n        if (d[now.y][now.x][now.lr] < now.all_cost || field[now.y][now.x] == 'T') continue;\n        if (now.lr == 0) { // 左の場合\n            for (int i = 0; i < 9; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'X') {\n                    int all_cost;\n                    if (field[ny][nx] == 'T' || field[ny][nx] == 'S') {\n                        all_cost = now.all_cost;\n                    } else {\n                        all_cost = now.all_cost + (int)(field[ny][nx] - '0');\n                    }\n                    if (d[ny][nx][1] > all_cost) {\n                        d[ny][nx][1] = all_cost;\n                        state st; st.x = nx; st.y = ny; st.all_cost = all_cost; st.lr = 1;\n                        que.push(st);\n                    }\n                }\n            }\n        }\n        else { // 右の場合\n            for (int i = 0; i < 9; i++) {\n                int nx = now.x - dx[i];\n                int ny = now.y + dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] != 'x') {\n                    int all_cost;\n                    if (field[ny][nx] == 'T' || field[ny][nx] == 'S') {\n                        all_cost = now.all_cost;\n                    } else {\n                        all_cost = now.all_cost + (int)(field[ny][nx] - '0');\n                    }\n                    if (d[ny][nx][0] > all_cost) {\n                        d[ny][nx][0] = all_cost;\n                        state st; st.x = nx; st.y = ny; st.all_cost = all_cost; st.lr = 0;\n                        que.push(st);\n                    }\n                }\n            }\n        }\n    }\n    int ret = INF;\n    for (int i = 0; i < w; i++) {\n        if (field[0][i] == 'T') {\n            for (int j = 0; j < 2; j++) {\n                ret = min(ret, d[0][i][j]);\n            }\n        }\n    }\n    if (ret < INF) return ret;\n    else return -1;\n}\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        cout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<bool,PP> S;\n\n#define fir first\n#define sec second\n\nchar cmap[100][100];\nint w,h;\n\nbool chk(int x, int y) {\n    return x>=0 && y>=0 && x<w && y<h;\n}\nbool chk2(int lx, int ly, int rx, int ry) {\n    return abs(lx-rx) + abs(ly-ry) <= 3;\n}\nint c2c(char c) { // char 2 cost\n    switch(c) {\n        case 'S':\n            return 0;\n            break;\n        case 'X':\n            return 100000;\n            break;\n        case 'T':\n            return 0;\n            break;\n        default:\n            return  c - '0';\n            break;\n    }\n}\n\n\nint main(void) {\n    while(true) {\n        int res;\n        map<S,int> cost;\n\n        scanf(\"%d%d\",&w,&h);\n        if(!w) break;\n\n        memset(cmap, 0, sizeof(cmap));\n\n        for(int j=0; j<h; j++)\n            for(int i=0; i<w; i++) {\n                char in[2];\n                scanf(\"%s\",in);\n                cmap[i][j] = in[0];\n            }\n\n        priority_queue<pair<int,S> > q;\n        q.push(pair<int,S>(0,S(0,PP(P(0,h-1),P(1,h-1)))));\n\n        res = 1000000;\n        while(!q.empty()) {\n            int d = q.top().fir;\n            S stat = q.top().sec;\n            q.pop();\n            printf(\":%d\\n\",d);\n\n            if(cost[stat])\n                if(cost[stat]<=d) continue;\n            cost[stat] = d;\n\n            int lx = stat.sec.fir.fir;\n            int ly = stat.sec.fir.sec;\n            int rx = stat.sec.sec.fir;\n            int ry = stat.sec.sec.sec;\n\n            if(cmap[lx][ly] == 'T' || cmap[rx][ry] == 'T') {\n                res = min(d,res);\n                goto RES;\n            }\n\n            if(stat.fir) { // right foot moved last\n                for(int dx=-5; dx<=5; dx++)\n                    for(int dy=-5; dy<=5; dy++) {\n                        if(!chk(lx+dx, ly+dy)) continue;\n                        if(!chk2(lx+dx,ly+dy,rx,ry)) continue;\n                        if(lx>=rx) continue;\n\n                        int c = c2c(cmap[lx+dx][ly+dy]);\n                        if(c == 100000) continue;\n                        q.push(pair<int,S>(d+c, S(0,PP(P(lx+dx,ly+dy),P(rx,ry)))));\n                    }\n            } else {\n                for(int dx=-5; dx<=5; dx++)\n                    for(int dy=-5; dy<=5; dy++) {\n                        if(!chk(rx+dx, ry+dy)) continue;\n                        if(!chk2(lx,ly,rx+dx,ry+dy)) continue;\n                        if(lx>=rx) continue;\n\n                        int c = c2c(cmap[rx+dx][ry+dy]);\n                        if(c == 100000) continue;\n                        q.push(pair<int,S>(d+c, S(1,PP(P(lx,ly),P(rx+dx,ry+dy)))));\n                    }\n            }\n\n        }\n        printf(\"-1\\n\");\n        continue;\nRES:\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int W = 31;\nconst int H = 61;\n\nclass P{\n\tpublic:\n\tint a,b,c,d;\n\tint val;\n\tP(int a,int b,int c,int d,int val):a(a),b(b),c(c),d(d),val(val){}\n\tbool operator<(const P& tmp)const{\n\t\treturn val>tmp.val;\n\t}\n};\n\nint h,w;\nchar masu[H][W];\n\nvoid initQue(priority_queue<P>& que){\n\trep(i,h)rep(j,w){\n\t\tif(masu[i][j]=='S')que.push(P(i,j,i,j,0));\n\t}\n}\n\nint getCost(int y,int x){\n\tif(y<0 || x<0 || y>=h || x>=w)return -1;\n\tif(masu[y][x]=='X')return -1;\n\tif(masu[y][x]=='T')return 0;\n\tif(masu[y][x]=='S')return 0;\n\treturn masu[y][x]-'0';\n}\n\nvoid addQue(priority_queue<P> &que, P& u){\n\tint dy[]={-2,-1,-1,0,0,0,1,1,2};\n\tint dx[]={1,1,2,1,2,3,1,2,1};\n\t\n\trep(p,9){\n\t\tint ny = u.a + dy[p];\n\t\tint nx = u.b + dx[p];\n\t\tint ncost = getCost(ny,nx);\n\t\tif(ncost != -1) que.push(P(u.a,u.b, ny,nx, u.val+ncost));\n\t}\n\trep(p,9){\t\n\t\tint ty = u.c + dy[p];\n\t\tint tx = u.d - dx[p];\n\t\tint tcost = getCost(ty,tx);\n\t\tif(tcost != -1) que.push(P(ty,tx, u.c,u.d, u.val+tcost));\n\t}\n}\n\nbool isGoal(P& u){\n\treturn masu[u.a][u.b]=='T' || masu[u.c][u.d]=='T';\n}\n\nint visit[H][W][H][W];\nint solve(){\n\trep(i,h)rep(j,w)cin>>masu[i][j];\n\t\n\tpriority_queue<P> que;\n\tinitQue(que);\n\t\n\tint ans = -1;\n\trep(i,h)rep(j,w)rep(k,h)rep(p,w)visit[i][j][k][p]=0;\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.a][u.b][u.c][u.d]==1)continue;\n\t\tvisit[u.a][u.b][u.c][u.d]=1;\n\t\t\n\t\t//printf(\"(%d %d) (%d %d) %d\\n\",u.a,u.b,u.c,u.d,u.val);\n\t\t\n\t\tif(isGoal(u)){\n\t\t\tans = u.val;\n\t\t\tbreak;\n\t\t}\n\t\taddQue(que, u);\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(h==0 && w==0)break;\n\t\t\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define INF ((int)1e9)\n#define EPS (1e-9)\n#define MOD (1000000007)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\n\nvi dx={1,1,1,1,1,2,2,2,3};\nvi dy={2,1,0,-1,-2,1,0,-1,0};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvvi a(h,vi(w,0));\n\t\tvi s,t;\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c; cin>>c;\n\t\t\tif(isdigit(c)) a[i][j]=c-48;\n\t\t\tif(c=='X') a[i][j]=INF;\n\t\t\tif(c=='S') s.push_back(j);\n\t\t\tif(c=='T') t.push_back(j);\n\t\t}\n\t\tusing data=tuple<int,int,int,int>; //cost,y,x, L1 or R-1\n\t\tauto cmp=[](data a,data b){return get<0>(a)>get<0>(b);};\n\n\t\tint ans=INF;\n\t\tfor(auto start:s) for(auto LR:{1,0}){\n\t\t\tvector<vvi> f(2,vvi(h,vi(w,INF)));\n\t\t\tpriority_queue<data,vector<data>,decltype(cmp)> q(cmp);\n\t\t\tq.emplace(0,h-1,start,LR);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint cost,y,x,lr;\n\t\t\t\ttie(cost,y,x,lr)=q.top(); q.pop();\n\t\t\t\tif(f[lr][y][x]!=INF) continue;\n\t\t\t\tif(y==0 and binary_search(all(t),x)){\n\t\t\t\t\tans=min(ans,cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf[lr][y][x]=cost;\n\t\t\t\trep(i,9){\n\t\t\t\t\tint nx=x+dx[i]*(lr?1:-1),ny=y+dy[i];\n\t\t\t\t\tif(nx<0 or nx>=w or ny<0 or ny>=h or a[ny][nx]==INF or f[lr^1][ny][nx]!=INF) continue;\n\t\t\t\t\tq.emplace(cost+a[ny][nx],ny,nx,lr^1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF){\n\t\t\tcout<<-1<<endl;\n\t\t}else{\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int dy[] = { 1,  1,  1,  1,  1,  2,  2,  2,  3};\nconst int dx[] = {-2, -1,  0,  1,  2, -1,  0,  1,  0};\nconst int INF = 1001001001;\nconst int K = 3;\ntypedef pair<int, int> P;\nstruct STATE\n{\n\tint x, y, a, d;\n\tbool operator <(const STATE &t) const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[256][256];\nint d[256][256][2];\nvoid init();\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tinit();\n\t\tw += K; h += K;\n\t\t\n\t\tvector<P> start;\n\t\tfor (int i = K; i < h; i++){\n\t\t\tfor (int j = K; j < w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'S'){\n\t\t\t\t\tstart.PB(P(i, j));\n\t\t\t\t\tgrid[i][j] = 127;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'T'){\n\t\t\t\t\tgrid[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] >= '1' && grid[i][j] <= '9'){\n\t\t\t\t\tgrid[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i < start.size(); i++){\n\t\t\tpriority_queue<STATE> que;\n\t\t\tque.push({start[i].first, start[i].second, 1, 0});\n\t\t\tque.push({start[i].first, start[i].second, -1, 0});\n\t\t}\n\t\tfor (; que.size(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y][st.a == 1] <= st.d) continue;\n\t\t\td[st.x][st.y][st.a == 1] = st.d;\n\t\t\tif (st.d >= res) continue;\n\t\t\tif (grid[st.x][st.y] == 0){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//cout << st.x << \" \" << st.y << endl;\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 9; dir++){\n\t\t\t\tint tx = st.x + dx[dir] * st.a;\n\t\t\t\tint ty = st.y + dy[dir] * st.a;\n\t\t\t\tint ta = -st.a;\n\t\t\t\tint td = st.d + grid[tx][ty];\n\t\t\t\tif (grid[tx][ty] == 'X') continue;\n\t\t\t\tque.push({tx, ty, -st.a, td});\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (res != INF) cout << res << endl;\n\t\telse cout << \"-1\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\nvoid init()\n{\n\tmemset(grid, 'X', sizeof(grid));\n\tfor (int i = 0; i < 256; i++){\n\t\tfor (int j = 0; j < 256; j++){\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P{\n  int lx,ly;\n  int rx,ry;\n  bool f;                       // f : ツ篠淞右ツ堕ォ(0) ツ債カツ堕ォ(1)\n  int dis;\n  P(int lx,int ly,int rx,int ry, bool f, int dis):lx(lx),ly(ly),rx(rx),ry(ry),f(f),dis(dis) {}\n};\n\nconst bool operator<(const P &a, const P &b) {\n  return a.dis > b.dis;\n}\n\nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n\nint dist[30][60][30][60][2];\nint main() {\n  int w,h;\n  while(cin>>w>>h,w||h) {\n    char ba[w][h];\n    priority_queue<P> Q;\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba[x][y];\n        if (ba[x][y] == 'S') {\n          Q.push(P(x,y,x,y,0,0));\n          Q.push(P(x,y,x,y,1,0));\n        }\n      }\n    }\n    \n    REP(i,w)REP(j,h)REP(k,w)REP(l,h)REP(m,2)dist[i][j][k][l][m] = INF;\n//    memset(visited,0,sizeof(visited));\n    int res = -1;\n    while(!Q.empty()) {\n      P p = Q.top();\n      Q.pop();\n      if (dist[p.lx][p.ly][p.rx][p.ry][p.f] < p.dis) continue;\n\n      //printf(\"%d,%d,%d,%d\\n\",p.lx,p.ly,p.rx,p.ry);\n      if (ba[p.lx][p.ly] == 'T' || ba[p.rx][p.ry] == 'T') {\n        res = p.dis;\n        break;\n      }\n      REP(k,9) {\n        if (p.f) {                // ツ債カツ堕ォ\n          int xx = p.rx - dx[k];\n          int yy = p.ry + dy[k];\n          if (xx<0||xx>=w||yy<0||yy>=h)continue;\n          //printf(\"ssdfsdf\\n\");\n          if (ba[xx][yy] == 'X') continue;\n          int hoge = 0;\n          if (isdigit(ba[xx][yy])) \n            hoge = ba[xx][yy] - '0';\n          if (dist[xx][yy][p.rx][p.ry][0] > p.dis + hoge) {\n            dist[xx][yy][p.rx][p.ry][0] = p.dis + hoge;\n            Q.push(P(xx,yy,p.rx,p.ry,0,p.dis+hoge));\n          }\n        } else {\n          int xx = p.lx + dx[k];\n          int yy = p.ly + dy[k];\n          if (xx<0||xx>=w||yy<0||yy>=h)continue;\n          if (ba[xx][yy] == 'X') continue;\n          int hoge = 0;\n          if (isdigit(ba[xx][yy])) \n            hoge = ba[xx][yy] - '0';\n          if (dist[p.lx][p.ly][xx][yy][1] > p.dis + hoge) {\n            dist[p.lx][p.ly][xx][yy][1] = p.dis + hoge;\n            Q.push(P(p.lx,p.ly,xx,yy,1,p.dis+hoge));\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define MAX 3600\n\n\n#define TEST 0\n\nint edges[MAX][MAX];\nint edges_ind[MAX*9][2];\n//vector<pair<int,int> > edges_ind;\nchar dat[MAX];\nint w,h;\nint cnt;//|E|\n\nint shortest(int start)\n{\n    int d[MAX];\n    fill_n(d,2*w*h,-1);\n    d[start]=0;\n    for(int time=0;time<2*w*h-1;++time)\n    {\n        for(int i=0;i<cnt;i++)\n        {\n            int v0=edges_ind[i][0];\n            int v1=edges_ind[i][1];\n            if(d[v0]>=0)\n            {\n                if(d[v1]==-1)\n                {\n                    d[v1]=d[v0]+edges[v0][v1];\n                }\n                else{\n                    d[v1]=min(d[v1],d[v0]+edges[v0][v1]);\n                }\n            }\n        }\n    }\n    int minv=0x3fffffff;\n    for(int i=0;i<2*w*h;i++)\n    {\n        if(dat[i]=='T' && d[i]>=0)\n            minv=min(minv,d[i]);\n    }\n    return minv;\n}\n\nint main(void)\n{\n    while(scanf(\"%d%d\",&w,&h)==2 &&(w||h))\n    {\n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {   \n                int ch;\n                while((ch=getchar())<=' '){}\n                dat[i*w+j]=ch;\n            }\n        }\n        if(TEST&&0)\n        {\n            for(int i=0;i<w*h;i++)\n            {\n                printf(\"%c \",dat[i]);\n            }\n        }\n        for(int i=0;i<2*w*h;i++)\n        {\n            fill(edges[i],edges[i]+2*w*h,-1);\n        }\n        cnt=0;\n        //left->right\n        for(int x=0;x<w;x++)\n        {\n            for(int y=0;y<h;y++)\n            {\n                for(int p=0;p<3&&x+p+1<w;p++)\n                {\n                    for(int t=max(y-2+p,0);t<=y+2-p&&t<h;t++)\n                    {\n                        int dest=w*h+t*w+x+p+1;\n                        char ch=dat[dest-w*h];\n                        if(ch>='0'&&ch<='9')\n                        {\n                            edges[y*w+x][dest]=ch-'0';\n                            edges_ind[cnt][0]=y*w+x;\n                            edges_ind[cnt][1]=dest;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n        //right->left\n        for(int x=0;x<w;x++)\n        {\n            for(int y=0;y<h;y++)\n            {\n                for(int p=0;p<3&&x-p-1>=0;p++)\n                {\n                    for(int t=max(y-2+p,0);t<=y+2-p&&t<h;t++)\n                    {\n                        int dest=t*w+x-p-1;\n                        char ch=dat[dest];\n                        if(ch>='0'&&ch<='9')\n                        {\n                            edges[w*h+y*w+x][dest]=ch-'0';\n                            edges_ind[cnt][0]=w*h+y*w+x;\n                            edges_ind[cnt][1]=dest;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n        if(TEST)\n        {\n            for(int i=0;i<cnt;i++)\n            {\n                printf(\"%d-%d\\n\",edges_ind[i][0],edges_ind[i][1]);\n            }\n        }\n        int minv=0x3fffffff;\n        for(int i=0;i<w*h;i++)\n        {\n            if(dat[i]=='S')\n            {\n                minv=min(minv,shortest(i));\n                minv=min(minv,shortest(w*h+i));\n            }\n        }\n        printf(\"%d\\n\",minv==0x3fffffff?-1:minv);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\nstatic const int INF = 0x3f3f3f3f;\n\nstruct state {\n        int y, x, cost;\n        bool right;\n        bool operator < (const state& r) const { return cost < r.cost; }\n        bool operator > (const state& r) const { return cost > r.cost; }\n};\n\nvoid dijkstra(vector<vector<char>>& M, int w, int h) {\n        priority_queue<state, vector<state>, greater<state>> q;\n        rep(i, h) rep(j, w) if (M[i][j] == 'S') q.push((state){ i, j, 0, true });\n        rep(i, h) rep(j, w) if (M[i][j] == 'S') q.push((state){ i, j, 0, false });\n        int dis[70][40][2];\n        rep(i, 70) rep(j, 40) rep(k, 2) dis[i][j][k] = INF;\n        while (!q.empty()) {\n                state p = q.top(); q.pop();\n                dis[p.y][p.x][p.right] = p.cost;\n                if (M[p.y][p.x] == 'T') {\n                        cout << p.cost << endl;\n                        return;\n                }\n                for (int dx = 1; dx <= 3; dx ++) {\n                        for (int dy = -2; dy <= 2; dy ++) {\n                                if (abs(dx) + abs(dy) <= 3) {\n                                        state np;\n                                        np.x = p.x + dx * (p.right ? 1 : -1);\n                                        np.y = p.y + dy;\n                                        if (np.y < 0 || h <= np.y || np.x < 0 || w <= np.x) continue;\n                                        if (M[np.y][np.x] == 'X') continue;\n                                        if (M[np.y][np.x] == 'S') continue;\n                                        else if (M[np.y][np.x] == 'T') {\n                                                np.cost = p.cost;\n                                        } else np.cost = p.cost + (M[np.y][np.x] - '0');\n                                        np.right = !p.right;\n                                        if (dis[np.y][np.x][np.right] > np.cost) {\n                                                q.push(np);\n                                        }\n                                }\n                        }\n                }\n        }\n        cout << -1 << endl;\n        return;\n}\n\nint main() {\n        int w, h;\n        while (cin >> w >> h && w) {\n                vector<vector<char>> M(h, vector<char> (w));\n                rep(i, h) rep(j, w) cin >> M[i][j];\n                dijkstra(M, w, h);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint x , y  , turn , cost;\n\tNODE(int x,int y,int turn,int cost) : x(x) , y(y) , turn(turn) , cost(cost) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nbool memo[31][61][2];\nint d[61][31];\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h && w){\n\t\tpriority_queue<NODE> Q;\n\t\tint goal[100][100]={0};\n\t\tfor(int i = 0 ; i < h ; i++)\n\t\t\tfor(int j = 0 ; j < w ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tQ.push(NODE(j,i,0,0));\n\t\t\t\t\tQ.push(NODE(j,i,1,0));\n\t\t\t\t}else if( c == 'T'){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tgoal[i][j] = 1;\n\t\t\t\t}else if( c == 'X'){\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\td[i][j] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\tmemset(memo,0,sizeof(memo));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(goal[q.y][q.x]){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif(memo[q.y][q.x][q.turn]) continue;\n\t\t\telse memo[q.y][q.x][q.turn] = true;\n\t\t\t\n\t\t\tfor(int X = q.turn?1:-3 ; X <= (q.turn?3:-1) ; X++){\n\t\t\t\tfor(int Y = -2 ; Y <= 2 ; Y++){\n\t\t\t\t\tif(abs(X)+abs(Y) <= 3){\n\t\t\t\t\t\tint tx = q.x + X , ty = q.y + Y;\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w || d[ty][tx] == -1) continue;\n\t\t\t\t\t\tQ.push(NODE(tx,ty,q.turn^1,q.cost+d[ty][tx]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define len(v) (int)(v).size()\n#define show(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>pi;\n\nint dx[9] = {2,1,1,0,0,0,-1,-1,-2};\nint dy[9] = {1,1,2,1,2,3,1,2,1};\nint dp[61][31][2];\n\nint main()\n{\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0){\n            break;\n        }\n        vector<vector<string> > s(h,vector<string>(w));\n        vector<P> st;\n        vector<P> goal;\n        rep(i,h){\n            rep(j,w){\n                cin >> s[i][j];\n                if(s[i][j] == \"S\"){\n                    st.push_back(P(i,j));\n                }else if(s[i][j] == \"T\"){\n                    goal.push_back(P(i,j));\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,len(st)){\n            rep(j,h){\n                rep(k,w){\n                    rep(l,2){\n                        dp[j][k][l] = INF;\n                    }\n                }\n            }\n            queue<pi> que;\n            que.push(pi(st[i],-1));\n            dp[st[i].fi][st[i].se][0] = 0;\n            while(!que.empty()){\n                pi pp = que.front();\n                P p = pp.fi;\n                int cri = pp.se;\n                int x = (cri+1)/2;\n                int y = (x^1);\n                que.pop();\n                rep(k,9){\n                    int nx = p.fi+dx[k], ny = p.se+cri*dy[k];\n                    if(nx >= 0 && nx < h && ny >= 0 && ny < w && s[nx][ny] != \"X\" && dp[nx][ny][y] > dp[p.fi][p.se][x]+(isdigit(s[nx][ny][0])?(s[nx][ny][0]-'0'):0)){\n                        dp[nx][ny][y] = dp[p.fi][p.se][x]+(isdigit(s[nx][ny][0])?(s[nx][ny][0]-'0'):0);\n                        que.push(pi(P(nx,ny),-cri));\n                    }\n                }\n            }\n            rep(k,len(goal)){\n                ans = min(ans,min(dp[goal[k].fi][goal[k].se][0],dp[goal[k].fi][goal[k].se][1]));\n            }\n            rep(j,h){\n                rep(k,w){\n                    rep(l,2){\n                        dp[j][k][l] = INF;\n                    }\n                }\n            }\n            que.push(pi(st[i],1));\n            dp[st[i].fi][st[i].se][1] = 0;\n            while(!que.empty()){\n                pi pp = que.front();\n                P p = pp.fi;\n                int cri = pp.se;\n                int x = (cri+1)/2;\n                int y = (x^1);\n                que.pop();\n                rep(k,9){\n                    int nx = p.fi+dx[k], ny = p.se+cri*dy[k];\n                    if(nx >= 0 && nx < h && ny >= 0 && ny < w && s[nx][ny] != \"X\" && dp[nx][ny][y] > dp[p.fi][p.se][x]+(isdigit(s[nx][ny][0])?(s[nx][ny][0]-'0'):0)){\n                        dp[nx][ny][y] = dp[p.fi][p.se][x]+(isdigit(s[nx][ny][0])?(s[nx][ny][0]-'0'):0);\n                        que.push(pi(P(nx,ny),-cri));\n                    }\n                }\n            }\n            rep(k,len(goal)){\n                ans = min(ans,min(dp[goal[k].fi][goal[k].se][0],dp[goal[k].fi][goal[k].se][1]));\n            }\n        }\n        // rep(i,h){\n        //     rep(j,w){\n        //         cout << min(dp[i][j][0],dp[i][j][1]) << \" \";\n        //     }\n        //     cout << \"\\n\";\n        // }\n        if(ans == INF){\n            cout << \"-1\\n\";\n        }else{\n            cout << ans << \"\\n\";\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[2][9] = {{0, 1, -1, 2, -2, 0, 1, -1, 0}, {0, 1, -1, 2, -2, 0, 1, -1, 0}};\nconst int dx[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nconst int MAX_N = 70;\nchar field[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N][2];\nint h, w;\nstruct edge \n{\n    int cost;\n    int y, x;\n    bool flag;\n    bool operator > (const edge &d) const\n    {\n        return d.cost < cost;\n    }\n};\nint dijkstra(int y, int x, bool foot)\n{\n    priority_queue<edge, vector<edge>, greater<edge>> que;\n    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) for(int k = 0; k < 2; k++) dist[i][j][k] = INF;\n    dist[y][x][foot] = 0;\n    edge v = {0, y, x, foot};\n    que.push(v);\n    while(!que.empty())\n    {\n        edge p = que.top();\n        que.pop();\n        int ty = p.y;\n        int tx = p.x;\n        bool flag = (p.flag ? false : true);\n        if(dist[ty][tx][p.flag] < p.cost) continue;\n        for(int i = 0; i < 9; i++)\n        {\n            int ny = ty + dy[flag][i];\n            int nx = tx + dx[flag][i];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n            if(field[ny][nx] == 'X' || field[ny][nx] == 'S') continue; \n            int cost = 0;\n            if(field[ny][nx] != 'T') cost = field[ny][nx] - '0';\n            if(dist[ny][nx][flag] > dist[ty][tx][p.flag] + cost)\n            {\n                dist[ny][nx][flag] = dist[ty][tx][p.flag] + cost;\n                edge tmp = {cost, ny, nx, flag};\n                que.push(tmp);\n            }\n        }\n    }\n    int ret = INF;\n    for(int j = 0; j < w; j++)\n    {\n        if(field[0][j] != 'T') continue;\n        for(int k = 0; k < 2; k++) ret = min(dist[0][j][k], ret);\n    }\n    return ret;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        int ans = INF;\n        vector<P> start;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char ch;\n                cin >> ch;\n                if(ch == 'S') start.push_back(P(i, j));\n                field[i][j] = ch;\n            }\n        }\n        for(int i = 0; i < start.size(); i++)\n        {\n            for(int j = 0; j < 2; j++)\n            {\n                ans = min(dijkstra(start[i].first, start[i].second, j), ans);\n            }\n        }\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[33][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  int mincost[2][33][33];\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[(lr+1)%2][ny][nx]) {\n\t  mincost[(lr+1)%2][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, (lr+1)%2), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// start: 21:57\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <sstream>\n#include <deque>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\n// 左足のときに置ける右足\nint mx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    my[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nvoid dump(vector< vector<char> > &f, int x = -1, int y = -1, int l = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == y && j == x ) {\n                if ( l == 0 )\n                    cout << \"R\";\n                else\n                    cout << \"L\";\n            }\n            else\n                cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        int closed[h][w][2];\n        vector< queue<xy> > foot(2);   // 0:右 1:左\n        queue<int> cost, leg;\n        vector< vector<char> > f(h);\n        vector< xy > start;\n\n        REP(i, h) REP(j, w) REP(k, 2) closed[i][j][k] = 0;\n\n        REP(i, h) {\n            REP(j, w) {\n                char tmp;\n                cin >> tmp;\n                f[i].push_back(tmp);\n                if ( f[i][j] == 'S' ) {\n                    start.push_back( make_pair(j, i) );\n                }\n            }\n        }\n\n        // スタート地点＋左右を初期値としてpush\n        REP(i, start.size()) {\n            int l = 0;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n\n            l = 1;\n            leg.push(l);\n            foot[l].push( make_pair(start[i].first, start[i].second) );\n            cost.push(0);\n\n            // cout << start[i].first << \" \" << start[i].second << \" \" << f[start[i].second][start[i].first] << endl;\n        }\n\n        int min = INT_MAX;\n        while(!cost.empty()) {\n            int c = cost.front(); cost.pop();\n            int l = leg.front(); leg.pop();\n            xy ft = foot[l].front(); foot[l].pop();\n            int x = ft.first, y = ft.second;\n\n            // printf(\"f:%d, x:%d, y:%d, xy:%c\\n\", l, x, y, f[y][x]);\n            // dump(f, x, y, l);\n            if ( f[y][x] == 'T' && c < min ) {\n                min = c;\n                continue;\n            }\n\n            REP(i, 9) {\n                int dir = l == 0 ? -1: 1,\n                    nx = x + mx[i] * dir,\n                    ny = y + my[i],\n                    nl = !l;\n\n                if ( !(0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n                if ( f[ny][nx] == 'X' || f[ny][nx] == 'S' ) continue;   // バグ出るかも\n\n                // int nc = (int)f[ny][nx] - 48;\n                int nc;\n                if ( ((int)f[ny][nx] - 48) > 9 )\n                    nc = c + 1;\n                else\n                    nc = c + ((int)f[ny][nx] - 48);\n                // nc += c;\n                // int nc = c + 1;\n                // cout << nc << \" \" << f[ny][nx] << endl;\n\n                if ( closed[ny][nx][nl] != 0 && closed[ny][nx][nl] < nc ) continue;\n\n                cost.push(nc);\n                leg.push(nl);   // 逆足\n                foot[nl].push( make_pair(nx, ny) );\n                closed[ny][nx][nl] = nc;\n\n            }\n            // cout << c << endl;\n            // REP(i, h) {REP(j, w) {cout << closed[i][j][0];} cout << endl;}\n            // cout << endl << c << endl;\n            // REP(i, h) {REP(j, w) {cout << closed[i][j][1];} cout << endl;}\n            // cout << endl;\n\n        }\n\n        if ( min == INT_MAX )\n            cout << -1 << endl;\n        else\n            cout << (min-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint d[30][60][2];\nvector<int>sv;\n\nint dijkstra(vector<vector<int>>&cost, State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d > s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\tint flag = 0;\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tif (cost[s.x][s.y] == 0) return s.d;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = -1;\n\t\t\t\t\tsv.push_back(j);\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') cliff[j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000;\n\t\tfor (auto start : sv) {\n\t\t\tint ans1 = min(dijkstra(cliff, State(0, start, h - 1, 1)), dijkstra(cliff, State(0, start, h - 1, -1)));\n\t\t\tans = min(ans, ans1);\n\t\t}\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t\tsv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    int dp[2][60][30];\n    char mp[30][60];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>mp[i][j];\n\tdp[0][i][j]=dp[1][i][j]=1e9;\n\tif(mp[i][j]=='S')dp[0][i][j]=dp[0][i][j]=0;\n      }\n\n    int dx[9]={1,1,1,1,1,2,2,2,3},dy[9]={2,1,0,-1,-2,1,0,-1,0},ans=1e9;\n    for(int i=0;i<=250;i++)\n      for(int y=0;y<h;y++)\n\tfor(int x=0;x<w;x++)\n\t  for(int l=0;l<2;l++){\n\t    int f=1,c=0;\n\t    if(l)f=-1;\n\t    if(isdigit(mp[y][x]))c=mp[y][x]-'0';\n\t    for(int p=0;p<9;p++){\n\t      int nx=x+f*dx[p],ny=y+f*dy[p];\n\t      if(nx<0||w<=nx||ny<0||h<=ny||mp[ny][nx]=='X')continue;\n\t      dp[!l][ny][nx]=min(dp[!l][ny][nx],dp[l][y][x]+c);\n\t    }\n\t    if(mp[y][x]=='T')ans=min(ans,dp[l][y][x]);\n\t  }\n    if(ans==1e9)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<string.h>\n#include <stdlib.h>\nusing namespace std;\n\nint W,H;\nstruct Node{\n\tint x,y,cost,dir;\n\tNode(int p_x,int p_y,int p_c,int p_dir){\n\t\tx=p_x;y=p_y;dir=p_dir;cost=p_c;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.cost>b.cost;\n};\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=W || y>=H) return false;\n\treturn true;\n}\n\nint solve(){\n\tvector<vector<char> > M(H,vector<char>(W));\n\tvector<int> S;\n\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tM[y][x]=c;\n\t\t\tif(c=='S'){\n\t\t\t\tS.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Node> Q;\n\tint cost[2][60][30];\n\tmemset(cost,-1,sizeof(cost));\n\n\tfor(int i=0;i<S.size();i++){\n\t\tQ.push(Node(S[i],H-1,0,0));\n\t\tQ.push(Node(S[i],H-1,0,1));\n\t}\n\twhile(!Q.empty()){\n\t\tNode t=Q.top();\n\t\tQ.pop();\n\t\tif(cost[t.dir][t.y][t.x]>=0) continue;\n\t\tcost[t.dir][t.y][t.x]=t.cost;\n\t\tint mul,next;\n\t\tif(t.dir==0){mul=1;next=1;}\n\t\telse{mul=-1;next=0;}\n\n\t\tfor(int x=1;x<=3;x++){\n\t\t\tfor(int y=-2;y<=2;y++){\n\t\t\t\tif(x+abs(y)>3) continue;\n\t\t\t\tint nx=t.x+x*mul;\n\t\t\t\tint ny=t.y+y;\n\t\t\t\tif(!in(nx,ny)) continue;\n\n\t\t\t\tif(M[ny][nx]=='T') return t.cost;\n\t\t\t\tif(!isdigit(M[ny][nx])) continue;\n\n\t\t\t\tQ.push(Node(nx,ny,t.cost+M[ny][nx]-'0',next));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin>>W>>H){\n\t\tif(W==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nconst int INF = 1<<30;\n\n// lr-0 left, lr-1 right\nstruct data{\n    int i, j, lr, cost;\n    bool operator<(const data other)const{\n        return cost > other.cost;\n    }\n};\n\n#define inRange(x,a,b) (a <= x && x < b)\nint di[9] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nint dj[9] = {-1, -1, -2, -1, -2, -3, -1, -2, -1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w+h){\n        char mat[h][w];\n        for(int i = 0; i < w*h; i++)    cin >> mat[i/w][i%w];\n        int dp[2][h][w];\n        for(int i = 0; i < 2; i++)  for(int j = 0; j < h; j++)  for(int k = 0; k < w; k++)  dp[i][j][k] = INF;\n        priority_queue<data> pq;\n        for(int j = 0; j < w; j++){\n            if(mat[h-1][j] == 'S')  pq.push(data({h-1, j, 0, 0})), pq.push(data({h-1, j, 1, 0}));\n        }\n        int ans = 1<<30;\n        while(!pq.empty()){\n            data d = pq.top();  pq.pop();\n            int i = d.i, j = d.j, lr = d.lr, cost = d.cost;\n            if(dp[lr][i][j] <= cost)    continue;\n            dp[lr][i][j] = cost;\n            if(mat[i][j] == 'T'){\n                ans = min(ans, dp[lr][i][j]);\n                continue;\n            }\n            for(int k = 0; k < 9; k++){\n                int ni = i+di[k], nj = j + (2*lr-1)*dj[k];\n                if(inRange(ni,0,h)&&inRange(nj,0,w)&&mat[ni][nj]!='X'&&mat[ni][nj]!='S'){\n                    int ncost = cost;\n                    if(mat[ni][nj] != 'T')  ncost += mat[ni][nj]-'0';\n                    if(dp[1-lr][ni][nj] > ncost){\n                        pq.push(data({ni,nj,1-lr,ncost}));\n                    }\n                }\n            }\n        }\n        if(ans == 1<<30)    ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint ijk[61][30][61][30][2];//left,right... 0:last-left 1:last-right\nbool v[61][30][61][30][2];\nint map[60][30];\nint dx[]={2,1,1,0,0,0,-1,-1,-2};\nint dy[]={1,1,2,1,2,3,1,2,1};\nchar str[2];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\tif(str[0]=='X')map[i][j]=-1;\n\t\t\t\telse if(str[0]=='S'||str[0]=='T')map[i][j]=0;\n\t\t\t\telse map[i][j]=str[0]-'0';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tijk[i][j][0][0][0]=-1;\n\t\t\t\tv[i][j][0][0][0]=false;\n\t\t\t\tijk[0][0][i][j][1]=-1;\n\t\t\t\tv[0][0][i][j][1]=false;\n\t\t\t\tfor(int k=0;k<9;k++){\n\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<a&&j+dy[k]<b){\n\t\t\t\t\t\tijk[i][j][i+dx[k]][j+dy[k]][0]=-1;\n\t\t\t\t\t\tv[i][j][i+dx[k]][j+dy[k]][0]=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<a&&j-dy[k]>=0){\n\t\t\t\t\t\tijk[i+dx[k]][j-dy[k]][i][j][1]=-1;\n\t\t\t\t\t\tv[i+dx[k]][j-dy[k]][i][j][1]=false;;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tpriority_queue<pair<pair<int,int>,pair<pair<int,int > ,pair<int,int> > > >Q;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(map[a-1][i]==0){\n\t\t\t\tijk[a-1][i][0][0][0]=0;\n\t\t\t\tQ.push(make_pair(make_pair(0,0),make_pair(make_pair(a-1,i),make_pair(0,0))));\n\t\t\t\tijk[0][0][a-1][i][1]=0;\n\t\t\t\tQ.push(make_pair(make_pair(0,1),make_pair(make_pair(0,0),make_pair(a-1,i))));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first.first;\n\t\t\tint last=Q.top().first.second;\n\t\t\tint Lrow=Q.top().second.first.first;\n\t\t\tint Lcol=Q.top().second.first.second;\n\t\t\tint Rrow=Q.top().second.second.first;\n\t\t\tint Rcol=Q.top().second.second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[Lrow][Lcol][Rrow][Rcol][last])continue;\n\t\t\tv[Lrow][Lcol][Rrow][Rcol][last]=true;\n\t\t\tif(!last){\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tif(0<=Lrow+dx[i]&&Lrow+dx[i]<a&&Lcol+dy[i]<b&&~map[Lrow+dx[i]][Lcol+dy[i]]&&\n\t\t\t\t\t\t(ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]==-1||ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]>cost+map[Lrow+dx[i]][Lcol+dy[i]])){\n\t\t\t\t\t\tijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1]=cost+map[Lrow+dx[i]][Lcol+dy[i]];\n\t\t\t\t\t\tQ.push(make_pair(make_pair(-ijk[Lrow][Lcol][Lrow+dx[i]][Lcol+dy[i]][1],1),make_pair(make_pair(Lrow,Lcol),make_pair(Lrow+dx[i],Lcol+dy[i]))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tif(0<=Rrow+dx[i]&&Rrow+dx[i]<a&&Rcol-dy[i]>=0&&~map[Rrow+dx[i]][Rcol-dy[i]]&&\n\t\t\t\t\t\t(ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]==-1||ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]>cost+map[Rrow+dx[i]][Rcol-dy[i]])){\n\t\t\t\t\t\tijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0]=cost+map[Rrow+dx[i]][Rcol-dy[i]];\n\t\t\t\t\t\tQ.push(make_pair(make_pair(-ijk[Rrow+dx[i]][Rcol-dy[i]][Rrow][Rcol][0],0),make_pair(make_pair(Rrow+dx[i],Rcol-dy[i]),make_pair(Rrow,Rcol))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(map[0][i]==0){\n\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\tif(0<=dx[j]&&dx[j]<a&&i+dy[j]<b&&~ijk[0][i][dx[j]][i+dy[j]][0])ret=min(ret,ijk[0][i][dx[j]][i+dy[j]][0]);\n\t\t\t\t\tif(0<=dx[j]&&dx[j]<a&&i-dy[j]>=0&&~ijk[dx[j]][i-dy[j]][0][i][1])ret=min(ret,ijk[dx[j]][i-dy[j]][0][i][1]);\n\t\t\t\t//\tif(0<=-dx[j]&&-dx[j]<a&&i-dy[j]>=0)printf(\"%d %d %d %d 0: %d\\n\",0,i,-dx[j],i-dy[j],ijk[0][i][-dx[j]][i-dy[j]][0]);\n\t\t\t\t//\tif(0<=-dx[j]&&-dx[j]<a&&i+dy[j]<b)printf(\"%d %d %d %d 1: %d\\n\",-dx[j],i+dy[j],0,i,1,ijk[-dx[j]][i+dy[j]][0][i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret==99999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[61][61][61][61];\nchar field[61][61];\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[60][30][60][30] + 1, INF);\n\t\tpriority_queue<Ps, vector<Ps>, greater<Ps> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tque.push(Ps(0, P2(P(j, i), P(j, i))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tPs ps = que.top();\n\t\t\tque.pop();\n\t\t\txl = ps.second.first.first;\n\t\t\tyl = ps.second.first.second;\n\t\t\txr = ps.second.second.first;\n\t\t\tyr = ps.second.second.second;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = ps.first;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(Ps(memo[xl][yl][xr2][yr2], P2(P(xl, yl), P(xr2, yr2))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > memo[xl][yl][xr][yr] + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = memo[xl][yl][xr][yr] + cost;\n\t\t\t\t\t\tque.push(Ps(memo[xl2][yl2][xr][yr], P2(P(xl2, yl2), P(xr, yr))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\nint dy[] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvector<vi> fld(h, vi(w));\n\t\tvi st, go;\n\t\tmap<pii, int> mp;\n\t\tmp[pii(-1, -1)] = -1;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') fld[i][j] = INF;\n\t\t\telse if (c == 'S')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tst.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse if (c == 'T')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tgo.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse fld[i][j] = c - '0';\n\t\t}\n\t\tvi goal;\n\t\tGraph g(1);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tif (find(ALL(st), left) != st.end() || find(ALL(st), right) != st.end())\n\t\t\t\t{\n\t\t\t\t\tg[0].push_back(edge{ mp.size(), max(fld[i][j], fld[rx][ry]) });\n\t\t\t\t}\n\t\t\t\tif (find(ALL(go), left) != go.end() || find(ALL(go), right) != go.end())\n\t\t\t\t{\n\t\t\t\t\tgoal.push_back(mp.size());\n\t\t\t\t}\n\t\t\t\tmp[pii(left, right)] = mp.size();\n\t\t\t}\n\t\t}\n\t\tg.resize(mp.size());\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tint now = mp[pii(left, right)];\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(left, place(nx, ny, w))];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = rx + dx[l], ny = ry - dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(place(nx, ny, w), right)];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<weight> d;\n\t\tdijkstra(g, d, 0);\n\t\tint ans = INF;\n\t\tREP(i, goal.size()) chmin(ans, d[goal[i]]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <climits>\n#define INF INT_MAX>>1 \n#define W_MAX 35\n#define H_MAX 65\n\nusing namespace std;\n\ntypedef long long ll;\n\nint w, h;\nchar cliff[H_MAX][W_MAX];\nint dp[H_MAX][W_MAX][2];\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {2, 1, 0,-1,-2, 1, 0,-1, 0};\n\nbool check(int i, int j){\n\tif(i<0 || h<=i || j<0 || w<=j) return false;\n\tif(cliff[i][j] == 'X')return false;\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w && !h)break;\n\t\tqueue<tuple<int, int, int, int> > que;\n\t\tfill(dp[0][0], dp[H_MAX][0], INF);\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> cliff[i][j];\n\t\t\t\tif(cliff[i][j] == 'S'){\n\t\t\t\t\tdp[i][j][0] = dp[i][j][1] = 0;\n\t\t\t\t\tque.push(make_tuple(i, j, 0, 0));\n\t\t\t\t\tque.push(make_tuple(i, j, 1, 0));\n\t\t\t\t\tcliff[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\ttuple<int, int, int, int> t = que.front(); que.pop();\n\t\t\tint y = get<0>(t);\n\t\t\tint x = get<1>(t);\n\t\t\tint lr = get<2>(t);\n\t\t\tint m = get<3>(t);\n\t\t\t//if(dp[y][x][lr] != m)continue;\n\t\t\tfor(int k=0; k<9; k++){\n\t\t\t\tint i, j;\n\t\t\t\tif(lr == 0){\n\t\t\t\t\ti = y + dy[k];\n\t\t\t\t\tj = x + dx[k];\n\t\t\t\t} else{\n\t\t\t\t\ti = y - dy[k];\n\t\t\t\t\tj = x - dx[k];\n\t\t\t\t}\n\t\t\t\tif(check(i, j) == false)continue;\n\t\t\t\tif(dp[i][j][(lr+1)%2] > m + (cliff[y][x] - '0')){\n\t\t\t\t\tdp[i][j][(lr+1)%2] = m + (cliff[y][x] - '0');\n\t\t\t\t\tif(cliff[i][j] != 'T'){\n\t\t\t\t\t\tque.push(make_tuple(i, j, (lr+1)%2, dp[i][j][(lr+1)%2]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\t\tif(cliff[i][j] == 'T') ans = min(ans, dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"-1\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// start: 21:57\n// AC: 00:12\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <queue>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\nvoid dump(vector< vector<char> > &f, int x = -1, int y = -1, int l = -1) {\n    REP(i, f.size()) {\n        REP(j, f[i].size()) {\n            if ( i == y && j == x ) {\n                if ( l == 0 )\n                    cout << \"R\";\n                else\n                    cout << \"L\";\n            }\n            else\n                cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nclass Climb {\npublic:\n    int cost;\n    int leg;\n    xy foot;\n    Climb(xy f, int l, int c): foot(f), leg(l), cost(c){}\n};\n\nbool operator< (const Climb& cl1, const Climb &cl2) {\n    return cl1.cost > cl2.cost;\n}\nbool operator> (const Climb& cl1, const Climb &cl2) {\n    return cl1.cost < cl2.cost;\n}\n\n// 左足のときに置ける右足\nint mx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1},\n    my[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\nint main() {\n    int w, h;\n\n    while(cin >> w >> h, w||h) {\n        priority_queue< Climb, vector<Climb>, less<vector<Climb>::value_type> > pq;\n\n        int closed[h][w][2];\n        // vector< queue<xy> > foot(2);   // 0:右 1:左\n        // queue<int> cost, leg;\n        vector< vector<char> > f(h);\n        vector< xy > start;\n\n        REP(i, h) REP(j, w) REP(k, 2) closed[i][j][k] = 0;\n\n        REP(i, h) {\n            REP(j, w) {\n                char tmp;\n                cin >> tmp;\n                f[i].push_back(tmp);\n                if ( f[i][j] == 'S' ) {\n                    start.push_back( make_pair(j, i) );\n                }\n            }\n        }\n\n        // スタート地点＋左右を初期値としてpush\n        REP(i, start.size()) {\n            // 0:右, 1:左\n            pq.push( Climb( make_pair(start[i].first, start[i].second), 0, 0) );\n            pq.push( Climb( make_pair(start[i].first, start[i].second), 1, 0) );\n        }\n\n        int min = INT_MAX;\n        while(!pq.empty()) {\n            Climb climb = pq.top(); pq.pop();\n\n            int c = climb.cost;\n            int l = climb.leg;\n\n            xy ft = climb.foot;\n            int x = ft.first;\n            int y = ft.second;\n\n            // printf(\"f:%d, x:%d, y:%d, xy:%c\\n\", l, x, y, f[y][x]);\n            // dump(f, x, y, l);\n            if ( f[y][x] == 'T' && c < min ) {\n                min = c;\n                continue;\n            }\n\n            REP(i, 9) {\n                int dir = l == 0 ? -1: 1,\n                    nx = x + mx[i] * dir,\n                    ny = y + my[i],\n                    nl = !l;\n\n                if ( !(0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n                if ( f[ny][nx] == 'X' || f[ny][nx] == 'S' ) continue;   // バグ出るかも\n\n                int nc;\n                if ( ((int)f[ny][nx] - 48) > 9 )\n                    nc = c + 1;\n                else\n                    nc = c + ((int)f[ny][nx] - 48);\n\n                if ( closed[ny][nx][nl] != 0 && closed[ny][nx][nl] < nc ) continue;\n\n                pq.push( Climb( make_pair(nx, ny), nl, nc) );\n                closed[ny][nx][nl] = nc;\n\n            }\n        }\n\n        if ( min == INT_MAX )\n            cout << -1 << endl;\n        else\n            cout << (min-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[9]={1,1,1,1,1,2,2,2,3} , dy[9]={-2,-1,0,1,2,-1,0,1,0} ;\ntypedef pair<pli,pint> P;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w!=0){\n        char s[h][w];\n        vector<pint> st,gl;\n        rep(i,h)rep(j,w){\n            cin>>s[i][j];\n            if(s[i][j]=='S')st.push_back({i,j});\n            if(s[i][j]=='T')gl.push_back({i,j});\n        }\n        priority_queue<P,vector<P>,greater<P>> q;\n        ll dist[h][w][2];\n        rep(i,h)rep(j,w)rep(k,2)dist[i][j][k]=inf;\n        for(auto y:st){\n            rep(i,2)q.push({{0,i},y});\n            rep(i,2)dist[y.first][y.second][i]=0;\n        }\n        while(!q.empty()){\n            P p=q.top();\n            q.pop();\n            ll d=p.first.first;\n            int flag=p.first.second;\n            int y=p.second.first;\n            int x=p.second.second;\n            if(d>dist[y][x][flag])continue;\n            rep(i,9){\n                int nx=x+(flag?1:-1)*dx[i],ny=y+dy[i];\n                if(0<=nx&&nx<w&&0<=ny&&ny<h&&s[ny][nx]!='X'&&s[ny][nx]!='S'){\n                    int dd=(s[ny][nx]=='T'?0:s[ny][nx]-'0');\n                    if(dist[ny][nx][!flag]>d+dd){\n                        dist[ny][nx][1-flag]=d+dd;\n                        q.push({{d+dd,1-flag},{ny,nx}});\n                    }\n                }\n            }\n        }\n        ll ans=inf;\n        for(auto y:gl)rep(i,2)ans=min(ans,dist[y.first][y.second][i]);\n        cout<<(ans==inf?-1:ans)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconstexpr int MAX = 64;\nconstexpr int INF = 1e8;\nint w, h;\nchar grid[MAX][MAX] = {};\nint d[MAX][MAX][2] = {};\n\nstruct Node {\n    int x_;\n    int y_;\n    int cost_;\n    int side_; // 0 | 1 = left | right\n    Node(int x, int y, int cost, int side) \n        : x_(x), y_(y), cost_(cost), side_(side) {}   \n};\n\nauto clear() -> void {\n    for (int i = 0; i < MAX; ++i) {\n        for (int j = 0; j < MAX; ++j) {\n            for (int k = 0; k < 2; ++k) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n}\n\nauto check_range(int x, int y) -> bool {\n    if (x >= 0 && x < w \n        && y >= 0 && y < h \n        && grid[y][x] != 'X') {\n        return true;\n    }\n    return false;\n}\n\nauto dijkstra() -> int {\n    constexpr int dx[9] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n    constexpr int dy[9] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n    clear();\n\n    auto comp = [](auto& lhs, auto& rhs) { return lhs.cost_ > rhs.cost_; };\n    priority_queue<Node, vector<Node>, decltype(comp)> que(comp);\n\n    for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x) {\n            if (grid[y][x] == 'S') {\n                que.push(Node(x, y, 0, 0));\n                que.push(Node(x, y, 0, 1));\n                d[y][x][0] = 0;\n                d[y][x][1] = 0;\n            }\n        }\n    }\n\n    int ans = -1;\n    while(!que.empty()) {\n        Node node = que.top();\n        que.pop();\n        const int x = node.x_;\n        const int y = node.y_;\n        const int current_side = node.side_;\n\n        if(grid[y][x] == 'T'){\n            ans = node.cost_;\n            break;\n        }\n\n        for (int j = 0; j < 9; ++j) {\n            const int nx = x + dx[j] * (current_side ? -1 : 1);\n            const int ny = y + dy[j];\n            const int next_side = !current_side;\n            if (check_range(nx, ny)) {\n                const int grid_cost = (grid[ny][nx] == 'T') ? 0 : grid[ny][nx] - '0';\n                if(d[ny][nx][next_side] > node.cost_ + grid_cost) {\n                    d[ny][nx][next_side] = node.cost_ + grid_cost;\n                    que.push(Node(nx, ny, d[ny][nx][next_side], next_side));\n                }\n            }\n        }\n    }  \n    return ans;\n}\n\nauto main(int argc, char const *argv[]) -> int {\n    while( cin>>w>>h, w || h ) {\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin>>grid[i][j];\n            }\n        }\n        cout<<dijkstra()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os;}\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nstruct Edge {\n    int to;\n    ll cost;\n};\n\nll cost(char c) {\n    if (c == 'T' || c == 'S') {\n        return 0;\n    } else if (c == 'X') {\n        return 1LL << 60;\n    } else {\n        return c - '0';\n    }\n}\n\nvoid solve() {\n    int W, H;\n    while(cin >> W >> H, W) {\n        vector<vector<char>> A(H, vector<char>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> A[i][j];\n            }\n        }\n\n        vector<vector<Edge>> G(2 * H * W);\n        for(int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for(int k = -3; k <= 3; k++) {\n                    for(int l = -3; l <= 3; l++) {\n                        int lx = j, ly = i;\n                        int rx = j, ry = i;\n                        int nx = j + l, ny = i + k;\n                        if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n                        if (lx < nx && abs(lx - nx) + abs(ly - ny) <= 3) {\n                            G[ly * W + lx].push_back({W * H + ny * W + nx, cost(A[ny][nx])});\n                        }\n                        if (nx < rx && abs(rx - nx) + abs(ry - ny) <= 3) {\n                            G[W * H + ry * W + rx].push_back({ny * W + nx, cost(A[ny][nx])});\n                        }\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        for(int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (A[i][j] == 'S') {\n                    Q.push({0, i * W + j});\n                    Q.push({0, W * H + i * W + j});\n                }\n            }\n        }\n\n        vector<ll> dist(2 * W * H, 1LL << 60);\n        while(!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            ll d = p.first;\n            if (d >= dist[p.second]) continue;\n            dist[p.second] = d;\n            for(int i = 0; i < G[p.second].size(); i++) {\n                int u = G[p.second][i].to;\n                ll co = G[p.second][i].cost;\n                if (dist[u] > d + co) {\n                    Q.push({d + co, u});\n                }\n            }\n        }\n\n\n        ll ans = 1LL << 60;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (A[i][j] == 'T') {\n                    ans = min(ans, dist[i * W + j]);\n                    ans = min(ans, dist[W * H + i * W + j]);\n                }\n            }\n        }\n\n        if (ans == 1LL << 60) {\n            cout << -1 << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n}\n\nint main() {\n    #ifdef LOCAL_ENV\n    cin.exceptions(ios::failbit);\n    #endif\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    \n    solve();\n\n    #ifdef LOCAL_ENV\n    assert(cin.rdstate() & ios_base::eofbit);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint x , y  , turn , cost;\n\tNODE(int x,int y,int turn,int cost) : x(x) , y(y) , turn(turn) , cost(cost) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nbool memo[61][31][2];\nint d[61][31];\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h && w){\n\t\tpriority_queue<NODE> Q;\n\t\tint goal[100][100]={0};\n\t\tfor(int i = 0 ; i < h ; i++)\n\t\t\tfor(int j = 0 ; j < w ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tQ.push(NODE(j,i,0,0));\n\t\t\t\t\tQ.push(NODE(j,i,1,0));\n\t\t\t\t}else if( c == 'T'){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tgoal[i][j] = 1;\n\t\t\t\t}else if( c == 'X'){\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\td[i][j] = c - '0';\n\t\t\t\t}\n\t\t\t}\n\t\tmemset(memo,0,sizeof(memo));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(goal[q.y][q.x]){\n\t\t\t\tcout << q.cost << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif(memo[q.y][q.x][q.turn]) continue;\n\t\t\telse memo[q.y][q.x][q.turn] = true;\n\t\t\t\n\t\t\tfor(int X = q.turn?1:-3 ; X <= (q.turn?3:-1) ; X++){\n\t\t\t\tfor(int Y = -2 ; Y <= 2 ; Y++){\n\t\t\t\t\tif(abs(X)+abs(Y) <= 3){\n\t\t\t\t\t\tint tx = q.x + X , ty = q.y + Y;\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= h || tx >= w || d[ty][tx] == -1) continue;\n\t\t\t\t\t\tQ.push(NODE(tx,ty,q.turn^1,q.cost+d[ty][tx]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, step;\n    int feet;\n\n    bool operator >(const P& p) const {\n        return step > p.step;\n    }\n};\n\nconst int dx[] = {1,1,1,1,1,2,2,2,3}; const int dy[] = {2,1,0,-1,-2,1,0,-1,0};\n\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1e8\n\nconst char START = 'S';\nconst char GOAL = 'T';\nconst char WALL = 'X';\n\nchar field[MAX_H][MAX_W];\nint G[MAX_H][MAX_W][2];\n\nint w, h;\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        fill_n((char *)field, MAX_H*MAX_W, WALL);\n        fill_n((int *)G, MAX_H*MAX_W*2, INF);\n        priority_queue<P, vector<P>, greater<P>> que;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> field[y][x];\n                if ('0' <= field[y][x] && field[y][x] <= '9') {\n                    field[y][x] -= '0';\n                }\n                if (field[y][x] == START) {\n                    que.push({x, y, 0, 1});\n                    que.push({x, y, 0, -1});\n                }\n            }\n        }\n\n        int step = -1;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n\n            //LOG(\"%d %d [%d] left=%d\\n\", p.x, p.y,p.step, p.feet == 1);\n\n            if (field[p.y][p.x] == GOAL) {\n                step = p.step;\n                break;\n            }\n\n            for (int i = 0; i < 9; i++) {\n                int sx = p.x + dx[i] * p.feet, sy = p.y + dy[i];\n                if (0 <= sx && sx < w && 0 <= sy && sy < h) {\n                    switch (field[sy][sx]) {\n                    case WALL:\n                    case START:\n                        break;\n                    case GOAL:\n                        que.push({sx, sy, p.step, -p.feet});\n                        break;\n                    default:\n                        int f = -p.feet > 0 ? 0 : 1;\n                        int s = p.step + field[sy][sx];\n                        if (G[sx][sy][f] > s) {\n                            G[sx][sy][f] = s;\n                            que.push({sx, sy, s, -p.feet});\n                        }\n                    }\n                }\n            }\n        }\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f;\n\t\t\t\t\tf.ly = f.ry = i;\n\t\t\t\t\tf.lx = f.rx = j;\n\t\t\t\t\tf.p = 0;\n\t\t\t\t\tf.cnt = 0;\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-8;\nint INF=1e9;\nint txr[] = {1,1,1,1,1,2,2,2,3};\nint tyr[] = {-2,-1,0,1,2,-1,0,1,0};\nint txl[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nint tyl[] = {-2,-1,0,1,2,-1,0,1,0};\nchar stage[60][30];\nint cost[1800][1800];\nstruct dat{\npublic:\n    int cost;\n    int rhs;\n    int lhs;\n    bool turn;\n    dat(){}\n    dat(int cost,int lhs,int rhs,bool turn):cost(cost),lhs(lhs),rhs(rhs),turn(turn){\n    }\n\n    bool operator>(const dat& d) const{\n        return cost > d.cost;\n    }\n};\nint main(){\n    int w,h;\n    while(scanf(\"%d %d\",&w,&h)&&(w||h)){\n\t  REP(i,1000)REP(j,1000)cost[i][j]=INF;\n        vector<P> S;\n        vector<P> T;\n        for(int y=0;y<h;y++){\n            for(int x=0;x<w;x++){\n                scanf(\"%s\",&stage[y][x]);\n                if(stage[y][x]=='S') S.push_back(P(x,y));\n                if(stage[y][x]=='T') T.push_back(P(x,y));\n            }\n        }\n        priority_queue<dat,vector<dat>,greater<dat> > que;\n        for(int i=0;i<S.size();i++){\n            int x = S[i].first;\n            int y = S[i].second;\n            que.push(dat(0,y*w+x,y*w+x,false));\n            que.push(dat(0,y*w+x,y*w+x,true));\n        }\n        int res = numeric_limits<int>::max();\n        while(!que.empty()){\n            dat d = que.top();\n            int srx = d.rhs % w;\n            int sry = d.rhs / w;\n            int slx = d.lhs % w;\n            int sly = d.lhs / w;\n            que.pop();\n            if(d.cost >= res) continue;\n            if(d.turn){\n                for(int i=0;i<9;i++){\n                    int dx = txl[i] + srx;\n                    int dy = tyl[i] + sry;\n                    if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                    if(dx>=srx) continue;\n                    if(abs(dx - srx) + abs(dy - sry) > 3) continue;\n                    if(stage[dy][dx] == 'X') continue;\n                    if(stage[dy][dx] == 'T'){\n                        res = cost[dy*w+dx][d.rhs] = min(cost[dy*w+dx][d.rhs],d.cost);\n                        continue;\n                    }\n                    if(cost[dy*w+dx][d.rhs] <= d.cost + stage[dy][dx]-'0') continue;\n                    cost[dy*w+dx][d.rhs] = d.cost + stage[dy][dx]-'0';\n                    que.push(dat(d.cost + stage[dy][dx]-'0',dy*w+dx,d.rhs,false));\n                }\n            }\n            else{\n                for(int i=0;i<9;i++){\n                    int dx = txr[i] + slx;\n                    int dy = tyr[i] + sly;\n                    if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n                    if(slx>=dx) continue;\n                    if(abs(dx - slx) + abs(dy - sly) > 3) continue;\n                    if(stage[dy][dx] == 'X') continue;\n                    if(stage[dy][dx] == 'T'){\n                        res = cost[d.lhs][dy*w+dx] = min(cost[d.lhs][dy*w+dx],d.cost);\n                        continue;\n                    }\n                    if(cost[d.lhs][dy*w+dx] <= d.cost + stage[dy][dx]-'0') continue;\n                    cost[d.lhs][dy*w+dx] = d.cost + stage[dy][dx]-'0';\n                    que.push(dat(d.cost + stage[dy][dx]-'0',d.lhs,dy*w+dx,true));\n                }\n            }\n        }\n        printf(\"%d\\n\",res >= 0x3f3f3f3f ? -1 : res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nstruct edge { int to, cost; };\nint V;\nvector<edge> G[100000];\nint d[100000];\nint dy[9] = { 1,1,1,1,1,2,2,2,3 };\nint dx[9] = { -2,-1,0,1,2,-1,0,1,0 };\nvoid init(int v) {\n\trep(i, v) {\n\t\tG[i].clear();\n\t}\n}\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, (int)MOD);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint w, h;\nbool onboard(P x) {\n\tif (x.first >= 0 && x.first < h&&x.second >= 0 && x.second < w)return true;\n\treturn false;\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tV = w * h * 2; init(w*h * 2);\n\t\tchar cliff[60][30];\n\t\tvector<int> sta; vector<int> las;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> cliff[i][j];\n\t\t\t\tif (cliff[i][j] == 'T')las.push_back(i*w + j);\n\t\t\t\telse if (cliff[i][j] == 'S')sta.push_back(i*w + j);\n\t\t\t}\n\t\t}\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\trep(k, 9) {\n\t\t\t\t\tint nx = i + dx[k]; int ny1 = j + dy[k]; int ny2 = j - dy[k];\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tif (onboard({ nx,ny1 }) && cliff[nx][ny1] != 'X') {\n\t\t\t\t\t\tif ('1' <= cliff[nx][ny1] && cliff[nx][ny1] <= '9') {\n\t\t\t\t\t\t\tcost = cliff[nx][ny1] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tG[i*w + j].push_back({ nx*w + ny1 + h * w,cost });\n\t\t\t\t\t}\n\t\t\t\t\tcost = 0;\n\t\t\t\t\tif (onboard({ nx,ny2 }) && cliff[nx][ny2] != 'X') {\n\t\t\t\t\t\tif ('1' <= cliff[nx][ny2] && cliff[nx][ny2] <= '9') {\n\t\t\t\t\t\t\tcost = cliff[nx][ny2] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tG[i*w + j+w*h].push_back({ nx*w + ny2,cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = (int)MOD;\n\t\trep(i, (int)sta.size()) {\n\t\t\tdijkstra(sta[i]);\n\t\t\trep(j, (int)las.size()) {\n\t\t\t\tmi = min(mi, d[las[j]]);\n\t\t\t\tmi = min(mi, d[las[j] + h * w]);\n\t\t\t}\n\t\t\tdijkstra(sta[i] + h * w);\n\t\t\trep(j, (int)las.size()) {\n\t\t\t\tmi = min(mi, d[las[j]]);\n\t\t\t\tmi = min(mi, d[las[j] + h * w]);\n\t\t\t}\n\t\t}\n\t\tif (mi == (int)MOD) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << mi << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nint d[3602],w,h,dx[]={1,1,1,1,1,2,2,2,3},dy[]={-2,-1,0,1,2,-1,0,1,0};\nchar m[60][30];\nvector<edge> g[3602];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+2*h*w+2,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\trep(i,2*h*w+2)g[i].clear();\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>m[i][j];\n\t\t\tif(m[i][j]=='S'){\n\t\t\t\tedge e;\n\t\t\t\te.to=i*w+j+2;\n\t\t\t\te.cost=0;\n\t\t\t\tg[0].push_back(e);\n\t\t\t\te.to+=h*w;\n\t\t\t\tg[0].push_back(e);\n\t\t\t}\n\t\t\tif(m[i][j]=='T'){\n\t\t\t\tedge e;\n\t\t\t\te.to=1;\n\t\t\t\te.cost=0;\n\t\t\t\tg[i*w+j+2].push_back(e);\n\t\t\t\tg[h*w+i*w+j+2].push_back(e);\n\t\t\t}\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\trep(k,9){\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tedge e;\n\t\t\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h&&m[ny][nx]!='X'){\n\t\t\t\t\te.to=h*w+ny*w+nx+2;\n\t\t\t\t\te.cost=m[ny][nx]-'0';\n\t\t\t\t\tif(e.cost>9)e.cost=0;\n\t\t\t\t\tg[i*w+j+2].push_back(e);\n\t\t\t\t}\n\t\t\t\tnx=j-dx[k];\n\t\t\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h&&m[ny][nx]!='X'){\n\t\t\t\t\te.to=ny*w+nx+2;\n\t\t\t\t\te.cost=m[ny][nx]-'0';\n\t\t\t\t\tif(e.cost>9)e.cost=0;\n\t\t\t\t\tg[h*w+i*w+j+2].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tcout<<(d[1]!=INF?d[1]:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cctype>\nusing namespace std;\n\nint w, h;\nchar M[60][30];\n\nclass Point {\npublic:\n  int x;\n  int y;\n  Point() {}\n  Point(int x, int y) : x(x), y(y) {}\n  bool operator <(const Point &p) const {\n    if(x != p.x) return x < p.x;\n    return y < p.y;\n  }\n};\n\nclass State {\npublic:\n  int time;\n  Point left;\n  Point right;\n  State() {\n    time = 0;\n  }\n  bool operator <(const State &s) const {\n    if(time != s.time) return time > s.time;\n    if(left < s.left || s.left < left) return left < s.left;\n    return right < s.right;\n  }\n};\n\nclass VisSta {\npublic:\n  Point left;\n  Point right;\n  VisSta(State &s) {\n    left = s.left;\n    right = s.right;\n  }\n\n  bool operator <(const VisSta &vs) const {\n    if(left < vs.left || vs.left < left) return left < vs.left;\n    return right < vs.right;\n  }\n};\n\nint solve() {\n  State s;\n  priority_queue<State> que;\n  set<VisSta> vis;\n  const int rr[9][2] = {{1,-2},{1,-1},{1,0},{1,1},{1,2},\n\t\t\t{2,-1},{2,0},{2,1},{3,0}};\n  const int rl[9][2] = {{-1,-2},{-1,-1},{-1,0},{-1,1},{-1,2},\n\t\t\t{-2,-1},{-2,0},{-2,1},{-3,0}};\n\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      if(M[i][j] == 'S') {\n\ts.left = Point(j, i);\n\ts.right = Point(j, i);\n\tque.push(s);\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n\n    if(M[s.left.y][s.left.x] == 'T' || M[s.right.y][s.right.x] == 'T') {\n      //cout << s.left.x << \", \" << s.left.y << \" | \" << s.right.x << \", \" << s.right.y << endl;\n      return s.time;\n    }\n    \n    for(int k = 0; k < 9; ++k) {\n      State newS = s;\n      int nx = s.left.x + rr[k][0];\n      int ny = s.left.y + rr[k][1];\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      if(nx == s.right.x && ny == s.right.y) continue;\n      if(M[ny][nx] == 'X') continue;\n      newS.right = Point(nx, ny);\n      if(isdigit(M[ny][nx])) newS.time += M[ny][nx] - '0';\n      VisSta vs(newS);\n      if(vis.find(vs) == vis.end()) {\n        vis.insert(vs);\n        que.push(newS);\n      }\n    }\n\n    for(int k = 0; k < 9; ++k) {\n      State newS = s;\n      int nx = s.right.x + rl[k][0];\n      int ny = s.right.y + rl[k][1];\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      if(nx == s.left.x && ny == s.left.y) continue;\n      if(M[ny][nx] == 'X') continue;\n      newS.left = Point(nx, ny);\n      if(isdigit(M[ny][nx])) newS.time += M[ny][nx] - '0';\n      VisSta vs(newS);\n      if(vis.find(vs) == vis.end()) {\n        vis.insert(vs);\n        que.push(newS);\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n  while((cin >> w >> h) && (w || h)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n\tcin >> M[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150&lang=jp\nusing namespace std;\ntypedef long long ll;\ntypedef pair<pair<int, int>, pair<int, int>> foot;\n#define INF 1<<30\n\nint dx[9] = { 1,1,1,1,1,2,2,2,3 };\nint dy[9] = { -2,-1,0,1,2,-1,0,1,0 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<int>> masu(h, vector<int>(w, INF));\n\t\tvector<vector<vector<int>>> dist(h, vector<vector<int>>(w, vector<int>(2,INF)));\n\t\tqueue<pair<foot, bool>> q; // foot: foot location , bool : next foot(left:bool,right:true)\n\t\t/* input */\n\t\tfor (int y = 0; y < h;y++) {\n\t\t\tfor (int x = 0; x < w;x++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == 'X') continue;\n\t\t\t\tif (c == 'S' || c == 'T') masu[y][x] = 0;\n\t\t\t\telse masu[y][x] = c - '0';\n\t\t\t}\n\t\t}\n\n\t\t/* initialize */\n\t\tfor (int x = 0; x < w;x++) {\n\t\t\tif (masu[h - 1][x] == 0) {\n\t\t\t\t// dist initialize\n\t\t\t\tdist[h - 1][x][0] = dist[h-1][x][1] = 0;\n\t\t\t\t// q initialize\n\t\t\t\tq.push({ {{h - 1,x},{-1,-1}},true });\n\t\t\t\tq.push({ {{-1,-1},{h - 1,x}},false });\n\t\t\t}\n\t\t}\n\n\t\twhile (!q.empty()) {\n\t\t\tauto v = q.front(); q.pop();\n\t\t\tpair<int, int> l_foot = { v.first.first.first,v.first.first.second };\n\t\t\tpair<int, int> r_foot = { v.first.second.first,v.first.second.second };\n\t\t\tbool foot_flag = v.second;\n\n\t\t\tif (foot_flag) {\n\t\t\t\tfor (int i = 0; i < 9;i++) {\n\t\t\t\t\tint next_r_foot_y = l_foot.first + dy[i];\n\t\t\t\t\tint next_r_foot_x = l_foot.second + dx[i];\n\n\t\t\t\t\tif (next_r_foot_y < 0 || next_r_foot_y >= h) continue;\n\t\t\t\t\tif (next_r_foot_x < 0 || next_r_foot_x >= w) continue;\n\n\t\t\t\t\tif (dist[next_r_foot_y][next_r_foot_x][foot_flag] >\n\t\t\t\t\t\tdist[l_foot.first][l_foot.second][!foot_flag] + masu[next_r_foot_y][next_r_foot_x]) {\n\t\t\t\t\t\tdist[next_r_foot_y][next_r_foot_x][foot_flag] =\n\t\t\t\t\t\t\tdist[l_foot.first][l_foot.second][!foot_flag] + masu[next_r_foot_y][next_r_foot_x];\n\t\t\t\t\t\tq.push({ {{l_foot.first,l_foot.second},{next_r_foot_y,next_r_foot_x}},!foot_flag });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 9;i++) {\n\t\t\t\t\tint next_l_foot_y = r_foot.first + dy[i];\n\t\t\t\t\tint next_l_foot_x = r_foot.second - dx[i];\n\n\t\t\t\t\tif (next_l_foot_y < 0 || next_l_foot_y >= h) continue;\n\t\t\t\t\tif (next_l_foot_x < 0 || next_l_foot_x >= w) continue;\n\n\t\t\t\t\tif (dist[next_l_foot_y][next_l_foot_x][foot_flag] >\n\t\t\t\t\t\tdist[r_foot.first][r_foot.second][!foot_flag] + masu[next_l_foot_y][next_l_foot_x]) {\n\t\t\t\t\t\tdist[next_l_foot_y][next_l_foot_x][foot_flag] =\n\t\t\t\t\t\t\tdist[r_foot.first][r_foot.second][!foot_flag] + masu[next_l_foot_y][next_l_foot_x];\n\t\t\t\t\t\tq.push({ {{next_l_foot_y,next_l_foot_x},{r_foot.first,r_foot.second} }, !foot_flag });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < w;i++) {\n\t\t\tif (masu[0][i] != 0) continue;\n\t\t\tans = min(ans, min(dist[0][i][0],dist[0][i][1]));\n\t\t}\n\t\tif (ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nchar map[60][30];\n\nclass Trl\n{\npublic:\n\tint lx, ly, rx, ry, c;\n\tbool n;\n\tTrl(int lx, int ly, int rx, int ry, int c, bool n)\n\t\t: lx(lx), ly(ly), rx(rx), ry(ry), c(c), n(n) {}\n\tbool operator<(const Trl& t) const\n\t{\n\t\treturn c > t.c;\n\t}\n};\n\nbool v[60][30][60][30];\nint dx[] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nint dy[] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\n\nint main()\n{\n\tint W, H;\n\twhile (cin >> W >> H, W||H)\n\t{\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tcin >> map[y][x];\n\n\t\tmemset(v, 0, sizeof(v));\n\t\tpriority_queue<Trl> q;\n\t\t\n\t\tfor (int y=0; y<H; y++)\n\t\tfor (int x=0; x<W; x++)\n\t\t\tif (map[y][x] == 'S')\n\t\t\t{\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 1));\n\t\t\t\tq.push(Trl(x, y, x, y, 0, 0));\n\t\t\t}\n\t\tbool f = 0;\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tTrl t = q.top(); q.pop();\n\n\t\t\tif (v[t.ly][t.lx][t.ry][t.rx]) continue;\n\t\t\tv[t.ly][t.lx][t.ry][t.rx] = 1;\n\n\t\t\tif (map[t.ly][t.lx]=='T' || map[t.ry][t.rx]=='T')\n\t\t\t{\n\t\t\t\tcout << t.c << endl;\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0; i<9; i++)\n\t\t\t{\n\t\t\t\tint nx, ny;\n\t\t\t\tTrl ne = t;\n\t\t\t\tif (t.n)\n\t\t\t\t{\n\t\t\t\t\tnx = t.lx + dx[i];\n\t\t\t\t\tny = t.ly + dy[i];\n\t\t\t\t\tne.rx = nx;\n\t\t\t\t\tne.ry = ny;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnx = t.rx - dx[i];\n\t\t\t\t\tny = t.ry - dy[i];\n\t\t\t\t\tne.lx = nx;\n\t\t\t\t\tne.ly = ny;\n\t\t\t\t}\n\n\t\t\t\tif (nx<0||nx>=W||ny<0||ny>=H) continue;\n\t\t\t\tif (map[ny][nx] == 'X') continue;\n\n\t\t\t\tif (map[ny][nx] != 'T' && map[ny][nx] != 'S')\n\t\t\t\t\tne.c += map[ny][nx] - '0';\n\t\t\t\t\n\t\t\t\tne.n = !ne.n;\n\t\t\t\tif (v[ne.ly][ne.lx][ne.ry][ne.rx]) continue;\n\t\t\t\tq.push(ne);\n\t\t\t}\n\t\t}\n\n\t\tif (!f)\n\t\t\tcout << -1 << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[33][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint mincost[2][33][33];\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[(lr+1)%2][ny][nx]) {\n\t  mincost[(lr+1)%2][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, (lr+1)%2), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 61\n#define MAX_W 31\n#define INF 1e9\n#define Fi first\n#define Se second\ntypedef pair<int,int> pii;\n\nstruct State{\n  int d,lx,ly,rx,ry;\n  bool f;\n  State(){}\n  State(int d,int lx,int ly,int rx,int ry,bool f) :\n    d(d),lx(lx),ly(ly),rx(rx),ry(ry),f(f) {}\n  bool operator > (const State &s)const{\n    return d > s.d;\n  }\n};\n\nint W,H;\nint ps,pt;\npii S[MAX_W],T[MAX_W];\nchar field[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W][MAX_H][MAX_W][2];\n\nconst int dx[9] = {1,1,1,1,1,2,2,2,3};\nconst int dy[9] = {-2,-1,0,1,2,-1,0,1,0};\n\nbool inField(int x,int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  fill(dist[0][0][0][0],dist[0][0][0][0]+MAX_H*MAX_W*MAX_H*MAX_W*2,INF);\n  for(int i = 0 ; i < ps ; i++){\n    Q.push(State(0,S[i].Fi,S[i].Se,W,H,0)); \n    Q.push(State(0,W,H,S[i].Fi,S[i].Se,1));\n    dist[S[i].Se][S[i].Fi][H][W][0] = 0;\n    dist[H][W][S[i].Se][S[i].Fi][1] = 0;\n  }\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int lx = s.lx, ly = s.ly;\n    int rx = s.rx, ry = s.ry;\n\n    if(dist[ly][lx][ry][rx][s.f] < s.d) continue;\n    for(int i = 0 ; i < pt ; i++){\n      if(lx == T[i].Fi && ly == T[i].Se ||\n         rx == T[i].Fi && ry == T[i].Se){\n        return s.d;\n      }\n    }\n    if(s.f){\n      for(int i = 0 ; i < 9 ; i++){\n        int nlx = rx - dx[i];\n        int nly = ry + dy[i];\n        if(!inField(nlx,nly)) continue;\n        if(field[nly][nlx] == 'X') continue;\n        int t = field[nly][nlx] - '0';\n        if(s.d + t < dist[nly][nlx][ry][rx][0]){\n          dist[nly][nlx][ry][rx][0] = s.d + t;\n          Q.push(State(dist[nly][nlx][ry][rx][0],nlx,nly,rx,ry,0));\n        }\n      }\n    }else{\n      for(int i = 0 ; i < 9 ; i++){\n        int nrx = lx + dx[i];\n        int nry = ly + dy[i];\n        if(!inField(nrx,nry)) continue;\n        if(field[nry][nrx] == 'X') continue;\n        int t = field[nry][nrx] - '0';\n        if(s.d + t < dist[ly][lx][nry][nrx][1]){\n          dist[ly][lx][nry][nrx][1] = s.d + t;\n          Q.push(State(dist[ly][lx][nry][nrx][1],lx,ly,nrx,nry,1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  dijkstra();\n  while(cin >> W >> H, W){\n    ps = pt = 0;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'S'){\n          S[ps++] = pii(j,i);\n          field[i][j] = '0';\n        }else if(field[i][j] == 'T'){\n          T[pt++] = pii(j,i);\n          field[i][j] = '0';      \n        }\n      }\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\nint w,h;\nchar board[61][30];\ntypedef tuple< ll, ll, PII> State;\nconst ll INF = 1e15;\nll dijkstra(){\n  ll res = INF;\n  ll dist[h][w][2];\n  rep(a,h)rep(b,w)rep(c,2) dist[a][b][c] = INF;\n  priority_queue< State, vector<State>, greater<State>> que;\n  rep(i,w){\n    if(board[h-1][i] == 'S'){\n      que.push(State(0,1,{h-1,i}));\n      que.push(State(0,0,{h-1,i}));\n    }\n  }\n\n  while(que.empty() == false){\n    State s = que.top(); que.pop();\n    ll cdist = get<0>(s);\n    ll cturn = get<1>(s);\n    PII current = get<2>(s);\n    int ci = current.first, cj = current.second;\n\n    if(dist[ci][cj][cturn] < cdist) continue;\n    if(board[ci][cj] == 'T') res = min(cdist,res);\n    if(cturn == 0){//左足を動かす\n      FOR(i,ci-3, ci+4) FOR(j,cj-4,cj){\n        if(i >= 0 && j >= 0 && i < h && j < w &&\n          (abs(ci - i) + abs(cj - j) <= 3) && board[i][j] != 'X'){\n\n            ll cost = 0;\n            if(board[i][j]!= 'T' && board[i][j]!= 'S') cost += board[i][j] - '0';\n            if( dist[i][j][1] > cdist + cost){\n              dist[i][j][1] = cdist + cost;\n              que.push(State(cdist+cost,1,{i,j}));\n            }\n          }\n        }\n    }else{\n      FOR(i,ci-3, ci+4) FOR(j,cj+1,cj+4){\n        if(i >= 0 && j >= 0 && i < h && j < w &&\n          (abs(ci - i) + abs(cj - j)) <= 3 && board[i][j] != 'X'){\n            ll cost = 0;\n            if(board[i][j]!= 'T' && board[i][j]!= 'S') cost += board[i][j] - '0';\n            if( dist[i][j][0] > cdist + cost){\n              dist[i][j][0] = cdist + cost;\n              que.push(State(cdist+cost,0,{i,j}));\n            }\n          }\n        }\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  ll ans = dijkstra();\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  while(true){\n    cin >> w >> h;\n    if( w == 0 && h == 0) break;\n    rep(i,h)rep(j,w) cin >> board[i][j];\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<28;\n\nstruct feet {\n\tint x, y, p, cnt;\n\tfeet(int a, int b, int c, int d): x(a), y(b), p(c), cnt(d) {};\n\tbool operator >(feet const &a) const {\n\t\treturn cnt > a.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, greater<feet> > pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tif(field[i][j] == 11) {\n\t\t\t\t\tfeet f(j, i, 0, 0);\n\t\t\t\t\tpq.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.x < 0 || w-1 < f.x || f.y < 0 || h-1 < f.y) continue;\n\t\t\tif(field[f.y][f.x] == 10) continue;\n\t\t\tif(field[f.y][f.x] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\tfeet temp(f.x+i+1, f.y+j, 2, f.cnt+field[f.y+j][f.x+i+1]);\n\t\t\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\tfeet temp(f.x+i-1, f.y+j, 1, f.cnt+field[f.y+j][f.x+i-1]);\n\t\t\t\t\t\tstring chk = to_string(temp.x) + to_string(temp.y) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2017/07/09\n *      Author: aihara\n */\n#include <bits/stdc++.h>\n//#define MYDEBUG\n#ifdef MYDEBUG\n#define dbp(a) cout<<#a<<\": \"<<a<<endl\n#define dbp2(a,b) cout<<#a<<\",\"<<#b<<\": \"<<a<<\",\"<<b<<endl\n#define dbp3(a,b,c) cout<<#a<<\",\"<<#b<<\",\"<<#c<<\": \"<<a<<\",\"<<b<<\",\"<<c<<endl\n#define dbp4(a,b,c,d) cout<<#a<<\",\"<<#b<<\",\"<<#c<<\",\"<<#d<<\": \"<<a<<\",\"<<b<<\",\"<<c<<\",\"<<d<<endl\n#else\n#define dbp(a)\n#define dbp2(a,b)\n#define dbp3(a,b,c)\n#define dbp4(a,b,c,d)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i,from,to) for(ll i=from; i<to; ++i)\n#define REP(i,from,to) for(ll i=from; i<=to; ++i)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const pair<T, T>& p) {\n\tcout << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn out;\n}\n\nstruct edge {\n\tint from, to, cost;\n\tedge(int f, int t, int c) {\n\t\tfrom = f;\n\t\tto = t;\n\t\tcost = c;\n\t}\n\tedge() {\n\t\tfrom = -1;\n\t\tto = -1;\n\t\tcost = -1;\n\t}\n\tbool operator<(const edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nstruct vertex {\n\tint id, w, h, foot, cost; //foot: 0(left), 1(right)\n\tvertex(int id_, int w_, int h_, int foot_, int cost_) {\n\t\tid = id_;\n\t\tw = w_;\n\t\th = h_;\n\t\tfoot = foot_;\n\t\tcost = cost_;\n\t}\n\tvertex() {\n\t\tid = 0;\n\t\tw = 0;\n\t\th = 0;\n\t\tfoot = 0;\n\t\tcost = 0;\n\t}\n};\n\ntypedef struct edge edge;\ntypedef struct vertex vertex;\n\nostream& operator<<(ostream& out, const edge& e) {\n\tcout << \"(\" << e.from << \"->\" << e.to << \": \" << e.cost << \")\";\n\treturn out;\n}\nostream& operator<<(ostream& out, const vertex& v) {\n\tcout << \"<\" << v.id << \",\" << v.w << \",\" << v.h << \",\" << v.foot << \",\"\n\t\t\t<< v.cost << \">\";\n\treturn out;\n}\nstatic const int MAX_W = 32;\nstatic const int MAX_H = 62;\nstatic const int MAX_V = MAX_W * MAX_H * 2; //Left, Right\nstatic const int INF = 1e9 + 10000;\nstatic const int LEFT = 0;\nstatic const int RIGHT = 1;\nvector<edge> g[MAX_V];\nvector<vector<vertex> > v[2];\nint d[MAX_V];\nint w, h;\nint id;\nint Ldi[9] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\nint Ldj[9] = { -1, -1, -1, -1, -1, -2, -2, -2, -3 };\nint Rdi[9] = { -2, -1, 0, 1, 2, -1, 0, 1, 0 };\nint Rdj[9] = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\nint di[2][9] = { { -2, -1, 0, 1, 2, -1, 0, 1, 0 }, { -2, -1, 0, 1, 2, -1, 0, 1,\n\t\t0 } };\nint dj[2][9] = { { -1, -1, -1, -1, -1, -2, -2, -2, -3 }, { 1, 1, 1, 1, 1, 2, 2,\n\t\t2, 3 } };\nvector<vertex> start;\nvector<vertex> goal;\nvoid init() {\n\tid = 0;\n\trep(i, 0, MAX_V)\n\t{\n\t\tg[i] = vector<edge>();\n\t}\n\tv[0] = vector<vector<vertex> >();\n\tv[1] = vector<vector<vertex> >();\n\tstart = vector<vertex>();\n\tgoal = vector<vertex>();\n}\n\nint swapfoot(int foot) {\n\tif (foot == LEFT) {\n\t\treturn RIGHT;\n\t} else {\n\t\treturn LEFT;\n\t}\n}\n\nbool ok(int ni, int nj, int nfoot) {\n\tif (0 <= ni && ni < h && 0 <= nj && nj < w) {\n\t\tif (v[nfoot][ni][nj].cost != -1) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvoid enumerate(vertex &vx, int i, int j) {\n\tint nfoot = swapfoot(vx.foot);\n\trep(k,0,9)\n\t{\n\t\tint ni = i + di[nfoot][k];\n\t\tint nj = j + dj[nfoot][k];\n\t\tif (ok(ni, nj, nfoot)) {\n\t\t\tvertex &nv = v[nfoot][ni][nj];\n\t\t\tedge e(vx.id, nv.id, nv.cost);\n\t\t\tdbp(e);\n\t\t\tg[vx.id].push_back(e);\n\t\t}\n\t}\n}\n\nvoid dijkstra(int r) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\td[r] = 0;\n\tque.push(P(0, r));\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tfor (size_t i = 0; i < g[v].size(); ++i) {\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\twhile (cin >> w >> h, w || h) {\n\t\tinit();\n\t\tv[0] = vector<vector<vertex> >(h);\n\t\tv[1] = vector<vector<vertex> >(h);\n\t\trep(i,0,h)\n\t\t{\n\t\t\tv[0][i] = vector<vertex>(w);\n\t\t\tv[1][i] = vector<vertex>(w);\n\t\t\trep(j,0,w)\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tint cost = c - '0';\n\t\t\t\tif (c == 'X') {\n\t\t\t\t\tcost = -1;\n\t\t\t\t}\n\t\t\t\tif (c == 'S' || c == 'T') {\n\t\t\t\t\tcost = 0;\n\n\t\t\t\t}\n\n//\t\t\tdbp2(c, cost);\n\t\t\t\tvertex vl(id, i, j, LEFT, cost);\n\t\t\t\tid++;\n\t\t\t\tvertex vr(id, i, j, RIGHT, cost);\n\t\t\t\tid++;\n\t\t\t\tv[LEFT][i][j] = vl;\n\t\t\t\tv[RIGHT][i][j] = vr;\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tstart.push_back(vl);\n\t\t\t\t\tstart.push_back(vr);\n\t\t\t\t}\n\t\t\t\tif (c == 'T') {\n\t\t\t\t\tgoal.push_back(vl);\n\t\t\t\t\tgoal.push_back(vr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//debug v\n//\tREP(foot, 0, 1)\n//\t{\n//\t\trep(i,0,h)\n//\t\t{\n//\t\t\trep(j,0,w)\n//\t\t\t{\n//\t\t\t\tdbp4(foot, i, j, v[foot][i][j]);\n//\t\t\t}\n//\t\t}\n//\t}\n\t\t//enumerate\n//\twhile (true) {\n//\t\tint f, i, j;\n//\t\tcin >> f >> i >> j;\n//\t\tenumerate(v[f][i][j], i, j);\n//\t}\n\t\trep(i,0,h)\n\t\t{\n\t\t\trep(j,0,w)\n\t\t\t{\n\t\t\t\tenumerate(v[LEFT][i][j], i, j);\n\t\t\t\tenumerate(v[RIGHT][i][j], i, j);\n\t\t\t}\n\t\t}\n\t\trep(i,0,id)\n\t\t{\n\t\t\tdbp2(i, g[i]);\n\t\t}\n\t\tfill(d, d + MAX_V, INF);\n\t\trep(i,0, (int)start.size())\n\t\t{\n\t\t\tvertex &r = start[i];\n\t\t\tdbp(r);\n\t\t\tdijkstra(r.id);\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, (int)goal.size())\n\t\t{\n\t\t\tvertex &gg = goal[i];\n\t\t\tdbp2(gg, d[gg.id]);\n\t\t\tans = min(ans, d[gg.id]);\n\t\t}\n\t\tif (ans == INF) {\n\t\t\tans = -1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, std::numeric_limits<T>::max());\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint dr[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nint dc[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int w, h; cin >> w >> h;\n    if(w == 0) break;\n    vvi s(h, vi(w, 0));\n    vi str, stc, edr, edc;\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        char tmp; cin >> tmp;\n        if(tmp == 'S') {\n          str.push_back(i);\n          stc.push_back(j);\n        } else if(tmp == 'T') {\n          edr.push_back(i);\n          edc.push_back(j);\n        } else if(tmp == 'X') {\n          s[i][j] = INF;\n        } else {\n          s[i][j] = static_cast<int>(tmp - '0');\n        }\n      }\n    }\n    Graph<int> g(h*w*2);\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        for(int k=0;k<2;++k) {\n          for(int l=0;l<9;++l) {\n            int nr = i + dr[l], nc = j + (k == 0 ? 1 : -1) * dc[l];\n            if(!(0 <= nr && nr < h && 0 <= nc && nc < w) || s[nr][nc] == INF) continue;\n            g[2*w*i + 2*j + k].push_back(Edge<int>(2*w*i + 2*j + k, 2*w*nr + 2*nc + 1 - k, s[nr][nc]));\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<(int)(str.size());++i) {\n      vector<int> dist1 = dijkstra(g, 2*w*str[i] + 2*stc[i]);\n      vector<int> dist2 = dijkstra(g, 2*w*str[i] + 2*stc[i] + 1);\n      for(int j=0;j<(int)(edr.size());++j) {\n        ans = min(ans, dist1[2*w*edr[j] + 2*edc[j]]);\n        ans = min(ans, dist2[2*w*edr[j] + 2*edc[j]]);\n        ans = min(ans, dist1[2*w*edr[j] + 2*edc[j] + 1]);\n        ans = min(ans, dist2[2*w*edr[j] + 2*edc[j] + 1]);\n      }\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nint w, h;\nchar s[33][33];\n\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nconst int inf = 1 << 25;\n\nint dijkstra()\n{\n  int mincost[2][33][33];\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      mincost[0][i][j] = inf;\n      mincost[1][i][j] = inf;\n    }\n  }\n  priority_queue<PP, vector<PP>, greater<PP> > que;  \n  for(int i = 0; i < w; i++) {\n    if(s[h-1][i] == 'S') {\n      que.push(PP(P(0, 0), P(i, h-1))); mincost[0][h-1][i] = 0;\n      que.push(PP(P(0, 1), P(i, h-1))); mincost[1][h-1][i] = 0;\n    }\n  }\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int c = p.first.first, lr = p.first.second;\n    int x = p.second.first, y = p.second.second;\n    if(s[y][x] == 'T') return c;\n    if(mincost[lr][y][x] < c) continue;\n    for(int i = 0; i < 9; i++) {\n      int nx = x + (lr ? dx[i] : -dx[i]), ny = y + dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && s[ny][nx] != 'X') {\n\tint d = isdigit(s[ny][nx]) ? s[ny][nx]-'0' : 0;\n\tif(c + d < mincost[!lr][ny][nx]) {\n\t  mincost[!lr][ny][nx] = c + d;\n\t  que.push(PP(P(c + d, !lr), P(nx, ny)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h) {\n    memset(s, 0, sizeof(s));\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> s[i][j];\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n// g++ -std=c++14 main.cpp\n//\n\n//#include \"main.hpp\"\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nll inf = 1e9, d[4000], w, h;\nvector<pair<ll, ll> > G[4000];\n// goto, cost\n\nvoid dijkstra(ll s) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + 2 * w * h, inf);\n    d[s] = 0;\n    que.push(P(0, s));\n    \n    while (!que.empty()) {\n        P p = que.top();  que.pop();\n        ll v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n            P e = G[v][i];\n            if (d[e.first] > d[v] + e.second) {\n                d[e.first] = d[v] + e.second;\n                que.push(P(d[e.first], e.first));\n            }\n        }\n    }\n}\n\nint main(void){\n    while (cin >> w >> h) {\n        for (int i = 0; i < 4000; i++) G[i].clear();\n        \n        if (w * h == 0) return 0;\n        \n        vector<int> start, goal;\n        int s[100][100] = {};\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c[1];\n                cin >> c;\n                if (c[0] == 'S') {\n                    start.push_back(i * w + j);\n                    s[i][j] = 0;\n                }\n                else if (c[0] == 'T') {\n                    goal.push_back(i * w + j);\n                    s[i][j] = 0;\n                }\n                else if (c[0] == 'X') s[i][j] = inf;\n                else s[i][j] = int(c[0] - '0');\n            }\n        }\n        \n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                // left: + 0, right: + w * h\n                for (int p = i - 3; p <= i + 3; p++) {\n                    for (int q = j - 3; q <= j + 3; q++) {\n                        if (p < 0 || p >= h || q < 0 || q >= w) ;\n                        else if (q < j && abs(p - i) + abs(q - j) <= 3) {\n                            // right -> left\n                            if (s[p][q] != inf)\n                            G[i * w + j + w * h].emplace_back(p * w + q, s[p][q]);\n                        }\n                        else if (q > j && abs(p - i) + abs(q - j) <= 3) {\n                            // left -> right\n                            if (s[p][q] != inf)\n                            G[i * w + j].emplace_back(p * w + q + w * h, s[p][q]);\n                        }\n                    }\n                }\n            }\n        }\n        \n        /*\n        for (int i = 0; i <  w * h * 2; i++) {\n            cout << i << \" \" ;\n            for (int j = 0; j < G[i].size(); j++) cout << G[i][j].first << \" \" << G[i][j].second << \" \";\n            cout << endl;\n        }*/\n        \n        ll ans = inf;\n        for (int i = 0; i < start.size(); i++) {\n            dijkstra(start[i]);\n            for (int j = 0; j < goal.size(); j++) {\n                ans = min(ans, d[goal[j]]);\n                ans = min(ans, d[goal[j] + w * h]);\n            }\n            dijkstra(start[i] + w * h);\n            for (int j = 0; j < goal.size(); j++) {\n                ans = min(ans, d[goal[j]]);\n                ans = min(ans, d[goal[j] + w * h]);\n            }\n        }\n        \n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}\n\n/*\n g++ -std=c++14 main.cpp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint INF = 1'000'000'000;\ntypedef tuple<double, int, int> T;\n\nint main(){\n    while (1){\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) break;\n        priority_queue<T, vector<T>, greater<T>> que_left;\n        priority_queue<T, vector<T>, greater<T>> que_right;\n        vector<vector<char>> clif(h, vector<char>(w));\n        int t = 0;\n        int left = 0;\n        int right = 1;\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                cin >> clif[i][j];\n                if (clif[i][j] == 'S'){\n                    int pos = i * 100 + j;\n                    que_left.push(tie(t, left, pos));\n                    que_right.push(tie(t, right, pos));\n                }\n            }\n        }\n        vector<vector<bool>> check_left(h, vector<bool>(w, false));\n        vector<vector<bool>> check_right(h, vector<bool>(w, false));\n\n        int ans = INF;\n        while(que_left.size()){\n            int d = get<0>(que_left.top());\n            int mode = get<1>(que_left.top());\n            int x = get<2>(que_left.top());\n            int y = x % 100; x /= 100;\n            que_left.pop();\n            if (mode == 0 && check_left[x][y]) continue;\n            if (mode == 1 && check_right[x][y]) continue;\n            if (clif[x][y] == 'T'){\n                ans = d;\n                break;\n            }\n            if (mode == 0){\n                check_left[x][y] = true;\n                for (int i = -2; i < 3; i++){\n                    for (int j = 1; j <= 3; j++){\n                        if ((abs(i) + j) > 3) continue;\n                        if (0 <= x + i && x + i < h && 0 <= y + j && y + j < w && clif[x+i][y+j] != 'X'){\n                            int nmode = 1;\n                            int nx = x + i;\n                            int ny = y + j;\n                            int nd = d;\n                            if (clif[nx][ny] != 'S' && clif[nx][ny] != 'T') nd += (clif[nx][ny] - '0');\n                            nx *= 100;\n                            nx += ny;\n                            que_left.push(tie(nd, nmode, nx));\n                        }\n                    }\n                }\n            }\n            else {\n                check_right[x][y] = true;\n                for (int i = -2; i < 3; i++){\n                    for (int j = -3; j < 0; j++){\n                        if (abs(i) + abs(j) > 3) continue;\n                        if (0 <= x + i && x + i < h && 0 <= y + j && y + j < w && clif[x+i][y+j] != 'X'){\n                            int nmode = 0;\n                            int nx = x + i;\n                            int ny = y + j;\n                            int nd = d;\n                            if (clif[nx][ny] != 'S' && clif[nx][ny] != 'T') nd += (clif[nx][ny] - '0');\n                            nx *= 100;\n                            nx += ny;\n                            que_left.push(tie(nd, nmode, nx));\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                check_left[i][j] = false;\n                check_right[i][j] = false;\n            }\n        }\n\n        while(que_right.size()){\n            int d = get<0>(que_right.top());\n            int mode = get<1>(que_right.top());\n            int x = get<2>(que_right.top());\n            int y = x % 100; x /= 100;\n            que_right.pop();\n            if (mode == 0 && check_left[x][y]) continue;\n            if (mode == 1 && check_right[x][y]) continue;\n            if (clif[x][y] == 'T'){\n                ans = min(ans, d);\n                break;\n            }\n            if (mode == 0){\n                check_left[x][y] = true;\n                for (int i = -2; i < 3; i++){\n                    for (int j = 1; j <= 3; j++){\n                        if ((abs(i) + j) > 3) continue;\n                        if (0 <= x + i && x + i < h && 0 <= y + j && y + j < w && clif[x+i][y+j] != 'X'){\n                            int nmode = 1;\n                            int nx = x + i;\n                            int ny = y + j;\n                            int nd = d;\n                            if (clif[nx][ny] != 'S' && clif[nx][ny] != 'T') nd += (clif[nx][ny] - '0');\n                            nx *= 100;\n                            nx += ny;\n                            que_right.push(tie(nd, nmode, nx));\n                        }\n                    }\n                }\n            }\n            else {\n                check_right[x][y] = true;\n                for (int i = -2; i < 3; i++){\n                    for (int j = -3; j < 0; j++){\n                        if (abs(i) + abs(j) > 3) continue;\n                        if (0 <= x + i && x + i < h && 0 <= y + j && y + j < w && clif[x+i][y+j] != 'X'){\n                            int nmode = 0;\n                            int nx = x + i;\n                            int ny = y + j;\n                            int nd = d;\n                            if (clif[nx][ny] != 'S' && clif[nx][ny] != 'T') nd += (clif[nx][ny] - '0');\n                            nx *= 100;\n                            nx += ny;\n                            que_right.push(tie(nd, nmode, nx));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (ans != INF) cout << ans << endl;\n        else cout << -1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\nint dy[] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvector<vi> fld(h, vi(w));\n\t\tvi st, go;\n\t\tmap<pii, int> mp;\n\t\tmp[pii(-1, -1)] = -1;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'X') fld[i][j] = INF;\n\t\t\telse if (c == 'S')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tst.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse if (c == 'T')\n\t\t\t{\n\t\t\t\tfld[i][j] = 0;\n\t\t\t\tgo.push_back(place(i, j, w));\n\t\t\t}\n\t\t\telse fld[i][j] = c - '0';\n\t\t}\n\t\tvi goal;\n\t\tGraph g(1);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tif (find(ALL(st), left) != st.end() || find(ALL(st), right) != st.end())\n\t\t\t\t{\n\t\t\t\t\tg[0].push_back(edge{ (int)mp.size(), max(fld[i][j], fld[rx][ry]) });\n\t\t\t\t}\n\t\t\t\tif (find(ALL(go), left) != go.end() || find(ALL(go), right) != go.end())\n\t\t\t\t{\n\t\t\t\t\tgoal.push_back(mp.size());\n\t\t\t\t}\n\t\t\t\tmp[pii(left, right)] = mp.size();\n\t\t\t}\n\t\t}\n\t\tg.resize(mp.size());\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tint left = place(i, j, w);\n\t\t\tREP(k, 9)\n\t\t\t{\n\t\t\t\tint rx = i + dx[k], ry = j + dy[k];\n\t\t\t\tif (!valid(rx, ry, h, w)) continue;\n\t\t\t\tint right = place(rx, ry, w);\n\t\t\t\tint now = mp[pii(left, right)];\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(left, place(nx, ny, w))];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t\tREP(l, 9)\n\t\t\t\t{\n\t\t\t\t\tint nx = rx + dx[l], ny = ry - dy[l];\n\t\t\t\t\tif (!valid(nx, ny, h, w)) continue;\n\t\t\t\t\tint next = mp[pii(place(nx, ny, w), right)];\n\t\t\t\t\tg[now].push_back(edge{ next, fld[nx][ny] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<weight> d;\n\t\tdijkstra(g, d, 0);\n\t\tint ans = INF;\n\t\tREP(i, goal.size()) chmin(ans, d[goal[i]]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<sstream>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<deque>\n#include<queue>\n#include<climits>\n#include<list>\n#include<stack>\n#include<ctime>\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define insert(a,b,c,d) PIB(P(a,b),IB(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define INF (1<<27)\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,bool> IB;\ntypedef pair<P,IB> PIB;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int left_dx[9] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\nconst int left_dy[9] = {-2,-1,+0,+1,+2,-1,+0,+1,+0};\nconst int right_dx[9] = {+1,+1,+1,+1,+1,+2,+2,+2,+3};\nconst int right_dy[9] = {-2,-1,0,+1,+2,-1,+0,+1,+0};\n\n\nclass Solve{\n private:\n  int w,h;\n  int d[61][31][2]; // 0->left, 1->right\n  char cmap[61][31];\n public:\n  Solve(int w,int h):w(w),h(h){\n    rep(i,h)rep(j,w)rep(k,2)d[i][j][k] = INT_MAX;\n  }\n  ~Solve(){}\n\n  void input(){\n    rep(i,h)\n      rep(j,w)\n      cin >> cmap[i][j];\n  }\n\n  void printAll(){\n    cout << endl << \"### START ###\" << endl;\n    cout << \"w = \" << w << \",h = \" << h << endl;\n    cout << \"cmap --- \" << endl;\n    rep(i,h){\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n    cout << \"d_left --- \"<< endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][0] != INT_MAX)cout << d[i][j][0] << ' ';\n\telse cout << \"0 \";\n      }\n      cout << endl;\n    }\n\n    cout << endl << \"d_right --- \"<< endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][1] != INT_MAX)cout << d[i][j][1] << ' ';\n\telse cout << \"0 \";\n      }\n      cout << endl;\n    }\n    cout << endl << \"comb---\" << endl;\n    rep(i,h){\n      rep(j,w){\n\tif(d[i][j][0] == INT_MAX && d[i][j][1] != INT_MAX)cout << d[i][j][1] << ' ';\n\telse if(d[i][j][0] != INT_MAX && d[i][j][1] == INT_MAX)cout << d[i][j][0] << \" \";\n\telse if(d[i][j][0] != INT_MAX && d[i][j][1] != INT_MAX)cout << min(d[i][j][0],d[i][j][1]) << ' ';\n\telse cout << 0 << ' ';\n      }\n      cout << endl;\n    }\n    cout << \"### END ###\" << endl << endl;\n  }\n\n  void run(){\n    input();\n    deque<PIB> deq; // bool true->left,false->right\n    rep(i,w){\n      if(cmap[h-1][i] != 'S')continue;\n      d[h-1][i][1] = d[h-1][i][0] = 0; // %%%\n      deq.pb(insert(i,h-1,0,1));      \n      deq.pb(insert(i,h-1,0,0));\n    }\n\n    while(!deq.empty()){\n      PIB pib = deq.front(); deq.pop_front();\n      if(cmap[pib.F.S][pib.F.F] == 'T'){\n\tint lr = pib.S.S==0?0:1;\n\td[pib.F.S][pib.F.F][lr] = min(d[pib.F.S][pib.F.F][lr],pib.S.F);\n\tcontinue;\n      }\n     \n\n      P p = pib.F;\n      int LR = pib.S.S==0?0:1;\n      int rLR = LR == 0?1:0;\n      rep(i,9){\n\tint nx,ny;\n\tif(LR == 0)nx = p.F+right_dx[i],ny = p.S+right_dy[i];\n\telse nx = p.F+left_dx[i],ny = p.S+left_dy[i];\n\n\tif(!(0<= nx && nx < w && 0<= ny && ny < h))continue;\n\tif(cmap[ny][nx] == 'X')continue;\n\tint cost;\n\tif(cmap[ny][nx] == 'T')cost = 0;\n\telse cost = (cmap[ny][nx]-'0');\n\tif(d[ny][nx][rLR] <= cost+pib.S.F)continue;\n\td[ny][nx][rLR] =  cost+pib.S.F;\n\tif(deq.front().S.F < d[ny][nx][rLR])deq.pb(insert(nx,ny,d[ny][nx][rLR],rLR));\n\telse deq.pf(insert(nx,ny,d[ny][nx][rLR],rLR));  \n \n      }\n    }\n\n    output();\n\n  }\n  \n  void output(){\n    int MIN = INT_MAX;\n    rep(i,w){\n      if(cmap[0][i] == 'T')MIN = min(MIN,min(d[0][i][1],d[0][i][0]));\n    }\n    if(MIN != INT_MAX)cout << MIN << endl;\n    else cout << -1 << endl;\n  }\n\n\n};\n\nint main(){\n  int _w,_h;\n  while(cin >> _w >> _h && _w+_h){\n    Solve ans = Solve(_w,_h);\n    ans.run();\n    //ans.printAll();\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nbool ischecked[61][61][2];\nchar cliff[61][61];\nint tesu[61][61][2];\nint w, h;\n\nint dy[2][9] = {{1, 1, 1, 1, 1, 2, 2, 2, 3}, {-1, -1, -1, -1, -1, -2, -2, -2, -3}};\nint dx[9] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\ntypedef struct Data\n{\n    int x;\n    int y;\n    int isnowleft;\n} d;\n\nint solve(int isleft, int sx, int sy)\n{\n    int ans = 1000000;\n    queue<d> qu;\n    d tmp;\n    tmp.x = sx;\n    tmp.y = sy;\n    tmp.isnowleft = isleft;\n    qu.push(tmp);\n    while(!qu.empty()){\n        d top = qu.front();\n        qu.pop();\n        int x = top.x;\n        int y = top.y;\n        int isnowleft = top.isnowleft;\n        // cout << x << \" \" << y << \" \" << tesu[x][y][isnowleft] << \" \" << isnowleft << endl;\n        for(int i = 0; i < 9; i++){\n            int nx = x + dx[i];\n            int ny = y + dy[isnowleft][i];\n            if(nx < 0 || ny < 0 || nx >= h || ny >= w || cliff[nx][ny] == 'X') continue;\n            if(cliff[nx][ny] == 'T') ans = min(tesu[x][y][isnowleft], ans);\n            // else if(cliff[nx][ny] == 'S') solve(!isnowleft, nx, ny, nowtesu);\n            else{\n                d next;\n                next.x = nx;\n                next.y = ny;\n                next.isnowleft = !isnowleft;\n                int nexttesu;\n                if(cliff[nx][ny] == 'S') nexttesu = tesu[x][y][isnowleft];\n                else nexttesu = tesu[x][y][isnowleft] + cliff[nx][ny] - '0';\n                if(nexttesu < tesu[nx][ny][!isnowleft]){\n                    tesu[nx][ny][!isnowleft] = nexttesu;\n                    // ischecked[nx][ny][!isnowleft] = true;\n                    qu.push(next);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        vector<int> sx, sy, tx, ty;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> cliff[i][j];\n                if(cliff[i][j] == 'S'){\n                    sx.push_back(i);\n                    sy.push_back(j);\n                } else if(cliff[i][j] == 'T'){\n                    tx.push_back(i);\n                    ty.push_back(j);\n                }\n            }\n        }\n        // memset(ischecked, false, sizeof(ischecked));\n        memset(tesu, 1000000, sizeof(tesu));\n        int ans = 1000000;\n        for(int i = 0; i < 2; i++){\n            for(int j = 0; j < sx.size(); j++){\n                tesu[sx[j]][sy[j]][i] = 0;\n                // ischecked[sx[j]][sy[j]][i] = true;\n                ans = min(ans, solve(i, sx[j], sy[j]));\n            }\n        }\n        // for(int k = 0; k < 2; k++){\n        //     for(int i = 0; i < h; i++){\n        //             for(int j = 0; j < w; j++){\n        //                 cout << tesu[i][j][k] << \" \";\n        //             }\n        //             cout << endl;\n        //         }\n        //         cout << endl;\n        //     }\n        if(ans == 1000000) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nint field[70][40];\n\nint mintime[70][40][2];\n\nstruct aa {\n\tint time;\n\tint y;\n\tint x;\n\tbool isl;\n\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 70; ++i) {\n\t\t\tfor (int j = 0; j < 40; ++j) {\n\t\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\t\tmintime[i][j][k] = 99999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(field, 0, sizeof(field));\n\t\tint w, h; cin >> w >> h;\n\t\tif (!w)break;\n\t\t\n\t\tvector<pair<int, int>>sts;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0;j < w; ++j) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == 'X') {\n\n\t\t\t\t}\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tfield[i + 5][j + 5] = 100;\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tsts.push_back(make_pair(i + 5, j + 5));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 5][j + 5] = c-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sts.size(); ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tque.push(aa{ 0, sts[i].first, sts[i].second, bool(j) });\n\t\t\t\tmintime[sts[i].first][sts[i].second][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\twhile (que.size()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst bool mover = atop.isl;\n\t\t\tfor (int dy = -2; dy <= 2; ++dy) {\n\t\t\t\tfor (int dx = 1; dx < 4 - abs(dy); ++dx) {\n\t\t\t\t\tif (!mover)dx = -dx;\n\t\t\t\t\tconst int nx = atop.x + dx;\n\t\t\t\t\tconst int ny = atop.y + dy;\n\t\t\t\t\tif (field[ny][nx]) {\n\t\t\t\t\t\tint nt = atop.time;\n\t\t\t\t\t\tif (field[ny][nx] == 100) {\n\t\t\t\t\t\t\tans = min(nt, ans);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnt += field[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mintime[ny][nx][!mover]>nt) {\n\t\t\t\t\t\t\tmintime[ny][nx][!mover] = nt;\n\t\t\t\t\t\t\tque.push(aa{ nt, ny, nx, !mover });\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!mover)dx = -dx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define Y first\n#define X second\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint W,H;\nchar s[65][35];\nint d[65][35][2];\n\nstruct cliffState{\n  int step;\n  int y;\n  int x;\n  int side;\n  cliffState(int _step, int _y, int _x, int _side){\n    step = _step;\n    y = _y;\n    x = _x;\n    side = _side;\n  }\n  bool operator >(const cliffState &e) const{\n    return step > e.step;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>W>>H;\n    if(W==0 || H==0) break;\n    vector< pair<int, int> > iniv;\n    REP(i,0,H){\n      REP(j,0,W){\n        cin>>s[i][j];\n        if(s[i][j]=='S') iniv.push_back(make_pair(i,j));\n      }\n    }\n\n    int ans = INF;\n\n    REP(inipos,0,iniv.size()){/*?????????????????°????????°?????????????????§W???H????????????*/\n      REP(iniside,0,2){\n\n        REP(i,0,H)REP(j,0,W)REP(k,0,2) d[i][j][k] = INF;\n        d[iniv[inipos].Y][iniv[inipos].X][iniside] = 0;\n\n        priority_queue< cliffState, vector<cliffState>, greater<cliffState> > PQ;\n        cliffState cs = cliffState(0,iniv[inipos].Y,iniv[inipos].X,iniside);\n        PQ.push(cs);\n\n        while(!PQ.empty()){\n\n          cliffState nowPos = PQ.top();\n          PQ.pop();\n          if(d[nowPos.y][nowPos.x][nowPos.side] < nowPos.step) continue;\n\n          REP(i,nowPos.y-2,nowPos.y+2+1){\n            if(i < 0 || H <= i) continue;\n            int diff;\n            if(i == nowPos.y-2 || i == nowPos.y+2) diff = 1;\n            else if(i == nowPos.y-1 || i == nowPos.y+1) diff = 2;\n            else diff = 3;\n            if(nowPos.side == 0){\n              REP(j,nowPos.x+1,nowPos.x+diff+1){\n                if(j < 0 || W <= j || i < 0 || H <= i) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }else{\n              REP(j,nowPos.x-diff,nowPos.x){\n                if(j < 0 || W <= j) continue;\n                if(s[i][j] != 'X' && d[i][j][(nowPos.side+1)%2] == INF){\n                  int nstep;\n                  if(s[i][j] != 'S' && s[i][j] != 'T') nstep = nowPos.step + (int)(s[i][j]-'0');\n                  else nstep = nowPos.step;\n                  if(nstep < d[i][j][(nowPos.side+1)%2]){\n                    d[i][j][(nowPos.side+1)%2] = nstep;\n                    cliffState ncs = cliffState(nstep,i,j,(nowPos.side+1)%2);\n                    PQ.push(ncs);\n                  }\n                }\n              }\n            }\n\n          }\n\n        }\n\n        int tans = INF;\n        REP(i,0,H){\n          REP(j,0,W){\n            if(s[i][j] == 'T') tans = min(tans, min(d[i][j][0],d[i][j][1]));\n          }\n        }\n        ans = min(ans,tans);\n\n      }\n    }\n\n    if(ans == INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define exist(c, x) find(all(c), x) != (c).end()\n#define mp(a, b) make_pair(a, b)\nconst int inf = 1 << 28;\nconst int dx[][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1,  0,  0,  0,  1,  1,  2}},\n          dy[][9] = {{ 1,  1,  2, 1, 2, 3, 1, 2, 1}, {-1, -1, -2, -1, -2, -3, -1, -2, -1}};\n\nint w, h;\nvector<vector<int> > cliff;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(){\n    vector<vector<int> > mem;\n    mem.assign(h * 100 + w, vector<int>(h * 100 + w, inf));\n    vector<int> T;\n    rep(j, w)if(cliff[0][j] == 0)T.push_back(j);\n    auto comp = [&](const pair<int, int> &a, const pair<int, int> &b){\n        return mem[a.first][a.second] > mem[b.first][b.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int> >, decltype(comp)> q(comp);\n    rep(k, w)if(cliff[h-1][k] == -1){\n        int st = (h-1) * 100 + k;\n        rep(i, 2)rep(j, 9){\n            int nx = h-1 + dx[i][j], ny = k + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int nxt = nx * 100 + ny;\n                mem[i? nxt: st][i? st: nxt] = cliff[nx][ny];\n                q.push(mp(i? nxt: st, i? st: nxt));\n            }\n        }\n    }\n    int res = inf;\n    while(!q.empty()){\n        pair<int, int> p = q.top(); q.pop();\n        if(exist(T, p.first) || exist(T, p.second)){\n            res = min(res, mem[p.first][p.second]);\n            continue;\n        }\n        if(res <= mem[p.first][p.second])continue;\n        int lx = p.first / 100, ly = p.first % 100, rx = p.second / 100, ry = p.second % 100;\n        rep(i, 2)rep(j, 9){\n            int nx = (i? rx: lx) + dx[i][j], ny = (i? ry: ly) + dy[i][j];\n            if(inrect(nx, ny) && 0 <= cliff[nx][ny]){\n                int cost = mem[p.first][p.second] + cliff[nx][ny], nxt = nx * 100 + ny;\n                if(mem[i? nxt: p.first][i? p.second: nxt] <= cost)continue;\n                mem[i? nxt: p.first][i? p.second: nxt] = cost;\n                q.push(mp(i? nxt: p.first, i? p.second: nxt));\n            }\n        }\n    }\n    return res == inf? -1: res;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        cin.ignore();\n        cliff.assign(h, vector<int>(w, 0));\n        rep(i, h){\n            string in;\n            getline(cin, in);\n            in.erase(remove_if(all(in), [](char c){return c == ' ';}), in.end());\n            rep(j, w)cliff[i][j] = in[j] == 'X'? -2: in[j] == 'S'? -1: in[j] == 'T'? 0: in[j] - '0';\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nstruct State\n{\n    int lx, ly, rx, ry, last, cost;\n};\n\nbool operator<(const State &e, const State &f)\n{\n    return e.cost > f.cost;\n}\n\nint dp[70][40][70][40][2];\nint c[70][40];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n    while (cin >> w >> h, w || h)\n    {\n        vector<P> st, gt;\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                string s;\n                cin >> s;\n                if (s == \"X\")\n                    c[i][j] = INF;\n                else if (s == \"S\")\n                {\n                    c[i][j] = 0;\n                    st.push_back(P(i, j));\n                }\n                else if (s == \"T\")\n                {\n                    c[i][j] = 0;\n                    gt.push_back(P(i, j));\n                }\n                else\n                {\n                    c[i][j] = stoi(s);\n                }\n            }\n        }\n        for (int lx = 0; lx < h; lx++)\n            for (int ly = 0; ly < w; ly++)\n                for (int rx = 0; rx < h; rx++)\n                    for (int ry = 0; ry < w; ry++)\n                    {\n                        dp[lx][ly][rx][ry][0] = INF;\n                        dp[lx][ly][rx][ry][1] = INF;\n                    }\n        priority_queue<State> q;\n        for (auto p : st)\n        {\n            int x = p.first, y = p.second;\n            dp[x][y][h][w][0] = 0;\n            dp[h][w][x][y][1] = 0;\n            q.push(State{x, y, h, w, 0, 0});\n            q.push(State{h, w, x, y, 1, 0});\n        }\n        while (!q.empty())\n        {\n            State st = q.top();\n            q.pop();\n            int lx = st.lx, ly = st.ly, rx = st.rx, ry = st.ry, cost = st.cost;\n            if (st.last == 0)\n            {\n                for (int i = 0; i < h; i++)\n                {\n                    for (int j = ly + 1; j < w; j++)\n                    {\n                        if (c[i][j] == INF)\n                            continue;\n                        if (abs(lx - i) + abs(ly - j) > 3)\n                            continue;\n                        if (dp[lx][ly][i][j][1] != INF)\n                            continue;\n                        dp[lx][ly][i][j][1] = cost + c[i][j];\n                        q.push(State{lx, ly, i, j, 1, cost + c[i][j]});\n                    }\n                }\n            }\n            else\n            {\n                for (int i = 0; i < h; i++)\n                {\n                    for (int j = 0; j < ry; j++)\n                    {\n                        if (c[i][j] == INF)\n                            continue;\n                        if (abs(i - rx) + abs(j - ry) > 3)\n                            continue;\n                        if (dp[i][j][rx][ry][0] != INF)\n                            continue;\n                        dp[i][j][rx][ry][0] = cost + c[i][j];\n                        q.push(State{i, j, rx, ry, 0, cost + c[i][j]});\n                    }\n                }\n            }\n        }\n        int res = INF;\n        for (auto g : gt)\n        {\n            int lx = g.first, ly = g.second;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    res = min(res, dp[lx][ly][i][j][0]);\n                }\n            }\n        }\n        for (auto g : gt)\n        {\n            int rx = g.first, ry = g.second;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    res = min(res, dp[i][j][rx][ry][1]);\n                }\n            }\n        }\n        if (res == INF)\n            cout << -1 << endl;\n        else\n            cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\nstruct xy{\n  int x,y,f;\n  bool operator<(const xy& a)const{\n    return true;\n  }\n};\ntypedef pair<int, xy > P;\n\nint w,h;\nbool in(xy a){\n  if(a.x<0||a.x>=w||a.y<0||a.y>=h) return false;\n  return true;\n}\n\nint main(){\n  int inf = 1<<20;\n  cin >> w >> h;\n  while(w!=0){\n    char st[60][30];\n    char c;\n    int i,j,k;\n    int d[61][31][2];\n    fill(d[0][0],d[60][30],inf);\n    priority_queue<P,vector<P>,greater<P> > q;\n\n    xy v,b;\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> st[j][i];\n\tif(st[j][i]=='S'){\n\t  v.x=j;v.y=i;v.f=0;\n\t  q.push(mp(0,v));\n\t  v.f=1;\n\t  q.push(mp(0,v));\n\t  d[j][i][0]=0;\n\t  d[j][i][1]=0;\n\t}\n      }\n    }\n    int o=inf;\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      v = p.second;\n      if(d[v.x][v.y][v.f] < p.first) continue;\n      if(v.f==0){\n\tfor(i=1;i<=3;i++){\n\t  for(j=-3+i;j<=3-i;j++){\n\t    b.x=v.x+i;b.y=v.y+j;b.f=1;\n\t    if(in(b)){\n\t      if(st[b.x][b.y]=='T'){\n\t\to=min(o,p.first);\n\t      }else{\n\t\tint g;\n\t\tif(st[b.x][b.y]=='S') g=0;\n\t\telse if(st[b.x][b.y]=='X') g=inf;\n\t\telse g=st[b.x][b.y]-'0';\n\t\tif(d[b.x][b.y][b.f] > d[v.x][v.y][v.f]+g){\n\t\t  d[b.x][b.y][b.f] = d[v.x][v.y][v.f]+g;\n\t\t  q.push(mp(d[b.x][b.y][b.f],b));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }else{\n\tfor(i=1;i<=3;i++){\n\t  for(j=-3+i;j<=3-i;j++){\n\t    b.x=v.x-i;b.y=v.y+j;b.f=0;\n\t    if(in(b)){\n\t      if(st[b.x][b.y]=='T'){\n\t\to=min(o,p.first);\n\t      }else{\n\t\tint g;\n\t\tif(st[b.x][b.y]=='S') g=0;\n\t\telse if(st[b.x][b.y]=='X') g=inf;\n\t\telse g=st[b.x][b.y]-'0';\n\t\tif(d[b.x][b.y][b.f] > d[v.x][v.y][v.f]+g){\n\t\t  d[b.x][b.y][b.f] = d[v.x][v.y][v.f]+g;\n\t\t  q.push(mp(d[b.x][b.y][b.f],b));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(o==inf) cout << -1 << endl;\n    else cout << o << endl;\n    cin >> w >> h;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = f.rx = i;\n\t\t\t\tf.ly = f.ry = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tpq.push(f);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PB push_back\nconst int dy[] = { 1,  1,  1,  1,  1,  2,  2,  2,  3};\nconst int dx[] = {-2, -1,  0,  1,  2, -1,  0,  1,  0};\nconst int INF = 1001001001;\nconst int K = 3;\ntypedef pair<int, int> P;\nstruct STATE\n{\n\tint x, y, a, d;\n\tbool operator <(const STATE &t) const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[256][256];\nint d[256][256][2];\nvoid init();\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tinit();\n\t\tw += K; h += K;\n\t\t\n\t\tvector<P> start;\n\t\tfor (int i = K; i < h; i++){\n\t\t\tfor (int j = K; j < w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'S'){\n\t\t\t\t\tstart.PB(P(i, j));\n\t\t\t\t\tgrid[i][j] = 127;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'T'){\n\t\t\t\t\tgrid[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] >= '1' && grid[i][j] <= '9'){\n\t\t\t\t\tgrid[i][j] -= '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tpriority_queue<STATE> que;\n\t\tfor (int i = 0; i < start.size(); i++){\n\t\t\tque.push({start[i].first, start[i].second, 1, 0});\n\t\t\tque.push({start[i].first, start[i].second, -1, 0});\n\t\t}\n\t\tfor (; que.size(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y][st.a == 1] <= st.d) continue;\n\t\t\td[st.x][st.y][st.a == 1] = st.d;\n\t\t\tif (st.d >= res) continue;\n\t\t\tif (grid[st.x][st.y] == 0){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//cout << st.x << \" \" << st.y << endl;\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 9; dir++){\n\t\t\t\tint tx = st.x + dx[dir] * st.a;\n\t\t\t\tint ty = st.y + dy[dir] * st.a;\n\t\t\t\tint ta = -st.a;\n\t\t\t\tint td = st.d + grid[tx][ty];\n\t\t\t\tif (grid[tx][ty] == 'X') continue;\n\t\t\t\tque.push({tx, ty, -st.a, td});\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (res != INF) cout << res << endl;\n\t\telse cout << \"-1\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\nvoid init()\n{\n\tmemset(grid, 'X', sizeof(grid));\n\tfor (int i = 0; i < 256; i++){\n\t\tfor (int j = 0; j < 256; j++){\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint W,H;\nstruct Node{\n\tint x,y,cost,dir;\n\tNode(int p_x,int p_y,int p_c,int p_dir){\n\t\tx=p_x;y=p_y;dir=p_dir;cost=p_c;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.cost>b.cost;\n};\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=W || y>=H) return false;\n\treturn true;\n}\n\nint solve(){\n\tvector<vector<char> > M(H,vector<char>(W));\n\tvector<int> S;\n\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tM[y][x]=c;\n\t\t\tif(c=='S'){\n\t\t\t\tS.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Node> Q;\n\tint cost[2][60][30];\n\tmemset(cost,-1,sizeof(cost));\n\n\tfor(int i=0;i<S.size();i++){\n\t\tQ.push(Node(S[i],H-1,0,0));\n\t\tQ.push(Node(S[i],H-1,0,1));\n\t}\n\twhile(!Q.empty()){\n\t\tNode t=Q.top();\n\t\tQ.pop();\n\t\tif(cost[t.dir][t.y][t.x]>=0) continue;\n\t\tcost[t.dir][t.y][t.x]=t.cost;\n\t\tint mul,next;\n\t\tif(t.dir==0){mul=1;next=1;}\n\t\telse{mul=-1;next=0;}\n\n\t\tfor(int x=1;x<=3;x++){\n\t\t\tfor(int y=-2;y<=2;y++){\n\t\t\t\tif(x+abs(y)>3) continue;\n\t\t\t\tint nx=t.x+x*mul;\n\t\t\t\tint ny=t.y+y;\n\t\t\t\tif(!in(nx,ny)) continue;\n\n\t\t\t\tif(M[ny][nx]=='T') return t.cost;\n\t\t\t\tif(!isdigit(M[ny][nx])) continue;\n\n\t\t\t\tQ.push(Node(nx,ny,t.cost+M[ny][nx]-'0',next));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin>>W>>H){\n\t\tif(W==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <cctype>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx[9] = { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\nconst int dy[9] = { 2, 1, 1, 0, 0, 0, -1, -1, -2 };\n\nint H, W, d[60][30][2]; char M[60][30];\n\nint solve(int sx)\n{\n\tmemset(d, -1, sizeof(d));\n\n\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\tque.push(make_tuple(sx, H - 1, 0)); d[H - 1][sx][0] = 0;\n\tque.push(make_tuple(sx, H - 1, 1)); d[H - 1][sx][1] = 0;\n\n\twhile (!que.empty())\n\t{\n\t\tint x = get<0>(que.top());\n\t\tint y = get<1>(que.top());\n\t\tint s = get<2>(que.top());\n\n\t\tif (s == 0)\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x - dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][1] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][1] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int dir = 0; dir < 9; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t\t\t{\n\t\t\t\t\tif (M[y2][x2] != 'X' && d[y2][x2][0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[y2][x2][0] = d[y][x][s] + (isdigit(M[y2][x2]) ? M[y2][x2] - 48 : 0);\n\n\t\t\t\t\t\tque.push(make_tuple(x2, y2, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < W; i++)\n\t{\n\t\tif (M[0][i] == 'T')\n\t\t{\n\t\t\tif (d[0][i][0] != -1) ret = min(ret, d[0][i][0]);\n\t\t\tif (d[0][i][1] != -1) ret = min(ret, d[0][i][1]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (M[H - 1][i] == 'S')\n\t\t\t{\n\t\t\t\tret = min(ret, solve(i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\n\nconst int w_max = 30;\nconst int h_max = 60;\n\nint stage[w_max][h_max];\nint cost[w_max][h_max][2];\n\nint w, h;\n\ntypedef std::tuple<int, int> S;\nstd::tuple<int, int> can[2][9] =\n{\n\t{\n\t\tS(-3, 0), S(-2, 1), S(-2, 0), S(-2, -1), S(-1, 2), S(-1, 1), S(-1, 0), S(-1, -1), S(-1, -2)\n\t}, \n\t{\n\t\tS(3, 0), S(2, 1), S(2, 0), S(2, -1), S(1, 2), S(1, 1), S(1, 0), S(1, -1), S(1, -2)\n\t}\n};\n\ntypedef std::tuple<int, int, int, bool> T;\nint search(int x, int y, bool migi)\n{\n\tfor ( int k = 0; k < h; ++k ) {\n\t\tfor ( int l = 0; l < w; ++l ) {\n\t\t\tcost[l][k][0] = 0xffff;\n\t\t\tcost[l][k][1] = 0xffff;\n\t\t}\n\t}\n\tcost[x][y][migi] = 0;\n\n\tint min = 0xffff;\n\tstd::priority_queue<std::tuple<T>, std::vector<T>, std::greater<T>> q;\n\tq.push(T(0, x, y, migi));\n\twhile(!q.empty()) {\n\t\tint c = std::get<0>(q.top());\n\t\tint px = std::get<1>(q.top());\n\t\tint py = std::get<2>(q.top());\n\t\tint pmigi = std::get<3>(q.top());\n\t\tq.pop();\n\t\t//std::cout << c << \" \" << px << \" \" << py << \" \" << pmigi << std::endl;\n\n\t\tif ( stage[px][py] == 11 ) {\n\t\t\tif ( c < min ) min = c;\n\t\t}\n\t\t\n\t\tfor ( int i = 0; i < 9; ++i ) {\n\t\t\tint nx = px + std::get<0>(can[pmigi][i]);\n\t\t\tint ny = py + std::get<1>(can[pmigi][i]);\n\n\t\t\tif ( nx < 0 || ny < 0 || nx >= w || ny >= h || stage[nx][ny] == 10 ) continue;\n\t\t\tint nc = c;\n\t\t\tif ( stage[nx][ny] < 10 ) {\n\t\t\t\t nc += stage[nx][ny];\n\t\t\t}\n\n\t\t\tif ( cost[nx][ny][1-pmigi] > nc ) {\n\t\t\t\tcost[nx][ny][1-pmigi] = nc;\n\t\t\t\tq.push(T(nc, nx, ny, 1-pmigi));\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}\n\nint main()\n{\n\twhile(true){\n\t\tstd::cin >> w >> h;\n\n\t\tif ( w == 0 && h == 0 ) break;\n\t\tfor ( int j = 0; j < h; ++j ) {\n\t\t\tfor ( int i = 0; i < w; ++i ) {\n\t\t\t\tchar c;\n\t\t\t\tstd::cin >> c;\n\t\t\t\tif ( isdigit(c) ) {\n\t\t\t\t\tstage[i][j] = c - '0';\n\t\t\t\t} else {\n\t\t\t\t\tswitch(c) {\n\t\t\t\t\t\tcase 'X':\n\t\t\t\t\t\t\tstage[i][j] = 10;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\tstage[i][j] = 11;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\tstage[i][j] = 12;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min = 0xffff;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tif ( stage[j][i] == 12 ) {\n\t\t\t\t\tint a = search(j, i, false);\n\t\t\t\t\tint b = search(j, i, true);\n\n\t\t\t\t\tif ( a < min ) min = a;\n\t\t\t\t\tif ( b < min ) min = b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( min == 0xffff ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<utility>\n#include<queue>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct State {\n\tint d, x, y, foot;\n\tState(int _d, int _x, int _y, int _foot) {\n\t\td = _d;\n\t\tx = _x;\n\t\ty = _y;\n\t\tfoot = _foot;\n\t}\n};\n\nint s_l, s_r, t_l, t_r;\nint d[30][60][2];\n//dijkstra\nint dijkstra(vector<vector<int>>&cost,State start) {\n\tint res = 1000000;\n\tauto compare = [](const State& s1, const State& s2) {return s1.d < s2.d; };\n\tpriority_queue < State, vector<State>, decltype(compare) > q(compare);\n\tfor (int i = 0; i < 30; i++) {\n\t\tfor (int j = 0; j < 60; j++) {\n\t\t\td[i][j][0] = d[i][j][1] = 1000000;\n\t\t}\n\t}\n\td[start.x][start.y][start.foot == 1] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif (d[s.x][s.y][s.foot == 1] < s.d)continue;\n\t\tfor (int mx = 1; mx <= 3; mx++) {\n\t\t\tfor (int my = 3 - mx; my >= mx - 3; my--) {\n\t\t\t\tint next_x = s.x + mx*s.foot;\n\t\t\t\tint next_y = s.y + my;\n\t\t\t\tif (!(next_x >= 0 && next_x < cost.size() && next_y >= 0 && next_y < cost[0].size()))continue;\n\t\t\t\tif (cost[next_x][next_y] == -1)continue;\n\t\t\t\tif (d[next_x][next_y][(-s.foot) == 1] > d[s.x][s.y][s.foot == 1] + cost[next_x][next_y]) {\n\t\t\t\t\td[next_x][next_y][(-s.foot) == 1] = d[s.x][s.y][s.foot == 1] + cost[next_x][next_y];\n\t\t\t\t\tq.push(State(d[next_x][next_y][(-s.foot) == 1], next_x, next_y, -s.foot));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = t_l; i <= t_r; i++) {\n\t\tint d_min = min(d[i][0][0], d[i][0][1]);\n\t\tres = min(res, d_min);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<vector<int>>cliff(w, vector<int>(h));\n\t\t//input\n\t\tbool s_flag = 0, t_flag = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c <= '9' && c >= '0') {\n\t\t\t\t\tcliff[j][i] = atoi(&c);\n\t\t\t\t}\n\t\t\t\telse if (c == 'S') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (s_flag == 0) {\n\t\t\t\t\t\ts_l = j; s_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\ts_r = j;\n\t\t\t\t}\n\t\t\t\telse if (c == 'X')cliff[j][i] = -1;\n\t\t\t\telse if (c == 'T') {\n\t\t\t\t\tcliff[j][i] = 0;\n\t\t\t\t\tif (t_flag == 0) {\n\t\t\t\t\t\tt_l = j; t_flag = 1;\n\t\t\t\t\t}\n\t\t\t\t\tt_r = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = min(dijkstra(cliff, State(0, s_l, h - 1, 1)), dijkstra(cliff, State(0, s_l, h - 1, -1)));\n\t\tint ans1 = min(dijkstra(cliff, State(0, s_r, h - 1, 1)), dijkstra(cliff, State(0, s_r, h - 1, -1)));\n\t\tans = min(ans, ans1);\n\t\tif (ans == 1000000)ans = -1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nchar s[50][50], buf[2];\nint d[50][50][50][50][2];\nstruct st {\n\tint lx, ly, rx, ry, c, b;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint C(char c) {\n\tif (isdigit(c))return c - '0';\n\treturn 0;\n}\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tpriority_queue<st>que;\n\t\trep(i, h)rep(j, w) {\n\t\t\tscanf(\"%s\", buf); s[i][j] = buf[0];\n\t\t}\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\t\tint a = 3 - abs(k);\n\t\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\t\tint nx = i + k, ny = j + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[i][j][nx][ny][0] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ i,j,nx,ny,C(s[nx][ny]),0 });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnx = i + k, ny = j - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\td[nx][ny][i][j][1] = C(s[nx][ny]);\n\t\t\t\t\t\t\tque.push({ nx,ny,i,j,C(s[nx][ny]),1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.lx][p.ly][p.rx][p.ry][p.b] != p.c)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tint a = 3 - abs(k);\n\t\t\t\tfor (int t = 1; t <= a; t++) {\n\t\t\t\t\tif (p.b) {\n\t\t\t\t\t\tint nx = p.lx + k, ny = p.ly + t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[p.lx][p.ly][nx][ny][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ p.lx,p.ly,nx,ny,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nx = p.rx + k, ny = p.ry - t;\n\t\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != 'X') {\n\t\t\t\t\t\t\tint&u = d[nx][ny][p.rx][p.ry][!p.b];\n\t\t\t\t\t\t\tint c = p.c + C(s[nx][ny]);\n\t\t\t\t\t\t\tif (u > c) {\n\t\t\t\t\t\t\t\tu = c; que.push({ nx,ny,p.rx,p.ry,u,!p.b });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\trep(i, h)rep(j, w)rep(k, h)rep(t, w)rep(y, 2) {\n\t\t\tif (s[i][j] == 'T' || s[k][t] == 'T')Min = min(Min, d[i][j][k][t][y]);\n\t\t}\n\t\tif (Min == INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <functional>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nint w, h;\n\nint field[61][31];\n\nstruct Search {\n  int y, x;\n  int foot;\n  int cost;\n  Search(int y, int x, int foot, int c): y(y), x(x), foot(foot), cost(c) { }\n};\n\nint main() {\n  while (true) {\n    cin >> w  >> h;\n    if (w + h == 0) {\n      break;\n    }\n\n    int min_cost[2][61][31];\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 31; j++) {\n        min_cost[0][i][j] = INF;\n        min_cost[1][i][j] = INF;\n      }\n    }\n\n\n    queue<Search> que;\n\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        char c;\n        cin >> c;\n        if (c == 'X') {\n          field[i][j] = -1;\n        } else if (c == 'S') {\n          field[i][j] = 0;\n          min_cost[0][i][j] = 0;\n          min_cost[1][i][j] = 0;\n          que.push(Search(i, j, 0, 0));\n          que.push(Search(i, j, 1, 0));\n        } else if (c == 'T') {\n          field[i][j] = 10;\n        } else {\n          field[i][j] = c - '0';\n        }\n      }\n    }\n\n    const int dy[2][9] = { \n      { -2, -1, -1, 0, 0, 0, 1, 1, 2 },\n      { -2, -1, -1, 0, 0, 0, 1, 1, 2 }\n    };\n    const int dx[2][9] = {\n      { 1, 1, 2, 1, 2, 3, 1, 2, 1 },\n      { -1, -1, -2, -1, -2, -3, -1, -2, -1 }\n    };\n\n    int ans = INF;\n\n    while (!que.empty()) {\n      Search s = que.front(); que.pop();\n      int next_foot = !s.foot;\n      for (int i = 0; i < 9; i++) {\n        int ny = s.y + dy[next_foot][i];\n        int nx = s.x + dx[next_foot][i];\n        \n        if (ny < 0 || ny >= h) {\n          continue;\n        }\n        if (nx < 0 || nx >= w) {\n          continue;\n        }\n        if (field[ny][nx] == -1) {\n          continue;\n        }\n        if (field[ny][nx] == 10) {\n          ans = min(ans, s.cost);\n          continue;\n        }\n        int cost = s.cost + field[ny][nx];\n        if (cost < min_cost[next_foot][ny][nx]) {\n          min_cost[next_foot][ny][nx] = cost;\n          que.push(Search(ny, nx, next_foot, cost));\n        }\n      }\n    }\n    \n    if (ans == INF) {\n      ans = -1;\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint INF = 1e+9;\nint w, h;\nchar s[60][31];\nint dp[60][30][2];\t//left:0, right:1\n\nint solve() {\n\tint i, j, k;\n\tqueue<T> que;\n\t\n\trep(i, h) rep(j, w) rep(k, 2) dp[i][j][k] = INF;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == 'S') {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\tque.push(T(i, j, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint y = get<0>(now);\n\t\tint x = get<1>(now);\n\t\tint d = get<2>(now);\n\t\tint cst = dp[y][x][d];\n\t\t\n\t\tfor (i = -2; i <= 2; i++) {\n\t\t\tfor (j = 1; j <= 3; j++) {\n\t\t\t\tif (abs(i) + abs(j) > 3) continue;\n\t\t\t\tint ny = y + i;\n\t\t\t\tint nx = x;\n\t\t\t\tif (d == 0) nx += j;\n\t\t\t\telse nx -= j;\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif (s[ny][nx] == 'X') continue;\n\t\t\t\t\n\t\t\t\tint ncst = 0;\n\t\t\t\tif ('0' <= s[ny][nx] && s[ny][nx] <= '9') {\n\t\t\t\t\tncst = s[ny][nx] - '0';\n\t\t\t\t}\n\t\t\t\tncst += cst;\n\t\t\t\tint nd = !d;\n\t\t\t\t\n\t\t\t\tif (dp[ny][nx][nd] > ncst) {\n\t\t\t\t\tdp[ny][nx][nd] = ncst;\n\t\t\t\t\tque.push(T(ny, nx, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == 'T') {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tans = min(ans, dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans >= INF) return -1;\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (!w) { break; }\n\t\tint i, j;\n\t\trep(i, h) rep(j, w) cin >> s[i][j];\n\t\tint res = solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nstruct State {\n  int to, cost;\n  bool left;\n  bool operator < (const State& s) const {\n    return cost > s.cost;\n  }\n  State(int t, int c, bool l)\n    : to(t), cost(c), left(l) {}\n};\n\ntypedef pair<int, int> P;\n\nvector<P> start, goal;\nchar t[61][31];\nint G[61][31];\nint W, H;\n\ninline bool inF(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n/*\n  0 1   2   3 ...\n  W W+1 W+2 ...\n  ...\n*/\ninline int nidx(int x, int y) {\n  return y*W+x;\n}\n\ninline int posx(int nidx) {\n  return nidx % W;\n}\n\ninline int posy(int nidx) {\n  return nidx / W;\n}\n\ninline bool isout(int i, int j) {\n  if(i == -1 && j == 3) return true;\n  if(i == +1 && j == 3) return true;\n  if(i == -2 && j == 2) return true;\n  if(i == +2 && j == 2) return true;\n  if(i == -2 && j == 3) return true;\n  if(i == +2 && j == 3) return true;\n  return false;\n}\n\nint dijkstra() {\n  \n  int dist[61][31][2];\n  fill(dist[0][0], dist[0][0]+61*31*2, INF);\n  priority_queue<State> PQ;\n  for(int I=0; I<start.size(); I++) {\n    int sx = start[I].first, sy = start[I].second;\n    dist[sy][sx][0] = dist[sy][sx][1] = 0;\n    PQ.push(State(nidx(sx, sy), 0, false));\n    PQ.push(State(nidx(sx, sy), 0, true));\n  }\n  while(!PQ.empty()) {\n    const State st = PQ.top(); PQ.pop();\n    const int x = posx(st.to), y = posy(st.to);\n    int s = st.left ? -1 : +1;\n    \n    if(t[y][x] == 'T') return st.cost;\n    \n    for(int i=-2; i<=2; i++) {\n      for(int j=1; j<=3; j++) {\n        if(isout(i, j)) continue;\n        int nx = x+s*j, ny = y+i;\n        if(!inF(nx, ny)) continue;\n        if(dist[ny][nx][!st.left] <= st.cost+G[ny][nx]) continue;\n        dist[ny][nx][!st.left] = st.cost+G[ny][nx];\n        PQ.push(State(nidx(nx, ny), dist[ny][nx][!st.left], !st.left));\n      }\n    }\n  }\n  \n  return -1;\n}\n\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    start.clear(); goal.clear();\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++) {\n        cin >> t[i][j];\n        if(t[i][j] == 'S') {\n          start.push_back(P(j, i));\n          G[i][j] = 0;\n        }\n        else if(t[i][j] == 'T') {\n          goal.push_back(P(j, i));\n          G[i][j] = 0;\n        }\n        else if(t[i][j] == 'X'){\n          G[i][j] = INF;\n        }\n        else {\n          G[i][j] = t[i][j]-'0';\n        }\n      }\n    \n    cout << dijkstra() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    while (true) {\n        int m,n; cin >> m >> n;\n        if (n == 0 && m == 0) break;\n        auto a = make_v<char,2>(n,m); cin >> a;\n        auto valid = [&](int i, int j) {\n            return (0 <= i && i < n &&\n                    0 <= j && j < m &&\n                    a[i][j] != 'X');\n        };\n        vector<pair<int,int>> s,t;\n        rep (i,n) rep (j,m) {\n            if (a[i][j] == 'S') s.eb(i,j), a[i][j] = '0';\n            if (a[i][j] == 'T') t.eb(i,j), a[i][j] = '0';\n        }\n\n        using state = tuple<int,int,int>;\n        auto dist = make_v<int,3>(2,n,m,INF);\n        pque_min<pair<int,state>> pq;\n        for (auto ij : s) {\n            int i,j; tie(i,j) = ij;\n            dist[0][i][j] = dist[1][i][j] = 0;\n            pq.emplace(0,state{0,i,j});\n            pq.emplace(0,state{1,i,j});\n        }\n        while (pq.size()) {\n            auto top = pq.top(); pq.pop();\n            int d = top.fst;\n            auto st = top.snd;\n            int LR,i,j; tie(LR,i,j) = st;\n            if (dist[LR][i][j] < d) continue;\n            auto push = [&](int ni, int nj) {\n                int cost = a[ni][nj]-'0';\n                if (chmin(dist[LR^1][ni][nj], d + cost)) {\n                    pq.emplace(d+cost, state{LR^1,ni,nj});\n                }\n            };\n            if (LR == 0) {\n                loop (ni,i-2,<=i+2) loop (nj,j+1,<=j+3) {\n                    if (abs(ni-i) + abs(nj-j) <= 3 && valid(ni,nj)) {\n                        push(ni,nj);\n                    }\n                }\n            } else {\n                loop (ni,i-2,<=i+2) loop (nj,j-3,<=j-1) {\n                    if (abs(ni-i) + abs(nj-j) <= 3 && valid(ni,nj)) {\n                        push(ni,nj);\n                    }\n                }\n            }\n        }\n\n        int mi = INF;\n        for (auto ij : t) {\n            int i,j; tie(i,j) = ij;\n            chmin(mi, dist[0][i][j]);\n            chmin(mi, dist[1][i][j]);\n        }\n\n        cout << (mi < INF ? mi : -1) << \"\\n\";\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF 100000000\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  char grid[100][50];\n  vector<P2> G[2][100][50];\n  int d[2][100][50];\n  int dy[] = {-2,-1,0,1,2,-1,0,1,0} , dx[] = {1,1,1,1,1,2,2,2,3};\n\n  while(cin >> w >> h , w||h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tscanf(\" %c \",&grid[i][j]);\n\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tG[0][i][j].clear();\n\tG[1][i][j].clear();\n\tif(grid[i][j] == 'S'){\n\t  d[0][i][j] = d[1][i][j] = 0;\n\t  q.push(P2(P(0,0),P(i,j)));\n\t  q.push(P2(P(0,1),P(i,j)));\n\t}else d[0][i][j] = d[1][i][j] = INF;\n      }\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j+dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[0][i][j].push_back(P2(P(grid[sy][sx]-'0',1),P(sy,sx)));\n\t  if(grid[sy][sx] == 'T')\n\t    G[0][i][j].push_back(P2(P(0,1),P(sy,sx)));\n\t}\n\tfor(int k=0;k<9;k++){\n\t  int sy = i+dy[k], sx = j-dx[k];\n\t  if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\t  if('1'<=grid[sy][sx] && grid[sy][sx]<='9')\n\t    G[1][i][j].push_back(P2(P(grid[sy][sx]-'0',0),P(sy,sx)));\n\t  if(grid[sy][sx] == 'T')\n\t    G[1][i][j].push_back(P2(P(0,0),P(sy,sx)));\n\t}\n      }\n    }\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      \n      int t = p.first.first, f = p.first.second;\n      int y = p.second.first, x = p.second.second;\n\n      if(grid[y][x] == 'T'){\n\tq.push(p);\n\tcout << t << endl;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)G[f][y][x].size();i++){\n\tint tt = G[f][y][x][i].first.first, tf = G[f][y][x][i].first.second;\n\tint ty = G[f][y][x][i].second.first, tx = G[f][y][x][i].second.second;\n\n\tif(d[tf][ty][tx] > t + tt){\n\t  d[tf][ty][tx] = t+tt;\n\t  q.push(P2(P(t+tt,tf),P(ty,tx)));\n\t}\n      }\n    }\n    if(q.empty())cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\nenum LR{L,R};\n\nstruct Info{\n\tint x,y;\n\tLR bef;\n\tInfo(int _x,int _y,LR _bef){ x=_x,y=_y,bef=_bef; }\n};\n\nbool operator<(const Info &i1,const Info &i2){\n\treturn true;\n}\n\nchar clif[60][30];\nint tmin[60][30][2];\nbool visited[60][30][2];\nconst int dx[]={1,1,1,1,1,2,2,2,3};\nconst int dy[]={-2,-1,0,1,2,-1,0,1,0};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d \",&w,&h),w;){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%c \",clif[i]+j);\n\n\t\tpriority_queue< pair<int,Info> > pq;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(clif[i][j]=='S'){\n\t\t\t\tpq.push(mp(0,Info(j,i,L)));\n\t\t\t\tpq.push(mp(0,Info(j,i,R)));\n\t\t\t\tclif[i][j]='0';\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\ttmin[i][j][k]=1<<30;\n\t\t\t\tvisited[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t\tint ans=-1;\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,Info> a=pq.top();\tpq.pop();\n\t\t\tint t=-a.first,x=a.second.x,y=a.second.y;\n\t\t\tLR bef=a.second.bef;\n\t\t\tif(visited[y][x][bef])\tcontinue;\n\t\t\tvisited[y][x][bef]=true;\n\n\t\t\tif(clif[y][x]=='T'){ ans=t; break; }\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tint xx,yy;\n\t\t\t\tif(bef==L)\txx=x+dx[i],yy=y+dy[i];\n\t\t\t\telse\t\txx=x-dx[i],yy=y-dy[i];\n\t\t\t\tLR foot=(bef==L?R:L);\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h\n\t\t\t\t&& clif[yy][xx]!='X' && !visited[yy][xx][foot]){\n\t\t\t\t\tint nextt=t+(clif[yy][xx]=='T'?0:clif[yy][xx]-'0');\n\t\t\t\t\tif(nextt<tmin[yy][xx][bef]){\n\t\t\t\t\t\tpq.push(mp(-nextt,Info(xx,yy,foot)));\n\t\t\t\t\t\ttmin[yy][xx][bef]=nextt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n/*\nll dfs(vector<string> &v, vector<vvl> &dp, int i, int j, int t) {\n\tif (dp[i][j][t] != -1)return dp[i][j][t];\n\tif (v[i][j] == 'T')return dp[i][j][t] = 0;\n\tdp[i][j][t] = INF;\n\tll ret = INF;\n\tif (t == 0) {\n\t\tfor (int y = j + 1; y <= j + 3; ++y) {\n\t\t\tfor (int x = i - (2 - (y - j)); x <= i + (2 - (y - j)); ++x) {\n\t\t\t\tif (x >= h || x < 0 || y >= w || y < 0 || v[x][y] == 'X')continue;\n\t\t\t\tint cost;\n\t\t\t\tif (isdigit(v[x][y]))cost = v[x][y] - '0';\n\t\t\t\telse cost = 0;\n\t\t\t\tret = min(ret, dfs(v, dp, x, y, 1) + cost);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int y = j - 3; y <= j - 1; ++y) {\n\t\t\tfor (int x = i - (2 - (j - y)); x <= i + (2 - (j - y)); ++x) {\n\t\t\t\tif (x >= h || x < 0 || y >= w || y < 0 || v[x][y] == 'X')continue;\n\t\t\t\tint cost;\n\t\t\t\tif (isdigit(v[x][y]))cost = v[x][y] - '0';\n\t\t\t\telse cost = 0;\n\t\t\t\tret = min(ret, dfs(v, dp, x, y, 0) + cost);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[i][j][t] = ret;\n}\n*/\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> v(h);\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tREP(j, w) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\ts += c;\n\t\t\t}\n\t\t\tv[i] = s;\n\t\t}\n\t\tvector<vvi> dp(h, vvi(w, vi(2, INF)));\n\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<>> q;\n\t\tREP(i, h)REP(j, w) if (v[i][j] == 'S') {\n\t\t\tdp[i][j][0] = 0;\n\t\t\tdp[i][j][1] = 0;\n\t\t\tq.push({ 0,{i*w + j,0} });\n\t\t\tq.push({ 0,{i*w + j,1} });\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tauto p = q.top(); q.pop();\n\t\t\tint d = p.first;\n\t\t\tint i = p.second.first / w, j = p.second.first%w;\n\t\t\tint t = p.second.second;\n\t\t\tif (v[i][j] == 'T')continue;\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int y = j + 1; y <= j + 3; ++y) {\n\t\t\t\t\tfor (int x = i - (3 - (y - j)); x <= i + (3 - (y - j)); ++x) {\n\t\t\t\t\t\tif (x >= h || x < 0 || y >= w || y < 0 || v[x][y] == 'X')continue;\n\t\t\t\t\t\tint cost;\n\t\t\t\t\t\tif (isdigit(v[x][y]))cost = v[x][y] - '0';\n\t\t\t\t\t\telse cost = 0;\n\t\t\t\t\t\tif (cost + d < dp[x][y][1]) {\n\t\t\t\t\t\t\tdp[x][y][1] = cost + d;\n\t\t\t\t\t\t\tq.push({ cost + d,{x*w+y,1} });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = j - 3; y <= j - 1; ++y) {\n\t\t\t\t\tfor (int x = i - (3 - (j - y)); x <= i + (3 - (j - y)); ++x) {\n\t\t\t\t\t\tif (x >= h || x < 0 || y >= w || y < 0 || v[x][y] == 'X')continue;\n\t\t\t\t\t\tint cost;\n\t\t\t\t\t\tif (isdigit(v[x][y]))cost = v[x][y] - '0';\n\t\t\t\t\t\telse cost = 0;\n\t\t\t\t\t\tif (cost + d < dp[x][y][0]) {\n\t\t\t\t\t\t\tdp[x][y][0] = cost + d;\n\t\t\t\t\t\t\tq.push({ cost + d,{x*w+y,0} });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP(i, h)REP(j, w)if (v[i][j] == 'T')ans = min(ans, min(dp[i][j][0], dp[i][j][1]));\n\t\tif (ans == INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nstruct S{int x,y,c,a;S(int x,int y,int c,int a):x(x),y(y),c(c),a(a){}bool operator<(const S&s)const{return c>s.c;}};\nint main()\n{\n\tchar m[66][36];\t//ツ湘」ツ可コツ債カツ右ツづ可氾板閉コツ閉ェツ＋3\n\tint d[66][36][2],h,w,x,y,z,a,i;\n\tint dx[]={1,1,1,1,1,2,2,2,3};\n\tint dy[]={2,1,0,-1,-2,1,0,-1,0};\n\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\ta=-1;\n\t\tmemset(m,'X',sizeof(m));\n\t\tmemset(d,127,sizeof(d));\n\t\tstd::priority_queue<S>q;\n\t\tfor(y=3;y<h+3;++y)\n\t\t\tfor(x=3;x<w+3;++x)\n\t\t\t{\n\t\t\t\tscanf(\" %c\",&m[y][x]);\n\t\t\t\tif(m[y][x]=='S')\n\t\t\t\t{\n\t\t\t\t\tq.push(S(x,y,0,0));\n\t\t\t\t\tq.push(S(x,y,0,1));\n\t\t\t\t\tm[y][x]='0';\n\t\t\t\t}\n\t\t\t}\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tS p(q.top());q.pop();\n\t\t\tif(m[p.y][p.x]=='X')continue;\n\t\t\tif(m[p.y][p.x]=='T'){a=p.c;break;}\n\t\t\tp.c+=m[p.y][p.x]-'0';\n\t\t\tif(d[p.y][p.x][p.a]<=p.c)continue;\n\t\t\td[p.y][p.x][p.a]=p.c;\n\t\t\tz=p.a*2-1;\n\t\t\tfor(i=0;i<9;++i)\n\t\t\t{\n\t\t\t\tx=p.x+z*dx[i];\n\t\t\t\ty=p.y+dy[i];\n\t\t\t\tq.push(S(x,y,p.c,!p.a));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef complex<double> Point;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nbool operator < (const Point & a, const Point & b){\n\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n\n\ntypedef pair<P, P> P2;\ntypedef pair<int, P2> Ps;\nint w, h;\nint memo[71][41][71][41];\nint dl[61][61];\nint dr[61][61];\nchar field[61][61];\n\nstruct state{\n\tint xl, xr, yl, yr, dis;\n\tstate(int dis, int xl, int yl, int xr, int yr){\n\t\tthis->xl = xl;\n\t\tthis->dis = dis;\n\t\tthis->xr = xr;\n\t\tthis->yr = yr;\n\t\tthis->yl = yl;\n\t}\n};\n\nbool operator < (const state &s1, const state &s2){\n\treturn s1.dis < s2.dis;\n};\n\nint dy[] = {2, 1, 1, 0, 0, 0, -1, -1, -2};\nint dx[] = {1, 1, 2, 1, 2, 3, 1, 2, 1};\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tbool ok = false;\n\t\tint xl, xr, yl, yr, xl2, xr2, yl2, yr2;\n\t\tint dis, cost;\n\t\tfill(&memo[0][0][0][0], &memo[70][40][70][40] + 1, INF);\n\t\tfill(&dl[0][0], &dl[60][60] + 1, INF);\n\t\tfill(&dr[0][0], &dr[60][60] + 1, INF);\n\t\tpriority_queue<state, vector<state> > que;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[j][i];\n\t\t\t\tif(field[j][i] == 'S'){\n\t\t\t\t\tfield[j][i] = '0';\n\t\t\t\t\tmemo[j][i][j][i] = 0;\n\t\t\t\t\tdl[j][i] = dr[j][i] = 0;\n\t\t\t\t\tque.push(state(0, j, i, j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.top();\n\t\t\tque.pop();\n\t\t\txl = s.xl;\n\t\t\tyl = s.yl;\n\t\t\txr = s.xr;\n\t\t\tyr = s.yr;\n\t//\t\tcout << \"l \" << xl << \" \" << yl << endl;\n\t//\t\tcout << \"r \" << xr << \" \"  << yr << endl << endl;\n\n\t\t\tdis = -s.dis;\n\t\t\tif(dis > memo[xl][yl][xr][yr]) continue;\n\t\t\tif(field[xl][yl] == 'T' || field[xr][yr] == 'T'){\n\t\t\t\tcout << memo[xl][yl][xr][yr] << endl;\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txr2 = xl + dx[i];\n\t\t\t\tyr2 = yl + dy[i];\n\t\t\t\tif(0 <= xr2 && xr2 < w && 0 <= yr2 && yr2 < h && field[xr2][yr2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xr2][yr2])) cost = field[xr2][yr2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl][yl][xr2][yr2] > dis + cost){\n\t\t\t\t\t\tmemo[xl][yl][xr2][yr2] = dis + cost;\n\t\t\t\t//\t\tdr[xr2][yr2] = min(dr[xr2][yr2], memo[xl][yl][xr2][yr2]);\n\t\t\t\t\t\tque.push(state(-memo[xl][yl][xr2][yr2], xl, yl, xr2, yr2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\txl2 = xr - dx[i];\n\t\t\t\tyl2 = yr + dy[i];\n\t\t\t\tif(0 <= xl2 && xl2 < w && 0 <= yl2 && yl2 < h && field[xl2][yl2] != 'X'){\n\t\t\t\t\tif(isdigit(field[xl2][yl2])) cost = field[xl2][yl2] - '0';\n\t\t\t\t\telse cost = 0;\n\t\t\t\t\tif(memo[xl2][yl2][xr][yr] > dis + cost){\n\t\t\t\t\t\tmemo[xl2][yl2][xr][yr] = dis + cost;\n\t\t\t//\t\t\tdl[xl2][yl2] = min(dl[xl2][yl2], memo[xl2][yl2][xr][yr]);\n\t\t\t\t\t\tque.push(state(-memo[xl2][yl2][xr][yr], xl2, yl2, xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint w,h;\nchar s[99][99];\nint cost[60][30][60][30][2];\n\nstruct Node{\n  int lx,ly,rx,ry;\n  int foot,cost;\n  bool operator<(const Node &r)const{\n    return cost>r.cost;\n  }\n};\nbool ok(Node &node){\n  int lx=node.lx,rx=node.rx,ly=node.ly,ry=node.ry;\n  if(lx<0||rx<0||ly<0||ry<0||lx>=w||rx>=w||ly>=h||ry>=h)return 0;\n     if(s[ly][lx]=='X'||s[ry][rx]=='X')return 0;\n     return lx<rx&&abs(lx-rx)+abs(ly-ry)<=3;\n}\n\nint main()\n{\n  while(cin>>w>>h,w){\n  \n    rep(i,h)rep(j,w)rep(ii,h)rep(jj,w)rep(k,2)cost[i][j][ii][jj][k]=inf;\n\n    priority_queue<Node>Q;\n    rep(i,h)rep(j,w){\n      cin>>s[i][j];\n      if(s[i][j]=='S'){\n\tNode node;\n\tnode.ry=-inf,node.rx=-inf;\n\tnode.ly=i,node.lx=j; node.foot=node.cost=0;\n\tQ.push(node);\n\tswap(node.ry,node.ly); swap(node.rx,node.lx);\n\tnode.foot=1;\n\tQ.push(node);\n      }\n    }\n    int ans=inf;\n    while(!Q.empty()){\n      Node cur=Q.top();\n      //dbg(cur.ly);dbg(cur.lx);dbg(cur.ry);dbg(cur.rx);\n      //dbg(cur.cost);dbg(cur.foot);\n      Q.pop();\n    \n      if(ok(cur)&&(s[cur.ly][cur.lx]=='T'||s[cur.ry][cur.rx]=='T')){\n\tans=cur.cost; break;\n      }\n\n      rep(y,h)rep(x,w){\n\tNode node=cur;\n\tif(node.foot==0)node.ry=y,node.rx=x;\n\telse node.ly=y,node.lx=x;\n\tnode.foot^=1;\n\tif(!ok(node))continue;\n\n\tnode.cost+=isdigit(s[y][x])?s[y][x]-'0':0;\n\tint &c=cost[node.ly][node.lx][node.ry][node.rx][node.foot];\n\tif(node.cost>=c)continue;\n\t\n\tc=node.cost;\n\tQ.push(node);\n      }\n    }\n    cout<<(ans==inf?-1:ans)<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2007 D. Roè\n\n#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 999999;\n\nclass Node{\npublic:\n\tint x, y, foot, cost;\n\tNode(int x, int y, int foot, int cost) : x(x), y(y), foot(foot), cost(cost) {}\n\tbool operator < (const Node &n) const { return cost > n.cost; }\n};\n\nint main(){\n\tint w, h;\n\tchar b[60][30];\n\tbool visit[2][60][30];\n\tint dist[2][60][30];\n\twhile(cin >> w >> h, w){\n\t\tint ans = INF;\n\t\tpriority_queue<Node> qu;\n\t\tmemset(visit, false, sizeof(visit));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> b[i][j];\n\t\t\t\tif(b[i][j] == 'S'){\n\t\t\t\t\tqu.push(Node(j,i,0,0));\n\t\t\t\t\tqu.push(Node(j,i,1,0));\n\t\t\t\t\tdist[0][i][j] = dist[1][i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[0][i][j] = dist[1][i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!qu.empty()){\n\t\t\tNode e = qu.top(); qu.pop();\n\t\t\tif(visit[e.foot][e.y][e.x]) continue;\n\t\t\tif(b[e.y][e.x]=='T'){\n\t\t\t\tans = e.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvisit[e.foot][e.y][e.x] = true;\n\t\t\tfor(int dx=1;dx<=3;dx++){\n\t\t\t\tfor(int dy=dx-3;dy<=3-dx;dy++){\n\t\t\t\t\tint x = e.x + (e.foot ? -dx : dx);\n\t\t\t\t\tint y = e.y + dy;\n\t\t\t\t\tif(x<0||w<=x||y<0||h<=y||visit[1-e.foot][y][x]) continue;\n\t\t\t\t\tif(b[y][x]=='X'||b[y][x]=='S') continue;\n\t\t\t\t\tif(dist[1-e.foot][y][x] > e.cost + (b[y][x]!='T'?b[y][x]-'0':0)){\n\t\t\t\t\t\tdist[1-e.foot][y][x] = e.cost + (b[y][x]!='T'?b[y][x]-'0':0);\n\t\t\t\t\t\tqu.push(Node(x, y, 1-e.foot, dist[1-e.foot][y][x]));\n\t\t\t\t\t}   \n\t\t\t\t}   \n\t\t\t}\n\t\t}\n\t\tcout << (ans == INF ? -1 : ans) << endl;  \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define int long long\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct to {\n    int type, x, y;\n    to(int type, int y, int x):type(type),y(y),x(x){}\n    bool operator<(const to& t) const {\n        return type < t.type;\n    }\n};\nstruct edge {\n    to t; int cost;\n    edge(to t, int cost):t(t),cost(cost){}\n};\n\nvector<edge> G[2][61][31];\nint d[2][61][31];\n\nchar fld[62][32];\n\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint W, H;\n\nbool inside(int h, int w)\n{\n    return (0 <= h && h < H && 0 <= w && w < W);\n}\n\nvoid build_graph()\n{\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (fld[i][j] == 'T' || fld[i][j] == 'X') continue;\n\n            for (int k = 0; k < 9; ++k) {\n                int y = i + dy[k], ax = j + dx[k], bx = j + dx[k] * -1;\n\n                if (inside(y, ax) && fld[y][ax] != 'X') {\n                    int cost = (isdigit(fld[y][ax]) ? fld[y][ax] - '0' : 0);\n                    G[0][i][j].push_back(edge(to(1, y, ax), cost));\n                }\n                \n                if (inside(y, bx) && fld[y][bx] != 'X') {\n                    int cost = (isdigit(fld[y][bx]) ? fld[y][bx] - '0' : 0);\n                    G[1][i][j].push_back(edge(to(0, y, bx), cost));\n                }\n            }\n        }\n    }\n}\n\nvoid dijkstra(to s)\n{\n    typedef pair<int, to> P;\n\n    for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n        d[i][j][k] = inf;\n    }\n\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(0, to(s.type, s.y, s.x)));\n\n    d[s.type][s.y][s.x] = 0;\n\n    while (q.size()) {\n        P p = q.top();\n        q.pop();\n\n        to t = p.scd;\n        \n        if (p.fst > d[t.type][t.y][t.x]) continue;\n\n        for (int i = 0; i < G[t.type][t.y][t.x].size(); ++i) {\n            edge e = G[t.type][t.y][t.x][i];\n\n            if (d[e.t.type][e.t.y][e.t.x] > d[t.type][t.y][t.x] + e.cost) {\n                d[e.t.type][e.t.y][e.t.x] = d[t.type][t.y][t.x] + e.cost;\n                q.push(P(d[e.t.type][e.t.y][e.t.x], e.t));\n            }\n        }\n    }\n}\nsigned main()\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        for (int i = 0; i < 2; ++i) for (int j = 0; j < H; ++j) for (int k = 0; k < W; ++k) {\n            G[i][j][k].clear();\n        }\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                scanf(\"\\n%c\", &fld[i][j]);\n            }\n        }\n\n        build_graph();\n\n        int mi = inf;\n\n        for (int i = 0; i < W; ++i) {\n            if (fld[H - 1][i] == 'S') {\n                for (int j = 0; j < 2; ++j) {\n                    dijkstra(to(j, H - 1, i));\n                    for (int k = 0; k < W; ++k) {\n                        if (fld[0][k] == 'T') {\n                            chmin(mi, min(d[j][0][k], d[j^1][0][k]));\n                        }\n                    }\n                }\n            }\n        }\n\n        printf(\"%d\\n\", mi == inf ? -1 : mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\nstruct Step {\n\tint h, w;\n\tbool left;\n\n\tbool operator < (const Step& r)const {\n\t\tif (left != r.left)return left < r.left;\n\t\telse if (h != r.h)return h > r.h;\n\t\telse return w > r.w;\n\t}\n};\n\nstruct Stage {\n\tint H, W;\n\tvector<vector<int>> s;\n\tvector<pair<int,int>> t;\n\n\tStage()\n\t{\n\t\tcin >> W >> H;\n\t\tif (W == 0)return;\n\t\ts.resize(H, vector<int>(W, INF));\n\t\tdpL.resize(H, vector<int>(W, INF));\n\t\tdpR.resize(H, vector<int>(W, INF));\n\t\tREP(i, H){\n\t\t\tREP(j, W) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tswitch (c) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tnext.insert(Step({ i, j, true }));\n\t\t\t\t\tnext.insert(Step({ i, j, false }));\n\t\t\t\t\tdpL[i][j] = 0;\n\t\t\t\t\tdpR[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tt.push_back({ i,j });\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'X':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ts[i][j] = c - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid action()\n\t{\n\t\t//calculation\n\t\twhile (!next.empty()) \n\t\t{\n\t\t\tStep now = *next.begin();\n\t\t\tnext.erase(next.begin());\n\t\t\twalk(now);\n\t\t}\n\n\t\t//output\n\t\tint res = INF;\n\t\tfor (auto goal : t)\n\t\t{\n\t\t\tres = min(res, dpL[goal.first][goal.second]);\n\t\t\tres = min(res, dpR[goal.first][goal.second]);\n\t\t}\n\t\tcout << (res != INF ? res : -1) << endl;\n\t}\n\nprivate:\n\tset<Step> next;\n\tvector<vector<int>> dpL, dpR;\n\n\tvoid walk(const Step& now)\n\t{\n\t\t//移動ベクトル定義\n\t\tint dh[] = { -2,-1,-1,0,0,0,1,1,2 };\n\t\tint dw[] = { 1,1,2,1,2,3,1,2,1 };\n\t\tif (now.left)\n\t\t{\n\t\t\tfor (int& tmp : dw) {\n\t\t\t\ttmp *= -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//移動\n\t\tREP(i, 9)\n\t\t{\n\t\t\tint h = now.h + dh[i];\n\t\t\tint w = now.w + dw[i];\n\n\t\t\tif (!is_in({ h,w }))continue;\n\t\t\tif (s[h][w] == INF)continue;\n\n\t\t\tif (now.left) {\n\t\t\t\tif (dpR[now.h][now.w] + s[h][w] >= dpL[h][w]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpL[h][w] = dpR[now.h][now.w] + s[h][w];\n\t\t\t\t\tnext.insert({ h,w,!now.left });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (dpL[now.h][now.w] + s[h][w] >= dpR[h][w]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpR[h][w] = dpL[now.h][now.w] + s[h][w];\n\t\t\t\t\tnext.insert({ h,w,!now.left });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool is_in(pair<int, int> p)const\n\t{\n\t\tif (p.first < 0)return false;\n\t\tif (p.second < 0)return false;\n\t\tif (H <= p.first)return false;\n\t\tif (W <= p.second)return false;\n\t\treturn true;\n\t}\n};\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true)\n\t{\n\t\tStage stage;\n\t\tif (!stage.W)break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nclass State{\npublic:\n    int y, x, f, c;\n    State(){}\n    State(int y, int x, int f, int c): y(y), x(x), f(f), c(c) {}\n    bool operator < (const State &s) const{\n        return c > s.c;\n    }\n};\n\nconst int INF = 1e7;\nint w, h;\nint a[61][31], d[61][31][2];\npriority_queue<State> q;\nint dy[9] = {-2, -1, -1, 0, 0, 0, 1, 1, 2};\nint dx[9] = { 1,  1,  2, 1, 2, 3, 1, 2, 1};\n \nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nint dijkstra(){\n    while(!q.empty()){\n        State u = q.top(); q.pop();\n        if(a[u.y][u.x] == -2) return d[u.y][u.x][u.f];\n        // if(u.c > d[u.y][u.x][u.f]) continue;\n        rep(i, 0, 9){\n            int nf = (u.f + 1) % 2;\n            int k = (u.f == 0 ? 1 : -1);\n            int ny = u.y + dy[i];\n            int nx = u.x + k * dx[i];\n            \n            if(!contain(ny, nx) || a[ny][nx] == -INF || d[ny][nx][nf] != INF) continue;\n            int cost = d[u.y][u.x][u.f] + (a[ny][nx] == -2 ? 0 : a[ny][nx]);\n            if(cost < d[ny][nx][nf]){\n                d[ny][nx][nf] = cost;\n                q.push(State(ny, nx, nf, cost));\n            }\n        }\n    }\n    return -1;\n}\n\nsigned main(){\n    while(cin >> w >> h && w + h){\n        q = priority_queue<State>();\n        rep(i, 0, 61) rep(j, 0, 31) rep(k, 0, 2) d[i][j][k] = INF;        \n        rep(i, 0, h){\n            rep(j, 0, w){\n                char c;\n                cin >> c;\n                if(c == 'X') a[i][j] = -INF;\n                else if(c == 'S'){\n                    a[i][j] = -1;\n                    rep(k, 0, 2){\n                        q.push(State(i, j, k, 0));\n                        d[i][j][k] = 0;\n                    }\n                }else if(c == 'T') a[i][j] = -2;\n                else a[i][j] = c - '0';\n            }\n        }\n        cout << dijkstra() << endl;\n        // rep(k, 0, 2){\n        //     rep(i, 0, h){\n        //         rep(j, 0, w){\n        //             printf(\"%8d \", d[i][j][k]);\n        //         }\n        //         cout << endl;\n        //     }\n        //     cout <<endl;\n        // }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint v[60][30];\n\nint dx[] = {-2,-1,-1,0,0,0,1,1,2};\nint dy[] = {1,1,2,1,2,3,1,2,1};//反転\n\nint h,w;\n\nbool in(int x, int y){\n    if(x < 0 || x >= h) return false;\n    if(y < 0 || y >= w) return false;\n    return true;\n}\n\nint main(void) {\n    int i,j,k;\n    while(cin >> w >> h, w){\n\n        vector<pii> s,g;\n\n        rep(i,h)rep(j,w){\n            string t;\n            cin >> t;\n\n            if(isdigit(t[0])){\n                v[i][j] = t[0] - '0';\n            }else if(t[0] == 'S'){\n                v[i][j] = 0;\n                s.push_back(pii(i,j));\n            }else if(t[0] == 'T'){\n                v[i][j] = 0;\n                g.push_back(pii(i,j));\n            }else{\n                v[i][j] = -1;\n            }\n\n        }\n\n        int dp[60][30][2];\n        rep(i,h)rep(j,w)rep(k,2) dp[i][j][k] = INF;\n\n        queue<vi> q;\n\n        rep(i,s.size())rep(j,2){\n            vi t(3);\n            t[0] = s[i].first;\n            t[1] = s[i].second;\n            t[2] = j;\n            dp[t[0]][t[1]][j] = 0;\n            q.push(t);\n        }\n\n        while(q.size()){\n            int x = q.front()[0];\n            int y = q.front()[1];\n            int z = q.front()[2];\n            q.pop();\n            //cout << x << \" \" << y << \" \" << z << endl;\n            rep(i,9){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                int nz = 1;\n                if(z){\n                    ny = y - dy[i];\n                    nz = 0;\n                }\n                if(!in(nx,ny) || v[nx][ny] < 0)continue;\n                vi t(3);\n                t[0] = nx;\n                t[1] = ny;\n                t[2] = nz;\n                if(dp[nx][ny][nz] > dp[x][y][z] + v[x][y]){\n                    dp[nx][ny][nz] = dp[x][y][z] + v[x][y];\n                    q.push(t);\n                }\n            }\n        }\n\n\n\n        int ans = INF;\n        rep(i,g.size())rep(j,2){\n            ans = min(ans,dp[g[i].first][g[i].second][j]);\n        }\n        if(ans < INF){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<iomanip>\n#include<vector>\n#include<queue>\n \nusing namespace std;\n#define REP(i,b,e) for(int i=(int)b;i<(int)e;i++)\n#define rep0(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define shosu setprecision(10)\ntypedef long long ll;\ntypedef pair<int,pair<int,pair<int,int>>> P;\n\nll longinf=1ll<<60;\nint inf=1<<29;\nint dy[]={2,1,1,0,0,0,-1,-1,-2};\nint dlx[]={1,1,2,1,2,3,1,2,1}; //0~8\nint drx[]={-1,-1,-2,-1,-2,-3,-1,-2,-1};\n\nint W,H;\nchar s[62][32];\nint dist[62][32][2];\n\n//左足0,右足1\n//queには距離,足,点を入れる\nint main(){\n    while(1){\n        int ans=inf;\n        cin>>W>>H;\n        if(W==0&&H==0) break;\n        rep0(h,H)rep0(w,W) cin>>s[h][w];\n        rep0(h,H)rep0(w,W)rep0(f,2) dist[h][w][f]=inf;\n        priority_queue<P,vector<P>,greater<P>> que;\n        rep0(h,H){\n            rep0(w,W){\n                if(s[h][w]=='S'){\n                    P x,y;\n                    x={0,{0,{h,w}}};\n                    y={0,{1,{h,w}}};\n                    dist[h][w][0]=dist[h][w][1]=0;\n                    que.push(x);\n                    que.push(y);\n                }\n            }\n        }\n        while(que.size()){\n            P x;\n            x=que.top();\n            que.pop();\n            int d=x.first;\n            int foot=x.second.first;\n            int h=x.second.second.first;\n            int w=x.second.second.second;\n                if(foot){\n                    rep0(i,9){\n                        int nh=h+dy[i];\n                        int nw=w+dlx[i];\n                        if(nh>=0&&nw>=0&&nh<H&&nw<W){\n                            if(s[nh][nw]=='X') continue;\n                            else if(s[nh][nw]=='T') ans=min(ans,dist[h][w][1]);\n                            else if(s[nh][nw]=='S') continue;\n                            else{\n                                int n=s[nh][nw]-'0';\n                                if(dist[nh][nw][0]<dist[h][w][1]+n) continue;\n                                dist[nh][nw][0]=dist[h][w][1]+n;\n                                P nx;\n                                nx={dist[nh][nw][0],{0,{nh,nw}}};\n                                que.push(nx);\n                            }\n                        }\n                    }\n                }\n                else{\n                    rep0(i,9){\n                        int nh=h+dy[i];\n                        int nw=w+drx[i];\n                        if(nh>=0&&nw>=0&&nh<H&&nw<W){\n                            if(s[nh][nw]=='X') continue;\n                            else if(s[nh][nw]=='T') ans=min(ans,dist[h][w][0]);\n                            else if(s[nh][nw]=='S') continue;\n                            else{\n                                int n=s[nh][nw]-'0';\n                                if(dist[nh][nw][1]<dist[h][w][0]+n) continue;\n                                dist[nh][nw][1]=dist[h][w][0]+n;\n                                P nx;\n                                nx={dist[nh][nw][1],{1,{nh,nw}}};\n                                que.push(nx);\n                            }\n                        }\n                    }\n                }\n            \n        }\n        /*rep0(i,2){\n        rep0(h,H){\n            rep0(w,W){\n                cout<<dist[h][w][i]<<\" \";\n            };\n            cout<<endl;\n        }\n        cout<<endl;\n        }*/\n        if(ans==inf) cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl;\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[60][30][2];\n\nint main() {\n\twhile (true) {\n\t\tint w, h;\tcin >> w >> h;\n\t\tif (w == 0)\tbreak;\n\t\tvector<string> s(h);\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tchar a;\tcin >> a;\n\t\t\t\ts[i] = s[i] + a;\n\t\t\t}\n\t\t}\n\t\trep(i, h)\trep(j, w)\tdp[i][j][0] = dp[i][j][1] = mod;\n\t\tpriority_queue<tuple<int, int, int, int>> pq;\n\t\trep(i, w) {\n\t\t\tif (s[h - 1][i] == 'S') {\n\t\t\t\tdp[h - 1][i][0] = dp[h - 1][i][1] = 0;\n\t\t\t\tpq.push(mt(0, h - 1, i, 0));\n\t\t\t\tpq.push(mt(0, h - 1, i, 1));\n\t\t\t}\n\t\t}\n\t\tint ret = mod;\n\t\twhile (!pq.empty()) {\n\t\t\tint cost, y, x, use;\n\t\t\ttie(cost, y, x, use) = pq.top();\tpq.pop();\n\t\t\tcost *= -1;\n\t\t\tif (cost != dp[y][x][use])\tcontinue;\n\t\t\tSREP(i, 1, 3) {\n\t\t\t\tSREP(j, i - 3, 3 - i) {\n\t\t\t\t\tint ny = y + j;\n\t\t\t\t\tint nx = x + (use == 0 ? i : -i);\n\t\t\t\t\tif (ny < 0 || h <= ny)\tcontinue;\n\t\t\t\t\tif (nx < 0 || w <= nx)\tcontinue;\n\t\t\t\t\tif (s[ny][nx] == 'S' || s[ny][nx] == 'X')\tcontinue;\n\t\t\t\t\tif (s[ny][nx] == 'T') {\n\t\t\t\t\t\tdp[ny][nx][use ^ 1] = min(dp[ny][nx][use ^ 1], cost);\n\t\t\t\t\t\tret = min(ret, dp[ny][nx][use ^ 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[ny][nx][use ^ 1] > cost + (s[ny][nx] - '0')) {\n\t\t\t\t\t\tdp[ny][nx][use ^ 1] = cost + (s[ny][nx] - '0');\n\t\t\t\t\t\tpq.push(mt(-dp[ny][nx][use ^ 1], ny, nx, use ^ 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = (ret == mod ? -1 : ret);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nclass data{\npublic:\n\tint x,y,rx,ry,s,cost;\n\tbool operator<(const data &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint w,h;\nint dp[35][65][3][7][2];\nint fie[100][100];\nint flag[100][100];\nint sx[5],gx[5];\n\nint dijk(){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tdata inp;\n\tint res=-1;\n\tinp.x=sx[0];\n\tinp.y=h;\n\tinp.rx=sx[1]-sx[0];\n\tinp.ry=3;\n\tinp.cost=0;\n\tinp.s=0;\n\tque.push(inp);\n\tinp.s=1;\n\tque.push(inp);\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.x][q.y][q.rx][q.ry][q.s]!=-1 && dp[q.x][q.y][q.rx][q.ry][q.s]<q.cost)continue;\n\t\tdp[q.x][q.y][q.rx][q.ry][q.s]=q.cost;\n\t\tif(flag[q.x][q.y]==1 || flag[q.x+q.rx][q.y+q.ry-3]==1){\n\t\t\tres=min(res,q.cost);\n\t\t\tif(res==-1)res=q.cost;\n\t\t}\n\t\t//printf(\"%d %d %d %d %d %d\\n\",q.x,q.y,q.rx,q.ry,q.s,q.cost);\n\t\tif(q.s==0){\n\t\t\tfor(int i=1;i<=3;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x][q.y][i][j+3][1]==-1 || dp[q.x][q.y][i][j+3][1]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x][q.y][i][j+3][1]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq=q;\n\t\t\t\t\t\t\t\tnq.rx=i;\n\t\t\t\t\t\t\t\tnq.ry=j+3;\n\t\t\t\t\t\t\t\tnq.s=1;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.s==1){\n\t\t\tq.x=q.x+q.rx;\n\t\t\tq.y=q.y+q.ry-3;\n\t\t\tfor(int i=-3;i<=-1;i++){\n\t\t\t\tfor(int j=-3;j<=3;j++){\n\t\t\t\t\tif(-i+abs(j)>3)continue;\n\t\t\t\t\tif(q.x+i>=1 && q.x+i<=w && q.y+j>=1 && q.y+j<=h){\n\t\t\t\t\t\tif(fie[q.x+i][q.y+j]!=-1){\n\t\t\t\t\t\t\tif(dp[q.x+i][q.y+j][-i][-j+3][0]==-1 || dp[q.x+i][q.y+j][-i][-j+3][0]>q.cost+fie[q.x+i][q.y+j]){\n\t\t\t\t\t\t\t\tdp[q.x+i][q.y+j][-i][-j+3][0]=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tdata nq;\n\t\t\t\t\t\t\t\tnq.x=q.x+i;\n\t\t\t\t\t\t\t\tnq.y=q.y+j;\n\t\t\t\t\t\t\t\tnq.rx=-i;\n\t\t\t\t\t\t\t\tnq.ry=-j+3;\n\t\t\t\t\t\t\t\tnq.s=0;\n\t\t\t\t\t\t\t\tnq.cost=q.cost+fie[q.x+i][q.y+j];\n\t\t\t\t\t\t\t\tque.push(nq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(flag,0,sizeof(flag));\n\t\tint scnt=0,gcnt=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='S')fie[j][i]=0,sx[scnt++]=j;\n\t\t\t\tif(c=='T')fie[j][i]=0,flag[j][i]=1;\n\t\t\t\tif(c=='X')fie[j][i]=-1;\n\t\t\t\tif(c>='1' && c<='9')fie[j][i]=c-'0';\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif((int)input - '0' < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T') {\n\t\t\t\t\tif(i==0)\n\t\t\t\t\t\tfield[i][j] = 12;\n\t\t\t\t\telse\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = f.rx = i;\n\t\t\t\tf.ly = f.ry = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tpq.push(f);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1000*1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif(f.lx < 0 || w-1 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 0 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(pq.size() > ans) break;\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define fi first\n#define se second\n\nstruct s {\n\tint time;\n\tpii foot;\n\tint nex;\n\ts() {};\n\ts(int t, pii f, int n) {\n\t\ttime = t; foot = f; nex = n;\n\t}\n};\n\nbool operator<(const s &a, const s &b) {\n\treturn a.time > b.time;\n}\n\nbool visit[70][70][2];\nint w, h;\nvector<string> v;\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tfor(int i = 0; i < 70; i++)\n\t\t\tfor(int j = 0; j < 70; j++)\n\t\t\t\tvisit[i][j][0] = visit[i][j][1] = false;\n\t\tv.clear();\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tstring a = \"\";\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tstring b;\n\t\t\t\tcin >> b;\n\t\t\t\ta += b;\n\t\t\t}\n\t\t\tv.push_back(a);\n\t\t}\n\t\tpriority_queue<s> q;\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tif(v[i][j] == 'S') {\n\t\t\t\t\tvisit[i][j][0] = visit[i][j][1] = 1;\n\t\t\t\t\tq.push(s(0, pii(i,j), 0));\n\t\t\t\t\tq.push(s(0, pii(i,j), 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = -1;\n\t\twhile(q.size()) {\n\t\t\ts a;\n\t\t\ta = q.top(); q.pop();\n\t\t\tif(v[a.foot.fi][a.foot.se] == 'T') {\n\t\t\t\tres = a.time;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = -2; i <= 2; i++) {\n\t\t\t\tfor(int j = 1; j <= 3; j++) {\n\t\t\t\t\tif(abs(i) + abs(j) > 3) continue;\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tny = a.foot.fi + i;\n\t\t\t\t\tif(a.nex)\n\t\t\t\t\t\tnx = a.foot.se + j;\n\t\t\t\t\telse\n\t\t\t\t\t\tnx = a.foot.se - j;\n\t\t\t\t\tif(ny < 0 || h <= ny || nx < 0 || w <= nx)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(!visit[ny][nx][!a.nex] && v[ny][nx] != 'X') {\n\t\t\t\t\t\tif(v[ny][nx] == 'T')\n\t\t\t\t\t\t\tq.push(s(a.time, pii(ny,nx), !a.nex));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tq.push(s(a.time+v[ny][nx]-'0', pii(ny,nx), !a.nex));\n\t\t\t\t\t\tvisit[ny][nx][!a.nex] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nstruct edge {\n    int to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, int co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nvoid dijkstra(int s) {\n    priority_queue<plglg, vector<plglg>, greater<plglg> > que;\n    fill(d, d + V + 10, llmax);\n    d[s] = 0;\n    que.push(plglg(0, s));\n\n    while (!que.empty()) {\n        plglg p = que.top();\n        que.pop();\n        ll v = p.second;\n        if (d[v] < p.first) {\n            continue;\n        }\n        int len = G[v].size();\n        for (int i = 0; i < len; i++) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(plglg(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint bo[70][70];\n\nll calcost(int i) {\n    if (i >= 0) {\n        return i;\n    } else if (i == -1) {\n        return llmax;\n    } else {\n        return 0;\n    }\n}\n\nint foot[9][2] = {{2, 1}, {1, 1}, {1, 2}, {0, 1}, {0, 2}, {0, 3}, {-1, 1}, {-1, 2}, {-2, 1}};\n\nint main() {\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        int num = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == 'X') {\n                    bo[i][j] = -1;\n                } else if (isdigit(c)) {\n                    bo[i][j] = c - '0';\n                } else if (c == 'S') {\n                    bo[i][j] = -2;\n                    num++;\n                } else {\n                    bo[i][j] = -3;\n                }\n            }\n        }\n        V = (w * h) * 9 * 2 + (w * h) * 2 + 2;\n        for (int i = 0; i < V; i++) {\n            G[i].clear();\n        }\n        for (int i1 = 0; i1 < h; i1++) {\n            for (int j1 = 0; j1 < w; j1++) {\n                for (int k = 0; k < 9; k++) {\n                    int i2 = i1 + foot[k][0];\n                    int j2 = j1 - foot[k][1];\n                    if (i2 >= 0 && i2 < h && j2 >= 0 && j2 < w) {\n                        if (bo[i2][j2] != -1) {\n                            for (int k2 = 0; k2 < 9; k2++) {\n                                int x = i2 + foot[k2][0];\n                                int y = j2 + foot[k2][1];\n                                if (x >= 0 && x < h && y >= 0 && y < w) {\n                                    if (bo[x][y] != -1) {\n                                        addedge(((i1 * w + j1) * 9 + k) * 2 + 1, ((i2 * w + j2) * 9 + k2) * 2,\n                                                calcost(bo[x][y]));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                for (int k = 0; k < 9; k++) {\n                    int i2 = i1 + foot[k][0];\n                    int j2 = j1 + foot[k][1];\n                    if (i2 >= 0 && i2 < h && j2 >= 0 && j2 < w) {\n                        if (bo[i2][j2] != -1) {\n                            for (int k2 = 0; k2 < 9; k2++) {\n                                int x = i2 + foot[k2][0];\n                                int y = j2 - foot[k2][1];\n                                if (x >= 0 && x < h && y >= 0 && y < w) {\n                                    if (bo[x][y] != -1) {\n                                        addedge(((i1 * w + j1) * 9 + k) * 2, ((i2 * w + j2) * 9 + k2) * 2 + 1,\n                                                calcost(bo[x][y]));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (bo[i][j] == -2) {\n                    addedge(V - 2, (w * h) * 9 * 2 + (i * w + j) * 2 + 1, 0);\n                    for (int k = 0; k < 9; k++) {\n                        int x = i + foot[k][0];\n                        int y = j + foot[k][1];\n                        if (x >= 0 && x < h && y >= 0 && y < w) {\n                            if (bo[x][y] != -1) {\n                                addedge((w * h) * 9 * 2 + (i * w + j) * 2 + 1,\n                                        (i * w + j) * 9 * 2 + k * 2, calcost(bo[x][y]));\n                            }\n                        }\n                    }\n                    addedge(V - 2, (w * h) * 9 * 2 + (i * w + j) * 2, 0);\n                    for (int k = 0; k < 9; k++) {\n                        int x = i + foot[k][0];\n                        int y = j - foot[k][1];\n                        if (x >= 0 && x < h && y >= 0 && y < w) {\n                            if (bo[x][y] != -1) {\n                                addedge((w * h) * 9 * 2 + (i * w + j) * 2,\n                                        (i * w + j) * 9 * 2 + k * 2 + 1, calcost(bo[x][y]));\n                            }\n                        }\n                    }\n                }\n                for (int k = 0; k < 9; k++) {\n                    int x = i + foot[k][0];\n                    int y = j + foot[k][1];\n                    if (x >= 0 && x < h && y >= 0 && y < w) {\n                        if (bo[x][y] == -3) {\n                            addedge((i * w + j) * 9 * 2 + k * 2, V - 1, 0);\n                        }\n                    }\n                    int x2 = i + foot[k][0];\n                    int y2 = j - foot[k][1];\n                    if (x2 >= 0 && x2 < h && y2 >= 0 && y2 < w) {\n                        if (bo[x2][y2] == -3) {\n                            addedge((i * w + j) * 9 * 2 + k * 2 + 1, V - 1, 0);\n                        }\n                    }\n                }\n            }\n        }\n        dijkstra(V - 2);\n        ll ans = d[V - 1];\n        if (ans != llmax) {\n            cout << ans << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18;\n\nll dp[65][35][3];\nint main() {\n\tint w, h;\n\tint dx[9] = { 1,1,2,1,2,3,1,2,1 }, dy[9] = { -2,-1,-1,0,0,0,1,1,2 };\n\tchar s[65][35];\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\tdp[i][j][0] = dp[i][j][1] = 0LL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto isOutOfRange = [] (int x, int y, int h, int w){\n\t\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t\t};\n\t\tauto cost = [&](int x, int y) {\n\t\t\tif (s[y][x] == 'X') return INF;\n\t\t\tif (s[y][x] == 'S') return INF;\n\t\t\tif (s[y][x] == 'T') return 0LL;\n\t\t\treturn (ll)s[y][x] - '0';\n\t\t};\n\t\tfor (int _ = 0; _ < 1800*10; _++) {\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tfor (int now = 0; now < 2; now++) {\n\t\t\t\t\t\tif (dp[y][x][now] == INF) continue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + (now==0?dx[i]:-dx[i]), ny = y + dy[i], nxt = (now + 1) % 2;\n\t\t\t\t\t\t\tif (isOutOfRange(nx, ny, h, w) || s[ny][nx] == 'X') continue;\n\t\t\t\t\t\t\tdp[ny][nx][nxt] = min(dp[ny][nx][nxt], dp[y][x][now] + cost(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcout << \"(\" << (dp[i][j][0]==INF?-1:dp[i][j][0]) << \", \" << (dp[i][j][1]==INF?-1:dp[i][j][1])<< \")\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tll ans = INF;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] != 'T') continue;\n\t\t\t\tans = min({ ans, dp[i][j][0], dp[i][j][1] });\n\t\t\t}\n\t\t}\n\t\tif (ans == INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdlib>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int x, y, foot, cost;\n    Edge(int _x, int _y, int f, int c)\n        : x(_x), y(_y), foot(f), cost(c) {}\n    Edge() {}\n    bool operator<(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w + h) {\n        auto mp = make_v(h, w, ' ');\n        REP(i, 0, h) {\n            REP(j, 0, w) {\n                cin >> mp[i][j];\n            }\n        }\n        priority_queue<Edge, vector<Edge>> pq;\n        REP(i, 0, h) {\n            REP(j, 0, w) {\n                if (mp[i][j] == 'S') {\n                    REP(x, -3, 4) {\n                        if (x == 0) continue;\n                        REP(y, -3, 4) {\n                            if (abs(x) + abs(y) > 3) continue;\n                            int nx = j + x;\n                            int ny = i + y;\n                            if (nx < 0 || ny < 0 || nx >= w || ny >= h || mp[ny][nx] == 'X') continue;\n                            pq.emplace(nx, ny, x < 0, mp[ny][nx] - '0');\n                        }\n                    }\n                }\n            }\n        }\n        const int inf = 1 << 29;\n        auto Cost = make_v(w, h, 2, inf);\n        auto used = make_v(w, h, 2, false);\n        int ans = -1;\n        while (pq.size()) {\n            Edge e = pq.top();\n            pq.pop();\n            if (used[e.x][e.y][e.foot]) continue;\n            used[e.x][e.y][e.foot] = true;\n            if (mp[e.y][e.x] == 'T') {\n                ans = e.cost;\n                break;\n            }\n            REP(x, 1, 4) {\n                REP(y, -3, 4) {\n                    if (x + abs(y) > 3) continue;\n                    int nx = e.x + (2 * e.foot - 1) * x;\n                    int ny = e.y + y;\n                    if (nx < 0 || ny < 0 || nx >= w || ny >= h || mp[ny][nx] == 'X') continue;\n                    int nc = mp[ny][nx] - '0';\n                    if (mp[ny][nx] == 'T') {\n                        nc = 0;\n                    }\n                    if (Cost[nx][ny][!e.foot] > e.cost + nc) {\n                        Cost[nx][ny][!e.foot] = e.cost + nc;\n                        pq.emplace(nx, ny, !e.foot, Cost[nx][ny][!e.foot]);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<pint,pint> ppi;\npint ss[2001];\nconst int dx[]={1,1,1,1,1,2,2,2,3},dy[]={2,1,0,-1,-2,1,0,-1,0};\nchar s[61][31];\nint d[2001][2];\nint INF=1000100010;\nint n,cur,w,h;\nint dijkstra(){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(j,2) d[i][j]=INF;\n    rep(i,cur){\n        d[ss[i].first+ss[i].second*w][0]=d[ss[i].first+ss[i].second*w][1]=0;\n        pq.push({{0,0},{ss[i].first,ss[i].second}});\n        pq.push({{0,1},{ss[i].first,ss[i].second}});\n    }\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int cost=pi.first.first,lr=pi.first.second;\n        int x=pi.second.first,y=pi.second.second;\n        if(d[x+y*w][lr]<pi.first.first) continue;\n        rep(i,9){\n            int p=1;\n            if(lr==0) p=-1;\n            int tx=x+dx[i]*p,ty=y+dy[i];\n            if(tx>=0&&tx<w&&ty>=0&&ty<h&&s[ty][tx]!='X'){\n                if(s[ty][tx]=='T') return cost;\n                else if(isdigit(s[ty][tx])){\n                    int tt=s[ty][tx]-'0';\n                    if(d[tx+ty*w][1-lr]>cost+tt){\n                        d[tx+ty*w][1-lr]=cost+tt;\n                        pq.push({{cost+tt,1-lr},{tx,ty}});\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    while(cin>>w>>h,w|h){\n        n=w*h;\n        cur=0;\n        rep(i,h)rep(j,w){\n            cin>>s[i][j];\n            if(s[i][j]=='S') ss[cur++]={j,i};\n        }\n        cout<<dijkstra()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1150\n// Cliff Climbing\n#include<iostream>\n#include<cmath>\n#include<stdio.h>\n#define MAX_W 30\n#define MAX_H 60\n#define INF 1000000\n\nusing namespace std;\nchar map[MAX_H][MAX_W];\nint d[MAX_H][MAX_W][2];\t\t// ??¶???(y??????x??????foot?¶?)\nbool used[MAX_H][MAX_W][2];\nint w, h;\n\nbool transision(int x, int y, int foot, int new_x, int new_y)\n{\n  int new_foot;\n  if(foot)\n    new_foot = 0;\n  else\n    new_foot = 1;\n  if(new_foot)\t\t\t// ????¶?\n    {\n      if(x >= new_x)return false;      \n    }\n  else\t\t\t\t// ????¶?\n    {\n      if(new_x >= x)return false;\n    }\n\n  if(0 <= new_x && new_x < w && 0 <= new_y && new_y < h && map[new_y][new_x] != 'X')\n    {\n      if(abs((double)(x - new_x)) + abs((double)(y - new_y)) <= 3)\n\treturn true;\n      else\n\treturn false;\n    }\n  else\n    return false;\n}\n\nvoid dijkstra(int s_x, int s_y, int s_foot)\n{\n  d[s_y][s_x][s_foot] = 0;\t// ????????¶???=?????????0\n  while(true)\n    {\n      int x = -1, y = -1, foot = -1;\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  for(int k = 0; k < 2; k++) // ???????????????????????? ?????? ????????¶????????????????????????????°???????=???????????¢????¢????????????????\n\t    if(!used[i][j][k] && ((x == -1 && y == -1 && foot == -1) || (d[i][j][k] < d[y][x][foot])))\n\t      x = j, y = i, foot = k;\n\n      // cout << x << y << foot << endl;\n      // cout << d[y][x][foot] << endl;\n\n      if(x == -1 && y == -1 && foot == -1)\n\tbreak;\n      used[y][x][foot] = true;\n      // ??¶???(y, x, foot)??????????§????????????¶??????\"????????¶?????????????????????\"?????´??°\n      for(int i = y + 3; i >= y - 3; i--)\n\tfor(int j = x - 3; j <= x + 3; j++)\n\t  {\n\t    if(transision(x, y, foot, j, i))\n\t      {\n\t\t//\t\tcout << \"!!!\" << endl;;\n\t\tint new_f, cost;\n\t\tif(foot)\n\t\t  new_f = 0;\n\t\telse\n\t\t  new_f = 1;\n\t\tif(map[i][j] == 'S' || map[i][j] == 'T')\n\t\t  cost = 0;\n\t\telse\n\t\t  cost = map[i][j] - '0';\n\t\td[i][j][new_f] = min(d[i][j][new_f], d[y][x][foot] + cost);\n\t      }\n\t  }\n    }\n}\n\nint main(void)\n{\n  while(cin >> w >> h, (w && h))\n    {\n      for(int i = 0; i < MAX_H; i++)\n\tfor(int j = 0; j < MAX_W; j++)\n\t  for(int k = 0; k < 2; k++)\n\t    {\n\t      d[i][j][k] = INF;\n\t      used[i][j][k] = false;\n\t    }\n\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  cin >> map[i][j];\n\n      \n      int ans = INF;\n\n      for(int ii = 0; ii < h; ii++)\n\tfor(int jj = 0; jj < w; jj++)\n\t  if(map[ii][jj] == 'S')\n\t    {\n\t      dijkstra(jj, ii, 0); // ????¶?????????????\n\t      dijkstra(jj, ii, 1); // ????¶?????????????\n\t      for(int i = 0; i < h; i++)\n\t\tfor(int j = 0; j < w; j++)\n\t\t  if(map[i][j] == 'T')\n\t\t    {\n\t\t      //\t      cout << d[i][j][0] << \", \" << d[i][j][1] << endl;;\n\t\t      ans = min(ans, d[i][j][0]);\n\t\t      ans = min(ans, d[i][j][1]);\n\t\t    }\n\t      for(int i = 0; i < MAX_H; i++)\n\t\tfor(int j = 0; j < MAX_W; j++)\n\t\t  for(int k = 0; k < 2; k++)\n\t\t    {\n\t\t      d[i][j][k] = INF;\n\t\t      used[i][j][k] = false;\n\t\t    }\n\t    }\n\n\n      if(ans != INF)\n\tcout << ans << endl;\n      else\n\tcout << \"-1\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\n\nstruct position {\n\tint i, j;\n\n\tposition(int i, int j) :i(i), j(j){\n\t}\n};\n\nconst int MAX_V = 3600;\nconst int INF = 9999999;\n\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint dxl[] = {1, 1, 1, 1, 1, 2, 2, 2, 3}, dyl[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\nint dxr[] = {-1, -1, -1, -1, -1, -2, -2, -2, -3}, dyr[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nint h, w;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint toV(int i, int j, int foot){\n\treturn 2 * (i * w + j) + foot;\n}\n\nvoid calc(int s){\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[s] = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\tif (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < V; u++) {\n\t\t\td[u] = min(d[u], d[v] + cost[v][u]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tauto s = vvc(h, vc(w, 0));\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> s[i][j];\n\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tfor (int j = 0; j < MAX_V; j++)\n\t\t\t\tcost[i][j] = INF;\n\n\t\tV = w * h * 2;\n\n\t\tauto start = vector<position>();\n\t\tauto goal = vector<position>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'S') start.push_back(position(i, j));\n\t\t\t\telse if (s[i][j] == 'T') goal.push_back(position(i, j));\n\t\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcost[toV(i, j, 0)][toV(i, j, 0)] = 0;\n\t\t\t\tcost[toV(i, j, 1)][toV(i, j, 1)] = 0;\n\n\t\t\t\t// left foot\n\t\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\t\tint ni = i + dyl[k], nj = j + dxl[k];\n\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\tif ('1' <= s[ni][nj] && s[ni][nj] <= '9')\n\t\t\t\t\t\tcost[toV(i, j, 0)][toV(ni, nj, 1)] = s[ni][nj] - '0';\n\t\t\t\t\telse if (s[ni][nj] == 'S' || s[ni][nj] == 'T')\n\t\t\t\t\t\tcost[toV(i, j, 0)][toV(ni, nj, 1)] = 0;\n\t\t\t\t}\n\n\t\t\t\t// right foot\n\t\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\t\tint ni = i + dyr[k], nj = j + dxr[k];\n\t\t\t\t\tif (!in(ni, nj)) continue;\n\t\t\t\t\tif ('1' <= s[ni][nj] && s[ni][nj] <= '9')\n\t\t\t\t\t\tcost[toV(i, j, 1)][toV(ni, nj, 0)] = s[ni][nj] - '0';\n\t\t\t\t\telse if(s[ni][nj] == 'S' || s[ni][nj] == 'T')\n\t\t\t\t\t\tcost[toV(i, j, 1)][toV(ni, nj, 0)] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (auto&& sp : start) {\n\t\t\tcalc(toV(sp.i, sp.j, 0));\n\t\t\tfor (auto&& gp : goal) {\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 0)]);\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 1)]);\n\t\t\t}\n\t\t\tcalc(toV(sp.i, sp.j, 1));\n\t\t\tfor(auto&& gp : goal) {\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 0)]);\n\t\t\t\tans = min(ans, d[toV(gp.i, gp.j, 1)]);\n\t\t\t}\n\t\t}\n\n\t\tif (ans == INF)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nstruct State{\n    int y, x, lr, c;\n    State(int y, int x, int lr, int c): y(y), x(x), lr(lr), c(c){}\n    bool operator<(const State& right ) const {\n        return c > right.c;\n    }\n};\n\nint main(){\n    while(1){\n        int W, H;\n        cin >> W >> H;\n        if(W == 0) break;\n\n        char field[30][60];\n        int minDist[30][60][2];\n        memset(minDist, -1, sizeof(minDist));\n        priority_queue<State> que;\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j] == 'S'){\n                    minDist[i][j][0] = 0;\n                    minDist[i][j][1] = 0;\n                    que.emplace(i, j, 0, 0);\n                    que.emplace(i, j, 1, 0);\n                }\n            }\n        }\n\n        int ans = -1;\n        while(que.size()){\n            State s = que.top(); que.pop();\n            if(minDist[s.y][s.x][s.lr] < s.c) continue;\n            if(field[s.y][s.x] == 'T'){\n                ans = s.c;\n                break;\n            }\n            int mul = s.lr == 0 ? 1 : -1;\n            for(int dx=mul;abs(dx)<=3;dx+=mul){\n                for(int dy=-3+abs(dx);abs(dy)+abs(dx)<=3;dy++){\n                    int ny = s.y + dy, nx = s.x + dx, nlr = (s.lr+1)%2, nc = s.c;;\n                    if(ny<0 || H<=ny || nx<0 || W<=nx) continue;\n                    if(field[ny][nx] == 'X') continue;\n                    if('1' <= field[ny][nx] && field[ny][nx] <= '9'){\n                        nc += field[ny][nx] - '0';\n                    }\n                    if(minDist[ny][nx][nlr] == -1 || minDist[ny][nx][nlr] > nc){\n                        minDist[ny][nx][nlr] = nc;\n                        que.emplace(ny, nx, nlr, nc);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n\nstruct feet {\n\tint lx, ly, rx, ry, p, cnt;\n\tbool operator() (feet const &a, feet const &b) {\n\t\treturn a.cnt > b.cnt;\n\t}\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h) {\n\t\tpriority_queue<feet, vector<feet>, feet> pq;\n\t\tmap<string, int> memo;\n\n\t\tint field[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tchar input;\n\t\t\t\tcin >> input;\n\t\t\t\tif(((int)input - '0') < 10)\n\t\t\t\t\tfield[i][j] = (int)input - '0';\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[i][j] = 10;\n\t\t\t\telse if(input == 'S')\n\t\t\t\t\tfield[i][j] = 11;\n\t\t\t\telse if(input == 'T')\n\t\t\t\t\tfield[i][j] = 12;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<w; i++) {\n\t\t\tif(field[h-1][i] == 11) {\n\t\t\t\tfeet f;\n\t\t\t\tf.lx = i;\n\t\t\t\tf.ly = h-1;\n\t\t\t\tf.p = 0;\n\t\t\t\tf.cnt = 0;\n\t\t\t\tfor(int j=i+1; j<w; j++) {\n\t\t\t\t\tif(field[h-1][j] == 11) {\n\t\t\t\t\t\tf.rx = j;\n\t\t\t\t\t\tf.ry = h-1;\n\t\t\t\t\t\tpq.push(f);\n\t\t\t\t\t\tstring chk = to_string(f.rx) + to_string(f.ry) + to_string(f.p);\n\t\t\t\t\t\tmemo[chk] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\tcout << field[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}\n\t\tint ans = 1000*1000;\n\n\t\twhile(pq.size()) {\n\t\t\tfeet f;\n\t\t\tf = pq.top();\n\t\t\tpq.pop();\n\n//\t\t\tcout << pq.size() << \" size\" << endl;\n\t\t\tif(f.lx < 0 || w-2 < f.lx || f.ly < 0 || h-1 < f.ly) continue;\n\t\t\tif(f.rx < 1 || w-1 < f.rx || f.ry < 0 || h-1 < f.ry) continue;\n\t\t\tif(field[f.ly][f.lx] == 10 || field[f.ry][f.rx] == 10) continue;\n\t\t\tif(field[f.ly][f.lx] == 12 || field[f.ry][f.rx] == 12) {\n\t\t\t\t\tf.cnt -= 12;\n//\t\t\t\t\tcout << ans << ' ' << f.cnt << \" ans\" << endl;\n//\t\t\t\t\tcout << f.lx << ' ' << f.ly << ' ' << f.rx << ' ' << f.ry << ' ' << f.cnt << ' ' << f.p << \" ans\"  << endl;\n\t\t\t\t\tans = ans>f.cnt ? f.cnt : ans;\n\t\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcout << f.lx << ' ' << f.ly << ' ' << f.rx << ' ' << f.ry << ' ' << f.cnt << ' ' << f.p << endl;\n\n\t\t\tif(f.p == 0 || f.p == 1) { //right foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=0; i<=2; i++) {\n\t\t\t\t\tfor(int j=i-2; j<=-i+2; j++) {\n\t\t\t\t\t\ttemp.ry = f.ly + j;\n\t\t\t\t\t\ttemp.rx = f.lx+i+1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ry][temp.rx];\n\t\t\t\t\t\ttemp.p = 2;\n\t\t\t\t\t\tstring chk = to_string(temp.rx) + to_string(temp.ry) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f.p == 0 || f.p == 2) { //left foot\n\t\t\t\tfeet temp = f;\n\t\t\t\tfor(int i=-2; i<=0; i++) {\n\t\t\t\t\tfor(int j=-i-2; j<=i+2; j++) {\n\t\t\t\t\t\ttemp.ly = f.ry + j;\n\t\t\t\t\t\ttemp.lx = f.rx+i-1;\n\t\t\t\t\t\ttemp.cnt += field[temp.ly][temp.lx];\n\t\t\t\t\t\ttemp.p = 1;\n\t\t\t\t\t\tstring chk = to_string(temp.lx) + to_string(temp.ly) + to_string(temp.p);\n\t\t\t\t\t\tif(memo.find(chk) == memo.end() || memo[chk] > temp.cnt) {\n\t\t\t\t\t\t\tmemo[chk] = temp.cnt;\n\t\t\t\t\t\t\tpq.push(temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000*1000)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<vector>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_DIR 9\n#define MAX_N 100\n#define INF 1 << 30\n\nchar C;\nint X[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint G[MAX_N][MAX_N];\nint DIST[MAX_N][MAX_N][MAX_DIR];//Left,DY-DX\nint dy[MAX_DIR] = { 1,1,1,1,1,2,2,2,3 };\nint dx[MAX_DIR] = { -2,-1,0,1,2,-1,0,1,0 };\nint dz[MAX_DIR] = { 4,3,2,1,0,7,6,5,8 };\nint H, W;\nchar U[11] = \"0123456789\";\n\npriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>> > Q;\n\nvoid MEMSET() {\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tX[i][j] = INF;\n\t\t\tS[i][j] = 0;\n\t\t\tG[i][j] = 0;\n\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\tDIST[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DIJKSTRA() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i + dy[k];\n\t\t\t\t\tint X1 = j + dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[i][j][k] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (S[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint Y1 = i - dy[k];\n\t\t\t\t\tint X1 = j - dx[k];\n\t\t\t\t\tif (S[Y1][X1] == 1) {\n\t\t\t\t\t\tDIST[Y1][X1][dz[k]] = 0;\n\t\t\t\t\t\tQ.push(make_tuple(0, i, j, dz[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\ttuple<int, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tint LY = a2, LX = a3;\n\t\tint RY = a2 + dy[a4], RX = a3 + dx[a4];\n\n\t\t//hidari.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = RY - dy[k];\n\t\t\tint cx = RX - dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[cy][cx][dz[k]] > dis + pos) {\n\t\t\t\t\tDIST[cy][cx][dz[k]] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[cy][cx][dz[k]], cy, cx, dz[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//migi.\n\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\tint cy = LY + dy[k];\n\t\t\tint cx = LX + dx[k];\n\t\t\tif (cy < 1 || cy > H) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cx < 1 || cx > W) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (X[cy][cx] < INF) {\n\t\t\t\tint dis = X[cy][cx];\n\t\t\t\tint pos = DIST[LY][LX][a4];\n\t\t\t\tif (DIST[LY][LX][k]>dis + pos) {\n\t\t\t\t\tDIST[LY][LX][k] = dis + pos;\n\t\t\t\t\tQ.push(make_tuple(DIST[LY][LX][k], LY, LX, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (G[i][j] == 1) {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < MAX_DIR; k++) {\n\t\t\t\t\tint ey = i + dy[k];\n\t\t\t\t\tint ex = j + dx[k];\n\t\t\t\t\tif (ey < 1 || ey > H) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ex < 1 || ex > W) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (G[ey][ex] == 1) {\n\t\t\t\t\t\tres = min(res, DIST[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res >= INF) {\n\t\treturn -1;\n\t}\n\treturn res;\n}\n\nvoid CIN() {\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> C;\n\t\t\tif (C == 'X') {\n\t\t\t\tX[i][j] = INF;\n\t\t\t}\n\t\t\telse if (C == 'S') {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tS[i][j] = 1;\n\t\t\t}\n\t\t\telse if (C == 'T') {\n\t\t\t\tX[i][j] = 0;\n\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (U[k] == C) {\n\t\t\t\t\t\tX[i][j] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= W; i++) {\n\t\tS[H + 1][i] = 1;\n\t\tX[H + 1][i] = 0;\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tMEMSET();\n\t\t//cin.\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tCIN();\n\t\tcout << DIJKSTRA() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1.05e7;\n\n\nint calc_cost(vector<vector<char> > &m, int x, int y)\n{\n\tint w = m.size(), h = m[0].size();\n\tif(x < 0 || x >= w || y < 0 || y >= h)\n\t\treturn inf;\n\tif(m[x][y] < '0' || m[x][y] > '9')\n\t\treturn (m[x][y] == 'T' || m[x][y] == 'S') ? 0 : inf;\n\treturn m[x][y] - '0'; \n}\n\n\nint calc_idx(vector<vector<char> > &m, int x1, int y1, int x2, int y2, int next)\n{\n\tint w = m.size(), h = m[0].size();\n\treturn ((x1 * h + y1) * (w * h) + (x2 * h + y2)) * 2 + next;\n}\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tint w, h, wh;\n\t\tvector<vector<char> > m;\n\t\tconst int dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\t\tconst int dy[] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\t\tconst int dir = 9;\n\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\twh = w * h;\n\t\tm.resize(w);\n\t\tfor(int i = 0; i < w; ++i)\n\t\t\tm[i].resize(h);\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x)\n\t\t\t\tscanf(\" %c\", &m[x][y]);\n\t\t}\n\n\t\tvector<int> distl, distr;\n\t\tpriority_queue<pair<int, int> > q;\n\t\tint ans = inf;\n\n\t\tdistl.resize(wh * wh * 2, inf);\n\t\tdistr.resize(wh * wh * 2, inf);\n\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\n\t\t\t\tif(m[x][y] != 'S')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx1 = x + dx[d], nx2 = x - dx[d];\n\t\t\t\t\tint ny1 = y + dy[d], ny2 = y + dy[d];\n\t\t\t\t\tint c1 = calc_cost(m, nx1, ny1);\n\t\t\t\t\tint c2 = calc_cost(m, nx2, ny2);\n\t\t\t\t\tif(c1 < inf)\n\t\t\t\t\t\tq.push(make_pair(-c1, calc_idx(m, x, y, nx1, ny1, 0)));\n\t\t\t\t\tif(c2 < inf)\n\t\t\t\t\t\tq.push(make_pair(-c2, calc_idx(m, nx2, ny2, x, y, 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!q.empty()) {\n\n\t\t\tint cost = -q.top().first;\n\t\t\tint idx = q.top().second;\n\t\t\tq.pop();\n\n\t\t\tint x1 = ((idx / 2) / wh) / h;\n\t\t\tint y1 = ((idx / 2) / wh) % h;\n\t\t\tint x2 = ((idx / 2) % wh) / h;\n\t\t\tint y2 = ((idx / 2) % wh) % h;\n\t\t\tint next = idx % 2;\n\n\t\t\t//printf(\"%d %d %d %d (%d) -> %d  / %c %c\\n\", x1, y1, x2, y2, next, cost,\n\t\t\t//\tm[x1][y1], m[x2][y2]);\n\n\t\t\tif(next == 0) {\n\t\t\t\tif(distr[idx] <= cost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdistr[idx] = cost;\n\t\t\t} else {\n\t\t\t\tif(distl[idx] <= cost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdistl[idx] = cost;\n\t\t\t}\n\n\t\t\tif((m[x1][y1] == 'T') || (m[x2][y2] == 'T')) {\n\t\t\t\tans = min(ans, cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(next == 0) {\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx = x2 - dx[d], ny = y2 + dy[d];\n\t\t\t\t\tint c = calc_cost(m, nx, ny) + cost;\n\t\t\t\t\tint i = calc_idx(m, nx, ny, x2, y2, 1);\n\t\t\t\t\tif(c >= inf)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(c >= distl[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tq.push(make_pair(-c, i));\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor(int d = 0; d < dir; ++d) {\n\t\t\t\t\tint nx = x1 + dx[d], ny = y1 + dy[d];\n\t\t\t\t\tint c = calc_cost(m, nx, ny) + cost;\n\t\t\t\t\tint i = calc_idx(m, x1, y1, nx, ny, 0);\n\t\t\t\t\tif(c >= inf)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(c >= distr[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tq.push(make_pair(-c, i));\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\tif(ans < inf)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tprintf(\"-1\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 1e+9\n#define mp make_pair\nusing namespace std;\n\nstruct edge{ int to,cost; };\ntypedef pair<int,int> POS;//x,y\ntypedef pair<int,POS> FOOT;//foot\ntypedef pair<int,FOOT> P;//cost\n\nint dx[] = {-2,-1,-1,0,0,0,1,1,2},dy[] = {1,1,2,1,2,3,1,2,1};\n\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h,w){\n\t\tint field[60][30],d[60][30][2];\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tvector<POS> t;\n\t\tfor(int i = 0;i < 60;i++){\n\t\t\tfor(int j = 0;j < 30;j++) {\n\t\t\t\td[i][j][0] = INF;\n\t\t\t\td[i][j][1] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c != 'X'){\n\t\t\t\t\tif(c == 'S'){\n\t\t\t\t\t\td[i][j][0] = 0;\n\t\t\t\t\t\td[i][j][1] = 0;\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\tque.push(mp(0,mp(-1,mp(i,j))));\n\t\t\t\t\t\tque.push(mp(0,mp(1,mp(i,j))));\n\t\t\t\t\t}else if(c == 'T'){\n\t\t\t\t\t\tt.push_back(mp(i,j));\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t}else field[i][j] = c - '0';\n\t\t\t\t}else field[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint cost = p.first,foot = p.second.first,x = p.second.second.first,y = p.second.second.second;\n\t\t\tint fa = (foot + 1) / 2,_fa = (1 - foot) / 2;\n\t\t\tif(d[x][y][fa] < cost) continue;\n\t\t\tfor(int i = 0;i < 9;i++){\n\t\t\t\tint nx = x + foot * dx[i],ny = y + foot * dy[i];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != INF && d[nx][ny][_fa] > d[x][y][fa] + field[nx][ny]){\n\t\t\t\t\td[nx][ny][_fa] = d[x][y][fa] + field[nx][ny];\n\t\t\t\t\tque.push(mp(d[nx][ny][_fa],mp(-foot,mp(nx,ny))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < t.size();i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tmi = min(mi,d[t[i].first][t[i].second][j]);\n\t\t\t}\n\t\t}\n\t\tif(mi != INF) cout << mi << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint W,H;\nchar board[61][31];\n\nconst int INF=1e9;\n\n#define mkt make_tuple\nint dist[61][31][61][31][2];\n\nint dijkstra(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<H;k++){\n                for(int l=0;l<W;l++){\n                    dist[i][j][k][l][0]=INF;\n                    dist[i][j][k][l][1]=INF;\n                }\n            }\n        }\n    }\n    priority_queue<tuple<int,int,int,int,int,int>> PQ;\n    for(int i=0;i<W;i++){\n        if(board[0][i]=='S'){\n            dist[0][i][0][0][0]=0;\n            dist[0][0][0][i][1]=0;\n            PQ.push(mkt(0,0,i,0,0,0));\n            PQ.push(mkt(0,0,0,0,i,1));\n        }\n    }\n\n    while(!PQ.empty()){\n        auto f=PQ.top();\n        PQ.pop();\n\n        int co,lx,ly,rx,ry,p;\n        co=-get<0>(f);\n        lx=get<1>(f);\n        ly=get<2>(f);\n        rx=get<3>(f);\n        ry=get<4>(f);\n        p=get<5>(f);\n\n        if(dist[lx][ly][rx][ry][p]<co) continue;\n\n        if(board[lx][ly]=='T'||board[rx][ry]=='T') return co;\n\n        for(int i=1;i<=3;i++){\n            for(int j=i-3;j<=3-i;j++){\n                int dx=j,dy=i;\n                int nlx=lx,nly=ly,nrx=rx,nry=ry;\n                int neco=0;\n                if(p==0){\n                    nrx=nlx+dx;\n                    nry=nly+dy;\n                    if(nrx<0||nrx>=H||nry<0||nry>=W) continue;\n                    if(board[nrx][nry]=='X'||board[nrx][nry]=='S') continue;\n                    if(board[nrx][nry]!='T') neco+=board[nrx][nry]-'0';\n                }else{\n                    nlx=nrx+dx;\n                    nly=nry-dy;\n                    if(nlx<0||nlx>=H||nly<0||nly>=W) continue;\n                    if(board[nlx][nly]=='X'||board[nlx][nly]=='S') continue;\n                    if(board[nlx][nly]!='T') neco+=board[nlx][nly]-'0';\n                }\n\n                if(dist[nlx][nly][nrx][nry][1-p]<co+neco) continue;\n                dist[nlx][nly][nrx][nry][1-p]=co+neco;\n                PQ.push(mkt(-(co+neco),nlx,nly,nrx,nry,1-p));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>board[H-i-1][j];\n        }\n    }\n\n    int ans=dijkstra();\n    cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>W>>H;\n      if(W==0&&H==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint W,H;\nint tiles[31][61] = {};\nint tleft[31][61] = {};\nint tright[31][61] = {};\nstruct Position {\n    int x,y;\n    bool foot; // true:left false:right\n};\nstruct CompareByFirst {\n    bool operator()(pair<int, Position> const & a,\n                              pair<int, Position> const & b) const\n    { return a.first > b.first; }\n};\nvector<int> answers;\n\nint main() {\nSTART:\n    while (cin>>W>>H && W != 0 && H != 0) {\n        priority_queue<pair<int, Position>, vector<pair<int, Position> >, CompareByFirst> pqueue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                tleft[w][h] = -1;\n                tright[w][h] = -1;\n                char tile = 0;\n                cin>>tile;\n                switch(tile) {\n                    case 'S':\n                    {\n                        tiles[w][h] = 0;\n                        Position pos = {w,h,true};\n                        pqueue.push(make_pair(0, pos));\n                        pos.foot = false;\n                        pqueue.push(make_pair(0, pos));\n                        break;\n                    }\n\n                    case 'T':\n                    {\n                        tiles[w][h] = -2;\n                        break;\n                    }\n\n                    case 'X':\n                        tiles[w][h] = -1;\n                        break;\n\n                    default:\n                        tiles[w][h] = atoi(&tile);\n                }\n            }\n        }\n\n        while (!pqueue.empty()) {\n            pair<int, Position> p = pqueue.top();\n            pqueue.pop();\n            if (p.second.foot == true) {\n                if (tleft[p.second.x][p.second.y] == -1) tleft[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = 1; w <= 3 - abs(h); w++) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                answers.push_back(p.first);\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, false};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (tright[p.second.x][p.second.y] == -1) tright[p.second.x][p.second.y] = p.first;\n                else continue;\n\n                for (int h = -2; h <= 2; h++) {\n                    for (int w = -1; w >= abs(h) - 3; w--) {\n                        if (0 <= p.second.x+w && p.second.x+w < W && 0 <= p.second.y+h && p.second.y+h < H) {\n                            if (tiles[p.second.x+w][p.second.y+h] == -1) continue;\n                            else if (tiles[p.second.x+w][p.second.y+h] == -2) {\n                                answers.push_back(p.first);\n                                goto START;\n                            } else {\n                                Position pos = {p.second.x+w, p.second.y+h, true};\n                                //cout<<\"distance:\"<<p.first+tiles[p.second.x+w][p.second.y+h]<<\", x:\"<<pos.x<<\", y:\"<<pos.y<<\", foot:\"<<(pos.foot ? \"left\" : \"right\")<<endl;\n                                pqueue.push(make_pair(p.first+tiles[p.second.x+w][p.second.y+h], pos));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        answers.push_back(-1);\n    }\n\n    for (int i = 0; i < answers.size(); i++) cout<<answers[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int step;\n    bool next_right;\n    int y,x;\n    State(int s,bool nr,int y,int x) : step(s),next_right(nr),y(y),x(x) {};\n    bool operator<(const State& rhs){\n        return step < rhs.step;\n    }\n};\n\n\nstruct Comp{\n    bool operator()(State& left,State& right){\n        return left.step > right.step;\n    };\n};\n\nint main(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 and h == 0) break;\n        vector<vector<char> > S(h,vector<char>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> S[i][j];\n            }\n        }\n\n        set<pair<int,int> > goal;\n        priority_queue<State,vector<State>,Comp > que;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(S[i][j] == 'S'){\n                    que.push(State(0,true,i,j));\n                    que.push(State(0,false,i,j));\n                }else if(S[i][j] == 'T'){\n                    goal.insert(make_pair(i,j));\n                }\n            }\n        }\n        int ret = -1;\n        // right?\n        vector<vector<vector<char> > > used(h,vector<vector<char> >(w,vector<char>(2,false)));\n        while(not que.empty()){\n            State s = que.top();\n            que.pop();\n            if(goal.find(make_pair(s.y,s.x)) != goal.end()){\n                ret = s.step;\n                break;\n            }\n            if(used[s.y][s.x][s.next_right]) continue;\n            used[s.y][s.x][s.next_right] = true;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(s.next_right){\n                        if(s.x < j and abs(i-s.y)+abs(j-s.x) <= 3){\n                            if(S[i][j] == 'T'){\n                                que.push(State(s.step,!s.next_right,i,j));\n                            }else if(S[i][j] != 'S' and S[i][j] != 'X'){\n                                que.push(State(s.step+S[i][j]-'0',!s.next_right,i,j));\n                            }\n                        }\n                    }else{\n                        if(s.x > j and abs(i-s.y)+abs(j-s.x) <= 3){\n                            if(S[i][j] == 'T'){\n                                que.push(State(s.step,!s.next_right,i,j));\n                            }else if(S[i][j] != 'S' and S[i][j] != 'X'){\n                                que.push(State(s.step+S[i][j]-'0',!s.next_right,i,j));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MAX = 1LL << 50;\n\nll h, w;\nll a[30][50];\nchar b[30][50];\nll minr[30][50];//????????°???????°????\nll minl[30][50];//????????°???????°????\nint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\nqueue<P> quer;\nqueue<P> quel;\n\nvoid doRight() {\n\twhile (!quel.empty()) {\n\t\tP p = quel.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquel.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x + dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minr[yy][xx] > minl[y][x] +a[yy][xx]) {\n\t\t\t\tminr[yy][xx] = minl[y][x] + a[yy][xx];\n\t\t\t\tquer.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid doLeft() {\n\twhile (!quer.empty()) {\n\t\tP p = quer.front();\n\t\tint y = p.second;\n\t\tint x = p.first;\n\t\tquer.pop();\n\t\tfor(int i = 0; i < 9; ++i) {\n\t\t\tint yy = y + dy[i];\n\t\t\tint xx = x - dx[i];\n\t\t\tif (!(0 <= yy && yy < h && 0 <= xx && xx < w && b[yy][xx] != 'X')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (minl[yy][xx] > minr[y][x] +a[yy][xx]) {\n\t\t\t\tminl[yy][xx] = minr[y][x] + a[yy][xx];\n\t\t\t\tquel.push(make_pair(xx, yy));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\n\t\tfor (ll i = 0; i < h; ++i) {\n\t\t\tfor (ll j = 0; j < w; ++j) {\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (ll i = 0; i < h; ++i) {\n\t\t\tfor (ll j = 0; j < w; ++j) {\n\t\t\t\tminr[i][j] = MAX;\n\t\t\t\tminl[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\t//?¨?????????°??????\n\t\tfor (ll i = 0; i < h; ++i) {\n\t\t\tfor (ll j = 0; j < w; ++j) {\n\t\t\t\tif ('S' == b[i][j]) {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\tminr[i][j] = 0;\n\t\t\t\t\tminl[i][j] = 0;\n\t\t\t\t} else if ('X' == b[i][j]) {\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t} else if ('T' == b[i][j]) {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = b[i][j] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (a[h - 1][i] == 0) {\n\t\t\t\tquel.push(make_pair(i, h - 1));\n\t\t\t}\n\t\t}\n\t\twhile (!quel.empty()) {\n\t\t\tdoRight();\n\t\t\tdoLeft();\n\t\t}\n\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (a[h - 1][i] == 0) {\n\t\t\t\tquer.push(make_pair(i, h - 1));\n\t\t\t}\n\t\t}\n\t\tdo {\t\n\t\t\tdoLeft();\n\t\t\tdoRight();\n\t\t}while (!quer.empty());\n\n\n\t\tll min = MAX;\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tif (b[0][i] == 'T' && minr[0][i] < min) {\n\t\t\t\tmin = minr[0][i];\n\t\t\t}\n\t\t\tif (b[0][i] == 'T' && minl[0][i] < min) {\n\t\t\t\tmin = minl[0][i];\n\t\t\t}\n\t\t}\n\n\t\tif (min == MAX) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << min << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <functional>\n#define INF 100000000\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nclass Node{\npublic:\n  Node(int x, int y, int f):x(x),y(y),f(f){}\n  int x,y,f;\n  int tonum(){return (x<<7)+(y<<1)+f;}\n};\n\nNode tonode(int num){\n  return Node(num>>7,num>>1&63,num&1);\n};\n\nint hoge[2][9][2] = {{{1,2},{1,1},{1,0},{1,-1},{1,-2},{2,1},{2,0},{2,-1},{3,0}},\n\t\t     {{-1,2},{-1,1},{-1,0},{-1,-1},{-1,-2},{-2,1},{-2,0},{-2,-1},{-3,0}}};\n\nint w,h;\nint map[100][100];\nint d[100000];\nbool visit[100000];\n\nvoid dijkstra(Node from) {\n  int m = from.tonum();\n  priority_queue<P,vector<P>,greater<P> > que;\n  fill(d,d+100000,INF); fill(visit,visit+100000,false);\n  d[m] = 0;\n  que.push(P(0,m));\n  while(!que.empty()) {\n    P p = que.top(); que.pop();\n    int cand = p.second;\n    if (visit[cand])\n      continue;\n    visit[cand] = true;\n    \n    for (int i=0; i<9; i++) {\n      Node n = tonode(cand);\n      int dx = hoge[n.f][i][0], dy = hoge[n.f][i][1];\n      int x = n.x+dx, y= n.y+dy, f = (n.f+1)&1;\n      if (x >= 0 && x < w && y >= 0 && y < h && map[x][y] != INF) {\n\tint next = Node(x,y,f).tonum();\n\tif (d[next] > d[cand] + map[x][y]) {\n\t  d[next] = d[cand] + map[x][y];\n\t  que.push(P(d[next],next));\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  while(scanf(\"%d %d\",&w,&h),w) {\n    vector<Node> start,goal;\n\n    for (int y=0; y<h; y++) {\n      for (int x=0; x<w; x++) {\n\tchar c;\n\twhile(isspace(c=getchar())) ;\n\tswitch (c) {\n\tcase 'X':\n\t  map[x][y]=INF;\n\t  break;\n\tcase 'S':\n\t  map[x][y] = 0;\n\t  start.push_back(Node(x,y,0));\n\t  start.push_back(Node(x,y,1));\n\t  break;\n\tcase 'T':\n\t  map[x][y] = 0;\n\t  goal.push_back(Node(x,y,0));\n\t  goal.push_back(Node(x,y,1));\n\t  break;\n\tdefault:\n\t  assert('0' < c && c <= '9');\n\t  map[x][y] = c-'0';\n\t}\n      }\n    }\n\n    int ans = INF;\n    for (int s=0; s<start.size(); s++){\n      dijkstra(start[s]);\n      for (int g=0; g<goal.size(); g++) {\n\tans = min(ans,d[goal[g].tonum()]);\n      }\n    }\n  \n    printf (\"%d\\n\",(ans==INF)?-1:ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1150: Cliff Climbing\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\ntypedef struct { int r, c, t, lr; } Q;\nQ q[20005]; int top, end;\nchar map[62][32]; int h, w;\nint mk[62][32][2];\nint mv[2][9][2] = {\n\t{{-2, 1},{-1, 2},{-1, 1},{0, 3},{0, 2},{0, 1},{1, 2},{1, 1},{2, 1}},\n\t{{-2,-1},{-1,-2},{-1,-1},{0,-3},{0,-2},{0,-1},{1,-2},{1,-1},{2,-1}} };\n\nint main()\n{\n\tint i, r, c, r2, c2, t, t2, lr, ans;\n\tchar s[10];\n\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tmemset(mk, -1, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%s\", s), map[r][c] = *s;\n\t\tfor (ans = -1, top = end = 0, r = h-1, c = 0; c < w; c++) if (map[r][c] == 'S') {\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 0, mk[r][c][0] = 0;\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 1; mk[r][c][1] = 0;\n\t\t}\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, lr = !(q[top++].lr);\n\t\t\tif (map[r][c] == 'T') { if (ans < 0 || t < ans) ans = t; continue; }\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tr2 = r + mv[lr][i][0], c2 = c + mv[lr][i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'X') continue;\n\t\t\t\tif (mk[r2][c2][lr] >= 0 && t >= mk[r2][c2][lr]) continue;\n\t\t\t\tmk[r2][c2][lr] = t;\n\t\t\t\tt2 = t; if (isdigit(map[r2][c2])) t2 += map[r2][c2] - '0';\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t2, q[end++].lr = lr;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1150: Cliff Climbing\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\ntypedef struct { int r, c, t, lr; } Q;\nQ q[50005]; int top, end;\nchar map[62][32]; int h, w;\nint mk[62][32][2];\nint mv[2][9][2] = {\n\t{{-2, 1},{-1, 2},{-1, 1},{0, 3},{0, 2},{0, 1},{1, 2},{1, 1},{2, 1}},\n\t{{-2,-1},{-1,-2},{-1,-1},{0,-3},{0,-2},{0,-1},{1,-2},{1,-1},{2,-1}} };\n\nint main()\n{\n\tint i, r, c, r2, c2, t, t2, lr, ans;\n\tchar s[10];\n\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tmemset(mk, -1, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%s\", s), map[r][c] = *s;\n\t\tfor (ans = -1, top = end = 0, r = h-1, c = 0; c < w; c++) if (map[r][c] == 'S') {\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 0, mk[r][c][0] = 0;\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 1; mk[r][c][1] = 0;\n\t\t}\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, lr = !(q[top++].lr);\n\t\t\tif (map[r][c] == 'T') { if (ans < 0 || t < ans) ans = t; continue; }\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tr2 = r + mv[lr][i][0], c2 = c + mv[lr][i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'X') continue;\n\t\t\t\tif (mk[r2][c2][lr] >= 0 && t >= mk[r2][c2][lr]) continue;\n\t\t\t\tmk[r2][c2][lr] = t;\n\t\t\t\tt2 = t; if (isdigit(map[r2][c2])) t2 += map[r2][c2] - '0';\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t2, q[end++].lr = lr;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define NUM_NODE 20000\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PairNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[NUM_NODE];\nPairNumDis heap[NUM_NODE];\nint hsize;\nNode node[NUM_NODE];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\nvoid decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PairNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PairNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair = delete();\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromPair.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l, m;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t// ????¶???????????????????????¶?????????°?????????\n\t\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\t\tfor (m = j + 1; m <= j + 3; m++)\n\t\t\t\t\t\t\t\t\tif (m < w)\n\t\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ????¶???????????????????????¶?????????°?????????\n\t\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\t\tfor (m = j - 3; m <= j - 1; m++)\n\t\t\t\t\t\t\t\t\tif (m >= 0)\n\t\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S') {\n\t\t\t\t// ????¶?????????????\n\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i);\n\t\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\t\tif (field[0][j] == 'T') {\n\t\t\t\t\t\tmin = min(min, node[j].d);\n\t\t\t\t\t\tmin = min(min, node[j + h * w].d);\n\t\t\t\t\t}\n\t\t\t\t// ????¶?????????????\n\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + h * w);\n\t\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\t\tif (field[0][j] == 'T') {\n\t\t\t\t\t\tmin = min(min, node[j].d);\n\t\t\t\t\t\tmin = min(min, node[j + h * w].d);\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PairNumDis;\n\nVecEdge adj[3600];\nPairNumDis heap[32400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nvoid insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PairNumDis){num, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair;\n\n\t\tfromPair = delete();\n\t\tif (fromPair.d > d[fromPair.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromPair.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l, m;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\tfor (m = (k ? j - 3 : j + 1); m <= (k ? j - 1: j + 3); m++)\n\t\t\t\t\t\t\t\tif (m >= 0 &&  m < w)\n\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[k]);\n\t\t\t\t\t\t\tmin = min(min, d[k + h * w]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[32400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = 0; l < 9; l++) {\n\t\t\t\t\t\tconst int ni = i + di[k][l], nj = j + dj[k][l];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w && field[ni][nj] != 'X')\n\t\t\t\t\t\t\tadd(i * w + j + k * h * w, ni * w + nj + (k ^ 1) * h * w, field[ni][nj] <= '9' ? field[ni][nj] - '0' : 0);\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[k]);\n\t\t\t\t\t\t\tmin = min(min, d[k + h * w]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[32400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = 0; l < 9; l++) {\n\t\t\t\t\t\tconst int ni = i + di[k][l], nj = j + dj[k][l];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w && field[ni][nj] != 'X')\n\t\t\t\t\t\t\tadd(i * w + j + k * h * w, ni * w + nj + (k ^ 1) * h * w, field[ni][nj] <= '9' ? field[ni][nj] - '0' : 0);\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[k]);\n\t\t\t\t\t\t\tmin = min(min, d[k + h * w]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define NUM_NODE 20000\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PairNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[NUM_NODE];\nPairNumDis heap[NUM_NODE];\nint hsize;\nNode node[NUM_NODE];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\nvoid decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PairNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PairNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair = delete();\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromPair.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l, m;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\tfor (m = (k ? j - 3 : j + 1); m <= (k ? j - 1: j + 3); m++)\n\t\t\t\t\t\t\t\tif (m >= 0 &&  m < w)\n\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, node[k].d);\n\t\t\t\t\t\t\tmin = min(min, node[k + h * w].d);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define NUM_NODE 20000\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PairNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[NUM_NODE];\nPairNumDis heap[NUM_NODE];\nint hsize;\nNode node[NUM_NODE];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\nvoid decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PairNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PairNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair = delete();\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromPair.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l, m;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t// テ・ツキツヲティツカツウテ」ツ?古」ツ?、テ」ツ??」ツ?ヲテ」ツつ凝ッツシツ暗・ツ渉ウティツカツウテ」ツ?古、ツシツクテ」ツ?ーテ」ツ?崚」ツつ凝ッツシツ?\n\t\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\t\tfor (m = j + 1; m <= j + 3; m++)\n\t\t\t\t\t\t\t\t\tif (m < w)\n\t\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// テ・ツ渉ウティツカツウテ」ツ?古」ツ?、テ」ツ??」ツ?ヲテ」ツつ凝ッツシツ暗・ツキツヲティツカツウテ」ツ?古、ツシツクテ」ツ?ーテ」ツ?崚」ツつ凝ッツシツ?\n\t\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\t\tfor (m = j - 3; m <= j - 1; m++)\n\t\t\t\t\t\t\t\t\tif (m >= 0)\n\t\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S') {\n\t\t\t\t// テ・ツキツヲティツカツウテ」ツつケテ」ツつソテ」ツδシテ」ツδ?\n\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i);\n\t\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\t\tif (field[0][j] == 'T') {\n\t\t\t\t\t\tmin = min(min, node[j].d);\n\t\t\t\t\t\tmin = min(min, node[j + h * w].d);\n\t\t\t\t\t}\n\t\t\t\t// テ・ツ渉ウティツカツウテ」ツつケテ」ツつソテ」ツδシテ」ツδ?\n\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + h * w);\n\t\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\t\tif (field[0][j] == 'T') {\n\t\t\t\t\t\tmin = min(min, node[j].d);\n\t\t\t\t\t\tmin = min(min, node[j + h * w].d);\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_NODES 2000\n#define INF 1010001000\n#define min(a, b) a<b?a:b\n\ntypedef struct edge {\n    int tx, ty, lr, cost;\n    struct edge *next;\n}edge;\n\ntypedef struct vertex {\n    int edges;\n    int cost;\n    char value;\n    struct edge *head;\n}vertex;\n\ntypedef struct pair {\n    int f, x, y, lr;\n}pair;\n\nvertex graph[60][30][3]; //h, w, lr\nvertex clear;\npair queue[MAX_NODES];\nint sz, V, E, start;\nint w, h;\nint dx[9] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\nint dy[9] = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\npair pop(void);\nvoid push(pair x);\nvoid init(void);\nvoid make(int w, int h);\nvoid add_edge(int fx, int fy, int lr, int tx, int ty, char cost);\nvoid dijkstra(int stx, int sty, int stlr);\n\nint main(void)\n{\n    int i, j, k, ans;\n    scanf(\"%d %d\", &w, &h);\n    while(w) {\n        ans = INF;\n        init();\n        for (i = 0; i < h; i++) {\n            for (j = 0; j < w; j++) {\n                scanf(\" %c\", &graph[i][j][0].value);\n                graph[i][j][2] = graph[i][j][0];\n            }\n        }\n        /*for (i = 0; i < h; i++) {\n            for (j = 0; j < w; j++) {\n                printf(\"%c\", graph[i][j][0].value);\n            }\n            puts(\"\");\n        }*/\n        make(w, h);\n        //puts(\"made\");\n        //printf(\"%d %d\\n\", h, w);\n        for (i = 0; i < w; i++) {\n            //printf(\"%d%c\\n\", i, graph[h-1][i][0].value);\n            if (graph[h-1][i][0].value == 'S') {\n                dijkstra(h-1, i, -1);\n                for (j = 0; j < w; j++) {\n                    if (graph[0][j][0].value == 'T') {\n                        ans = min(ans, graph[0][j][0].cost);\n                        ans = min(ans, graph[0][j][2].cost);\n                    }\n                }\n                //printf(\"%d\\n\", ans);\n                dijkstra(h-1, i, 1);\n                for (j = 0; j < w; j++) {\n                    if (graph[0][j][0].value == 'T') {\n                        ans = min(ans, graph[0][j][0].cost);\n                        ans = min(ans, graph[0][j][2].cost);\n                    }\n                }\n                //printf(\"%d\\n\", ans);\n            }\n        }\n        if (ans == INF) {\n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", ans);\n        }\n        scanf(\"%d %d\", &w, &h);\n    }\n    return 0;\n}\n\nvoid dijkstra(int stx, int sty, int stlr)\n{\n    int i, j, fx, fy, flr;\n    //printf(\"Dijkstra :(%d, %d), %d\\n\", stx, sty, stlr);\n    pair tmp;\n    edge *now;\n    //Queue????????????\n    for (i = 0; i < 2000; i++) {\n        queue[i].f = INF;\n    }\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++ ) {\n            graph[i][j][0].cost = INF;\n            graph[i][j][2].cost = INF;\n        }\n    }\n    graph[stx][sty][stlr+1].cost = 0;\n\n    tmp.f = 0; tmp.x = stx; tmp.y = sty; tmp.lr = stlr;\n    push(tmp);\n\n    while (queue[0].f != INF) {\n        //puts(\"\");\n        if (sz==0) {\n            break;\n        }\n        tmp = pop();\n        //printf(\"poped:%d %d\\n\", tmp.f, tmp.s);\n        fx = tmp.x;      //?????¨??????????????????????????????\n        fy = tmp.y;\n        flr = tmp.lr;\n        //printf(\"pop:(%d, %d), %d\\n\", fx, fy, flr+1);\n        now = graph[fx][fy][flr+1].head;\n        if (graph[fx][fy][flr+1].cost < tmp.f) { \n            continue;\n        }\n        while (now != NULL) {\n            //printf(\"to :(%d, %d), %d\\n\", now->tx, now->ty, now->lr+1);\n            /*printf(\"cmp :(%d, %d)\\n\", \n                    now->cost\n                    , graph[fx][fy][flr+1].cost);*/\n\n            if (graph[now->tx][now->ty][now->lr+1].cost\n                    > graph[fx][fy][flr+1].cost + now->cost) {\n                graph[now->tx][now->ty][now->lr+1].cost \n                    = graph[fx][fy][flr+1].cost + now->cost;\n                tmp.f = graph[now->tx][now->ty][now->lr+1].cost;\n                tmp.x = now->tx;\n                tmp.y = now->ty;\n                tmp.lr = now->lr;\n                push(tmp);\n            }\n            now = now->next;\n        }\n    }\n}\n\nvoid make(int w, int h)\n{\n    int i, j, k;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            for (k = 0; k < 9; k++) {\n                if (0<=j+dx[k] && j+dx[k]<w &&\n                        0<=i+dy[k] && i+dy[k]<h) {\n                    add_edge(i, j, -1, i+dy[k], j+dx[k], \n                            graph[i+dy[k]][j+dx[k]][0].value);\n                }\n                if (0<=j-dx[k] && j-dx[k]<w &&\n                        0<=i+dy[k] && i+dy[k]<h) {\n                    add_edge(i, j, 1, i+dy[k], j-dx[k], \n                            graph[i+dy[k]][j-dx[k]][2].value);\n                }\n            }\n        }\n    }\n}\n\nvoid init(void)\n{\n    int i, j;\n    for (i = 0; i < 60; i++) {\n        for (j = 0; j < 30; j++) {\n            graph[i][j][0] = clear;\n            graph[i][j][2] = clear;\n        }\n    }\n    for (i = 0; i < MAX_NODES; i++) {\n        queue[i].f = 0;\n    }\n}\n\nvoid add_edge(int fx, int fy, int lr, int tx, int ty, char cost)\n{\n    //from??????to???????????????\n    edge *new, *now = graph[fx][fy][lr+1].head;\n    new = (edge *)malloc(sizeof(edge));\n    new->tx = tx;\n    new->ty = ty;\n    new->lr = -lr;\n    if (cost == 'X') {\n        return ;\n    } else if (cost == 'S') {\n        new->cost = 0;\n    } else if (cost == 'T') {\n        new->cost = 0;\n    } else {\n        new->cost = cost - '0';\n    }\n    new->next = NULL;\n    if (now == NULL) {\n        graph[fx][fy][lr+1].head = new;\n    } else {\n        while (now->next != NULL) {\n            now = now->next;\n        }\n        now->next = new;\n    }\n    graph[fx][fy][lr+1].edges++;\n}\n\nvoid push(pair x)\n{\n    int i = sz++, p;\n    //queue[sz++] = x;\n    while (i > 0) {\n        p = (i - 1) / 2;\n        if (queue[p].f <= x.f) {\n            break;\n        }\n        queue[i].f = queue[p].f;\n        queue[i].x = queue[p].x;\n        queue[i].y = queue[p].y;\n        queue[i].lr = queue[p].lr;\n        i = p;\n    }\n    queue[i] = x;\n}\n\npair pop(void)\n{\n    int i = 0, a, b;\n    pair ans = queue[0], x = queue[--sz];\n    //printf(\"sz:%d\\n\", sz);\n    while (i * 2 + 1 < sz) {\n        a = i * 2 + 1;\n        b = i * 2 + 2;\n        if (b < sz && queue[b].f < queue[a].f) { \n            a = b;\n        }\n        if (queue[a].f >= x.f) {\n            break;\n        }\n        queue[i] = queue[a];\n        i = a;\n    }\n    queue[i] = x;\n    //queue[sz].f = INF;\n    return ans;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\nconst int cost[] = {['S'] = 0, ['T'] = 0, ['X'] = INF, ['1'] = 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[field[ni][nj]] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[field[ni][nj]];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num, d;\n} PNumDis;\n\nVecEdge adj[3600];\nPNumDis heap[32400];\nint hsize;\nint d[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline void insert(int num, int d) {\n\tint i;\n\tfor (i = hsize++; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1)\n\t\theap[i] = heap[i - 1 >> 1];\n\theap[i] = (PNumDis){num, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\td[i] = INF;\n\n\td[s] = 0;\n\tinsert(s, 0);\n\twhile (hsize > 0) {\n\t\tconst PNumDis fromP = delete();\n\n\t\tif (fromP.d > d[fromP.num])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < adj[fromP.num].size; i++) {\n\t\t\tconst Edge e = adj[fromP.num].elem[i];\n\t\t\tif (fromP.d + e.w < d[e.to]) {\n\t\t\t\td[e.to] = fromP.d + e.w;\n\t\t\t\tinsert(e.to, d[e.to]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = 0; l < 9; l++) {\n\t\t\t\t\t\tconst int ni = i + di[k][l], nj = j + dj[k][l];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w && field[ni][nj] != 'X')\n\t\t\t\t\t\t\tadd(i * w + j + k * h * w, ni * w + nj + (k ^ 1) * h * w, field[ni][nj] <= '9' ? field[ni][nj] - '0' : 0);\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[k]);\n\t\t\t\t\t\t\tmin = min(min, d[k + h * w]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\nconst int cost[] = {['S'] = 0, ['T'] = 0, ['X'] = INF, ['1'] = 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromPair = delete();\n\n\t\tif (fromPair.d > d[fromPair.i][fromPair.j][fromPair.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromPair.i + di[fromPair.f][i], nj = fromPair.j + dj[fromPair.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromPair.d + cost[field[ni][nj]] < d[ni][nj][fromPair.f ^ 1]) {\n\t\t\t\t\td[ni][nj][fromPair.f ^ 1] = fromPair.d + cost[field[ni][nj]];\n\t\t\t\t\tinsert(ni, nj, fromPair.f ^ 1, d[ni][nj][fromPair.f ^ 1]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1150: Cliff Climbing\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\ntypedef struct { int r, c, t, lr; } Q;\nQ q[100005]; int top, end;\nchar map[62][32]; int h, w;\nint mk[62][32][2];\nint mv[2][9][2] = {\n\t{{-2, 1},{-1, 2},{-1, 1},{0, 3},{0, 2},{0, 1},{1, 2},{1, 1},{2, 1}},\n\t{{-2,-1},{-1,-2},{-1,-1},{0,-3},{0,-2},{0,-1},{1,-2},{1,-1},{2,-1}} };\n\nint main()\n{\n\tint i, r, c, r2, c2, t, t2, lr, ans;\n\tchar s[10];\n\tint max = 0;\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tmemset(mk, -1, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%s\", s), map[r][c] = *s;\n\t\tfor (ans = -1, top = end = 0, r = h-1, c = 0; c < w; c++) if (map[r][c] == 'S') {\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 0, mk[r][c][0] = 0;\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 1; mk[r][c][1] = 0;\n\t\t}\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, lr = !(q[top++].lr);\n\t\t\tif (map[r][c] == 'T') { if (ans < 0 || t < ans) ans = t; continue; }\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tr2 = r + mv[lr][i][0], c2 = c + mv[lr][i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'X') continue;\n\t\t\t\tif (mk[r2][c2][lr] >= 0 && t >= mk[r2][c2][lr]) continue;\n\t\t\t\tmk[r2][c2][lr] = t;\n\t\t\t\tt2 = t; if (isdigit(map[r2][c2])) t2 += map[r2][c2] - '0';\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t2, q[end++].lr = lr;\n\t\t\t\tif (end > max) max = end;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n\tprintf(\"max %d\\n\", max);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\ninline void insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\ninline void dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main(void)\n{\n  int w,h;\n  char s[60][30];\n  int i,j,m,n,c;\n  int dp[60][30][2];\n  int tmp1,tmp2,min;\n\n  while(1){\n    scanf(\"%d %d \",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%c \",&s[i][j]);\n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tdp[i][j][0] = -1;\n\tdp[i][j][1] = -1;\n      }\n    }\n\n    for(i=0;i<w;i++){\n      if(s[h-1][i] == 'S'){\n        dp[h-1][i][0] = 0;\n        dp[h-1][i][1] = 0;\n      }\n    }\n\n    \n    while(1){\n      c=0;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){ \n\t  if(dp[i][j][0] >= 0){\n\t    for(m=-2;m<=2;m++){\n\t      for(n=1;n<=3;n++){\n\t\tif(i+m>=0 && i+m<h && j+n<w && fabs(m)+n<=3 && s[i+m][j+n]!='X'){\n\t\t  tmp1 = dp[i+m][j+n][1];\n\t\t  if(s[i+m][j+n] == 'S' || s[i+m][j+n] == 'T'){\n\t\t    tmp2 = dp[i][j][0];\n\t\t  }else{\n\t\t    tmp2 = dp[i][j][0] + s[i+m][j+n] - '0';\n\t\t  }\n\t\t  if(tmp1 < 0 || tmp1 > tmp2){\n\t\t    dp[i+m][j+n][1] = tmp2;\n\t\t    c++;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if(dp[i][j][1] >= 0){\n\t    for(m=-2;m<=2;m++){\n\t      for(n=1;n<=3;n++){\n\t\tif(i+m>=0 && i+m<h && j-n>=0 && fabs(m)+n<=3 && s[i+m][j-n]!='X'){\n\t\t  tmp1 = dp[i+m][j-n][0];\n\t\t  if(s[i+m][j-n] == 'S' || s[i+m][j-n] == 'T'){\n\t\t    tmp2 = dp[i][j][1];\n\t\t  }else{\n\t\t    tmp2 = dp[i][j][1] + (int)(s[i+m][j-n] - '0');\n\t\t  }\n\t\t  if(tmp1 < 0 || tmp1 > tmp2){\n\t\t    dp[i+m][j-n][0] = tmp2;\n\t\t    c++;\n\t          }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(c==0)break;\n    }\n\n    min = -1;\n    for(i=0;i<w;i++){\n      if(s[0][i] == 'T'){\n\t for(j=0;j<2;j++){\n           if(min < 0 || (dp[0][i][j] > 0 && min > dp[0][i][j]))min = dp[0][i][j];\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",min);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,k,x,y,nx,ny,min,m,han,a;\n  char g;\n  int Y[9]={2,1,1,0,0,0,-1,-1,-2};\n  int X[9]={1,1,2,1,2,3,1,2,1};\n  int c[2][62][32],f[2][62][32],d[62][32];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int ans=2100000000;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tc[0][i][j]=c[1][i][j]=200000000;\n\tf[0][i][j]=f[1][i][j]=0;\n\tscanf(\" %c\",&g);\n\tif     (g=='S')d[i][j]=c[0][i][j]=c[1][i][j]=0;\n\telse if(g=='T')d[i][j]=-1;\n\telse if(g=='X')d[i][j]=100000000;\n\telse           d[i][j]=g-'0';\n\tif(g=='X'||g=='T')f[0][i][j]=f[1][i][j]=2;\n      }\n    }\n    while(han=1){\n      min=2100000000;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  for(k=0;k<2;k++){\n\t    if(f[k][i][j])continue;\n\t    han=0;\n\t    if(min>c[k][i][j]){\n\t      y=i;\n\t      x=j;\n\t      m=a=1-k;\n\t      min=c[k][i][j];\n\t    }\n\t  }\n\t}\n      }\n      if(han)break;//printf(\"%d %d\\n\",y,x);\n      if(m==0)m--;\n      for(i=0;i<9;i++){\n\tny=y+Y[i];\n\tnx=x+X[i]*m;\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(d[ny][nx]==-1){//printf(\"d%d %d\\n\",y,x);\n\t  if(ans>c[1-a][y][x])ans=c[1-a][y][x];\n\t  continue;\n\t}\n\tif(c[a][ny][nx]>c[1-a][y][x]+d[ny][nx]){\n\t   c[a][ny][nx]=c[1-a][y][x]+d[ny][nx];\n\t}\n      }\n      f[1-a][y][x]=1;\n    }\n    /*for(k=0;k<2;k++){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)printf(\"%10d\",c[k][i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      }//*/\n    if(ans>100000000)printf(\"-1\\n\");\n    else              printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint BLOCK_S = 10;\nint BLOCK_T = 11;\nint BLOCK_X = 12;\nint BLOCK_NULL = -1;\n\n/* 足の届く範囲 */\nint REACH[2][9][2] = {\n\t{{-1, -2}, {-1, -1}, {-1, 0}, {-1, 1}, {-1, 2}, {-2, -1}, {-2, 0}, {-2, 1}, {-3, 0}},\n\t{{1, -2}, {1, -1}, {1, 0}, {1, 1}, {1, 2}, {2, -1}, {2, 0}, {2, 1}, {3, 0}}\n};\n\nint w, h, s[60][30]; /* 崖のデータ */\n\n/* 指定された座標のブロックを返す */\nint getBlock(int x, int y) {\n\tif (x < 0 || x >= w || y < 0 || y >= h) return BLOCK_NULL;\n\treturn s[y][x];\n}\n\n/* 幅優先探索 */\nint memo[60][30][2]; /* 探索のメモ (ブロックに足が掛かるまでの最短時間) */\nint UNREACHED = INT_MAX;\ntypedef struct { int time; int x; int y; int foot; } Log; /* 探索状態 */\n\n/* FIFOキュー */\ntypedef Log Data;\nData queue[2000]; int queue_size = 2000; int queue_head; int queue_length;\nvoid initqueue() {\n\tqueue_length = 0;\n}\nvoid enqueue(Data d) {\n\tqueue[(queue_head + queue_length) % queue_size] = d;\n\tqueue_length++;\n}\nData dequeue() {\n\tData d = queue[queue_head];\n\tqueue_head = (queue_head + 1) % queue_size;\n\tqueue_length--;\n\treturn d;\n}\n\n/* 幅優先探索をする */\nint search(Log l) {\n\tint i;\n\t/* この試行が現在いるブロックまでの最短経路か確認する */\n\tif (l.time > memo[l.y][l.x][l.foot]) return UNREACHED;\n\n\t/* 次の動作 */\n\tfor (i = 0; i < 9; i++) {\n\t\tint x = l.x + REACH[l.foot][i][0];\n\t\tint y = l.y + REACH[l.foot][i][1];\n\t\tint b = getBlock(x, y);\n\t\tif (b == BLOCK_X || b == BLOCK_NULL || b == BLOCK_S) {\n\t\t\t/* 足を置けないブロック */\n\t\t\tcontinue;\n\t\t} else if (b == BLOCK_T) {\n\t\t\t/* 崖登り完了 */\n\t\t\treturn l.time;\n\t\t} else {\n\t\t\t/* 次のブロック */\n\t\t\tif (l.time + b < memo[y][x][1 - l.foot]) {\n\t\t\t\tmemo[y][x][1 - l.foot] = l.time + b;\n\t\t\t\tLog m = {l.time + b, x, y, 1 - l.foot};\n\t\t\t\tenqueue(m);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn UNREACHED;\n}\n\nint main(void) {\n\tint min, i, j;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%d%d\", &w, &h) == 2 && w >= 2 && w <= 30 && h >= 5 && h <= 60) {\n\t\t/* 崖を表現する行列データを読み込む */\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\"%1s\", &(s[i][j]));\n\t\t\t\t/* int 型の配列に変換する */\n\t\t\t\tif (s[i][j] >= '0' && s[i][j] <= '9') s[i][j] -= '0';\n\t\t\t\telse if (s[i][j] == 'S') s[i][j] = BLOCK_S;\n\t\t\t\telse if (s[i][j] == 'T') s[i][j] = BLOCK_T;\n\t\t\t\telse s[i][j] = BLOCK_X;\n\n\t\t\t\t/* メモを初期化する */\n\t\t\t\tmemo[i][j][0] = UNREACHED;\n\t\t\t\tmemo[i][j][1] = UNREACHED;\n\t\t\t}\n\t\t}\n\n\t\t/* 探索の始点をキューに入れる */\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tif (s[h - 1][i] == BLOCK_S) {\n\t\t\t\tLog l0 = {0, i, h - 1, 0}; /* 右足から */\n\t\t\t\tLog l1 = {0, i, h - 1, 1}; /* 左足から */\n\t\t\t\tenqueue(l0);\n\t\t\t\tenqueue(l1);\n\t\t\t}\n\t\t}\n\t\t/* 幅優先探索する */\n\t\tmin = UNREACHED;\n\t\twhile (queue_length > 0) {\n\t\t\tint t = search(dequeue());\n\t\t\tif (t < min) min = t;\n\t\t}\n\n\t\t/* 結果を出力する */\n\t\tif (min == UNREACHED) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", min);\n\n\t\t/* デバッグ */\n\t\t/*\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tprintf(\"%2d \", s[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (memo[i][j][0] == UNREACHED) printf(\"-1 \");\n\t\t\t\telse printf(\"%2d \", memo[i][j][0]);\n\t\t\t}\n\t\t\tprintf(\" | \");\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (memo[i][j][1] == UNREACHED) printf(\"-1 \");\n\t\t\t\telse printf(\"%2d \", memo[i][j][1]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\\n\");\n\t\t*/\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\ninline void insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,k,x,y,nx,ny,min,m,han,a;\n  char g;\n  int Y[9]={2,1,1,0,0,0,-1,-1,-2};\n  int X[9]={1,1,2,1,2,3,1,2,1};\n  int c[2][62][32],f[2][62][32],d[62][32];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int ans=2100000000;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tc[0][i][j]=c[1][i][j]=200000000;\n\tf[0][i][j]=f[1][i][j]=0;\n\tscanf(\" %c\",&g);\n\tif     (g=='S')d[i][j]=c[0][i][j]=c[1][i][j]=0;\n\telse if(g=='T')d[i][j]=-1;\n\telse if(g=='X')d[i][j]=100000000;\n\telse           d[i][j]=g-'0';\n\tif(g=='X'||g=='T')f[0][i][j]=f[1][i][j]=2;\n      }\n    }\n    while(han=1){\n      min=2100000000;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  for(k=0;k<2;k++){\n\t    if(f[k][i][j])continue;\n\t    han=0;\n\t    if(min>c[k][i][j]){\n\t      y=i;\n\t      x=j;\n\t      m=a=1-k;\n\t      min=c[k][i][j];\n\t    }\n\t  }\n\t}\n      }\n      if(han)break;//printf(\"%d %d\\n\",y,x);\n      if(m==0)m--;\n      for(i=0;i<9;i++){\n\tny=y+Y[i];\n\tnx=x+X[i]*m;\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(d[ny][nx]==-1){//printf(\"d%d %d\\n\",y,x);\n\t  if(ans>c[1-a][y][x])ans=c[1-a][y][x];\n\t  continue;\n\t}\n\tif(c[a][ny][nx]>c[1-a][y][x]+d[ny][nx]){\n\t   c[a][ny][nx]=c[1-a][y][x]+d[ny][nx];\n\t}\n      }\n      f[1-a][y][x]=1;\n    }\n    /*for(k=0;k<2;k++){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)printf(\"%10d\",c[k][i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      }//*/\n    if(ans>100000000)printf(\"-1\\n\");\n    else              printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n \nint main(void)\n{\n  int w,h;\n  char s[60][30];\n  int i,j,m,n,c;\n  int dp[60][30][2];\n  int tmp1,tmp2,min;\n \n  while(1){\n    scanf(\"%d %d \",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n    scanf(\"%c \",&s[i][j]);\n      }\n    }\n \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n    dp[i][j][0] = -1;\n    dp[i][j][1] = -1;\n      }\n    }\n \n    for(i=0;i<w;i++){\n      if(s[h-1][i] == 'S'){\n        dp[h-1][i][0] = 0;\n        dp[h-1][i][1] = 0;\n      }\n    }\n \n     \n    while(1){\n      c=0;\n      for(i=0;i<h;i++){\n    for(j=0;j<w;j++){ \n      if(dp[i][j][0] >= 0){\n        for(m=-2;m<=2;m++){\n          for(n=1;n<=3;n++){\n        if(i+m>=0 && i+m<h && j+n<w && fabs(m)+n<=3 && s[i+m][j+n]!='X'){\n          tmp1 = dp[i+m][j+n][1];\n          if(s[i+m][j+n] == 'S' || s[i+m][j+n] == 'T'){\n            tmp2 = dp[i][j][0];\n          }else{\n            tmp2 = dp[i][j][0] + s[i+m][j+n] - '0';\n          }\n          if(tmp1 < 0 || tmp1 > tmp2){\n            dp[i+m][j+n][1] = tmp2;\n            c++;\n          }\n        }\n          }\n        }\n      }\n      if(dp[i][j][1] >= 0){\n        for(m=-2;m<=2;m++){\n          for(n=1;n<=3;n++){\n        if(i+m>=0 && i+m<h && j-n>=0 && fabs(m)+n<=3 && s[i+m][j-n]!='X'){\n          tmp1 = dp[i+m][j-n][0];\n          if(s[i+m][j-n] == 'S' || s[i+m][j-n] == 'T'){\n            tmp2 = dp[i][j][1];\n          }else{\n            tmp2 = dp[i][j][1] + (int)(s[i+m][j-n] - '0');\n          }\n          if(tmp1 < 0 || tmp1 > tmp2){\n            dp[i+m][j-n][0] = tmp2;\n            c++;\n              }\n        }\n          }\n        }\n      }\n    }\n      }\n      if(c==0)break;\n    }\n \n    min = -1;\n    for(i=0;i<w;i++){\n      if(s[0][i] == 'T'){\n     for(j=0;j<2;j++){\n           if(min < 0 || (dp[0][i][j] > 0 && min > dp[0][i][j]))min = dp[0][i][j];\n    }\n      }\n    }\n \n    printf(\"%d\\n\",min);\n     \n  }\n  return 0;\n} "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,k,x,y,nx,ny,min,m,han,a;\n  char g;\n  int Y[9]={2,1,1,0,0,0,-1,-1,-2};\n  int X[9]={1,1,2,1,2,3,1,2,1};\n  int c[2][62][32],f[2][62][32],d[62][32];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int ans=2100000000;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tc[0][i][j]=c[1][i][j]=200000000;\n\tf[0][i][j]=f[1][i][j]=0;\n\tscanf(\" %c\",&g);\n\tif     (g=='S')d[i][j]=c[0][i][j]=c[1][i][j]=0;\n\telse if(g=='T')d[i][j]=-1;\n\telse if(g=='X')d[i][j]=100000000;\n\telse           d[i][j]=g-'0';\n\tif(g=='X'||g=='T')f[0][i][j]=f[1][i][j]=2;\n      }\n    }\n    while(han=1){\n      min=2100000000;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  for(k=0;k<2;k++){\n\t    if(f[k][i][j])continue;\n\t    han=0;\n\t    if(min>c[k][i][j]){\n\t      y=i;\n\t      x=j;\n\t      m=a=1-k;\n\t      min=c[k][i][j];\n\t    }\n\t  }\n\t}\n      }\n      if(han)break;//printf(\"%d %d\\n\",y,x);\n      if(m==0)m--;\n      for(i=0;i<9;i++){\n\tny=y+Y[i];\n\tnx=x+X[i]*m;\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(d[ny][nx]==-1){//printf(\"d%d %d\\n\",y,x);\n\t  if(ans>c[1-a][y][x])ans=c[1-a][y][x];\n\t  continue;\n\t}\n\tif(c[a][ny][nx]>c[1-a][y][x]+d[ny][nx]){\n\t   c[a][ny][nx]=c[1-a][y][x]+d[ny][nx];\n\t}\n      }\n      f[1-a][y][x]=1;\n    }\n    /*for(k=0;k<2;k++){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)printf(\"%10d\",c[k][i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      }//*/\n    if(ans==2100000000)printf(\"-1\\n\");\n    else              printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,k,x,y,nx,ny,min,m,han,a;\n  char g;\n  int Y[9]={2,1,1,0,0,0,-1,-1,-2};\n  int X[9]={1,1,2,1,2,3,1,2,1};\n  int c[2][62][32],f[2][62][32],d[62][32];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int ans=2100000000;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tc[0][i][j]=c[1][i][j]=200000000;\n\tf[0][i][j]=f[1][i][j]=0;\n\tscanf(\" %c\",&g);\n\tif     (g=='S')d[i][j]=c[0][i][j]=c[1][i][j]=0;\n\telse if(g=='T')d[i][j]=-1;\n\telse if(g=='X')d[i][j]=100000000;\n\telse           d[i][j]=g-'0';\n\tif(g=='X'||g=='T')f[0][i][j]=f[1][i][j]=2;\n      }\n    }\n    while(han=1){\n      min=2100000000;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  for(k=0;k<2;k++){\n\t    if(f[k][i][j])continue;\n\t    han=0;\n\t    if(min>c[k][i][j]){\n\t      y=i;\n\t      x=j;\n\t      m=a=1-k;\n\t      min=c[k][i][j];\n\t    }\n\t  }\n\t}\n      }\n      if(han)break;//printf(\"%d %d\\n\",y,x);\n      if(m==0)m--;\n      for(i=0;i<9;i++){\n\tny=y+Y[i];\n\tnx=x+X[i]*m;\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(d[ny][nx]==-1){//printf(\"d%d %d\\n\",y,x);\n\t  if(ans>c[1-a][y][x])ans=c[1-a][y][x];\n\t  continue;\n\t}\n\tif(c[a][ny][nx]>c[1-a][y][x]+d[ny][nx]){\n\t   c[a][ny][nx]=c[1-a][y][x]+d[ny][nx];\n\t}\n      }\n      f[1-a][y][x]=1;\n    }\n    /*for(k=0;k<2;k++){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)printf(\"%10d\",c[k][i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      }//*/\n    if(ans>100000000)printf(\"-1\\n\");\n    else              printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1150: Cliff Climbing\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\ntypedef struct { int r, c, t, lr; } Q;\nQ q[100005]; int top, end;\nchar map[62][32]; int h, w;\nint mk[62][32][2];\nint mv[2][9][2] = {\n\t{{-2, 1},{-1, 2},{-1, 1},{0, 3},{0, 2},{0, 1},{1, 2},{1, 1},{2, 1}},\n\t{{-2,-1},{-1,-2},{-1,-1},{0,-3},{0,-2},{0,-1},{1,-2},{1,-1},{2,-1}} };\n\nint main()\n{\n\tint i, r, c, r2, c2, t, t2, lr, ans;\n\tchar s[10];\n\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tmemset(mk, -1, sizeof(mk));\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%s\", s), map[r][c] = *s;\n\t\tfor (ans = -1, top = end = 0, r = h-1, c = 0; c < w; c++) if (map[r][c] == 'S') {\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 0, mk[r][c][0] = 0;\n\t\t\tq[end].r = r, q[end].c = c, q[end].t = 0, q[end++].lr = 1; mk[r][c][1] = 0;\n\t\t}\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top].t, lr = !(q[top++].lr);\n\t\t\tif (map[r][c] == 'T') { if (ans < 0 || t < ans) ans = t; continue; }\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tr2 = r + mv[lr][i][0], c2 = c + mv[lr][i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'X') continue;\n\t\t\t\tif (mk[r2][c2][lr] >= 0 && t >= mk[r2][c2][lr]) continue;\n\t\t\t\tmk[r2][c2][lr] = t;\n\t\t\t\tt2 = t; if (isdigit(map[r2][c2])) t2 += map[r2][c2] - '0';\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end].t = t2, q[end++].lr = lr;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PairNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[3600];\nPairNumDis heap[3600];\nint hsize;\nNode node[3600];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\ninline void add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\ninline PairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\ninline void decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PairNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PairNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair = delete();\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromPair.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = 0; l < 9; l++) {\n\t\t\t\t\t\tconst int ni = i + di[k][l], nj = j + dj[k][l];\n\t\t\t\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w && field[ni][nj] != 'X')\n\t\t\t\t\t\t\tadd(i * w + j + k * h * w, ni * w + nj + (k ^ 1) * h * w, field[ni][nj] <= '9' ? field[ni][nj] - '0' : 0);\n\t\t\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, node[k].d);\n\t\t\t\t\t\t\tmin = min(min, node[k + h * w].d);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define min(x,y) (x)<(y)?x:y;\n#define N 100000000\ntypedef struct{\n    int w;\n    int h;\n    int leg;\n}Data;\nData queue[N];\nint num,head;\nvoid enqueue(int leg,int h,int w){\n    if(num<N){\n        queue[(head+num)%N].w=w;\n        queue[(head+num)%N].h=h;\n        queue[(head+num)%N].leg=leg;\n        num++;\n    }else{\n        printf(\"エラー\\n\");\n        exit(1);\n    }\n}\nData dequeue(const int cost[2][62][32]){\n    int index=head; Data x=queue[head];\n    int min=cost[x.leg][x.h][x.w];\n    for(int i=head+1;i<head+num;i++){\n        if(min>cost[queue[i%N].leg][queue[i%N].h][queue[i%N].w]){\n            min=cost[queue[i%N].leg][queue[i%N].h][queue[i%N].w];\n            index=i%N;\n        }\n    }\n    Data tmp=queue[head]; queue[head]=queue[index]; queue[index]=tmp;\n    Data d={-1,-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nchar map[62][32];\nint mv[2][9][2]={{{1,2},{1,1},{1,0},{1,-1},{1,-2},{2,1},{2,0},{2,-1},{3,0}},\n    {{-3,0},{-2,1},{-2,0},{-2,-1},{-1,2},{-1,1},{-1,0},{-1,-1},{-1,-2}}};\nint main(void){\n    while(1){\n        int w,h;\n        char s[10];\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        getchar();\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                scanf(\"%s\",s);\n                map[i][j]=s[0];\n            }\n        }\n        /*for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                printf(\"%c \",map[i][j]);\n            }puts(\"\");\n        }*/\n        int ans=100000000;\n        int cost[2][62][32]={0};\n        for(int j=0;j<w;j++)\n            if(map[h-1][j]=='S') enqueue(0,h-1,j),enqueue(1,h-1,j);\n        while(1){\n            int nh,nw;\n            Data tmp=dequeue(cost);\n            if(tmp.leg==-1) break;\n            for(int i=0;i<9;i++){\n                int leg=tmp.leg;\n                nh=tmp.h+mv[leg][i][1];\n                nw=tmp.w+mv[leg][i][0];\n                if(nh<0||nh>=h||nw<0||nw>=w) continue;\n                if(map[nh][nw]=='S'||map[nh][nw]=='X') continue;\n                if(map[nh][nw]=='T'){\n                    if(cost[!leg][nh][nw]==0||\n                       cost[!leg][nh][nw]>cost[leg][tmp.h][tmp.w]){\n                        cost[!leg][nh][nw]=cost[leg][tmp.h][tmp.w];\n                    }\n                }\n                else if(cost[!leg][nh][nw]==0||\n                   cost[!leg][nh][nw]>\n                   cost[leg][tmp.h][tmp.w]+(map[nh][nw]-'0')){\n                    cost[!leg][nh][nw]=cost[leg][tmp.h][tmp.w]+(map[nh][nw]-'0');\n                    enqueue(!leg,nh,nw);\n                }\n            }\n        }\n        int min=10000000;\n        for(int j=0;j<w;j++){\n            if(map[0][j]=='T'){\n                if(cost[0][0][j]!=0&&min>cost[0][0][j])\n                    min=cost[0][0][j];\n                if(cost[1][0][j]!=0&&min>cost[1][0][j])\n                    min=cost[1][0][j];\n            }\n        }\n        if(min==10000000) printf(\"-1\\n\");\n        else printf(\"%d\\n\",min);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INIT_CAP 10\n#define NUM_NODE 20000\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\ntypedef struct {\n\tint to, w;\n} Edge;\n\ntypedef struct {\n\tEdge *elem;\n\tint cap, size;\n} VecEdge;\n\ntypedef struct {\n\tint num;\n\tint d;\n} PairNumDis;\n\ntypedef struct {\n\tint d;\n\tint idx;\n} Node;\n\nVecEdge adj[NUM_NODE];\nPairNumDis heap[NUM_NODE];\nint hsize;\nNode node[NUM_NODE];\n\nvoid init(int n) {\n\twhile (n--)\n\t\tadj[n] = (VecEdge){malloc(sizeof(Edge) * INIT_CAP), INIT_CAP, 0};\n}\n\nvoid add(int from, int to, int w) {\n\tif (adj[from].size == adj[from].cap) {\n\t\tadj[from].cap <<= 1;\n\t\tadj[from].elem = realloc(adj[from].elem, sizeof(Edge) * adj[from].cap);\n\t}\n\tadj[from].elem[adj[from].size++] = (Edge){to, w};\n}\n\nvoid freeAll(int n) {\n\twhile (n--)\n\t\tfree(adj[n].elem);\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairNumDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairNumDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx) {\n\t\theap[i] = heap[nextIdx];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = last;\n\tnode[last.num].idx = i;\n\n\treturn root;\n}\n\nvoid decreaseKey(int num, int d) {\n\tint i;\n\n\tfor (i = node[num].idx; i > 0 && d < heap[i - 1 >> 1].d; i = i - 1 >> 1) {\n\t\theap[i] = heap[i - 1 >> 1];\n\t\tnode[heap[i].num].idx = i;\n\t}\n\theap[i] = (PairNumDis){num, d};\n\tnode[num].idx = i;\n}\n\nvoid dijkstra(int n, int s) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\theap[i] = (PairNumDis){i, INF};\n\t\tnode[i] = (Node){INF, i};\n\t}\n\thsize = n;\n\n\tnode[s].d = 0;\n\tdecreaseKey(s, 0);\n\twhile (hsize > 0) {\n\t\tPairNumDis fromPair = delete();\n\t\tfor (i = 0; i < adj[fromPair.num].size; i++) {\n\t\t\tEdge e = adj[fromPair.num].elem[i];\n\t\t\tif (fromPair.d + e.w < node[e.to].d) {\n\t\t\t\tnode[e.to].d = fromPair.d + e.w;\n\t\t\t\tdecreaseKey(e.to, node[e.to].d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar field[60][30];\n\nint main(void) {\n\tint i, j, k, l, m;\n\tint w, h;\n\tint min;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\n\t\tinit(h * w * 2);\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\tfor (l = i - 2; l <= i + 2; l++)\n\t\t\t\t\t\tif (l >= 0 && l < h)\n\t\t\t\t\t\t\tfor (m = (k ? j - 3 : j + 1); m <= (k ? j - 1: j + 3); m++)\n\t\t\t\t\t\t\t\tif (m >= 0 &&  m < w)\n\t\t\t\t\t\t\t\t\tif (abs(i - l) + abs(j - m) <= 3)\n\t\t\t\t\t\t\t\t\t\tif (field[l][m] == 'S' || field[l][m] == 'T')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, 0);\n\t\t\t\t\t\t\t\t\t\telse if (field[l][m] != 'X')\n\t\t\t\t\t\t\t\t\t\t\tadd(i * w + j + k * h * w, l * w + m + (k ^ 1) * h * w, field[l][m] - '0');\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h * w * 2, (h - 1) * w + i + j * h * w);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, node[k].d);\n\t\t\t\t\t\t\tmin = min(min, node[k + h * w].d);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\n\t\tfreeAll(h * w * 2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\ninline int calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000000\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n\nconst int di[2][9] = {{-2, -1, -1, 0, 0, 0, 1, 1, 2}, {-2, -1, -1, 0, 0, 0, 1, 1, 2}};\nconst int dj[2][9] = {{1, 1, 2, 1, 2, 3, 1, 2, 1}, {-1, -2, -1, -3, -2, -1, -2, -1, -1}};\n\ntypedef struct {\n\tint i, j, f, d;\n} PairCoordDis;\n\nPairCoordDis heap[32400];\nint hsize;\n\nvoid insert(int i, int j, int f, int d) {\n\tint ii;\n\tfor (ii = hsize++; ii > 0 && d < heap[ii - 1 >> 1].d; ii = ii - 1 >> 1)\n\t\theap[ii] = heap[ii - 1 >> 1];\n\theap[ii] = (PairCoordDis){i, j, f, d};\n}\n\nint calcNextIdx(int i) {\n\treturn i * 2 + 1 + (i * 2 + 2 < hsize && heap[i * 2 + 1].d > heap[i * 2 + 2].d);\n}\n\nPairCoordDis delete(void) {\n\tint i;\n\tint nextIdx;\n\tconst PairCoordDis root = heap[0], last = heap[--hsize];\n\n\tfor (i = 0; i * 2 + 1 < hsize && last.d > heap[nextIdx = calcNextIdx(i)].d; i = nextIdx)\n\t\theap[i] = heap[nextIdx];\n\theap[i] = last;\n\n\treturn root;\n}\n\nchar field[60][30];\nint cost[60][30];\nint d[60][30][2];\n\nvoid dijkstra(int h, int w, int si, int sj, int sf) {\n\tint i, j;\n\n\tfor (i = 0; i < h; i++)\n\t\tfor (j = 0; j < w; j++)\n\t\t\td[i][j][0] = d[i][j][1] = INF;\n\n\td[si][sj][sf] = 0;\n\tinsert(si, sj, sf, 0);\n\twhile (hsize > 0) {\n\t\tconst PairCoordDis fromP = delete();\n\t\tconst int nf = fromP.f ^ 1;\n\n\t\tif (fromP.d > d[fromP.i][fromP.j][fromP.f])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tconst int ni = fromP.i + di[fromP.f][i], nj = fromP.j + dj[fromP.f][i];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w)\n\t\t\t\tif (fromP.d + cost[ni][nj] < d[ni][nj][nf]) {\n\t\t\t\t\td[ni][nj][nf] = fromP.d + cost[ni][nj];\n\t\t\t\t\tinsert(ni, nj, nf, d[ni][nj][nf]);\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h), w) {\n\t\tint min;\n\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", field[i] + j);\n\t\t\t\tcost[i][j] = field[i][j] == 'X' ? INF : field[i][j] <= '9' ? field[i][j] - '0' : 0;\n\t\t\t}\n\n\t\tmin = INF;\n\t\tfor (i = 0; i < w; i++)\n\t\t\tif (field[h - 1][i] == 'S')\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tdijkstra(h, w, h - 1, i, j);\n\t\t\t\t\tfor (k = 0; k < w; k++)\n\t\t\t\t\t\tif (field[0][k] == 'T') {\n\t\t\t\t\t\t\tmin = min(min, d[0][k][0]);\n\t\t\t\t\t\t\tmin = min(min, d[0][k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", min == INF ? -1 : min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tboolean[][][] ft = new boolean[2][5][7];\n\n\tclass State implements Comparable<State> {\n\t\tint i;\n\t\tint j;\n\t\tint foot;\n\t\tint cost;\n\n\t\tState(int i, int j, int foot, int cost) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.foot = foot;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\n\tclass ij {\n\t\tint i;\n\t\tint j;\n\n\t\tij(int i, int j) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\treturn ((ij) obj).i == i && ((ij) obj).j == j;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tft[0][0][4] = true;\n\t\tft[0][1][4] = true;\n\t\tft[0][1][5] = true;\n\t\tft[0][2][4] = true;\n\t\tft[0][2][5] = true;\n\t\tft[0][2][6] = true;\n\t\tft[0][3][4] = true;\n\t\tft[0][3][5] = true;\n\t\tft[0][4][4] = true;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tft[1][i][j] = ft[0][i][6 - j];\n\t\t\t}\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[h + 4][w + 6];\n\n\t\t\tint[][][] cost = new int[h + 4][w + 6][2];\n\t\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\t\tfor (int j = 0; j < cost[i].length; j++) {\n\t\t\t\t\tcost[i][j][0] = Integer.MAX_VALUE >> 2;\n\t\t\t\t\tcost[i][j][1] = Integer.MAX_VALUE >> 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<ij> goal = new LinkedList<ij>();\n\t\t\tPriorityQueue<State> Q = new PriorityQueue<State>();\n\t\t\tfor (int i = 2; i < h + 2; i++) {\n\t\t\t\tfor (int j = 3; j < w + 3; j++) {\n\t\t\t\t\tif (sc.hasNextInt()) {\n\t\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString a = sc.next();\n\t\t\t\t\t\tif (a.equals(\"S\")) {\n\t\t\t\t\t\t\tmap[i][j] = -2;\n\t\t\t\t\t\t\tQ.add(new State(i, j, 0, 0));\n\t\t\t\t\t\t\tQ.add(new State(i, j, 1, 0));\n\t\t\t\t\t\t\tcost[i][j][0] = 0;\n\t\t\t\t\t\t\tcost[i][j][1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a.equals(\"T\")) {\n\t\t\t\t\t\t\tmap[i][j] = -3;\n\t\t\t\t\t\t\tgoal.add(new ij(i, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = -1;\n\t\t\tfor (; !Q.isEmpty();) {\n\t\t\t\tState s = Q.poll();\n\n\t\t\t\tif (goal.contains(new ij(s.i, s.j))) {\n\t\t\t\t\tif (ans == -1 ||ans > s.cost) {\n\t\t\t\t\t\tans = s.cost;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (s.cost < cost[s.i][s.j][s.foot]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\t\t\tif (ft[s.foot ^ 1][i][j]) {\n\t\t\t\t\t\t\tint mvalue = map[s.i + i - 2][s.j + j - 3];\n\t\t\t\t\t\t\tif (mvalue == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mvalue < 0) {\n\t\t\t\t\t\t\t\tmvalue = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cost[s.i + i - 2][s.j + j - 3][1 - s.foot] > s.cost\n\t\t\t\t\t\t\t\t\t+ mvalue) {\n\t\t\t\t\t\t\t\tcost[s.i + i - 2][s.j + j - 3][1 - s.foot] = s.cost\n\t\t\t\t\t\t\t\t\t\t+ mvalue;\n\t\t\t\t\t\t\t\tQ.add(new State(s.i + i - 2, s.j + j - 3,\n\t\t\t\t\t\t\t\t\t\t1 - s.foot, cost[s.i + i - 2][s.j + j\n\t\t\t\t\t\t\t\t\t\t\t\t- 3][1 - s.foot]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ2\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ1150();\n\t}\n\t\n\tint[] rx={1,1,2,1,2,3,1,2,1}, fy={-2,-1,-1,0,0,0,1,1,2};\n\tint[] lx={-1,-1,-2,-1,-2,-3,-1,-2,-1};\n\tvoid AOJ1150(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][][] close=new int[W][H][2];\n\t\t\tPriorityQueue<C1150> open=new PriorityQueue<C1150>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tchar temp=sc.next().charAt(0);\n\t\t\t\t\tc[x][y]=temp;\n\t\t\t\t\tif(temp=='S'){\n\t\t\t\t\t\topen.add(new C1150(x,y,0,0));\n\t\t\t\t\t\tclose[x][y][0]=-1;\n\t\t\t\t\t\topen.add(new C1150(x,y,0,1));\n\t\t\t\t\t\tclose[x][y][1]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\t//int count=0;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\t//debug\n\t\t\t\t//count++;\n\t\t\t\tC1150 now=open.poll();\n\t\t\t\t//out.println(now.x+\" \"+now.y);\n\t\t\t\tint[] fx=(now.f==0? rx: lx);\n\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\tint xx=now.x+fx[i], yy=now.y+fy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='X')\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='T'){\n\t\t\t\t\t\tans=(ans<0? now.c: min(ans,now.c));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c+Character.digit(c[xx][yy],10)>=close[xx][yy][1-now.f] && close[xx][yy][1-now.f]!=0)\tcontinue;\n\t\t\t\t\topen.add(new C1150(xx,yy,now.c+Character.digit(c[xx][yy],10),1-now.f));\n\t\t\t\t\tclose[xx][yy][1-now.f]=now.c+Character.digit(c[xx][yy],10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t//out.println(count+\"times\");\n\t\t}\n\t}\n\tclass C1150 implements Comparable<C1150>{\n\t\tint x,y,c,f;\n\t\tC1150(int x,int y,int c,int f){\n\t\t\tthis.x=x;\tthis.y=y;\tthis.c=c;\tthis.f=f;\n\t\t}\n\t\t@Override public int compareTo(C1150 oth) {\n\t\t\tif(this.c<oth.c)\treturn -1;\n\t\t\tif(this.c>oth.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1149(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt(),w=sc.nextInt(),h=sc.nextInt();\n\t\t\tif((n|w|h)==0)\tbreak;\n\t\t\tArrayList<C1149> c=new ArrayList<C1149>();\n\t\t\tc.add(new C1149(w,h));\n\t\t\twhile(--n>=0){\n\t\t\t\tint p=sc.nextInt()-1,s=sc.nextInt();\n\t\t\t\tC1149 now=c.get(p);\n\t\t\t\ts=s%(now.w+now.h);\n\t\t\t\tint aw=now.w,ah=now.h,bw=now.w,bh=now.h;\n\t\t\t\tif(s<now.w){\n\t\t\t\t\taw=s;\tbw=now.w-s;\n\t\t\t\t}else{\n\t\t\t\t\tah=s-now.w;\tbh=(now.w+now.h)-s;\n\t\t\t\t}\n\t\t\t\t//out.println(\"W\"+now.w+\" H\"+now.h+\" S\"+s+\" AW\"+aw+\" AH\"+ah+\" BW\"+bw+\" BH\"+bh);\n\t\t\t\tC1149 a=new C1149(aw,ah), b=new C1149(bw,bh);\n\t\t\t\tc.remove(p);\n\t\t\t\tif(a.s>b.s){\n\t\t\t\t\tc.add(b);\tc.add(a);\n\t\t\t\t}else{\n\t\t\t\t\tc.add(a);\tc.add(b);\n\t\t\t\t}\n\t\t\t\t//out.println(\"D\"+c);\n\t\t\t}\n\t\t\tCollections.sort(c);\n\t\t\tout.print(c.get(0).s);\n\t\t\tfor(int i=1; i<c.size(); i++)\tout.print(\" \"+c.get(i).s);\n\t\t\tout.println();\n\t\t}\n\t}\n\tclass C1149 implements Comparable<C1149>{\n\t\tint w,h,s;\n\t\tC1149(int w,int h){\n\t\t\tthis.w=w;\tthis.h=h;\tthis.s=w*h;\n\t\t}\n\t\t@Override public String toString(){\n\t\t\treturn \"(\"+w+\",\"+h+\")\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C1149 oth) {\n\t\t\tif(this.s<oth.s)\treturn -1;\n\t\t\tif(this.s>oth.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1148(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\tif((N|M)==0)\tbreak;\n\t\t\tint r=sc.nextInt();\n\t\t\tC1148[] rec=new C1148[r];\n\t\t\tfor(int i=0; i<r; i++)\trec[i]=new C1148(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt()==1);\n\t\t\tint q=sc.nextInt();\n\t\t\twhile(--q>=0){\n\t\t\t\tint ts=sc.nextInt(),te=sc.nextInt(),st=sc.nextInt(),ans=0,temp=0,lastIn=0;\n\t\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\t\tif(rec[i].st==st){\n\t\t\t\t\t\tif(rec[i].in){\t// login\n\t\t\t\t\t\t\tlastIn=(temp==0?rec[i].time:lastIn);\n\t\t\t\t\t\t\ttemp++;\n\t\t\t\t\t\t}else{\t// logout\n\t\t\t\t\t\t\tif(--temp==0){\n\t\t\t\t\t\t\t\tint out=(te<rec[i].time?te:rec[i].time);\n\t\t\t\t\t\t\t\tlastIn=(lastIn<ts?ts:lastIn);\n\t\t\t\t\t\t\t\tans+=max(0,out-lastIn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\tclass C1148{\n\t\tint time,pc,st;\tboolean in;\n\t\tC1148(int time,int pc,int st,boolean in){\n\t\t\tthis.time=time;\tthis.pc=pc;\tthis.st=st;\tthis.in=in;\n\t\t}\n\t}\n\t\n\tvoid AOJ1147(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint[] score=new int[n];\n\t\t\tfor(int i=0; i<n; i++)\tscore[i]=sc.nextInt();\n\t\t\tArrays.sort(score);\n\t\t\tint sum=0;\n\t\t\tfor(int i=1; i<n-1; i++)\tsum+=score[i];\n\t\t\tout.println(sum/(n-2));\n\t\t}\n\t}\n\t\n\t/*\n\t*** Compile Error\n\tvoid AOJ1148(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(), M=sc.nextInt();\n\t\t\tif((N|M)==0)break;\n\t\t\tint r=sc.nextInt();\n\t\t\tArrayList<C1148>[] list=new ArrayList[M];\n\t\t\tfor(int i=0; i<M; i++)\tlist[i]=new ArrayList<C1148>();\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tint time=sc.nextInt(), pc=sc.nextInt(), st=sc.nextInt()-1, k=sc.nextInt();\n\t\t\t\tArrayList<C1148> ar=list[st];\n\t\t\t\tif(k==1){\n\t\t\t\t\tif(ar.size()==0)\tar.add(new C1148(time,1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\t\tC1148 temp=ar.get(j);\n\t\t\t\t\t\t\tif(temp.s<=time && time<=temp.e){\n\t\t\t\t\t\t\t\ttemp.count++;\n\t\t\t\t\t\t\t\tar.set(j, temp);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//out.println(\"R\"+j);\n\t\t\t\t\t\t\t\tar.add(new C1148(time,1));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist[st]=ar;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\tC1148 temp=ar.get(j);\n\t\t\t\t\t\ttemp.count--;\n\t\t\t\t\t\tif(temp.count==0){\n\t\t\t\t\t\t\ttemp.e=time;\n\t\t\t\t\t\t\ttemp.count=-1;\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(temp.count>0){\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//out.println(\"K\"+k+\" \")\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t//for(int i=0; i<M; i++)\tout.println(list[i]);\n\t\t\t\n\t\t\tint Q=sc.nextInt();\n\t\t\tfor(int i=0; i<Q; i++){\n\t\t\t\tint S=sc.nextInt(), E=sc.nextInt(), ST=sc.nextInt()-1;\n\t\t\t\tArrayList<C1148> ar=list[ST];\n\t\t\t\tint ans=0;\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tC1148 temp2=ar.get(j);\n\t\t\t\t\tC1148 temp=new C1148(temp2.s,temp2.e,temp2.count);\n\t\t\t\t\tif(temp.s<=S && S<=temp.e)\ttemp.s=S;\n\t\t\t\t\tif(temp.s<=E && E<=temp.e)\ttemp.e=E;\n\t\t\t\t\tif(S<=temp.s && temp.e<=E)\tans+=temp.e-temp.s;\n\t\t\t\t\t//out.println(\"ANS\"+ans+\"\"+temp.s+\" E\"+temp.e);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\tclass C1148{\n\t\tint s,e,count;\n\t\tC1148(int s,int count){\n\t\t\tthis.s=s;\tthis.e=Integer.MAX_VALUE;\tthis.count=count;\n\t\t}\n\t\tC1148(int s,int e,int count){\n\t\t\tthis.s=s;\tthis.e=e;\tthis.count=count;\n\t\t}\n\t\t@Override public String toString(){\n\t\t\treturn \"S\"+s+\" E\"+e+\" C\"+count;\n\t\t}\n\t}\n\t*/\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int w,h,min;\n\tstatic int[] leftx={-1,-1,-1,-1,-1,-2,-2,-2,-3};\n\tstatic int[] lefty={2,1,0,-1,-2,1,0,-1,0};\n\tstatic Wall[][] wall;\n\tstatic Queue<Integer[]> q = new LinkedList<Integer[]>();\n\tstatic{\n\t\tfor(int j = 0;j<30;j++){\n\t\t\tSystem.out.print(\"T\"+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0;i<58;i++){\n\t\t\tfor(int j = 0;j<30;j++){\n\t\t\t\tSystem.out.print(1+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tfor(int j = 0;j<30;j++){\n\t\t\tSystem.out.print(\"S\"+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin=Integer.MAX_VALUE;\n\t\t\twall=new Wall[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tString s = cin.next();\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tif(s.equals(\"T\")){\n\t\t\t\t\t\ta=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"S\")){\n\t\t\t\t\t\ta=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"X\")){\n\t\t\t\t\t\ta=-3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t\twall[i][j]=new Wall(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t//System.out.print(wall[i][j].cost+\" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(wall[i][j].cost==-1){\n\t\t\t\t\t\tInteger[] a = {i,j,0,0};\n\t\t\t\t\t\tInteger[] b = {i,j,1,0};\n\t\t\t\t\t\twall[i][j].min[0]=wall[i][j].min[1]=0;\n\t\t\t\t\t\tq.add(a);q.add(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tInteger[] a=q.poll();\n\t\t\t\tint cost,y,x,isRight;\n\t\t\t\ty=a[0];x=a[1];isRight=a[2];cost=a[3];\n\t\t\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n\t\t\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(wall[y][x].cost==-2){\n\t\t\t\t\tmin=Math.min(min, cost+2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twall[y][x].min[isRight]=cost;\n\t\t\t\tint right=0;\n\n\t\t\t\tif(isRight==0){\n\t\t\t\t\tright=1;\n\t\t\t\t\tisRight=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright=-1;\n\t\t\t\t\tisRight=0;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\t\t\tint xx=x+leftx[i]*right;\n\t\t\t\t\tint yy=y+lefty[i]*right;\n\t\t\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tInteger[] next={yy,xx,isRight,cost+wall[yy][xx].cost};\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(min==Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t\n\t}\n\t\n\tstatic void climb(int y,int x,int isRight,int cost){\n\t\t//System.out.println(x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\treturn;\n\t\t}\n\t\tif(wall[y][x].cost==-2){\n\t\t\tmin=Math.min(min, cost+2);\n\t\t\treturn;\n\t\t}\n\t\twall[y][x].min[isRight]=cost;\n\t\tint right=0;\n\n\t\tif(isRight==0){\n\t\t\tright=1;\n\t\t\tisRight=1;\n\t\t}\n\t\telse{\n\t\t\tright=-1;\n\t\t\tisRight=0;\n\t\t}\n\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\tint xx=x+leftx[i]*right;\n\t\t\tint yy=y+lefty[i]*right;\n\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclimb(yy,xx,isRight,cost+wall[yy][xx].cost);\n\n\n\t\t}\n\t}\n}\nclass Wall{\n\tint cost;\n\tint[] min;\n\tWall(int a){\n\t\tcost=a;\n\t\tmin=new int[2];\n\t\tmin[0]=min[1]=Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint w, h;\n\tchar[][] c;\n\tint[] rdx = { 1, 1, 1, 1, 1, 2, 2, 2, 3 };\n\tint[] rdy = { 2, 1, 0, -1, -2, 1, 0, -1, 0 };\n\tint[] ldx = { -1, -1, -1, -1, -1, -2, -2, -2, -3 };\n\tint[] ldy = { 2, 1, 0, -1, -2, 1, 0, -1, 0 };\n\n\tclass D implements Comparable<D> {\n\t\tint lx, ly, rx, ry;\n\t\tint min;\n\n\t\tD(int lx, int ly, int rx, int ry, int min) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ry = ry;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.lx != o.lx) {\n\t\t\t\treturn this.lx - o.lx;\n\t\t\t}\n\t\t\tif (this.ly != o.ly) {\n\t\t\t\treturn this.ly - o.ly;\n\t\t\t}\n\t\t\tif (this.rx != o.rx) {\n\t\t\t\treturn this.rx - o.rx;\n\t\t\t}\n\t\t\tif (this.ry != o.ry) {\n\t\t\t\treturn this.ry - o.ry;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\n\t\tList<Point> list = new LinkedList<Point>();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (c[i][j] == 'S') {\n\t\t\t\t\tlist.add(new Point(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//\t\tPoint[] p = list.toArray(new Point[0]);\n\t\t//\t\tfor (int i = 0; i < p.length; i++) {\n\t\t//\t\t\tfor (int j = i + 1; j < p.length; j++) {\n\t\t//\t\t\t\tPoint l = p[i].x < p[j].x ? p[i] : p[j];\n\t\t//\t\t\t\tPoint r = p[i].x < p[j].x ? p[j] : p[i];\n\t\t//\t\t\t\tif (r.x - l.x <= 3) {\n\t\t//\t\t\t\t\tqueue.add(new D(l.x, l.y, r.x, r.y, 0));\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\tfor (Point p : list) {\n\t\t\tqueue.add(new D(p.x, p.y, p.x, p.y, 0));\n\t\t}\n\n\t\tboolean[][][][] vis = new boolean[w][h][w][h];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint lx = d.lx;\n\t\t\tint ly = d.ly;\n\t\t\tint rx = d.rx;\n\t\t\tint ry = d.ry;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[lx][ly][rx][ry]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[lx][ly][rx][ry] = true;\n\n\t\t\tif (c[ly][lx] == 'T' || c[ry][rx] == 'T') {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tint nlx = lx;\n\t\t\t\tint nly = ly;\n\t\t\t\tint nrx = nlx + rdx[i];\n\t\t\t\tint nry = nly + rdy[i];\n\t\t\t\tif (nrx < 0 || w <= nrx || nry < 0 || h <= nry) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c[nry][nrx] == 'X') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint add;\n\t\t\t\tif (c[nry][nrx] == 'T') {\n\t\t\t\t\tadd = 0;\n\t\t\t\t} else {\n\t\t\t\t\tadd = c[nry][nrx] - '0';\n\t\t\t\t}\n\t\t\t\tint nmin = min + add;\n\t\t\t\tqueue.add(new D(nlx, nly, nrx, nry, nmin));\n\t\t\t}\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tint nrx = rx;\n\t\t\t\tint nry = ry;\n\t\t\t\tint nlx = rx + ldx[i];\n\t\t\t\tint nly = ry + ldy[i];\n\t\t\t\tif (nlx < 0 || w <= nlx || nly < 0 || h <= nly) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c[nly][nlx] == 'X') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint add;\n\t\t\t\tif (c[nly][nlx] == 'T') {\n\t\t\t\t\tadd = 0;\n\t\t\t\t} else {\n\t\t\t\t\tadd = c[nly][nlx] - '0';\n\t\t\t\t}\n\t\t\t\tint nmin = min + add;\n\t\t\t\tqueue.add(new D(nlx, nly, nrx, nry, nmin));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tc[i][j] = sc.next().charAt(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic class State implements Comparable<State>{\n\t\tint x, y, cost, foot;\n\t\tState(int foot, int y, int x, int cost){\n\t\t\tthis.foot=foot;\n\t\t\tthis.y=y;\n\t\t\tthis.x=x;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.cost-s.cost;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tif(w+h==0) break;\n\t\t\t\tint INF=100000000;\n\t\t\t\tint[][] board=new int[h+1][w+1];\n\t\t\t\tint[][][] dist=new int[2][h+1][w+1];\n\t\t\t\tfor(int i=1; i<=h; i++) {\n\t\t\t\t\tfor(int j=1; j<=w; j++) {\n\t\t\t\t\t\tString str=sc.next();\n\t\t\t\t\t\tif(str.equals(\"S\")) board[i][j]=-1;\n\t\t\t\t\t\telse if(str.equals(\"T\")) board[i][j]=-2;\n\t\t\t\t\t\telse if(str.equals(\"X\")) board[i][j]=INF;\n\t\t\t\t\t\telse board[i][j]=Integer.parseInt(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPriorityQueue<State> pq=new PriorityQueue<>();\n\t\t\t\tfor(int k=0; k<2; k++) {\n\t\t\t\t\tfor(int i=1; i<=h; i++) {\n\t\t\t\t\t\tfor(int j=1; j<=w; j++) {\n\t\t\t\t\t\t\tdist[k][i][j]=INF;\n\t\t\t\t\t\t\tif(board[i][j]==-1) {\n\t\t\t\t\t\t\t\tpq.add(new State(k, i, j, 0));//あらかじめ左startと右startいれておく\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile(!pq.isEmpty()) {//foot:0左 1右\n\t\t\t\t\tState state=pq.poll();\n\t\t\t\t\tif(dist[state.foot][state.y][state.x]<state.cost) continue;\n\t\t\t\t\tdist[state.foot][state.y][state.x]=state.cost;\n\t\t\t\t\tfor(int j=1; j<=3; j++) {\n\t\t\t\t\t\tfor(int i=-2; i<=2; i++) {\n\t\t\t\t\t\t\tif(j+Math.abs(i)<=3) {\n\t\t\t\t\t\t\t\tint ny=state.y+i;\n\t\t\t\t\t\t\t\tint nx=state.x+(state.foot==0?j:-j);\n\t\t\t\t\t\t\t\tif(0>ny || ny>h || 0>nx | nx>w) continue;\n\t\t\t\t\t\t\t\tif(board[ny][nx]==INF) continue;\n\t\t\t\t\t\t\t\tif(dist[1-state.foot][ny][nx]<INF) continue;\n\t\t\t\t\t\t\t\tpq.add(new State(1-state.foot,ny, nx, state.cost+(board[ny][nx]>0?board[ny][nx]:0)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ret=INF;\n\t\t\t\tfor(int k=0; k<2; k++) {\n\t\t\t\t\tfor(int i=1; i<=h; i++) {\n\t\t\t\t\t\tfor(int j=1; j<=w; j++) {\n\t\t\t\t\t\t\tif(board[i][j]==-2) {\n\t\t\t\t\t\t\t\tret=Math.min(ret, dist[k][i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ret>=INF? -1:ret);\n\t\t\t\t\n\n\n\t\t\t}\n\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int MAX = Integer.MAX_VALUE;\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\tnew Cliff_Climbing().Main();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doIt();\n\t}\n\n\tclass Cliff_Climbing{\n\n\t\tvoid Main() {\n\t\t\twhile(true) {\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tif(w == 0 && h == 0) return;\n\t\t\t\tint dx[] = {1, 1, 1, 1, 1, 2, 2, 2, 3};\n\t\t\t\tint dy[] = {2, 1, 0, -1, -2, 1, 0, -1, 0};\n\t\t\t\tint d[][][] = new int[h][w][2];\n\t\t\t\tint c[][][] = new int[h][w][2];\n\t\t\t\tList<Point> t = new ArrayList<>(); \n\t\t\t\tPriorityQueue<Node> next = new PriorityQueue<>();\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tString s = sc.next();\n\t\t\t\t\t\tif (s.equals(\"X\")) {\n\t\t\t\t\t\t\td[i][j][0] = -1;\n\t\t\t\t\t\t\tc[i][j][0] = -1;\n\t\t\t\t\t\t\td[i][j][1] = -1;\n\t\t\t\t\t\t\tc[i][j][1] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.equals(\"S\")) {\n\t\t\t\t\t\t\td[i][j][0] = 0;\n\t\t\t\t\t\t\tc[i][j][0] = 0;\n\t\t\t\t\t\t\tnext.add(new Node(0, i, j, 0));\n\t\t\t\t\t\t\td[i][j][1] = 0;\n\t\t\t\t\t\t\tc[i][j][1] = 0;\n\t\t\t\t\t\t\tnext.add(new Node(0, i, j, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.equals(\"T\")) {\n\t\t\t\t\t\t\tt.add(new Point(i, j));\n\t\t\t\t\t\t\td[i][j][0] = MAX;\n\t\t\t\t\t\t\tc[i][j][0] = 0;\n\t\t\t\t\t\t\td[i][j][1] = MAX;\n\t\t\t\t\t\t\tc[i][j][1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\td[i][j][0] = MAX;\n\t\t\t\t\t\t\tc[i][j][0] = Integer.parseInt(s);\n\t\t\t\t\t\t\td[i][j][1] = MAX;\n\t\t\t\t\t\t\tc[i][j][1] = Integer.parseInt(s);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!next.isEmpty()) {\n\t\t\t\t\tNode v = next.poll();\n\t\t\t\t\tif(d[v.y][v.x][v.z] < v.d)continue;\n\t\t\t\t\tfor(int i = 0; i < 9; i++) {\n\t\t\t\t\t\tint mx = 1;\n\t\t\t\t\t\tif(v.z == 1) mx = -1;\n\t\t\t\t\t\tint x = v.x + dx[i] * mx; \n\t\t\t\t\t\tint y = v.y + dy[i];\n\t\t\t\t\t\tint z = v.z ^ 1;\n\t\t\t\t\t\tif(x >= 0 && x < w \n\t\t\t\t\t\t\t\t&& y >= 0 && y < h) {\n\t\t\t\t\t\t\tif(c[y][x][z] < 0)continue;\n\t\t\t\t\t\t\t//System.out.println(d[y][x][z] + \" \"  +(c[y][x][z] + v.d));\n\t\t\t\t\t\t\tif(d[y][x][z] > c[y][x][z] + v.d) {\n\t\t\t\t\t\t\t\td[y][x][z] = c[y][x][z] + v.d;\n\t\t\t\t\t\t\t\tnext.add(new Node(d[y][x][z], y, x, z));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//System.out.println(\"!\");\n\t\t\t\tint min = MAX;\n\t\t\t\tfor(Point p: t) {\n\t\t\t\t\tif(min > d[p.y][p.x][0]) {\n\t\t\t\t\t\tmin = d[p.y][p.x][0];\n\t\t\t\t\t}\n\t\t\t\t\tif(min > d[p.y][p.x][1]) {\n\t\t\t\t\t\tmin = d[p.y][p.x][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println((min < MAX)?min:-1);\n\n\t\t\t}\n\t\t}\n\t\tclass Point{\n\t\t\tint x, y; Point (int y, int x){this.x = x; this.y = y;}\n\t\t}\n\t\tclass Node implements Comparable<Node>{\n\t\t\tint d, x, y, z;\n\t\t\t//d => 最短距離\n\t\t\t@Override\n\t\t\tpublic int compareTo(Node arg0) {\n\t\t\t\tif(this.d < arg0.d){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if(this.d > arg0.d){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tNode(int d, int y, int x, int z){\n\t\t\t\tthis.d = d; this.x = x; this.y = y; this.z = z;\n\t\t\t}\n\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n//        new aoj2585().doIt();\n    \tnew aoj1150().doIt();\n    }\n    class aoj1150{\n    \tchar map[][] = new char [61][31];\n    \tint cost_map[][][] = new int [61][31][2];\n    \tint mlx[] = {-1,-1,-1,-1,-1,-2,-2,-2,-3};\n    \tint mly[] = {2,1,0,-1,-2,1,0,-1,0};\n    \tint mrx[] = {1,1,1,1,1,2,2,2,3};\n    \tint mry[] = {2,1,0,-1,-2,1,0,-1,0};\n    \tPriorityQueue<Par_Par> pos = new PriorityQueue<Par_Par>();\n    \tvoid clear(int W,int H){\n    \t\tpos.clear();\n    \t\tfor(int i = 0;i < H;i++){\n    \t\t\tfor(int j = 0;j < W;j++){\n    \t\t\t\tcost_map[i][j][0] = 10000000;\n                    cost_map[i][j][1] = 10000000;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid set(int W,int H){\n    \t\tfor(int i = 0;i < H;i++){\n    \t\t\tfor(int j = 0;j < W;j++){\n    \t\t\t\tmap[i][j] = sc.next().charAt(0);\n    \t\t\t\tif(map[i][j] == 'S'){\n    \t\t\t\t\tpos.add(new Par_Par(j, i, 0, 0));\n    \t\t\t\t\tpos.add(new Par_Par(j, i, 0, 1));\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint bfs(int W,int H){\n    \t\twhile(pos.size() > 0){\n    \t\t\tPar_Par pp = pos.poll();\n//    \t\t\tSystem.out.println(pp.x+\" \"+pp.y+\" \"+pp.cost+\" \"+\"ok\");\n                if(map[pp.y][pp.x] =='T')return pp.cost;\n                else if(map[pp.y][pp.x]=='X')continue;\n                else if(map[pp.y][pp.x]=='S')pp.cost += 0;\n                else pp.cost += Integer.parseInt(\"\"+map[pp.y][pp.x]);\n                \n                if(cost_map[pp.y][pp.x][pp.left_right]<=pp.cost){\n                \tcontinue;\n                }\n                cost_map[pp.y][pp.x][pp.left_right] = pp.cost;\n                if(pp.left_right==0){\n                \tfor(int i = 0;i < 9;i++){\n                \t\tint x = pp.x + mrx[i];\n                \t\tint y = pp.y + mry[i];\n                \t\tif(x >= W || y < 0 || y >= H)continue; \n                        pos.add(new Par_Par(x, y, pp.cost, 1));\n                \t}\n                }else if(pp.left_right==1){\n                \tfor(int i = 0;i < 9;i++){\n                \t\tint x = pp.x + mlx[i];\n                \t\tint y = pp.y + mly[i];\n                \t\tif(x < 0 || y < 0 || y >= H)continue;\n                        pos.add(new Par_Par(x, y, pp.cost, 0));\n                    }\n                }\n    \t\t}\n    \t\treturn -1;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint W = sc.nextInt();\n    \t\t\tint H = sc.nextInt();\n    \t\t\tif(W+H == 0)break;\n    \t\t\tclear(W,H);\n    \t\t\tset(W,H);\n    \t\t\tSystem.out.println(bfs(W,H));\n    \t\t}\n    \t}\n    \tclass Par_Par implements Comparable<Par_Par>{\n    \t\tint x,y,cost,left_right;\n            public Par_Par(int x,int y,int cost,int left_right) {\n                this.x = x;\n                this.y = y;\n                this.cost = cost;\n                this.left_right = left_right;\n            }\n            public int compareTo(Par_Par o) {\n                return this.cost - o.cost;\n            }\n    \t}\n    }\n    class aoj2585{\n    \tint W,H;\n    \tint map[][] = new int[21][21];\n    \tboolean stay[][] = new boolean[21][21];\n    \tint mx[] = {0,1,0,-1};\n    \tint my[] = {1,0,-1,0};\n    \tint result = 0;\n    \tclass Par{\n    \t\tint y,x;\n    \t\tpublic Par(int y,int x){\n    \t\t\tthis.y = y;\n    \t\t\tthis.x = x;\n    \t\t}\n    \t}\n    \tvoid dfs(int W,int H,Par end,Par start,int cnt){\n    \t\tif(start.x == end.x && start.y == end.y){\n    \t\t\tresult = Math.min(result,cnt);\n    \t\t}\n    \t\tif(cnt < 10){\n    \t\t\tfor(int i = 0;i < 4;i++){\n    \t\t\t\tif(start.x + mx[i] < 0 || start.x + mx[i] >= W\n    \t\t\t\t\t\t|| start.y + my[i] < 0 || start.y + my[i] >= H)continue;\n    \t\t\t\telse if(map[start.y + my[i]][start.x + mx[i]] == 1)continue;\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tPar end,start;\n    \t\t\tW = sc.nextInt();\n    \t\t\tH = sc.nextInt();\n    \t\t\tif(W + H == 0)break;\n    \t\t\tfor(int i = 0;i < H;i++){\n    \t\t\t\tfor(int j = 0;j < W;j++){\n    \t\t\t\t\tmap[i][j] = sc.nextInt();\n    \t\t\t\t\tif(map[i][j] == 2){\n    \t\t\t\t\t\tstay[i][j] = true;\n    \t\t\t\t\t\tstart = new Par(i,j);\n    \t\t\t\t\t}\n    \t\t\t\t\telse if(map[i][j] == 3)end = new Par(i,j);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println(result);\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic Queue<Point> queue = new LinkedList<Point>();\n\tstatic Queue<Character> footqueue = new LinkedList<Character>();\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] smap;\n\tstatic int[][] nummapr;\n\tstatic int[][] nummapl;\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ssum = 0;\n\t\t\tint gsum = 0;\n\t\t\tsc.nextLine();\n\t\t\tString line = null;\n\t\t\tchar[][] map = new char[w][h];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tline = sc.nextLine().replaceAll(\" \", \"\");\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[j][i] = line.charAt(j);\n\t\t\t\t\tif(map[j][i] == 'S'){\n\t\t\t\t\t\tssum++;\n\t\t\t\t\t}else if(map[j][i] == 'T'){\n\t\t\t\t\t\tgsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmap = map;\n\t\t\tnummapr = new int[w][h];;\n\t\t\tnummapl = new int[w][h];\n\t\t\tint[][] start = new int[2][ssum];\n\t\t\tint[][] goal = new int[2][gsum];\n\t\t\tssum = 0;\n\t\t\tgsum = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[j][i] == 'S'){\n\t\t\t\t\t\tstart[0][ssum] = j;\n\t\t\t\t\t\tstart[1][ssum] = i;\n\t\t\t\t\t\tssum++;\n\t\t\t\t\t}else if(map[j][i] == 'T'){\n\t\t\t\t\t\tgoal[0][gsum] = j;\n\t\t\t\t\t\tgoal[1][gsum] = i;\n\t\t\t\t\t\tgsum++;\n\t\t\t\t\t}\n\t\t\t\t\tnummapr[j][i] = nummapl[j][i] = Integer.MAX_VALUE; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tqueue.clear();\n\t\t\tfootqueue.clear();\n\t\t\t\n\t\t\tfor(int i = 0; i < ssum; i++){\n\t\t\t\tif(i == 0){\n\t\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\t\tnummapl[start[0][i]][start[1][i]] = 0;\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}else if(i == start.length - 1){\n\t\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\t\tnummapr[start[0][i]][start[1][i]] = 0;\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}else{\n\t\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\t\tnummapl[start[0][i]][start[1][i]] = 0;\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\t\tnummapr[start[0][i]][start[1][i]] = 0;\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size = 0;\n\t\t\tchar direction;\n\t\t\twhile(true){\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdirection = footqueue.poll();\n\t\t\t\t\tif(direction == 'r'){\n\t\t\t\t\t\tclimbing(queue.peek().x, queue.peek().y,direction,nummapr[queue.peek().x][queue.poll().y]);\n\t\t\t\t\t}else if(direction == 'l'){\n\t\t\t\t\t\tclimbing(queue.peek().x, queue.peek().y,direction,nummapl[queue.peek().x][queue.poll().y]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(queue.isEmpty() && footqueue.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tSystem.out.print(nummapr[j][i] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tSystem.out.print(nummapl[j][i] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}*/\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < goal[0].length; i++){\n\t\t\t\tsum = Math.min(sum, nummapl[goal[0][i]][goal[1][i]]);\n\t\t\t\tsum = Math.min(sum, nummapr[goal[0][i]][goal[1][i]]);\n\t\t\t}\n\t\t\tif(sum == Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static void climbing(int x, int y, Character direction, int count) {\n\t\tif(direction == 'l'){\n\t\t\tif(y + 2 <= h - 1 && x + 1 <= w - 1 && smap[x + 1][y + 2] != 'X' && smap[x + 1][y + 2] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y + 2] > count + smap[x + 1][y + 2] - 48){\n\t\t\t\tif(smap[x + 1][y + 2] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y + 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y + 2] = count + smap[x + 1][y + 2] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y + 2));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x + 1 <= w - 1 && smap[x + 1][y + 1] != 'X' && smap[x + 1][y + 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y + 1] > count + smap[x + 1][y + 1] - 48){\n\t\t\t\tif(smap[x + 1][y + 1] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y + 1] = count + smap[x + 1][y + 1] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y + 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x + 2 <= w - 1 && smap[x + 2][y + 1] != 'X' && smap[x + 2][y + 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y + 1] > count + smap[x + 2][y + 1] - 48){\n\t\t\t\tif(smap[x + 2][y + 1] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y + 1] = count + smap[x + 2][y + 1] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y + 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 1 <= w - 1 && smap[x + 1][y] != 'X' && smap[x + 1][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y] > count + smap[x + 1][y] - 48){\n\t\t\t\tif(smap[x + 1][y] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y] = count + smap[x + 1][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 2 <= w - 1 && smap[x + 2][y] != 'X' && smap[x + 2][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y] > count + smap[x + 2][y] - 48){\n\t\t\t\tif(smap[x + 2][y] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y] = count + smap[x + 2][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 3 <= w - 1 && smap[x + 3][y] != 'X' && smap[x + 3][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 3][y] > count + smap[x + 3][y] - 48){\n\t\t\t\tif(smap[x + 3][y] == 'T'){\n\t\t\t\t\tnummapr[x + 3][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 3][y] = count + smap[x + 3][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 3, y));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x + 1 <= w - 1 && smap[x + 1][y - 1] != 'X' && smap[x + 1][y - 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y - 1] > count + smap[x + 1][y - 1] - 48){\n\t\t\t\tif(smap[x + 1][y - 1] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y - 1] = count + smap[x + 1][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y - 1));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x + 2 <= w - 1 && smap[x + 2][y - 1] != 'X' && smap[x + 2][y - 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y - 1] > count + smap[x + 2][y - 1]- 48){\n\t\t\t\tif(smap[x + 2][y - 1] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y - 1] = count + smap[x + 2][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y - 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 2 >= 0 && x + 1 <= w - 1 && smap[x + 1][y - 2] != 'X' && smap[x + 1][y - 2] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y - 2] > count + smap[x + 1][y - 2]- 48){\n\t\t\t\tif(smap[x + 1][y - 2] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y - 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y - 2] = count + smap[x + 1][y - 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y - 2));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(direction == 'r'){\n\t\t\tif(y + 2 <= h - 1 && x - 1 >= 0 && smap[x - 1][y + 2] != 'X' && smap[x - 1][y + 2] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y + 2] > count + smap[x - 1][y + 2]- 48){\n\t\t\t\tif(smap[x - 1][y + 2] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y + 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y + 2] = count + smap[x - 1][y + 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y + 2));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x - 1 >= 0 && smap[x - 1][y + 1] != 'X' && smap[x - 1][y + 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y + 1] > count + smap[x - 1][y + 1]- 48){\n\t\t\t\tif(smap[x - 1][y + 1] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y + 1] = count + smap[x - 1][y + 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y + 1));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x - 2 >= 0 && smap[x - 2][y + 1] != 'X' && smap[x - 2][y + 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y + 1] > count + smap[x - 2][y + 1]- 48){\n\t\t\t\tif(smap[x - 2][y + 1] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y + 1] = count + smap[x - 2][y + 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y + 1));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 1 >= 0 && smap[x - 1][y] != 'X' && smap[x - 1][y] != 'S' \n\t\t\t\t\t&& nummapl[x - 1][y] > count + smap[x - 1][y]- 48){\n\t\t\t\tif(smap[x - 1][y] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y] = count + smap[x - 1][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 2 >= 0 && smap[x - 2][y] != 'X' && smap[x - 2][y] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y] > count + smap[x - 2][y]- 48){\n\t\t\t\tif(smap[x - 2][y] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y] = count + smap[x - 2][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 3 >= 0 && smap[x - 3][y] != 'X' && smap[x - 3][y] != 'S' \n\t\t\t\t\t&& nummapl[x - 3][y] > count + smap[x - 3][y]- 48){\n\t\t\t\tif(smap[x - 3][y] == 'T'){\n\t\t\t\t\tnummapl[x - 3][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 3][y] = count + smap[x - 3][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 3, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x - 1 >= 0 && smap[x - 1][y - 1] != 'X' && smap[x - 1][y - 1] != 'S' \n\t\t\t\t\t&& nummapl[x - 1][y - 1] > count + smap[x - 1][y - 1]- 48){\n\t\t\t\tif(smap[x - 1][y - 1] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y - 1] = count + smap[x - 1][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y - 1));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x - 2 >= 0 && smap[x - 2][y - 1] != 'X' && smap[x - 2][y - 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y - 1] > count + smap[x - 2][y - 1]- 48){\n\t\t\t\tif(smap[x - 2][y - 1] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y - 1] = count + smap[x - 2][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y - 1));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 2 >= 0 && x - 1 >= 0 && smap[x - 1][y - 2] != 'X' && smap[x - 1][y - 2] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y - 2] > count + smap[x - 1][y - 2]- 48){\n\t\t\t\tif(smap[x - 1][y - 2] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y - 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y - 2] = count + smap[x - 1][y - 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y - 2));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new int[60][30][60][30][2];\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][0] =  INF;\n\t\t\t\t\t\t\tmemo[i][j][k][l][1] =  INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tq.add(new Data(i,j,-1,-1,0,false));\n\t\t\t\t\t\tq.add(new Data(-1,-1,i,j,0,true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = solv(q);\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tout.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t\t\n\t}\n\t\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\treturn p.time;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\treturn p.time;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.swing.plaf.SliderUI;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint w, h;\n\t\n\tint INF = 100000000;\n\t\n\tint[][] edge;\n\tint[][][] minCost;\n\t\n\tint[][] vx = {\n\t\t\t{1, 2, 1, 3, 2, 1, 2, 1, 1},\n\t\t\t{-1, -2, -1, -3, -2, -1, -2, -1, -1}\n\t};\n\tint[] vy = {2, 1, 1, 0, 0, 0, -1, -1, -2};\n\t\n\tclass State implements Comparable<State> {\n\t\tint leg, x, y;\n\t\t\n\t\tState(int leg, int x, int y) {\n\t\t\tthis.leg = leg;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tpublic int compareTo(State s) {\n\t\t\tint c1 = minCost[leg][y][x], c2 = minCost[s.leg][s.y][s.x];\n\t\t\treturn c1 - c2;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x, int w, int y, int h) {\n\t\treturn x >= 0 && x < w && y >= 0 && y < h;\n\t}\n\t\n\tvoid dijkstra(int leg, int x, int y) {\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0; j < h; j++)\n\t\t\tArrays.fill(minCost[i][j], INF);\n\t\tminCost[leg][y][x] = 0;\n\t\t\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(leg, x, y));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < vy.length; i++) {\n\t\t\t\tint nx = s.x + vx[s.leg][i];\n\t\t\t\tint ny = s.y + vy[i];\n\t\t\t\tif (isOk(nx, w, ny, h) && minCost[s.leg^1][ny][nx] > minCost[s.leg][s.y][s.x] + edge[ny][nx]) {\n\t\t\t\t\tminCost[s.leg^1][ny][nx] = minCost[s.leg][s.y][s.x] + edge[ny][nx];\n\t\t\t\t\tpq.add(new State(s.leg^1, nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tw = in.nextInt(); h = in.nextInt();\n\t\t\tif (w == 0) break;\n\t\t\t\n\t\t\tArrayList<Integer> sx = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> sy = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> gx = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> gy = new ArrayList<Integer>();\n\t\t\t\n\t\t\tedge = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar c = in.next().charAt(0);\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\tedge[i][j] = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tedge[i][j] = 0;\n\t\t\t\t\t\tsx.add(j); sy.add(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tgx.add(j); gy.add(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tedge[i][j] = c - '0';\n \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tminCost = new int[2][h][w];\n\t\t\tfor (int i = 0; i < sx.size(); i++) {\n\t\t\t\tint x = sx.get(i), y = sy.get(i);\n\t\t\t\tdijkstra(0, x, y);\n//\t\t\t\tfor (int j = 0; j < h; j++)\n//\t\t\t\t\tSystem.out.println(Arrays.toString(minCost[0][j]));\n//\t\t\t\tSystem.out.println();\n//\t\t\t\tfor (int j = 0; j < h; j++)\n//\t\t\t\t\tSystem.out.println(Arrays.toString(minCost[1][j]));\n//\t\t\t\tSystem.out.println();\n\t\t\t\tfor (int j = 0; j < gx.size(); j++) {\n\t\t\t\t\tint Gx = gx.get(j), Gy = gy.get(j);\n\t\t\t\t\tres = Math.min(res, minCost[0][Gy][Gx]);\n\t\t\t\t\tres = Math.min(res, minCost[1][Gy][Gx]);\n\t\t\t\t}\n\t\t\t\tdijkstra(1, x, y);\n//\t\t\t\tfor (int j = 0; j < h; j++)\n//\t\t\t\t\tSystem.out.println(Arrays.toString(minCost[0][j]));\n//\t\t\t\tSystem.out.println();\n//\t\t\t\tfor (int j = 0; j < h; j++)\n//\t\t\t\t\tSystem.out.println(Arrays.toString(minCost[1][j]));\n//\t\t\t\tSystem.out.println();\n\t\t\t\tfor (int j = 0; j < gx.size(); j++) {\n\t\t\t\t\tint Gx = gx.get(j), Gy = gy.get(j);\n\t\t\t\t\tres = Math.min(res, minCost[0][Gy][Gx]);\n\t\t\t\t\tres = Math.min(res, minCost[1][Gy][Gx]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"-1\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tmemo = new int[h][w][h][w][2];\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tArrays.fill(memo[i][j][k][l], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(lx >= rx || Math.abs(lx - rx) + Math.abs(ly - ry) > 3) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//0030 start\n\t//0050 cording end\n\tint ans, w,h;\n\t//0が右\n\tint [][] vx = {\n\t\t\t{1,1,1,1,  1, 2, 2,  2,3},\n\t\t\t{-1,-1,-1,-1,-1, -2,-2,-2, -3}\n\t};\n\tint [][] vy = {\n\t\t\t{2,1,0,-1,-2, 1, 0, -1,0},\n\t\t\t{2,1,0,-1,-2   , 1, 0, -1,0}\n\t};\n\tint INF = 1 << 24;\n\t\n\tclass C implements Comparable<C>{\n\t\tint x, y, cost;\n\t\tint digit;\n\t\tpublic C(int x, int y, int digit, int cost) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.digit = digit;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.cost < o.cost) return -1;\n\t\t\tif(this.cost > o.cost) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", cost=\" + cost + \", digit=\"\n\t\t\t\t\t+ digit + \"]\";\n\t\t}\n\t\t\n\t}\n\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\tint [][] data = new int[h][w];\n\t\t\t//System.out.println(\"w = \" + w + \" h = \" + h);\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0;j < w; j++){\n\t\t\t\t\tchar c =sc.next().charAt(0);\n\t\t\t\t\tswitch(c){\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\tdata[i][j] = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\topen.add(new C(j, i, 0, 0));\n\t\t\t\t\t\topen.add(new C(j, i, 1, 0));\n\t\t\t\t\t\tdata[i][j] = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tdata[i][j] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tdata[i][j] = c - '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][][] close = new int[h][w][2];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0 ; j < w; j++){\n\t\t\t\t\tclose[i][j][0] = INF;\n\t\t\t\t\tclose[i][j][1] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\t//System.out.println(\"y = \" + now.y + \" x= \" + now.x + \"cost  = \" + now.cost);\n\t\t\t\tif(data[now.y][now.x] == 0){\n\t\t\t\t\t\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < vx[now.digit].length; i++){\n\t\t\t\t\tint xx = now.x + vx[now.digit][i];\n\t\t\t\t\tint yy = now.y + vy[now.digit][i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == INF) continue;\n\t\t\t\t\tint nextcost = now.cost + data[yy][xx];\n\t\t\t\t\tint nextdigit = (now.digit + 1) % 2;\n\t\t\t\t\tif(close[yy][xx][nextdigit] <= nextcost) continue;\n\t\t\t\t\t//System.out.println(\"next = \" + new C(xx, yy, nextdigit, nextcost));\n\t\t\t\t\topen.add(new C(xx, yy, nextdigit, nextcost));\n\t\t\t\t\tclose[yy][xx][nextdigit] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}//while end\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\tstatic int mi;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint w = ir.nextInt();\n\t\t\tint h = ir.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\treturn;\n\t\t\tmi = 1 << 30;\n\t\t\tchar[][] a = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\ta[i][j] = ir.next().charAt(0);\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tif (a[i][j] == 'S') {\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\t\t\tdijkstra(i * w + j, k, a);\n\t\t\t\t\t}\n\t\t\tout.println(mi == 1 << 30 ? -1 : mi);\n\t\t}\n\t}\n\n\tprivate static int[][] dijkstra(int s, int f, char[][] a) {\n\t\tint h = a.length;\n\t\tint w = a[0].length;\n\t\tint[][] d = new int[h * w][2];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tfor (int i = 0; i < a.length * a[0].length; i++)\n\t\t\tArrays.fill(d[i], 1 << 29);\n\t\td[s][f] = 0;\n\t\tpq.offer(new int[] { s, 0, f });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\t\tint nx = from / w + i;\n\t\t\t\tif (!(nx >= 0 && nx < h))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 1; j <= 3 - Math.abs(i); j++) {\n\t\t\t\t\tint ny = from % w + (2 * p[2] - 1) * j;\n\t\t\t\t\tif (!(ny >= 0 && ny < w))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (a[nx][ny] != 'X' && d[nx * w + ny][p[2] ^ 1] > d[from][p[2]]\n\t\t\t\t\t\t\t+ ((a[nx][ny] >= '0' && a[nx][ny] <= '9') ? (a[nx][ny] - '0') : 0)) {\n\t\t\t\t\t\td[nx * w + ny][p[2] ^ 1] = d[from][p[2]]\n\t\t\t\t\t\t\t\t+ ((a[nx][ny] >= '0' && a[nx][ny] <= '9') ? (a[nx][ny] - '0') : 0);\n\t\t\t\t\t\tpq.offer(new int[] { nx * w + ny, d[nx * w + ny][p[2] ^ 1], p[2] ^ 1 });\n\t\t\t\t\t\tif (a[nx][ny] == 'T')\n\t\t\t\t\t\t\tmi = Math.min(mi, d[nx * w + ny][p[2] ^ 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint w, h;\n\tchar s[][];\n\tboolean visited[][][][];\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\ts = new char[h][w];\n\t\t\tvisited = new boolean[2][w][h][w * h * 9];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = sc.next().charAt(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tif (s[h - 1][i] == 'S') {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tq.add(new Node(i, h - 1, 0, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tboolean goal = false;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode n = q.poll();\n\t\t\t\tint x = n.x;\n\t\t\t\tint y = n.y;\n\t\t\t\tint t = n.t;\n\t\t\t\tif (t >= w * h * 9)\n\t\t\t\t\tcontinue;\n\t\t\t\tint leg = n.leg;\n\t\t\t\t// System.out.println(x + \" \" + y + \" \" + t + \" \" + leg);\n\t\t\t\tif (visited[leg][x][y][t]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[leg][x][y][t] = true;\n\t\t\t\tif (t > ans)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (s[y][x] == 'T') {\n\t\t\t\t\tans = Math.min(ans, t);\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint dx[][] = new int[2][9];\n\t\t\t\tint dy[][] = new int[2][9];\n\t\t\t\tdx[0] = new int[] { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\t\t\t\tdy[0] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\t\tdx[1] = new int[] { -1, -1, -2, -1, -2, -3, -1, -2, -1 };\n\t\t\t\tdy[1] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\tint nx = x + dx[leg][i];\n\t\t\t\t\tint ny = y + dy[leg][i];\n\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h\n\t\t\t\t\t\t\t|| s[ny][nx] == 'X')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nt = t;\n\t\t\t\t\tif (s[ny][nx] >= '1' && s[ny][nx] <= '9') {\n\t\t\t\t\t\tnt += s[ny][nx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Node(nx, ny, nt, leg ^ 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal ? ans : -1);\n\t\t}\n\t}\n}\n\nclass Node {\n\tint x;\n\tint y;\n\tint t;\n\tint leg; // left 0 right 1\n\n\tNode(int x, int y, int t, int leg) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.t = t;\n\t\tthis.leg = leg;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int w,h,min;\n\tstatic int[] leftx={-1,-1,-1,-1,-1,-2,-2,-2,-3};\n\tstatic int[] lefty={2,1,0,-1,-2,1,0,-1,0};\n\tstatic Wall[][] wall;\n\tstatic Queue<Integer[]> q = new LinkedList<Integer[]>();\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin=Integer.MAX_VALUE;\n\t\t\twall=new Wall[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tString s = cin.next();\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tif(s.equals(\"T\")){\n\t\t\t\t\t\ta=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"S\")){\n\t\t\t\t\t\ta=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"X\")){\n\t\t\t\t\t\ta=-3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t\twall[i][j]=new Wall(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t//System.out.print(wall[i][j].cost+\" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(wall[i][j].cost==-1){\n\t\t\t\t\t\tInteger[] a = {i,j,0,0};\n\t\t\t\t\t\tInteger[] b = {i,j,1,0};\n\t\t\t\t\t\twall[i][j].min[0]=wall[i][j].min[1]=0;\n\t\t\t\t\t\tq.add(a);q.add(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tInteger[] a=q.poll();\n\t\t\t\tint cost,y,x,isRight;\n\t\t\t\ty=a[0];x=a[1];isRight=a[2];cost=a[3];\n\t\t\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n\t\t\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(wall[y][x].cost==-2){\n\t\t\t\t\tmin=Math.min(min, cost+2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twall[y][x].min[isRight]=cost;\n\t\t\t\tint right=0;\n\n\t\t\t\tif(isRight==0){\n\t\t\t\t\tright=1;\n\t\t\t\t\tisRight=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright=-1;\n\t\t\t\t\tisRight=0;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\t\t\tint xx=x+leftx[i]*right;\n\t\t\t\t\tint yy=y+lefty[i]*right;\n\t\t\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tInteger[] next={yy,xx,isRight,cost+wall[yy][xx].cost};\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(min==Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t\n\t}\n\t\n\tstatic void climb(int y,int x,int isRight,int cost){\n\t\t//System.out.println(x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\treturn;\n\t\t}\n\t\tif(wall[y][x].cost==-2){\n\t\t\tmin=Math.min(min, cost+2);\n\t\t\treturn;\n\t\t}\n\t\twall[y][x].min[isRight]=cost;\n\t\tint right=0;\n\n\t\tif(isRight==0){\n\t\t\tright=1;\n\t\t\tisRight=1;\n\t\t}\n\t\telse{\n\t\t\tright=-1;\n\t\t\tisRight=0;\n\t\t}\n\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\tint xx=x+leftx[i]*right;\n\t\t\tint yy=y+lefty[i]*right;\n\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclimb(yy,xx,isRight,cost+wall[yy][xx].cost);\n\n\n\t\t}\n\t}\n}\n\nclass Wall{\n\tint cost;\n\tint[] min;\n\tWall(int a){\n\t\tcost=a;\n\t\tmin=new int[2];\n\t\tmin[0]=min[1]=Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int W, H;\n\tstatic char[][] cliff = new char[60][30];\n\tstatic int ns, ng;\n\tstatic int[] sx = new int[30], gx = new int[30];\n\t\n\tstatic boolean read() {\n\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\tif (W == 0 && H == 0) return false;\n\t\t\n\t\tns = 0;\n\t\tfor (int i = 0; i < H; i++) { \n\t\t\tfor (int j = 0; j < W; j++) { \n\t\t\t\tcliff[i][j] = sc.next().charAt(0);\n\t\t\t\tif (cliff[i][j] == 'S') {\n\t\t\t\t\tsx[ns++] = j;\n\t\t\t\t\tcliff[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn true;\n\t}\n\n\tstatic final int INF = 1 << 29;\n\tstatic void solve() {\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < ns; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tans = min(ans, dijkstra(i, j));\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tif (ans == INF) \n\t\t\tans = -1;\n\t\tSystem.out.println(ans);\n\t}\t\n\t\n\tstatic int[][] dx = {\n\t\t{3, 2, 2, 2, 1, 1, 1, 1, 1},\n\t\t{-3, -2, -2, -2, -1, -1, -1, -1, -1}\n\t};\n\tstatic int[] dy = {\n\t\t0, -1, 0, 1, -2, -1, 0, 1, 2\n\t};\n\tstatic int dijkstra(int start, int sprev) {\n\t\tint[][][] dist = new int[2][60][30]; // prev_foot, prev_y, prev_x\t\n\t\tfor (int i = 0; i < 2; i++) \n\t\t\tfor (int j = 0; j < 60; j++)\n\t\t\t\tfill(dist[i][j], INF);\n\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.add(new State(0, sprev, start, H - 1));\n\t\tint ans = INF;\n\t\tboolean find = false;\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\n\t\t\tint cost = s.cost, prev = s.prev, prev_y = s.foot[1], prev_x = s.foot[0];\n\t\t\tif (dist[prev][prev_y][prev_x] <= cost) continue;\n\t\t\t\n\t\t\t// update distination\n\t\t\tdist[prev][prev_y][prev_x] = cost;\n\t\t\t// try to next step\n\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\tint nx = prev_x + dx[prev][k];\n\t\t\t\tint ny = prev_y + dy[k];\n\t\t\t\tint nprev = (prev + 1) % 2;\n\t\t\t\tint dc = getCost(nx, ny);\n\t\t\t\tif (dc == 0) {\n\t\t\t\t\t// find goal\n\t\t\t\t\tans = cost;\n\t\t\t\t\tfind = true;\n\t\t\t\t} else if (dc != -1) {\n\t\t\t\t\tint ncost = cost + dc;\n\t\t\t\t\tif (dist[nprev][ny][nx] > ncost) \n\t\t\t\t\t\tque.add(new State(ncost, nprev, nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (find)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tstatic int getCost(int x, int y) {\n\t\tif (x < 0 || W <= x || y < 0 || H <= y || cliff[y][x] == 'X')\n\t\t\treturn -1;\n\t\telse if (cliff[y][x] == 'T')\n\t\t\treturn 0;\n\t\telse \n\t\t\treturn Integer.parseInt(Character.toString(cliff[y][x]));\n\t}\n}\n\n\nclass State implements Comparable<State> {\n\tint cost, prev; // time, prev_foot\n\tint[] foot; // Lfoot\n\tState(int cost, int prev, int x, int y) {\n\t\tthis.cost = cost;\n\t\tthis.prev = prev;\n\t\tfoot = new int[2];\n\t\tfoot[0] = x;\n\t\tfoot[1] = y;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.cost - s.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int W, H;\n\tstatic char[][] cliff = new char[60][30];\n\tstatic int ns, ng;\n\tstatic int[] sx = new int[30], gx = new int[30];\n\t\n\tstatic boolean read() {\n\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\tif (W == 0 && H == 0) return false;\n\t\t\n\t\tns = 0;\n\t\tfor (int i = 0; i < H; i++) { \n\t\t\tfor (int j = 0; j < W; j++) { \n\t\t\t\tcliff[i][j] = sc.next().charAt(0);\n\t\t\t\tif (cliff[i][j] == 'S') {\n\t\t\t\t\tsx[ns++] = j;\n\t\t\t\t\tcliff[i][j] = 'X';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn true;\n\t}\n\n\tstatic final int INF = 1 << 29;\n\tstatic void solve() {\n\t\tint ans = dijkstra();\n\t\tif (ans == INF)\n\t\t\tans = -1;\n\t\tSystem.out.println(ans);\n\t}\t\n\t\n\tstatic int[][] dx = {\n\t\t{3, 2, 2, 2, 1, 1, 1, 1, 1},\n\t\t{-3, -2, -2, -2, -1, -1, -1, -1, -1}\n\t};\n\tstatic int[] dy = {\n\t\t0, -1, 0, 1, -2, -1, 0, 1, 2\n\t};\n\tstatic int[][][] dist = new int[2][60][30]; // prev_foot, prev_y, prev_x\n\tstatic int dijkstra() {\n\t\tfor (int i = 0; i < 2; i++) \n\t\t\tfor (int j = 0; j < 60; j++)\n\t\t\t\tfill(dist[i][j], INF);\n\t\t\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tfor (int i = 0; i < ns; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tque.add(new State(0, j, sx[i], H - 1));\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tint ans = INF;\n\t\tboolean find = false;\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\n\t\t\tint cost = s.cost, prev = s.prev, prev_y = s.foot[1], prev_x = s.foot[0];\n\t\t\tif (dist[prev][prev_y][prev_x] <= cost) continue;\n\t\t\t\n\t\t\t// update distination\n\t\t\tdist[prev][prev_y][prev_x] = cost;\n\t\t\t// try to next step\n\t\t\tfor (int k = 0; k < 9; k++) {\n\t\t\t\tint nx = prev_x + dx[prev][k];\n\t\t\t\tint ny = prev_y + dy[k];\n\t\t\t\tint nprev = (prev + 1) % 2;\n\t\t\t\tint dc = getCost(nx, ny);\n\t\t\t\tif (dc == 0) {\n\t\t\t\t\t// find goal\n\t\t\t\t\treturn cost;\n\t\t\t\t} else if (dc != -1) {\n\t\t\t\t\tint ncost = cost + dc;\n\t\t\t\t\tque.add(new State(ncost, nprev, nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn INF;\n\t}\n\t\n\tstatic int getCost(int x, int y) {\n\t\tif (x < 0 || W <= x || y < 0 || H <= y || cliff[y][x] == 'X')\n\t\t\treturn -1;\n\t\telse if (cliff[y][x] == 'T')\n\t\t\treturn 0;\n\t\telse \n\t\t\treturn Integer.parseInt(Character.toString(cliff[y][x]));\n\t}\n}\n\n\nclass State implements Comparable<State> {\n\tint cost, prev; // time, prev_foot\n\tint[] foot; // Lfoot\n\tState(int cost, int prev, int x, int y) {\n\t\tthis.cost = cost;\n\t\tthis.prev = prev;\n\t\tfoot = new int[2];\n\t\tfoot[0] = x;\n\t\tfoot[1] = y;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.cost - s.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\t\n\tstatic Queue<Point> queue = new LinkedList<Point>();\n\tstatic Queue<Character> footqueue = new LinkedList<Character>();\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] smap;\n\tstatic int[][] nummapr;\n\tstatic int[][] nummapl;\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ssum = 0;\n\t\t\tint gsum = 0;\n\t\t\tsc.nextLine();\n\t\t\tString line = null;\n\t\t\tchar[][] map = new char[w][h];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tline = sc.nextLine().replaceAll(\" \", \"\");\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[j][i] = line.charAt(j);\n\t\t\t\t\tif(map[j][i] == 'S'){\n\t\t\t\t\t\tssum++;\n\t\t\t\t\t}else if(map[j][i] == 'T'){\n\t\t\t\t\t\tgsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmap = map;\n\t\t\tnummapr = new int[w][h];;\n\t\t\tnummapl = new int[w][h];\n\t\t\tint[][] start = new int[2][ssum];\n\t\t\tint[][] goal = new int[2][gsum];\n\t\t\tssum = 0;\n\t\t\tgsum = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[j][i] == 'S'){\n\t\t\t\t\t\tstart[0][ssum] = j;\n\t\t\t\t\t\tstart[1][ssum] = i;\n\t\t\t\t\t\tssum++;\n\t\t\t\t\t}else if(map[j][i] == 'T'){\n\t\t\t\t\t\tgoal[0][gsum] = j;\n\t\t\t\t\t\tgoal[1][gsum] = i;\n\t\t\t\t\t\tgsum++;\n\t\t\t\t\t}\n\t\t\t\t\tnummapr[j][i] = nummapl[j][i] = Integer.MAX_VALUE; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tqueue.clear();\n\t\t\tfootqueue.clear();\n\t\t\t\n\t\t\tfor(int i = 0; i < ssum; i++){\n\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\tnummapl[start[0][i]][start[1][i]] = 0;\n\t\t\t\tfootqueue.offer('l');\n\t\t\t\tqueue.offer(new Point(start[0][i], start[1][i]));\n\t\t\t\tnummapr[start[0][i]][start[1][i]] = 0;\n\t\t\t\tfootqueue.offer('r');\n\t\t\t}\n\t\t\tint size = 0;\n\t\t\tchar direction;\n\t\t\twhile(true){\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tdirection = footqueue.poll();\n\t\t\t\t\tif(direction == 'r'){\n\t\t\t\t\t\tclimbing(queue.peek().x, queue.peek().y,direction,nummapr[queue.peek().x][queue.poll().y]);\n\t\t\t\t\t}else if(direction == 'l'){\n\t\t\t\t\t\tclimbing(queue.peek().x, queue.peek().y,direction,nummapl[queue.peek().x][queue.poll().y]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(queue.isEmpty() && footqueue.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < goal[0].length; i++){\n\t\t\t\tsum = Math.min(sum, nummapl[goal[0][i]][goal[1][i]]);\n\t\t\t\tsum = Math.min(sum, nummapr[goal[0][i]][goal[1][i]]);\n\t\t\t}\n\t\t\tif(sum == Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static void climbing(int x, int y, Character direction, int count) {\n\t\tif(direction == 'l'){\n\t\t\tif(y + 2 <= h - 1 && x + 1 <= w - 1 && smap[x + 1][y + 2] != 'X' && smap[x + 1][y + 2] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y + 2] > count + smap[x + 1][y + 2] - 48){\n\t\t\t\tif(smap[x + 1][y + 2] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y + 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y + 2] = count + smap[x + 1][y + 2] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y + 2));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x + 1 <= w - 1 && smap[x + 1][y + 1] != 'X' && smap[x + 1][y + 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y + 1] > count + smap[x + 1][y + 1] - 48){\n\t\t\t\tif(smap[x + 1][y + 1] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y + 1] = count + smap[x + 1][y + 1] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y + 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x + 2 <= w - 1 && smap[x + 2][y + 1] != 'X' && smap[x + 2][y + 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y + 1] > count + smap[x + 2][y + 1] - 48){\n\t\t\t\tif(smap[x + 2][y + 1] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y + 1] = count + smap[x + 2][y + 1] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y + 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 1 <= w - 1 && smap[x + 1][y] != 'X' && smap[x + 1][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y] > count + smap[x + 1][y] - 48){\n\t\t\t\tif(smap[x + 1][y] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y] = count + smap[x + 1][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 2 <= w - 1 && smap[x + 2][y] != 'X' && smap[x + 2][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y] > count + smap[x + 2][y] - 48){\n\t\t\t\tif(smap[x + 2][y] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y] = count + smap[x + 2][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x + 3 <= w - 1 && smap[x + 3][y] != 'X' && smap[x + 3][y] != 'S'\n\t\t\t\t\t&& nummapr[x + 3][y] > count + smap[x + 3][y] - 48){\n\t\t\t\tif(smap[x + 3][y] == 'T'){\n\t\t\t\t\tnummapr[x + 3][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 3][y] = count + smap[x + 3][y] - 48;\n\t\t\t\t\tqueue.offer(new Point(x + 3, y));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x + 1 <= w - 1 && smap[x + 1][y - 1] != 'X' && smap[x + 1][y - 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y - 1] > count + smap[x + 1][y - 1] - 48){\n\t\t\t\tif(smap[x + 1][y - 1] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y - 1] = count + smap[x + 1][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y - 1));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x + 2 <= w - 1 && smap[x + 2][y - 1] != 'X' && smap[x + 2][y - 1] != 'S'\n\t\t\t\t\t&& nummapr[x + 2][y - 1] > count + smap[x + 2][y - 1]- 48){\n\t\t\t\tif(smap[x + 2][y - 1] == 'T'){\n\t\t\t\t\tnummapr[x + 2][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 2][y - 1] = count + smap[x + 2][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 2, y - 1));\n\t\t\t\t\tfootqueue.offer('r');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 2 >= 0 && x + 1 <= w - 1 && smap[x + 1][y - 2] != 'X' && smap[x + 1][y - 2] != 'S'\n\t\t\t\t\t&& nummapr[x + 1][y - 2] > count + smap[x + 1][y - 2]- 48){\n\t\t\t\tif(smap[x + 1][y - 2] == 'T'){\n\t\t\t\t\tnummapr[x + 1][y - 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapr[x + 1][y - 2] = count + smap[x + 1][y - 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x + 1, y - 2));\n\t\t\t\t\tfootqueue.offer('r');\t\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(direction == 'r'){\n\t\t\tif(y + 2 <= h - 1 && x - 1 >= 0 && smap[x - 1][y + 2] != 'X' && smap[x - 1][y + 2] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y + 2] > count + smap[x - 1][y + 2]- 48){\n\t\t\t\tif(smap[x - 1][y + 2] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y + 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y + 2] = count + smap[x - 1][y + 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y + 2));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x - 1 >= 0 && smap[x - 1][y + 1] != 'X' && smap[x - 1][y + 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y + 1] > count + smap[x - 1][y + 1]- 48){\n\t\t\t\tif(smap[x - 1][y + 1] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y + 1] = count + smap[x - 1][y + 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y + 1));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y + 1 <= h - 1 && x - 2 >= 0 && smap[x - 2][y + 1] != 'X' && smap[x - 2][y + 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y + 1] > count + smap[x - 2][y + 1]- 48){\n\t\t\t\tif(smap[x - 2][y + 1] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y + 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y + 1] = count + smap[x - 2][y + 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y + 1));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 1 >= 0 && smap[x - 1][y] != 'X' && smap[x - 1][y] != 'S' \n\t\t\t\t\t&& nummapl[x - 1][y] > count + smap[x - 1][y]- 48){\n\t\t\t\tif(smap[x - 1][y] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y] = count + smap[x - 1][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 2 >= 0 && smap[x - 2][y] != 'X' && smap[x - 2][y] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y] > count + smap[x - 2][y]- 48){\n\t\t\t\tif(smap[x - 2][y] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y] = count + smap[x - 2][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x - 3 >= 0 && smap[x - 3][y] != 'X' && smap[x - 3][y] != 'S' \n\t\t\t\t\t&& nummapl[x - 3][y] > count + smap[x - 3][y]- 48){\n\t\t\t\tif(smap[x - 3][y] == 'T'){\n\t\t\t\t\tnummapl[x - 3][y] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 3][y] = count + smap[x - 3][y]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 3, y));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x - 1 >= 0 && smap[x - 1][y - 1] != 'X' && smap[x - 1][y - 1] != 'S' \n\t\t\t\t\t&& nummapl[x - 1][y - 1] > count + smap[x - 1][y - 1]- 48){\n\t\t\t\tif(smap[x - 1][y - 1] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y - 1] = count + smap[x - 1][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y - 1));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 1 >= 0 && x - 2 >= 0 && smap[x - 2][y - 1] != 'X' && smap[x - 2][y - 1] != 'S'\n\t\t\t\t\t&& nummapl[x - 2][y - 1] > count + smap[x - 2][y - 1]- 48){\n\t\t\t\tif(smap[x - 2][y - 1] == 'T'){\n\t\t\t\t\tnummapl[x - 2][y - 1] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 2][y - 1] = count + smap[x - 2][y - 1]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 2, y - 1));\n\t\t\t\t\tfootqueue.offer('l');\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y - 2 >= 0 && x - 1 >= 0 && smap[x - 1][y - 2] != 'X' && smap[x - 1][y - 2] != 'S'\n\t\t\t\t\t&& nummapl[x - 1][y - 2] > count + smap[x - 1][y - 2]- 48){\n\t\t\t\tif(smap[x - 1][y - 2] == 'T'){\n\t\t\t\t\tnummapl[x - 1][y - 2] = count;\n\t\t\t\t}else{\n\t\t\t\t\tnummapl[x - 1][y - 2] = count + smap[x - 1][y - 2]- 48;\n\t\t\t\t\tqueue.offer(new Point(x - 1, y - 2));\n\t\t\t\t\tfootqueue.offer('l');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint w, h;\n\tchar s[][];\n\tboolean visited[][][][];\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\ts = new char[h][w];\n\t\t\tvisited = new boolean[2][w][h][w * h * 9];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = sc.next().charAt(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\n\t\t\tint dx[][] = new int[2][9];\n\t\t\tint dy[][] = new int[2][9];\n\t\t\tdx[0] = new int[] { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\t\t\tdy[0] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\tdx[1] = new int[] { -1, -1, -2, -1, -2, -3, -1, -2, -1 };\n\t\t\tdy[1] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tif (s[h - 1][k] == 'S') {\n\t\t\t\t\tQueue<Node> q = new PriorityQueue<Node>(w * h * 2,\n\t\t\t\t\t\t\tnew Comparator<Node>() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic int compare(Node o1, Node o2) {\n\t\t\t\t\t\t\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\t\t\t\t\t\t\treturn o1.t - o2.t;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\tint d[][][] = new int[2][w][h];\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\t\tArrays.fill(d[i][j], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td[0][k][h - 1] = 0;\n\t\t\t\t\td[1][k][h - 1] = 0;\n\t\t\t\t\tq.add(new Node(k, h - 1, 0, 0));\n\t\t\t\t\tq.add(new Node(k, h - 1, 1, 0));\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tNode n = q.poll();\n\t\t\t\t\t\tint x = n.x;\n\t\t\t\t\t\tint y = n.y;\n\t\t\t\t\t\tint t = n.t;\n\t\t\t\t\t\tint leg = n.leg;\n\t\t\t\t\t\tif (d[leg][x][y] < t)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + dx[leg][i];\n\t\t\t\t\t\t\tint ny = y + dy[leg][i];\n\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h\n\t\t\t\t\t\t\t\t\t|| s[ny][nx] == 'X')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tint nt = 0;\n\t\t\t\t\t\t\tif (s[ny][nx] >= '1' && s[ny][nx] <= '9') {\n\t\t\t\t\t\t\t\tnt = s[ny][nx] - '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (d[leg ^ 1][nx][ny] > d[leg][x][y] + nt) {\n\t\t\t\t\t\t\t\td[leg ^ 1][nx][ny] = d[leg][x][y] + nt;\n\t\t\t\t\t\t\t\tq.add(new Node(nx, ny, leg ^ 1, nt));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\t\tif (s[0][i] == 'T')\n\t\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\t\tans = Math.min(ans, d[j][i][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans != INF ? ans : -1);\n\t\t}\n\t}\n}\n\nclass Node {\n\tint x;\n\tint y;\n\tint leg;\n\tint t;\n\n\tNode(int x, int y, int leg, int t) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.leg = leg;\n\t\tthis.t = t;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tstatic final int INF = 1001001001;\n\tstatic int[][][] memo = new int[2][32][32];\n\n\tstatic class State implements Comparable<State> {\n\t\tint side;\n\t\tint h, w;\n\t\tint cost;\n\t\tpublic State(int side, int h, int w, int cost) {\n\t\t\tthis.side = side;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\tint ref() {\n\t\t\treturn memo[side][h][w];\n\t\t}\n\t\tvoid memo(int v) {\n\t\t\tmemo[side][h][w] = v;\n\t\t}\n\t\tpublic int compareTo(State o) {\n\t\t\tif (cost != o.cost) return cost < o.cost ? -1 : 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint W, H;\n\tint[][] a;\n\tchar[][] s;\n\n\tvoid solve() {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tif ((W | H) == 0) return;\n\t\ta = new int[H][W];\n\t\ts = new char[H][W];\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = sc.next().toCharArray()[0];\n\t\t\t\ts[i][j] = ch;\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ta[i][j] = ch - '0';\n\t\t\t\t}\n\t\t\t}\n\n//\t\tfor (int i = 0; i < H; i++) tr(s[i]);\n\n\t\tfor (int i = 0; i < memo.length; i++) for (int j = 0; j < memo[0].length; j++) Arrays.fill(memo[i][j], INF);\n\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(0, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(1, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = -1;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState cur = pq.poll();\n//\t\t\ttr(cur.h, cur.w, cur.cost);\n\t\t\tif (cur.cost != cur.ref()) continue;\n\t\t\tif (s[cur.h][cur.w] == 'T') {\n\t\t\t\tres = cur.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int di = -3; di <= 3; di++) {\n\t\t\t\tfor (int dj = -3; dj <= 3; dj++) {\n\t\t\t\t\tif (Math.abs(di) + Math.abs(dj) <= 3) {\n\t\t\t\t\t\tint nh = cur.h + di;\n\t\t\t\t\t\tint nw = cur.w + dj;\n\t\t\t\t\t\tif (0 <= nh && nh < H && 0 <= nw && nw < W) {\n\t\t\t\t\t\t\tif (s[nh][nw] != 'X') {\n\t\t\t\t\t\t\t\tif ((cur.side == 0 && cur.w < nw) ||\n\t\t\t\t\t\t\t\t\t(cur.side == 1 && cur.w > nw)) {\n\t\t\t\t\t\t\t\t\tState nxt = new State(1 - cur.side, nh, nw, cur.cost + a[nh][nw]);\n\t\t\t\t\t\t\t\t\tif (nxt.ref() > nxt.cost) {\n\t\t\t\t\t\t\t\t\t\tnxt.memo(nxt.cost);\n\t\t\t\t\t\t\t\t\t\tpq.add(nxt);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tmemo = new int[h][w][h][w][2];\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tArrays.fill(memo[i][j][k][l], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint foot_x, foot_y;\n\t\tint using_foot;\n\t\tint time;\n\t\t\n\t\tpublic Walk(int foot_x, int foot_y, int using_foot, int denger) {\n\t\t\tsuper();\n\t\t\tthis.foot_x = foot_x;\n\t\t\tthis.foot_y = foot_y;\n\t\t\tthis.using_foot = using_foot;\n\t\t\tthis.time = denger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] times = new int[h][w];\n\t\t\tboolean[][] is_goal = new boolean[h][w];\n\t\t\t\n\t\t\tboolean[][][] is_visited = new boolean[h][w][2];\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tString str = sc.next();\n\t\t\t\t\t\n\t\t\t\t\tif(\"T\".equals(str)){\n\t\t\t\t\t\tis_goal[i][j] = true;\n\t\t\t\t\t\ttimes[i][j] = 0; \n\t\t\t\t\t}else if(\"S\".equals(str)){\n\t\t\t\t\t\tqueue.add(new Walk(j, i, 0, 0));\n\t\t\t\t\t\tqueue.add(new Walk(j, i, 1, 0));\n\t\t\t\t\t\ttimes[i][j] = 0;\n\t\t\t\t\t}else if(\"X\".equals(str)){\n\t\t\t\t\t\ttimes[i][j] = -1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttimes[i][j] = Integer.parseInt(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.foot_y][walk.foot_x][walk.using_foot]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.foot_y][walk.foot_x][walk.using_foot] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_goal[walk.foot_y][walk.foot_x]){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(walk.time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int x = 1; x <= 3; x++){\n\t\t\t\t\tfor(int y = -2; y <= 2; y++){\n\t\t\t\t\t\tif(x + Math.abs(y) > 3){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//using_foot : 0 -> left 1 -> right\n\t\t\t\t\t\tfinal int nx = walk.foot_x + (walk.using_foot == 0 ? x : -x);\n\t\t\t\t\t\tfinal int ny = walk.foot_y + y;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(times[ny][nx] < 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(is_visited[ny][nx][1 - walk.using_foot]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(new Walk(nx, ny, 1 - walk.using_foot, walk.time + times[ny][nx]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint map[][];\n\tint w, h;\n\tLinkedList<P> s;\n\tLinkedList<P> t;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h)==0) break;\n\t\t\tmap = new int[h][w];\n\t\t\ts = new LinkedList<P>();\n\t\t\tt = new LinkedList<P>();\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif( c == 'S' ) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\ts.add(new P(j, i));\n\t\t\t\t}\n\t\t\t\telse if( c == 'T' ) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tt.add(new P(j, i));\n\t\t\t\t}\n\t\t\t\telse if(c == 'X' )map[i][j] = -1;\n\t\t\t\telse map[i][j] = c - '0';\n\t\t\t}\n\t\t\tSystem.out.println(bfs());\n\t\t}\n\t}\n\t\n\tint bfs() {\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new Comp());\n\t\tfor(P p: s) {\n\t\t\tque.add(new Pair(p, false, 0));\n\t\t\tque.add(new Pair(p, true, 0));\n\t\t}\n\t\tHashSet<Pair> isVisited = new HashSet<Pair>();\n\t\tfor(;!que.isEmpty();) {\n\t\t\tPair now = que.remove();\n\t\t\tP p = now.p;\n\t\t\tif(isGoal(p)) return now.t;\n\t\t\tif(isVisited.contains(now))continue;\n\t\t\tisVisited.add(now);\n\t\t\tfor(int i=1;i<=3;i++) {\n\t\t\t\tfor(int dy=-(3-i);dy<=(3-i);dy++) {\n\t\t\t\t\tint dx = now.left? i:-i;\n\t\t\t\t\tif(canMove(p.x+dx, p.y+dy)) {\n\t\t\t\t\t\tque.add(new Pair(new P(p.x+dx, p.y+dy),\n\t\t\t\t\t\t\t\t!now.left, \n\t\t\t\t\t\t\t\tnow.t + map[p.y+dy][p.x+dx]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tboolean isGoal(P p) {\n\t\tfor(P pos: t) \n\t\t\tif(p.x == pos.x && p.y == pos.y) return true;\n\t\treturn false;\n\t}\n\t\n\tboolean canMove(int x, int y) {\n\t\treturn 0 <= x && 0 <= y && x < w && y < h && map[y][x] >= 0 ;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\tP p;\n\t\tboolean left;\n\t\tint t;\n\t\tPair(P p, boolean left, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.left = left;\n\t\t}\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\treturn p.y*60+p.x*2+(left?1:0);\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tPair pp = (Pair) o;\n\t\t\treturn left&pp.left && p.x == pp.p.x && p.y == pp.p.y;\n\t\t}\n\t}\n\t\n\tclass Comp implements Comparator<Pair> {\n\t\t\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tPair p1 = (Pair) o1;\n\t\t\tPair p2 = (Pair) o2;\n\t\t\treturn p1.t-p2.t;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().D();\n\t}\n\t\n\tint[] rx={1,1,2,1,2,3,1,2,1}, fy={-2,-1,-1,0,0,0,1,1,2};\n\tint[] lx={-1,-1,-2,-1,-2,-3,-1,-2,-1};\n\tvoid D(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][][] close=new int[W][H][2];\n\t\t\tPriorityQueue<D> open=new PriorityQueue<D>();\n\t\t\t//LinkedList<D> open=new LinkedList<D>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tchar temp=sc.next().charAt(0);\n\t\t\t\t\tc[x][y]=temp;\n\t\t\t\t\tif(temp=='S'){\n\t\t\t\t\t\topen.add(new D(x,y,0,0));\n\t\t\t\t\t\topen.add(new D(x,y,0,1));\n\t\t\t\t\t\tclose[x][y][0]=-1;\n\t\t\t\t\t\tclose[x][y][1]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tD now=open.poll();\n\t\t\t\t//out.println(now.x+\" \"+now.y);\n\t\t\t\tint[] fx=(now.f==0? rx: lx);\n\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\tint xx=now.x+fx[i], yy=now.y+fy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='X')\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='T'){\n\t\t\t\t\t\tans=(ans<0? now.c: min(ans,now.c));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c+Character.digit(c[xx][yy],10)>=close[xx][yy][1-now.f] && close[xx][yy][1-now.f]!=0)\tcontinue;\n\t\t\t\t\topen.add(new D(xx,yy,now.c+Character.digit(c[xx][yy],10),now.f==0?1:0));\n\t\t\t\t\tclose[xx][yy][1-now.f]=now.c+Character.digit(c[xx][yy],10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass D implements Comparable<D>{\n\t\tint x,y,c,f;\n\t\tD(int x,int y,int c,int f){\n\t\t\tthis.x=x;\tthis.y=y;\tthis.c=c;\tthis.f=f;\n\t\t}\n\t\t@Override public int compareTo(D arg0) {\n\t\t\tif(this.c<c)\treturn -1;\n\t\t\tif(this.c>c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid B(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(), M=sc.nextInt();\n\t\t\tif((N|M)==0)break;\n\t\t\tint r=sc.nextInt();\n\t\t\tArrayList<C>[] list=new ArrayList[M];\n\t\t\tfor(int i=0; i<M; i++)\tlist[i]=new ArrayList<C>();\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tint time=sc.nextInt(), pc=sc.nextInt(), st=sc.nextInt()-1, k=sc.nextInt();\n\t\t\t\tArrayList<C> ar=list[st];\n\t\t\t\tif(k==1){\n\t\t\t\t\tif(ar.size()==0)\tar.add(new C(time,1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\t\tC temp=ar.get(j);\n\t\t\t\t\t\t\tif(temp.s<=time && time<=temp.e){\n\t\t\t\t\t\t\t\ttemp.count++;\n\t\t\t\t\t\t\t\tar.set(j, temp);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//out.println(\"R\"+j);\n\t\t\t\t\t\t\t\tar.add(new C(time,1));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist[st]=ar;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\tC temp=ar.get(j);\n\t\t\t\t\t\ttemp.count--;\n\t\t\t\t\t\tif(temp.count==0){\n\t\t\t\t\t\t\ttemp.e=time;\n\t\t\t\t\t\t\ttemp.count=-1;\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(temp.count>0){\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//out.println(\"K\"+k+\" \")\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t//for(int i=0; i<M; i++)\tout.println(list[i]);\n\t\t\t\n\t\t\tint Q=sc.nextInt();\n\t\t\tfor(int i=0; i<Q; i++){\n\t\t\t\tint S=sc.nextInt(), E=sc.nextInt(), ST=sc.nextInt()-1;\n\t\t\t\tArrayList<C> ar=list[ST];\n\t\t\t\tint ans=0;\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tC temp2=ar.get(j);\n\t\t\t\t\tC temp=new C(temp2.s,temp2.e,temp2.count);\n\t\t\t\t\tif(temp.s<=S && S<=temp.e)\ttemp.s=S;\n\t\t\t\t\tif(temp.s<=E && E<=temp.e)\ttemp.e=E;\n\t\t\t\t\tif(S<=temp.s && temp.e<=E)\tans+=temp.e-temp.s;\n\t\t\t\t\t//out.println(\"ANS\"+ans+\"\"+temp.s+\" E\"+temp.e);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tclass C{\n\t\tint s,e,count;\n\t\tC(int s,int count){\n\t\t\tthis.s=s;\tthis.e=Integer.MAX_VALUE;\tthis.count=count;\n\t\t}\n\t\tC(int s,int e,int count){\n\t\t\tthis.s=s;\tthis.e=e;\tthis.count=count;\n\t\t}\n\t\t@Override public String toString(){\n\t\t\treturn \"S\"+s+\" E\"+e+\" C\"+count;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\npublic class Main {\n\n    static class State implements Comparable<State>{\n        int x, y, lr;\n        int cost;\n        State(int x, int y, int lr, int cost){\n            this.x = x;\n            this.y = y;\n            this.lr = lr;\n            this.cost = cost;\n        }\n        public int compareTo(State st){\n            return this.cost - st.cost;\n        }\n    }\n    static int w, h;\n    static char[][] t;\n\n    static int[][] dx;\n    static int[][] dy;\n\n    static {\n        dx = new int[2][9];\n        dy = new int[2][9];\n        int cnt = 0;\n        for(int i=1;i<=3;i++){\n            for(int j=-2;j<=2;j++){\n                if(Math.abs(i) + Math.abs(j) <= 3){\n//                    out.println(i+\" \"+j);\n                    dx[0][cnt] = i;\n                    dy[0][cnt] = j;\n                    dx[1][cnt] = i*(-1);\n                    dy[1][cnt] = j;\n                    cnt++;\n                }\n            }\n        }\n    }\n\n    static void solve(){\n        PriorityQueue<State> open = new PriorityQueue<State>();\n        boolean[][][] closed = new boolean[h][w][2];\n        State st = null;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(t[i][j] != 'S') continue;\n                st = new State(j, i, 0, 0);\n                open.add(st);\n                st = new State(j, i, 1, 0);\n                open.add(st);\n            }\n        }\n\n        while(!open.isEmpty()){\n            st = open.poll();\n            if(closed[st.y][st.x][st.lr]) continue;\n            closed[st.y][st.x][st.lr] = true;\n\n            if(t[st.y][st.x] == 'T'){\n                out.println(st.cost);\n                return;\n            }\n\n            for(int i=0;i<9;i++){\n                int nx, ny, nc;\n\n                nx = st.x + dx[st.lr][i];\n                ny = st.y + dy[st.lr][i];\n                if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n                nc = st.cost + t[ny][nx] - '0';\n\n                if(t[ny][nx] == 'X') continue;\n                if(t[ny][nx] == 'S' || t[ny][nx] == 'T') nc = nc - t[ny][nx] + '0';\n\n                State ns = new State(nx, ny, (st.lr+1)%2, nc);\n\n                open.add(ns);\n            }\n        }\n        out.println(-1);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w == 0 && h == 0) break;\n            t = new char[h][w];\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    t[i][j] = sc.next().charAt(0);\n                }\n            }\n\n            solve();\n        }\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tmemo = new int[h][w][h][w][2];\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tArrays.fill(memo[i][j][k][l], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n//\tpublic static int[][][] cost;\n\tpublic static int[][] dx = {\n\t\t{1, 1, 2, 1, 2, 3, 1, 2, 1},\n\t\t{-1, -1, -2, -1, -2, -3, -1, -2, -1},\n\t};\n\tpublic static int[][] dy = {\n\t\t{-2, -1, -1, 0, 0, 0, 1, 1, 2},\n\t\t{-2, -1, -1, 0, 0, 0, 1, 1, 2}\n\t};\n\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tfinal int INF = (int)1e8;\n\t\twhile(true){\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tQueue<Pos> slist = new LinkedList<Pos>();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmap[i][j] = in.next().charAt(0);\n\t\t\t\t\tif(map[i][j] == 'S'){\n\t\t\t\t\t\tslist.add(new Pos(i*w+j, j, i, 0, 0));\n\t\t\t\t\t\tslist.add(new Pos(i*w+j, j, i, 1, 0));\n\t\t\t\t\t\t// state: 0:left 1:right\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcost = new int[2][h][w];\n\t\t\tBitSet[] used = new BitSet[2];\n\t\t\tused[0] = new BitSet(h*w);\n\t\t\tused[1] = new BitSet(h*w);\n\t\t\tint res = INF;\n\t\t\twhile(!slist.isEmpty()){\n\t\t\t\tPos start = slist.poll();\n\t\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\t\tqu.add(start);\n\t\t\t\tused[0].clear();\n\t\t\t\tused[1].clear();\n\t\t\t\twhile(!qu.isEmpty()){\n\t\t\t\t\tPos p = qu.poll();\n\t\t\t\t\tif(used[p.state].get(p.id)) continue;\n\t\t\t\t\tused[p.state].set(p.id);\n\t\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\t\tint nx = p.x + dx[p.state][i];\n\t\t\t\t\t\tint ny = p.y + dy[p.state][i];\n\t\t\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\t\tif(map[ny][nx] == 'S' || map[ny][nx] == 'X') continue;\n\t\t\t\t\t\tif(map[ny][nx] == 'T'){\n\t\t\t\t\t\t\tres = Math.min(res, p.dist);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint d = map[ny][nx] - '0';\n\t\t\t\t\t\tqu.add(new Pos(ny*w+nx, nx, ny, p.state==0?1:0, p.dist+d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t\tin.close();\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id, x, y, state, dist;\n\tpublic Pos(int id, int x, int y, int state, int dist){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.id = id;\n\t\tthis.dist = dist;\n\t\tthis.state = state;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn dist - o.dist;\n//\t\treturn Main.cost[state][y][x] - Main.cost[o.state][o.y][o.x];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tnew AOJ1150().doIt(w, h);\n\t\t}\n\t}\n\tclass AOJ1150{\n\t\tvoid doIt(int w,int h){\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = in.next().charAt(0);\n//\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='S'){\n\t\t\t\tq.add(new State(s, i, 0, 0));\n\t\t\t\tq.add(new State(s, i, 0, 1));\n\t\t\t}\n\n\t\t\tint[][][] maps = new int[h][w][2];\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++){\n\t\t\t\tmaps[i][s][0] = Integer.MAX_VALUE/2;\n\t\t\t\tmaps[i][s][1] = Integer.MAX_VALUE/2;\n\t\t\t}\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tint x = now.x,y = now.y;\n\t\t\t\tif(map[y][x]=='T'){\n\t\t\t\t\tresult = now.step;break;\n\t\t\t\t}else if(map[y][x]=='X'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x]=='S'){\n\t\t\t\t\tnow.step += 0;\n\t\t\t\t}else{\n\t\t\t\t\tnow.step += Integer.parseInt(\"\"+map[y][x]);\n\t\t\t\t}\n\t\t\t\tif(maps[y][x][now.foot]<=now.step)continue;\n\t\t\t\tmaps[y][x][now.foot] = now.step;\n\t\t\t\tif(now.foot==0){//次に動かすのは右\n\t\t\t\t\tfor(int px=1;px<=3;px++)for(int py=-2;py<=2;py++){\n\t\t\t\t\t\tint nx = px+x, ny = py+y;\n\t\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\t\tif(Math.abs(nx-x)+Math.abs(ny-y)>3)continue;\t\n\t\t\t\t\t\tq.add(new State(nx, ny, now.step, 1));\n\t\t\t\t\t}\n\t\t\t\t}else if(now.foot==1){//次に動かすのは左\n\t\t\t\t\tfor(int px=-3;px<0;px++)for(int py=-2;py<=2;py++){\n\t\t\t\t\t\tint nx = px+x, ny = py+y;\n\t\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\t\tif(Math.abs(nx-x)+Math.abs(ny-y)>3)continue;\t\t\t\t\t\t\n\t\t\t\t\t\tq.add(new State(nx, ny, now.step, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"right\");\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.printf(\"%10d \",maps[i][s][0]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println(\"\\n left\");\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.printf(\"%10d \",maps[i][s][1]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n//\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='T'){\n//\t\t\t\tresult = Math.min(result, Math.min(maps[i][s][0], maps[i][s][1]));\n//\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,step,foot;//1なら右、0で左\n\t\t\tpublic State(int x,int y,int step,int foot) {\n\t\t\t\tthis.x = x;this.y = y;this.step = step;this.foot = foot;\n\t\t\t}\n\t\t\tpublic int compareTo(State o) {\n\t\t\t\treturn this.step - o.step;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tnew AOJ1150().doIt(w, h);\n\t\t}\n\t}\n\tclass AOJ1150{\n\t\tvoid doIt(int w,int h){\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = in.next().charAt(0);\n\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='S'){\n\t\t\t\tq.add(new State(s, i, 0, 0));\n\t\t\t\tq.add(new State(s, i, 0, 1));\n\t\t\t}\n\n\t\t\tint[][][] maps = new int[h][w][2];\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++){\n\t\t\t\tmaps[i][s][0] = Integer.MAX_VALUE/2;\n\t\t\t\tmaps[i][s][1] = Integer.MAX_VALUE/2;\n\t\t\t}\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tint x = now.x,y = now.y;\n\t\t\t\tif(map[y][x]=='T'){\n\t\t\t\t\tresult = now.step;\n\t\t\t\t}else if(map[y][x]=='X'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x]=='S'){\n\t\t\t\t\tnow.step += 0;\n\t\t\t\t}else{\n\t\t\t\t\tnow.step += Integer.parseInt(\"\"+map[y][x]);\n\t\t\t\t}\n\t\t\t\tif(maps[y][x][now.foot]<=now.step)continue;\n\t\t\t\tmaps[y][x][now.foot] = now.step;\n\t\t\t\tif(now.foot==0){//次に動かすのは右\n\t\t\t\t\tfor(int px=1;px<=3;px++)for(int py=-2;py<=2;py++){\n\t\t\t\t\t\tint nx = px+x, ny = py+y;\n\t\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\t\tif(Math.abs(nx-x)+Math.abs(ny-y)>3)continue;\t\n\t\t\t\t\t\tq.add(new State(nx, ny, now.step, 1));\n\t\t\t\t\t}\n\t\t\t\t}else if(now.foot==1){//次に動かすのは左\n\t\t\t\t\tfor(int px=-3;px<0;px++)for(int py=-2;py<=2;py++){\n\t\t\t\t\t\tint nx = px+x, ny = py+y;\n\t\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\t\t\tif(Math.abs(nx-x)+Math.abs(ny-y)>3)continue;\t\t\t\t\t\t\n\t\t\t\t\t\tq.add(new State(nx, ny, now.step, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"right\");\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.printf(\"%10d \",maps[i][s][0]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println(\"\\n left\");\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.printf(\"%10d \",maps[i][s][1]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='T'){\n\t\t\t\tresult = Math.min(result, Math.min(maps[i][s][0], maps[i][s][1]));\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tclass State{\n\t\t\tint x,y,step,foot;//1なら右、0で左\n\t\t\tpublic State(int x,int y,int step,int foot) {\n\t\t\t\tthis.x = x;this.y = y;this.step = step;this.foot = foot;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint w, h;\n\tint[][] board;\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = in.nextInt(); h = in.nextInt();\n\t\t\tif(w==0 && h==0) return ;\n\t\t\tboard = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tString s = in.next();\n\t\t\t\t\tchar c = s.charAt(0);\n\t\t\t\t\tif(Character.isDigit(c)){\n\t\t\t\t\t\tboard[i][j] = c - '0';\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 'T'){\n\t\t\t\t\t\tboard[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 'S'){\n\t\t\t\t\t\tboard[i][j] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tclass State{\n\t\tint dist, x, y, foot;\n\t\tState(int _d, int _y, int _x, int _f){\n\t\t\tthis.dist = _d;\n\t\t\tthis.y = _y;\n\t\t\tthis.x = _x;\n\t\t\tthis.foot = _f;\n\t\t}\n\t}\n\n\tclass Cmp implements Comparator<State>{\n\t\tpublic int compare(State a, State b){\n\t\t\treturn a.dist>b.dist?1:a.dist<b.dist?-1:0;\n\t\t}\n\t}\n\n\tint solve(){\n\t\tPriorityQueue<State> Q = new PriorityQueue<State>(11,new Cmp())\t;\n\t\tint[][][] dist = new int[2][h][w];\n\t\tfor(int k=0; k<2; k++)\n\t\t\tfor(int i=0; i<h; i++)\n\t\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\t\tdist[k][i][j] = -1;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++)if(board[i][j] == -1){\n\t\t\t\tfor(int k=0; k<2; k++)\n\t\t\t\t\tQ.add(new State(0,i,j,k));\n\t\t\t}\n\t\t}\n\t\twhile(!Q.isEmpty()){\n\t\t\tState tp = Q.poll();\n\t\t\tif(dist[tp.foot][tp.y][tp.x] != -1) continue;\n\t\t\tdist[tp.foot][tp.y][tp.x] = tp.dist;\n\t\t\tfor(int dx=1; dx<=3; dx++){\n\t\t\t\tfor(int dy=-2; dy<=2; dy++)if(dx + abs(dy) <= 3){\n\t\t\t\t\tint ny = tp.y + dy, nx = tp.x + ((tp.foot==0)?dx:-dx);\n\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && board[ny][nx]!=0 && dist[1-tp.foot][ny][nx] == -1){\n\t\t\t\t\t\tQ.add(new State(tp.dist + (board[ny][nx]>0?board[ny][nx]:0), ny, nx, 1-tp.foot));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 1<<20;\n\t\tfor(int k=0; k<2; k++){\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] == -2 && dist[k][i][j] != -1 && ret > dist[k][i][j])\n\t\t\t\t\t\tret = dist[k][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret==1<<20?-1:ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic int[] dx=new int[]{1,0,-1,0};\n\tpublic int[] dy=new int[]{0,1,0,-1};\n\n\tclass Task implements Comparable<Task>{\n\t\tint x,y,lr;\n\t\tint cost;\n\t\tTask(int _y,int _x,int _lr,int _cost){\n\t\t\tx=_x;y=_y;lr=_lr;cost=_cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(!(o instanceof Task))return false;\n\t\t\tTask t=(Task)o;\n\t\t\treturn x==t.x && y==t.y && lr==t.lr;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task o) {\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tmap[h][w]=sc.next().charAt(0);\n\t\t\t}\n\n\t\t\tint[][][] dp=new int[H][W][2];//lr\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tArrays.fill(dp[h][w],100000000);\n\t\t\t}\n\t\t\t//S\n\t\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\t\tboolean[][][] used=new boolean[H][W][2];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(map[h][w]=='S'){\n\t\t\t\t\tdp[h][w][1]=dp[h][w][0]=0;\n\t\t\t\t\tque.add(new Task(h,w,0,0));\n\t\t\t\t\tque.add(new Task(h,w,1,0));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tTask t=que.poll();\n\t\t\t\tif(used[t.y][t.x][t.lr])continue;\n\t\t\t\t//次の点に行く\n\t\t\t\tint nlr=t.lr==0?1:0;\n\t\t\t\tfor(int x=-3;x<=3;x++)for(int y=-3;y<=3;y++){\n\t\t\t\t\tif(((t.lr==0 && x>0) ||(t.lr==1 && x<0)) && abs(x)+abs(y)<=3){\n\t\t\t\t\t\tint nx=x+t.x,ny=y+t.y;\n\t\t\t\t\t\tif(!(0<=nx && nx <W && 0<=ny && ny<H))continue;\n\t\t\t\t\t\tswitch(map[ny][nx]){\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\tln(t.cost);continue Case;\n\t\t\t\t\t\tcase 'X':\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tint c=t.cost+(map[ny][nx]-'0');\n\t\t\t\t\t\t\tif(dp[ny][nx][nlr]>c){\n\t\t\t\t\t\t\t\tdp[ny][nx][nlr]=c;\n\t\t\t\t\t\t\t\tque.add(new Task(ny,nx,nlr,c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[t.y][t.x][t.lr]=true;\n\t\t\t}\n\t\t\tln(-1);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tstatic final int INF = 1001001001;\n\tstatic int[][][] memo = new int[2][32][32];\n\n\tstatic class State implements Comparable<State> {\n\t\tint side;\n\t\tint h, w;\n\t\tint cost;\n\t\tpublic State(int side, int h, int w, int cost) {\n\t\t\tthis.side = side;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\tint ref() {\n\t\t\treturn memo[side][h][w];\n\t\t}\n\t\tvoid memo(int v) {\n\t\t\tmemo[side][h][w] = v;\n\t\t}\n\t\tpublic int compareTo(State o) {\n\t\t\tif (cost != o.cost) return cost < o.cost ? -1 : 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint W, H;\n\tint[][] a;\n\tchar[][] s;\n\n\tvoid solve() {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tif ((W | H) == 0) return;\n\t\ta = new int[H][W];\n\t\ts = new char[H][W];\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = sc.next().toCharArray()[0];\n\t\t\t\ts[i][j] = ch;\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ta[i][j] = ch - '0';\n\t\t\t\t}\n\t\t\t}\n\n//\t\tfor (int i = 0; i < H; i++) tr(s[i]);\n\n\t\tfor (int i = 0; i < memo.length; i++) for (int j = 0; j < memo[0].length; j++) Arrays.fill(memo[i][j], INF);\n\n\t\tPriorityQueue<State> pq = new PriorityQueue<>();\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(0, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(1, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = -1;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState cur = pq.poll();\n//\t\t\ttr(cur.h, cur.w, cur.cost);\n\t\t\tif (cur.cost != cur.ref()) continue;\n\t\t\tif (s[cur.h][cur.w] == 'T') {\n\t\t\t\tres = cur.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int di = -3; di <= 3; di++) {\n\t\t\t\tfor (int dj = -3; dj <= 3; dj++) {\n\t\t\t\t\tif (Math.abs(di) + Math.abs(dj) <= 3) {\n\t\t\t\t\t\tint nh = cur.h + di;\n\t\t\t\t\t\tint nw = cur.w + dj;\n\t\t\t\t\t\tif (0 <= nh && nh < H && 0 <= nw && nw < W) {\n\t\t\t\t\t\t\tif (s[nh][nw] != 'X') {\n\t\t\t\t\t\t\t\tif ((cur.side == 0 && cur.w < nw) ||\n\t\t\t\t\t\t\t\t\t(cur.side == 1 && cur.w > nw)) {\n\t\t\t\t\t\t\t\t\tState nxt = new State(1 - cur.side, nh, nw, cur.cost + a[nh][nw]);\n\t\t\t\t\t\t\t\t\tif (nxt.ref() > nxt.cost) {\n\t\t\t\t\t\t\t\t\t\tnxt.memo(nxt.cost);\n\t\t\t\t\t\t\t\t\t\tpq.add(nxt);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    static int w,h,min;\n    static int[] leftx={-1,-1,-1,-1,-1,-2,-2,-2,-3};\n    static int[] lefty={2,1,0,-1,-2,1,0,-1,0};\n    static Wall[][] wall;\n    static PriorityQueue<State> q = new PriorityQueue<State>();\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        for(;;){\n            w=cin.nextInt();\n            h=cin.nextInt();\n            if(w+h==0){\n                break;\n            }\n            min=Integer.MAX_VALUE;\n            wall=new Wall[h][w];\n            for(int i = 0;i<h;i++){\n                for(int j = 0;j<w;j++){\n                    String s = cin.next();\n                    int a = 0;\n                    if(s.equals(\"T\")){\n                        a=-2;\n                    }\n                    else if(s.equals(\"S\")){\n                        a=-1;\n                    }\n                    else if(s.equals(\"X\")){\n                        a=-3;\n                    }\n                    else{\n                        a=Integer.parseInt(s);\n                    }\n                    wall[i][j]=new Wall(a);\n                }\n            }\n            for(int i = 0;i<h;i++){\n                for(int j = 0;j<w;j++){\n                    //System.out.print(wall[i][j].cost+\" \");\n                }\n                //System.out.println();\n            }\n            for(int i = 0;i<h;i++){\n                for(int j = 0;j<w;j++){\n                    if(wall[i][j].cost==-1){\n                    \tState a = new State(i,j,0,0);\n                    \tState b = new State(i,j,1,0);\n                        wall[i][j].min[0]=wall[i][j].min[1]=0;\n                        q.add(a);q.add(b);\n                    }\n                }\n            }\n            while(!q.isEmpty()){\n                State a=q.poll();\n                int cost,y,x,isRight;\n                y=a.y;x=a.x;isRight=a.isRight;cost=a.cost;\n                if(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n                    //System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n                    continue;\n                }\n                if(wall[y][x].cost==-2){\n                    min=Math.min(min, cost+2);\n                    continue;\n                }\n                wall[y][x].min[isRight]=cost;\n                int right=0;\n \n                if(isRight==0){\n                    right=1;\n                    isRight=1;\n                }\n                else{\n                    right=-1;\n                    isRight=0;\n                }\n                for(int i = 0;i<leftx.length;i++){\n                    int xx=x+leftx[i]*right;\n                    int yy=y+lefty[i]*right;\n                    if(xx<0||xx>=w||yy<0||yy>=h){\n                        continue;\n                    }\n                    if(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n                        continue;\n                    }\n                    State next=new State(yy,xx,isRight,cost+wall[yy][xx].cost);\n                    q.add(next);\n                }       \n            }\n            if(min==Integer.MAX_VALUE){\n                System.out.println(-1);\n            }\n            else{\n                System.out.println(min);\n            }\n        }\n     \n    }\n     \n    static void climb(int y,int x,int isRight,int cost){\n        //System.out.println(x+\" \" +y+\" \" +isRight+\" \"+cost);\n        if(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n            //System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n            return;\n        }\n        if(wall[y][x].cost==-2){\n            min=Math.min(min, cost+2);\n            return;\n        }\n        wall[y][x].min[isRight]=cost;\n        int right=0;\n \n        if(isRight==0){\n            right=1;\n            isRight=1;\n        }\n        else{\n            right=-1;\n            isRight=0;\n        }\n        for(int i = 0;i<leftx.length;i++){\n            int xx=x+leftx[i]*right;\n            int yy=y+lefty[i]*right;\n            if(xx<0||xx>=w||yy<0||yy>=h){\n                continue;\n            }\n            if(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n                continue;\n            }\n            climb(yy,xx,isRight,cost+wall[yy][xx].cost);\n \n \n        }\n    }\n}\nclass State implements Comparable{\n\tint y,x,isRight,cost;\n\tState(int a,int b,int c,int d){\n\t\ty=a;x=b;isRight=c;cost=d;\n\t}\n\tpublic int compareTo(Object o){\n\t\tState s = (State)o;\n\t\treturn this.cost-s.cost;\n\t}\n}\nclass Wall{\n    int cost;\n    int[] min;\n    Wall(int a){\n        cost=a;\n        min=new int[2];\n        min[0]=min[1]=Integer.MAX_VALUE;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tint[][] left = new int[h][w];\n\t\t\tint[][] right = new int[h][w];\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.next().charAt(0);\n\t\t\t\t\tleft[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tright[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tif(map[h-1][i]=='S'){\n\t\t\t\t\tleft[h-1][i] = 0;\n\t\t\t\t\tright[h-1][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(true){\n\t\t\t\tboolean flag = false;\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(left[i][j]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tfor(int p=-2;p<=2;p++){\n\t\t\t\t\t\t\t\tfor(int q=1;q<=3-Math.abs(p);q++){\n\t\t\t\t\t\t\t\t\tif(0<=j+q && j+q<w && 0<=i+p && i+p<h){\n\t\t\t\t\t\t\t\t\t\tif(map[i+p][j+q]=='T' && ans>left[i][j]){\n\t\t\t\t\t\t\t\t\t\t\tans = left[i][j];\n\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t}else if(map[i+p][j+q]=='S' || map[i+p][j+q]=='X'){\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tif(left[i][j]+(int)map[i+p][j+q]-48 < right[i+p][j+q]){\n\t\t\t\t\t\t\t\t\t\t\t\tright[i+p][j+q] = left[i][j] + (int)map[i+p][j+q]-48;\n\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(right[i][j]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tfor(int p=-2;p<=2;p++){\n\t\t\t\t\t\t\t\tfor(int q=1;q<=3-Math.abs(p);q++){\n\t\t\t\t\t\t\t\t\tif(0<=j-q && j-q<w && 0<=i+p && i+p<h){\n\t\t\t\t\t\t\t\t\t\tif(map[i+p][j-q]=='T' && ans>right[i][j]){\n\t\t\t\t\t\t\t\t\t\t\tans = right[i][j];\n\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t}else if(map[i+p][j-q]=='S' || map[i+p][j-q]=='X'){\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tif(right[i][j]+(int)map[i+p][j-q]-48 < left[i+p][j-q]){\n\t\t\t\t\t\t\t\t\t\t\t\tleft[i+p][j-q] = right[i][j] + (int)map[i+p][j-q]-48;\n\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\tif(ans==Integer.MAX_VALUE) System.out.println(-1);\n\t\t\telse System.out.println(ans);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "// Cliff Climbing\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] cliff = new int[h][w];\n\t\t\tint[][][] costs = new int[2][h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tArrays.fill(cliff[i], -1);\n\t\t\t\tArrays.fill(costs[0][i], -1);\n\t\t\t\tArrays.fill(costs[1][i], -1);\n\t\t\t}\n\t\t\tList<Integer> gx = new ArrayList<Integer>();\n\t\t\tList<Integer> gy = new ArrayList<Integer>();\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\t\tif (Character.isDigit(c))\n\t\t\t\t\t\tcliff[i][j] = c - '0';\n\t\t\t\t\telse if (c == 'S') {\n\t\t\t\t\t\tcliff[i][j] = 0;\n\t\t\t\t\t\tqueue.add(new Node(j, i, 0, 'R'));\n\t\t\t\t\t\tqueue.add(new Node(j, i, 0, 'L'));\n\t\t\t\t\t} else if (c == 'T') {\n\t\t\t\t\t\tcliff[i][j] = 0;\n\t\t\t\t\t\tgx.add(j);\n\t\t\t\t\t\tgy.add(i);\n\t\t\t\t\t} else if (c == 'X')\n\t\t\t\t\t\tcliff[i][j] = -1;\n\t\t\t\t}\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint tx = node.x;\n\t\t\t\tint ty = node.y;\n\t\t\t\tint tc = node.cost;\n\t\t\t\tchar tf = node.foot;\n\t\t\t\tif (tf == 'R') {\n\t\t\t\t\tif (costs[0][ty][tx] >= 0 && costs[0][ty][tx] <= tc)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[0][ty][tx] = tc;\n\t\t\t\t\tfor (int lx = -3; lx <= -1; lx++)\n\t\t\t\t\t\tfor (int ly = -3 - lx; ly <= 3 + lx; ly++) {\n\t\t\t\t\t\t\tint x = tx + lx;\n\t\t\t\t\t\t\tint y = ty + ly;\n\t\t\t\t\t\t\tif (x >= 0 && x < w && y >= 0 && y < h\n\t\t\t\t\t\t\t\t\t&& cliff[y][x] >= 0)\n\t\t\t\t\t\t\t\tqueue.add(new Node(x, y, tc + cliff[y][x], 'L'));\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (costs[1][ty][tx] >= 0 && costs[1][ty][tx] <= tc)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcosts[1][ty][tx] = tc;\n\t\t\t\t\tfor (int rx = 1; rx <= 3; rx++)\n\t\t\t\t\t\tfor (int ry = -3 + rx; ry <= 3 - rx; ry++) {\n\t\t\t\t\t\t\tint x = tx + rx;\n\t\t\t\t\t\t\tint y = ty + ry;\n\t\t\t\t\t\t\tif (x >= 0 && x < w && y >= 0 && y < h\n\t\t\t\t\t\t\t\t\t&& cliff[y][x] >= 0)\n\t\t\t\t\t\t\t\tqueue.add(new Node(x, y, tc + cliff[y][x], 'R'));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint result = -1;\n\t\t\tfor (int i : gy)\n\t\t\t\tfor (int j : gx)\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tif (result == -1)\n\t\t\t\t\t\t\tresult = costs[k][i][j];\n\t\t\t\t\t\telse if (costs[k][i][j] >= 0)\n\t\t\t\t\t\t\tresult = Math.min(result, costs[k][i][j]);\n\t\t\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint x, y, cost;\n\t\tchar foot;\n\n\t\tNode(int i, int j, int c, char f) {\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t\tcost = c;\n\t\t\tfoot = f;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\tif (this.foot == anotherNode.foot)\n\t\t\t\treturn this.cost - anotherNode.cost;\n\t\t\treturn this.foot - anotherNode.foot;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tmemo = new int[h][w][h][w][2];\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tArrays.fill(memo[i][j][k][l], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(lx >= rx || Math.abs(lx - rx) + Math.abs(ly - ry) > 3) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new int[60][30][60][30][2];\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][0] =  INF;\n\t\t\t\t\t\t\tmemo[i][j][k][l][1] =  INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\t//System.gc();\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new int[60][30][60][30][2];\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][0] =  INF;\n\t\t\t\t\t\t\tmemo[i][j][k][l][1] =  INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint map[][];\n\tint w, h;\n\tLinkedList<P> s;\n\tLinkedList<P> t;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h)==0) break;\n\t\t\tmap = new int[h][w];\n\t\t\ts = new LinkedList<P>();\n\t\t\tt = new LinkedList<P>();\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif( c == 'S' ) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\ts.add(new P(j, i));\n\t\t\t\t}\n\t\t\t\telse if( c == 'T' ) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tt.add(new P(j, i));\n\t\t\t\t}\n\t\t\t\telse if(c == 'X' )map[i][j] = -1;\n\t\t\t\telse map[i][j] = c - '0';\n\t\t\t}\n\t\t\tSystem.out.println(bfs());\n\t\t}\n\t}\n\t\n\tint bfs() {\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new Comp());\n\t\tfor(P p: s) {\n\t\t\tque.add(new Pair(p, false, 0));\n\t\t\tque.add(new Pair(p, true, 0));\n\t\t}\n\t\tTreeSet<Pair> isVisited = new TreeSet<Pair>();\n\t\tfor(;!que.isEmpty();) {\n\t\t\tPair now = que.remove();\n\t\t\tP p = now.p;\n\t\t\tif(isGoal(p)) return now.t;\n\t\t\tif(isVisited.contains(now))continue;\n\t\t\tisVisited.add(now);\n\t\t\tfor(int i=1;i<=3;i++) {\n\t\t\t\tfor(int dy=-(3-i);dy<=(3-i);dy++) {\n\t\t\t\t\tint dx = now.left? i:-i;\n\t\t\t\t\tif(canMove(p.x+dx, p.y+dy)) {\n\t\t\t\t\t\tque.add(new Pair(new P(p.x+dx, p.y+dy),\n\t\t\t\t\t\t\t\t!now.left, \n\t\t\t\t\t\t\t\tnow.t + map[p.y+dy][p.x+dx]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tboolean isGoal(P p) {\n\t\tfor(P pos: t) \n\t\t\tif(p.x == pos.x && p.y == pos.y) return true;\n\t\treturn false;\n\t}\n\t\n\tboolean canMove(int x, int y) {\n\t\treturn 0 <= x && 0 <= y && x < w && y < h && map[y][x] >= 0 ;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tclass Pair implements Comparable<Pair>{\n\t\tP p;\n\t\tboolean left;\n\t\tint t;\n\t\tPair(P p, boolean left, int t) {\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t\tthis.left = left;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\treturn (p.y-o.p.y)*60+(p.x-o.p.x)*2+(left? 1:0);\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tPair pp = (Pair) o;\n\t\t\treturn left&pp.left && p.x == pp.p.x && p.y == pp.p.y;\n\t\t}\n\t}\n\t\n\tclass Comp implements Comparator<Pair> {\n\t\t\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tPair p1 = (Pair) o1;\n\t\t\tPair p2 = (Pair) o2;\n\t\t\treturn p1.t-p2.t;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new int[60][30][60][30][2];\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][0] =  INF;\n\t\t\t\t\t\t\tmemo[i][j][k][l][1] =  INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\treturn p.time;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\treturn p.time;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().D();\n\t}\n\t\n\tint[] rx={1,1,2,1,2,3,1,2,1}, fy={-2,-1,-1,0,0,0,1,1,2};\n\tint[] lx={-1,-1,-2,-1,-2,-3,-1,-2,-1};\n\tvoid D(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][][] close=new int[W][H][2];\n\t\t\tPriorityQueue<D> open=new PriorityQueue<D>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tchar temp=sc.next().charAt(0);\n\t\t\t\t\tc[x][y]=temp;\n\t\t\t\t\tif(temp=='S'){\n\t\t\t\t\t\topen.add(new D(x,y,0,0));\n\t\t\t\t\t\topen.add(new D(x,y,0,1));\n\t\t\t\t\t\tclose[x][y][0]=-1;\n\t\t\t\t\t\tclose[x][y][1]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tD now=open.poll();\n\t\t\t\t//out.println(now.x+\" \"+now.y);\n\t\t\t\tint[] fx=(now.f==0? rx: lx);\n\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\tint xx=now.x+fx[i], yy=now.y+fy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='X')\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='T'){\n\t\t\t\t\t\tans=(ans<0? now.c: min(ans,now.c));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c+Character.digit(c[xx][yy],10)>=close[xx][yy][1-now.f] && close[xx][yy][1-now.f]!=0)\tcontinue;\n\t\t\t\t\topen.add(new D(xx,yy,now.c+Character.digit(c[xx][yy],10),now.f==0?1:0));\n\t\t\t\t\tclose[xx][yy][1-now.f]=now.c+Character.digit(c[xx][yy],10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass D implements Comparable<D>{\n\t\tint x,y,c,f;\n\t\tD(int x,int y,int c,int f){\n\t\t\tthis.x=x;\tthis.y=y;\tthis.c=c;\tthis.f=f;\n\t\t}\n\t\t@Override public int compareTo(D arg0) {\n\t\t\tif(this.c<c)\treturn -1;\n\t\t\tif(this.c>c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\tvoid B(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(), M=sc.nextInt();\n\t\t\tif((N|M)==0)break;\n\t\t\tint r=sc.nextInt();\n\t\t\tArrayList<C>[] list=new ArrayList[M];\n\t\t\tfor(int i=0; i<M; i++)\tlist[i]=new ArrayList<C>();\n\t\t\tfor(int i=0; i<r; i++){\n\t\t\t\tint time=sc.nextInt(), pc=sc.nextInt(), st=sc.nextInt()-1, k=sc.nextInt();\n\t\t\t\tArrayList<C> ar=list[st];\n\t\t\t\tif(k==1){\n\t\t\t\t\tif(ar.size()==0)\tar.add(new C(time,1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\t\tC temp=ar.get(j);\n\t\t\t\t\t\t\tif(temp.s<=time && time<=temp.e){\n\t\t\t\t\t\t\t\ttemp.count++;\n\t\t\t\t\t\t\t\tar.set(j, temp);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//out.println(\"R\"+j);\n\t\t\t\t\t\t\t\tar.add(new C(time,1));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist[st]=ar;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\t\tC temp=ar.get(j);\n\t\t\t\t\t\ttemp.count--;\n\t\t\t\t\t\tif(temp.count==0){\n\t\t\t\t\t\t\ttemp.e=time;\n\t\t\t\t\t\t\ttemp.count=-1;\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(temp.count>0){\n\t\t\t\t\t\t\tar.set(j,temp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//out.println(\"K\"+k+\" \")\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t//for(int i=0; i<M; i++)\tout.println(list[i]);\n\t\t\t\n\t\t\tint Q=sc.nextInt();\n\t\t\tfor(int i=0; i<Q; i++){\n\t\t\t\tint S=sc.nextInt(), E=sc.nextInt(), ST=sc.nextInt()-1;\n\t\t\t\tArrayList<C> ar=list[ST];\n\t\t\t\tint ans=0;\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tC temp2=ar.get(j);\n\t\t\t\t\tC temp=new C(temp2.s,temp2.e,temp2.count);\n\t\t\t\t\tif(temp.s<=S && S<=temp.e)\ttemp.s=S;\n\t\t\t\t\tif(temp.s<=E && E<=temp.e)\ttemp.e=E;\n\t\t\t\t\tif(S<=temp.s && temp.e<=E)\tans+=temp.e-temp.s;\n\t\t\t\t\t//out.println(\"ANS\"+ans+\"\"+temp.s+\" E\"+temp.e);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tclass C{\n\t\tint s,e,count;\n\t\tC(int s,int count){\n\t\t\tthis.s=s;\tthis.e=Integer.MAX_VALUE;\tthis.count=count;\n\t\t}\n\t\tC(int s,int e,int count){\n\t\t\tthis.s=s;\tthis.e=e;\tthis.count=count;\n\t\t}\n\t\t@Override public String toString(){\n\t\t\treturn \"S\"+s+\" E\"+e+\" C\"+count;\n\t\t}\n\t}\n\t*/\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint w, h;\n\tchar s[][];\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\ts = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = sc.next().charAt(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\n\t\t\tint dx[][] = new int[2][9];\n\t\t\tint dy[][] = new int[2][9];\n\t\t\tdx[0] = new int[] { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n\t\t\tdy[0] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\tdx[1] = new int[] { -1, -1, -2, -1, -2, -3, -1, -2, -1 };\n\t\t\tdy[1] = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tif (s[h - 1][k] == 'S') {\n\t\t\t\t\tQueue<Node> q = new PriorityQueue<Node>(w * h * 2,\n\t\t\t\t\t\t\tnew Comparator<Node>() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic int compare(Node o1, Node o2) {\n\t\t\t\t\t\t\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\t\t\t\t\t\t\treturn o1.t - o2.t;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\tint d[][][] = new int[2][w][h];\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\t\tArrays.fill(d[i][j], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td[0][k][h - 1] = 0;\n\t\t\t\t\td[1][k][h - 1] = 0;\n\t\t\t\t\tq.add(new Node(k, h - 1, 0, 0));\n\t\t\t\t\tq.add(new Node(k, h - 1, 1, 0));\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tNode n = q.poll();\n\t\t\t\t\t\tint x = n.x;\n\t\t\t\t\t\tint y = n.y;\n\t\t\t\t\t\tint t = n.t;\n\t\t\t\t\t\tint leg = n.leg;\n\t\t\t\t\t\tif (d[leg][x][y] < t)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\t\t\tint nx = x + dx[leg][i];\n\t\t\t\t\t\t\tint ny = y + dy[leg][i];\n\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= w || ny >= h\n\t\t\t\t\t\t\t\t\t|| s[ny][nx] == 'X')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tint nt = 0;\n\t\t\t\t\t\t\tif (s[ny][nx] >= '1' && s[ny][nx] <= '9') {\n\t\t\t\t\t\t\t\tnt = s[ny][nx] - '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (d[leg ^ 1][nx][ny] > d[leg][x][y] + nt) {\n\t\t\t\t\t\t\t\td[leg ^ 1][nx][ny] = d[leg][x][y] + nt;\n\t\t\t\t\t\t\t\tq.add(new Node(nx, ny, leg ^ 1, nt));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\t\tif (s[0][i] == 'T')\n\t\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\t\tans = Math.min(ans, d[j][i][0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans != INF ? ans : -1);\n\t\t}\n\t}\n}\n\nclass Node {\n\tint x;\n\tint y;\n\tint leg;\n\tint t;\n\n\tNode(int x, int y, int leg, int t) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.leg = leg;\n\t\tthis.t = t;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n//\tpublic static int[][][] cost;\n\tpublic static int[][] dx = {\n\t\t{1, 1, 2, 1, 2, 3, 1, 2, 1},\n\t\t{-1, -1, -2, -1, -2, -3, -1, -2, -1},\n\t};\n\tpublic static int[][] dy = {\n\t\t{-2, -1, -1, 0, 0, 0, 1, 1, 2},\n\t\t{-2, -1, -1, 0, 0, 0, 1, 1, 2}\n\t};\n\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tfinal int INF = (int)1e8;\n\t\twhile(true){\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tQueue<Pos> slist = new LinkedList<Pos>();\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmap[i][j] = in.next().charAt(0);\n\t\t\t\t\tif(map[i][j] == 'S'){\n\t\t\t\t\t\tslist.add(new Pos(i*w+j, j, i, 0, 0));\n\t\t\t\t\t\tslist.add(new Pos(i*w+j, j, i, 1, 0));\n\t\t\t\t\t\t// state: 0:left 1:right\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcost = new int[2][h][w];\n\t\t\tBitSet[] used = new BitSet[2];\n\t\t\tused[0] = new BitSet(h*w);\n\t\t\tused[1] = new BitSet(h*w);\n\t\t\tint res = INF;\n\t\t\twhile(!slist.isEmpty()){\n\t\t\t\tPos start = slist.poll();\n\t\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\t\tqu.add(start);\n\t\t\t\tused[0].clear();\n\t\t\t\tused[1].clear();\n\t\t\t\tout: while(!qu.isEmpty()){\n\t\t\t\t\tPos p = qu.poll();\n\t\t\t\t\tif(used[p.state].get(p.id)) continue;\n\t\t\t\t\tused[p.state].set(p.id);\n\t\t\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\t\t\tint nx = p.x + dx[p.state][i];\n\t\t\t\t\t\tint ny = p.y + dy[p.state][i];\n\t\t\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\t\tif(map[ny][nx] == 'S' || map[ny][nx] == 'X') continue;\n\t\t\t\t\t\tif(map[ny][nx] == 'T'){\n\t\t\t\t\t\t\tres = Math.min(res, p.dist);\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint d = map[ny][nx] - '0';\n\t\t\t\t\t\tqu.add(new Pos(ny*w+nx, nx, ny, p.state==0?1:0, p.dist+d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t\tin.close();\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint id, x, y, state, dist;\n\tpublic Pos(int id, int x, int y, int state, int dist){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.id = id;\n\t\tthis.dist = dist;\n\t\tthis.state = state;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn dist - o.dist;\n//\t\treturn Main.cost[state][y][x] - Main.cost[o.state][o.y][o.x];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,min;\n\tstatic int[] leftx={-1,-1,-1,-1,-1,-2,-2,-2,-3};\n\tstatic int[] lefty={2,1,0,-1,-2,1,0,-1,0};\n\tstatic Wall[][] wall;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin=Integer.MAX_VALUE;\n\t\t\twall=new Wall[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tString s = cin.next();\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tif(s.equals(\"T\")){\n\t\t\t\t\t\ta=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"S\")){\n\t\t\t\t\t\ta=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"X\")){\n\t\t\t\t\t\ta=-3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t\twall[i][j]=new Wall(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t//System.out.print(wall[i][j].cost+\" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(wall[i][j].cost==-1){\n\t\t\t\t\t\twall[i][j].min[0]=wall[i][j].min[1]=0;\n\t\t\t\t\t\tclimb(i,j,0,0);\n\t\t\t\t\t\tclimb(i,j,1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min==Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void climb(int y,int x,int isRight,int cost){\n\t\t//System.out.println(x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3){\n\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\treturn;\n\t\t}\n\t\tif(wall[y][x].cost==-2){\n\t\t\tmin=Math.min(min, cost+2);\n\t\t\treturn;\n\t\t}\n\t\twall[y][x].min[isRight]=cost;\n\t\tint right=0;\n\t\t\n\t\tif(isRight==0){\n\t\t\tright=1;\n\t\t\tisRight=1;\n\t\t}\n\t\telse{\n\t\t\tright=-1;\n\t\t\tisRight=0;\n\t\t}\n\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\tint xx=x+leftx[i]*right;\n\t\t\tint yy=y+lefty[i]*right;\n\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclimb(yy,xx,isRight,cost+wall[yy][xx].cost);\n\n\n\t\t}\n\t}\n}\nclass Wall{\n\tint cost;\n\tint[] min;\n\tWall(int a){\n\t\tcost=a;\n\t\tmin=new int[2];\n\t\tmin[0]=min[1]=Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\nclass Main {\n\tstatic int[][][][][] memo;\n\tstatic int INF = 2 << 28;\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tmemo = new int[60][30][60][30][2];\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tString in = sc.next();\n\t\t\t\t\tmap[i][j] = in.charAt(0);\n\t\t\t\t} \n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tfor(int k = 0; k < h; k++) {\n\t\t\t\t\t\tfor(int l = 0; l < w; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][0] =  INF;\n\t\t\t\t\t\t\tmemo[i][j][k][l][1] =  INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'S') {\n\t\t\t\t\t\tint ret = start(i,j);\n\t\t\t\t\t\tans = Math.min(ans, ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans == INF) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic int start(int y, int x) {\n\t\tPriorityQueue<Data> q = new PriorityQueue<Data>();\n\t\tq.add(new Data(y,x,-1,-1,0,false));\n\t\tint ret = solv(q);\n\t\tq.clear();\n\t\tq.add(new Data(-1,-1,y,x,0,true));\n\t\tret = Math.min(solv(q),ret);\n\t\tq.clear();\n\t\treturn ret;\n\t}\n\tstatic int[] vx = {1,1,2,1,2,3, 1, 2, 1};\n\tstatic int[] vy = {2,1,1,0,0,0,-1,-1,-2};\n\tstatic int solv(PriorityQueue<Data> q) {\n\t\tint ret = INF;\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\t\n\t\t\tif(p.ly == -1 || p.ry == -1) {\n\t\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\t\tif(p.nextL) {\n\t\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\t\tif(!check(ty,tx,p.ry,p.rx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(!p.nextL) {\n\t\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\t\tif(!check(p.ly, p.lx, ty,tx)) continue;\n\t\t\t\t\t\tint time = p.time;\n\t\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] <= p.time) continue;\n\t\t\tmemo[p.ly][p.lx][p.ry][p.rx][p.nextL?0:1] = p.time;\n\t\t\tif(map[p.ly][p.lx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[p.ry][p.rx] == 'T') {\n\t\t\t\tret = Math.min(ret, p.time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < vx.length; i++) {\n\t\t\t\tif(p.nextL) {\n\t\t\t\t\tint tx = p.rx - vx[i];\n\t\t\t\t\tint ty = p.ry + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[ty][tx][p.ry][p.rx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(ty,tx,p.ry,p.rx,time,!p.nextL));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(!p.nextL) {\n\t\t\t\t\tint tx = p.lx + vx[i];\n\t\t\t\t\tint ty = p.ly + vy[i];\n\t\t\t\t\tif(!rcheck(ty,tx) || map[ty][tx] == 'X') continue;\n\t\t\t\t\tint time = p.time;\n\t\t\t\t\tif(map[ty][tx] != 'T' && map[ty][tx] != 'S') {\n\t\t\t\t\t\ttime += map[ty][tx] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif(memo[p.ly][p.lx][ty][tx][(!p.nextL)?0:1] <= time) continue;\n\t\t\t\t\tq.add(new Data(p.ly,p.lx,ty,tx,time,!p.nextL));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\tstatic boolean check(int ly, int lx, int ry, int rx) {\n\t\tif(!rcheck(ly,lx)) return false;\n\t\tif(!rcheck(ry,rx)) return false;\n\t\tif(map[ly][lx] == 'X') return false;\n\t\tif(map[ry][rx] == 'X') return false;\n\t\treturn true;\n\t\t\n\t}\n\tstatic boolean rcheck(int ty, int tx) {\n\t\tif(tx < 0 || ty < 0 || ty >= map.length || tx >= map[ty].length) return false;\n\t\treturn true;\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint ly;\n\t\tint lx;\n\t\tint ry;\n\t\tint rx;\n\t\tint time;\n\t\tboolean nextL;\n\t\tData(int a, int b, int c, int d, int e, boolean f) {\n\t\t\tly = a;\n\t\t\tlx = b;\n\t\t\try = c;\n\t\t\trx = d;\n\t\t\ttime = e;\n\t\t\tnextL = f;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t}\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Reader in = new Reader();\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] directedGraph(int n, int[] s, int[] t, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : s) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<s.length; i++) {\n\t\t\tint from = s[i];\n\t\t\tint to = t[i];\n\n\t\t\tg[from][--cnt[from]][0] = to;\n\t\t\tg[from][cnt[from]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic int[] dijkstra(int[][][] g, int source) {\n\t\tint n = g.length;\n\n\t\tfinal int[] d = new int[n];\n\t\tArrays.fill(d, 1<<29);\n\t\td[source] = 0;\n\n\t\tTreeSet<Integer> pQ = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (d[a] != d[b]) return d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\tpQ.add(source);\n\n\t\twhile (!pQ.isEmpty()) {\n\t\t\tint cur = pQ.pollFirst();\n\n\t\t\tfor (int i=0; i<g[cur].length; i++) {\n\t\t\t\tint next = g[cur][i][0];\n\t\t\t\tint dist = d[cur] + g[cur][i][1];\n\t\t\t\tif (dist < d[next]) {\n\t\t\t\t\tpQ.remove(next);\n\t\t\t\t\td[next] = dist;\n\t\t\t\t\tpQ.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\n\tstatic boolean solve(){\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tchar[][] table = new char[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\ttable[i][j] = in.nextChar();\n\t\t\t}\n\t\t}\n\n\t\tint[] rx = {1, 1, 1, 2, 2, 3, 1, 1, 2};\n\t\tint[] ry = {0, 1, 2, 1, 0, 0, -1, -2, -1};\n\n\t\tint[] lx = {-1, -1, -1, -2, -2, -3, -1, -1, -2};\n\t\tint[] ly = {0, 1, 2, 1, 0, 0, -1, -2, -1};\n\n\t\tArrayList<Integer> s = new ArrayList<>();\n\t\tArrayList<Integer> t = new ArrayList<>();\n\t\tArrayList<Integer> cost = new ArrayList<>();\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (table[i][j] == 'X') continue;\n\n\t\t\t\t// r\n\t\t\t\tfor (int k=0; k<9; k++) {\n\t\t\t\t\tint ni = i + ry[k];\n\t\t\t\t\tint nj = j + rx[k];\n\t\t\t\t\tif (ni < 0 || nj < 0 || h <= ni || w <= nj) continue;\n\t\t\t\t\tif (table[ni][nj] == 'X') continue;\n\t\t\t\t\ts.add(i*w+j);\n\t\t\t\t\tt.add(ni*w+nj + h*w);\n\t\t\t\t\tcost.add(table[ni][nj] == 'T' ? 0 : table[ni][nj] - '0');\n\t\t\t\t}\n\n\t\t\t\t// l\n\t\t\t\tfor (int k=0; k<9; k++) {\n\t\t\t\t\tint ni = i + ly[k];\n\t\t\t\t\tint nj = j + lx[k];\n\t\t\t\t\tif (ni < 0 || nj < 0 || h <= ni || w <= nj) continue;\n\t\t\t\t\tif (table[ni][nj] == 'X') continue;\n\t\t\t\t\ts.add(i*w+j + h*w);\n\t\t\t\t\tt.add(ni*w+nj);\n\t\t\t\t\tcost.add((table[ni][nj] == 'T' ||table[ni][nj] == 'S') ? 0 : (table[ni][nj] - '0'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint start = h*w*2;\n\t\tint goal = start + 1;\n\n\t\tfor (int j=0; j<w; j++) {\n\t\t\tif (table[h-1][j] == 'S') {\n\t\t\t\ts.add(start);\n\t\t\t\tt.add((h-1)*w+j);\n\t\t\t\tcost.add(0);\n\n\t\t\t\ts.add(start);\n\t\t\t\tt.add((h-1)*w+j + h*w);\n\t\t\t\tcost.add(0);\n\t\t\t}\n\t\t}\n\n\t\tfor (int j=0; j<w; j++) {\n\t\t\tif (table[0][j] == 'T') {\n\t\t\t\ts.add(0*w+j);\n\t\t\t\tt.add(goal);\n\t\t\t\tcost.add(0);\n\n\t\t\t\ts.add(0*w+j + h*w);\n\t\t\t\tt.add(goal);\n\t\t\t\tcost.add(0);\n\t\t\t}\n\t\t}\n\n\t\tint m = s.size();\n\t\tint[] ss = new int[m];\n\t\tint[] tt = new int[m];\n\t\tint[] cc = new int[m];\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tss[i] = s.get(i);\n\t\t\ttt[i] = t.get(i);\n\t\t\tcc[i] = cost.get(i);\n\t\t}\n\n\t\t// dump(ss);\n\t\t// dump(tt);\n\t\t// dump(cc);\n\n\t\tint[][][] g = directedGraph(goal+1, ss, tt, cc);\n\n\t\t// dump(g);\n\n\t\tint[] d = dijkstra(g, start);\n\n\t\tout.println(d[goal] >= 1<<29 ? -1 : d[goal]);\n\n\t\t// dump(d);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}\n\nclass Reader {\n\tprivate final InputStream in;\n\tprivate final byte[] buf = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic Reader() { this(System.in);}\n\tpublic Reader(InputStream source) { this.in = source;}\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) return true;\n\t\tptr = 0;\n\t\ttry{\n\t\t\tbuflen = in.read(buf);\n\t\t}catch (IOException e) {e.printStackTrace();}\n\t\tif (buflen <= 0) return false;\n\t\treturn true;\n\t}\n\n\tprivate int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n\tprivate boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n\tprivate void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n\tpublic boolean hasNext() {skip(); return hasNextByte();}\n\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tboolean minus = false;\n\t\tlong num = readByte();\n\n\t\tif(num == '-'){\n\t\t\tnum = 0;\n\t\t\tminus = true;\n\t\t}else if (num < '0' || '9' < num){\n\t\t\tthrow new NumberFormatException();\n\t\t}else{\n\t\t\tnum -= '0';\n\t\t}\n\n\t\twhile(true){\n\t\t\tint b = readByte();\n\t\t\tif('0' <= b && b <= '9')\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\telse if(b == -1 || !isPrintableChar(b))\n\t\t\t\treturn minus ? -num : num;\n\t\t\telse\n\t\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\tlong num = nextLong();\n\t\tif (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int)num;\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic char nextChar() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\treturn (char)readByte();\n\t}\n\n\tpublic String nextLine() {\n\t\twhile (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n\t\tif (!hasNextByte()) throw new NoSuchElementException();\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b != '\\n' && b != '\\r' && b != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] res = new int[n];\n\t\tfor (int i=0; i<n; i++) res[i] = nextInt();\n\t\treturn res;\n\t}\n\n\tpublic char[] nextCharArray(int n) {\n\t\tchar[] res = new char[n];\n\t\tfor (int i=0; i<n; i++) res[i] = nextChar();\n\t\treturn res;\n\t}\n\n\tpublic void close() {try{ in.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Cliff Climbing\npublic class Main{\n\n\tstatic int[][][] dist;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] leftMove = {{-2,-1},{-1,-1},{0,-1},{1,-1},{2,-1},{-1,-2},{0,-2},{1,-2},{0,-3}};\n\t\tint[][] rightMove = {{-2,1},{-1,1},{0,1},{1,1},{2,1},{-1,2},{0,2},{1,2},{0,3}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.next().charAt(0);\n\t\t\tdist = new int[h][w][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<2;k++)dist[i][j][k]=Integer.MAX_VALUE;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]][o1[2]] - dist[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tdist[i][j][0] = 0;\n\t\t\t\t\t\tdist[i][j][1] = 0;\n\t\t\t\t\t\tq.add(new int[]{i, j, 0});\n\t\t\t\t\t\tq.add(new int[]{i, j, 1});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tint foot = a[2];\n\t\t\t\tif(m[i][j]=='T'){\n\t\t\t\t\tans = dist[i][j][foot];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//next movement is right side\n\t\t\t\tif(foot==0){\n\t\t\t\t\tfor(int k=0;k<9;k++){\n\t\t\t\t\t\tint ni = i+rightMove[k][0];\n\t\t\t\t\t\tint nj = j+rightMove[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='X'){\n\t\t\t\t\t\t\tint v = dist[i][j][foot] + (Character.isDigit(m[ni][nj])?(int)(m[ni][nj]-'0'):0);\n\t\t\t\t\t\t\tif(v < dist[ni][nj][1]){\n\t\t\t\t\t\t\t\tdist[ni][nj][1] = v;\n\t\t\t\t\t\t\t\tq.add(new int[]{ni, nj, 1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=0;k<9;k++){\n\t\t\t\t\t\tint ni = i+leftMove[k][0];\n\t\t\t\t\t\tint nj = j+leftMove[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='X'){\n\t\t\t\t\t\t\tint v = dist[i][j][foot] + (Character.isDigit(m[ni][nj])?(int)(m[ni][nj]-'0'):0);\n\t\t\t\t\t\t\tif(v < dist[ni][nj][0]){\n\t\t\t\t\t\t\t\tdist[ni][nj][0] = v;\n\t\t\t\t\t\t\t\tq.add(new int[]{ni, nj, 0});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tstatic final int INF = 1001001001;\n\tstatic int[][][] memo = new int[2][64][32];\n\n\tstatic class State implements Comparable<State> {\n\t\tint side;\n\t\tint h, w;\n\t\tint cost;\n\t\tpublic State(int side, int h, int w, int cost) {\n\t\t\tthis.side = side;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\tint ref() {\n\t\t\treturn memo[side][h][w];\n\t\t}\n\t\tvoid memo(int v) {\n\t\t\tmemo[side][h][w] = v;\n\t\t}\n\t\tpublic int compareTo(State o) {\n\t\t\tif (cost != o.cost) return cost < o.cost ? -1 : 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint W, H;\n\tint[][] a;\n\tchar[][] s;\n\n\tvoid solve() {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tif ((W | H) == 0) return;\n\t\ta = new int[H][W];\n\t\ts = new char[H][W];\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = sc.next().toCharArray()[0];\n\t\t\t\ts[i][j] = ch;\n\t\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t\ta[i][j] = ch - '0';\n\t\t\t\t}\n\t\t\t}\n\n//\t\tfor (int i = 0; i < H; i++) tr(s[i]);\n\n\t\tfor (int i = 0; i < memo.length; i++) for (int j = 0; j < memo[0].length; j++) Arrays.fill(memo[i][j], INF);\n\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(0, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tState state = new State(1, i, j, 0);\n\t\t\t\t\t\tstate.memo(state.cost);\n\t\t\t\t\t\tpq.add(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = -1;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState cur = pq.poll();\n//\t\t\ttr(cur.h, cur.w, cur.cost);\n\t\t\tif (cur.cost != cur.ref()) continue;\n\t\t\tif (s[cur.h][cur.w] == 'T') {\n\t\t\t\tres = cur.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int di = -3; di <= 3; di++) {\n\t\t\t\tfor (int dj = -3; dj <= 3; dj++) {\n\t\t\t\t\tif (Math.abs(di) + Math.abs(dj) <= 3) {\n\t\t\t\t\t\tint nh = cur.h + di;\n\t\t\t\t\t\tint nw = cur.w + dj;\n\t\t\t\t\t\tif (0 <= nh && nh < H && 0 <= nw && nw < W) {\n\t\t\t\t\t\t\tif (s[nh][nw] != 'X') {\n\t\t\t\t\t\t\t\tif ((cur.side == 0 && cur.w < nw) ||\n\t\t\t\t\t\t\t\t\t(cur.side == 1 && cur.w > nw)) {\n\t\t\t\t\t\t\t\t\tState nxt = new State(1 - cur.side, nh, nw, cur.cost + a[nh][nw]);\n\t\t\t\t\t\t\t\t\tif (nxt.ref() > nxt.cost) {\n\t\t\t\t\t\t\t\t\t\tnxt.memo(nxt.cost);\n\t\t\t\t\t\t\t\t\t\tpq.add(nxt);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\tchar[][] map = new char[h][w];\n\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s = \"\";\n\t\t\t\tfor(int j=0;j<w;j++) s += sc.next();\n\t\t\t\tmap[i] = s.toCharArray();\n\t\t\t}\n\n\t\t\tState st = null;\n\t\t\tQueue<State> open = new PriorityQueue<State>();\n\t\t\tMap<State, State> closed = new HashMap<State, State>();\n\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(map[h-1][x] == 'S'){\n\t\t\t\t\topen.add(new State(0, new Foot(x, h-1, true)));\n\t\t\t\t\topen.add(new State(0, new Foot(x, h-1, false)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tst = open.poll();\n\t\t\t\tif(closed.get(st) != null) continue;\n\t\t\t\tclosed.put(st,st);\n\t\t\t\tif(st.ans(map)){\n\t\t\t\t\tans = st.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topen.addAll(st.nexts(map));\n\t\t\t}\n\t\t\tif(ans == Integer.MAX_VALUE) System.out.println(\"-1\");\n\t\t\telse System.out.println(ans);\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint cost;\n\tFoot foot;\n\n\tpublic State(int cost, Foot foot){\n\t\tthis.cost = cost;\n\t\tthis.foot = foot;\n\t}\n\n\tpublic ArrayList<State> nexts(char[][] map){\n\t\tArrayList<State> al = new ArrayList<State>();\n\n\t\tfor(int i=0;i<9;i++){\n\t\t\tFoot f = foot.copy();\n\t\t\tint rst = f.move(i,map);\n\n\t\t\tif(rst != -1){\n\t\t\t\tint c = cost;\n\t\t\t\tc += rst;\n\t\t\t\tal.add(new State(c,f));\n\t\t\t}\n\t\t}\n\t\treturn al;\n\t}\n\n\tpublic boolean ans(char[][] map){\n\t\treturn map[foot.p.y][foot.p.x]=='T';\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn this.foot.p.equals(st.foot.p) &&\n\t\t\tthis.foot.nextFlg==st.foot.nextFlg;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn foot.p.x + foot.p.y;\n\t}\n}\n\nclass Foot{\n\tPoint p;\n\tboolean nextFlg;\n\n\tfinal int[][] dr = new int[][]{{1,-2}, {1,-1}, {1,0}, {1,1}, {1,2},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t {2,-1}, {2,0}, {2,1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t {3,0}};\n\tfinal int[][] dl = new int[][]{{-1,-2}, {-1,-1}, {-1,0}, {-1,1}, {-1,2},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t {-2,-1}, {-2,0}, {-2,1},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t {-3,0}};\n\n\tpublic Foot(int x, int y, boolean nextFlg){\n\t\tthis.p = new Point(x,y);\n\t\tthis.nextFlg = nextFlg;\n\t}\n\n\tpublic int move(int to, char[][] map){\n\t\tint h = map.length;\n\t\tint w = map[0].length;\n\n\t\tif(nextFlg){\n\t\t\tnextFlg = !nextFlg;\n\t\t\tthis.p.translate(dl[to][0], dl[to][1]);\n\t\t}\n\t\telse{\n\t\t\tnextFlg = !nextFlg;\n\t\t\tthis.p.translate(dr[to][0], dr[to][1]);\n\t\t}\n\n\t\tif(p.x<0 || p.x>=w || p.y<0 || p.y>=h || map[p.y][p.x]=='X')\n\t\t\treturn -1;\n\t\telse if(map[p.y][p.x] == 'S' || map[p.y][p.x] == 'T')\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn map[p.y][p.x] - '0';\n\t}\n\n\tpublic Foot copy(){\n\t\tFoot cp = new Foot(p.x, p.y, nextFlg);\n\t\treturn cp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int w, h;\n  char[][] field;\n  boolean[][][] done;\n  boolean[][][] mate;\n  int[][][] memo;\n\n  int[][] ofs = {\n      // ????¶??????????????¶?????????????\n      {1, -2},\n      {1, -1},\n      {1, 0},\n      {1, 1},\n      {1, 2},\n      {2, -1},\n      {2, 0},\n      {2, 1},\n      {3, 0}\n  };\n\n  boolean isOut(int x, int y) {\n    return x < 0 || w <= x || y < 0 || h <= y;\n  }\n\n  class Foot {\n    int index, x, y;\n  }\n\n  class Node {\n    int score;\n    Foot foot;\n  }\n\n  int daikusutora(int index, int x, int y) {\n    Foot atom = new Foot();\n    atom.index = index;\n    atom.x = x;\n    atom.y = y;\n    Node btom = new Node();\n    btom.foot = atom;\n    btom.score = 0;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.score));\n    queue.add(btom);\n    done = new boolean[2][h][w];\n    int min = INF;\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      Foot foot = node.foot;\n      if (done[foot.index][foot.y][foot.x]) {\n        continue;\n      }\n      done[foot.index][foot.y][foot.x] = true;\n\n      if (foot.index == 0) {\n        for (int[] d : ofs) {\n          int nx = foot.x + d[0];\n          int ny = foot.y + d[1];\n          if (isOut(nx, ny)) {\n            continue;\n          }\n          char c = field[ny][nx];\n          if (c == 'S' || c == 'X') {\n            continue;\n          }\n          if (c == 'T') {\n            min = Math.min(min, node.score);\n            continue;\n          }\n          int v = c - '0';\n          Node next = new Node();\n          next.foot = new Foot();\n          next.foot.index = 1 - foot.index;\n          next.foot.x = nx;\n          next.foot.y = ny;\n          next.score = node.score + v;\n          queue.add(next);\n        }\n      } else {\n        for (int[] d : ofs) {\n          int nx = foot.x - d[0];\n          int ny = foot.y + d[1];\n          if (isOut(nx, ny)) {\n            continue;\n          }\n          char c = field[ny][nx];\n          if (c == 'S') {\n            continue;\n          }\n          if (c == 'T') {\n            min = Math.min(min, node.score);\n            continue;\n          }\n          int v = c - '0';\n          Node next = new Node();\n          next.foot = new Foot();\n          next.foot.index = 1 - foot.index;\n          next.foot.x = nx;\n          next.foot.y = ny;\n          next.score = node.score + v;\n          queue.add(next);\n        }\n      }\n    }\n    return min;\n  }\n\n  class Point {\n    int x, y;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      ArrayList<Point> s = new ArrayList<>();\n      field = new char[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          field[i][j] = sc.next().charAt(0);\n          if (field[i][j] == 'S') {\n            Point p = new Point();\n            p.x = j;\n            p.y = i;\n            s.add(p);\n          }\n        }\n      }\n      int min = INF;\n      for (Point p : s) {\n        min = Math.min(min, daikusutora(0, p.x, p.y));\n        min = Math.min(min, daikusutora(1, p.x, p.y));\n      }\n      System.out.println(min == INF ? -1 : min);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "// Cliff Climbing\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] cliff = new int[h][w];\n\t\t\tboolean[][] feeted = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tArrays.fill(feeted[i], false);\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\t\tif (Character.isDigit(c))\n\t\t\t\t\t\tcliff[i][j] = c - '0';\n\t\t\t\t\telse if (c == 'S') {\n\t\t\t\t\t\tcliff[i][j] = 0;\n\t\t\t\t\t\tqueue.add(new Node(j, i, 0, 'R'));\n\t\t\t\t\t\tqueue.add(new Node(j, i, 0, 'L'));\n\t\t\t\t\t} else if (c == 'T')\n\t\t\t\t\t\tcliff[i][j] = -1;\n\t\t\t\t\telse if (c == 'X')\n\t\t\t\t\t\tcliff[i][j] = Integer.MAX_VALUE / 100;\n\t\t\t\t}\n\t\t\tint result = 1;\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint tx = node.x;\n\t\t\t\tint ty = node.y;\n\t\t\t\tint tc = node.cost;\n\t\t\t\tchar tf = node.foot;\n\t\t\t\tfeeted[ty][tx] = true;\n\t\t\t\tif (cliff[ty][tx] == -1) {\n\t\t\t\t\tresult += tc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (tf == 'R') {\n\t\t\t\t\tfor (int lx = -3; lx <= -1; lx++)\n\t\t\t\t\t\tfor (int ly = -3 - lx; ly <= 3 + lx; ly++) {\n\t\t\t\t\t\t\tint x = tx + lx;\n\t\t\t\t\t\t\tint y = ty + ly;\n\t\t\t\t\t\t\tif (x >= 0 && x < w && y >= 0 && y < h\n\t\t\t\t\t\t\t\t\t&& !feeted[y][x])\n\t\t\t\t\t\t\t\tqueue.add(new Node(x, y, tc + cliff[y][x], 'L'));\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int rx = 1; rx <= 3; rx++)\n\t\t\t\t\t\tfor (int ry = -3 + rx; ry <= 3 - rx; ry++) {\n\t\t\t\t\t\t\tint x = tx + rx;\n\t\t\t\t\t\t\tint y = ty + ry;\n\t\t\t\t\t\t\tif (x >= 0 && x < w && y >= 0 && y < h\n\t\t\t\t\t\t\t\t\t&& !feeted[y][x])\n\t\t\t\t\t\t\t\tqueue.add(new Node(x, y, tc + cliff[y][x], 'R'));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result < Integer.MAX_VALUE / 100)\n\t\t\t\tSystem.out.println(result);\n\t\t\telse\n\t\t\t\tSystem.out.println(-1);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint x, y, cost;\n\t\tchar foot;\n\n\t\tNode(int i, int j, int c, char f) {\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t\tcost = c;\n\t\t\tfoot = f;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\tif (this.foot == anotherNode.foot)\n\t\t\t\treturn this.cost - anotherNode.cost;\n\t\t\treturn this.foot - anotherNode.foot;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,min;\n\tstatic int[] leftx={-1,-1,-1,-1,-1,-2,-2,-2,-3};\n\tstatic int[] lefty={2,1,0,-1,-2,1,0,-1,0};\n\tstatic Wall[][] wall;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin=Integer.MAX_VALUE;\n\t\t\twall=new Wall[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tString s = cin.next();\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tif(s.equals(\"T\")){\n\t\t\t\t\t\ta=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"S\")){\n\t\t\t\t\t\ta=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.equals(\"X\")){\n\t\t\t\t\t\ta=-3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t\twall[i][j]=new Wall(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t//System.out.print(wall[i][j].cost+\" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(wall[i][j].cost==-1){\n\t\t\t\t\t\twall[i][j].min[0]=wall[i][j].min[1]=0;\n\t\t\t\t\t\tclimb(i,j,0,0);\n\t\t\t\t\t\tclimb(i,j,1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min==Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void climb(int y,int x,int isRight,int cost){\n\t\t//System.out.println(x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\tif(cost>wall[y][x].min[isRight]||wall[y][x].cost==-3||min<cost){\n\t\t\t//System.out.println(\"    \"+x+\" \" +y+\" \" +isRight+\" \"+cost);\n\t\t\treturn;\n\t\t}\n\t\tif(wall[y][x].cost==-2){\n\t\t\tmin=Math.min(min, cost+2);\n\t\t\treturn;\n\t\t}\n\t\twall[y][x].min[isRight]=cost;\n\t\tint right=0;\n\t\t\n\t\tif(isRight==0){\n\t\t\tright=1;\n\t\t\tisRight=1;\n\t\t}\n\t\telse{\n\t\t\tright=-1;\n\t\t\tisRight=0;\n\t\t}\n\t\tfor(int i = 0;i<leftx.length;i++){\n\t\t\tint xx=x+leftx[i]*right;\n\t\t\tint yy=y+lefty[i]*right;\n\t\t\tif(xx<0||xx>=w||yy<0||yy>=h){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(wall[yy][xx].cost==-3||wall[yy][xx].cost==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclimb(yy,xx,isRight,cost+wall[yy][xx].cost);\n\n\n\t\t}\n\t}\n}\nclass Wall{\n\tint cost;\n\tint[] min;\n\tWall(int a){\n\t\tcost=a;\n\t\tmin=new int[2];\n\t\tmin[0]=min[1]=Integer.MAX_VALUE;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int w, h;\n  char[][] field;\n  boolean[][][] done;\n  boolean[][][] mate;\n  int[][][] memo;\n\n  int[][] ofs = {\n      // ????¶??????????????¶?????????????\n      {1, -2},\n      {1, -1},\n      {1, 0},\n      {1, 1},\n      {1, 2},\n      {2, -1},\n      {2, 0},\n      {2, 1},\n      {3, 0}\n  };\n\n  boolean isOut(int x, int y) {\n    return x < 0 || w <= x || y < 0 || h <= y;\n  }\n\n  class Foot {\n    int index, x, y;\n  }\n\n  class Node {\n    int score;\n    Foot foot;\n  }\n\n  int daikusutora(int index, int x, int y) {\n    Foot atom = new Foot();\n    atom.index = index;\n    atom.x = x;\n    atom.y = y;\n    Node btom = new Node();\n    btom.foot = atom;\n    btom.score = 0;\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.score));\n    queue.add(btom);\n    done = new boolean[2][h][w];\n    int min = INF;\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      Foot foot = node.foot;\n      if (done[foot.index][foot.y][foot.x]) {\n        continue;\n      }\n      done[foot.index][foot.y][foot.x] = true;\n\n      if (foot.index == 0) {\n        for (int[] d : ofs) {\n          int nx = foot.x + d[0];\n          int ny = foot.y + d[1];\n          if (isOut(nx, ny)) {\n            continue;\n          }\n          char c = field[ny][nx];\n          if (c == 'S' || c == 'X') {\n            continue;\n          }\n          if (c == 'T') {\n            min = Math.min(min, node.score);\n            continue;\n          }\n          int v = c - '0';\n          Node next = new Node();\n          next.foot = new Foot();\n          next.foot.index = 1 - foot.index;\n          next.foot.x = nx;\n          next.foot.y = ny;\n          next.score = node.score + v;\n          queue.add(next);\n        }\n      } else {\n        for (int[] d : ofs) {\n          int nx = foot.x - d[0];\n          int ny = foot.y + d[1];\n          if (isOut(nx, ny)) {\n            continue;\n          }\n          char c = field[ny][nx];\n          if (c == 'S' || c == 'X') {\n            continue;\n          }\n          if (c == 'T') {\n            min = Math.min(min, node.score);\n            continue;\n          }\n          int v = c - '0';\n          Node next = new Node();\n          next.foot = new Foot();\n          next.foot.index = 1 - foot.index;\n          next.foot.x = nx;\n          next.foot.y = ny;\n          next.score = node.score + v;\n          queue.add(next);\n        }\n      }\n    }\n    return min;\n  }\n\n  class Point {\n    int x, y;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      ArrayList<Point> s = new ArrayList<>();\n      field = new char[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          field[i][j] = sc.next().charAt(0);\n          if (field[i][j] == 'S') {\n            Point p = new Point();\n            p.x = j;\n            p.y = i;\n            s.add(p);\n          }\n        }\n      }\n      int min = INF;\n      for (Point p : s) {\n        min = Math.min(min, daikusutora(0, p.x, p.y));\n        min = Math.min(min, daikusutora(1, p.x, p.y));\n      }\n      System.out.println(min == INF ? -1 : min);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tString line;\n\t\t\tchar[][] map = new char[w][h];\n\t\t\tNodeList[][] rightnodemap = new NodeList[w][h];\n\t\t\tNodeList[][] leftnodemap = new NodeList[w][h];\n\t\t\tint[][] leftMove = {{-2,-1},{-1,-1},{-1,-2},{-1,0},{-2,0},{-3,0},{-2,1},{-1,1},{-1,2}};\n\t\t\tint[][] rightMove = {{2,1},{1,1},{1,2},{1,0},{2,0},{3,0},{1,-1},{1,-2},{2,-1}};\n\t\t\tPriorityQueue<NodeList> queue = new PriorityQueue<NodeList>(w * h, new Comparator<NodeList>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(NodeList o1, NodeList o2) {\n\t\t\t\t\treturn o1.count - o2.count;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tline = sc.nextLine().replaceAll(\" \", \"\");\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[j][i] = line.charAt(j);\n\t\t\t\t\tif(map[j][i] == 'S'){\n\t\t\t\t\t\trightnodemap[j][i] = new NodeList(0, 0, 'r', j, i);\n\t\t\t\t\t\tqueue.offer(rightnodemap[j][i]);\n\t\t\t\t\t\tleftnodemap[j][i] = new NodeList(0, 0, 'l', j, i);\n\t\t\t\t\t\tqueue.offer(leftnodemap[j][i]);\n\t\t\t\t\t}else if(map[j][i] == 'T'){\n\t\t\t\t\t\trightnodemap[j][i] = new NodeList(Integer.MAX_VALUE, 0, 'r', j, i);\n\t\t\t\t\t\tleftnodemap[j][i] = new NodeList(Integer.MAX_VALUE, 0, 'l', j, i);\n\t\t\t\t\t\t\n\t\t\t\t\t}else if(map[j][i] == 'X'){\n\t\t\t\t\t\trightnodemap[j][i] = new NodeList(Integer.MAX_VALUE, -1, 'r', j, i);\n\t\t\t\t\t\tleftnodemap[j][i] = new NodeList(Integer.MAX_VALUE, -1, 'l', j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trightnodemap[j][i] = new NodeList(Integer.MAX_VALUE, new Integer(line.charAt(j)) - 48, 'r', j, i);\n\t\t\t\t\t\tleftnodemap[j][i] = new NodeList(Integer.MAX_VALUE, new Integer(line.charAt(j)) - 48, 'l', j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size;\n\t\t\tint count;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tchar nowfoot;\n\t\t\twhile(true){\n\t\t\t\tsize = queue.size();\n\t\t\t\tif(size == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tcount = queue.peek().count;\n\t\t\t\t\tnowfoot = queue.peek().nowfoot;\n\t\t\t\t\tx = queue.peek().x;\n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tif(nowfoot == 'r'){\n\t\t\t\t\t\tfor(int j = 0; j < leftMove.length; j++){\n\t\t\t\t\t\t\tnextx = x + leftMove[j][0];\n\t\t\t\t\t\t\tnexty = y + leftMove[j][1];\n\t\t\t\t\t\t\tif(nextx >= 0 && nextx <= w - 1 && nexty >= 0 && nexty <= h-1 && leftnodemap[nextx][nexty].cost != -1\n\t\t\t\t\t\t\t\t\t&& count + leftnodemap[nextx][nexty].cost < leftnodemap[nextx][nexty].count){\n\t\t\t\t\t\t\t\tleftnodemap[nextx][nexty].changeCount(count + leftnodemap[nextx][nexty].cost);\n\t\t\t\t\t\t\t\tqueue.offer(leftnodemap[nextx][nexty]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(nowfoot == 'l'){\n\t\t\t\t\t\tfor(int j = 0; j < rightMove.length; j++){\n\t\t\t\t\t\t\tnextx = x + rightMove[j][0];\n\t\t\t\t\t\t\tnexty = y + rightMove[j][1];\n\t\t\t\t\t\t\tif(nextx >= 0 && nextx <= w - 1 && nexty >= 0 && nexty <= h-1 && rightnodemap[nextx][nexty].cost != -1\n\t\t\t\t\t\t\t\t\t&& count + rightnodemap[nextx][nexty].cost < rightnodemap[nextx][nexty].count){\n\t\t\t\t\t\t\t\trightnodemap[nextx][nexty].changeCount(count + rightnodemap[nextx][nexty].cost);\n\t\t\t\t\t\t\t\tqueue.offer(rightnodemap[nextx][nexty]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[j][i] == 'T'){\n\t\t\t\t\t\tif(rightnodemap[j][i].count < sum){\n\t\t\t\t\t\t\tsum = rightnodemap[j][i].count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(leftnodemap[j][i].count < sum){\n\t\t\t\t\t\t\tsum = leftnodemap[j][i].count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum == Integer.MAX_VALUE){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\n}\n\nclass NodeList{\n\t\n\tint x;\n\tint y;\n\tint cost;\n\tint count;\n\tchar nowfoot;\n\t\n\tpublic NodeList(int count, int cost, char nowfoot,int x, int y){\n\t\tthis.cost = cost;\n\t\tthis.count = count;\n\t\tthis.nowfoot = nowfoot;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t\n\tpublic void changeCount(int count){\n\t\tthis.count = count;\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t// ??§?¨????????´?????????????????????????\n\tclass Pair {\n\t\tint cost, y, x, lr;\n\t\tPair(int c, int y, int x, int lr) {\n\t\t\tthis.cost = c;\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.lr = lr;\n\t\t}\n\t}\n\t\n\tstatic final int INF = Integer.MAX_VALUE;\n\tstatic final int LEFT  = 0;\n\tstatic final int RIGHT = 1;\n\t\n\tstatic char[][] map;\n\tstatic int w;\n\tstatic int h;\n\n\tstatic int[] right_y = {-2, -1, 0, 1, 2, -1, 0, 1, 0};\n\tstatic int[] right_x = { 1,  1, 1, 1, 1,  2, 2, 2, 3};\n\tstatic int[] left_y =  { 0, -1,  0,  1, -2, -1,  0,  1,  2};\n\tstatic int[] left_x =  {-3, -2, -2, -2, -1, -1, -1, -1, -1};\n\t\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif (w + h == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tmap[i][j] = scan.next().charAt(0);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tint solve() {\n\t\t// ??????????????¨?????????\n\t\tint[][][] dp = new int[h][w][2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] != 'S') {\n\t\t\t\t\tdp[i][j][0] = INF;\n\t\t\t\t\tdp[i][j][1] = INF;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j][0] = 0;\n\t\t\t\t\tdp[i][j][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/** ????????\\??£?????????????¢????\n\t\tSystem.out.printf(\"w = %d, h = %d\\n\", w, h);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (dp[i][j][0] == INF) {\n\t\t\t\t\tSystem.out.print(\"F \");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(dp[i][j][0] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\t\n\t\tQueue<Pair> que = new PriorityQueue<Pair>(new Comparator<Pair>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn o1.cost - o2.cost;\n\t\t\t}\n\t\t});\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (map[h - 1][j] == 'S') {\n\t\t\t\tque.add(new Pair(0, h - 1,j, LEFT));\n\t\t\t\tque.add(new Pair(0, h - 1,j, RIGHT));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!que.isEmpty()) {\n\t\t\tPair pair = que.poll();\n\t\t\tif (map[pair.y][pair.x] == 'T')\n\t\t\t\treturn pair.cost;\n\t\t\t\n//\t\t\tif (dp[pair.y][pair.x][pair.lr] < pair.cost)\n//\t\t\t\tcontinue;\n\t\t\tint[] move_h, move_w;\n\t\t\tif (pair.lr == RIGHT) {\n\t\t\t\tmove_h = right_y;\n\t\t\t\tmove_w = right_x;\n\t\t\t} else {\n\t\t\t\tmove_h = left_y;\n\t\t\t\tmove_w = left_x;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < 9; j++) {\n\t\t\t\tint my = pair.y + move_h[j];\n\t\t\t\tint mx = pair.x + move_w[j];\n\t\t\t\tif (my < 0 || mx < 0 || my >= h || mx >= w)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (map[my][mx] == 'X' || map[my][mx] == 'S')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (map[my][mx] == 'T') {\n\t\t\t\t\tdp[my][mx][pair.lr] = pair.cost;\n\t\t\t\t\tque.add(new Pair(pair.cost, my, mx, 1 - pair.lr));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint cost = pair.cost + (int)(map[my][mx] - '0');\n\t\t\t\tif (cost <= dp[my][mx][pair.lr]) {\n\t\t\t\t\tdp[my][mx][pair.lr] = cost;\n\t\t\t\t\tque.add(new Pair(cost, my , mx, 1 - pair.lr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing static System.Math;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\n\npublic class Edge\n{\n    public int to { get; set; }\n    public long d { get; set; }\n}\n\npublic class Node : IComparable\n{\n    public int id { get; set; }\n    public long d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Node)obj;\n        if (this.d > x.d) return 1;\n        else if (this.d == x.d) return 0;\n        else return -1;\n    }\n}\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w;\n    public static int[] dx, dy;\n\n    public static void Main()\n    {\n        dx = new int[] { -2, -1, -1, 0, 0, 0, 1, 1, 2 };\n        dy = new int[] { 1, 1, 2, 1, 2, 3, 1, 2, 1 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            w = int.Parse(line[0]);\n            h = int.Parse(line[1]);\n            var hw = w * h;\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            var sp = new List<int>();\n            var tp = new List<int>();\n            var a = new List<Edge>[hw * 2];\n            for (int i = 0; i < h * w * 2; i++) a[i] = new List<Edge>();\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++)\n                {\n                    var t = line[j];\n                    if (t == \"S\") { sp.Add(getNextL(i, j)); sp.Add(getNextr(i, j)); }\n                    else if (t == \"T\") { tp.Add(getNextL(i, j)); tp.Add(getNextr(i, j)); }\n                    else if (t == \"X\") map[i, j] = -1;\n                    else map[i, j] = int.Parse(line[j]);\n                }\n            }\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    if (map[i, j] != -1)\n                    {\n                        for (int k = 0; k < 9; k++)\n                        {\n                            var nextx = i + dx[k];\n                            var nextry = j + dy[k];\n                            var nextLy = j - dy[k];\n                            if (nextx >= 0 && nextx < h && nextry >= 0 &&  nextry < w && map[nextx, nextry] >= 0)\n                            {\n                                var tt = getNextr(nextx, nextry);\n                                a[getNextL(i, j)].Add(new Edge { to = tt, d = map[nextx, nextry] });\n                            }\n                            if (nextx >= 0 && nextx < h && nextLy >= 0 && nextLy < w   && map[nextx, nextLy] >= 0)\n                            {\n                                var tt = getNextL(nextx, nextLy);\n                                a[getNextr(i, j)].Add(new Edge { to = tt, d = map[nextx, nextLy] });\n                            }\n                        }\n                    }\n            var ans = 9999999999999;\n            foreach (var x in sp)\n            {\n                var pq = new PriorityQueue<Node>(hw * 9 + 10000);\n                var mind = new long[hw * 2];\n                for (int i = 0; i < hw * 2; i++) mind[i] = 9999999999999;\n                goDijk(pq, a, x, hw, mind);\n                foreach (var y in tp)\n                    ans =Min(ans, mind[y]);\n            }\n            Console.WriteLine(ans == 9999999999999? -1:ans);\n        }\n    }\n    static void goDijk(PriorityQueue<Node> pq, List<Edge>[] aa, int r, int n, long[] mind)\n    {\n        pq.Push(new Node { id = r, d = 0 });\n        while (pq.Count() > 0)\n        {\n            var targ = pq.Pop();\n            var nowd = targ.d;\n            var nowid = targ.id;\n            if (mind[nowid] < nowd) continue;\n            mind[nowid] = nowd;\n            foreach (var x in aa[nowid])\n                if (nowd + x.d < mind[x.to])\n                {\n                    mind[x.to] = nowd + x.d;\n                    pq.Push(new Node { id = x.to, d = nowd + x.d });\n                }\n        }\n    }\n    static int getNextL(int x, int y) => w * x + y;\n    static int getNextr(int x, int y) => w * x + y + h * w;\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\nBLK_X = -1\nBLK_T = 10\n\nLEG_L = 0\nLEG_R = 1\n\nDXYS = [\n  [[1, -2],\n   [1, -1], [2, -1],\n   [1,  0], [2,  0], [3, 0],\n   [1,  1], [2,  1],\n   [1,  2]],\n  [[-1, -2],\n   [-1, -1], [-2, -1],\n   [-1,  0], [-2,  0], [-3, 0],\n   [-1,  1], [-2,  1],\n   [-1,  2]]\n]\n\n### main\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if (w | h) == 0\n\n  blks = h.times.map{[]}\n  starts = []\n\n  for y in (0...h)\n    line = gets.strip.split\n    for x in (0...w)\n      case line[x]\n      when 'S'\n        starts << [x, y]\n        blks[y][x] = 0\n      when 'T'\n        blks[y][x] = BLK_T\n      when 'X'\n        blks[y][x] = BLK_X\n      else\n        blks[y][x] = line[x].to_i\n      end\n    end\n  end\n  #p blks\n  #p starts\n\n  dists = h.times.map{w.times.map{2.times.map{INF}}}\n  q = []\n\n  starts.each do |x, y|\n    dists[y][x][LEG_L] = dists[y][x][LEG_R] = 0\n    q += [[x, y, LEG_L], [x, y, LEG_R]]\n  end\n\n  min_dist = INF\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a[1]][a[0]][a[2]] <=> dists[b[1]][b[0]][b[2]]}\n    q.delete(u)\n\n    ux, uy, ulr = u\n    ud = dists[uy][ux][ulr]\n    vlr = (ulr ^ 1)\n\n    DXYS[ulr].each do |dx, dy|\n      vx = ux + dx\n      vy = uy + dy\n\n      if vx >= 0 && vx < w && vy >= 0 && vy < h\n        blk = blks[vy][vx]\n        next if blk == BLK_X\n\n        if blk == BLK_T\n          min_dist = ud if min_dist > ud\n          next\n        end\n\n        vd = dists[vy][vx][vlr]\n        nvd = ud + blk\n\n        if vd > nvd\n          q << [vx, vy, vlr] if dists[vy][vx][vlr] >= INF\n          dists[vy][vx][vlr] = nvd\n        end\n      end\n    end\n  end\n\n  puts (min_dist >= INF ? -1 : min_dist)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Q1150\n  @@field = nil;\n  @@dp = nil;\n  @@w = 0;\n  @@h = 0;\n  @@pos = Struct.new(\"Pos\", :x, :y, :bRight)\n  @@queue = Array.new\n  LEFTFOOT = [[1,2],[1,1],[1,0],[1,-1],[1,-2],[2,1],[2,0],[2,-1],[3,0]]\n  RIGHTFOOT = [[-1,2],[-1,1],[-1,0],[-1,-1],[-1,-2],[-2,1],[-2,0],[-2,-1],[-3,0]]\n  MAX_COST = 100000000\n  def climb x,y,bRight\n    dir = bRight ? RIGHTFOOT : LEFTFOOT\n    foot = bRight ? 1 : 0\n    nfoot = bRight ? 0 : 1\n    #puts \"y = #{y}, x = #{x}, foot = #{foot}\"\n    dir.length.times do |i|\n      nx = x + dir[i][0]\n      ny = y + dir[i][1]\n      if((0 <= nx && nx < @@w) && (0 <= ny && ny < @@h))\n        if(@@field[ny][nx] == ?T)\n          @@dp[ny][nx][nfoot] = (@@dp[y][x][foot] < @@dp[ny][nx][nfoot]) ? @@dp[y][x][foot] : @@dp[ny][nx][nfoot]\n        elsif(?1 <= @@field[ny][nx] && @@field[ny][nx] <= ?9) \n          n = @@field[ny][nx].to_i\n          if(@@dp[y][x][foot] + n < @@dp[ny][nx][nfoot])\n            @@dp[ny][nx][nfoot] = @@dp[y][x][foot] + n\n            #puts \"dp[#{ny}][#{nx}][#{nfoot}] = #{@@dp[ny][nx][nfoot]}\"\n            @@queue.push @@pos.new(nx,ny,!bRight)\n          end\n        end\n      end\n    end\n  end\n  def doIt\n    arg = gets.split(\" \").map{|x| x.to_i}\n    while(0 < arg[0] + arg[1])\n      @@w = arg[0]\n      @@h = arg[1]\n      @@field = Array.new(@@h)\n      @@h.times do |i|\n        #puts  i\n        @@field[i] = gets.split(\" \")\n      end\n      @@dp = Array.new(@@h).map!{Array.new(@@w).map!{Array.new(2, MAX_COST)}}\n      #climing simulation\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?S)\n            #puts @@field[j][i]\n            @@dp[j][i][0] = @@dp[j][i][1] = 0\n            @@queue.push @@pos.new(i,j,true) \n            @@queue.push @@pos.new(i,j,false)\n          end\n        end     \n      end\n      #exec Dijkstra\n      while(@@queue.length > 0)\n        t = @@queue.shift\n        climb t.x,t.y,t.bRight\n      end\n      #solve min\n      min = MAX_COST\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?T)\n            min = @@dp[j][i][0] < min ? @@dp[j][i][0] : min\n            min = @@dp[j][i][1] < min ? @@dp[j][i][1] : min\n          end\n        end     \n      end\n      puts(min == MAX_COST ? -1 : min)\n      arg = gets.split(\" \").map{|x| x.to_i}\n    end\n  end\nend\n\nQ1150.new.doIt"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nmodule Grid\n\tdef each_neighbour_of(u)\n\t\ty, x = u\n\t\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\t\ti, j = y+dy, x+dx\n\t\t\tyield [i, j] if (0..self.size-1) === i && (0..self[0].size-1) === j\n\t\t}\n\tend\nend\n\n\nloop {\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\t$a = (1..h).map { gets.chomp.split }\n\t$a.extend Graphical\n\t$a.extend Grid\n\tdef $a.each_out_connection_of(u)\n\t\teach_neighbour_of(u){|v|\n\t\t\tyield [v, 1]\n\t\t}\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(legs)\n\t\tleft, right = legs\n\t\tif left\n\t\t\t$a.reachable_from(left, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[nil, v], $a[y][x].to_i] if left[1] < x && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\telse \n\t\t\t$a.reachable_from(right, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[v, nil], $a[y][x].to_i] if x < right[1] && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\tend\n\tend\n\n\tstarts = Set.new\n\tgoals = Set.new\n\t(0..h-1).each{|i|\n\t\t(0..w-1).each{|j|\n\t\t\tstarts << [i,j] if $a[i][j] == ?S\n\t\t\tgoals << [i,j] if $a[i][j] == ?T\n\t\t}\n\t}\n\n\tp dijkstra(starts.map{|y, x|\n\t\t[ [[y,x], nil], [nil, [y,x]] ]\n\t}.flatten(1)){|u|\n\t\tgoals.include?(u[0]) || goals.include?(u[1])\n\t} || -1\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(start, goal)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\traise \"goal must be Enumerable\" if !goal.kind_of?(Enumerable)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tstart.each{|s| f_heap.add(s, 0)}\n\t\tgoal.each{|t| b_heap.add(t, 0)}\n\n\t\tf_reached = Set[*start.to_a]\n\t\tb_reached = Set[*goal.to_a]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nmodule Grid\n\tdef each_neighbour_of(u)\n\t\ty, x = u\n\t\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\t\ti, j = y+dy, x+dx\n\t\t\tyield [i, j] if (0..self.size-1) === i && (0..self[0].size-1) === j\n\t\t}\n\tend\nend\n\n\nloop {\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\t$a = (1..h).map { gets.chomp.split }\n\t$a.extend Graphical\n\t$a.extend Grid\n\tdef $a.each_out_connection_of(u)\n\t\teach_neighbour_of(u){|v|\n\t\t\tyield [v, 1]\n\t\t}\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(legs)\n\t\tleft, right = legs\n\t\tif left\n\t\t\t$a.reachable_from(left, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[nil, v], $a[y][x].to_i] if left[1] < x && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\telse \n\t\t\t$a.reachable_from(right, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[v, nil], $a[y][x].to_i] if x < right[1] && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\tend\n\tend\n\n\tdef each_in_connection_of(legs)\n\t\tleft, right = legs\n\t\tif left\n\t\t\t$a.reachable_from(left, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[nil, v], $a[left[0]][left[1]].to_i] if left[1] < x && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\telse \n\t\t\t$a.reachable_from(right, 3).each{|v|\n\t\t\t\ty, x = v\n\t\t\t\tyield [[v, nil], $a[right[0]][right[1]].to_i] if x < right[1] && $a[v[0]][v[1]] != ?X\n\t\t\t}\n\t\tend\n\tend\n\n\tstarts = Set.new\n\tgoals = Set.new\n\t(0..h-1).each{|i|\n\t\t(0..w-1).each{|j|\n\t\t\tstarts << [i,j] if $a[i][j] == ?S\n\t\t\tgoals << [i,j] if $a[i][j] == ?T\n\t\t}\n\t}\n\n\tp bidir_dijkstra(\n\t\tstarts.map{|y, x|\n\t\t\t[ [[y,x], nil], [nil, [y,x]] ]\n\t\t}.flatten(1),\n\t\tgoals.map{|y, x|\n\t\t\t[ [[y,x], nil], [nil, [y,x]] ]\n\t\t}.flatten(1)\n\t) || -1\n}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Q1150\n  @@field = nil;\n  @@dp = nil;\n  @@w = 0;\n  @@h = 0;\n  @@pos = Struct.new(\"Pos\", :x, :y, :bRight)\n  @@queue = Array.new\n  LEFTFOOT = [[1,2],[1,1],[1,0],[1,-1],[1,-2],[2,1],[2,0],[2,-1],[3,0]]\n  RIGHTFOOT = [[-1,2],[-1,1],[-1,0],[-1,-1],[-1,-2],[-2,1],[-2,0],[-2,-1],[-3,0]]\n  MAX_COST = 100000000\n  def climb x,y,bRight\n    dir = bRight ? RIGHTFOOT : LEFTFOOT\n    foot = bRight ? 1 : 0\n    nfoot = bRight ? 0 : 1\n    #puts \"y = #{y}, x = #{x}, foot = #{foot}\"\n    dir.length.times do |i|\n      nx = x + dir[i][0]\n      ny = y + dir[i][1]\n      if((0 <= nx && nx < @@w) && (0 <= ny && ny < @@h))\n        if(@@field[ny][nx] == \"T\")\n          @@dp[ny][nx][nfoot] = (@@dp[y][x][foot] < @@dp[ny][nx][nfoot]) ? @@dp[y][x][foot] : @@dp[ny][nx][nfoot]\n        elsif(\"1\" <= @@field[ny][nx] && @@field[ny][nx] <= \"9\") \n          n = @@field[ny][nx].to_i\n          if(@@dp[y][x][foot] + n < @@dp[ny][nx][nfoot])\n            @@dp[ny][nx][nfoot] = @@dp[y][x][foot] + n\n            #puts \"dp[#{ny}][#{nx}][#{nfoot}] = #{@@dp[ny][nx][nfoot]}\"\n            @@queue.push @@pos.new(nx,ny,!bRight)\n          end\n        end\n      end\n    end\n  end\n  def doIt\n    arg = gets.split(\" \").map{|x| x.to_i}\n    while(0 < arg[0] + arg[1])\n      @@w = arg[0]\n      @@h = arg[1]\n      @@field = Array.new(@@h)\n      @@h.times do |i|\n        #puts  i\n        @@field[i] = gets.split(\" \")\n      end\n      @@dp = Array.new(@@h).map!{Array.new(@@w).map!{Array.new(2, MAX_COST)}}\n      #climing simulation\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == \"S\")\n            #puts @@field[j][i]\n            @@dp[j][i][0] = @@dp[j][i][1] = 0\n            @@queue.push @@pos.new(i,j,true) \n            @@queue.push @@pos.new(i,j,false)\n          end\n        end     \n      end\n      #exec Dijkstra\n      while(@@queue.length > 0)\n        t = @@queue.shift\n        climb(t.x,t.y,t.bRight)\n      end\n      #solve min\n      min = MAX_COST\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == \"T\")\n            min = (@@dp[j][i][0] < min) ? @@dp[j][i][0] : min\n            min = (@@dp[j][i][1] < min) ? @@dp[j][i][1] : min\n          end\n        end     \n      end\n      puts(min == MAX_COST ? -1 : min)\n      arg = gets.split(\" \").map{|x| x.to_i}\n    end\n  end\nend\n\nQ1150.new.doIt"
  },
  {
    "language": "Ruby",
    "code": "class Q1150\n  @@field = nil;\n  @@dp = nil;\n  @@w = 0;\n  @@h = 0;\n  @@pos = Struct.new(\"Pos\", :x, :y, :bRight)\n  @@queue = Array.new\n  LEFTFOOT = [[1,2],[1,1],[1,0],[1,-1],[1,-2],[2,1],[2,0],[2,-1],[3,0]]\n  RIGHTFOOT = [[-1,2],[-1,1],[-1,0],[-1,-1],[-1,-2],[-2,1],[-2,0],[-2,-1],[-3,0]]\n  MAX_COST = 100000000\n  def climb x,y,bRight\n    dir = bRight ? RIGHTFOOT : LEFTFOOT\n    foot = bRight ? 1 : 0\n    nfoot = bRight ? 0 : 1\n    #puts \"y = #{y}, x = #{x}, foot = #{foot}\"\n    dir.length.times do |i|\n      nx = x + dir[i][0]\n      ny = y + dir[i][1]\n      if((0 <= nx && nx < @@w) && (0 <= ny && ny < @@h))\n        if(@@field[ny][nx] == \"T\")\n          @@dp[ny][nx][nfoot] = (@@dp[y][x][foot] < @@dp[ny][nx][nfoot]) ? @@dp[y][x][foot] : @@dp[ny][nx][nfoot]\n        elsif(\"1\" <= @@field[ny][nx] && @@field[ny][nx] <= \"9\") \n          n = @@field[ny][nx].to_i\n          if(@@dp[y][x][foot] + n < @@dp[ny][nx][nfoot])\n            @@dp[ny][nx][nfoot] = @@dp[y][x][foot] + n\n            #puts \"dp[#{ny}][#{nx}][#{nfoot}] = #{@@dp[ny][nx][nfoot]}\"\n            @@queue.push @@pos.new(nx,ny,!bRight)\n          end\n        end\n      end\n    end\n  end\n  def doIt\n    arg = gets.split(\" \").map{|x| x.to_i}\n    while(0 < arg[0] + arg[1])\n      @@w = arg[0]\n      @@h = arg[1]\n      @@field = Array.new(@@h)\n      @@h.times do |i|\n        #puts  i\n        @@field[i] = gets.split(\" \")\n      end\n      @@dp = Array.new(@@h).map!{Array.new(@@w).map!{Array.new(2, MAX_COST)}}\n      #climing simulation\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == \"S\")\n            #puts @@field[j][i]\n            @@dp[j][i][0] = @@dp[j][i][1] = 0\n            @@queue.push @@pos.new(i,j,true) \n            @@queue.push @@pos.new(i,j,false)\n          end\n        end     \n      end\n      #exec Dijkstra\n      while(@@queue.length > 0)\n        t = @@queue.shift\n        climb t.x,t.y,t.bRight\n      end\n      #solve min\n      min = MAX_COST\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == \"T\")\n            min = @@dp[j][i][0] < min ? @@dp[j][i][0] : min\n            min = @@dp[j][i][1] < min ? @@dp[j][i][1] : min\n          end\n        end     \n      end\n      puts(min == MAX_COST ? -1 : min)\n      arg = gets.split(\" \").map{|x| x.to_i}\n    end\n  end\nend\n\nQ1150.new.doIt"
  },
  {
    "language": "Ruby",
    "code": "class Q1150\n  @@field = nil;\n  @@dp = nil;\n  @@w = 0;\n  @@h = 0;\n  @@pos = Struct.new(\"Pos\", :x, :y, :bRight)\n  @@queue = Array.new\n  LEFTFOOT = [[1,2],[1,1],[1,0],[1,-1],[1,-2],[2,1],[2,0],[2,-1],[3,0]]\n  RIGHTFOOT = [[-1,2],[-1,1],[-1,0],[-1,-1],[-1,-2],[-2,1],[-2,0],[-2,-1],[-3,0]]\n  MAX_COST = 100000000\n  def climb x,y,bRight\n    dir = bRight ? RIGHTFOOT : LEFTFOOT\n    foot = bRight ? 1 : 0\n    nfoot = bRight ? 0 : 1\n    #puts \"y = #{y}, x = #{x}, foot = #{foot}\"\n    dir.length.times do |i|\n      nx = x + dir[i][0]\n      ny = y + dir[i][1]\n      if((0 <= nx && nx < @@w) && (0 <= ny && ny < @@h))\n        if(@@field[ny][nx] == ?T)\n          @@dp[ny][nx][nfoot] = (@@dp[y][x][foot] < @@dp[ny][nx][nfoot]) ? @@dp[y][x][foot] : @@dp[ny][nx][nfoot]\n        elsif(?0 <= @@field[ny][nx] && @@field[ny][nx] <= ?9) \n          n = @@field[ny][nx].to_i\n          if(@@dp[y][x][foot] + n < @@dp[ny][nx][nfoot])\n            @@dp[ny][nx][nfoot] = @@dp[y][x][foot] + n\n            #puts \"dp[#{ny}][#{nx}][#{nfoot}] = #{@@dp[ny][nx][nfoot]}\"\n            @@queue.push @@pos.new(nx,ny,!bRight)\n          end\n        end\n      end\n    end\n  end\n  def doIt\n    arg = gets.split(\" \").map{|x| x.to_i}\n    while(0 < arg[0] + arg[1])\n      @@w = arg[0]\n      @@h = arg[1]\n      @@field = Array.new(@@h)\n      @@h.times do |i|\n        #puts  i\n        @@field[i] = gets.split(\" \")\n      end\n      @@dp = Array.new(@@h).map!{Array.new(@@w).map!{Array.new(2, MAX_COST)}}\n      #climing simulation\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?S)\n            #puts @@field[j][i]\n            @@dp[j][i][0] = @@dp[j][i][1] = 0\n            @@queue.push @@pos.new(i,j,true) \n            @@queue.push @@pos.new(i,j,false)\n          end\n        end     \n      end\n      #exec Dijkstra\n      while(@@queue.length > 0)\n        t = @@queue.shift\n        climb t.x,t.y,t.bRight\n      end\n      #solve min\n      min = MAX_COST\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?T)\n            min = @@dp[j][i][0] < min ? @@dp[j][i][0] : min\n            min = @@dp[j][i][1] < min ? @@dp[j][i][1] : min\n          end\n        end     \n      end\n      puts(min == MAX_COST ? -1 : min)\n      arg = gets.split(\" \").map{|x| x.to_i}\n    end\n  end\nend\n\nQ1150.new.doIt"
  },
  {
    "language": "Ruby",
    "code": "class Q1150\n  @@field = nil;\n  @@dp = nil;\n  @@w = 0;\n  @@h = 0;\n  LEFTFOOT = [[1,2],[1,1],[1,0],[1,-1],[1,-2],[2,1],[2,0],[2,-1],[3,0]]\n  RIGHTFOOT = [[-1,2],[-1,1],[-1,0],[-1,-1],[-1,-2],[-2,1],[-2,0],[-2,-1],[-3,0]]\n  MAX_COST = 100000000\n  def climb x,y,bRight\n    dir = bRight ? RIGHTFOOT : LEFTFOOT\n    foot = bRight ? 1 : 0\n    nfoot = bRight ? 0 : 1\n    #puts \"y = #{y}, x = #{x}, foot = #{foot}\"\n    dir.length.times do |i|\n      nx = x + dir[i][0]\n      ny = y + dir[i][1]\n      if((0 <= nx && nx < @@w) && (0 <= ny && ny < @@h))\n        if(@@field[ny][nx] == ?T)   \n          #puts @@dp[5][1]\n          @@dp[ny][nx][nfoot] = (@@dp[y][x][foot] < @@dp[ny][nx][nfoot]) ? @@dp[y][x][foot] : @@dp[ny][nx][nfoot]\n        elsif(?0 <= @@field[ny][nx] && @@field[ny][nx] <= ?9) \n          #puts @@field[ny][nx]\n          n = @@field[ny][nx].to_i\n          if(@@dp[y][x][foot] + n < @@dp[ny][nx][nfoot])\n            @@dp[ny][nx][nfoot] = @@dp[y][x][foot] + n\n            #puts \"dp[#{ny}][#{nx}][#{nfoot}] = #{@@dp[ny][nx][nfoot]}\"\n            climb nx,ny,!bRight\n          end\n        end\n      end\n    end\n  end\n  def doIt\n    arg = gets.split(\" \").map{|x| x.to_i}\n    while(0 < arg[0] + arg[1])\n      @@w = arg[0]\n      @@h = arg[1]\n      @@field = Array.new(@@h)\n      @@h.times do |i|\n        #puts  i\n        @@field[i] = gets.split(\" \")\n      end\n      @@dp = Array.new(@@h).map!{Array.new(@@w).map!{Array.new(2, MAX_COST)}}\n      #climing simulation\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?S)\n            #puts @@field[j][i]\n            @@dp[j][i][0] = @@dp[j][i][1] = 0\n            climb i,j,true\n            climb i,j,false\n          end\n        end     \n      end\n      #solve min\n      min = MAX_COST\n      @@h.times do |j|\n        @@w.times do |i|\n          if(@@field[j][i] == ?T)\n            min = @@dp[j][i][0] < min ? @@dp[j][i][0] : min\n            min = @@dp[j][i][1] < min ? @@dp[j][i][1] : min\n          end\n        end     \n      end\n      puts(min == MAX_COST ? -1 : min)\n      arg = gets.split(\" \").map{|x| x.to_i}\n    end\n  end\nend\n\nQ1150.new.doIt"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n    ddd = []\n    for i in range(-2,3):\n        for j in range(1,4):\n            if abs(i)+j > 3:\n                break\n            ddd.append((i,j))\n\n    while True:\n        w,h = LI()\n        if w == 0:\n            break\n\n        a = [LS() for _ in range(h)]\n        b = [[int(c) if '1' <= c <= '9' else 0 for c in t] for t in a]\n\n        def search():\n            d = collections.defaultdict(lambda: inf)\n            q = []\n            for i in range(w):\n                if a[-1][i] == 'S':\n                    for j in [-1,1]:\n                        s = (h-1, i, j)\n                        d[s] = 0\n                        heapq.heappush(q, (0, s))\n\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if a[u[0]][u[1]] == 'T':\n                    return k\n\n                for di, dj in ddd:\n                    ni = u[0] + di\n                    nj = u[1] + dj * u[2]\n                    if ni < 0 or ni >= h or nj < 0 or nj >= w or a[ni][nj] == 'X':\n                        continue\n                    uv = (ni,nj,-u[2])\n\n                    if v[uv]:\n                        continue\n                    ud = b[ni][nj]\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return -1\n\n        rr.append(search())\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nR_next = tuple((x, y) for x in range(-3, 0) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nL_next = tuple((x, y) for x in range(1, 4) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nc_num = tuple(str(i) for i in range(10))\nL, R = 0, 1\nINF = 10 ** 20\n\ndef conv(c):\n  if c in c_num:\n    return int(c)\n  if c in (\"T\", \"S\"):\n    return 0\n  return -1\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  mp = [[-1] * 3 + input().split() + [-1] * 3 for _ in range(h)]\n  for i in range(h):\n    mp[i] = list(map(conv, mp[i]))\n  mp.insert(0, [-1] * (w + 6))\n  mp.insert(0, [-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n  start = []\n  goal = []\n  for x in range(3, w + 3):\n    if mp[h + 1][x] == 0:\n      start.append((x, h + 1))\n    if mp[2][x] == 0:\n      goal.append((x, 2))\n\n  que = []\n  dic = {}\n  for x, y, in start:\n    heappush(que, (0, x, y, L))\n    heappush(que, (0, x, y, R))\n    dic[(x, y, L)] = 0\n    dic[(x, y, R)] = 0\n\n  while que:\n    total, x, y, foot = heappop(que)\n    if foot == R:\n      direct = R_next\n      next_foot = L\n    else:\n      direct = L_next\n      next_foot = R\n\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      cost = mp[ny][nx]\n      if cost == -1:\n        continue\n      if not (nx, ny, next_foot) in dic or dic[(nx, ny, next_foot)] > total + cost:\n        dic[(nx, ny, next_foot)] = total + cost\n        heappush(que, (total + cost, nx, ny, next_foot))\n  \n  ans = INF\n  for x, y in goal:\n    if (x, y, L) in dic: ans = min(ans, dic[(x, y, L)])\n    if (x, y, R) in dic: ans = min(ans, dic[(x, y, R)])\n  if ans == INF:\n    print(-1)\n  else:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\nmvL=((-1, 0), (-1, 1), (-1, 2), (-1, -1), (-1, -2), (-2, 0), (-2, 1), (-2, -1), (-3, 0))\nmvR=((1, 0), (1, 1), (1, 2), (1, -1), (1, -2), (2, 0), (2, 1), (2, -1), (3, 0))\nmv=(mvL,mvR)\nwhile True:\n    w,h=map(int,raw_input().split())\n    if w==h==0:break\n    INF=1000\n    LEFT,RIGHT=0,1\n    S=[raw_input().split() for i in range(h)]\n    D=[[[INF,INF] for j in range(w)] for i in range(h)]\n    Q=Queue()\n    posT=[]\n    for i in range(h):\n        for j in range(w):\n            if S[i][j]==\"S\":\n                Q.put((j,i,LEFT))\n                Q.put((j,i,RIGHT))\n                D[i][j][LEFT]=D[i][j][RIGHT]=0\n            elif S[i][j]==\"T\":\n                posT.append((j,i))\n    while not Q.empty():\n        x,y,foot=Q.get()\n        if foot==RIGHT:\n            for dx,dy in mv[LEFT]:\n                mx=x+dx\n                my=y+dy\n                if 0<=mx<w and 0<=my<h and S[my][mx]!=\"X\" and S[my][mx]!=\"S\":\n                    if S[my][mx]==\"T\":\n                        cost=D[y][x][RIGHT]\n                    else:\n                        cost=int(S[my][mx])+D[y][x][RIGHT]\n                    if D[my][mx][LEFT]>cost:\n                        D[my][mx][LEFT]=cost\n                        Q.put((mx,my,LEFT))\n        elif foot==LEFT:\n            for dx,dy in mv[RIGHT]:\n                mx=x+dx\n                my=y+dy\n                if 0<=mx<w and 0<=my<h and S[my][mx]!=\"X\" and S[my][mx]!=\"S\":\n                    if S[my][mx]==\"T\":\n                        cost=D[y][x][LEFT]\n                    else:\n                        cost=int(S[my][mx])+D[y][x][LEFT]\n                    if D[my][mx][RIGHT]>cost:\n                        D[my][mx][RIGHT]=cost\n                        Q.put((mx,my,RIGHT))\n    minCost=INF\n    for x,y in posT:\n        minCost=min(minCost,D[y][x][LEFT])\n        minCost=min(minCost,D[y][x][RIGHT])\n    print minCost if minCost!=INF else -1"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\ninput = sys.stdin.readline\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0:\n            break\n        board = [input().strip().split() for i in range(h)]\n        check = [[[False, False] for i in range(w)] for j in range(h)]\n        q = []\n        for y in range(h):\n            for x in range(w):\n                if board[y][x] == \"S\":\n                    # 0: 右足   1: 左足\n                    check[y][x][0] = True\n                    check[y][x][1] = True\n                    heapq.heappush(q, (0, 0, x, y))\n                    heapq.heappush(q, (0, 1, x, y))\n        ok = False\n        while len(q) > 0:\n            cost, foot, x, y = heapq.heappop(q)\n            if foot == 0:# 次は左足\n                nexts = [(x+1, y-2), (x+1, y-1), (x+1, y), (x+1, y+1), (x+1, y+2), (x+2, y-1), (x+2, y), (x+2, y+1), (x+3, y)]\n            else:# 次は右足\n                nexts = [(x-3, y), (x-2, y-1), (x-2, y), (x-2, y+1), (x-1, y-2), (x-1, y-1), (x-1, y), (x-1, y+1), (x-1, y+2)]\n            # 足を動かす\n            next_foot = (foot + 1) % 2\n            for nx, ny in nexts:\n                if 0 <= nx and nx < w and 0 <= ny and ny < h:\n                    if board[ny][nx] == \"T\":\n                        print(cost)\n                        ok = True\n                        break\n                    if (not check[ny][nx][next_foot]) and board[ny][nx] != \"X\":\n                        check[ny][nx][next_foot] = True\n                        heapq.heappush(q, (cost + int(board[ny][nx]), next_foot, nx, ny))\n\n            if ok:\n                break\n        \n        if not ok:\n            print(-1)\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\nfrom heapq import heappop,heappush\nMA = 1000000\ndef v(y,x,d):\n    if (x == 0 and d) or (x == w-1 and not d):\n        return []\n    k = 1-2*d\n    l = [(i,x+k) for i in range(max(0,y-2),min(h,y+3))]\n    if (x == 1 and d) or (x == w-2 and not d):\n        return l\n    for i in range(max(0,y-1),min(h,y+2)):\n        l.append((i,x+2*k))\n    if (x == 2 and d) or (x == w-3 and not d):\n        return l\n    l.append((y,x+3*k))\n    return l\n\ndef dijkstra(start,goal):\n    d = defaultdict(lambda : MA)\n    q = []\n    for y,x in start:\n        for i in range(2):\n            d[(y,x,i)] = 0\n            heappush(q,(0,y,x,i))\n\n    while q:\n        dp,y,x,di = heappop(q)\n        e = v(y,x,di)\n        di ^= 1\n        for y_,x_ in e:\n            if s[y_][x_] == \"X\":continue\n            cost = 0 if s[y_][x_] == \"S\" or s[y_][x_] == \"T\" else s[y_][x_]\n            if dp+cost < d[(y_,x_,di)]: #昨日はずっとここでd[(y_,x_)]と比較してた。頭が悪い\n                d[(y_,x_,di)] = dp+cost\n                heappush(q,(d[(y_,x_,di)],y_,x_,di))\n\n    res = MA\n    for y,x in goal:\n        for i in range(2):\n            if d[(y,x,i)] < res:\n                res = d[(y,x,i)]\n    res = res if res < MA else -1\n    return res\n\ndef solve(w,h,s):\n    start = []\n    goal = []\n    for y in range(h):\n        for x in range(w):\n            if s[y][x].isdecimal():\n                s[y][x] = int(s[y][x])\n            elif s[y][x] == \"S\":\n                start.append((y,x))\n            elif s[y][x] == \"T\":\n                goal.append((y,x))\n    print(dijkstra(start,goal))\n\nwhile 1:\n    w,h = map(int, sys.stdin.readline().split())\n    if w == 0:\n        break\n    s = [sys.stdin.readline().split() for i in range(h)]\n    solve(w,h,s)\n\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nimport math\nimport bisect\nimport heapq\nimport copy\nsys.setrecursionlimit(1000000)\nfrom collections import deque\nfrom itertools import permutations\n\ndef main():\n\n    dy = [-2,-1,0,1,2,-1,0,1,0]\n    rx = [1,1,1,1,1,2,2,2,3]\n    lx = [-1,-1,-1,-1,-1,-2,-2,-2,-3]\n    inf = 1000000007\n\n    while True:\n        m,n = map(int,input().split())\n        if n == 0:break\n        grid = []\n        for _ in range(n):\n            grid.append(list(input().split()))\n\n\n        dp = [[[inf]*2 for _ in range(m)] for _ in range(n)]\n        pq = []\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]=='S':\n                    pq.append([0,i,j,0])\n                    dp[i][j][0] = 0\n                    pq.append([0,i,j,1])\n                    dp[i][j][1] = 0\n        heapq.heapify(pq)\n\n        res = inf\n\n        while pq:\n            cost,i,j,b = heapq.heappop(pq)\n            if dp[i][j][b]<cost:continue\n\n            if grid[i][j] == 'T':\n                res = cost\n                break\n\n            for k in range(9):\n                h = i+dy[k]\n                if b:w = j+lx[k]\n                else:w = j+rx[k]\n                bb = (b+1)%2\n                if not (0<=h and h<n and 0<=w and w<m):continue\n                if grid[h][w]=='X':continue\n                if '1'<=grid[i][j]  and grid[i][j]<='9':\n                    ncost = cost+int(grid[i][j])\n                else :\n                    ncost = copy.copy(cost)\n                if ncost<dp[h][w][bb]:\n                    dp[h][w][bb] = ncost\n                    heapq.heappush(pq,[ncost,h,w,bb])\n\n        print (res if res!=inf else -1)\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef cal(x,y,f):\n    return (x+y*W)*2+f\n\ndef dijkstra(lines,N,s):\n    weight = [INF]*N\n    weight[s] = 0\n    def search(s,w_0,q,weight):\n        for t,w in lines[s]:\n            w += w_0\n            if weight[t] > w:\n                heapq.heappush(q,[w,t])\n                weight[t] = w\n    q = [[0,s]]\n    heapq.heapify(q)\n    while q:\n        w,n = heapq.heappop(q)\n        search(n,w,q,weight)\n    return weight\n\n\ndxr = [ 1, 1, 1, 1, 1, 2, 2, 2, 3]\ndyr = [-2,-1, 0, 1, 2,-1, 0, 1, 0]\n\ndxl = [-1,-1,-1,-1,-1,-2,-2,-2,-3]\ndyl = [-2,-1, 0, 1, 2,-1, 0, 1, 0]\n\nwhile True:\n    W,H = inpl()\n    if W == 0:\n        break\n    ss = [list(input().split()) for _ in range(H)]\n\n    N = W*H*2+2\n    S = W*H*2\n    T = W*H*2+1\n    lines = defaultdict(set)\n    for x in range(W):\n        for y in range(H):\n            if ss[y][x] == 'S':\n                lines[S].add((cal(x,y,0),0))\n                lines[S].add((cal(x,y,1),0))\n            if ss[y][x] == 'T':\n                lines[cal(x,y,0)].add((T,0))\n                lines[cal(x,y,1)].add((T,0))\n                continue\n            if ss[y][x] == 'X':\n                continue\n            else:\n                f = 0 # 次が右足\n                for i in range(9):\n                    tx = x + dxr[i]\n                    ty = y + dyr[i]\n                    if (0 <= tx < W) and (0 <= ty < H):\n                        if ss[ty][tx] == 'S' or ss[ty][tx] == 'T':\n                            cost = 0\n                        elif ss[ty][tx] == 'X':\n                            continue\n                        else:\n                            cost = int(ss[ty][tx])\n                        lines[cal(x,y,0)].add((cal(tx,ty,1),cost))\n\n                f = 1 # 次が左足\n                for i in range(9):\n                    tx = x + dxl[i]\n                    ty = y + dyl[i]\n                    if (0 <= tx < W) and (0 <= ty < H):\n                        if ss[ty][tx] == 'S' or ss[ty][tx] == 'T':\n                            cost = 0\n                        elif ss[ty][tx] == 'X':\n                            continue\n                        else:\n                            cost = int(ss[ty][tx])\n                        lines[cal(x,y,1)].add((cal(tx,ty,0),cost))\n\n    weights = dijkstra(lines,N,S)\n    if weights[T] == INF:\n        print(-1)\n    else:\n        print(weights[T])\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nR_next = tuple((x, y) for x in range(-3, 0) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nL_next = tuple((x, y) for x in range(1, 4) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nc_num = tuple(str(i) for i in range(10))\nL, R = 0, 1\nINF = 10 ** 20\n\ndef conv(c):\n  if c in c_num:\n    return int(c)\n  if c in (\"T\", \"S\"):\n    return 0\n  return -1\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  mp = [[-1] * 3 + input().split() + [-1] * 3 for _ in range(h)]\n  for i in range(h):\n    mp[i] = list(map(conv, mp[i]))\n  mp.insert(0, [-1] * (w + 6))\n  mp.insert(0, [-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n\n  def search():\n    start = []\n    goal = []\n    for x in range(3, w + 3):\n      if mp[h + 1][x] == 0:\n        start.append((x, h + 1))\n      if mp[2][x] == 0:\n        goal.append((x, 2))\n\n    que = []\n    dic = {}\n    for x, y, in start:\n      heappush(que, (0, x, y, L))\n      heappush(que, (0, x, y, R))\n      dic[(x, y, L)] = 0\n      dic[(x, y, R)] = 0\n \n    while que:\n      total, x, y, foot = heappop(que)\n      if foot == R:\n        direct = R_next\n        next_foot = L\n      else:\n        direct = L_next\n        next_foot = R\n\n      for dx, dy in direct:\n        nx, ny = x + dx, y + dy\n        if (nx, ny) in goal:\n          return total\n        cost = mp[ny][nx]\n        if cost == -1:\n          continue\n        if not (nx, ny, next_foot) in dic or dic[(nx, ny, next_foot)] > total + cost:\n          dic[(nx, ny, next_foot)] = total + cost\n          heappush(que, (total + cost, nx, ny, next_foot))\n    else:\n      return -1\n  print(search()) \n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nR_next = tuple((x, y) for x in range(-3, 0) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nL_next = tuple((x, y) for x in range(1, 4) for y in range(-2, 3) if abs(x) + abs(y) <= 3)\nc_num = tuple(str(i) for i in range(10))\nL, R = 0, 1\nINF = 10 ** 20\n\ndef conv(c):\n  if c in c_num:\n    return int(c)\n  if c in (\"T\", \"S\"):\n    return 0\n  return -1\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  mp = [[-1] * 3 + input().split() + [-1] * 3 for _ in range(h)]\n  for i in range(h):\n    mp[i] = list(map(conv, mp[i]))\n  mp.insert(0, [-1] * (w + 6))\n  mp.insert(0, [-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n  mp.append([-1] * (w + 6))\n\n  def search():\n    start = []\n    goal = []\n    for x in range(3, w + 3):\n      if mp[h + 1][x] == 0:\n        start.append((x, h + 1))\n      if mp[2][x] == 0:\n        goal.append((x, 2))\n\n    que = []\n    visited = {}\n    for x, y, in start:\n      heappush(que, (0, x, y, L))\n      heappush(que, (0, x, y, R))\n      visited[(x, y, L)] = True\n      visited[(x, y, R)] = True\n \n    while que:\n      total, x, y, foot = heappop(que)\n      if foot == R:\n        direct = R_next\n        next_foot = L\n      else:\n        direct = L_next\n        next_foot = R\n\n      for dx, dy in direct:\n        nx, ny = x + dx, y + dy\n        if (nx, ny) in goal:\n          return total\n        cost = mp[ny][nx]\n        if cost == -1:\n          continue\n        if not (nx, ny, next_foot) in visited:\n          visited[(nx, ny, next_foot)] = True\n          heappush(que, (total + cost, nx, ny, next_foot))\n    else:\n      return -1\n  \n  print(search()) \n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nfrom heapq import heapify,heappop,heappush\ndef solve(H,W):\n    grid = [input().split() for _ in range(H)]\n    dist = [[[INF]*2 for _ in range(W)] for _ in range(H)]\n\n    q = []\n    #find start and goal\n    g = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                heappush(q,(0,i,j,0))\n                heappush(q,(0,i,j,1))\n                dist[i][j][0] = 0\n                dist[i][j][1] = 0\n            elif grid[i][j] == 'T':\n                grid[i][j] = '0'\n                g.append((i,j))\n\n    #Dijkstra\n    t = ord('0')\n    while q:\n        d,ny,nx,leg = heappop(q)\n        if d > dist[ny][nx][leg]:\n            continue\n        if leg == 0:\n            for ly in range(max(ny - 2,0),min(ny + 3,H)):\n                for lx in range(max(0,nx - 3),nx):\n                    if abs(ly - ny) + abs(lx - nx) > 3:\n                        continue\n                    if grid[ly][lx] == 'X' or grid[ly][lx] == 'S':\n                        continue\n                    if dist[ly][lx][1] > dist[ny][nx][0] + ord(grid[ly][lx]) - t:\n                        dist[ly][lx][1] = dist[ny][nx][0] + ord(grid[ly][lx]) - t\n                        heappush(q,(dist[ly][lx][1],ly,lx,1))\n        else:\n            for ry in range(max(ny - 2,0),min(ny + 3,H)):\n                for rx in range(nx + 1,min(nx + 4,W)):\n                    if abs(ry - ny) + abs(rx - nx) > 3:\n                        continue\n                    if grid[ry][rx] == 'X' or grid[ry][rx] == 'S':\n                        continue\n                    if dist[ry][rx][0] > dist[ny][nx][1] + ord(grid[ry][rx]) - t:\n                        dist[ry][rx][0] = dist[ny][nx][1] + ord(grid[ry][rx]) - t\n                        heappush(q,(dist[ry][rx][0],ry,rx,0))\n\n    ans = min(min(dist[gy][gx]) for gy,gx in g)\n    print(-1 if ans == INF else ans)\n\ndef main():\n    while True:\n        W,H = map(int,input().split())\n        if H == 0 and W == 0:\n            return\n        solve(H,W)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Rust",
    "code": "use std::hash::Hash;\nuse std::collections::hash_set::Iter;\nuse std::rc::Rc;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Eq, PartialEq)]\nstruct Rev<T: Ord>(T);\nimpl <T: std::cmp::Ord> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, rhs: &Rev<T>) -> std::option::Option<std::cmp::Ordering> { \n        rhs.0.partial_cmp(&self.0)\n    }\n}\nimpl <T: Ord> Ord for Rev<T> {\n    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering { \n        rhs.0.cmp(&self.0)\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Coordinate{\n    x: i32, y: i32\n}\n\nimpl Coordinate {\n    fn manhattan_distance(&self, other: Coordinate) -> i32 {\n        (self.x - other.x).abs() + (self.y - other.y).abs()\n    }\n}\nimpl Add for Coordinate {\n    type Output = Coordinate;\n    fn add(self, rhs: Coordinate) -> <Self as std::ops::Add<Coordinate>>::Output {\n        Coordinate{x: self.x + rhs.x, y: self.y + rhs.y}\n    }\n}\n#[derive(Copy, Clone, Debug)]\nenum Block {\n    Start, Goal, Break, Num(i32)\n}\nimpl FromStr for Block {\n    type Err = ();\n    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {\n        match s {\n            \"S\" => Ok(Block::Start),\n            \"T\" => Ok(Block::Goal),\n            \"X\" => Ok(Block::Break),\n            _ => {\n                if let Ok(n) = s.parse::<i32>() {\n                    Ok(Block::Num(n))\n                }else {\n                    Err(())\n                }\n            }\n        }\n    }\n}\nimpl Block {\n    fn is_goal(&self) -> bool {\n        match self {\n            &Block::Goal => true,\n            _ => false\n        }\n    }\n    fn is_start(&self) -> bool {\n        match self {\n            &Block::Start => true,\n            _ => false\n        }\n    }\n}\nfn find_start_pos(state: &Vec<Vec<Block>>) -> Vec<Coordinate> {\n    let mut res = Vec::with_capacity(2);\n    for i in 0 .. state.len() {\n        for j in 0 .. state[i].len() {\n            match state[i][j] {\n                Block::Start => res.push(Coordinate{x: j as i32, y: i as i32}),\n                _ => ()\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let right_next = (1 .. 4).flat_map(|x| (-2 .. 3).map(move |y| Coordinate{x: x, y: y})).filter(|c| c.x.abs() + c.y.abs() <= 3).collect::<Vec<_>>();\n    let left_next = (-3 .. 0).flat_map(|x| (-2 .. 3).map(move |y| Coordinate{x: x, y: y})).filter(|c| c.x.abs() + c.y.abs() <= 3).collect::<Vec<_>>();\n    loop {\n        read!(width: usize, height: usize);\n        if width == 0 && height == 0 {break;}\n        read!(state: [[Block]; height]);\n        let mut memo = vec![vec![vec![std::i32::MAX; width]; height]; 2];\n        let mut queue = BinaryHeap::new();\n        for start in find_start_pos(&state) {\n            queue.push(Rev(KeyValue{key: 0, value: (0, start)}));\n            queue.push(Rev(KeyValue{key: 0, value: (1, start)}));\n            memo[0][start.y as usize][start.x as usize] = 0;\n            memo[1][start.y as usize][start.x as usize] = 0;\n        }\n        let mut result = None;\n        while let Some(Rev(KeyValue{key: time, value: value})) = queue.pop() {\n            match value {\n                (0, left) => {\n                    for next_right in right_next.iter().map(|&c| c + left).filter(|c| 0 <= c.x && c.x < width as i32 && 0 <= c.y && c.y < height as i32) {\n                        match state[next_right.y as usize][next_right.x as usize] {\n                            Block::Num(c) => {\n                                if memo[1][next_right.y as usize][next_right.x as usize] > time + c {\n                                    memo[1][next_right.y as usize][next_right.x as usize] = time + c;\n                                    queue.push(Rev(KeyValue{key: time + c, value: (1, next_right)}));\n                                }\n                            }\n                            Block::Break => (),\n                            Block::Goal => {\n                                result = Some(time);\n                                break;\n                            }\n                            _ => {\n                                if memo[1][next_right.y as usize][next_right.x as usize] > time {\n                                    memo[1][next_right.y as usize][next_right.x as usize] = time;\n                                    queue.push(Rev(KeyValue{key: time, value: (1, next_right)}));\n                                }\n                            }\n                        }\n                    }\n                },\n                (1, right) => {\n                    for next_left in left_next.iter().map(|&c| c + right).filter(|c| 0 <= c.x && c.x < width as i32 && 0 <= c.y && c.y < height as i32) {\n                        match state[next_left.y as usize][next_left.x as usize] {\n                            Block::Num(c) => {\n                                if memo[0][next_left.y as usize][next_left.x as usize] > time + c {\n                                    memo[0][next_left.y as usize][next_left.x as usize] = time + c;\n                                    queue.push(Rev(KeyValue{key: time + c, value: (0, next_left)}));\n                                }\n                            }\n                            Block::Break => (),\n                            Block::Goal => {\n                                result = Some(time);\n                                break;\n                            }\n                            _ => {\n                                if memo[0][next_left.y as usize][next_left.x as usize] > time {\n                                    memo[0][next_left.y as usize][next_left.x as usize] = time;\n                                    queue.push(Rev(KeyValue{key: time, value: (0, next_left)}));\n                                }\n                            }\n                        }\n                    }\n                },\n                _ => panic!()\n            }\n            if result.is_some() {break;}\n        }\n        println!(\"{}\", result.unwrap_or(-1));\n    }\n}\n"
  }
]