[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 1000\n\ntypedef struct {\n    int row, col, time;\n} Node;\n\ntypedef struct {\n    Node nodes[MAX_SIZE * MAX_SIZE];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = q->rear = 0;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, Node node) {\n    q->nodes[q->rear++] = node;\n}\n\nNode dequeue(Queue *q) {\n    return q->nodes[q->front++];\n}\n\nint minTimeToClimb(char grid[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int dist[MAX_SIZE][MAX_SIZE];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n\n    Queue q;\n    initQueue(&q);\n\n    for (int j = 0; j < cols; j++) {\n        if (grid[rows - 1][j] == 'S') {\n            dist[rows - 1][j] = 0;\n            enqueue(&q, (Node){rows - 1, j, 0});\n        }\n    }\n\n    int minTime = INT_MAX;\n    int dr[] = {-1, 0, 0};\n    int dc[] = {0, -1, 1};\n\n    while (!isEmpty(&q)) {\n        Node current = dequeue(&q);\n        if (grid[current.row][current.col] == 'T') {\n            if (current.time < minTime) {\n                minTime = current.time;\n            }\n            continue;\n        }\n\n        for (int i = 0; i < 3; i++) {\n            int newRow = current.row + dr[i];\n            int newCol = current.col + dc[i];\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                if (grid[newRow][newCol] == 'X') continue;\n\n                int time = current.time;\n                if (grid[newRow][newCol] != 'S' && grid[newRow][newCol] != 'T') {\n                    time += grid[newRow][newCol] - '0';\n                }\n\n                if (time < dist[newRow][newCol]) {\n                    dist[newRow][newCol] = time;\n                    enqueue(&q, (Node){newRow, newCol, time});\n                }\n            }\n        }\n    }\n\n    return minTime == INT_MAX ? -1 : minTime;\n}\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n    char grid[MAX_SIZE][MAX_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = minTimeToClimb(grid, rows, cols);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ClimbCliff {\n    public static int minimumTimeToClimb(char[][] cliff, int[] footPositions) {\n        int rows = cliff.length;\n        int cols = cliff[0].length;\n        \n        // 3D DP array to store minimum times\n        int[][][] dp = new int[rows][cols][footPositions.length];\n        \n        // Initialize with max value\n        for (int[][] row2D : dp) {\n            for (int[] row1D : row2D) {\n                Arrays.fill(row1D, Integer.MAX_VALUE);\n            }\n        }\n        \n        // Initialize starting row\n        for (int j = 0; j < cols; j++) {\n            if (cliff[0][j] != 'X') {\n                for (int k = 0; k < footPositions.length; k++) {\n                    if (Math.abs(j - footPositions[k]) <= 1) {\n                        dp[0][j][k] = cliff[0][j] - '0';\n                    }\n                }\n            }\n        }\n        \n        // Dynamic programming\n        for (int i = 1; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (cliff[i][j] == 'X') continue;\n                \n                for (int k = 0; k < footPositions.length; k++) {\n                    if (Math.abs(j - footPositions[k]) > 1) continue;\n                    \n                    int currentTime = cliff[i][j] - '0';\n                    \n                    // Check previous row's possible positions\n                    for (int prevJ = 0; prevJ < cols; prevJ++) {\n                        for (int prevK = 0; prevK < footPositions.length; prevK++) {\n                            if (dp[i-1][prevJ][prevK] != Integer.MAX_VALUE &&\n                                Math.abs(prevJ - j) <= 1) {\n                                dp[i][j][k] = Math.min(dp[i][j][k], \n                                    dp[i-1][prevJ][prevK] + currentTime);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Find minimum time to reach top row with 'T'\n        int minTime = Integer.MAX_VALUE;\n        for (int j = 0; j < cols; j++) {\n            if (cliff[rows-1][j] == 'T') {\n                for (int k = 0; k < footPositions.length; k++) {\n                    minTime = Math.min(minTime, dp[rows-1][j][k]);\n                }\n            }\n        }\n        \n        return minTime == Integer.MAX_VALUE ? -1 : minTime;\n    }\n    \n    public static void main(String[] args) {\n        char[][] cliff = {\n            {'1', '2', '3'},\n            {'4', '5', '6'},\n            {'T', '7', '8'}\n        };\n        int[] footPositions = {0, 1, 2};\n        \n        System.out.println(minimumTimeToClimb(cliff, footPositions));\n    }\n}",
    "timestamp": "2025-08-05 19:07:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct State {\n    int row, col, time;\n    State(int r, int c, int t) : row(r), col(c), time(t) {}\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<string> grid(H);\n    int start_row = -1, start_col = -1;\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                start_row = i;\n                start_col = j;\n            }\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    pq.emplace(start_row, start_col, 0);\n    dist[start_row][start_col] = 0;\n\n    int dr[] = {0, 0};\n    int dc[] = {-1, 1};\n    int ans = INT_MAX;\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (grid[current.row][current.col] == 'T') {\n            ans = current.time;\n            break;\n        }\n\n        if (current.time > dist[current.row][current.col]) continue;\n\n        for (int k = 0; k < 2; ++k) {\n            for (int step = 1; step <= N; ++step) {\n                int nr = current.row + dr[k] * step;\n                int nc = current.col + dc[k] * step;\n                if (nr < 0 || nr >= H || nc < 0 || nc >= W) break;\n                if (grid[nr][nc] == 'X') break;\n                int nt = current.time + (grid[nr][nc] - '0');\n                if (nt < dist[nr][nc]) {\n                    dist[nr][nc] = nt;\n                    pq.emplace(nr, nc, nt);\n                }\n            }\n        }\n    }\n\n    if (ans != INT_MAX) {\n        cout << ans << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\nint minTime(char cliff[MAX_ROWS][MAX_COLS], int rows, int cols) {\n    int dp[MAX_ROWS][MAX_COLS];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n\n    // Find start position\n    int startCol = -1;\n    for (int j = 0; j < cols; j++) {\n        if (cliff[0][j] == 'S') {\n            startCol = j;\n            dp[0][j] = 0;\n            break;\n        }\n    }\n\n    if (startCol == -1) return -1;\n\n    for (int i = 0; i < rows - 1; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (dp[i][j] == INT_MAX || cliff[i][j] == 'X') continue;\n\n            for (int dx = -1; dx <= 1; dx++) {\n                for (int step = 1; step <= 3; step++) {\n                    int newJ = j + dx * step;\n                    int newI = i + 1;\n\n                    if (newJ >= 0 && newJ < cols && cliff[newI][newJ] != 'X') {\n                        int time = dp[i][j] + (cliff[newI][newJ] - '0');\n                        dp[newI][newJ] = (dp[newI][newJ] < time) ? dp[newI][newJ] : time;\n                    }\n                }\n            }\n        }\n    }\n\n    int minTimePath = INT_MAX;\n    for (int j = 0; j < cols; j++) {\n        if (cliff[rows-1][j] == 'T' && dp[rows-1][j] < minTimePath) {\n            minTimePath = dp[rows-1][j];\n        }\n    }\n\n    return (minTimePath == INT_MAX) ? -1 : minTimePath;\n}\n\nint main() {\n    int rows, cols;\n    char cliff[MAX_ROWS][MAX_COLS];\n\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", cliff[i]);\n    }\n\n    int result = minTime(cliff, rows, cols);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int row, col, time;\n    State(int r, int c, int t) : row(r), col(c), time(t) {}\n};\n\nint minTimeToReachTop(vector<vector<char>>& cliff, int maxLeftRight) {\n    int rows = cliff.size();\n    int cols = cliff[0].size();\n    vector<vector<int>> visited(rows, vector<int>(cols, INT_MAX));\n    queue<State> q;\n\n    // Find starting positions\n    for (int j = 0; j < cols; j++) {\n        if (cliff[0][j] == 'S') {\n            q.push(State(0, j, 0));\n            visited[0][j] = 0;\n        }\n    }\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        // Reached top\n        if (current.row == rows - 1) {\n            for (int j = 0; j < cols; j++) {\n                if (cliff[current.row][j] == 'T') {\n                    return current.time;\n                }\n            }\n        }\n\n        // Try moving left and right\n        for (int dx : {-1, 1}) {\n            for (int step = 1; step <= maxLeftRight; step++) {\n                int newRow = current.row + 1;\n                int newCol = current.col + dx * step;\n\n                // Check bounds and block validity\n                if (newRow < rows && newCol >= 0 && newCol < cols && \n                    cliff[newRow][newCol] != 'X') {\n                    \n                    int stepTime = cliff[newRow][newCol] - '0';\n                    int totalTime = current.time + stepTime;\n\n                    if (totalTime < visited[newRow][newCol]) {\n                        visited[newRow][newCol] = totalTime;\n                        q.push(State(newRow, newCol, totalTime));\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;  // Cannot reach top\n}\n\nint main() {\n    int rows, cols, maxLeftRight;\n    cin >> rows >> cols >> maxLeftRight;\n\n    vector<vector<char>> cliff(rows, vector<char>(cols));\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> cliff[i][j];\n        }\n    }\n\n    int result = minTimeToReachTop(cliff, maxLeftRight);\n    cout << (result != -1 ? to_string(result) : \"IMPOSSIBLE\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CliffClimbing {\n    static class State {\n        int row, col, time;\n        State(int row, int col, int time) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine();\n        char[][] grid = new char[rows][cols];\n        int startRow = -1, startCol = -1;\n        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.time));\n        boolean[][] visited = new boolean[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'S') {\n                    startRow = i;\n                    startCol = j;\n                }\n            }\n        }\n\n        pq.add(new State(startRow, startCol, 0));\n        visited[startRow][startCol] = true;\n        int[][] directions = {{-1, -2}, {-1, 2}, {-2, -1}, {-2, 1}};\n        int minTime = -1;\n\n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            if (grid[current.row][current.col] == 'T') {\n                minTime = current.time;\n                break;\n            }\n            for (int[] dir : directions) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol] && grid[newRow][newCol] != 'X') {\n                    visited[newRow][newCol] = true;\n                    int time = current.time + (grid[newRow][newCol] - '0');\n                    pq.add(new State(newRow, newCol, time));\n                }\n            }\n        }\n\n        System.out.println(minTime);\n    }\n}",
    "timestamp": "2025-08-05 19:08:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_climb_time(cliff):\n    rows = len(cliff)\n    cols = len(cliff[0])\n    \n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and cliff[nx][ny] != 'X':\n                yield nx, ny\n\n    start_positions = [(r, c) for r in range(rows) for c in range(cols) if cliff[r][c] == 'S']\n    end_positions = [(r, c) for r in range(rows) for c in range(cols) if cliff[r][c] == 'T']\n    \n    min_time = float('inf')\n    \n    for sr, sc in start_positions:\n        pq = [(0, sr, sc)]\n        visited = set()\n        while pq:\n            time, x, y = heapq.heappop(pq)\n            if (x, y) in end_positions:\n                min_time = min(min_time, time)\n                break\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for nx, ny in neighbors(x, y):\n                if (nx, ny) not in visited:\n                    slippery_time = int(cliff[nx][ny])\n                    heapq.heappush(pq, (time + slippery_time, nx, ny))\n    \n    return min_time if min_time != float('inf') else -1\n\n# Sample input grid (cliff):\ncliff = [\n    \"S1234\",\n    \"345X5\",\n    \"23456\",\n    \"X345X\",\n    \"5678T\"\n]\n\nprint(min_climb_time(cliff))",
    "timestamp": "2025-08-13 02:35:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CliffClimbing {\n    private static final int[] DR = {-1, 0, 0}; // Up, Right, Left\n    private static final int[] DC = {0, 1, -1}; // Up, Right, Left\n\n    static class Point {\n        int r, c;\n        int time;\n\n        Point(int r, int c, int time) {\n            this.r = r;\n            this.c = c;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        char[][] cliff = {\n            {'5', '4', 'X', '3', 'T'},\n            {'X', '2', '3', 'X', 'X'},\n            {'S', '2', 'X', '1', '2'},\n        };\n\n        int minTime = calculateMinTime(cliff);\n        System.out.println(minTime);\n    }\n\n    public static int calculateMinTime(char[][] cliff) {\n        int rows = cliff.length;\n        int cols = cliff[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<Point> queue = new LinkedList<>();\n\n        // Find start position 'S'\n        for (int c = 0; c < cols; c++) {\n            if (cliff[rows - 1][c] == 'S') {\n                queue.add(new Point(rows - 1, c, 0));\n                visited[rows - 1][c] = true;\n                break;\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Point point = queue.poll();\n\n            // If 'T' is reached at the top row\n            if (point.r == 0 && cliff[point.r][point.c] == 'T') {\n                return point.time;\n            }\n\n            for (int d = 0; d < 3; d++) {\n                int nr = point.r + DR[d];\n                int nc = point.c + DC[d];\n\n                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && cliff[nr][nc] != 'X') {\n                    visited[nr][nc] = true;\n                    int additionalTime = cliff[nr][nc] == 'T' ? 0 : Character.getNumericValue(cliff[nr][nc]);\n                    queue.add(new Point(nr, nc, point.time + additionalTime));\n                }\n            }\n        }\n\n        return -1; // If 'T' is not reachable\n    }\n}",
    "timestamp": "2025-08-13 02:35:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 1000000\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n, m;\n    char cliff[MAX_ROWS][MAX_COLS];\n    int time[MAX_ROWS][MAX_COLS];\n    int dp[MAX_ROWS][MAX_COLS];\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", cliff[i]);\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (cliff[i][j] >= '1' && cliff[i][j] <= '9') {\n                time[i][j] = cliff[i][j] - '0';\n            } else {\n                time[i][j] = INF;\n            }\n            dp[i][j] = INF;\n        }\n    }\n    \n    for (int j = 0; j < m; j++) {\n        if (cliff[n - 1][j] == 'S') {\n            dp[n - 1][j] = time[n - 1][j];\n        }\n    }\n    \n    for (int i = n - 2; i >= 0; i--) {\n        for (int j = 0; j < m; j++) {\n            if (cliff[i][j] != 'X') {\n                if (j > 0 && cliff[i + 1][j - 1] != 'X') {\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + time[i][j]);\n                }\n                if (cliff[i + 1][j] != 'X') {\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + time[i][j]);\n                }\n                if (j < m - 1 && cliff[i + 1][j + 1] != 'X') {\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j + 1] + time[i][j]);\n                }\n            }\n        }\n    }\n    \n    int result = INF;\n    for (int j = 0; j < m; j++) {\n        if (cliff[0][j] == 'T') {\n            result = min(result, dp[0][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", result == INF ? -1 : result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 02:35:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_time_to_climb(cliff):\n    rows, cols = len(cliff), len(cliff[0])\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols and cliff[r][c] != 'X'\n    \n    start = None\n    target = None\n    \n    for r in range(rows):\n        for c in range(cols):\n            if cliff[r][c] == 'S':\n                start = (r, c)\n            if cliff[r][c] == 'T':\n                target = (r, c)\n    \n    queue = deque([(start[0], start[1], 0)])\n    visited = set([(start[0], start[1])])\n    \n    while queue:\n        r, c, time = queue.popleft()\n        \n        if (r, c) == target:\n            return time\n        \n        # Try moving right and left within 2 block range\n        for nc in [c-2, c-1, c+1, c+2]:\n            if is_valid(r+1, nc) and (r+1, nc) not in visited:\n                new_time = time + int(cliff[r+1][nc]) if cliff[r+1][nc] not in ['S', 'T', 'X'] else time\n                queue.append((r+1, nc, new_time))\n                visited.add((r+1, nc))\n    \n    return -1",
    "timestamp": "2025-08-13 02:35:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_time_to_cliff(cliff):\n    rows = len(cliff)\n    if rows == 0:\n        return -1\n    cols = len(cliff[0])\n    \n    # Find the starting positions (S) and target positions (T)\n    start_positions = []\n    target_positions = []\n    for i in range(rows):\n        for j in range(cols):\n            if cliff[i][j] == 'S':\n                start_positions.append((i, j))\n            elif cliff[i][j] == 'T':\n                target_positions.append((i, j))\n    \n    if not start_positions or not target_positions:\n        return -1\n    \n    # Priority queue: (time, row, col, left_foot, right_foot)\n    heap = []\n    visited = set()\n    \n    # Initialize the heap with all starting positions\n    for (i, j) in start_positions:\n        heapq.heappush(heap, (0, i, j, -1, -1))  # Initial foot positions are invalid\n    \n    # Directions: left and right\n    directions = [(0, -1), (0, 1)]\n    \n    while heap:\n        time, i, j, left_foot, right_foot = heapq.heappop(heap)\n        \n        if (i, j, left_foot, right_foot) in visited:\n            continue\n        visited.add((i, j, left_foot, right_foot))\n        \n        # Check if current position is a target\n        if cliff[i][j] == 'T':\n            return time\n        \n        # Explore left and right moves\n        for di, dj in directions:\n            ni, nj = i, j + dj\n            if 0 <= ni < rows and 0 <= nj < cols:\n                if cliff[ni][nj] == 'X':\n                    continue\n                \n                # Determine which foot is moving\n                if dj == -1:  # Moving left: left foot moves\n                    new_left_foot = nj\n                    new_right_foot = right_foot\n                else:  # Moving right: right foot moves\n                    new_left_foot = left_foot\n                    new_right_foot = nj\n                \n                # Check foot constraints\n                if new_left_foot != -1 and new_right_foot != -1:\n                    if abs(new_left_foot - new_right_foot) > 2:\n                        continue\n                \n                # Calculate new time\n                if cliff[ni][nj] == 'T':\n                    new_time = time\n                else:\n                    new_time = time + int(cliff[ni][nj])\n                \n                if (ni, nj, new_left_foot, new_right_foot) not in visited:\n                    heapq.heappush(heap, (new_time, ni, nj, new_left_foot, new_right_foot))\n    \n    return -1\n\n# Example usage:\n# cliff = [\n#     \"123\",\n#     \"SX4\",\n#     \"567\",\n#     \"T89\"\n# ]\n# print(min_time_to_cliff(cliff))",
    "timestamp": "2025-08-13 02:36:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Position {\n    int row;\n    int col;\n    int time;\n};\n\n// Directions: Down, Left, Right\nvector<pair<int, int>> directions = {{1, 0}, {0, -1}, {0, 1}};\n\nint minClimbTime(vector<string>& cliff) {\n    int rows = cliff.size();\n    int cols = cliff[0].length();\n    vector<vector<int>> minTime(rows, vector<int>(cols, INT_MAX));\n    queue<Position> q;\n\n    // Initialize the queue with starting positions\n    for (int col = 0; col < cols; ++col) {\n        if (cliff[0][col] == 'S') {\n            q.push({0, col, 0});\n            minTime[0][col] = 0;\n        }\n    }\n\n    // BFS to find the minimum time to reach any 'T'\n    while (!q.empty()) {\n        Position current = q.front();\n        q.pop();\n\n        for (auto& [dr, dc] : directions) {\n            int newRow = current.row + dr;\n            int newCol = current.col + dc;\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols &&\n                cliff[newRow][newCol] != 'X') {\n                int stepTime = cliff[newRow][newCol] - '0';\n                int newTime = current.time + stepTime;\n\n                if (newTime < minTime[newRow][newCol]) {\n                    minTime[newRow][newCol] = newTime;\n                    q.push({newRow, newCol, newTime});\n                }\n            }\n        }\n    }\n\n    // Find the minimum time to reach top row marked 'T'\n    int result = INT_MAX;\n    for (int col = 0; col < cols; ++col) {\n        if (cliff[rows - 1][col] == 'T') {\n            result = min(result, minTime[rows - 1][col]);\n        }\n    }\n\n    return result == INT_MAX ? -1 : result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> cliff(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cliff[i];\n    }\n\n    int minimumTime = minClimbTime(cliff);\n    cout << minimumTime << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:48"
  }
]