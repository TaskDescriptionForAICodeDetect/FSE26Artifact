[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint solve(int N, int K, int M, int* A) {\n    long long totalCount = 0;\n    \n    for (int start = 0; start <= N - M; start++) {\n        int* subsequence = malloc(K * sizeof(int));\n        int* seen = calloc(K + 1, sizeof(int));\n        int colorful = 0;\n        \n        for (int i = start; i < start + K; i++) {\n            if (seen[subsequence[i - start]] || subsequence[i - start] < 1 || subsequence[i - start] > K) {\n                colorful = 0;\n                break;\n            }\n            subsequence[i - start] = subsequence[i - start];\n            seen[subsequence[i - start]] = 1;\n        }\n        \n        if (colorful) {\n            int matchCount = 0;\n            for (int i = start; i <= N - M; i++) {\n                int match = 1;\n                for (int j = 0; j < M; j++) {\n                    if (A[j] != subsequence[i - start + j]) {\n                        match = 0;\n                        break;\n                    }\n                }\n                if (match) {\n                    matchCount++;\n                }\n            }\n            totalCount = (totalCount + matchCount) % MOD;\n        }\n        \n        free(subsequence);\n        free(seen);\n    }\n    \n    return (int)totalCount;\n}",
    "timestamp": "2025-08-05 23:04:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_K 20\n#define MAX_N 100000\n\nint N, K, M;\nint A[MAX_N];\nint dp[1 << MAX_K];\nint total = 0;\n\nvoid solve() {\n    int full_mask = (1 << K) - 1;\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n\n    int current_mask = 0;\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        int x = i % K + 1; // Generating the sequence 1, 2, ..., K, 1, 2, ..., K, ...\n        current_mask ^= (1 << (x - 1));\n\n        if (current_mask == full_mask) {\n            count++;\n            current_mask = 0;\n        }\n\n        if (i >= M - 1) {\n            int target_mask = 0;\n            int valid = 1;\n            for (int j = 0; j < M; j++) {\n                int pos = i - M + 1 + j;\n                int val = pos % K + 1;\n                if (val != A[j]) {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (valid) {\n                total = (total + dp[current_mask]) % MOD;\n            }\n        }\n\n        for (int m = current_mask; ; m = (m - 1) & current_mask) {\n            dp[m] = (dp[m] + dp[m ^ (1 << (x - 1))]) % MOD;\n            if (m == 0) break;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &K, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    solve();\n    printf(\"%d\\n\", total);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint solve(int N, int K, vector<int>& A) {\n    int M = A.size();\n    if (M > N) return 0;\n\n    unordered_map<int, int> freq;\n    int unique = 0;\n    int total = 0;\n\n    // Precompute the required pattern A's frequency map\n    unordered_map<int, int> target;\n    for (int num : A) {\n        target[num]++;\n    }\n    int target_unique = target.size();\n\n    // Sliding window to find all K-length colorful windows\n    vector<int> sequences;\n    unordered_map<int, int> window;\n    int left = 0;\n    int count = 0;\n\n    for (int right = 0; right < N; ++right) {\n        int num = right + 1; // Assuming the sequence is 1..N for the colorful condition\n        window[num]++;\n        if (window[num] == 1) {\n            count++;\n        }\n\n        while (right - left + 1 > K) {\n            int left_num = left + 1;\n            window[left_num]--;\n            if (window[left_num] == 0) {\n                count--;\n            }\n            left++;\n        }\n\n        if (right - left + 1 == K && count == K) {\n            sequences.push_back(left);\n        }\n    }\n\n    if (sequences.empty()) {\n        return 0;\n    }\n\n    // Now, for each colorful sequence, check how many times A appears\n    // We need to precompute the prefix hashes for the main sequence (1..N)\n    // But since the main sequence is 1..N, it's trivial, but A can be arbitrary\n    // So we need to find all occurrences of A in 1..N and sum those in colorful sequences\n\n    // Precompute prefix hashes for the main sequence (1..N)\n    const int P = 31;\n    vector<long long> p_pow(N + 1);\n    p_pow[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        p_pow[i] = (p_pow[i - 1] * P) % MOD;\n    }\n\n    vector<long long> h(N + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        h[i + 1] = (h[i] + (i + 1) * p_pow[i]) % MOD;\n    }\n\n    // Compute the hash of A\n    long long hash_A = 0;\n    for (int i = 0; i < M; ++i) {\n        hash_A = (hash_A + A[i] * p_pow[i]) % MOD;\n    }\n\n    // Find all starting positions where A occurs in 1..N\n    vector<int> occurrences;\n    for (int i = 0; i <= N - M; ++i) {\n        long long curr_hash = (h[i + M] - h[i] + MOD) % MOD;\n        if (curr_hash == (hash_A * p_pow[i]) % MOD) {\n            occurrences.push_back(i);\n        }\n    }\n\n    // For each occurrence, check if it's within any colorful sequence\n    for (int pos : occurrences) {\n        // Check if pos is within any of the sequences' left..left+K-M\n        for (int left : sequences) {\n            if (pos >= left && pos <= left + K - M) {\n                total++;\n                if (total >= MOD) total -= MOD;\n            }\n        }\n    }\n\n    return total;\n}",
    "timestamp": "2025-08-05 23:05:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ColorfulSequence {\n    private static final int MOD = 1_000_000_007;\n\n    public static int solve(int N, int K, int[] A) {\n        int M = A.length;\n        int total = 0;\n\n        // Precompute all possible sequences of length N\n        // Using backtracking to generate all possible sequences\n        List<int[]> sequences = new ArrayList<>();\n        generateSequences(sequences, new int[N], 0, N, K);\n\n        for (int[] seq : sequences) {\n            if (isColorful(seq, K)) {\n                total = (total + countSubsequences(seq, A)) % MOD;\n            }\n        }\n\n        return total;\n    }\n\n    private static void generateSequences(List<int[]> sequences, int[] current, int pos, int N, int K) {\n        if (pos == N) {\n            sequences.add(current.clone());\n            return;\n        }\n        for (int num = 1; num <= K; num++) {\n            current[pos] = num;\n            generateSequences(sequences, current, pos + 1, N, K);\n        }\n    }\n\n    private static boolean isColorful(int[] sequence, int K) {\n        for (int i = 0; i <= sequence.length - K; i++) {\n            Set<Integer> set = new HashSet<>();\n            boolean valid = true;\n            for (int j = i; j < i + K; j++) {\n                if (sequence[j] < 1 || sequence[j] > K || !set.add(sequence[j])) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid && set.size() == K) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int countSubsequences(int[] sequence, int[] A) {\n        int count = 0;\n        int M = A.length;\n        int N = sequence.length;\n        for (int i = 0; i <= N - M; i++) {\n            boolean match = true;\n            for (int j = 0; j < M; j++) {\n                if (sequence[i + j] != A[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[] A = new int[M];\n        for (int i = 0; i < M; i++) {\n            A[i] = scanner.nextInt();\n        }\n        System.out.println(solve(N, K, A));\n    }\n}",
    "timestamp": "2025-08-05 23:06:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int countColorfulSubsequences(int N, int K, int[] A) {\n        final int MOD = 1_000_000_007;\n        \n        // Create frequency array for the subsequence A\n        int[] freq = new int[K + 1];\n        for (int num : A) {\n            if (num <= K) freq[num]++;\n        }\n        \n        // Initial validation\n        for (int i = 1; i <= K; i++) {\n            if (freq[i] == 0) return 0;\n        }\n        \n        // Dynamic programming to track valid subsequences\n        long[][] dp = new long[N + 1][K + 1];\n        \n        // Initialize first column\n        for (int i = 0; i <= N; i++) {\n            dp[i][0] = 1;\n        }\n        \n        // Fill DP table\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= K; j++) {\n                dp[i][j] = dp[i-1][j];\n                \n                if (A[i-1] == j) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;\n                }\n            }\n        }\n        \n        // Compute final result\n        long result = 0;\n        for (int i = K; i <= N; i++) {\n            result = (result + dp[i][K]) % MOD;\n        }\n        \n        return (int) result;\n    }\n}",
    "timestamp": "2025-08-05 23:06:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int colorfulSubsequences(int N, int K, vector<int>& A) {\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> dp(N + 1, vector<int>(K + 1, 0));\n        \n        for (int i = 0; i < N; i++) {\n            vector<bool> seen(K + 1, false);\n            int distinct = 0;\n            \n            for (int j = i; j < N; j++) {\n                if (A[j] <= K) {\n                    if (!seen[A[j]]) {\n                        seen[A[j]] = true;\n                        distinct++;\n                    }\n                }\n                \n                if (distinct == K) {\n                    dp[j + 1][K]++;\n                }\n                \n                for (int k = 1; k < K; k++) {\n                    dp[j + 1][k] += dp[i][k];\n                }\n            }\n        }\n        \n        int result = 0;\n        for (int k = 1; k <= K; k++) {\n            result = (result + dp[N][k]) % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 23:06:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_colorful(subsequence, K):\n    return sorted(subsequence) == list(range(1, K + 1))\n\ndef count_matches(N, K, A, M, sequence):\n    match_count = 0\n    for i in range(N - K + 1):\n        if is_colorful(sequence[i:i + K], K):\n            for j in range(i, N - M + 1):\n                if sequence[j:j + M] == A:\n                    match_count += 1\n    return match_count\n\ndef count_colorful_sequences(N, K, A, M):\n    MOD = 10**9 + 7\n    total_count = 0\n    \n    def generate_sequences(curr_sequence):\n        nonlocal total_count\n        if len(curr_sequence) == N:\n            total_count += count_matches(N, K, A, M, curr_sequence) % MOD\n            return\n        \n        for num in range(1, K + 1):\n            generate_sequences(curr_sequence + [num])\n    \n    generate_sequences([])\n    \n    return total_count % MOD\n\n# Example Usage\nN = 5\nK = 3\nA = [1, 2]\nM = 2\nprint(count_colorful_sequences(N, K, A, M))  # Example Output",
    "timestamp": "2025-08-13 13:33:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ColorfulSubsequence {\n\n    private static final int MODULO = 1000000007;\n\n    public static int countSubsequences(int N, int K, int[] A, int[] sequence) {\n        int M = A.length;\n        int count = 0;\n\n        // Map to check against the subsequences\n        Map<Integer, Integer> targetMap = new HashMap<>();\n        for (int a : A) {\n            targetMap.put(a, targetMap.getOrDefault(a, 0) + 1);\n        }\n\n        // Slide window of length K over sequence of length N\n        for (int i = 0; i <= N - K; i++) {\n            Map<Integer, Integer> currentMap = new HashMap<>();\n            boolean isColorful = true;\n\n            // Check if the subsequence from i to i + K is colorful\n            for (int j = i; j < i + K; j++) {\n                int num = sequence[j];\n                currentMap.put(num, currentMap.getOrDefault(num, 0) + 1);\n                \n                // Check for validity as we are populating the map\n                if (currentMap.get(num) > 1 || num < 1 || num > K) {\n                    isColorful = false;\n                    break;\n                }\n            }\n\n            // Check if it's colorful and matches target sequence A\n            if (isColorful && currentMap.equals(targetMap)) {\n                count = (count + 1) % MODULO;\n            }\n        }\n\n        return count;\n    }\n}",
    "timestamp": "2025-08-13 13:33:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K, M;\n    scanf(\"%d %d %d\", &N, &K, &M);\n    int array[N], sequence[M];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &array[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &sequence[i]);\n    }\n\n    int count = 0;\n    for (int i = 0; i <= N - K; i++) {\n        int visited[K + 1];\n        memset(visited, 0, sizeof(visited));\n        int isColorful = 1;\n        for (int j = i; j < i + K; j++) {\n            if (array[j] > K || visited[array[j]]) {\n                isColorful = 0;\n                break;\n            }\n            visited[array[j]] = 1;\n        }\n        if (isColorful) {\n            for (int j = i; j <= N - M; j++) {\n                int matches = 1;\n                for (int k = 0; k < M; k++) {\n                    if (array[j + k] != sequence[k]) {\n                        matches = 0;\n                        break;\n                    }\n                }\n                if (matches) {\n                    count = (count + 1) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:33:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nbool isColorful(const vector<int>& sequence, int K) {\n    vector<int> count(K + 1, 0);\n    for (int num : sequence) {\n        if (num <= K) {\n            if (++count[num] > 1) return false;\n        }\n    }\n    for (int i = 1; i <= K; ++i) {\n        if (count[i] == 0) return false;\n    }\n    return true;\n}\n\nint countMatches(const vector<int>& colorful, const vector<int>& A) {\n    int N = colorful.size(), M = A.size();\n    int count = 0;\n    for (int i = 0; i <= N - M; ++i) {\n        if (equal(A.begin(), A.end(), colorful.begin() + i)) {\n            count = (count + 1) % MOD;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> K >> M;\n    vector<int> sequence(N), A(M);\n    for (int i = 0; i < N; ++i) cin >> sequence[i];\n    for (int i = 0; i < M; ++i) cin >> A[i];\n\n    int colorfulSubsequences = 0;\n    for (int i = 0; i <= N - K; ++i) {\n        vector<int> subseq(sequence.begin() + i, sequence.begin() + i + K);\n        if (isColorful(subseq, K)) {\n            colorfulSubsequences = (colorfulSubsequences + countMatches(subseq, A)) % MOD;\n        }\n    }\n    cout << colorfulSubsequences << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 13:33:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def countColorfulSubsequences(N, K, A):\n    MOD = 10**9 + 7\n    \n    def is_colorful(subseq):\n        return len(set(subseq)) == K and len(subseq) == K and set(subseq) == set(range(1, K+1))\n    \n    total_count = 0\n    \n    for start in range(N - K + 1):\n        window = []\n        for j in range(start, N):\n            window.append(A[j])\n            \n            if len(window) > K:\n                window.pop(0)\n            \n            if len(window) == K and is_colorful(window):\n                count = 0\n                for idx in range(N - len(A) + 1):\n                    if A[idx:idx+len(A)] == window:\n                        count += 1\n                total_count = (total_count + count) % MOD\n    \n    return total_count",
    "timestamp": "2025-08-13 13:33:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, K, M = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    if M > N:\n        print(0)\n        return\n    \n    # Precompute factorial, inverse factorial for combination calculations\n    max_n = N\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    # Total colorful sequences is K! * K^(N-K) * comb(N, K)\n    total_colorful = fact[K] * pow(K, N - K, MOD) % MOD * comb(N, K) % MOD\n    \n    if M > N:\n        print(0)\n        return\n    \n    # The number of sequences of length N that contain A exactly t times\n    # We need to compute sum_{S is colorful} count_A(S)\n    # Which is equal to sum_{t >= 1} t * (# of colorful S that contain A exactly t times)\n    \n    # The main idea is to use linearity of expectation, but here we compute it combinatorially.\n    \n    # The total is equal to the number of (S, i) where S is colorful and S starts A at position i.\n    # So for each possible starting position i (1 <= i <= N - M + 1), compute the number of S where:\n    # 1. S[i..i+M-1] = A\n    # 2. S is colorful\n    \n    # The answer is the sum over i of (# of S with S[i..i+M-1] = A and S is colorful)\n    \n    # For a fixed i, the number of such S is:\n    # If A itself is a permutation of 1..K (i.e., it contributes to the colorfulness), then:\n    # The rest of the sequence must contain another permutation of 1..K (since S must be colorful)\n    # Otherwise, the rest must contain at least one permutation of 1..K\n    \n    # So, first check if A is a permutation of 1..K\n    is_A_permu = (len(A) == K) and (sorted(A) == list(range(1, K+1)))\n    \n    total = 0\n    \n    # Precompute the number of colorful sequences of length L\n    # f[L] = K! * K^{L-K} * comb(L, K)\n    # But for L < K, f[L] = 0\n    def f(L):\n        if L < K:\n            return 0\n        return fact[K] * pow(K, L - K, MOD) % MOD * comb(L, K) % MOD\n    \n    # For each possible i (1-based to N-M+1)\n    for i in range(1, N - M + 2):\n        left_len = i - 1\n        right_len = N - (i + M - 1)\n        \n        # The total is f(left_len + right_len) if A is a permutation, but we have to subtract cases where the rest has no permutation\n        # The exact formula is complicated, but we can use inclusion-exclusion\n        \n        if is_A_permu:\n            # The rest can be anything, but S must be colorful. Since A is a permutation, S is colorful.\n            # So the number is K^{left_len + right_len} * comb(left_len + right_len, 0) ? No.\n            # The number is the total number of sequences where the fixed part is A, and the rest is arbitrary, but the whole sequence is colorful.\n            # Since A is a permutation, the whole sequence is colorful regardless of the rest.\n            # So the number is K^{left_len + right_len}\n            cnt = pow(K, left_len + right_len, MOD)\n        else:\n            # The number is (total colorful sequences of length left_len + right_len + M) where the fixed part is A.\n            # Which is equal to (number of sequences of length left_len + right_len that contain at least one permutation of 1..K)\n            # Which is K^{left_len + right_len} - (# sequences without any permutation of 1..K)\n            # The latter is g(left_len + right_len), where g(L) is the number of sequences of length L with no permutation of 1..K.\n            # g(L) = total sequences - f(L) = K^L - f(L)\n            # So the count is K^{left_len + right_len} - g(left_len + right_len) = f(left_len + right_len)\n            cnt = f(left_len + right_len)\n        \n        total = (total + cnt) % MOD\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 13:34:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countMatchingSubsequences(N, K, A, sequence) {\n  const MOD = 1e9 + 7;\n\n  function isColorful(subseq) {\n    const set = new Set(subseq.slice(0, K));\n    for (let i = 1; i <= K; i++) {\n      if (!set.has(i)) return false;\n    }\n    return true;\n  }\n\n  let count = 0;\n\n  for (let i = 0; i <= N - K; i++) {\n    const subseq = sequence.slice(i, i + K);\n    if (JSON.stringify(subseq) === JSON.stringify(A) && isColorful(subseq)) {\n      count++;\n    }\n  }\n\n  return count % MOD;\n}",
    "timestamp": "2025-08-13 13:34:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countColorfulSubsequences(N, K, A) {\n    const MOD = 1e9 + 7;\n    let totalCount = 0;\n\n    for (let start = 0; start <= N - K; start++) {\n        let isColorful = true;\n        let used = new Set();\n\n        for (let i = start; i < start + K; i++) {\n            if (used.has(A[i]) || A[i] < 1 || A[i] > K) {\n                isColorful = false;\n                break;\n            }\n            used.add(A[i]);\n        }\n\n        if (isColorful && used.size === K) {\n            let count = 0;\n            for (let j = 0; j <= N - A.length; j++) {\n                let match = true;\n                for (let k = 0; k < A.length; k++) {\n                    if (A[k] !== A[j + k]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) count++;\n            }\n            totalCount = (totalCount + count) % MOD;\n        }\n    }\n\n    return totalCount;\n}",
    "timestamp": "2025-08-13 13:34:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve(N, K, A) {\n    const M = A.length;\n    if (M > N) return 0;\n    \n    // Precompute factorial, inverse factorial for combinatorics\n    const maxN = Math.max(N, K);\n    const fact = new Array(maxN + 1).fill(1);\n    const invFact = new Array(maxN + 1).fill(1);\n    \n    for (let i = 2; i <= maxN; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    \n    invFact[maxN] = modInverse(fact[maxN], MOD);\n    for (let i = maxN - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n    \n    function comb(n, k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n    \n    // Check if A itself is a valid K-length colorful sequence\n    let isAValid = false;\n    if (A.length === K) {\n        const set = new Set(A);\n        if (set.size === K) {\n            let valid = true;\n            for (let i = 1; i <= K; i++) {\n                if (!set.has(i)) {\n                    valid = false;\n                    break;\n                }\n            }\n            isAValid = valid;\n        }\n    }\n    \n    // Total number of colorful sequences is K! * K^(N-K) * C(N-1, K-1)\n    const totalColorful = fact[K] * modPow(K, N - K, MOD) % MOD * comb(N - 1, K - 1) % MOD;\n    \n    if (!isAValid) {\n        // If A is not a valid K-length colorful sequence, then the answer is totalColorful * occurrences\n        // But occurrences is (N - M + 1) * (K^(N - M)) / (K^M)\n        // Simplified to (N - M + 1) * K^(N - 2M)\n        if (N < M) return 0;\n        const occurrences = (N - M + 1) * modPow(K, N - M, MOD) % MOD;\n        return totalColorful * occurrences % MOD;\n    } else {\n        // If A is a valid K-length colorful sequence, then it's part of the K-length sequences\n        // The total is (number of K-length sequences) * (number of A's in each) + other cases\n        const numKSequences = (N - K + 1) * modPow(K, N - K, MOD) % MOD;\n        const countInK = fact[K] * invFact[K] % MOD; // 1, since A is one permutation\n        const totalInK = numKSequences * countInK % MOD;\n        \n        // For sequences not containing A as the K-length sequence, same as before\n        const remainingColorful = (totalColorful - numKSequences + MOD) % MOD;\n        const occurrences = (N - M + 1 - 1) * modPow(K, N - M, MOD) % MOD;\n        const totalOther = remainingColorful * occurrences % MOD;\n        \n        return (totalInK + totalOther) % MOD;\n    }\n}\n\nfunction modPow(a, b, mod) {\n    let res = 1;\n    a = a % mod;\n    while (b > 0) {\n        if (b % 2 === 1) res = res * a % mod;\n        a = a * a % mod;\n        b = Math.floor(b / 2);\n    }\n    return res;\n}\n\nfunction modInverse(a, mod) {\n    return modPow(a, mod - 2, mod);\n}",
    "timestamp": "2025-08-13 13:35:05"
  }
]